{"completions": ["**Solution Explanation**\n\nWe only have to touch the first `n` elements of the input vector.  \nThe goal is to bring all negative numbers to the front **while keeping\nthe relative order inside the negative part and inside the positive part**.\nThis is exactly a *stable partition* of the first `n` elements.\n\nA straightforward way to keep stability is:\n\n1. Scan the first `n` elements once and push each negative value into a\n   temporary vector `neg`.\n2. Scan the same range once more and push each non\u2011negative value into\n   a temporary vector `pos`.\n3. Concatenate `neg` and `pos` and return the result.\n\nThe algorithm runs in `O(n)` time, uses `O(n)` extra space (the two\ntemporary vectors), and preserves the order of both groups.  \nIf `n` is larger than the size of the input vector, we simply treat the\nwhole vector as the first `n` elements.\n\nBelow is a clean C++ implementation that follows this idea.\n\n\n\n```cpp\n#include <vector>\n\n/*\n * Rearranges the first `n` elements of the given vector so that\n *   \u2013 all negative elements appear before all non\u2011negative elements,\n *   \u2013 relative order among negative elements is preserved,\n *   \u2013 relative order among non\u2011negative elements is preserved.\n *\n * If `n` is greater than the size of the vector, the whole vector is\n * considered as the first `n` elements.\n *\n * The function returns a new vector containing the rearranged values\n * (the original vector is left unchanged).\n */\nstd::vector<long> re_arrange_array(const std::vector<long>& arr, long n)\n{\n    // How many elements do we actually need to look at?\n    long len = static_cast<long>(arr.size());\n    if (n < 0) n = 0;                     // avoid negative sizes\n    if (n > len) n = len;                 // clamp to actual size\n\n    std::vector<long> neg;                // will hold negative values\n    std::vector<long> pos;                // will hold non\u2011negative values\n\n    // First pass: collect negatives\n    for (long i = 0; i < n; ++i) {\n        if (arr[i] < 0)\n            neg.push_back(arr[i]);\n    }\n\n    // Second pass: collect non\u2011negatives\n    for (long i = 0; i < n; ++i) {\n        if (arr[i] >= 0)\n            pos.push_back(arr[i]);\n    }\n\n    // Build the result: negatives first, then positives\n    std::vector<long> result;\n    result.reserve(neg.size() + pos.size());\n    result.insert(result.end(), neg.begin(), neg.end());\n    result.insert(result.end(), pos.begin(), pos.end());\n\n    // Append any remaining elements that were beyond the first `n`\n    if (n < len) {\n        result.insert(result.end(), arr.begin() + n, arr.end());\n    }\n\n    return result;\n}\n```\n\n### How It Works\n\n1. **Bounds handling** \u2013 We clamp `n` to the actual vector size to avoid\n   out\u2011of\u2011range accesses.  \n2. **Two\u2011pass stable collection** \u2013  \n   * First pass pushes every negative element into `neg`.  \n   * Second pass pushes every non\u2011negative element into `pos`.  \n   Because we scan in order, the relative order within each group is\n   naturally preserved.\n3. **Concatenation** \u2013 Copy `neg` and then `pos` into the result.  \n   If the original vector had elements beyond the first `n`, we copy\n   them unchanged at the end.\n4. **Return** \u2013 The original vector is untouched; the rearranged\n   version is returned.\n\n### Complexity\n\n- **Time**: `O(n)` \u2013 two linear scans over the first `n` elements.  \n- **Space**: `O(n)` \u2013 temporary vectors for negatives and positives.\n\nThis solution meets all the requirements: it keeps relative order,\nworks for any `n` within the vector bounds, and has clear,\nreadable code.", "**Solution Overview**\n\nThe task is to rearrange only the first `n` elements of the vector so that\n\n1. All negative elements appear before the positive elements.\n2. The relative order inside the negative group **and** inside the positive group must stay unchanged.  \n   (This is a *stable\u2011partition* problem.)\n\nWe can solve it in two simple passes:\n\n| Pass | How it works | Complexity |\n|------|--------------|------------|\n| 1 | Extract all negative numbers (keeping order) in a temporary vector, then overwrite the beginning of `arr` with these negatives. | `O(n)` |\n| 2 | Extract all non\u2011negative numbers (keeping order) in another temporary vector, then write them into `arr` after the negatives. | `O(n)` |\n\nBecause we only touch the first `n` elements, the rest of `arr` is left untouched.  \nMemory usage is `O(n)` for the temporary storage (you could do it in\u2011place with a more complex algorithm, but this is clear and fast).\n\n---\n\n### C++ Implementation\n\n```cpp\n#include <vector>\n#include <cstddef>   // for std::size_t\n#include <cassert>\n\n// Re-arrange only the first n elements of arr:\n//\n//   * all negative values appear first (keeping their relative order)\n//   * then all non\u2011negative values (also keeping order)\n//   * the remaining part of arr (indices >= n) is unchanged\n//\nstd::vector<long> re_arrange_array(std::vector<long> arr, long n)\n{\n    // Sanity check: n cannot exceed the vector length\n    assert(n <= static_cast<long>(arr.size()));\n\n    std::vector<long> negs;   // to store negatives\n    std::vector<long> pos;    // to store non\u2011negatives\n\n    // First pass: collect elements from the first n positions\n    for (long i = 0; i < n; ++i)\n    {\n        if (arr[i] < 0)\n            negs.push_back(arr[i]);   // keep order\n        else\n            pos.push_back(arr[i]);    // keep order\n    }\n\n    // Second pass: overwrite arr with negatives then positives\n    std::size_t idx = 0;\n    for (long v : negs) arr[idx++] = v;   // negatives first\n    for (long v : pos)  arr[idx++] = v;   // then positives\n\n    // Elements from index n onward are left untouched\n    return arr;\n}\n```\n\n### Complexity Analysis\n\n- **Time:**  \n  Two linear passes over the first `n` elements \u2192 `O(n)`.\n\n- **Space:**  \n  Two auxiliary vectors of size at most `n` \u2192 `O(n)` additional memory.  \n  (In\u2011place solutions exist but are more involved; this is typical for interview\u2011style problems.)\n\n---\n\n### Quick Test\n\n```cpp\nint main()\n{\n    std::vector<long> v = {1, -3, 4, -2, 5, -6, 7};\n    auto res = re_arrange_array(v, 5);   // rearrange first 5\n\n    // Expected: [-3, -2, 1, 4, 5, -6, 7]\n    for (auto x : res) std::cout << x << ' ';\n}\n```\n\nThe program prints: `-3 -2 1 4 5 -6 7`, satisfying the requirement.", "Here\u2019s a concise, **O(n)**\u2011time, **O(1)**\u2011in\u2011place solution that preserves the relative order of the negative and positive elements using a **stable partition** approach.\n\n```cpp\n#include <vector>\n#include <algorithm>   // for std::stable_partition\n\n// Rearranges the first `n` elements of `arr` so that\n// all negative elements come first, positives follow,\n// and the relative order within each group is preserved.\nstd::vector<long> re_arrange_array(std::vector<long> arr, long n) {\n    // Ensure we don't go past the vector size\n    n = std::min(n, static_cast<long>(arr.size()));\n\n    // Use std::stable_partition to keep relative order.\n    // The lambda returns true for negatives.\n    std::stable_partition(arr.begin(),\n                          arr.begin() + n,\n                          [](long x){ return x < 0; });\n\n    return arr;   // the vector is already modified in place\n}\n```\n\n### Why `std::stable_partition`?\n- **Stability**: Keeps the original order of negative numbers as well as of positive numbers.\n- **Complexity**: `O(n)` average time, `O(1)` additional memory (some implementations use a small buffer, but it's still considered constant).\n- **Readability**: Expresses the intention directly, making the code self\u2011explanatory.\n\nIf you need a manual implementation (e.g., for educational purposes or environments where `stable_partition` isn\u2019t available), see the optional implementation below:\n\n```cpp\nstd::vector<long> re_arrange_array_manual(std::vector<long> arr, long n) {\n    n = std::min(n, static_cast<long>(arr.size()));\n    std::vector<long> result(n);\n    long neg = 0, pos = 0;\n\n    for (long i = 0; i < n; ++i) {\n        if (arr[i] < 0)\n            result[neg++] = arr[i];\n        else\n            result[n - pos - 1] = arr[i]; // fill from the end\n    }\n\n    // Combine remaining elements\n    for (long i = n; i < arr.size(); ++i)\n        result.push_back(arr[i]);\n\n    return result;\n}\n```\n\nBut the first version using `std::stable_partition` is the preferred, production\u2011ready solution."]}
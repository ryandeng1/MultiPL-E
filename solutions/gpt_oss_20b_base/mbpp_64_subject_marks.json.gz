{"completions": ["Here\u2019s a concise implementation that returns the vector sorted by the **second** element (the mark) of each tuple.  \n(The first element \u2013 the subject name \u2013 is kept untouched.)\n\n```cpp\n#include <tuple>\n#include <vector>\n#include <string>\n#include <algorithm>   // std::sort\n\n// Sorts the vector of (subject, mark) tuples by the mark (second value).\nstd::vector<std::tuple<std::string, long>>\nsubject_marks(std::vector<std::tuple<std::string, long>> subjectmarks)\n{\n    // In\u2011place sort using a lambda that compares the second element of the tuples\n    std::sort(subjectmarks.begin(), subjectmarks.end(),\n              [](const std::tuple<std::string, long>& a,\n                 const std::tuple<std::string, long>& b)\n              {\n                  return std::get<1>(a) < std::get<1>(b);\n              });\n\n    return subjectmarks;          // return the sorted vector\n}\n```\n\n### Why this works\n\n* `std::sort` rearranges the elements in the range `[begin, end)` according to the supplied comparison function.\n* The lambda captures two tuples by reference and compares their second element (`std::get<1>(\u2026)`), effectively sorting by the marks.\n* Once sorted, the function simply returns the modified vector.\n\nYou can test it with:\n\n```cpp\nint main() {\n    std::vector<std::tuple<std::string, long>> data = {\n        {\"Math\", 80}, {\"Physics\", 90}, {\"Chemistry\", 70}\n    };\n\n    auto sorted = subject_marks(data);\n\n    for (auto const& [subj, mark] : sorted)\n        std::cout << subj << \" \" << mark << '\\n';\n}\n```\n\nOutput will be:\n\n```\nChemistry 70\nMath 80\nPhysics 90\n```\n\nFeel free to adjust the sort order (ascending vs. descending) by changing the comparison operator.", "Here\u2019s a complete, self\u2011contained C++ function that does exactly what you\u2019re asking for \u2013 it takes a vector of `std::tuple<std::string, long>` (a subject name followed by a mark) and returns the vector sorted **by the second element (the mark)** in ascending order.\n\n```cpp\n#include <vector>\n#include <tuple>\n#include <string>\n#include <algorithm>   // for std::sort\n\n// ---------------------------------------------------------------------------\n// subject_marks\n// ---------------------------------------------------------------------------\n//  Sorts the input vector of tuples using the *second* component of each\n//  tuple (i.e. the long mark).  The original order is preserved unless the\n//  marks are different, because std::sort is stable if we use a stable\n//  algorithm (std::stable_sort).  This function returns the sorted vector.\n// ---------------------------------------------------------------------------\nstd::vector<std::tuple<std::string, long>>\nsubject_marks(std::vector<std::tuple<std::string, long>> subjectmarks)\n{\n    // Use std::stable_sort to keep relative order among equal marks\n    std::stable_sort(\n        subjectmarks.begin(),\n        subjectmarks.end(),\n        [](const auto& a, const auto& b) {\n            return std::get<1>(a) < std::get<1>(b);   // compare marks (second element)\n        });\n\n    return subjectmarks;\n}\n```\n\n### How it works\n\n| Step | Explanation |\n|------|-------------|\n| **1.** `std::stable_sort` is called on the vector\u2019s range. | `stable_sort` guarantees that ties (equal marks) keep their relative order, which is often useful in teaching benchmarks. |\n| **2.** A *lambda comparator* `[](const auto& a, const auto& b) { \u2026 }` is supplied. | The lambda receives two tuples and compares the second element (`std::get<1>`) of each. |\n| **3.** The sorted vector is returned. | Since the function accepts a *copy* of the input vector by value, we can sort it in place and return the result without modifying the caller\u2019s original vector. |\n\n### Usage example\n\n```cpp\nint main() {\n    std::vector<std::tuple<std::string, long>> data = {\n        {\"Math\", 88},\n        {\"Physics\", 95},\n        {\"Chemistry\", 78},\n        {\"Biology\", 95}\n    };\n\n    auto sorted = subject_marks(data);\n\n    for (const auto& t : sorted) {\n        std::cout << std::get<0>(t) << \": \" << std::get<1>(t) << '\\n';\n    }\n}\n```\n\nOutput:\n```\nChemistry: 78\nMath: 88\nPhysics: 95\nBiology: 95\n```\n\nFeel free to adjust the comparison operator (`<`, `>` or a custom comparator) if you need descending order or a different sorting criterion.", "Here\u2019s a small, self\u2011contained function that does exactly what you asked for: it takes a vector of pairs (actually `std::tuple<std::string,long>` \u2013 a subject name and a mark), sorts the vector **in\u2011place** by the second element (the mark), and then returns the sorted vector.\n\n```cpp\n#include <tuple>\n#include <vector>\n#include <algorithm>\n#include <string>\n\n/*  Sort a vector of tuples by the second element of each tuple\n *  subjectmarks  \u2013  vector of std::tuple<std::string,long>\n *  Returns the sorted vector (the input vector is modified in\u2011place)\n */\nstd::vector<std::tuple<std::string, long>>\nsubject_marks(std::vector<std::tuple<std::string, long>> subjectmarks)\n{\n    // Helper: lambda that compares two tuples by their second element\n    auto cmp_by_second = [](const auto& a, const auto& b)\n    {\n        return std::get<1>(a) < std::get<1>(b);\n    };\n\n    // Perform the sort\n    std::sort(subjectmarks.begin(), subjectmarks.end(), cmp_by_second);\n\n    return subjectmarks;\n}\n```\n\n### How it works\n\n1. **Lambda comparator** \u2013 `cmp_by_second` extracts the second element of each tuple (`std::get<1>(a)`) and compares them using `<`.  \n2. **`std::sort`** \u2013 Sorts the entire vector in ascending order of the marks.  \n3. The sorted vector is returned.  \n   - If you want descending order, just change the comparator to `return std::get<1>(a) > std::get<1>(b);`.\n\n### Example usage\n\n```cpp\nint main() {\n    std::vector<std::tuple<std::string, long>> marks{\n        {\"Math\", 92},\n        {\"Physics\", 85},\n        {\"Chemistry\", 78}\n    };\n\n    auto sorted = subject_marks(marks);\n\n    for (const auto& t : sorted) {\n        std::cout << std::get<0>(t) << \": \" << std::get<1>(t) << '\\n';\n    }\n}\n```\n\nOutput:\n\n```\nChemistry: 78\nPhysics: 85\nMath: 92\n```\n\nFeel free to adjust the comparator or change the sorting order as needed!"]}
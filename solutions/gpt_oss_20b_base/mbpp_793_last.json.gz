{"completions": ["Here is a compact, **O(log\u202fn)** implementation that works on a sorted vector of `long`s.  \nIt returns the *zero\u2011based* index of the **last** occurrence of `x` (or `-1` if `x` is not present).\n\n```cpp\n#include <vector>\n#include <algorithm>   // for std::upper_bound\n\n// Return last index of x in a sorted vector arr,\n// or \u20131 if x does not occur.\nlong last(const std::vector<long>& arr, long x)\n{\n    // upper_bound gives iterator *to the first element > x*.\n    auto it = std::upper_bound(arr.begin(), arr.end(), x);\n\n    if (it == arr.begin())          // all elements > x  => x not present\n        return -1;\n\n    --it;                            // step back to the last \u2264 x\n\n    if (*it != x)                    // ensure it actually equals x\n        return -1;\n\n    return static_cast<long>(it - arr.begin());\n}\n```\n\n### Why this works\n\n| Step | What it does | Why it works |\n|------|--------------|--------------|\n| `upper_bound` | Finds first element > `x` | Binary search on sorted range, `O(log n)` |\n| `--it` | Move one element back | Points to the last element \u2264 `x` |\n| `*it != x` | Check if this element equals `x` | If not, `x` never appeared |\n| `it - arr.begin()` | Convert iterator to index | Standard iterator arithmetic |\n\nThe algorithm is stable for any sorted container (unique or with duplicates). It handles empty vectors and all edge cases correctly.", "Below is a compact, well\u2011commented C++17 implementation that returns the **last** (i.e. right\u2011most) position of a given value\u202f`x` in a sorted vector `arr`.  \nIf the value is not found it returns `-1`.  \nThe implementation uses binary search (log\u202fn time) and works for any sorted order (ascending or descending) by detecting the order first.\n\n```cpp\n#include <vector>\n#include <cstddef>   // for std::size_t\n#include <cassert>   // for assert\n\n/**\n * @brief   Find the last (right\u2011most) index of x in a sorted vector.\n *\n * @param   arr  A sorted vector (ascending or descending).  The vector is\n *               passed by reference to avoid copying.\n * @param   x    The value to search for.\n *\n * @return  The index of the last occurrence of x, or -1 if x is not in arr.\n *\n * @note    The function works in O(log n) time.  It handles both\n *          ascending and descending sorted vectors.\n */\nlong last(const std::vector<long>& arr, long x)\n{\n    if (arr.empty())\n        return -1;\n\n    std::size_t lo = 0;\n    std::size_t hi = arr.size() - 1;\n    long result = -1;\n\n    // Detect whether the vector is sorted ascending or descending.\n    const bool ascending = arr[hi] >= arr[lo];\n\n    while (lo <= hi) {\n        std::size_t mid = lo + (hi - lo) / 2;\n\n        if (arr[mid] == x) {\n            result = static_cast<long>(mid);   // remember this match\n            // Continue searching to the right for a later occurrence\n            if (ascending)\n                lo = mid + 1;   // skip left part\n            else\n                hi = mid - 1;   // skip right part\n        }\n        else {\n            if (ascending) {\n                if (arr[mid] < x)\n                    lo = mid + 1;\n                else\n                    hi = mid - 1;\n            } else {  // descending\n                if (arr[mid] < x)\n                    hi = mid - 1;\n                else\n                    lo = mid + 1;\n            }\n        }\n    }\n\n    return result;\n}\n\n/* ---------- Example usage ---------- */\n#include <iostream>\n\nint main()\n{\n    std::vector<long> v1 = {1, 2, 2, 3, 5, 5, 7};\n    std::cout << \"Last position of 5: \" << last(v1, 5) << '\\n'; // 5\n\n    std::vector<long> v2 = {9, 8, 8, 7, 5, 3, 1};\n    std::cout << \"Last position of 8: \" << last(v2, 8) << '\\n'; // 2\n\n    std::cout << \"Last position of 4: \" << last(v1, 4) << '\\n'; // -1\n\n    return 0;\n}\n```\n\n**Explanation of the algorithm**\n\n1. **Determine order** \u2013 Compare the first and last elements to know whether the vector is sorted ascending or descending.\n2. **Binary search** \u2013 Use the usual binary\u2011search loop.\n   * When the middle element equals `x`, record the index (`result`) and *continue* searching on the right side (or left side for descending order). This guarantees that the right\u2011most occurrence will be found.\n   * If the middle element is not `x`, move the search window (`lo`/`hi`) depending on the order and the relative value of `arr[mid]` and `x`.\n3. The loop ends when `lo > hi`; `result` already holds the last position or remains `-1` if `x` was never found.\n\nThe function is `O(log n)` in time and `O(1)` in additional space.", "Below is a compact, self\u2011contained C++ function that returns the **last** (right\u2011most) index of a value `x` in a sorted `std::vector<long>`.  \nIf `x` is not present the function returns `-1`.\n\n```cpp\n#include <vector>\n\n/*  last\n *  --------\n *  Parameters:\n *    arr - sorted vector of long (non\u2011decreasing order).\n *    x   - value to search for.\n *\n *  Returns:\n *    Index (0\u2011based) of the last occurrence of x.\n *    If x is not present, returns -1.\n */\nlong last(const std::vector<long>& arr, long x)\n{\n    long lo = 0, hi = static_cast<long>(arr.size()) - 1;\n    long ans = -1;                // will store the position of the last occurrence\n\n    while (lo <= hi)\n    {\n        long mid = lo + (hi - lo) / 2;   // avoid overflow\n\n        if (arr[mid] == x) {\n            ans = mid;          // record a match \u2013 it might still be right\u2011most\n            lo = mid + 1;       // keep searching to the right\n        }\n        else if (arr[mid] < x) {\n            lo = mid + 1;  // x must be on the right\n        }\n        else {                  // arr[mid] > x\n            hi = mid - 1;  // x must be on the left\n        }\n    }\n\n    return ans;\n}\n```\n\n### How it works\n1. **Binary Search** \u2013 The vector is sorted, so we use a classic binary\u2011search loop.  \n2. **Capture the last position** \u2013 Whenever we find `arr[mid] == x` we store `mid` in `ans` and *continue* the search on the right half (`lo = mid + 1`). This guarantees that when the loop terminates, `ans` holds the position of the *last* occurrence.  \n3. **Return value** \u2013 `-1` is returned when the value is absent.  \n\n### Example usage\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> v = {1, 2, 4, 4, 4, 7, 9};\n    std::cout << last(v, 4) << '\\n';   // prints 4\n    std::cout << last(v, 5) << '\\n';   // prints -1\n    return 0;\n}\n```\n\nFeel free to drop this snippet into your project \u2013 it\u2019s header\u2011only and runs in **O(log\u202fn)** time."]}
{"completions": ["Below is a **Python** function that returns the highest power of\u202f2 that is less than or equal to a given integer `n`.  \nI\u2019ve also added a few helper tests and a short explanation of the algorithm.\n\n```python\ndef highest_power_of_2(n: int) -> int:\n    \"\"\"\n    Return the greatest power of 2 that is <= n.\n\n    Parameters\n    ----------\n    n : int\n        Positive integer (n >= 1).  For n <= 0 the function\n        returns 0 because no positive power of 2 satisfies\n        the inequality.\n\n    Returns\n    -------\n    int\n        2**k where k is the largest integer such that 2**k <= n.\n    \"\"\"\n    if n < 1:\n        return 0  # undefined for non\u2011positive n\n\n    # Method 1 (bit\u2011wise trick): shift 1 left until the\n    # result would exceed n, then step one shift back.\n    power = 1\n    while power <= n:\n        power <<= 1           # same as power *= 2\n    # power has just overflowed (or become > n), so step back\n    return power >> 1\n\n# ------------------------------------------------------------\n# Quick sanity checks\n# ------------------------------------------------------------\nif __name__ == \"__main__\":\n    test_cases = [\n        (1, 1),\n        (2, 2),\n        (3, 2),\n        (4, 4),\n        (5, 4),\n        (7, 4),\n        (8, 8),\n        (9, 8),\n        (15, 8),\n        (16, 16),\n        (31, 16),\n        (63, 32),\n        (64, 64),\n        (100, 64),\n        (1023, 512),\n        (1024, 1024),\n        (12345, 8192),\n    ]\n\n    for n, expected in test_cases:\n        assert highest_power_of_2(n) == expected, f\"n={n}\"\n    print(\"All tests passed!\")\n```\n\n### How it works\n\n1. **Bit\u2011shifting**  \n   `1 << k` is the same as `2**k`.  \n   We keep left\u2011shifting the value `1` (doubling it) until it exceeds `n`.\n\n2. **Undo the overflow**  \n   The loop stops with `power` being the first value *greater* than `n`.  \n   Shifting it right once (`power >> 1`) gives the previous value, which is the desired power of\u202f2.\n\n### Alternatives\n\n- **Using logarithm**  \n  `int(math.log2(n))` gives the exponent `k`, then `1 << k`.\n\n- **Built\u2011in function (Python\u202f3.10+)**  \n  `int.bit_length()` returns the number of bits needed to represent `n`.  \n  The result is `1 << (n.bit_length() - 1)`.\n\nThe bit\u2011shifting method is simple, fast, and doesn\u2019t require any imports.", "Below is a **fully\u2011self\u2011contained C++\u202f17** snippet that implements the requested function:\n\n```cpp\n#include <cassert>\n#include <cstdint>\n#include <iostream>\n\n/**\n * @brief   Return the largest power of two that does not exceed `n`.\n *\n * This function works for all `n >= 1`.  \n * For `n == 0` the function returns 0 (no positive power of two \u2264 0).\n *\n * We use the fact that `1ULL << k` is the `k`\u2011th power of two.\n * Starting from the most significant bit of `n` we shift until we\n * find the highest set bit and return its corresponding power of two.\n *\n * Complexity: O(log n) \u2013 at most 64 iterations on a 64\u2011bit\n * integer.  Constant\u2011time on most CPUs as this is a simple\n * bit\u2011scan operation.\n *\n * @param n unsigned integer for which we want the highest 2\u2011power\n * @return   largest 2^k such that 2^k <= n\n */\nstatic inline unsigned long long highestPowerOf2(unsigned long long n)\n{\n    if (n == 0) return 0;          // edge case: no positive power of two \u2264 0\n\n    // Find the position of the most significant set bit (0\u2011indexed).\n    // `__builtin_clzll` counts the leading zeros, so the bit index\n    // is: 63 - __builtin_clzll(n)\n    int msbPos = 63 - __builtin_clzll(n);\n\n    // Shift 1 left by that position: 1ULL << msbPos\n    return 1ULL << msbPos;\n}\n\n/* Example usage & quick sanity\u2011checks */\nint main()\n{\n    assert(highestPowerOf2(1) == 1);\n    assert(highestPowerOf2(2) == 2);\n    assert(highestPowerOf2(3) == 2);\n    assert(highestPowerOf2(4) == 4);\n    assert(highestPowerOf2(5) == 4);\n    assert(highestPowerOf2(6) == 4);\n    assert(highestPowerOf2(7) == 4);\n    assert(highestPowerOf2(8) == 8);\n    assert(highestPowerOf2(1000) == 512);\n    assert(highestPowerOf2(0) == 0);\n\n    std::cout << \"All tests passed.\\n\";\n    return 0;\n}\n```\n\n### What the function does\n\n1. **Edge case** \u2013 If `n == 0`, there is no positive power of two \u2264 0, so we return `0`.\n2. **Most significant bit (MSB)** \u2013 Using GCC/Clang\u2019s built\u2011in `__builtin_clzll`, we find the index of the highest set bit of `n`.  \n   For a 64\u2011bit value, `msbPos = 63 - __builtin_clzll(n)`.\n3. **Return the power** \u2013 A single `1` shifted left by `msbPos` yields the desired power of two (`1ULL << msbPos`).\n\n### Why this is optimal\n\n* **Time** \u2013 The function performs a constant amount of work for any 64\u2011bit integer.\n* **Space** \u2013 No extra memory beyond a few registers.\n* **Portability** \u2013 Only standard headers and GCC/Clang built\u2011ins are used; it will also compile with MSVC if you replace the builtin with a loop.\n\nFeel free to drop this function into your project and call `highestPowerOf2(n)` whenever you need the largest power of two not exceeding `n`.", "Below is a compact, fully\u2011commented Python implementation that returns the largest power of\u202f2\u202fthat is\u202f\u2264\u202f**n**.  \nThe code works for any non\u2011negative integer **n** (including `0`) and is written with clarity in mind.\n\n```python\ndef highest_power_of_2(n: int) -> int:\n    \"\"\"\n    Return the greatest power of two that is <= n.\n    \n    Parameters\n    ----------\n    n : int\n        A non\u2011negative integer. If n < 1, the function returns 0.\n    \n    Returns\n    -------\n    int\n        2**k where k is the largest integer such that 2**k <= n.\n    \n    Examples\n    --------\n    >>> highest_power_of_2(1)\n    1\n    >>> highest_power_of_2(5)\n    4\n    >>> highest_power_of_2(16)\n    16\n    >>> highest_power_of_2(0)\n    0\n    \"\"\"\n    # Edge case: n == 0 -> 0 (or you may decide to raise ValueError)\n    if n < 1:\n        return 0\n\n    # Python\u2019s int type is arbitrary precision, so we can safely shift.\n    # The trick is to find the position of the highest set bit.\n    # This corresponds to floor(log2(n)).\n    k = n.bit_length() - 1          # highest bit index (0\u2011based)\n    return 1 << k                   # 2 ** k\n```\n\n### How It Works\n\n1. **Edge case** \u2013 If `n` is less than 1, no positive power of two fits, so we return `0`.  \n2. **Bit length trick** \u2013  \n   `int.bit_length()` returns the number of bits needed to represent the number in binary, excluding the sign and leading zeros.  \n   For a number\u202f`n`, the highest set bit position is `bit_length - 1`.  \n3. **Shift to get the power** \u2013 `1 << k` is equivalent to `2 ** k`, which is the required power of two.\n\n### Why This Is Efficient\n\n- The operation is *O(1)* in time \u2013 just a few arithmetic operations, regardless of how big **n** is.  \n- It uses only constant extra space.  \n- It works for arbitrarily large integers thanks to Python\u2019s unlimited\u2011precision `int`.\n\nFeel free to adapt the function for other languages (e.g., C/C++), where the same logic can be implemented using built\u2011in bit\u2011twiddling functions such as `__builtin_clzll` or by looping with shifts."]}
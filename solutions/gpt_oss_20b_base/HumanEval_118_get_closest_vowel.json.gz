{"completions": ["**Answer**\n\n```cpp\n#include <string>\n\nbool isVowel(char c) {\n    const char *vowels = \"aeiouAEIOU\";\n    return std::string(vowels).find(c) != std::string::npos;\n}\n\nstd::string get_closest_vowel(std::string word)\n{\n    if (word.size() < 3)          // need at least one char with two neighbours\n        return \"\";\n\n    // scan from right to left\n    for (std::size_t i = word.size() - 2; i >= 1; --i) {\n        char cur = word[i];\n        if (!isVowel(cur))                // must be a vowel\n            continue;\n\n        char left = word[i - 1];\n        char right = word[i + 1];\n\n        if (isVowel(left) || isVowel(right))\n            continue;                    // not surrounded by consonants\n\n        // inside the word, left and right are consonants\n        return std::string(1, cur);\n    }\n\n    return \"\";\n}\n```\n\n**Explanation**\n\n1. `isVowel` checks whether a character is one of `aeiouAEIOU`.  \n2. If the word has fewer than 3 characters there can\u2019t be a vowel surrounded by two consonants.  \n3. We iterate **from right to left** (`for` loop starting at `size-2` and ending at `1`) so the first suitable vowel we hit is the *closest to the right*.  \n4. For each position `i`:\n   * it must be a vowel,\n   * the left (`i-1`) and right (`i+1`) neighbours must **not** be vowels (consonants),\n   * it must not be the very first or last character of the word (guaranteed by the loop bounds).  \n5. When the conditions hold we return that vowel as a one\u2011character string.  \n6. If we finish the loop with no match, we return an empty string.", "**Solution Outline**\n\nWe need to return the *first* vowel that\n\n* is **not** the first or the last character  \n* has a consonant immediately to its left and to its right  \n\nand we must search **from right to left** \u2013 i.e. we want the *closest* vowel to the right end of the word.  \nIf no such vowel exists the function must return an empty string.\n\nThe word contains only English letters, so we can simply treat every character\nwith `isalpha`.  \nThe set of vowels is `{a, e, i, o, u, A, E, I, O, U}`.  \nAll other alphabetic characters are consonants.\n\n**Algorithm**\n\n```\n1. Let n = word.length()\n2. If n < 3 \u2192 return \"\"  (no possible vowel between two letters)\n3. For i from n-2 down to 1   (i.e. from right\u2013most inner character to the left)\n      if word[i] is a vowel\n          if word[i-1] is a consonant  AND  word[i+1] is a consonant\n                return string(1, word[i])   // single\u2011char string\n4. Return \"\"   // no vowel satisfies the condition\n```\n\nThe inner loop examines at most `n\u22122` positions, thus the algorithm runs\nin `O(n)` time and uses `O(1)` auxiliary space.\n\n\n\n**C++17 Implementation**\n\n```cpp\n#include <string>\n#include <cctype>\n\nstd::string get_closest_vowel(std::string word)\n{\n    const std::string vowels = \"aeiouAEIOU\";\n    const size_t n = word.size();\n\n    // Need at least 3 characters to have a vowel between two others\n    if (n < 3) return \"\";\n\n    // Helper lambda: test if a character is a vowel\n    auto isVowel = [&](char c) -> bool {\n        return vowels.find(c) != std::string::npos;\n    };\n\n    // Scan from right to left (starting at n-2 so we never touch the last char)\n    for (int i = static_cast<int>(n) - 2; i >= 1; --i) {\n        char cur = word[i];\n        if (!isVowel(cur)) continue;        // skip consonants\n\n        char left  = word[i - 1];\n        char right = word[i + 1];\n\n        // left and right must be alphabetic and *not* vowels -> consonants\n        if (isVowel(left) || isVowel(right)) continue; // at least one side is a vowel\n\n        // both sides are consonants, return this vowel\n        return std::string(1, cur);\n    }\n\n    // No vowel satisfies the pattern\n    return \"\";\n}\n```\n\n**Explanation of key parts**\n\n* `isVowel` uses `find` on a constant string of vowels \u2013 fast enough for\n  this small alphabet set.\n* We iterate **downwards** from `n-2` to `1` to guarantee we return the\n  vowel closest to the right end.\n* At each position we check that both neighbouring characters are consonants\n  (i.e., they are alphabetic and not vowels).  \n  The problem statement guarantees the input contains only English letters,\n  so `isalpha` isn\u2019t strictly needed; we simply check against vowels.\n\n**Complexity**\n\n*Time* \u2013 O(n)  \n*Space* \u2013 O(1) (apart from the small constant\u2010size string of vowels)\n\nThis implementation follows the specified behaviour and passes the provided examples.", "**Solution Explanation**\n\nWe must find the *closest* vowel that satisfies\n\n* it lies between two consonants,\n* it is **not** the first or last character of the word,\n* the search proceeds from right to left (so the \u201cclosest\u201d is the first one we\n  encounter in that direction).\n\nThe word contains only English letters and the function must be case\u2011sensitive.\nIf no such vowel exists, we return an empty string.\n\n\n\n--------------------------------------------------------------------\n\n### Algorithm\n```\n1. If word length < 3 => return \"\"          // no room for vowel with two neighbours\n\n2. Define helper:\n      isConsonant(ch) = isalpha(ch) AND ch NOT IN {'a','e','i','o','u','A','E','I','O','U'}\n\n3. Iterate i from word.length()-2 down to 1  (skip first and last char)\n      ch = word[i]\n      If ch is a vowel (i.e. not a consonant):\n          If isConsonant(word[i-1]) AND isConsonant(word[i+1]):\n                 return string(1,ch)   // closest vowel found\n\n4. Return \"\"  // none found\n```\n\n--------------------------------------------------------------------\n\n### Correctness Proof  \n\nWe prove that the algorithm returns the desired vowel or an empty string.\n\n*Let `W` be the input word, `n` its length.*\n\n**Lemma 1**  \nDuring the scan, every examined position `i` satisfies `1 \u2264 i \u2264 n-2`; thus the\ncharacter at `i` is neither the first nor the last character of `W`.\n\n*Proof.*  \nThe loop starts at `n-2` and decrements until `1`. So all indices are inside that\nrange. \u220e\n\n**Lemma 2**  \nIf the algorithm returns a character `c` at position `i`, then `c` is a vowel\nbetween two consonants.\n\n*Proof.*  \nThe return occurs only when  \n`!isConsonant(c)` \u2192 `c` is a vowel, and  \n`isConsonant(W[i-1])` and `isConsonant(W[i+1])` \u2192 adjacent letters are consonants.  \nBy Lemma&nbsp;1, `c` is not at the ends. Thus all conditions hold. \u220e\n\n**Lemma 3**  \nIf a vowel fulfilling the requirement exists, the algorithm returns the one\nclosest to the right end of the word.\n\n*Proof.*  \nThe scan processes indices in strictly decreasing order: `n-2, n-3, \u2026, 1`.  \nThe first position `i` where the condition holds therefore has the largest\nindex among all such positions, i.e. it is the rightmost (closest from the right)\ncandidate. The algorithm returns immediately, so the returned vowel is exactly\nthat one. \u220e\n\n**Theorem**  \n`get_closest_vowel` returns  \n* the closest (from the right) vowel that lies between two consonants and is not\n  at either end, or  \n* an empty string if no such vowel exists.\n\n*Proof.*  \nIf the function returns a character, Lemma&nbsp;2 guarantees that it satisfies\nall conditions and Lemma&nbsp;3 shows it is the rightmost such vowel.  \nIf the function falls through the loop, no index met the condition, hence no\nvowel satisfies all requirements. Therefore the empty string is correct. \u220e\n\n--------------------------------------------------------------------\n\n### Complexity Analysis\n\nThe word is scanned once from right to left:  \n*Time* \u2013 **O(n)**, where *n* is the word length.  \n*Space* \u2013 **O(1)**, only a few variables are used.\n\n--------------------------------------------------------------------\n\n### Reference Implementation (C++17)\n\n```cpp\n#include <cctype>\n#include <string>\n\nbool isConsonant(char ch)\n{\n    if (!std::isalpha(static_cast<unsigned char>(ch))) return false;\n    switch (ch) {\n        case 'a': case 'e': case 'i': case 'o': case 'u':\n        case 'A': case 'E': case 'I': case 'O': case 'U':\n            return false;\n        default:\n            return true;\n    }\n}\n\nstd::string get_closest_vowel(std::string word)\n{\n    const int n = static_cast<int>(word.size());\n    if (n < 3) return \"\";               // no room for a vowel with two neighbours\n\n    for (int i = n - 2; i >= 1; --i) {   // skip first and last character\n        char ch = word[i];\n        if (!isConsonant(ch)) {          // ch is a vowel\n            if (isConsonant(word[i - 1]) && isConsonant(word[i + 1])) {\n                return std::string(1, ch);   // closest vowel found\n            }\n        }\n    }\n    return \"\";                            // none found\n}\n```\n\nThe code follows exactly the algorithm proven correct above and is fully\nconformant with the C++17 standard."]}
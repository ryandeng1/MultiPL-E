{"completions": ["Here\u2019s one clean, **O(n\u202flog\u202fn)** implementation that follows the spirit of the \u201cmerge\u2011three\u2011sorted\u2011lists\u201d problem you mentioned, but it also works if the input vectors are not already sorted.  \nIf you *do* know the three input vectors are already sorted, you can replace the call to `std::sort` with a linear\u2011time \u201cthree\u2011way merge\u201d (see the optional bonus section below).\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n\n/* --------------------------------------------------------------------\n *  merge_sorted_list\n *\n *  @brief  Merge three vectors into a single sorted vector.\n *  @note   This implementation first concatenates the three input\n *          vectors, then sorts the combined vector.  This is the most\n *          straightforward solution and guarantees O(n log n) time\n *          complexity, where n is the total number of elements.\n *\n *  @param  num1  First vector of long values (can be empty).\n *  @param  num2  Second vector of long values.\n *  @param  num3  Third vector of long values.\n *  @return      A vector containing all elements from the three\n *               input vectors, sorted in non\u2011decreasing order.\n * --------------------------------------------------------------------*/\nstd::vector<long> merge_sorted_list(std::vector<long> num1,\n                                    std::vector<long> num2,\n                                    std::vector<long> num3)\n{\n    // --- 1. Combine all elements ------------------------------------\n    std::vector<long> result;\n    result.reserve(num1.size() + num2.size() + num3.size()); // reserve to avoid reallocs\n\n    result.insert(result.end(), num1.begin(), num1.end());\n    result.insert(result.end(), num2.begin(), num2.end());\n    result.insert(result.end(), num3.begin(), num3.end());\n\n    // --- 2. Sort the combined vector --------------------------------\n    std::sort(result.begin(), result.end());\n\n    return result;\n}\n\n/* --------------------------------------------------------------------\n *  Optional: Three\u2011way merge when input vectors are already sorted\n *\n *  If you are certain that `num1`, `num2`, and `num3` are sorted,\n *  you can instead do a linear\u2011time merge:\n *\n *  std::vector<long> fast_merge_sorted_list(const std::vector<long>& a,\n *                                           const std::vector<long>& b,\n *                                           const std::vector<long>& c)\n *  {\n *      std::vector<long> out;\n *      out.reserve(a.size() + b.size() + c.size());\n *\n *      std::size_t i = 0, j = 0, k = 0;\n *      while (i < a.size() || j < b.size() || k < c.size()) {\n *          long va = (i < a.size()) ? a[i] : LLONG_MAX;\n *          long vb = (j < b.size()) ? b[j] : LLONG_MAX;\n *          long vc = (k < c.size()) ? c[k] : LLONG_MAX;\n *\n *          if (va <= vb && va <= vc) { out.push_back(va); ++i; }\n *          else if (vb <= va && vb <= vc) { out.push_back(vb); ++j; }\n *          else { out.push_back(vc); ++k; }\n *      }\n *\n *      return out;\n *  }\n *\n *  This eliminates the O(n\u202flog\u202fn) sort step and runs in O(n)\n *  where n is the total length of all three vectors.\n *  --------------------------------------------------------------------*/\n\nint main()\n{\n    std::vector<long> a{5, 13, 20, 35};\n    std::vector<long> b{3, 8, 15, 28, 42};\n    std::vector<long> c{2, 7, 11, 30};\n\n    auto merged = merge_sorted_list(a, b, c);\n\n    // Verify that the result is indeed sorted\n    assert(std::is_sorted(merged.begin(), merged.end()));\n\n    // Print the merged vector\n    for (long x : merged) std::cout << x << ' ';\n    std::cout << '\\n';\n\n    return 0;\n}\n```\n\n### What the code does\n\n1. **Reserve space** for the final vector to avoid repeated reallocations\u2014performance\u2011friendly.\n2. **Concatenate** all three input vectors into a single vector.\n3. **Sort** the concatenated vector using `std::sort`, giving a simple, reliable solution.\n\n### Complexity\n\n*Time:* `O((n\u2081 + n\u2082 + n\u2083) log (n\u2081 + n\u2082 + n\u2083))`  \n*Space:* `O(n\u2081 + n\u2082 + n\u2083)` (the additional vector that holds the result).\n\nIf you know the three input vectors are already sorted, switching to the *fast merge* routine above gives you linear\u2011time complexity while still leveraging the same logic structure.", "Here\u2019s a ready\u2011to\u2011drop implementation for the function `merge_sorted_list`.  \nIt assumes that the three input vectors are already sorted; if they aren\u2019t, the\nresult will still be correct because we use the same merging logic as with any\ntwo sorted arrays, but you should sort them first if that invariant isn\u2019t\nguaranteed.\n\n```cpp\n#include <vector>\n#include <algorithm>\n\n// ---------------------------------------------------------------------------\n// Merge three sorted vectors into a single sorted vector.\n// ---------------------------------------------------------------------------\nstd::vector<long> merge_sorted_list(const std::vector<long>& num1,\n                                    const std::vector<long>& num2,\n                                    const std::vector<long>& num3)\n{\n    // Result capacity: sum of lengths to avoid reallocations.\n    std::vector<long> result;\n    result.reserve(num1.size() + num2.size() + num3.size());\n\n    // Indices into each input vector.\n    std::size_t i = 0, j = 0, k = 0;\n\n    // While at least one vector still has elements left.\n    while (i < num1.size() || j < num2.size() || k < num3.size())\n    {\n        // Choose the smallest among the current elements of the three vectors.\n        // For each vector that is already exhausted, give it a sentinel value\n        // that is larger than any possible element (LLONG_MAX works for `long`).\n        const long a = (i < num1.size() ? num1[i] : LLONG_MAX);\n        const long b = (j < num2.size() ? num2[j] : LLONG_MAX);\n        const long c = (k < num3.size() ? num3[k] : LLONG_MAX);\n\n        // Pick the minimum of a, b, c.\n        if (a <= b && a <= c) {\n            result.push_back(a);\n            ++i;\n        } else if (b <= a && b <= c) {\n            result.push_back(b);\n            ++j;\n        } else {\n            result.push_back(c);\n            ++k;\n        }\n    }\n\n    return result;\n}\n```\n\n### How it works\n1. **Reserve space** \u2013 we reserve the total size at the beginning to avoid\n   repeated reallocations.\n2. **Three indices** \u2013 one for each input vector.\n3. **Main loop** \u2013 repeats until every vector is exhausted.  \n   Within each iteration we:\n   - Determine the current element from each vector (or `LLONG_MAX` if that\n     vector has been fully consumed).\n   - Append the smallest element to `result` and advance the corresponding index.\n\n### Complexity\n- **Time**:\u202f`O(n1 + n2 + n3)` \u2013 each element is visited once.\n- **Space**:\u202f`O(n1 + n2 + n3)` \u2013 for the resulting merged vector.\n\n### Usage\n\n```cpp\nint main()\n{\n    std::vector<long> a = {1, 4, 9};\n    std::vector<long> b = {2, 5, 8, 10};\n    std::vector<long> c = {3, 6, 7};\n\n    auto merged = merge_sorted_list(a, b, c);\n\n    for (auto x : merged) std::cout << x << ' ';\n    // Output: 1 2 3 4 5 6 7 8 9 10\n}\n```\n\nFeel free to adapt the sentinel value or the function signature to your particular coding style or constraints!", "```cpp\n#include <vector>\n#include <algorithm>\n\n/*  Merge three already\u2011sorted vectors into one sorted vector.\n *\n *  Parameters\n *  ----------\n *  num1, num2, num3 : const std::vector<long>&\n *      Three vectors that are each sorted in non\u2011decreasing order.\n *\n *  Returns\n *  -------\n *  std::vector<long>\n *      A new vector containing all elements from `num1`, `num2` and `num3`,\n *      sorted in non\u2011decreasing order.\n *\n *  Complexity\n *  ----------\n *  O(n1 + n2 + n3) time, where n1, n2, n3 are the sizes of the input\n *  vectors.  Uses O(n1 + n2 + n3) additional space for the result.\n */\nstd::vector<long> merge_sorted_list(const std::vector<long>& num1,\n                                    const std::vector<long>& num2,\n                                    const std::vector<long>& num3)\n{\n    // Result container \u2013 size is the sum of sizes of the three inputs\n    std::vector<long> result;\n    result.reserve(num1.size() + num2.size() + num3.size());\n\n    // Three pointers/cursors into the three vectors\n    auto it1 = num1.begin();\n    auto it2 = num2.begin();\n    auto it3 = num3.begin();\n\n    // Continue while at least one iterator has not reached the end\n    while (it1 != num1.end() || it2 != num2.end() || it3 != num3.end())\n    {\n        // Smallest element among the current items (if any)\n        long min_val;         // placeholder for the smallest value\n        bool taken = false;   // flag to remember which iterator provided it\n\n        if (it1 != num1.end() &&\n            (!taken || *it1 <= min_val))\n        {\n            min_val = *it1;\n            taken = true;\n        }\n        if (it2 != num2.end() &&\n            (!taken || *it2 <= min_val))\n        {\n            min_val = *it2;\n            taken = true;\n        }\n        if (it3 != num3.end() &&\n            (!taken || *it3 <= min_val))\n        {\n            min_val = *it3;\n            taken = true;\n        }\n\n        // Append the smallest element\n        result.push_back(min_val);\n\n        // Advance the iterator that produced the value\n        if (it1 != num1.end() && *it1 == min_val) ++it1;\n        else if (it2 != num2.end() && *it2 == min_val) ++it2;\n        else if (it3 != num3.end() && *it3 == min_val) ++it3;\n    }\n\n    return result;\n}\n```\n\n### How it works\n\n1. **Reserve the result capacity** \u2013 this keeps the algorithm at linear time.\n2. **Three iterators** keep track of our current position in each input vector.\n3. In the loop we pick the smallest of the three current elements (skipping any that are already exhausted).\n4. Push that value into `result` and advance the iterator that yielded it.\n5. Repeat until all three iterators have reached the end.\n\nThe function runs in \\(O(n_1 + n_2 + n_3)\\) time and uses only the output vector as additional memory."]}
{"completions": ["Below is a **C++** (I\u2019ll call it \u201ccppthon\u201d as you mentioned) implementation that finds the element that appears only once in a **sorted** `std::vector<long>`.  \nBecause the vector is sorted, the unique element can be found in **O(log\u202fn)** time by a binary\u2011search\u2013style approach:\n\n```cpp\n#include <vector>\n#include <stdexcept>\n#include <iostream>\n\n/*  Finds the single element in a sorted vector of longs\n *  Each element except one occurs exactly twice.\n *  Complexity: O(log n)        (binary\u2013search)\n *  Pre\u2011condition: arr.size() is odd\n */\nlong search(const std::vector<long>& arr)\n{\n    if (arr.empty()) {\n        throw std::invalid_argument(\"empty array\");\n    }\n    if (arr.size() % 2 == 0) {\n        throw std::invalid_argument(\"array size must be odd\");\n    }\n\n    long left = 0;\n    long right = static_cast<long>(arr.size()) - 1;\n\n    while (left < right) {\n        long mid = left + (right - left) / 2;\n\n        /* Because the array is sorted, the unique element\n         * will break the pairing pattern.\n         *\n         * If mid is even and arr[mid] == arr[mid+1] => unique is right\n         * If mid is odd  and arr[mid] == arr[mid-1] => unique is right\n         * Otherwise unique is left\n         */\n        if ( (mid % 2 == 0 && arr[mid] == arr[mid+1]) ||\n             (mid % 2 == 1 && arr[mid] == arr[mid-1]) )\n        {\n            left = mid + 1;                // search right half\n        } else {\n            right = mid;                    // search left half (incl. mid)\n        }\n    }\n    // left == right , single element found\n    return arr[left];\n}\n```\n\n### How it works  \n\n| Step | Condition | Why it moves `left` / `right` |\n|------|-----------|--------------------------------|\n| 1 | `mid` even and `arr[mid]==arr[mid+1]` | From the beginning to `mid` the pairs are normal, so the single element lies to the right. |\n| 2 | `mid` odd and `arr[mid]==arr[mid-1]` | Same reasoning as above, the single element lies to the right. |\n| 3 | otherwise | The symmetry is broken to the left, so the single element is in the left half (including `mid`). |\n\nBecause the unique element is the only element without a duplicate, the test above correctly narrows the search interval until only one element remains.\n\n### Example\n\n```cpp\nint main() {\n    std::vector<long> a = {1,1,2,2,3,3,4,5,5};\n    std::cout << search(a) << '\\n';   // prints 4\n}\n```\n\nThis function runs in logarithmic time and uses only O(1) additional memory, making it efficient even for large sorted vectors.", "Below is a **self\u2011contained, ready\u2011to\u2011compile** C++17 snippet that shows a function\n`search` which, given a **sorted** `std::vector<long>` that contains **exactly one element\nthat occurs only once** (all other elements occur exactly twice),\nreturns that unique element in **O(log\u202fn)** time.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cassert>\n\n/*\n * Find the element that appears only once in a sorted vector\n * where every other element appears exactly twice.\n *\n * The algorithm is a binary\u2011search variant that relies on the fact\n * that before the unique element the pair indices are (even,odd),\n * and after the unique element they are (odd,even).\n */\nlong search(const std::vector<long>& arr) {\n    int left  = 0;\n    int right = static_cast<int>(arr.size()) - 1;\n\n    // Edge cases: single element or unique element at one of the ends\n    if (left == right)                  // only one element\n        return arr[left];\n    if (arr[left] != arr[left + 1])     // unique is the first\n        return arr[left];\n    if (arr[right] != arr[right - 1])   // unique is the last\n        return arr[right];\n\n    // Binary search\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n\n        // Make sure mid is the first index of a pair\n        if (mid % 2 == 1) \n            mid--;          // even index -> start of a pair\n\n        if (arr[mid] == arr[mid + 1]) {\n            // Pair is intact -> unique is on the right half\n            left = mid + 2;\n        } else {\n            // Pair is broken -> unique is on the left half (including mid)\n            right = mid - 1;\n        }\n    }\n\n    // At this point left is exactly at the unique index\n    return arr[left];\n}\n\n/* -------------------- Testing -------------------- */\nint main() {\n    std::vector<long> v1 = {1,1,2,2,3,4,4,5,5};   // unique = 3\n    std::vector<long> v2 = {10,10,20,30,30,40,40}; // unique = 20\n    std::vector<long> v3 = {7};                    // single element\n    std::vector<long> v4 = {8,8,9,9,10};           // unique = 10\n\n    assert(search(v1) == 3);\n    assert(search(v2) == 20);\n    assert(search(v3) == 7);\n    assert(search(v4) == 10);\n\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\n### How it works\n\n1. **Observation**  \n   - In a sorted array where all elements except one appear twice, the pairs are aligned:\n     - Before the unique element: pair indices are `(0,1), (2,3), \u2026` \u2013 each pair starts\n       at an **even** index.\n     - After the unique element: pair indices are `(1,2), (3,4), \u2026` \u2013 each pair starts\n       at an **odd** index.\n\n2. **Binary Search**  \n   - Start with normal `left` / `right` pointers.\n   - Pick `mid`. If it's odd, decrement it to make sure we\u2019re at the **first index of a pair**.\n   - Compare `arr[mid]` with `arr[mid+1]`:\n     * If they are equal, the pair is intact \u2192 the unique element is **right** of this pair.\n     * If they differ, the pair is broken \u2192 the unique element is **left** of or at this `mid`.\n   - Narrow the interval accordingly until `left` points to the unique element.\n\n3. **Edge Cases**  \n   - Unique element could be the very first or last item (handled early).\n   - Array could contain only one element (also handled early).\n\nThe algorithm runs in `O(log\u202fn)` time, uses `O(1)` extra space, and requires only the sorted property.", "Here\u2019s a clean C++ implementation that searches a **sorted** vector for the unique element (the one that appears only once).  \nThe function runs in **O(log\u202fn)** time by using binary search\u2011like logic.\n\n```cpp\n#include <vector>\n#include <stdexcept>\n\n// Returns the element that appears exactly once in a sorted vector.\n// The vector must contain exactly one such element; otherwise an exception is thrown.\n// Complexity: O(log n),  Space: O(1)\nlong findUnique(const std::vector<long>& arr)\n{\n    if (arr.empty())\n        throw std::invalid_argument(\"Empty array\");\n\n    int left = 0, right = static_cast<int>(arr.size()) - 1;\n\n    while (left <= right)\n    {\n        int mid = left + (right - left) / 2;\n\n        /* 3 cases to consider:\n         *\n         * 1) mid is at the unique element\u2019s index\n         * 2) mid belongs to a pair that starts at even index (left pair)\n         * 3) mid belongs to a pair that starts at odd index  (right pair)\n         */\n\n        // Check if mid itself is unique\n        bool leftNeighbor  = (mid > 0   &&  arr[mid] == arr[mid-1]);\n        bool rightNeighbor = (mid < (int)arr.size()-1 && arr[mid] == arr[mid+1]);\n\n        if (!leftNeighbor && !rightNeighbor)          // case 1\n            return arr[mid];\n\n        // Now, mid is part of a pair\n        // Determine whether the pair starts at even or odd index\n        // The pair's first element\u2019s index parity shows where the unique element must be.\n        if ((mid % 2 == 0 && leftNeighbor) || (mid % 2 == 1 && rightNeighbor))\n        {\n            // Pair starts at even index \u2192 unique is to the right\n            left = mid + 1;\n        }\n        else\n        {\n            // Pair starts at odd index \u2192 unique is to the left\n            right = mid - 1;\n        }\n    }\n\n    throw std::logic_error(\"No unique element found\");\n}\n```\n\n### How it works\n\n1. **Binary search style loop** \u2013 We keep a `left` and `right` pointer.\n2. **Identify the pair** \u2013 By comparing the middle element with its neighbors we know whether it is part of a pair.\n3. **Decide direction** \u2013  \n   - If the pair starts at an **even** index (`mid` is the first element of the pair), everything to the left of `mid` is perfectly paired; the unique element must be on the **right**.  \n   - If the pair starts at an **odd** index, the unique element lies on the **left**.\n4. The loop converges in `O(log n)` iterations and returns the unique element.\n\n### Example\n\n```cpp\nint main() {\n    std::vector<long> v = {1,1,2,2,3,4,4,5,5};\n    long ans = findUnique(v);   // ans == 3\n    std::cout << ans << '\\n';\n}\n```\n\nThe function handles any sorted vector containing exactly one element that appears once, while all other elements appear exactly twice. If the input does not satisfy this guarantee, an exception is thrown."]}
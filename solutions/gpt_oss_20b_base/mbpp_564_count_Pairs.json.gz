{"completions": ["**Answer:**\n\nThe function must take a vector of integers and return the number of *unordered* pairs `(i , j)` (`i < j`) whose values are different.  \nThe obvious way is to look at every pair, but that would be **O(n\u00b2)**.  \nWe can do it in **O(n)** by using the fact that the total number of unordered pairs is\n\n```\ntotalPairs = n * (n-1) / 2\n```\n\nIf two elements are equal we must subtract the number of pairs that have that same value.  \nIf a value appears `cnt` times it contributes\n\n```\ncnt * (cnt-1) / 2\n```\n\nto the \u201cbad\u201d (equal) pairs.  \nSo the answer is\n\n```\ntotalPairs \u2013 \u03a3  cnt*(cnt-1)/2   (sum over all distinct values)\n```\n\n--------------------------------------------------------------------\n\n```cpp\n#include <vector>\n#include <unordered_map>\n\n/* Count unordered pairs of indices (i , j) , i < j,\n   such that arr[i] != arr[j].  Complexity: O(n). */\nlong long count_Pairs(const std::vector<long long>& arr)\n{\n    long long n = arr.size();\n    if (n < 2) return 0;\n\n    // 1. Find frequencies of all numbers\n    std::unordered_map<long long,long long> freq;\n    for (auto v : arr) ++freq[v];\n\n    // 2. Total number of unordered pairs\n    long long totalPairs = n * (n - 1) / 2;\n\n    // 3. Subtract pairs that contain equal numbers\n    long long equalPairs = 0;\n    for (const auto& kv : freq)\n    {\n        long long c = kv.second;\n        equalPairs += c * (c - 1) / 2;\n    }\n\n    return totalPairs - equalPairs;\n}\n```\n\n**Explanation of the code**\n\n| Line | What it does |\n|------|--------------|\n| `for (auto v : arr) ++freq[v];` | Counts how many times each number appears. |\n| `long long totalPairs = n * (n - 1) / 2;` | Computes `C(n,2)` \u2013 all unordered pairs. |\n| The second loop | Adds the number of pairs that have identical elements for each distinct value (`C(cnt,2)`). |\n| `return totalPairs - equalPairs;` | The required answer. |\n\nThe function runs in **O(n)** time and uses **O(k)** extra space (`k` = number of distinct values). It works for any 64\u2011bit integer values in the vector.", "Below is a self\u2011contained, **C++17** implementation of the requested function.  \nThe routine receives a vector of integers (`arr`) and its size (`n`) and returns the number of unordered pairs \\((i,j)\\) such that `arr[i] != arr[j]`.\n\n```cpp\n//  count_pairs.cpp\n//  C++17 implementation of count_Pairs\n//  Counts unordered pairs of unequal elements in a vector.\n\n#include <vector>\n#include <unordered_map>\n#include <cstddef>   // for std::size_t\n#include <cstdint>   // for int64_t\n\n/**\n * @brief   Count the number of unordered pairs (i, j) with i < j,\n *          such that arr[i] != arr[j].\n *\n * @param   arr  Input vector of integers.\n * @param   n    Number of elements in the vector. (Can also be arr.size())\n *\n * @return  The number of unordered unequal pairs.\n */\nlong long count_Pairs(const std::vector<long long>& arr, long long n)\n{\n    if (n <= 1) return 0;          // no pairs possible\n\n    // 1. Count how many times each distinct value occurs.\n    std::unordered_map<long long, long long> freq;\n    freq.reserve(static_cast<std::size_t>(n * 2)); // avoid rehashing\n    for (const auto& x : arr) {\n        ++freq[x];\n    }\n\n    // 2. Total number of unordered pairs: C(n, 2) = n*(n-1)/2\n    long long total_pairs = n * (n - 1) / 2;\n\n    // 3. Subtract the pairs where both elements are equal.\n    long long equal_pairs = 0;\n    for (const auto& [value, cnt] : freq) {\n        if (cnt > 1) {\n            equal_pairs += cnt * (cnt - 1) / 2;   // C(cnt, 2)\n        }\n    }\n\n    // 4. Unequal pairs = total pairs \u2013 equal pairs\n    return total_pairs - equal_pairs;\n}\n\n/* ---------- Test / Example usage ---------- */\n#if 0   // Change to 1 to compile the test harness\n#include <iostream>\n\nint main() {\n    std::vector<long long> v = {1, 2, 3, 1, 2};\n    long long n = static_cast<long long>(v.size());\n\n    std::cout << \"Unequal pairs: \" << count_Pairs(v, n) << std::endl;\n    return 0;\n}\n#endif\n```\n\n### How it works\n\n1. **Frequency table** \u2013 Count how many times each distinct integer occurs (hash table).\n2. **Total unordered pairs** \u2013 `C(n,2) = n*(n-1)/2`.\n3. **Subtract equal\u2011value pairs** \u2013 For every value that appears `cnt` times add `C(cnt,2)` to `equal_pairs`.\n4. **Result** \u2013 `total_pairs - equal_pairs`.\n\nThe algorithm runs in \\(O(n)\\) time and uses \\(O(k)\\) extra space, where \\(k\\) is the number of distinct values (`k \u2264 n`). This satisfies the typical constraints for such a counting problem.", "Here is a clean C++ implementation (no *cppthon* \u2013 the function is written in plain C++ but you can call it from a Python wrapper if you wish).  \nIt receives a `std::vector<long>` and returns the number of unordered pairs **(i , j)** with \\(i<j\\) and `arr[i] != arr[j]`.\n\n```cpp\n#include <vector>\n#include <unordered_map>\n\n/**\n * Count unordered pairs of distinct values in a vector.\n *\n * @param arr the input vector of numbers\n * @return the number of unordered pairs (i, j) with i < j and arr[i] != arr[j]\n */\nlong long count_Pairs(const std::vector<long long>& arr) {\n    const long long n = static_cast<long long>(arr.size());\n    if (n < 2) return 0;                       // no pairs possible\n\n    // Map to count occurrences of each value\n    std::unordered_map<long long, long long> freq;\n    for (long long v : arr) {\n        ++freq[v];\n    }\n\n    // Total unordered pairs = n choose 2\n    long long total_pairs = n * (n - 1) / 2;\n\n    // Subtract pairs that have equal elements\n    long long equal_pairs = 0;\n    for (const auto& p : freq) {\n        long long cnt = p.second;              // how many times this value occurs\n        equal_pairs += cnt * (cnt - 1) / 2;    // choose 2 among the `cnt`\n    }\n\n    return total_pairs - equal_pairs;\n}\n```\n\n### How it works\n\n1. **Frequency table** \u2013 We count how many times each distinct value occurs.\n2. **Total pairs** \u2013 The number of unordered pairs in a set of `n` items is \\( \\binom{n}{2} = n(n-1)/2 \\).\n3. **Subtract equal pairs** \u2013 For each value that appears `cnt` times, it contributes \\( \\binom{cnt}{2} \\) pairs that are *not* counted because the two elements are equal.\n4. **Result** \u2013 `total_pairs - equal_pairs` gives the number of unordered pairs with *different* elements.\n\n### Example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long long> v = {1, 2, 1, 3};\n    std::cout << count_Pairs(v) << '\\n';   // outputs 5\n}\n```\n\nPairs:  \n- (0,1): 1\u22602  \n- (0,2): 1=1 \u2192 not counted  \n- (0,3): 1\u22603  \n- (1,2): 2\u22601  \n- (1,3): 2\u22603  \n- (2,3): 1\u22603  \nSo 5 unordered pairs with unequal elements.\n\nFeel free to adapt the function for other integer types or to use it in a Python environment via `pybind11` or similar."]}
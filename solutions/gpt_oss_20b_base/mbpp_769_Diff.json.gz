{"completions": ["Below is a small, self\u2011contained **C++** routine that returns the *set\u2011difference* of two `std::vector<long>` objects \u2013 i.e. the elements that live in the first vector (`li1`) but **not** in the second (`li2`).  \nThe implementation is safe, O(n\u202flog\u202fn) (`unordered_set` makes it O(n) on average) and works for negative or duplicate values because we keep the multiplicity of the first vector while discarding any element that appears at least once in the second one.\n\n```cpp\n#include <vector>\n#include <unordered_set>\n#include <algorithm>\n\n//------------------------------------------------------------------\n//  Diff\n//------------------------------------------------------------------\n// Return the set\u2011difference li1 \\ li2.\n// Elements from li1 that also appear in li2 are omitted.\n// Duplicates in li1 are preserved (multiset\u2011like behaviour).\n//\nstd::vector<long> Diff(const std::vector<long>& li1,\n                       const std::vector<long>& li2)\n{\n    // Put all elements from li2 into a hash set for O(1) look\u2011ups.\n    std::unordered_set<long> bad;\n    bad.reserve(li2.size());\n    for (const auto& x : li2) bad.emplace(x);\n\n    // Build result while skipping elements that are in li2.\n    std::vector<long> result;\n    result.reserve(li1.size());               // max possible size\n    for (const auto& x : li1) {\n        if (bad.find(x) == bad.end()) result.emplace_back(x);\n    }\n    return result;\n}\n```\n\n### How it works\n\n| Step | What happens | Complexity |\n|------|--------------|------------|\n| 1 | Insert every element of `li2` into an `unordered_set` (`bad`). | **O(m)** (`m = li2.size()`) |\n| 2 | Iterate over `li1`. For each element, check whether it is *not* in `bad`; if not, push it into `result`. | **O(n)** (`n = li1.size()`)|\n| 3 | Return the resulting vector. | \u2013 |\n\nThe overall time complexity is **O(n + m)** and the extra space is `O(m)` for the hash set.\n\n### Example\n\n```cpp\nint main() {\n    std::vector<long> a{1, 2, 3, 4, 4, 5};\n    std::vector<long> b{2, 4};\n\n    auto c = Diff(a, b);          // c == {1,3,5}\n    for (auto v : c) std::cout << v << ' ';\n    // Output: 1 3 5\n}\n```\n\nFeel free to adapt the function to use `std::set` instead of `unordered_set` if you prefer sorted unique elements; the core idea remains the same.", "Below is a short, self\u2011contained C++ example that shows how to get the difference between two vectors.  \nThe function returns a vector that contains **all elements that are present in the first vector (`li1`) but not in the second vector (`li2`)** (multiset difference).  \nIt works for any integral element type (here `long`), and it keeps the order that the elements appear in `li1`.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\n// ---------------------------------------------------------------------------\n// Return the multiset difference li1 \\ li2 :  Li1 minus Li2. \n// Elements that appear in li1 but not in li2 are kept, preserving order.\n// ---------------------------------------------------------------------------\nstd::vector<long> Diff(const std::vector<long>& li1,\n                       const std::vector<long>& li2)\n{\n    // Count the occurrences of each value in li2.\n    std::unordered_map<long,long> counts;\n    for (auto v : li2) ++counts[v];\n\n    std::vector<long> result;\n    result.reserve(li1.size());      // avoid many reallocations\n\n    for (auto v : li1)\n    {\n        auto it = counts.find(v);\n        if (it == counts.end() || it->second == 0) {\n            // value not in li2 or already consumed\n            result.push_back(v);\n        } else {\n            // one occurrence of this value is removed\n            --it->second;\n        }\n    }\n    return result;\n}\n\n// ---------------------------------------------------------------------------\n// Helper to pretty\u2011print a vector\n// ---------------------------------------------------------------------------\ntemplate <typename T>\nvoid printVec(const std::vector<T>& v)\n{\n    std::cout << \"[\";\n    for (size_t i = 0; i < v.size(); ++i)\n    {\n        if (i) std::cout << \", \";\n        std::cout << v[i];\n    }\n    std::cout << \"]\\n\";\n}\n\n// ---------------------------------------------------------------------------\n// Demo\n// ---------------------------------------------------------------------------\nint main()\n{\n    std::vector<long> a{1, 2, 3, 4, 3, 5, 6};\n    std::vector<long> b{2, 3, 7};\n\n    std::vector<long> diff = Diff(a, b);\n\n    std::cout << \"a     = \"; printVec(a);\n    std::cout << \"b     = \"; printVec(b);\n    std::cout << \"a\\\\b   = \"; printVec(diff);\n\n    return 0;\n}\n```\n\n### How it works\n1. **Count in `li2`** \u2013 We build a hash map (`unordered_map`) that stores how many times each element occurs in the second vector.\n2. **Traverse `li1`** \u2013 For each element in the first vector:\n   * If it does **not** appear in `li2` **or** all occurrences have already been \u201cused\u201d, we keep it in the result.\n   * Otherwise, we decrement the counter for that value, effectively \u201cremoving\u201d one occurrence.\n3. The resulting vector contains the multiset difference, preserving the original ordering of elements from `li1`.\n\nFeel free to adapt the code to other types (e.g., `int`, `std::string`) just by changing the template type.", "Below is a compact, self\u2011contained C++ implementation that returns the element\u2011wise difference between two integer vectors.  \nIt is written in a \u201ccpp\u2011thon\u201d style \u2013 concise, uses the C++ standard library, and is fully commented so you can drop it straight into your project.\n\n```cpp\n#include <vector>\n#include <algorithm>   // for std::transform\n#include <cassert>     // for assert\n#include <iostream>    // for demo (remove in production)\n\n/*\n * Diff\n * ----\n * Compute the difference list of two integer vectors:\n *\n *   result[i] = li1[i] - li2[i],  for all i < min(li1.size(), li2.size())\n *\n * If one vector is longer, the remaining elements are taken \u201cas\u2011is\u201d.\n *\n * Example:\n *   li1 = {5, 7, 9}\n *   li2 = {1, 2}\n *   Diff -> {4, 5, 9}\n *\n * Arguments:\n *   li1, li2 \u2013 input vectors (passed by value to keep caller unchanged)\n *\n * Returns:\n *   vector<long> holding the element\u2011wise differences.\n */\nstd::vector<long> Diff(std::vector<long> li1, std::vector<long> li2)\n{\n    // Reserve enough space for the longer vector\n    std::vector<long> result;\n    result.reserve(std::max(li1.size(), li2.size()));\n\n    size_t i = 0;\n    // Handle common length first\n    for (; i < li1.size() && i < li2.size(); ++i) {\n        result.push_back(li1[i] - li2[i]);\n    }\n\n    // Append the rest of the longer vector unchanged\n    if (i < li1.size()) {\n        result.insert(result.end(), li1.begin() + i, li1.end());\n    } else if (i < li2.size()) {\n        result.insert(result.end(), li2.begin() + i, li2.end());\n    }\n\n    return result;\n}\n\n/* ---------- Demo (remove this part in real usage) ---------- */\nint main() {\n    std::vector<long> a = {5, 7, 9};\n    std::vector<long> b = {1, 2};\n\n    std::vector<long> c = Diff(a, b);\n\n    std::cout << \"Diff = { \";\n    for (size_t i = 0; i < c.size(); ++i) {\n        std::cout << c[i] << (i + 1 < c.size() ? \", \" : \" }\");\n    }\n    std::cout << \"\\n\";\n\n    // Simple assertion to verify the example\n    assert((c == std::vector<long>{4, 5, 9}));\n    return 0;\n}\n```\n\n### What this does\n\n1. **Reserves space** for the result to avoid reallocations.  \n2. **Falls back** to inserting the rest of the longer vector unchanged, so you don\u2019t have to pad the shorter vector with zeros.  \n3. **Keeps the signature** simple (`std::vector<long>` inputs/outputs) and works with any size.  \n\nFeel free to copy the `Diff` function into your project and remove the demo section once you\u2019re ready."]}
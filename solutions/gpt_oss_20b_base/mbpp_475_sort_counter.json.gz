{"completions": ["Here is a full, minimal implementation of `sort_counter` that takes a `std::map<std::string,long>` (you can change the type if you prefer) and returns a `std::vector<std::tuple<std::string,long>>` sorted by the *value* inside the map (ascending order).  \nFeel free to replace the sorting direction or tweak the signature to match your own codebase.\n\n```cpp\n#include <tuple>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>   // for std::sort\n\n/**\n * @brief Sort a map by its values.\n *\n * @param dict1   The map to be sorted. The map must be\n *                `std::map<std::string, long>` (or any\n *                associative container with `key_type` and `mapped_type`).\n *\n * @return A vector containing tuples `(key, value)` sorted by value\n *         in ascending order. If several keys have the same value, their\n *         relative order is preserved according to the original map\n *         (i.e. the input order of the map, which for `std::map` is the\n *         key\u2011order).\n */\nstd::vector<std::tuple<std::string, long>>\nsort_counter(const std::map<std::string, long>& dict1)\n{\n    // 1. Move the map contents into a vector of tuples\n    std::vector<std::tuple<std::string, long>> vec;\n    vec.reserve(dict1.size());\n    for (const auto& kv : dict1) {\n        vec.emplace_back(kv.first, kv.second);\n    }\n\n    // 2. Sort the vector by the second element of the tuple (the value)\n    std::sort(vec.begin(), vec.end(),\n              [](const std::tuple<std::string,long>& a,\n                 const std::tuple<std::string,long>& b)\n              {\n                  // ascending order; change to > for descending\n                  return std::get<1>(a) < std::get<1>(b);\n              });\n\n    return vec;\n}\n```\n\n### How it works\n\n1. **Copy into a vector** \u2013  \n   `std::map` is already sorted by key, but you cannot sort it by value in place.  \n   Copy each key\u2011value pair into a `std::vector<std::tuple<std::string,long>>`.\n\n2. **Sort the vector** \u2013  \n   `std::sort` with a lambda that looks at `std::get<1>` (the value).  \n   The lambda returns `true` if `a` should come before `b`.  \n   For descending order just replace `<` with `>`.\n\n3. **Return the sorted vector** \u2013  \n   The caller can now iterate or use the result however they like.\n\nYou can drop in this function directly into your code; just be sure to `#include <tuple>`, `<string>`, `<vector>`, and `<map>` (the first two are included in your snippet already).", "```cpp\n#include <cassert>\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n *  sort_counter\n *\n *  Create a vector of tuples <key,value> from the input map and\n *  sort it by the value part.  The order of equal values is\n *  **stable** \u2013 i.e. they keep the order they had in the original\n *  map (which, for a `std::map`, is already sorted by key and\n *  therefore deterministic).\n *\n *  Parameters\n *  ----------\n *  dict1 : std::map<std::string,long>\n *      A map that you want to sort by value.\n *\n *  Returns\n *  -------\n *  std::vector<std::tuple<std::string,long>>\n *      A vector that contains all key/value pairs from `dict1`, sorted\n *      in ascending order of the value.  If you need a descending\n *      order, just reverse the vector after the function returns or\n *      change the comparison function below.\n *\n *  Complexity\n *  ----------\n *  O(n log n) because of the sorting step, where *n* is\n *  `dict1.size()`.  Converting to a vector is O(n) and the sort\n *  dominates the overall complexity.\n */\nvector<tuple<string,long>> sort_counter(map<string,long> dict1)\n{\n    // 1. Copy key/value pairs into a vector of tuples\n    vector<tuple<string,long>> vec;\n    vec.reserve(dict1.size());              // pre\u2011allocate to avoid reallocations\n    for (const auto& kv : dict1) {\n        vec.emplace_back(kv.first, kv.second); // note: std::make_tuple is implicit\n    }\n\n    // 2. Sort the vector by value (2nd element of the tuple)\n    stable_sort(vec.begin(), vec.end(),\n        [](const auto& a, const auto& b)\n        {\n            return get<1>(a) < get<1>(b);      // ascending\n        });\n\n    return vec;\n}\n\n/* ---------------------------------------------------------- */\n/* Demo / Test function (you can delete this when using the  */\nvoid demo()\n{\n    map<string,long> freq;\n    freq[\"apple\"]  = 4;\n    freq[\"banana\"] = 1;\n    freq[\"orange\"] = 3;\n    freq[\"pear\"]   = 4;    // same value as apple\n\n    auto sorted = sort_counter(freq);\n\n    // Output in the sorted order\n    for (const auto& [k, v] : sorted) {\n        cout << k << \": \" << v << '\\n';\n    }\n    /* Expected (ascending)\n     * banana: 1\n     * orange: 3\n     * apple: 4\n     * pear: 4\n     *   Note: 'apple' comes before 'pear' because the sort is stable\n     *   and the original map kept 'apple' before 'pear'.\n     */\n}\n\nint main()\n{\n    demo();\n    return 0;\n}\n```\n\n### What the function does\n\n1. **Convert the map into a vector of tuples** \u2013  \n   `std::tuple<string,long>` where the first element is the key and the second the value.\n\n2. **Stable sort the vector** \u2013  \n   The lambda compares the second element (`get<1>(\u2026)`) to order them by value.  \n   A *stable* sort guarantees that equal values keep the relative order they had\n   in the initial map (which is by key, so the output is deterministic).\n\n3. **Return the sorted vector** \u2013  \n   The caller can then iterate over it or process it as needed.\n\nFeel free to tweak the comparison function if you need descending order, or to return a different container type if that better fits your use\u2011case.", "Below is a **complete, ready\u2011to\u2011compile C++17** example that shows how to\n\n1. Take a `std::map<std::string, long>` as input,\n2. Sort the key/value pairs by the **value** (optionally in descending order),\n3. Return a `std::vector<std::tuple<std::string,long>>` containing the sorted data.\n\n```cpp\n#include <assert.h>\n#include <bits/stdc++.h>\nusing namespace std;\n\n// ---------------------------------------------------------------------------\n//  sort_counter\n//\n//  Sort a map by its values and return a vector of `tuple<string,long>`\n//  containing the sorted key/value pairs.\n// ---------------------------------------------------------------------------\nstd::vector<std::tuple<std::string, long>>\nsort_counter(const std::map<std::string, long> &dict1,\n             bool descending = true)            // true \u2192 descending (default)\n{\n    // step 1 : copy the map into a vector\n    std::vector<std::tuple<std::string, long>> vec;\n    vec.reserve(dict1.size());\n    for (const auto &kv : dict1) {\n        vec.emplace_back(kv.first, kv.second);\n    }\n\n    // step 2 : sort by the second element of the tuple (the value)\n    std::sort(vec.begin(), vec.end(),\n              [descending](const auto &a, const auto &b) {\n                  if (descending)\n                      return std::get<1>(a) > std::get<1>(b);   // larger first\n                  else\n                      return std::get<1>(a) < std::get<1>(b);   // smaller first\n              });\n\n    return vec;     // already a vector of tuples\n}\n\n// ------------------------------------------------------------\n//  Helper to print the result nicely (for demonstration)\n// ------------------------------------------------------------\nvoid print_vec(const vector<tuple<string,long>> &v)\n{\n    for (const auto &t : v) {\n        cout << '(' << get<0>(t) << \", \" << get<1>(t) << \")\\n\";\n    }\n}\n\n// ------------------------------------------------------------\n//  Example usage / unit test\n// ------------------------------------------------------------\nint main()\n{\n    // Build a sample map\n    std::map<std::string, long> counts = {\n        {\"apple\",  4},\n        {\"banana\", 1},\n        {\"cherry\", 7},\n        {\"date\",   3}\n    };\n\n    // Sort descending\n    auto sorted_desc = sort_counter(counts);\n    cout << \"Sorted descending:\\n\";\n    print_vec(sorted_desc);\n\n    // Sort ascending\n    auto sorted_asc = sort_counter(counts, false);\n    cout << \"\\nSorted ascending:\\n\";\n    print_vec(sorted_asc);\n\n    // Simple sanity checks\n    assert(get<0>(sorted_desc[0]) == \"cherry\");\n    assert(get<0>(sorted_desc.back()) == \"banana\");\n    assert(get<0>(sorted_asc[0]) == \"banana\");\n    assert(get<0>(sorted_asc.back()) == \"cherry\");\n\n    return 0;\n}\n```\n\n### What this code does\n\n| Step | Action | C++ feature used |\n|------|--------|------------------|\n| 1 | Convert the `map` into a `vector` of `tuple<std::string,long>` | `reserve`, `emplace_back` |\n| 2 | Sort the vector by the value component | `std::sort` with a lambda that accesses `std::get<1>` |\n| 3 | Return the sorted vector | plain return |\n\n* `descending` is optional \u2013 set it to `false` if you want ascending order.\n* The helper function `print_vec` is only for demo purposes; you can delete it.\n\nCompile with a C++17 compliant compiler, e.g.:\n\n```bash\ng++ -std=c++17 -O2 -Wall -Wextra -pedantic main.cpp -o main\n./main\n```\n\nYou will see the map sorted first in descending and then in ascending order."]}
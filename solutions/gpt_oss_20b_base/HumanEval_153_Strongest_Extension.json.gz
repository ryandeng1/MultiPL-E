{"completions": ["```cpp\n#include <string>\n#include <vector>\n#include <cctype>\n\nstd::string Strongest_Extension(std::string class_name,\n                                std::vector<std::string> extensions)\n{\n    // Handle case where there are no extensions (undefined behaviour here)\n    // but for safety we return the class name without any extension.\n    if (extensions.empty())\n        return class_name;\n\n    int best_strength = std::numeric_limits<int>::min();\n    std::string best_ext = extensions[0];\n\n    for (const auto &ext : extensions) {\n        int cap = 0, sm = 0;\n        for (char c : ext) {\n            if (std::isupper(static_cast<unsigned char>(c))) cap++;\n            else if (std::islower(static_cast<unsigned char>(c))) sm++;\n        }\n        int strength = cap - sm;\n\n        // choose the first one in case of a tie\n        if (strength > best_strength) {\n            best_strength = strength;\n            best_ext = ext;\n        }\n    }\n\n    return class_name + \".\" + best_ext;\n}\n```\n\n**Explanation**  \n1. Iterate over every extension.  \n2. Count uppercase (`CAP`) and lowercase (`SM`) letters using `<cctype>`.  \n3. Compute the strength `CAP - SM`.  \n4. Keep track of the maximum strength and the corresponding extension.  \n5. In case of ties we keep the first one encountered because we only update when a *strictly* larger strength is found.  \n6. Finally concatenate `class_name` + `.` + `best_ext` and return it.", "**Answer (C++17)**\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Calculate the strength of a single extension\nint extension_strength(const string& ext) {\n    int cap = 0;   // count of uppercase\n    int sm  = 0;   // count of lowercase\n    for (char c : ext) {\n        if (isupper(static_cast<unsigned char>(c))) ++cap;\n        else if (islower(static_cast<unsigned char>(c))) ++sm;\n    }\n    return cap - sm;\n}\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    if (extensions.empty())\n        return class_name;          // no extension to attach\n\n    string best_ext = extensions[0];\n    int best_strength = extension_strength(best_ext);\n\n    for (size_t i = 1; i < extensions.size(); ++i) {\n        int cur_strength = extension_strength(extensions[i]);\n        if (cur_strength > best_strength) {\n            best_strength = cur_strength;\n            best_ext = extensions[i];\n        }\n        // If equal, we keep the earlier one (do nothing)\n    }\n\n    return class_name + \".\" + best_ext;\n}\n```\n\n**Explanation**\n\n1. **Strength calculation**  \n   - Count uppercase letters (`CAP`) and lowercase letters (`SM`) in the extension.  \n   - Strength = `CAP - SM`.\n\n2. **Selecting the strongest**  \n   - Iterate through the vector.  \n   - Keep track of the best strength found and the corresponding extension.  \n   - If a new extension has a higher strength, update.  \n   - If the strength ties, we keep the earlier one because we only update on a strictly greater value.\n\n3. **Return value**  \n   - Concatenate the original class name, a dot, and the chosen extension.  \n\nThe function works for all input sizes that fit into memory and follows the required tie\u2011breaking rule.", "**Solution Explanation**\n\nWe have to scan all extensions, compute their *strength* and keep the best one.\n\nFor an extension `E`\n\n```\nCAP = number of uppercase characters in E\nSM  = number of lowercase characters in E\nstrength(E) = CAP - SM      // can be negative\n```\n\nThe rule for choosing the \u201cstrongest\u201d extension is\n\n* the one with **larger** `strength`\n* if there is a tie, pick the one that appears **first** in the input\n  vector.\n\nAfter we found the best extension `best`, we simply return\n\n```\nclass_name + \".\" + best\n```\n\nThe straightforward implementation is `O(total length of all strings)` \u2013  \neach character is inspected once \u2013 and uses `O(1)` extra space.\n\n\n\n--------------------------------------------------------------------\n\n#### Algorithm\n```\nStrongest_Extension(class_name, extensions):\n    best_extension   = \"\"\n    best_strength    = -\u221e          // any number smaller than possible\n\n    for each extension e in extensions:\n        CAP = 0\n        SM  = 0\n        for each character c in e:\n            if 'A' <= c <= 'Z'  CAP++\n            else if 'a' <= c <= 'z'  SM++\n        strength = CAP - SM\n\n        if strength > best_strength:      // better -> replace\n            best_strength = strength\n            best_extension = e\n        // tie \u2192 do nothing, preserves earlier one\n\n    return class_name + \".\" + best_extension\n```\n\n--------------------------------------------------------------------\n\n#### Correctness Proof\n\nWe prove that the algorithm returns the required string.\n\n*Lemma 1*  \nFor every extension `e`, the algorithm computes `strength(e)` correctly.\n\n*Proof.*  \nThe inner loop iterates over all characters of `e`.  \nIt increments `CAP` for every uppercase letter and `SM` for every lowercase\nletter.  \nAfter the loop, `CAP` equals the number of uppercase letters in `e`,  \n`SM` equals the number of lowercase letters.  \nHence `strength = CAP - SM` is computed exactly as defined. \u220e\n\n\n\n*Lemma 2*  \nAt any point during the scan, `best_strength` equals the largest strength\nseen so far, and `best_extension` is the first extension (in the input order)\nthat attains this strength.\n\n*Proof.*  \nBy induction over the loop iterations.\n\n* Base: Before the first iteration `best_strength = -\u221e` and `best_extension\n  = \"\"`. Trivially the invariant holds.\n\n* Induction step:  \n  Assume the invariant holds before processing extension `e`.  \n  Let `s = strength(e)`.\n\n  * If `s > best_strength`: `e` has higher strength than any previous\n    extension, so we set `best_strength = s` and\n    `best_extension = e`. The invariant holds.\n\n  * If `s == best_strength`: removing the first\u2011in\u2011input rule would\n    require a change, but we do **not** update the variables, so the\n    stored extension remains the earliest one with this strength.\n    The invariant still holds.\n\n  * If `s < best_strength`: nothing changes; the invariant remains true.\n\nThus the invariant holds after each iteration. \u220e\n\n\n\n*Theorem*  \nThe function returns `ClassName.StrongestExtensionName` where\n`StrongestExtensionName` is the extension with maximum strength, breaking ties\nby earliest position in the vector.\n\n*Proof.*  \nAfter the loop terminates, by Lemma\u202f2 `best_extension` is exactly the\nextension required by the problem statement.  \nThe function concatenates `class_name`, a dot, and `best_extension`,\ntherefore the returned string has the required format. \u220e\n\n\n\n--------------------------------------------------------------------\n\n#### Complexity Analysis\n\nLet `N` be the number of extensions and `L` the total number of characters\nacross all extensions.\n\n*Time*:  \nEach character is examined once \u2192 `O(L)`.\n\n*Space*:  \nOnly a few integer variables and two strings are stored  \n\u2192 `O(1)` extra space.\n\n\n\n--------------------------------------------------------------------\n\n#### Reference Implementation (C++17)\n\n```cpp\n#include <string>\n#include <vector>\n#include <limits>\n\nstd::string Strongest_Extension(std::string class_name,\n                                std::vector<std::string> extensions)\n{\n    std::string best_extension = \"\";\n    // INF must be smaller than any possible strength.\n    int best_strength = std::numeric_limits<int>::min();\n\n    for (const std::string &e : extensions) {\n        int CAP = 0, SM = 0;\n        for (char c : e) {\n            if ('A' <= c && c <= 'Z') ++CAP;\n            else if ('a' <= c && c <= 'z') ++SM;\n        }\n        int strength = CAP - SM;\n\n        if (strength > best_strength) {\n            best_strength = strength;\n            best_extension = e;\n        }\n        /* on tie we keep the earlier one \u2013 so no action required */\n    }\n\n    return class_name + \".\" + best_extension;\n}\n```\n\nThis implementation follows exactly the algorithm proven correct above."]}
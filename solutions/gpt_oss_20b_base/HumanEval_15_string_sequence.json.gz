{"completions": ["Here is a minimal implementation that follows the specification you described:\n\n```cpp\n#include <string>\n#include <sstream>\n\n/// Return a string containing space\u2011delimited numbers starting from 0 up to n (inclusive).\n///   - If n < 0, nothing is added, and the function returns an empty string.\n///   - For n >= 0, the numbers \"0 1 2 ... n\" are concatenated separated by single spaces.\n///\n/// Examples:\n///   string_sequence(0)  -> \"0\"\n///   string_sequence(5)  -> \"0 1 2 3 4 5\"\nstd::string string_sequence(long n) {\n    if (n < 0) return \"\";               // No numbers to output for negative n\n\n    std::ostringstream oss;\n    for (long i = 0; i <= n; ++i) {\n        if (i) oss << ' ';              // add space after the first element\n        oss << i;\n    }\n    return oss.str();\n}\n```\n\n**Explanation**\n\n* `ostringstream` is used to build the string efficiently.\n* The loop runs from `0` to `n`.  \n  * For `i == 0` we skip adding a preceding space, for the rest we prepend a space.\n* Finally, the accumulated string is returned.  \n* The function handles negative `n` by simply returning an empty string, but you can adjust this behavior if the specification requires an error or a different sentinel value.", "Here\u2019s a compact and idiomatic implementation that satisfies the specification.  \nIt builds a space\u2011delimited list of numbers from **0** up to the given **n** (inclusive).  \nThe function works for any non\u2011negative `long` value and keeps the code clear.\n\n```cpp\n#include <string>\n#include <sstream>\n#include <limits>\n#include <stdexcept>\n\n/**\n * Return a string containing space\u2011delimited numbers starting from 0 up to n inclusive.\n *\n *   string_sequence(0) \u2192 \"0\"\n *   string_sequence(5) \u2192 \"0 1 2 3 4 5\"\n *\n * @param n  The maximum number to include in the sequence.  Must be >= 0.\n * @return   A space\u2011delimited string of numbers.\n *\n * @throws std::out_of_range if n < 0.\n */\nstd::string string_sequence(long n) {\n    if (n < 0) {\n        throw std::out_of_range(\"n must be non\u2011negative\");\n    }\n\n    // Reserve approximate capacity: each number takes at most 20 chars\n    std::string result;\n    result.reserve(static_cast<size_t>(n + 1) * 21);\n\n    for (long i = 0; i <= n; ++i) {\n        if (i > 0) result.push_back(' ');\n        // Convert number to string without temporary std::to_string cost\n        // by using a small buffer.\n        char buf[32];\n        int len = snprintf(buf, sizeof(buf), \"%lld\", static_cast<long long>(i));\n        result.append(buf, static_cast<size_t>(len));\n    }\n    return result;\n}\n```\n\n### How it works\n1. **Argument check** \u2013 A negative `n` would break the invariant \u201cstart from 0 up to n inclusive\u201d.  \n2. **String pre\u2011allocation** \u2013 We reserve enough capacity to avoid repeated re\u2011allocations (rough estimate).  \n3. **Building the sequence** \u2013  \n   * Loop from `0` to `n`.  \n   * Append a space before every element *except* the very first.  \n   * Convert each number to text efficiently with `snprintf` and append to the result.  \n4. **Return** the fully constructed string.\n\nFeel free to adapt the function to your exact error\u2011handling policy or performance fine\u2011tuning needs.", "Here\u2019s a complete, self\u2011contained implementation of the requested `string_sequence` function in C++:\n\n```cpp\n#include <string>\n#include <sstream>\n\n// Return a string containing space\u2011delimited numbers starting from 0 up to n inclusive.\nstd::string string_sequence(long n) {\n    // Handle the simplest case first\n    if (n < 0) {\n        // For negative n the requested sequence is undefined; we simply return an empty string.\n        return \"\";\n    }\n\n    std::ostringstream oss;          // efficient way to build strings\n    for (long i = 0; i <= n; ++i) {\n        oss << i;\n        if (i != n)                 // avoid trailing space after the last number\n            oss << ' ';\n    }\n    return oss.str();\n}\n```\n\n### How it works\n1. **Input validation**  \n   - If `n` is negative we return an empty string \u2013 the specification didn't define what to do with negative values, so this is a safe default.\n\n2. **String construction**  \n   - `std::ostringstream` is a fast, convenient helper to concatenate numbers.\n   - We loop from `0` to `n` inclusive, inserting each number followed by a space **only if** it\u2019s not the last one. This guarantees no trailing space.\n\n3. **Return**  \n   - The accumulated string is retrieved with `oss.str()` and returned.\n\n### Example usage\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << \"\\\"\" << string_sequence(0) << \"\\\"\\n\"; // prints \"0\"\n    std::cout << \"\\\"\" << string_sequence(5) << \"\\\"\\n\"; // prints \"0 1 2 3 4 5\"\n}\n```\n\nFeel free to adapt the error handling for negative numbers if your use\u2011case requires a different behavior."]}
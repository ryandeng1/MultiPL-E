{"completions": ["Here\u2019s a straightforward implementation of the `right_angle_triangle` function in C++.  \nThe function:\n\n1. Checks that the sides can actually form a triangle (triangle inequality).\n2. Sorts the side lengths so that the largest side can be treated as the hypotenuse.\n3. Uses the Pythagorean theorem to determine whether the triangle is right\u2011angled.\n\n```cpp\n#include <algorithm>   // for std::sort\n#include <vector>\n\n// Returns true if (a, b, c) can form a right\u2011angled triangle,\n// false otherwise.\nbool right_angle_triangle(long a, long b, long c) {\n    // 1. Triangle inequality \u2013 the sum of any two sides must be greater than the third\n    if ( (a + b <= c) || (a + c <= b) || (b + c <= a) )\n        return false;\n\n    // 2. Arrange sides so that c is the largest (hypotenuse)\n    //    Using a vector for simplicity of sorting\n    std::vector<long> sides = {a, b, c};\n    std::sort(sides.begin(), sides.end());           // sides[0] <= sides[1] <= sides[2]\n\n    long leg1 = sides[0];\n    long leg2 = sides[1];\n    long hyp = sides[2];\n\n    // 3. Pythagorean theorem\n    return leg1 * leg1 + leg2 * leg2 == hyp * hyp;\n}\n```\n\n### Why this works\n- **Triangle inequality** guarantees that the three lengths can form a non\u2011degenerate triangle.\n- By sorting, we identify the longest side (`hyp`) and compare the sum of squares of the two shorter sides with the square of `hyp`.  \n- Using `long` for arithmetic prevents overflow for typical input ranges; if you expect very large values, consider using `int64_t` or handling overflow explicitly.\n\nYou can use this function directly in your code or add your own unit tests to verify behavior.", "Here is a concise implementation that checks the three conditions:\n\n1. **All sides must be positive integers.**  \n2. **Triangle inequality**: the sum of any two sides must be strictly larger than the third side.  \n3. **Pythagorean theorem**: one of the permutations of the sides must satisfy  \n   `x\u00b2 + y\u00b2 == z\u00b2`.\n\nThe function returns `true` only when **all three** criteria are met.\n\n```cpp\n#include <cassert>\n#include <algorithm>\n#include <cstdint>\n\n/*\n * Returns true if the three given side lengths form a right\u2011angled triangle,\n * otherwise returns false.\n */\nbool right_angle_triangle(long a, long b, long c)\n{\n    // All sides must be positive\n    if (a <= 0 || b <= 0 || c <= 0) {\n        return false;\n    }\n\n    // Triangle inequality: each side must be less than the sum of the other two\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return false;\n    }\n\n    // Sort the sides so that sides[2] is the potentially largest side (hypotenuse)\n    long long sides[3] = {a, b, c};\n    std::sort(sides, sides + 3);          // sides[0] <= sides[1] <= sides[2]\n\n    // Use 64\u2011bit arithmetic to avoid overflow\n    long long x = sides[0];\n    long long y = sides[1];\n    long long z = sides[2];\n\n    // Pythagorean check\n    return (x * x + y * y == z * z);\n}\n```\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << right_angle_triangle(3, 4, 5) << '\\n';  // true\n    std::cout << right_angle_triangle(5, 4, 3) << '\\n';  // true (order doesn't matter)\n    std::cout << right_angle_triangle(1, 2, 3) << '\\n';  // false (triangle inequality fails)\n    std::cout << right_angle_triangle(6, 8, 10) << '\\n'; // true\n    std::cout << right_angle_triangle(7, 24, 25) << '\\n';// true\n    return 0;\n}\n```\n\nThis function handles all edge cases safely, using a 64\u2011bit type for the intermediate calculations to avoid overflow when squaring large side lengths.", "Here is a short, robust solution.  \nThe idea is\n\n1. **Sort** the three sides.  \n   The largest side must be the hypotenuse for a right\u2011angled triangle.  \n2. Verify the **triangle inequality** \u2013 the sum of the two shorter sides must be larger than the longest side (otherwise the points cannot even form a triangle).  \n3. Check the **Pythagorean theorem**:  \n   `a\u00b2 + b\u00b2 == c\u00b2`.  \n   Because the sides are of type `long`, the squares can overflow a 64\u2011bit integer; we therefore compute the squares in a wider type `__int128` (built\u2011in GCC/Clang/ICC type) to be safe.\n\n```cpp\n#include <algorithm>   // for std::sort\n#include <cstdint>     // for int64_t, int128_t if needed\n\n// Return true iff the three sides can form a right\u2011angled triangle.\nbool right_angle_triangle(long a, long b, long c)\n{\n    // Put the sides in ascending order: sides[0] <= sides[1] <= sides[2].\n    long sides[3] = { a, b, c };\n    std::sort(sides, sides + 3);\n\n    // 1. Triangle inequality: the two small sides must sum to greater than the largest.\n    if (sides[0] + sides[1] <= sides[2])\n        return false;          // not a triangle at all\n\n    // 2. Pythagorean theorem: a^2 + b^2 == c^2\n    // Use __int128 to avoid overflow (a,b,c are signed longs)\n    __int128 left  = static_cast<__int128>(sides[0]) * sides[0]\n                    + static_cast<__int128>(sides[1]) * sides[1];\n    __int128 right = static_cast<__int128>(sides[2]) * sides[2];\n\n    return left == right;\n}\n```\n\n### Why this works\n\n* **Sorting** guarantees that `sides[2]` is the hypotenuse when the triangle is right\u2011angled.  \n* **Triangle inequality** eliminates degenerate or impossible inputs (`(1, 2, 3)` \u21d2 `1+2 == 3`, not a triangle).  \n* Using `__int128` for the multiplication ensures the expression cannot overflow for any `long` values within the signed 64\u2011bit range.  \n\nThe function now safely returns the correct boolean value for any set of three `long` side lengths."]}
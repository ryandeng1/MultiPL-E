{"completions": ["Below is a small, self\u2011contained **C++** implementation of a function that returns the sum of all elements that appear **exactly once** in a `std::vector<long>`.  \nIt works for any size of the input vector (including an empty one) and handles negative numbers as well.\n\n```cpp\n#include <vector>\n#include <unordered_map>\n\n/**\n * @brief  Compute the sum of all elements that occur only once in the vector.\n *\n * The function first counts how many times each value appears using an\n * unordered_map (hash table).  Then it iterates over the map and adds\n * the key to the result only if its count is 1.\n *\n * @param arr   the input vector of long integers\n * @return long the sum of the non\u2011repeated elements\n */\nlong find_sum(const std::vector<long>& arr) {\n    // 1. Count occurrences of each value\n    std::unordered_map<long, size_t> freq;\n    for (const long& v : arr) {\n        ++freq[v];\n    }\n\n    // 2. Sum values that appear exactly once\n    long sum = 0;\n    for (const auto& [value, count] : freq) {\n        if (count == 1) {\n            sum += value;\n        }\n    }\n    return sum;\n}\n```\n\n### How to use it\n\n```cpp\nint main() {\n    std::vector<long> data = {5, 3, 5, 7, -2, 7, 10};\n    long total = find_sum(data);        // total == -2 + 3 + 10 = 11\n}\n```\n\n### Explanation\n\n* **Counting** \u2013 `unordered_map<long, size_t>` gives *O(1)* average\u2011time insertion and lookup.\n* **Summation** \u2013 We only add a number if its frequency is `1`, which satisfies \u201cnon\u2011repeated\u201d.\n* **Complexity** \u2013  \n  * Time: `O(n)` where *n* is the number of elements.  \n  * Extra space: `O(k)` where *k* is the number of distinct elements (\u2264 *n*).\n\nFeel free to replace `unordered_map` with `std::map` if deterministic ordering is required, but the overall algorithm remains the same.", "Here\u2019s a clean, idiomatic C++ solution that\n\n1.  iterates over the vector once to count each value,\n2.  iterates again to add those that appear only once.\n\n```cpp\n#include <vector>\n#include <unordered_map>\n\n/// @brief Compute the sum of all elements that appear exactly once in @c arr.\n/// @param arr Vector of long integers.\n/// @return Sum of the non\u2011repeated elements. If no element is unique, returns 0.\nlong find_sum(const std::vector<long>& arr)\n{\n    // First pass \u2013 count occurrences\n    std::unordered_map<long, unsigned> freq;\n    for (long v : arr) {\n        ++freq[v];         // O(1) amortised insert/increment\n    }\n\n    // Second pass \u2013 sum only the values that appear once\n    long sum = 0;\n    for (long v : arr) {\n        if (freq[v] == 1) {\n            sum += v;\n        }\n    }\n    return sum;\n}\n```\n\n### How it works\n- `freq` is an `unordered_map` that stores how many times each value shows up in `arr`.  \n- After building the frequency table, we loop through the original vector again and add only those values whose frequency is `1`.  \n- This guarantees **O(n)** time and **O(n)** additional space.\n\n### Usage example\n\n```cpp\nint main() {\n    std::vector<long> data{10, 20, 10, 30, 40, 20, 40, 30, 50};\n    std::cout << \"Sum of non\u2010repeated elements: \" << find_sum(data) << '\\n';\n    // Output: 50\n}\n```\nThe function is templated only for `long`; you can change the type or make it a template if you need more flexibility.", "Here is a clean, self\u2011contained C++ implementation that receives a `std::vector<long>` and returns the sum of all elements that appear **exactly once** in that vector.\n\n```cpp\n#include <vector>\n#include <unordered_map>\n#include <numeric>   // for std::accumulate\n#include <cassert>\n\n// -----------------------------------------------------------------\n// Return the sum of elements that occur only once in `arr`.\n// -----------------------------------------------------------------\nlong find_sum(const std::vector<long>& arr)\n{\n    /* 1. Count how many times each value appears.   */\n    std::unordered_map<long, std::size_t> freq;\n    for (const long v : arr)\n        ++freq[v];\n\n    /* 2. Sum only the elements whose frequency is 1. */\n    long sum = 0;\n    for (const long v : arr)\n        if (freq[v] == 1)\n            sum += v;\n\n    return sum;\n}\n\n/* -----------------------------------------------------------------\n   Quick tests to ensure the function behaves as expected.\n   ----------------------------------------------------------------- */\nint main()\n{\n    std::vector<long> a{1, 2, 3, 2, 4, 5, 5, 6};\n    // Non\u2011repeated: 1,3,4,6 \u2192 sum = 14\n    assert(find_sum(a) == 14);\n\n    std::vector<long> b{10, 10, 10};\n    // No non\u2011repeated elements \u2192 sum = 0\n    assert(find_sum(b) == 0);\n\n    std::vector<long> c{7};\n    // Single element is non\u2011repeated \u2192 sum = 7\n    assert(find_sum(c) == 7);\n\n    return 0;    // success\n}\n```\n\n### How it works\n\n1. **Counting** \u2013 We use an `unordered_map<long, size_t>` to keep a frequency count of every value in the input vector.\n2. **Summation** \u2013 We iterate over the original vector once more, adding only those values whose count equals `1`.\n3. **Return** \u2013 The accumulated sum is returned.\n\nThe algorithm runs in *O(n)* time and uses *O(n)* additional space (the map). The test cases in `main()` verify the function for a few typical scenarios. Feel free to drop the `main()` section into your own test harness or remove it before integrating this function into your project."]}
{"completions": ["Below is a complete, self\u2011contained implementation of **heap sort** in C++17 which you can drop\u2011in and use directly.\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n/*---------------------  Heap Sort  ----------------------------------*/\n/*\n   The algorithm works in two phases:\n\n   1.  Build a max\u2011heap out of the input vector.\n       Use the standard heap\u2011construction scheme that\n           * starts from the last internal node\n           * sifts down each node so that the max\u2011heap property\n             (parent \u2265 children) holds.\n       Complexity:  O(n)\n\n   2.  Repeatedly extract the maximum element (root of the heap)\n       and place it at the end of the vector.  After each\n       extraction we restore the heap property on the reduced\n       heap (the element that was swapped to the root).\n       Complexity:  O(n log n)\n\n   The routine returns a **new vector** containing the sorted\n   elements in ascending order.  The original `iterable` is not\n   modified.\n*/\n\ntemplate <typename T>\nstatic void sift_down(std::vector<T>& a, std::size_t root, std::size_t n)\n{\n    // While root has at least a left child\n    while (root * 2 + 1 < n)\n    {\n        std::size_t child  = root * 2 + 1;          // left child\n        std::size_t left   = child + 1;             // right child (if any)\n\n        // Pick the larger of the two children\n        if (left < n && a[left] > a[child])\n            child = left;\n\n        // If root is already larger than both children \u2013 done\n        if (a[root] >= a[child])\n            break;\n\n        std::swap(a[root], a[child]);   // Move larger child up\n        root = child;                   // Continue sifting down\n    }\n}\n\ntemplate <typename T>\nstd::vector<T> heap_sort(std::vector<T> iterable)\n{\n    const std::size_t n = iterable.size();\n    if (n <= 1) return iterable;            // already sorted\n\n    /* ----------------- 1. Build max\u2011heap ------------------- */\n    for (std::size_t i = n / 2; i-- > 0; ) // start from last internal node\n        sift_down(iterable, i, n);\n\n    /* ----------------- 2. Extract elements ------------------- */\n    for (std::size_t end = n; end > 1; --end)\n    {\n        std::swap(iterable[0], iterable[end - 1]);  // Move max to the tail\n        sift_down(iterable, 0, end - 1);            // Restore heap on the reduced size\n    }\n\n    return iterable;                 // Already in ascending order\n}\n\n/*---------------------  Usage example  ---------------------------*/\n\n#ifdef TEST_HEAP_SORT\n#include <iostream>\nint main()\n{\n    std::vector<long> v{ 3, 5, 1, 4, 2, 8, 7, 6 };\n    auto sorted = heap_sort<long>(v);\n\n    for (auto x : sorted)\n        std::cout << x << ' ';\n    std::cout << '\\n';\n    // Expected output: 1 2 3 4 5 6 7 8\n    return 0;\n}\n#endif\n```\n\n### Key Points\n\n1. **In\u2011place** \u2013 The sorting is done without allocating more than a few auxiliary variables.\n2. **Stable?** \u2013 Heap sort is **not** stable; equal elements may change relative order.\n3. **Complexity** \u2013  \n   * Construction: `O(n)`  \n   * Sorting phase: `O(n log n)`  \n   * Memory usage: `O(1)` (besides the input vector)\n4. **Templates** \u2013 The function is generic; it works for any type that supports `operator>` and `operator>=` (e.g., `int`, `long`, `double`, `std::string`, etc.).\n\nCompile with:\n\n```bash\ng++ -std=c++17 -DTEST_HEAP_SORT your_file.cpp -o test\n```\n\nand run `./test` to see the example output.", "Below is a **complete, clean, and fully\u2011commented implementation** of a vector\u2011based heap\u2011sort.\nIt shows how the algorithm works, how to use the helper functions efficiently, and\nprovides a short `main()` to demo the routine.\n\n> **Why this version?**  \n> * It operates in\u2011place \u2013 no extra arrays are allocated beyond the input vector.  \n> * It uses the standard \u201cmax\u2011heap\u201d construction in O(n) time and then repeatedly extracts the maximum in O(log\u202fn) time, yielding the classic `O(n\u202flog\u202fn)` overall complexity.  \n> * It is generic enough to compile on any modern C++ compiler (C++11 and newer).\n\n```cpp\n/*  heap_sort.cpp\n *\n *  A minimal, self\u2011contained implementation of heap sort for\n *  a std::vector<long>.  The function takes ownership of the vector\n *  and returns a new, sorted vector (ascending order).\n *\n *  Complexity:\n *      \u2022 Build\u2011heap:      O(n)\n *      \u2022 Extract\u2011max\u00d7n:   O(n log n)\n *      \u2192 Total:          O(n log n)\n *\n *  Reference: GE Algorithm Design Handbook \u2013 Heap Sort\n *  https://en.wikipedia.org/wiki/Heapsort\n */\n\n#include <vector>\n#include <algorithm>\n#include <iostream>\n\n/*  Helper:  percolateDown (sift\u2011down)\n *\n *  Ensures that the subtree rooted at `root` satisfies the max\u2011heap\n *  property, assuming its children already satisfy it.\n */\nstatic void percolateDown(std::vector<long> &heap, std::size_t root, std::size_t heapSize)\n{\n    std::size_t left   = 2 * root + 1;   // left child index\n    std::size_t right  = 2 * root + 2;   // right child index\n    std::size_t largest = root;\n\n    if (left < heapSize && heap[left] > heap[largest])\n        largest = left;\n    if (right < heapSize && heap[right] > heap[largest])\n        largest = right;\n\n    if (largest != root) {\n        std::swap(heap[root], heap[largest]);\n        percolateDown(heap, largest, heapSize);   // recurse to maintain heap\n    }\n}\n\n/*  Create a max\u2011heap from an unsorted array.\n *  Called once at the start of the sort.\n */\nstatic void buildMaxHeap(std::vector<long> &heap)\n{\n    std::size_t n = heap.size();\n    /* Start from the last internal node and sift down each one. */\n    for (std::size_t i = n / 2; i-- > 0; ) {\n        percolateDown(heap, i, n);\n    }\n}\n\n/*  Main routine: heap_sort\n *\n *  Accepts a vector, extracts the elements one by one,\n *  placing each smallest element at the end of the vector.\n *  The result is a sorted vector in ascending order.\n */\nstd::vector<long> heap_sort(std::vector<long> iterable)\n{\n    buildMaxHeap(iterable);          // O(n)\n\n    std::size_t heapSize = iterable.size();\n\n    for (std::size_t i = iterable.size(); i-- > 1; ) {\n        /* Move max element to the \"end\" (i.e. to position i). */\n        std::swap(iterable[0], iterable[i]);\n\n        --heapSize;                  // shrink the heap\n        percolateDown(iterable, 0, heapSize); // restore heap property\n    }\n    return iterable;                 // sorted vector\n}\n\n/*  Demo usage\n *\n *  Compile:\n *       g++ -std=c++17 -O2 heap_sort.cpp -o heap_sort\n *  Run:\n *       ./heap_sort\n */\nint main()\n{\n    std::vector<long> data{9, 3, 5, 1, 6, 8, 2, 7, 4};\n\n    std::cout << \"Original: \";\n    for (long v : data) std::cout << v << ' ';\n    std::cout << '\\n';\n\n    std::vector<long> sorted = heap_sort(data);\n\n    std::cout << \"Sorted:   \";\n    for (long v : sorted) std::cout << v << ' ';\n    std::cout << '\\n';\n\n    return 0;\n}\n```\n\n### Key points\n\n1. **In\u2011place** \u2013 the heap is built inside the same vector, and no temporary array of the same size is created.\n2. **Stable relative to complexity** \u2013 the algorithm runs in `O(n log n)` worst\u2011case time and `O(1)` additional space (besides the input vector).\n3. **Generic** \u2013 you can replace `long` with another numeric type or even a user\u2011defined type that supports `operator>`.\n\nFeel free to copy the code into your project and adapt the helper helpers if you prefer a min\u2011heap or descending order. Happy sorting!", "Here\u2019s a clean, self\u2011contained implementation of a **heap sort** that accepts a `std::vector<long>` and returns a new, sorted vector.\n\n```cpp\n#include <vector>\n#include <algorithm>   // for make_heap, pop_heap, push_heap\n\n/**\n * @brief  Sort a vector of `long`s using the heap\u2011sort algorithm.\n *\n * The function does **not** modify the input vector; instead it builds a\n * temporary copy, turns it into a max\u2011heap, and repeatedly extracts the\n * largest element to produce a sorted result in ascending order.\n *\n * @param iterable The vector to be sorted.\n * @return A new vector containing all elements of `iterable`,\n *         sorted in non\u2011decreasing order.\n */\nstd::vector<long> heap_sort(std::vector<long> iterable)\n{\n    // Turn the copy into a max\u2011heap (largest element at front).\n    std::make_heap(iterable.begin(), iterable.end());\n\n    // The vector will hold the sorted values in reverse order\n    // because a max\u2011heap always gives us the largest element.\n    std::vector<long> sorted;\n    sorted.reserve(iterable.size());\n\n    // Repeatedly pop the largest element from the heap\n    // and push it into the output vector.\n    while (!iterable.empty()) {\n        // Move the largest element to the back of `iterable`\n        std::pop_heap(iterable.begin(), iterable.end());\n        // `push_back` extracts the largest element.\n        sorted.push_back(iterable.back());\n        // Remove it from the heap.\n        iterable.pop_back();\n    }\n\n    // `sorted` now holds the elements in descending order.\n    // Reverse it to get ascending order.\n    std::reverse(sorted.begin(), sorted.end());\n    return sorted;\n}\n```\n\n### How it works\n\n1. **`std::make_heap`**: Transforms the vector into a *max\u2011heap*. The largest element will always be at the front (`iterable.front()`).\n\n2. **`std::pop_heap`**: Moves the largest element to the end of the vector and keeps the remaining ones as a heap.  \n   The largest value is then stored at `iterable.back()`.\n\n3. Repeating the pop step extracts all elements from largest to smallest, which we push into a temporary vector `sorted`.\n\n4. Finally, we reverse the `sorted` vector because it currently contains elements in **descending** order. The reverse gives us the desired **ascending** order.\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<long> v = { 9, 2, 7, 3, 5, 1, 8, 4, 6 };\n    std::vector<long> sorted = heap_sort(v);\n\n    for (auto x : sorted) std::cout << x << ' ';\n    // Output: 1 2 3 4 5 6 7 8 9\n}\n```\n\nFeel free to drop the function into your project. It\u2019s fully self\u2011contained, uses only standard library facilities, and observes the typical \\(O(n \\log n)\\) runtime of heap sort."]}
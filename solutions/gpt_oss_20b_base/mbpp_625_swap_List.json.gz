{"completions": ["Here\u2019s a minimal, self\u2011contained C++ function that takes a `std::vector<long>` (you can change the type if you wish), swaps its first and last element, and returns the modified vector.\n\n```cpp\n#include <vector>\n#include <algorithm>   // for std::swap\n\n/**\n * @brief  Swaps the first and last elements of a vector.\n *\n * If the vector contains fewer than two elements nothing is changed.\n *\n * @param newList  The vector to process (passed by value so the caller is not modified).\n * @return        A copy of the vector with its first and last elements swapped.\n */\nstd::vector<long> swap_List(const std::vector<long>& newList)\n{\n    // Make a copy so the original vector remains untouched.\n    std::vector<long> result = newList;\n\n    // Only perform the swap when the vector has at least two elements.\n    if (result.size() >= 2) {\n        std::swap(result.front(), result.back());\n    }\n\n    return result;\n}\n```\n\n### Why this version is nice\n\n| Feature | Why it matters |\n|---------|----------------|\n| **Const\u2011ref parameter** | Reads the original vector without copying until it\u2019s needed. |\n| **Copy inside the function** | Keeps the caller\u2019s data unchanged: typical functional style. |\n| **Uses `std::swap`** | Clear, handles any type, and is highly optimised. |\n| **Size guard** | No undefined behaviour when the vector is empty or has a single element. |\n\nYou can test it with a simple `main()`:\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<long> v{10, 20, 30, 40};\n\n    std::vector<long> swapped = swap_List(v);\n\n    for (long n : swapped)\n        std::cout << n << ' ';\n    std::cout << '\\n';\n\n    return 0;\n}\n```\n\nOutput will be:\n```\n40 20 30 10\n```\n\nFeel free to replace `long` with another type (e.g., `int`, `double`, or a template parameter) if you want a more generic solution.", "Below is a completely self\u2011contained C++ implementation that swaps the first and last element of a `std::vector<long>`.  \nThe function returns a *new vector* leaving the input untouched (pure\u2011functional style).  \nIf you prefer to modify the vector in place, just remove the `return newList;` part and set the last element after the swap.\n\n```cpp\n#include <vector>\n#include <algorithm>   // std::swap\n#include <iostream>    // For demonstration (optional)\n\n/**\n * @brief Returns a new vector where the first and last elements are interchanged.\n * \n * @param newList Input vector of type long.\n * @return std::vector<long> A vector identical to `newList` except that its first and\n *                            last elements have been swapped.  If the vector has fewer\n *                            than 2 elements, it is returned unchanged.\n */\nstd::vector<long> swap_List(std::vector<long> newList)\n{\n    if (newList.size() < 2) {          // nothing to swap\n        return newList;\n    }\n\n    std::swap(newList.front(), newList.back());   // swap first and last\n    return newList;\n}\n\n/* ----------  OPTIONAL: Demo ----------\nint main() {\n    std::vector<long> v = {1, 2, 3, 4, 5};\n    std::vector<long> swapped = swap_List(v);\n\n    std::cout << \"Original: \";\n    for (auto x : v) std::cout << x << ' ';\n    std::cout << \"\\nSwapped:  \";\n    for (auto x : swapped) std::cout << x << ' ';\n    std::cout << '\\n';\n    return 0;\n}\n---------------------------------- */\n```\n\n### Explanation\n\n1. **Size Check** \u2013 If the vector has fewer than two elements there is nothing to swap, so the original vector is returned unchanged.\n2. **Swapping** \u2013 `std::swap` exchanges the first (`front()`) and last (`back()`) elements.\n3. **Return** \u2013 The modified copy is returned.  \n   - *In\u2011place version:* Replace the body with `if(newList.size()>=2) std::swap(newList.front(),newList.back()); return newList;` and, if you want to avoid copying, just return `void` and work on a reference.\n\nFeel free to adapt the code to fit your specific coding style or project guidelines.", "Below is a minimal, self\u2011contained C++ implementation of a function that **interchanges the first and last element of a `std::vector<long>`**.  \nThe code follows modern C++ best\u2011practices (C++17/20), uses `std::swap`, and contains a short test\u2011suite that demonstrates the function\u2019s behaviour.\n\n```cpp\n// swap_list.hpp\n#pragma once\n#include <vector>\n#include <algorithm>   // std::swap\n#include <iterator>    // std::begin / std::end\n\n/**\n * @brief Interchanges the first and last element of the vector.\n *\n * If the vector contains fewer than 2 elements the function does nothing.\n *\n * @param vec The vector whose ends are to be swapped.\n * @return The modified vector.\n */\ninline std::vector<long> swap_List(std::vector<long> vec)\n{\n    // Only swap if there are at least two elements\n    if(vec.size() < 2)\n        return vec;\n\n    std::swap(vec.front(), vec.back());\n    return vec;\n}\n```\n\n```cpp\n// main.cpp\n#include <iostream>\n#include \"swap_list.hpp\"\n\nint main()\n{\n    std::vector<long> v{10, 20, 30, 40, 50};\n\n    std::cout << \"Before: \";\n    for(long x : v) std::cout << x << ' ';\n    std::cout << '\\n';\n\n    auto swapped = swap_List(v);\n\n    std::cout << \"After:  \";\n    for(long x : swapped) std::cout << x << ' ';\n    std::cout << '\\n';\n\n    return 0;\n}\n```\n\n### How it works\n\n1. **Guard clause**  \n   \\( \\texttt{if(vec.size() < 2)} \\) ensures we never try to swap in a vector that does not have distinct first and last elements.\n\n2. **Swapping**  \n   `std::swap(vec.front(), vec.back());` exchanges the values in constant time.\n\n3. **Return value**  \n   The modified vector is returned by value, allowing the caller to use the result directly or assign it back to the original vector.\n\n### Compile & Run\n\n```bash\ng++ -std=c++20 -O2 -Wall -Wextra -pedantic main.cpp -o swap_demo\n./swap_demo\n```\n\n**Output**\n\n```\nBefore: 10 20 30 40 50 \nAfter:  50 20 30 40 10\n```\n\n### Testing (optional but recommended)\n\nYou can add a quick unit\u2011test using your favourite framework (e.g., Catch2, GoogleTest) or a plain `assert`:\n\n```cpp\n#include <cassert>\n\nint main() {\n    auto a = swap_List({1, 2, 3});\n    assert(a == std::vector<long>{3, 2, 1});\n\n    auto b = swap_List({42});\n    assert(b == std::vector<long>{42});\n\n    auto c = swap_List({});\n    assert(c.empty());\n}\n```\n\nThat\u2019s all you need\u2014just include `swap_list.hpp` wherever you need the function. Happy coding!"]}
{"completions": ["Here\u2019s a clean implementation of the Euclidean algorithm to compute the greatest common divisor (GCD) of two `long` integers:\n\n```cpp\n#include <cassert>\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n    // Make sure inputs are non\u2011negative\n    if (a < 0) a = -a;\n    if (b < 0) b = -b;\n\n    // Edge cases: if one of them is zero, return the absolute value of the other\n    if (a == 0) return b;\n    if (b == 0) return a;\n\n    // Euclidean algorithm\n    while (b != 0) {\n        long temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;     // a now contains the GCD\n}\n```\n\n**Explanation**\n\n1. **Handle Sign** \u2013 GCD is normally defined for non\u2011negative integers, so we take the absolute value of both arguments.\n2. **Zero Cases** \u2013 If either is zero, the GCD is the absolute value of the other (by definition).\n3. **Iterative Euclidean Algorithm** \u2013 Repeatedly replace `(a, b)` with `(b, a % b)` until `b` becomes `0`. The remaining `a` is the GCD.\n\nYou can test it with the provided examples or any other pair of integers.", "Here is a concise and efficient implementation of the Euclidean algorithm:\n\n```cpp\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// 1\n// >>> greatest_common_divisor((25), (15))\n// 5\nlong greatest_common_divisor(long a, long b) {\n    // Ensure both numbers are non\u2011negative (GCD is always non\u2011negative)\n    a = llabs(a);\n    b = llabs(b);\n\n    // Euclid\u2019s algorithm \u2013 keep swapping until the remainder is 0\n    while (b != 0) {\n        long r = a % b;   // remainder of a divided by b\n        a = b;\n        b = r;\n    }\n\n    return a;   // when b == 0, a holds the GCD\n}\n```\n\n**Explanation:**\n\n1. **Absolute values** \u2013 GCD is defined for non\u2011negative ints, so we first convert `a` and `b` to their absolute values.\n2. **Euclid\u2019s algorithm** \u2013 repeatedly replace the larger number with the remainder of dividing the larger by the smaller.  \n   When the remainder becomes `0`, the other number is the `gcd`.\n3. The loop guarantees termination because the remainders strictly decrease.\n\nFeel free to drop this snippet into your project. If you need a template that handles very large integers (`long long`, `__int128`, etc.) the same algorithm works \u2013 just use an appropriate type for the variables.", "Below is a concise yet fully\u2011featured implementation of the classic **Greatest Common Divisor (GCD)** routine.  \nIt works for any pair of (signed or unsigned) integral values, handles the\nspecial case of zero automatically, and is written in a style that is easy\nto read and easy to copy\u2011paste into your own projects.\n\n```cpp\n#include <cassert>\n#include <cstdint>\n\n// ---------------------------------------------------------------------\n//  greatest_common_divisor\n//\n//  Returns the greatest common divisor (GCD) of two signed 64\u2011bit\n//  integers.  The function follows the Euclidean algorithm, which is\n//  O(log\u202fmin(|a|,|b|)) in time and constant extra space.\n//\n//  Parameters\n//      a \u2013 first integer (may be negative)\n//      b \u2013 second integer (may be negative)\n//\n//  Returns\n//      The non\u2011negative GCD of |a| and |b|. If both a and b are 0,\n//      the function returns 0 (the convention used by the C++17\n//  std::gcd implementation).  This matches the behaviour of the\n//  standard library function and keeps the implementation tidy.\n//\n//  Notes\n//      \u2022 We use std::int64_t to make the type explicit, but the\n//        algorithm works for any integral type that supports\n//        division and the modulus operator.  For brevity the\n//        template\u2011based approach (std::gcd) is omitted here.\n//\n//      \u2022 No recursion is used; an iterative loop is employed to\n//        avoid stack usage and provide clear control flow.\n//\n//  Examples\n//      greatest_common_divisor(3, 5)   == 1\n//      greatest_common_divisor(25, 15) == 5\n// ---------------------------------------------------------------------\nlong long greatest_common_divisor(long long a, long long b)\n{\n    // Make both numbers non\u2011negative \u2013 gcd is invariant under sign\n    a = a < 0 ? -a : a;\n    b = b < 0 ? -b : b;\n\n    // The standard Euclidean algorithm.\n    while (b != 0) {\n        long long tmp = a % b;\n        a = b;\n        b = tmp;\n    }\n    return a;              // 0 if both a and b were 0\n}\n```\n\n### Why this version?\n\n| Feature | Description |\n|---------|-------------|\n| **Iterative** | No recursion \u2013 safer for large numbers |\n| **Signed input support** | Handles negative numbers gracefully |\n| **Zero\u2010case** | Returns 0 when both inputs are zero, matching std::gcd |\n| **Testable** | You can use the assertions below to verify functionality |\n\n```cpp\nint main() {\n    assert(greatest_common_divisor(3, 5) == 1);\n    assert(greatest_common_divisor(25, 15) == 5);\n    assert(greatest_common_divisor(-8, 12) == 4);\n    assert(greatest_common_divisor(0, 0) == 0);\n    std::cout << \"All tests passed.\\n\";\n}\n```\n\nFeel free to drop the function into any .cpp file that includes `<cstdlib>` or `<cstdint>`. It doesn't rely on any non\u2011standard headers beyond the usual C/C++ standard library."]}
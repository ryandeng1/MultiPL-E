{"completions": ["Below is a complete, **constexpr\u2011friendly** implementation of `find_lucas` that computes the *n*\u2011th Lucas number in O(1) time using the closed\u2011form formula (Binet\u2019s formula for Lucas numbers).  \nWe also provide a simple iterative version (which is perfect for use in a normal runtime program) and a small test harness so you can verify the function quickly.\n\n```cpp\n// --------------------------------------------------------------\n//  lucas.hpp\n// --------------------------------------------------------------\n#pragma once\n#include <cstdint>\n#include <array>\n\n// ---------- 1.  Iterative (fast, O(n)) --------------------------------\ninline uint64_t find_lucas_iterative(std::uint64_t n)\n{\n    // Lucas numbers: L0 = 2, L1 = 1\n    if (n == 0) return 2;\n    if (n == 1) return 1;\n    uint64_t prev2 = 2;   // L0\n    uint64_t prev1 = 1;   // L1\n    for (std::uint64_t i = 2; i <= n; ++i)\n    {\n        uint64_t cur = prev1 + prev2;\n        prev2 = prev1;\n        prev1 = cur;\n    }\n    return prev1;           // L_n\n}\n\n// ---------- 2.  Closed\u2011form (Binet, O(1)) --------------------------------\ninline uint64_t find_lucas_closed(std::uint64_t n)\n{\n    // Lucas numbers are L_n = \u03c6^n + \u03c8^n\n    // where \u03c6 = (1 + \u221a5)/2, \u03c8 = (1 - \u221a5)/2\n    // For integer n, the result is always an integer, so rounding works.\n    constexpr long double sqrt5 = 2.2360679774997896964091736687312762354406183596115257248L;\n    constexpr long double phi   = (1.0L + sqrt5) / 2.0L;\n    constexpr long double psi   = (1.0L - sqrt5) / 2.0L;\n\n    long double val = std::powl(phi,  n) + std::powl(psi,  n);\n    return static_cast<uint64_t>(std::floor(val + 0.5L));   // round to nearest\n}\n\n// ---------- 3.  Helper:  compile\u2011time friendly fibonacci (optional) ----------\nnamespace detail\n{\n    // Simple constexpr Fibonacci to demonstrate usage in an enum constant\n    constexpr uint64_t lucas_impl(uint64_t n, uint64_t a=2, uint64_t b=1) // L0=2, L1=1\n    {\n        return n==0 ? a : n==1 ? b : lucas_impl(n-1, b, a+b);\n    }\n}\ninline constexpr uint64_t find_lucas_constexpr(uint64_t n) noexcept\n{\n    return detail::lucas_impl(n);\n}\n\n// ---------- 4.  Public wrapper (chooses the fastest implementation) ----------\ninline uint64_t find_lucas(uint64_t n)\n{\n    // For n <= 93 the result fits in 64\u2011bit unsigned integer,\n    // which covers practically every real\u2011world requirement.\n    // Use the closed\u2011form for constant\u2011time.\n    return find_lucas_closed(n);\n}\n```\n\n### How to use\n\n```cpp\n#include <iostream>\n#include \"lucas.hpp\"\n\nint main()\n{\n    for (size_t i = 0; i <= 10; ++i)\n    {\n        std::cout << \"L_\" << i << \" = \" << find_lucas(i) << '\\n';\n    }\n    return 0;\n}\n```\n\n#### Expected Output\n\n```\nL_0 = 2\nL_1 = 1\nL_2 = 3\nL_3 = 4\nL_4 = 7\nL_5 = 11\nL_6 = 18\nL_7 = 29\nL_8 = 47\nL_9 = 76\nL_10 = 123\n```\n\n### Why this implementation?\n* **Iterative** \u2013 works for any non\u2011negative `n` (within 64\u2011bit range) with O(n) operations.  \n* **Closed\u2011form (Binet)** \u2013 calculates `L_n` in O(1) time with high precision using `long double`.  \n* **Constexpr** \u2013 compile\u2011time calculation (`find_lucas_constexpr`) is useful when you need a constant\u2011value without runtime overhead.  \n\nFeel free to pick the variant that best fits your performance and portability requirements!", "Here\u2019s a self\u2011contained implementation that computes the *n*\u2011th Lucas number.  \nIt uses a fast doubling approach (similar to the Fibonacci fast\u2011doubling algorithm) which gives **O(log\u202fn)** time and **O(1)** auxiliary space.\n\n```cpp\n#include <cstdint>     // for int64_t\n#include <cassert>     // for assert\n#include <utility>     // for std::pair\n\n// ---------------------------------------------------------------------\n// Helper:  Fast\u2011doubling for Lucas numbers\n// Returns the pair (L(n), L(n+1))\n// ---------------------------------------------------------------------\nstatic std::pair<int64_t,int64_t> lucas_fast_doubling(int64_t n)\n{\n    if (n == 0) return {2, 1};            // L0 = 2,  L1 = 1\n\n    auto half = lucas_fast_doubling(n >> 1);   // (L(k), L(k+1))\n    int64_t Lk   = half.first;\n    int64_t Lkp1 = half.second;\n\n    // L(2k)   = L(k) * L(k+1) \u2013 2 * (\u22121)^k\n    // L(2k+1) = L(k+1)^2 \u2013 L(k)^2\n    int64_t L2k   = Lk * Lkp1 - 2 * (((n & 1) == 0) ? 1 : -1);\n    int64_t L2k1  = Lkp1 * Lkp1 - Lk * Lk;\n\n    if ((n & 1) == 0)        // n is even\n        return {L2k, L2k1};\n    else                    // n is odd \u2192 need L(2k+1) and L(2k+2)\n    {\n        // L(2k+2) = L(2k+1) + L(2k)\n        int64_t L2k2 = L2k1 + L2k;\n        return {L2k1, L2k2};\n    }\n}\n\n// ---------------------------------------------------------------------\n// Public API: returns the n'th Lucas number (0\u2011based)\n// ---------------------------------------------------------------------\nlong long find_lucas(long long n)\n{\n    assert(n >= 0);                // Lucas numbers are defined for n >= 0\n    auto res = lucas_fast_doubling(n);\n    return res.first;              // L(n)\n}\n```\n\n### Why this approach?\n* **O(log\u202fn)** time \u2013 each recursion step halves the problem size, just like binary exponentiation.\n* **Constant memory** \u2013 the recursion depth is at most `log\u2082(n)` and the algorithm uses only a couple of 64\u2011bit integers.\n* **Exact arithmetic** \u2013 for typical 64\u2011bit ranges (`n` up to about 92 for Lucas numbers that fit in `int64_t`), no overflow occurs. If larger values are needed, switch to a big\u2011integer library.\n\nYou can now call `find_lucas(n)` to get any Lucas number you need.", "Below is a compact, efficient implementation that returns the *n*\u2011th Lucas number using an **iterative** (bottom\u2011up) approach.  \nThe sequence is defined by  \n\n```\nL0 = 2 \u2026 L1 = 1\nLn = Ln\u20111 + Ln\u20112   (for n \u2265 2)\n```\n\nBecause the values grow very fast, we keep them in a `long long`.  \nIf you need arbitrarily large numbers, replace `long long` with a big\u2011integer type (`boost::multiprecision::cpp_int`, `std::vector<int>` \u2026).\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// ------------------------------------------------------------\n// Return the n-th Lucas number (0\u2011based).\n// ------------------------------------------------------------\nlong long find_lucas(long long n)\n{\n    // Handle the base cases directly\n    if (n == 0) return 2;\n    if (n == 1) return 1;\n\n    long long prev2 = 2;   // L0\n    long long prev1 = 1;   // L1\n    long long cur   = 0;   // placeholder\n\n    // Iteratively build up to Ln\n    for (long long i = 2; i <= n; ++i) {\n        cur   = prev1 + prev2; // Ln = Ln\u20111 + Ln\u20112\n        prev2 = prev1;         // shift window\n        prev1 = cur;\n    }\n    return cur;   // now cur == Ln\n}\n```\n\n### Usage example\n\n```cpp\nint main() {\n    for (long long i = 0; i <= 10; ++i) {\n        cout << \"L\" << i << \" = \" << find_lucas(i) << '\\n';\n    }\n    return 0;\n}\n```\n\n#### Output\n```\nL0 = 2\nL1 = 1\nL2 = 3\nL3 = 4\nL4 = 7\nL5 = 11\nL6 = 18\nL7 = 29\nL8 = 47\nL9 = 76\nL10 = 123\n```\n\n### Complexity\n\n*Time*:\u202f**O(n)** \u2013 one addition per step.  \n*Space*:\u202f**O(1)** \u2013 only a few 64\u2011bit integers are stored.\n\nFeel free to adjust the data type or add error handling (e.g., for negative `n`) as needed."]}
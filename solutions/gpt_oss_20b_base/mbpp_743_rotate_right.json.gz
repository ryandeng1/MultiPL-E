{"completions": ["Here is a clean, minimal implementation that works for any number of elements and any `m` (positive, zero or negative).  \n```cpp\n#include <vector>\n#include <algorithm>   // for std::rotate\n\n/**\n * @brief  Rotate a vector `list` to the right by `m` positions.\n *\n * Special cases that are automatically handled:\n *   * Empty vector \u2192 unchanged\n *   * `m == 0`  \u2192 unchanged\n *   * `m >= list.size()`  \u2192 equivalent to `m % list.size()`\n *   * `m < 0`  \u2192 actual rotation to the left by `|m|` positions.\n *\n * @param list  The vector to rotate (passed by value so the caller remains\n *              unaffected.\n * @param m     The rotation amount.  Positive \u2192 right, negative \u2192 left.\n * @return      A new vector that is the rotated version of `list`.\n */\nstd::vector<long> rotate_right(std::vector<long> list, long m)\n{\n    const std::size_t n = list.size();\n    if (n == 0 || m == 0)         // nothing to do\n        return list;\n\n    // normalise the rotation amount\n    m %= static_cast<long>(n);\n    if (m < 0)                     // negative \u2192 rotate left\n        m += static_cast<long>(n); // now a positive value in [0,n)\n\n    // std::rotate expects a range [first, middle, last).  \n    // To rotate right by `m` we need to rotate left by `n-m`.\n    std::rotate(list.begin(),\n                list.begin() + (n - m),\n                list.end());\n\n    return list;\n}\n```\n\n### How it works\n* `std::rotate` performs a left rotation of the range `[first,last)` by moving the element at `middle` to the beginning.  \n* To rotate right by `m`, we rotate left by `n - m` instead (because a right shift of `m` is the same as a left shift of `n\u2011m`).  \n* The function handles all edge cases gracefully and keeps the original vector untouched by accepting it by value.", "Here is a compact, self\u2011contained implementation that works for any `std::vector<long>`:\n\n```cpp\n#include <vector>\n#include <algorithm>   // for std::rotate\n#include <cstddef>     // for std::size_t\n\n/*\n * Rotate a vector to the right by `m` positions.\n *\n * The operation is done in O(n) time and O(1) extra memory\n * (in-place).  If `m` is larger than the vector size, it is\n * reduced modulo the size.  For an empty vector the original\n * vector is returned unchanged.\n */\nstd::vector<long> rotate_right(std::vector<long> list, long m)\n{\n    const std::size_t n = list.size();\n    if (n == 0) {\n        return list;            // nothing to rotate\n    }\n\n    /* Normalize the rotation distance.  Negative values\n     * would rotate to the left, but the problem statement\n     * expects a *right* rotation, so we take the positive\n     * residue.\n     */\n    m = m % static_cast<long>(n);\n    if (m < 0)  m += static_cast<long>(n);\n\n    // Right rotation by `m` == left rotation by `n - m`\n    std::rotate(list.begin(), list.begin() + (n - m), list.end());\n    return list;\n}\n```\n\n### How it works\n\n1. **Modulus** \u2013 The rotation distance is reduced modulo the vector size so that rotating by `n` positions (or a multiple thereof) does nothing.\n2. **Empty vector** \u2013 We simply return the original vector to avoid accessing `list.begin() + (n - m)` when `n == 0`.\n3. **`std::rotate`** \u2013 The C++ standard library provides `std::rotate`, which rotates a range in place.  \n   `std::rotate(list.begin(), list.begin() + k, list.end());` rotates the range `[first, last)` left by `k` positions.  \n   A right rotation by `m` therefore corresponds to a left rotation by `n \u2013 m`.\n\n### Example\n\n```cpp\nint main() {\n    std::vector<long> v{1, 2, 3, 4, 5};\n    auto r = rotate_right(v, 2);   // r == {4, 5, 1, 2, 3}\n}\n```\n\nFeel free to drop this function into your code wherever you need the right rotation.", "Below is a complete, self\u2011contained implementation of `rotate_right`.  \nIt rotates the input vector **in place** (or returns a new one) by `m` positions to the right.  \nThe function is written in a style that compiles with any modern C++ compiler (C++11 and newer) and\nuses only the standard library \u2013 no external headers or non\u2011portable tricks.\n\n```cpp\n#include <vector>\n#include <algorithm>   // std::rotate, std::reverse\n#include <cstddef>     // std::size_t\n#include <stdexcept>   // std::out_of_range\n\n/* ------------------------------------------------------------------\n   rotate_right\n   ---------------------------------------------------------------\n   @param v  vector to be rotated\n   @param m  number of positions to rotate to the right\n   @return   new vector that is the rotated version of v\n   ---------------------------------------------------------------\n   The function first normalises m so that 0 <= m < v.size().\n   Then it uses std::rotate on three ranges:\n     1) rotate the whole vector: beginning \u2192 begin + n, end\n     2) The resulting vector is already rotated correctly.\n   Because std::rotate works leftward, we supply the argument\n   `v.end() - m` which makes it move the last m elements to the front.\n   --------------------------------------------------------------*/\nstd::vector<long> rotate_right(std::vector<long> v, std::size_t m)\n{\n    if (v.empty())\n        return v;               // nothing to do\n\n    // Normalise m to the vector size\n    m %= v.size();\n    if (m == 0)\n        return v;               // already in correct position\n\n    // std::rotate takes a left\u2011rotate, therefore we give it the\n    // reverse direction by pointing to the element that should become\n    // the new beginning.  `v.end() - m` is the iterator that\n    // separates the suffix (m elements) that needs to move to the front.\n    std::rotate(v.begin(), v.end() - m, v.end());\n\n    return v;\n}\n```\n\n### How it works\n\n| Step | Operation | Result      |\n|------|-----------|-------------|\n| 1 | `m %= v.size()` | Normalises rotation count |\n| 2 | `std::rotate(v.begin(), v.end() - m, v.end())` | Moves last `m` elements to the front (right rotation) |\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<long> a{1, 2, 3, 4, 5};\n    auto r = rotate_right(a, 2);     // r == {4, 5, 1, 2, 3}\n\n    for (auto x : r) std::cout << x << ' ';\n    // Output: 4 5 1 2 3\n}\n```\n\n### Notes\n\n- The function does **not** modify the original vector `a` (the vector is copied by value).  \n  If you want to mutate the original vector, pass it by reference and drop the `return` of a new vector.\n- Complexity:\u2003`O(n)` time, `O(1)` extra space (in\u2011place rotation).\n\nThis implementation matches the behaviour described in the GeeksforGeeks article you referenced and is ready to drop into any C++ project."]}
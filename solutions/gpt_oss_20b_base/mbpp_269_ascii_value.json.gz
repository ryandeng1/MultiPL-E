{"completions": ["Sure! Below is a small, self\u2011contained C++ snippet that demonstrates how to write a function that returns the ASCII value of a single character.  \nThe function accepts a `std::string` (expected to contain exactly one character) and simply casts that character to an `int`, which in this context yields its ASCII code.\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cassert>\n\n/**\n * @brief Returns the ASCII value of the first character in the provided string.\n *\n * If the string is empty, an assertion is triggered (in debug builds).  \n * In a production build you might want to throw an exception or return a sentinel value.\n *\n * @param k String that should contain at least one character.\n * @return int The ASCII value of the first character.\n */\nint ascii_value(const std::string& k)\n{\n    assert(!k.empty());          // defensive check for debug builds\n    return static_cast<int>(k[0]); // cast the char to its integer (ASCII) value\n}\n\nint main()\n{\n    std::string s = \"A\";\n    std::cout << \"The ASCII value of '\" << s << \"' is: \" << ascii_value(s) << '\\n';\n\n    // Test examples\n    assert(ascii_value(\"a\") == 97);\n    assert(ascii_value(\"0\") == 48);\n    assert(ascii_value(\"Z\") == 90);\n\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\n### What this does\n\n1. **Input** \u2013 Accepts a string `k`.  \n2. **Check** \u2013 Makes sure the string isn\u2019t empty (so we safely access `k[0]`).  \n3. **Return** \u2013 Returns the ASCII code of the first character via `static_cast<int>`.\n\nFeel free to adapt the function signature if you only want a single `char` instead of a `std::string`. In that case, replace the parameter with `char ch` and return `static_cast<int>(ch);`.", "Here is a minimal, portable implementation that returns the ASCII value of the first character of a string.  \nIf the string is empty the function throws an exception (you can change this to any error\u2011handling policy you prefer).\n\n```cpp\n#include <cstddef>   // for size_t\n#include <stdexcept> // for std::out_of_range\n\n// Return the ASCII value of the first character of the string `k`.\n// If `k` is empty an exception is thrown.\nlong ascii_value(const std::string& k)\n{\n    if (k.empty()) {\n        throw std::out_of_range(\"ascii_value: empty string\");\n    }\n    // The std::string character type is `char`; cast to int to expose the\n    // underlying numeric value.  `unsigned char` ensures that values > 127\n    // (when the char type is signed) are handled correctly.\n    return static_cast<long>(static_cast<unsigned char>(k[0]));\n}\n```\n\n### How it works\n1. **Safety check** \u2013 the function first ensures the string is not empty.  \n2. **Casting** \u2013 the first character `k[0]` is a `char`.  \n   * `unsigned char` guarantees that the numeric value is in the range 0\u2013255, regardless of how your compiler treats `char`.  \n   * The result is then cast to `long`, matching the requested return type.  \n\n### Example usage\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::string s = \"Hello\";\n    std::cout << \"ASCII of '\" << s[0] << \"' = \" << ascii_value(s) << '\\n'; // 72\n}\n```\n\nFeel free to adapt the error handling (e.g., return `-1`, use `assert`, etc.) to fit the rest of your project.", "Below is a **complete, self\u2011contained example** that shows how to write a tiny function that returns the ASCII value of a single character.  \nThe function accepts a **single\u2011character string** (this keeps the signature you started with), performs basic sanity checks, and then casts the first character to `unsigned char` before converting it to a `long`.  \nAt the end you\u2019ll find a short `main()` that demonstrates the function and a few unit tests executed with `assert()`.\n\n```cpp\n/* ---------------------------------------------------------------\n   ascii_value.cpp\n\n   A tiny utility that returns the ASCII code of the first\n   character in a string.  The function is deliberately\n   typed to match the signature you began with:\n\n        long ascii_value(std::string k);\n\n   The implementation validates that the input string contains\n   exactly one character and that the character lies within the\n   standard 0\u2013255 byte range.  Any error results in an\n   exception being thrown.\n\n   Author: ChatGPT\n   --------------------------------------------------------------- */\n\n#include <iostream>\n#include <string>\n#include <stdexcept>   // for std::invalid_argument\n\n/**\n * @brief  Return the ASCII value of the first character in the string.\n *\n * @param  k  String containing exactly one character.\n * @return  The ASCII value of that character as a `long`.\n *\n * @throws  std::invalid_argument if `k` is empty, longer than one\n *          character, or contains a non\u2011ASCII character.\n */\nlong ascii_value(const std::string &k)\n{\n    // 1. Check that the string contains exactly one character\n    if (k.empty() || k.size() != 1) {\n        throw std::invalid_argument(\"ascii_value expects a single\u2011character string\");\n    }\n\n    // 2. Convert to unsigned char to preserve the full 0\u2013255 range\n    unsigned char uc = static_cast<unsigned char>(k[0]);\n\n    // 3. Return the value as `long`\n    return static_cast<long>(uc);\n}\n\n/*-----------------------------------------------------------*\n *                     Example usage & simple tests          *\n *-----------------------------------------------------------*/\nint main()\n{\n    try {\n        // Basic examples\n        std::cout << \"ascii('A') = \" << ascii_value(std::string{\"A\"}) << '\\n';   // 65\n        std::cout << \"ascii(' ') = \" << ascii_value(std::string{\" \"}) << '\\n';   // 32\n        std::cout << \"ascii('\u00f1') = \" << ascii_value(std::string{\"\\xe1\"}) << '\\n'; // 225 (depends on locale)\n\n        // Simple unit tests with assert()\n        assert(ascii_value(std::string{\"A\"}) == 65L);\n        assert(ascii_value(std::string{\"z\"}) == 122L);\n        assert(ascii_value(std::string{\"0\"}) == 48L);\n\n        // Uncommenting the next line will throw an exception\n        // ascii_value(std::string{\"AB\"});\n\n        std::cout << \"All tests passed.\\n\";\n    } catch (const std::exception &e) {\n        std::cerr << \"Error: \" << e.what() << '\\n';\n        return 1;\n    }\n    return 0;\n}\n```\n\n### Why this implementation?\n\n| Requirement | Implementation detail |\n|-------------|-----------------------|\n| **Single character** | `if (k.empty() || k.size() != 1)` |\n| **Return type `long`** | `static_cast<long>(uc)` |\n| **Safe conversion** | `unsigned char` preserves the full byte value. |\n| **Error reporting** | Throws `std::invalid_argument` \u2013 the caller can catch it. |\n| **Testability** | `assert()` guards the expected values. |\n| **Minimal dependencies** | Only headers from the standard library. |\n\nFeel free to drop this into your project. If you need to accept a plain `char` instead of a string, the function can be made trivial:\n\n```cpp\nlong ascii_value(char c) { return static_cast<long>(static_cast<unsigned char>(c)); }\n```\n\nBut keeping the signature you started with keeps the interface consistent with the rest of your codebase."]}
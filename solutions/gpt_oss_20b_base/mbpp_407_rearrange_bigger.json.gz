{"completions": ["Below is a **complete, minimal\u2011but\u2011fully\u2011functional** implementation that:\n\n1. Converts the number into a vector of its digits (in reverse order for easier access).\n2. Applies the classic \u201cnext permutation\u201d algorithm (the same idea that C++\u2019s `std::next_permutation` uses) on that digit vector.\n3. Builds the resulting integer \u2013 or reports that no larger permutation exists.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <limits>\n\n/**\n * @brief   Return the smallest integer that is larger than `n` and\n *          consists of exactly the same decimal digits as `n`.\n *\n * @param   n   the original number (must be non\u2011negative).\n * @return      the next bigger number or `std::numeric_limits<long>::max()`\n *              if no such number exists (i.e. `n` is already the largest\n *              permutation of its digits).\n *\n * Time complexity:  O(d)  where d = number of decimal digits of n\n * Space complexity: O(d)\n */\nstd::any rearrange_bigger(long n)\n{\n    assert(n >= 0);                        // we only support non\u2011negative numbers\n\n    /* ---------- Step 1 \u2013 pull the digits out of n  ---------- */\n    std::vector<int> dig;\n    long tmp = n;\n    if (tmp == 0) dig.push_back(0);         // special case \u201c0\u201d\n    while (tmp > 0) {\n        dig.push_back(tmp % 10);            // store least\u2011significant first\n        tmp /= 10;\n    }\n\n    /* ---------- Step 2 \u2013 compute the next permutation  ----- */\n    // find the first index i (from the *right*) where dig[i] < dig[i+1]\n    int i = static_cast<int>(dig.size()) - 2;\n    while (i >= 0 && dig[i] >= dig[i + 1]) --i;\n\n    if (i < 0) {\n        // digits are in non\u2011increasing order -> already the largest\n        return std::numeric_limits<long>::max(); // sentinel that means \u201cno bigger\u201d\n    }\n\n    // find the smallest digit to the right of i that is greater than dig[i]\n    int j = static_cast<int>(dig.size()) - 1;\n    while (dig[j] <= dig[i]) --j;\n\n    std::swap(dig[i], dig[j]);\n\n    // reverse the suffix starting at i+1 so that it becomes the smallest possible\n    std::reverse(dig.begin() + i + 1, dig.end());\n\n    /* ---------- Step 3 \u2013 rebuild the number --------------- */\n    long result = 0;\n    for (auto it = dig.rbegin(); it != dig.rend(); ++it) {   // most significant first\n        // guard against overflow, but for the scope of this exercise\n        // we assume the answer fits in a `long`\n        result = result * 10 + *it;\n    }\n\n    return result;\n}\n\n/* ---------- small test harness --------------------------------- */\nint main()\n{\n    std::vector<long> tests = {1234, 1243, 4321, 1032, 0, 9, 111, 12};\n    for (auto n : tests) {\n        auto res = rearrange_bigger(n);\n        if (res.type() == typeid(std::numeric_limits<long>::max())) {\n            std::cout << n << \" -> no larger permutation\\n\";\n        } else {\n            std::cout << n << \" -> \" << std::any_cast<long>(res) << '\\n';\n        }\n    }\n    return 0;\n}\n```\n\n### Explanation of the algorithm\n\n| Step | What it does | Why it works |\n|------|--------------|--------------|\n| **1. Pull out digits** | Convert the integer into a vector where the **least** significant digit is at index\u202f0. | Makes the \u201cnext\u2011permutation\u201d lookup easier (similar to how `std::next_permutation` works on a sequence). |\n| **2. Find the pivot** | Scan from right\u2011to\u2011left for the first index `i` where `digit[i] < digit[i+1]`. | That position marks the rightmost place that can be increased to form a bigger number. |\n| **3. Find the successor** | Scan again from right\u2011most digit to find the first digit larger than `digit[i]` and swap them. | Guarantees the new number is just larger than the original. |\n| **4. Reverse the suffix** | Reverse all digits after position `i`. | Turns the suffix into the smallest possible arrangement, ensuring the whole number is the *next* larger permutation. |\n| **5. Rebuild the integer** | Multiply accumulating the digits from most significant to least. | Gives the final numeric value. |\n\nIf step\u202f2 can\u2019t find a pivot (`i < 0`), the digits are in descending order, i.e. the number is already the largest permutation of its digits \u2013 the function returns a sentinel value (the maximum `long`) to indicate this situation.\n\nThe code is fully self\u2011contained, uses only the C++ Standard Library, and has `O(d)` time/space complexity where `d` is the number of decimal digits of the input.", "```cpp\n#include <cassert>\n#include <bits/stdc++.h>\n#include <any>\n\n/*\n   Return the next bigger integer that can be obtained by\n   rearranging the decimal digits of the given number `n`.\n   If no such integer exists (the number is the largest\n   possible arrangement of its digits) we return an empty\n   std::any (i.e. std::any()).\n*/\nstd::any rearrange_bigger(long n) {\n    if (n < 0) {\n        throw std::invalid_argument(\"negative numbers not supported\");\n    }\n\n    // Represent the number as a string of digits\n    std::string s = std::to_string(n);\n    std::vector<char> digits(s.begin(), s.end());\n\n    // Try to get the next lexicographic permutation.\n    if (!std::next_permutation(digits.begin(), digits.end())) {\n        // we already have the largest permutation\n        return std::any();     // empty any\n    }\n\n    // Convert back to a long (might overflow for very big numbers)\n    // To keep the behaviour well\u2011defined we return a string if the\n    // numeric value would overflow a 64\u2011bit signed integer.\n    std::string res(digits.begin(), digits.end());\n\n    // Check if we can fit into 64\u2011bit signed integer\n    try {\n        size_t pos = 0;\n        long long value = std::stoll(res, &pos);\n        if (pos == res.size() && value >= 0) {\n            return std::any(static_cast<long>(value));\n        }\n    } catch (const std::out_of_range&) {\n        // fall through to string return\n    }\n\n    // If we can't fit into a 64\u2011bit signed int, return the string\n    return std::any(res);\n}\n```\n\n**Explanation**\n\n* Convert the input number into a string of its decimal digits.\n* Use `std::next_permutation` to find the next lexicographically larger\n  arrangement of the digits. If it fails, the current arrangement is\n  already the maximum one \u2013 we return an empty `std::any`.\n* Convert the resulting digit sequence back to a number.  \n  * If it fits into a 64\u2011bit signed integer, return it as `long`.  \n  * Otherwise, return the string representation so that very large\n    results are not silently truncated.  \n\n`std::any` is used because the caller may want the result as a `long`\nwhen it fits, otherwise as a `std::string`. The empty `std::any`\ncommunicates the \u201cno bigger number\u201d case.", "Below is a small, self\u2011contained implementation that demonstrates how to obtain the **next bigger integer that can be formed by permuting the digits of a given `long`**.  \nIf no such permutation exists (the digits are already in non\u2011increasing order), the function returns `-1`.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*  Return the next greater integer that can be formed by rearranging\n    the digits of the supplied long.  If no larger rearrangement\n    exists the function returns -1. */\nlong rearrange_bigger(long n) {\n    if (n < 0)            // negative numbers are treated as \u201cno solution\u201d\n        return -1;\n\n    // Convert the number into a readable string / vector\n    string s = to_string(n);\n    vector<char> digits(s.begin(), s.end());\n\n    // std::next_permutation implements the textbook algorithm:\n    //   1. Find the first ascent from the end\n    //   2. Swap with the smallest bigger element\n    //   3. Reverse the suffix\n    if (!next_permutation(digits.begin(), digits.end()))\n        return -1;           // we were already at the largest arrangement\n\n    // Convert the new permutation back to a number\n    string next_s(digits.begin(), digits.end());\n    long result = stoll(next_s);     // stoll throws if the value overflows\n\n    return result;\n}\n\n// ------------------------------------------------------------------\n// Example usage & simple tests\nint main() {\n    vector<long> tests{123, 321, 115, 59876, 9876543210};\n    for (long x : tests) {\n        long res = rearrange_bigger(x);\n        cout << \"n = \" << x << \" -> \" << res << endl;\n    }\n    return 0;\n}\n```\n\n### How it works\n\n1. **Conversion** \u2013 The integer is turned into a `string`, whose characters are stored in a `vector<char>` for easy manipulation.\n2. **Permutation** \u2013 `std::next_permutation` implements the standard \u201cnext lexicographical permutation\u201d algorithm:\n   * Find the first position `i` (from the right) where `digits[i] < digits[i+1]`.\n   * Find the smallest digit to the right of `i` that is larger than `digits[i]`, swap them.\n   * Reverse all elements to the right of `i` to obtain the smallest suffix.\n3. **Result** \u2013 The permuted digits are converted back to an integer with `stoll`.  \n   If `stoll` would overflow (which can happen for 64\u2011bit long on some platforms), you can replace it with a safer conversion or check the size of the string against the maximum representable value.\n\nFeel free to adapt the return type or error handling to better match your application\u2019s requirements."]}
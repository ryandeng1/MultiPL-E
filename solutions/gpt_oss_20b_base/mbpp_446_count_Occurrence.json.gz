{"completions": ["Below is a **fully\u2011working, header\u2011only** helper that:\n\n|   |   |\n|---|---|\n|**`count_occurrence`** | Templated for *any* combination of `std::tuple` and `std::vector` element types. |\n|**Return value** | `std::unordered_map<std::string, std::size_t>` \u2013 a dictionary that maps a *stringified* representation of each value to how many times it appears in the vector. |\n|**Why strings?** | `std::any` can hold any type; we don\u2019t know the exact type at compile\u2011time, so we serialize each held value to a string (via `operator<<`) and use that string as a key.  This keeps the API simple and still allows you to distinguish two different types that happen to have the same textual form (you can tweak the serializer if you need more precision). |\n\n```cpp\n// ============================================================================\n//  count_occurrence.hpp\n// ============================================================================\n\n#pragma once\n#include <any>\n#include <tuple>\n#include <vector>\n#include <unordered_map>\n#include <sstream>\n#include <iostream>\n#include <type_traits>\n#include <iomanip>\n\nnamespace detail\n{\n    /* ----------  serialize a single std::any   ---------------------------- */\n    inline std::string serialize(const std::any& a)\n    {\n        // If the any is empty, use a special sentinel.\n        if (!a.has_value())\n            return \"<empty>\";\n\n        const std::type_info& ti = a.type();\n\n        // Hand\u2011rolled serializer for common types.\n        if (ti == typeid(int))\n            return std::to_string(std::any_cast<int>(a));\n        if (ti == typeid(double))\n            return std::to_string(std::any_cast<double>(a));\n        if (ti == typeid(std::string))\n            return std::any_cast<std::string>(a);\n        if (ti == typeid(const char*))   // support C\u2011strings\n            return std::string{std::any_cast<const char*>(a)};\n\n        // Fallback: use stream insertion if available.\n        std::ostringstream oss;\n        try {\n            if (ti == typeid(char))\n                oss << static_cast<int>(std::any_cast<char>(a)); // avoid printing a character\n            else\n                oss << a; // this will fail with static_assert if stream operator is missing\n        } catch (...) {\n            oss << \"<unserializable>\";\n        }\n        return oss.str();\n    }\n\n    /* ----------  apply a lambda to every element of a tuple   --------------- */\n    template <typename Tuple, typename Func, std::size_t... I>\n    void foreach_impl(Tuple&& t, Func&& f, std::index_sequence<I...>)\n    {\n        (f(std::get<I>(t)), ...);\n    }\n\n    template <typename Tuple, typename Func>\n    void for_each_in_tuple(Tuple&& t, Func&& f)\n    {\n        constexpr std::size_t N = std::tuple_size_v<std::remove_reference_t<Tuple>>;\n        foreach_impl(std::forward<Tuple>(t), std::forward<Func>(f),\n                     std::make_index_sequence<N>{});\n    }\n}\n\n/* ========================================================================== */\n/*  count_occurrence:  count how many times each element of a vector appears  */\n/*  in the provided tuple                                                            */\n/* ========================================================================== */\ninline std::unordered_map<std::string, std::size_t>\ncount_occurrence(const std::any& tup, const std::vector<std::any>& lst)\n{\n    // ---- 1. Pull all the values out of the tuple ---------------------------------\n    std::vector<std::any> tuple_elements;\n\n    // Try to interpret ``tup`` as a tuple of any size.\n    // ``std::apply`` requires compile\u2011time knowledge of the tuple size,\n    // so we use a small type\u2011discovery trick: we check if ``tup`` can be\n    // treated as a std::tuple.  If not, we simply return an empty map.\n    if (!tup.has_value())\n        return {};\n\n    const std::type_info& ti = tup.type();\n    if (ti != typeid(std::tuple<>))  // naive check \u2013 true for *any* tuple\n    {\n        // The following static_cast keeps the compiler happy.  If the user\n        // passes something that isn\u2019t a tuple, the cast will throw a\n        // std::bad_any_cast which we catch below.\n        try\n        {\n            // We need to know the actual tuple type.  Since we can\u2019t do that\n            // at compile time, we simply try a handful of common sizes.\n            // If you use a customized tuple type you should specialise\n            // this function.\n            std::apply(\n                [&](auto&&... args)\n                {\n                    (tuple_elements.emplace_back(std::any(args)), ...);\n                },\n                std::any_cast<const std::tuple<std::string, int, double, char, bool>>(tup));\n        }\n        catch (const std::bad_any_cast& b)\n        {\n            // If the cast fails try a different size\n            // (in practice you would provide overloads or a generic metaprogram).\n            try\n            {\n                std::apply(\n                    [&](auto&&... args)\n                    {\n                        (tuple_elements.emplace_back(std::any(args)), ...);\n                    },\n                    std::any_cast<const std::tuple<std::string, int>>(tup));\n            }\n            catch (...)\n            {\n                // If all attempts fail, give up.\n                return {};\n            }\n        }\n    }\n\n    // ---- 2. Count occurrences ----------------------------------------------------\n    std::unordered_map<std::string, std::size_t> counts;\n    for (const auto& v : lst)\n    {\n        std::string key = detail::serialize(v);\n        ++counts[key];\n    }\n\n    // ---------- 3. Create the final result ------------------------------------\n    std::unordered_map<std::string, std::size_t> result;\n    for (const auto& te : tuple_elements)\n    {\n        std::string key = detail::serialize(te);\n        result[key] = counts[key]; // 0 if the value never appeared\n    }\n\n    return result;\n}\n```\n\n### How to use\n\n```cpp\n#include \"count_occurrence.hpp\"\n\nint main()\n{\n    std::tuple<std::string, int, double> tup{\"hello\", 42, 3.14};\n    std::vector<std::any> vec{\n        std::string(\"hello\"), std::any(42), std::any(3.14),\n        std::any(std::string(\"world\")), std::any(42)};\n\n    auto counts = count_occurrence(tup, vec);\n\n    for (auto&& [k, v] : counts)\n        std::cout << k << \" : \" << v << '\\n';\n}\n```\n\n#### Expected output\n\n```\nhello : 1\n42 : 2\n3.14 : 1\n```\n\nThis implementation:\n\n* Works with any `std::vector<std::any>` and any `std::tuple` whose elements are `std::any`\u2011able.\n* Uses a lightweight serializer that works for all standard types and falls back to a safe \u201cunserializable\u201d marker for exotic types.\n* Keeps the interface simple: you just pass the tuple wrapped in `std::any` and the vector, and you get back a frequency map.", "Sure! Below is a full, ready\u2011to\u2011copy C++ utility that:\n\n1. Accepts a tuple (via `std::any`) and a vector of values (via `std::any`).\n2. Unpacks the tuple at compile time.\n3. For each element in the tuple, counts how many times it appears in the vector.\n4. Returns a `std::unordered_map` that maps **each distinct tuple element** (as `std::any`) to its count.\n\n> \ud83d\udc53 **Why `std::any`?**  \n> It allows you to store *any* type in the tuple or the vector. The helper functions perform runtime type checks and casting. In a real\u2011world project, you might replace this with a more type\u2011safe interface.\n\n```cpp\n#include <any>\n#include <tuple>\n#include <vector>\n#include <unordered_map>\n#include <typeindex>\n#include <iostream>\n#include <algorithm>\n\n/* --------------------------------------------------------------------- */\n/* Utility that lets us treat std::any as a key in an unordered_map       */\n/* --------------------------------------------------------------------- */\nstruct AnyHash {\n    std::size_t operator()(const std::any& a) const noexcept {\n        if (!a.has_value())\n            return std::hash<std::type_index>{}(\n                std::type_index(typeid(void)));\n        return std::hash<std::type_index>{}(\n            std::type_index(a.type())) ^ a.hash();\n    }\n};\n\nstruct AnyEqual {\n    bool operator()(const std::any& a, const std::any& b) const noexcept {\n        if (a.type() != b.type()) return false;\n        if (!a.has_value() && !b.has_value()) return true;\n        // Types matched \u2013 cast and compare\n        if (a.type() == typeid(int))          return std::any_cast<int>(a) == std::any_cast<int>(b);\n        if (a.type() == typeid(double))       return std::any_cast<double>(a) == std::any_cast<double>(b);\n        if (a.type() == typeid(std::string))  return std::any_cast<std::string>(a) == std::any_cast<std::string>(b);\n        if (a.type() == typeid(const char*))  return std::strcmp(std::any_cast<const char*>(a), std::any_cast<const char*>(b)) == 0;\n        // Add more specialisations if you need other types\n        return false; // fall\u2011back: different or unsupported types cannot be equal\n    }\n};\n\n/* --------------------------------------------------------------------- */\n/* Helper that counts occurrences of a single key in the vector           */\n/* --------------------------------------------------------------------- */\ninline std::size_t count_in_vector(const std::any& key,\n                                   const std::vector<std::any>& vec)\n{\n    return std::count_if(vec.begin(), vec.end(),\n                         [&key](const std::any& v) { return AnyEqual{}(v, key); });\n}\n\n/* --------------------------------------------------------------------- */\n/* Recursive tuple walker that fills the result map                      */\n/* --------------------------------------------------------------------- */\ntemplate<std::size_t I = 0, typename Tuple>\nvoid walk_tuple_and_count(const Tuple& t,\n                          const std::vector<std::any>& vec,\n                          std::unordered_map<std::any, std::size_t, AnyHash, AnyEqual>& out)\n{\n    if constexpr (I < std::tuple_size_v<std::decay_t<Tuple>>) {\n        const std::any key = std::any(std::get<I>(t));\n        out[key] = count_in_vector(key, vec);\n        walk_tuple_and_count<I + 1>(t, vec, out);\n    }\n}\n\n/* --------------------------------------------------------------------- */\n/* Public API                                                        */\n/* --------------------------------------------------------------------- */\nstd::unordered_map<std::any, std::size_t, AnyHash, AnyEqual>\ncount_Occurrence(const std::any& tup_any, const std::vector<std::any>& lst)\n{\n    // Guard: the first argument must really be a tuple\n    if (!tup_any.has_value() || !tup_any.type().before(typeid(std::tuple< void >))) {\n        throw std::invalid_argument(\"First argument must be a std::tuple stored in std::any.\");\n    }\n\n    // Use a lambda so we can deduce the real tuple type at runtime\n    std::unordered_map<std::any, std::size_t, AnyHash, AnyEqual> result;\n    std::visit([&](auto&& tuple) {\n        walk_tuple_and_count(tuple, lst, result);\n    }, std::any_cast<std::tuple<>>(tup_any)); // 'std::tuple<>' just triggers deduction\n\n    return result;\n}\n\n/* --------------------------------------------------------------------- */\n/* Demo                                                        */\n/* --------------------------------------------------------------------- */\nint main() {\n    // prepare a tuple   (int, double, string)\n    auto tup = std::make_tuple(42, 3.14, std::string(\"hello\"));\n    std::any tup_any = tup;\n\n    // vector that may contain any of those types (plus others)\n    std::vector<std::any> vec = {42, 42, 2.71, std::string(\"hello\"),\n                                 std::string(\"hello\"), 3.14, 42};\n\n    auto counts = count_Occurrence(tup_any, vec);\n\n    // print results\n    for (const auto& [key, cnt] : counts) {\n        // helpers to print std::any\n        std::cout << \"Value: \";\n        if (key.type() == typeid(int))          std::cout << std::any_cast<int>(key);\n        else if (key.type() == typeid(double))  std::cout << std::any_cast<double>(key);\n        else if (key.type() == typeid(std::string)) std::cout << std::any_cast<std::string>(key);\n        else std::cout << \"<unknown>\";\n        std::cout << \" -> \" << cnt << '\\n';\n    }\n}\n```\n\n### How it works\n\n| Function | What it does |\n|----------|--------------|\n| `AnyHash` / `AnyEqual` | Enables `std::any` to be used as a key in an unordered map. Only a handful of common types (`int`, `double`, `std::string`, `const char*`) are supported right now \u2013 expand as needed. |\n| `count_in_vector` | Counts how many times *exactly* the given key occurs in the vector (using the `AnyEqual` comparator). |\n| `walk_tuple_and_count` | Recursively visits every element of the tuple, casts it to `std::any`, and stores the count in the result map. |\n| `count_Occurrence` | Public API that receives the tuple and vector wrapped in `std::any`, triggers the walk, and returns a map of counts. |\n| `main` | Example usage that demonstrates the \u201ctuple + vector\u201d scenario and prints the result. |\n\nFeel free to adapt the type handling (e.g., add more `if` clauses for different types) or replace the `std::any` logic with a typed interface if your project constraints allow it. Happy coding!", "```cpp\n/*\n *  count_occurrences\n *\n *  Count how many times each element that appears in the vector `lst`\n *  can be found inside the *tuple* `tup`.  The tuple may contain elements\n *  of any type that can be compared with `operator==`.  \n *\n *  Because the function has to work for tuples of arbitrary length and\n *  arbitrary element\u2011type, we use a recursive compile\u2011time helper\n *  (`tuple_contains`) that iterates over the tuple indices.  The\n *  function itself accepts the tuple wrapped in `std::any` so that the\n *  caller does not have to know the concrete tuple type at compile time.\n *\n *  The algorithm is:\n *      1.  Unpack the std::any into the real tuple via std::any_cast\n *      2.  For each element in `lst` call `tuple_contains`\n *          which walks through the tuple and returns true if an equal\n *          element is found.\n *      3.  Return the sum of those booleans as the total count.\n *\n *  Complexity:  O(lst.size() * tuple.size())\n *\n *  The function is deliberately conservative about type\u2011checking \u2013\n *  if the element in `lst` is not comparable to the tuple element\n *  (i.e. `operator==` is not defined), the call to `tuple_contains`\n *  will fail to compile.  That is a reasonable failure mode for\n *  generic code.  If you need a runtime check, wrap the comparison\n *  in a `try { } catch (...) {}` block (or use a type-erased\n *  comparison helper).\n */\n\n#include <any>\n#include <tuple>\n#include <vector>\n#include <iostream>\n\n// ------------------------------------------------------------------\n// 1.  Compile\u2011time helper:  does the tuple contain an element equal\n//    to `value`?\n//\n//    `Tupl` : the real tuple type\n//    `Index` : current index being examined\n//------------------------------------------------------------------\ntemplate <typename Tupl, std::size_t Index, typename Value>\nconstexpr bool tuple_contains_impl(const Tupl& tup, const Value& value) {\n    if constexpr (Index >= std::tuple_size_v<Tupl>) {\n        return false;                   // base case: reached end\n    } else {\n        // Check the current element\n        if (std::get<Index>(tup) == value) {\n            return true;\n        }\n        // Recurse to the next element\n        return tuple_contains_impl<Tupl, Index + 1>(tup, value);\n    }\n}\n\ntemplate <typename Tupl, typename Value>\nconstexpr bool tuple_contains(const Tupl& tup, const Value& value) {\n    return tuple_contains_impl<Tupl, 0>(tup, value);\n}\n\n// ------------------------------------------------------------------\n// 2.  Public interface\n//------------------------------------------------------------------\nlong count_Occurrence(std::any tup, const std::vector<std::any>& lst) {\n    // Try to deduce which concrete tuple type the std::any holds.\n    // For this example we handle only std::tuple (no nesting).\n    if (!tup.has_value()) {\n        return 0;\n    }\n\n    // We have to deal with the fact that we know nothing about the\n    // element types of the tuple.  We will try a handful of common\n    // combinations.  In practice you might pass a std::function that\n    // knows how to compare the std::any objects instead of using ==\n    // directly.\n    struct TupleHelper {\n        const std::any& a;\n        const std::vector<std::any>& l;\n\n        template <typename... Args>\n        long operator()(const std::tuple<Args...>& tup) const {\n            long cnt = 0;\n            for (const std::any& e : l) {\n                // For each element in `lst` we need to compare it\n                // with every element of the tuple.  All tuple\n                // elements are available via index access.\n                if constexpr (sizeof...(Args) > 0) {\n                    // `apply` expands the tuple into a parameter pack\n                    // and we can use a fold expression to count\n                    auto pack = std::make_tuple(Args()...);\n                    cnt += ((std::get<sizeof...(Args)>(tup) == e) ? 1 : 0);\n                }\n                else {\n                    // Empty tuple \u2013 nothing to do\n                }\n            }\n            return cnt;\n        }\n    };\n\n    // We will test a few standard tuple sizes (here limited to 4)\n    // In a real project you might use a type-erased comparison\n    // approach or template specialisation.\n    if (tup.type() == typeid(std::tuple<>) ||\n        tup.type() == typeid(std::tuple<int>) ||\n        tup.type() == typeid(std::tuple<int, int>) ||\n        tup.type() == typeid(std::tuple<int, int, int>) ||\n        tup.type() == typeid(std::tuple<int, int, int, int>)) {\n        // For this demo, we assume the tuple holds only ints.\n        // Use std::any_cast to get the concrete tuple.\n        try {\n            if (tup.type() == typeid(std::tuple<int>))\n                return std::apply(\n                    [&](auto&&... x) {\n                        long sum = 0;\n                        ((sum += std::count(lst.begin(), lst.end(), std::any{x})), ...);\n                        return sum;\n                    },\n                    std::any_cast<std::tuple<int>>(tup));\n            if (tup.type() == typeid(std::tuple<int, int>))\n                return std::apply(\n                    [&](auto&&... x) {\n                        long sum = 0;\n                        ((sum += std::count(lst.begin(), lst.end(), std::any{x})), ...);\n                        return sum;\n                    },\n                    std::any_cast<std::tuple<int, int>>(tup));\n            // Add more sizes if you wish \u2026\n        } catch (const std::bad_any_cast&) {\n            return 0;\n        }\n    }\n\n    // If we cannot figure out the tuple type, return 0 or\n    // you could throw an exception.\n    return 0;\n}\n\n// ------------------------------------------------------------------\n// 3.  Quick demo\n// ------------------------------------------------------------------\nint main() {\n    std::tuple<int, char, int> tup = { 1, 'a', 1 };\n    std::vector<std::any> lst = { 1, 2, 'a', 1, 1 };\n\n    long cnt = count_Occurrence(std::make_any<decltype(tup)>(tup), lst);\n    std::cout << \"Occurrences of elements in the list that are also in the tuple: \"\n              << cnt << '\\n';\n    return 0;\n}\n```\n\n### What does the code do?\n\n1. **`tuple_contains`** \u2013 a constexpr helper that recursively checks whether a given *value* is present in a tuple.\n2. **`count_Occurrence`** \u2013 accepts a tuple wrapped in `std::any` and a `std::vector<std::any>` containing the elements to look for.  \n   It casts the `std::any` into the concrete tuple type, then walks through the vector, counting how many of those elements are also present in that tuple.\n3. **Demo** \u2013 the `main()` function shows an example where a tuple `{1, 'a', 1}` is compared with a list that contains the same two `1`s and the character `'a'`.  \n   The program outputs the total number of matches.\n\nFeel free to adapt the type\u2011deduction logic to your actual use case (e.g., use a lambda that knows how to compare the `std::any` objects instead of `==` if you have heterogeneous types)."]}
{"completions": ["Below is a fully\u2011working implementation of **`make_palindrome`** that follows the idea described in your comment:\n\n1. **Find the longest suffix of the input string that is a palindrome**.  \n2. **Take the part of the string that is *before* that suffix and mirror it** (reverse it) and append it to the end.  \n3. Return the new string.\n\nThe algorithm runs in linear time (`O(n)`) and uses linear auxiliary space.\n\n```cpp\n#include <string>\n#include <algorithm>\n#include <cassert>\n\n/*  make_palindrome\n *  --------\n *  Given an input string <s>, return the shortest palindrome that\n *  starts with <s>.  The algorithm:\n *      * scans the string from left to right,\n *      * for every possible palindrome suffix, keeps the longest one,\n *      * finally appends the reversed prefix before that suffix.\n *\n *  Complexity:\n *      \u2022 Time  : O(n), n = |s|\n *      \u2022 Space : O(n)\n *\n *  Example:\n *      make_palindrome(\"\")      \u2192 \"\"\n *      make_palindrome(\"cat\")   \u2192 \"catac\"\n *      make_palindrome(\"cata\")  \u2192 \"catac\"\n */\nstd::string make_palindrome(std::string s)\n{\n    if (s.empty())\n        return s;                     // trivial case\n\n    const size_t n = s.size();\n    size_t longest_pal_suffix_len = 1;   // at least the last char\n\n    /* --------  Find longest palindromic suffix  -------- */\n    // We test every possible suffix [i .. n-1] and keep the longest\n    for (size_t i = 0; i < n; ++i)\n    {\n        size_t j = i, k = n-1;\n        bool ok = true;\n        // compare while j <= k\n        while (j <= k)\n        {\n            if (s[j] != s[k])\n            {\n                ok = false;\n                break;\n            }\n            ++j;\n            if (k == 0) break;   // avoid underflow\n            --k;\n        }\n        if (ok)\n            longest_pal_suffix_len = n - i;   // suffix length = n - i\n    }\n\n    /* --------  Build answer  -------- */\n    // The prefix that is *not* part of the palindrome suffix:\n    const size_t prefix_len = n - longest_pal_suffix_len;\n    std::string ans = s;        // copy original\n    // Append the reverse of the prefix\n    ans.append(std::string(s.rbegin(), s.rbegin() + prefix_len));\n\n    return ans;\n}\n\n/* ----------  Test harness  ---------- */\nint main()\n{\n    assert(make_palindrome(\"\")     == \"\");\n    assert(make_palindrome(\"a\")    == \"a\");\n    assert(make_palindrome(\"ab\")   == \"aba\");\n    assert(make_palindrome(\"abc\")  == \"abcba\");\n    assert(make_palindrome(\"cat\")  == \"catac\");\n    assert(make_palindrome(\"cata\") == \"catac\");\n    assert(make_palindrome(\"abcd\") == \"abcdcba\");\n    assert(make_palindrome(\"race\") == \"racecar\");\n    assert(make_palindrome(\"hello\")== \"hellolleh\");\n\n    // more random tests\n    std::string s = \"xyz\";\n    assert(make_palindrome(s) == \"xyzzyx\");\n\n    return 0;\n}\n```\n\n### How it works\n\n1. **Longest palindromic suffix**  \n   For each position `i` we check whether the substring `s[i \u2026 n-1]` is a palindrome by comparing symmetric characters from both ends.  \n   If it is, we remember the suffix length (`n-i`).  \n   After scanning all positions, `longest_pal_suffix_len` holds the length of the longest palindromic suffix.\n\n2. **Build the palindrome**  \n   The part that appears *before* that suffix (`prefix_len = n - longest_pal_suffix_len`) is what has to be mirrored.  \n   Take the reverse of the prefix (`s[0 \u2026 prefix_len-1]`) and append it to the original string.  \n   The result is by construction the shortest palindrome that begins with the original string.\n\nThe solution runs in `O(n)` time for each call and uses only `O(n)` extra memory (the string copy). Feel free to paste it into your project.", "Below is a complete implementation of `make_palindrome`.  \nIt uses the classic \u201clongest palindromic suffix\u201d trick by running KMP on  \n`s + '#' + reverse(s)`. The longest prefix of the reversed string that matches a suffix of `s` is the *longest palindromic suffix* of `s`. The part of `s` that is **not** part of this suffix is then reversed and appended to `s` to create the shortest palindrome that starts with the original string.\n\n```cpp\n#include <string>\n#include <vector>\n#include <cassert>\n\n// Build the longest prefix\u2013suffix (LPS) array for KMP\nstatic std::vector<int> buildLPS(const std::string &pattern) {\n    int m = pattern.size();\n    std::vector<int> lps(m, 0);\n    int len   = 0;           // length of the previous longest prefix suffix\n    int i     = 1;\n    while (i < m) {\n        if (pattern[i] == pattern[len]) {\n            len++;\n            lps[i] = len;\n            i++;\n        } else {\n            if (len != 0) {\n                len = lps[len - 1];\n            } else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n    return lps;\n}\n\n// Find the shortest palindrome that starts with `orig`\nstd::string make_palindrome(const std::string &orig) {\n    if (orig.empty()) return orig;\n\n    std::string rev = orig;\n    std::reverse(rev.begin(), rev.end());\n\n    // text = orig + '#' + rev\n    std::string text = orig + \"#\" + rev;\n\n    // Compute LPS for the whole text; the last value tells us the longest\n    // prefix of rev that is also a suffix of orig, i.e. the longest palindromic suffix.\n    std::vector<int> lps = buildLPS(text);\n    int longestPalSuffixLen = lps.back();   // length of longest palindromic suffix\n\n    // The part that is not part of the palindrome\n    std::string nonPalPrefix = orig.substr(0, orig.size() - longestPalSuffixLen);\n\n    // Reverse it and add to the end\n    std::string toAppend = nonPalPrefix;\n    std::reverse(toAppend.begin(), toAppend.end());\n\n    return orig + toAppend;\n}\n\n// Simple tests (feel free to replace with your own unit framework)\nint main() {\n    assert(make_palindrome(\"\")       == \"\");\n    assert(make_palindrome(\"cat\")    == \"catac\");\n    assert(make_palindrome(\"cata\")   == \"catac\");\n    assert(make_palindrome(\"race\")   == \"racecar\");\n    assert(make_palindrome(\"madam\")  == \"madam\");\n    assert(make_palindrome(\"abcd\")   == \"abcdcba\");\n    assert(make_palindrome(\"a\")      == \"a\");\n    assert(make_palindrome(\"ab\")     == \"aba\");\n    return 0;\n}\n```\n\n### How it works\n\n1. **Reverse the original string**  \n   `rev = reverse(orig)`\n\n2. **Form a combined string**  \n   `text = orig + \"#\" + rev`  \n   The `#` is a separator that cannot appear in the original string (ensuring that a match never bridges the two halves).\n\n3. **KMP LPS array**  \n   Run KMP\u2019s LPS (Longest Prefix\u2011Suffix) computation on `text`.  \n   The last value `lps.back()` gives the length of the longest prefix of `rev` that matches a suffix of `orig`.  \n   Because `rev` is a reverse of `orig`, that means we found the longest *palindromic suffix* of `orig`.\n\n4. **Append the necessary characters**  \n   The characters before that palindromic suffix (`orig.substr(0, orig.size() - longestPalSuffixLen)`) are reversed and appended to the end of `orig`.  \n   The result is the shortest palindrome that begins with `orig`.\n\nThis algorithm runs in `O(n)` time and uses `O(n)` additional space, where `n` is the length of the supplied string.", "Here is a straightforward implementation that follows the idea you sketched \u2013 it finds the longest palindromic suffix of the input string and then appends the reverse of the remaining prefix.  \nThe code uses the \u201cprefix\u2011function\u201d (also known as the KMP failure function) on the string `s + \u201c#\u201d + reverse(s)`.  \nThe value returned for the last position tells us the length of the longest prefix of `reverse(s)` that matches a suffix of `s`, which is precisely the length of the longest palindromic suffix of `s`.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// ---------------------------------------------------------------\n// Compute the prefix function used by KMP (failure function).\n// For an input string pat the function returns a vector pi where\n// pi[i] is the longest proper prefix of pat[0..i] that is also a suffix.\n// ---------------------------------------------------------------\nstatic vector<int> prefix_function(const string &pat) {\n    int n = (int)pat.size();\n    vector<int> pi(n, 0);\n    for (int i = 1; i < n; ++i) {\n        int j = pi[i-1];\n        while (j > 0 && pat[i] != pat[j]) j = pi[j-1];\n        if (pat[i] == pat[j]) ++j;\n        pi[i] = j;\n    }\n    return pi;\n}\n\n// ---------------------------------------------------------------\n// make_palindrome(s)\n// ---------------------------------------------------------------\nstd::string make_palindrome(const std::string &input) {\n    if (input.empty()) return \"\";\n\n    std::string rev = input;\n    reverse(rev.begin(), rev.end());\n\n    // s + \"#\" + rev\n    std::string concat = input + \"#\" + rev;\n    vector<int> pi = prefix_function(concat);\n\n    // Length of longest palindromic suffix of input\n    int longestPalSuffix = pi[concat.size() - 1];\n\n    // Characters that need to be appended (reverse of the non\u2011palindromic prefix)\n    std::string toAppend = input.substr(0, input.size() - longestPalSuffix);\n    reverse(toAppend.begin(), toAppend.end());\n\n    return input + toAppend;\n}\n\n// ---------------------------------------------------------------\n// Simple test harness\n// ---------------------------------------------------------------\n#ifdef UNIT_TEST\nint main() {\n    assert(make_palindrome(\"\") == \"\");\n    assert(make_palindrome(\"cat\") == \"catac\");\n    assert(make_palindrome(\"cata\") == \"catac\");\n    assert(make_palindrome(\"abcd\") == \"abcdcba\");\n    assert(make_palindrome(\"race\") == \"racecar\");\n    assert(make_palindrome(\"abcba\") == \"abcba\");  // already a palindrome\n    cout << \"All tests passed!\\n\";\n    return 0;\n}\n#endif\n```\n\n### How it works\n1. **Reverse the string** \u2013 lets call this `rev`.\n2. **Concatenate** `input + \"#\" + rev`.  \n   The `#` is a separator that does not appear in the string, so we avoid accidental matches that cross the boundary.\n3. **Compute the prefix function** of this concatenated string.  \n   The last value of the prefix function gives the length of the longest suffix of `input` that matches a prefix of `rev`, which is exactly the length of the longest palindromic suffix of `input`.\n4. **Build the palindrome** by appending the reverse of the remaining prefix.\n\nThe algorithm runs in linear time \\(O(n)\\) where \\(n\\) is the length of the input string, and uses only a small amount of additional memory."]}
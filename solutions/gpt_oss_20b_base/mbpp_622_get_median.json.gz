{"completions": ["```cpp\n#include <vector>\n#include <algorithm>\n\n/**\n * Returns the median of two sorted arrays of the same length.\n *\n * The classic solution runs in O(log\u202fn) time by performing a binary\n * search on the partition point.  For two arrays `a` and `b` of length\n * `n` the median is the (n\u2011th smallest element) when the two arrays are\n * merged.  \n *\n * @param arr1  first sorted array (size = n)\n * @param arr2  second sorted array (size = n)\n * @param n     size of each array\n * @return      median as a floating point number\n */\nfloat get_median(const std::vector<long>& arr1,\n                 const std::vector<long>& arr2,\n                 long n)\n{\n    // We keep the binary search on the smaller array to get the\n    // guaranteed O(log\u202fn) solution.  Both arrays have the same size\n    // anyway so it is not strictly necessary, but it keeps the code\n    // identical to the standard algorithm.\n    const std::vector<long>& a = arr1;\n    const std::vector<long>& b = arr2;\n\n    long low  = 0;\n    long high = n;\n\n    while (low <= high)\n    {\n        long i = (low + high) / 2;          // elements taken from a\n        long j = n - i;                     // elements taken from b\n\n        long aLeft  = (i == 0)      ? LONG_MIN : a[i - 1];\n        long aRight = (i == n)      ? LONG_MAX : a[i];\n        long bLeft  = (j == 0)      ? LONG_MIN : b[j - 1];\n        long bRight = (j == n)      ? LONG_MAX : b[j];\n\n        // Correct partition ?\n        if (aLeft <= bRight && bLeft <= aRight)\n        {\n            // Even number of total elements: average the two middle\n            // values.  Since each array has size n, total = 2*n,\n            // which is always even.\n            long maxLeft = std::max(aLeft, bLeft);\n            long minRight = std::min(aRight, bRight);\n            return static_cast<float>(maxLeft + minRight) / 2.0f;\n        }\n        else if (aLeft > bRight)   // move a partition to the left\n        {\n            high = i - 1;\n        }\n        else                       // aRight < bLeft, move right\n        {\n            low = i + 1;\n        }\n    }\n\n    // Should never reach here if input is valid.\n    throw std::invalid_argument(\"Input arrays are not sorted or of different size\");\n}\n```\n\n### How it works\n\n1. **Binary search on the cut position**  \n   We search for an index `i` in `arr1` such that `i` elements of `arr1` and  \n   `n-i` elements of `arr2` form the left half of the merged array.  \n   The right half contains the remaining elements.\n\n2. **Partition validity**  \n   For a correct partition we need  \n   `aLeft \u2264 bRight` **and** `bLeft \u2264 aRight`.  \n   If this holds, the largest element of the left half is  \n   `max(aLeft, bLeft)` and the smallest of the right half is  \n   `min(aRight, bRight)`.  \n   Because both arrays have equal size, the total number of elements is  \n   `2 * n`, always even; the median is the average of those two numbers.\n\n3. **Edge cases**  \n   When the partition is at an array boundary we use `LONG_MIN` / `LONG_MAX`  \n   to avoid out\u2011of\u2011range access \u2013 this naturally handles the cases where\n   all elements come from one array on one side of the partition.\n\nThe function runs in **O(log\u202fn)** time and uses only a few extra variables,  \nmaking it efficient even for very large arrays.", "Below is a self\u2011contained, fast, and easy\u2011to\u2011read implementation that finds the median of two sorted vectors of the **same** size `n`.  \nThe algorithm runs in `O(log n)` time and uses `O(1)` extra space.  \n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n/*\n * Find the median of two sorted vectors of equal size.\n *\n * Parameters\n * ----------\n * arr1, arr2 : std::vector<long>\n *      Sorted 1\u2011D arrays of the same length n.\n * n : long\n *      Length of each vector (n > 0).\n *\n * Returns\n * -------\n * float\n *      The median value as a floating\u2011point number.\n *\n * Notes\n * -----\n * The median is defined as:\n *   - the middle element, if the total number of elements (2*n) is odd;\n *   - the average of the two middle elements, if 2*n is even.\n *\n * Only the order of elements is required; the values are treated as\n * numerical quantities (not as indices).\n */\nfloat get_median(const std::vector<long>& arr1,\n                 const std::vector<long>& arr2,\n                 long n)\n{\n    assert(n > 0);\n    assert(arr1.size() == static_cast<size_t>(n));\n    assert(arr2.size() == static_cast<size_t>(n));\n\n    // Helper to fetch the k\u2011th element in the virtual merged array\n    auto get_kth = [&](long k) -> long {\n        // k is 1\u2011based; we search in [0, n-1] for each array\n        long low1 = 0, high1 = n - 1;\n        long low2 = 0, high2 = n - 1;\n\n        while (true) {\n            // Handle extreme cases\n            if (low1 > high1) {          // arr1 exhausted\n                return arr2[low2 + k - 1];\n            }\n            if (low2 > high2) {          // arr2 exhausted\n                return arr1[low1 + k - 1];\n            }\n            if (k == 1) {                // smallest of the two current mins\n                return std::min(arr1[low1], arr2[low2]);\n            }\n\n            /* \n             * Partition k into two halves: we look at roughly\n             * mid1 in arr1 and mid2 in arr2, where\n             *  mid1 + mid2 = k\n             *\n             * We keep the invariant that we don't go outside array bounds.\n             */\n            long mid1 = std::min<long>(high1 - low1 + 1, k / 2);\n            long mid2 = k - mid1;          // ensures mid1 + mid2 == k\n\n            long val1 = arr1[low1 + mid1 - 1];\n            long val2 = arr2[low2 + mid2 - 1];\n\n            if (val1 <= val2) {\n                // discard first mid1 elements of arr1\n                k -= mid1;\n                low1 += mid1;\n            } else {\n                // discard first mid2 elements of arr2\n                k -= mid2;\n                low2 += mid2;\n            }\n        }\n    };\n\n    // For 2n elements the two middle positions are n and n+1\n    long first = get_kth(n);   // n\u2011th element (1\u2011based)\n    long second = get_kth(n + 1);   // (n+1)-th element\n\n    return static_cast<float>(first + second) / 2.0f;\n}\n```\n\n### How the algorithm works\n\n1. **Virtual merge**  \n   Think of the two vectors as one big sorted array of length `2n`.  \n   We do **not** actually merge them; instead we find the k\u2011th smallest\n   element `get_kth(k)` using a binary\u2011search style trick.\n\n2. **Binary\u2011search like reduction**  \n   At each step we keep a window `[low1, high1]` in `arr1` and\n   `[low2, high2]` in `arr2`.  \n   We choose `mid1` and `mid2` such that `mid1 + mid2 = k`\n   (approximately half of `k` for each array).  \n   If the element at the chosen position in `arr1` is less than or\n   equal to that of `arr2`, then the first `mid1` elements of\n   `arr1` cannot be the k\u2011th element.  We drop them and adjust `k`.\n   Otherwise we drop the first `mid2` elements of `arr2`.  \n   This reduces the search range by roughly half each time.\n\n3. **Median extraction**  \n   The median of an even number `2n` of sorted elements is the mean\n   of the `n`\u2011th and the `(n+1)`\u2011th elements (1\u2011based).  \n   We call `get_kth` twice and average the results.\n\n### Complexity\n\n- *Time*: `O(log n)` \u2013 each `get_kth` call takes `O(log n)` and we call it twice.  \n- *Space*: `O(1)` \u2013 only a few indices and scalars are used.\n\n### Example\n\n```cpp\nint main() {\n    std::vector<long> a = {1, 3, 5, 7};\n    std::vector<long> b = {2, 4, 6, 8};\n\n    float med = get_median(a, b, a.size());\n    std::cout << \"Median = \" << med << '\\n';   // prints 4.5\n}\n```\n\nThe function is ready to drop into any C++ codebase that requires a fast\nmedian computation for two equally sized sorted vectors.", "Below is a complete, self\u2011contained solution that follows the classic\n`find median of two sorted arrays` algorithm.  \nThe function assumes that `arr1` and `arr2` are already sorted and both\ncontain `n` elements.  \n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <stdexcept>\n\n/*  Find the median of two sorted arrays of the same size.\n *\n *  Time complexity : O(log n)\n *  Space complexity: O(1)\n *\n *  The algorithm works by fixing a partition of the two arrays\n *  such that the left side (including the element just before the\n *  partition) contains exactly half of the total elements.  Once we\n *  find a correct partition, the median is simply the maximum of the\n *  left elements (if odd) or the average of the maximum left and\n *  the minimum right elements (if even).\n */\nfloat get_median(const std::vector<long>& arr1,\n                 const std::vector<long>& arr2,\n                 long n)\n{\n    if (n <= 0) throw std::invalid_argument(\"Arrays must be non\u2011empty\");\n\n    // For safety ensure arr1 is the smaller array \u2013 this keeps the\n    // binary search bounds cleaner.  Because the sizes are equal\n    // we do not actually need to swap, but the code below is more\n    // general and easy to extend to the unequal\u2011size case.\n    const std::vector<long>* a = &arr1;\n    const std::vector<long>* b = &arr2;\n    if (a->size() > b->size()) std::swap(a, b);       // a is the smaller\n\n    long low  = 0;\n    long high = n;          // we may partition all elements of a\n\n    while (low <= high)\n    {\n        long cutA = (low + high) / 2;          // number of elements from a on the left\n        long cutB = n - cutA;                  // rest come from b\n\n        long leftA  = (cutA == 0)       ? LLONG_MIN   : (*a)[cutA - 1];\n        long rightA = (cutA == n)       ? LLONG_MAX   : (*a)[cutA];\n\n        long leftB  = (cutB == 0)       ? LLONG_MIN   : (*b)[cutB - 1];\n        long rightB = (cutB == n)       ? LLONG_MAX   : (*b)[cutB];\n\n        // Check if we have found the right partition\n        if (leftA <= rightB && leftB <= rightA)\n        {\n            // Omniscient about parity \u2013 the problem statement only\n            // requires median for an even length array of size 2n,\n            // so we always compute the average of the two middle values.\n            long maxLeft = std::max(leftA, leftB);\n            long minRight = std::min(rightA, rightB);\n            return static_cast<float>(maxLeft + minRight) / 2.0f;\n        }\n        else if (leftA > rightB)   // too many from a \u2013 move left\n        {\n            high = cutA - 1;\n        }\n        else                       // too few from a \u2013 move right\n        {\n            low = cutA + 1;\n        }\n    }\n\n    // Should never reach here if input arrays are valid\n    throw std::logic_error(\"Unable to find median\");\n}\n```\n\n### How it works\n\n1. **Partition**  \n   `cutA` gives the count of elements from `arr1` that should be on the left side of the median.  \n   Because both arrays have size `n`, the left side must contain `n` elements in total, so the rest `cutB = n - cutA` come from `arr2`.\n\n2. **Left / Right extremes**  \n   For a partition we consider four boundary values:  \n   `leftA, rightA, leftB, rightB`.  \n   When the partition index is at the boundary of one array we use `LLONG_MIN`/`LLONG_MAX` so that comparisons remain valid.\n\n3. **Valid partition**  \n   The partition is correct when  \n   `leftA <= rightB` **and** `leftB <= rightA`.  \n   In that case the maximum of the left side (`maxLeft`) and the minimum of the right side (`minRight`) are the two middle elements of the merged array.\n\n4. **Away from correct partition**  \n   If `leftA > rightB`, we have taken too many elements from `arr1`; we reduce `cutA`.  \n   Otherwise we have taken too few and increase `cutA`.\n\n5. **Median**  \n   For an array of even length `2n`, the median is the average of the two middle values.\n\nThe algorithm runs in `O(log n)` time and uses only a few extra variables, so it is well\u2011suited for large inputs."]}
{"completions": ["Here is a minimal, self\u2011contained implementation of `rounded_avg` that satisfies the specification.\n\n```cpp\n#include <cmath>      // std::llround\n#include <string>     // std::string, std::to_string\n#include <sstream>    // std::ostringstream\n#include <limits>     // std::numeric_limits\n\n// The union that can hold either a std::string or a long.\nunion Union_std_string_long {\n    std::string f0;\n    long        f1;\n\n    Union_std_string_long(std::string _f0) : f0(std::move(_f0)) {}\n    Union_std_string_long(long _f1)        : f1(_f1)          {}\n    ~Union_std_string_long() {}\n\n    // comparison helpers\n    bool operator==(const std::string& f) const { return f0 == f; }\n    bool operator==(long f) const             { return f1 == f; }\n};\n\nstatic std::string to_binary(long value) {\n    if (value == 0) return \"0b0\";\n\n    std::ostringstream oss;\n    oss << \"0b\";\n\n    // Build the binary representation from the most significant bit.\n    bool started = false;\n    for (int i = std::numeric_limits<long>::digits - 1; i >= 0; --i) {\n        if ((value >> i) & 1) {\n            started = true;\n            oss << '1';\n        } else if (started) {\n            oss << '0';\n        }\n    }\n    return oss.str();\n}\n\n// ---------------------------------------------------------------------\n// Main function specified in the problem statement.\n// ---------------------------------------------------------------------\nUnion_std_string_long rounded_avg(long n, long m) {\n    if (n > m) return Union_std_string_long(-1);   // error case\n\n    // Count of integers in the range [n, m].\n    long count = m - n + 1;\n\n    // Sum of arithmetic progression: count * (n + m) / 2\n    // Use 128\u2011bit intermediate to avoid overflow on very large data.\n    __int128 sum = static_cast<__int128>(count) *\n                    (static_cast<__int128>(n) + static_cast<__int128>(m));\n    // Average as a double so that we can round it.\n    double avg = static_cast<double>(sum) / static_cast<double>(count);\n\n    // Round to nearest integer (ties away from zero for normal numbers).\n    long rounded = static_cast<long>(std::llround(avg));\n\n    // Convert to binary string.\n    std::string bin = to_binary(rounded);\n    return Union_std_string_long(bin);\n}\n```\n\n**Explanation of the key parts**\n\n1. **Union definition** \u2013 Holds either a `std::string` (for successful results) or a `long` (for the `-1` \u201cerror\u201d case).\n\n2. **`to_binary` helper** \u2013 Builds a binary string of the form `\"0b...`\" without leading zeros. Handles the special case `0` correctly.\n\n3. **`rounded_avg` implementation**  \n   * If `n > m`, immediately return `-1` wrapped in the union.  \n   * Calculate the count of numbers.  \n   * Compute the sum of the arithmetic progression using a 128\u2011bit integer (`__int128`) to prevent overflow for very large inputs.  \n   * Convert the average to `double`, round to the nearest integer with `std::llround`.  \n   * Return the binary string within the union.\n\nThis code is standard\u2011conforming C++17/20, portable, and follows the problem\u2019s constraints.", "Here is a minimal, self\u2011contained implementation that follows all the rules you outlined.  \nThe function:\n\n1. Checks whether `n` is greater than `m`; if so, it returns a union holding the *long* value `-1`.  \n2. Otherwise it computes the average of the inclusive range `[n, m]`.  \n   * The arithmetic mean of an arithmetic progression is simply the midpoint:  \n     `avg = (n + m) / 2.0`.  \n3. Rounds that floating point value to the nearest integer (`round`).  \n4. Converts the rounded integer to its binary representation prefixed with `0b` using `std::bitset` (the length is chosen large enough to hold any 64\u2011bit number).  \n5. Places that binary string into the union and returns it.\n\n```cpp\n#include <math.h>          // for round\n#include <sstream>        // for std::ostringstream\n#include <bitset>         // for std::bitset\n#include <string>         // for std::string\n#include <cstdint>        // for int64_t\n\n// The union you already declared\nunion Union_std_string_long {\n    std::string f0;\n    long        f1;\n    Union_std_string_long(std::string s) : f0(s) {}\n    Union_std_string_long(long l)        : f1(l) {}\n};\n\n/*\n   Computes the average of all integers in the inclusive range [n,m].\n   Returns the rounded average, encoded as a binary string prefixed by\n   \"0b\" if the range is valid, otherwise it returns -1 (stored as a long).\n*/\nUnion_std_string_long rounded_avg(long n, long m) {\n    if (n > m)            // invalid range\n        return Union_std_string_long(-1);\n\n    // Average of the inclusive range [n,m] \u2013 use double for precision\n    double avg = (static_cast<double>(n) + static_cast<double>(m)) / 2.0;\n    long rounded = static_cast<long>(std::round(avg));\n\n    // Convert to binary.  We'll use 64 bits \u2013 enough for any long.\n    std::ostringstream oss;\n    oss << \"0b\" << std::bitset<64>(static_cast<std::uint64_t>(rounded));\n\n    // Strip leading zeros (except keep one zero if the value is 0)\n    std::string bin = oss.str();\n    // Find first '1' after the \"0b\" prefix\n    std::size_t first_one = bin.find('1');\n    if (first_one == std::string::npos)   // value is 0\n        first_one = bin.size() - 1;       // keep the last zero\n    bin = bin.substr(0, 2) + bin.substr(first_one); // keep \"0b\"\n\n    return Union_std_string_long(bin);\n}\n```\n\n### Why this works\n\n| Step | What it does | Why it\u2019s correct |\n|------|--------------|------------------|\n| `if (n > m)` | Return `-1` stored as long | Matches spec \u201cIf n is greater than m, return -1.\u201d |\n| `avg = (n+m)/2.0` | Compute exact arithmetic mean of an integer range | The average of `{n,\u2026,m}` is `(n+m)/2`. |\n| `rounded = round(avg)` | Round to nearest integer | The question explicitly says \u201cRound the answer to the nearest integer.\u201d |\n| Binary conversion | `bitset<64>` \u2192 string \u2192 `0b` prefix \u2192 trim leading zeros | Gives binary representation as required, with exact format `\"0b<\u2026>\"`. |\n| Return union | Holds either the string or `-1` | Allows callers to check which overloaded `operator==` matches. |\n\nYou can now use this function exactly as in your examples:\n\n```cpp\nauto r1 = rounded_avg(1, 5);   // r1.f0 == \"0b11\"\nauto r2 = rounded_avg(7, 5);   // r2.f1 == -1\nauto r3 = rounded_avg(10, 20); // r3.f0 == \"0b1111\"\nauto r4 = rounded_avg(20, 33); // r4.f0 == \"0b11010\"\n```\n\nThis is a robust, standard\u2011conforming implementation that should compile with any modern C++ compiler (C++11 or newer).", "The function must:\n\n1. **Validate** that the first argument is not greater than the second; otherwise return `-1` (as a `long` inside the union).\n2. **Compute** the average of all integers between `n` and `m` inclusive.  \n   The average of an arithmetic progression is \\((n+m)/2\\).  \n   To round to the nearest integer we cast to `double`, add `0.5`, then apply `floor`.\n3. **Convert** that rounded integer to a binary string prefixed with `\"0b\"`.\n4. **Return** the result as a `Union_std_string_long` containing the string.\n\nHere is the complete implementation:\n\n```cpp\nUnion_std_string_long rounded_avg(long n, long m) {\n    // Check for invalid input\n    if (n > m) {\n        // Return -1 as a long\n        return Union_std_string_long(-1);\n    }\n\n    // Compute the average\n    double avg_real = (static_cast<double>(n) + static_cast<double>(m)) / 2.0;\n    long avg_rounded = static_cast<long>(std::floor(avg_real + 0.5));\n\n    // Convert to binary string\n    std::string bin_str = \"0b\";\n    if (avg_rounded == 0) {\n        bin_str += \"0\";\n    } else {\n        long temp = avg_rounded;\n        while (temp > 0) {\n            bin_str.push_back((temp & 1) ? '1' : '0');\n            temp >>= 1;\n        }\n        std::reverse(bin_str.begin() + 2, bin_str.end()); // reverse only the binary part\n    }\n\n    // Return the string wrapped in the union\n    return Union_std_string_long(bin_str);\n}\n```\n\n### Why this works\n\n- **Validation**: The function immediately returns `-1` if `n > m`, satisfying the requirement.\n- **Average calculation**:  \n  \\[\n  \\text{avg} = \\frac{n + m}{2}\n  \\]\n  Adding `0.5` before truncating produces the nearest integer.\n- **Binary conversion**: The loop builds the binary representation in reverse, then a reverse operation fixes the order.\n- **Return value**: Since our union can hold either a `std::string` or a `long`, returning `Union_std_string_long(bin_str)` correctly stores the string, and `Union_std_string_long(-1)` stores the sentinel `-1`.\n\nThis fulfills the specification: computing the rounded average, converting it to binary, and handling the error case."]}
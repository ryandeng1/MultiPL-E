{"completions": ["**Solution Explanation**\n\nFor a given list of integers we need to\n\n1. find the **largest prime number** contained in the list,\n2. return the **sum of its decimal digits**.\n\nIf the list contains no prime number the behaviour is not specified in the statement, but the examples always contain at least one prime, so we can assume that at least one prime will always be present.\n\n--------------------------------------------------------------------\n\n#### Algorithm\n```\nmaxPrime = -1\nfor each x in the list\n        if x is prime and x > maxPrime\n                maxPrime = x\n\n// compute sum of decimal digits of maxPrime\nsum = 0\ntmp = maxPrime\nwhile tmp > 0\n        sum += tmp % 10\n        tmp /= 10\n\nreturn sum\n```\n\n--------------------------------------------------------------------\n\n#### Correctness Proof  \n\nWe prove that the algorithm returns the sum of the digits of the largest prime in the list.\n\n*Lemma 1:* After the loop, `maxPrime` equals the largest prime number in the list.\n\n*Proof of Lemma 1:*  \nThe loop examines each element `x` once.  \nIf `x` is prime and larger than the current `maxPrime`, the algorithm updates `maxPrime` to `x`.  \nTherefore `maxPrime` is always the largest prime seen so far.  \nWhen the loop ends, every element has been considered, so `maxPrime` is the largest prime in the whole list. \u220e\n\n*Lemma 2:*  \nThe digit\u2011sum part returns the sum of the decimal digits of `maxPrime`.\n\n*Proof of Lemma 2:*  \n`tmp` initially equals `maxPrime`.  \nEach iteration extracts the last decimal digit (`tmp % 10`), adds it to `sum`, and removes that digit (`tmp / 10`).  \nThis process terminates after processing all decimal digits, leaving `sum` equal to their total. \u220e\n\n*Theorem:*  \nThe algorithm returns the sum of the digits of the largest prime number in the input list.\n\n*Proof of Theorem:*  \nBy Lemma&nbsp;1, after the first loop `maxPrime` stores the largest prime in the list.  \nBy Lemma&nbsp;2, the second part returns the sum of its digits.  \nThus the algorithm returns the desired value. \u220e\n\n--------------------------------------------------------------------\n\n#### Complexity Analysis  \n\nLet `n` be the size of the input list and `p` the largest prime found.\n\n* Prime checking for a single number `x`: `O(\u221ax)` by trial division up to the square root.  \n* In the worst case the largest prime is about the magnitude of the largest list element, denote it by `M`.  \n  Checking all `n` numbers thus costs  \n  `O( \u03a3 sqrt(x_i) ) \u2264 O(n * sqrt(M))`.\n\n* Digit summation costs `O( log10(M) )`, which is negligible compared to the prime tests.\n\nTherefore the overall time complexity is `O( n * sqrt(M) )`.  \nThe algorithm uses only a few variables: `O(1)` extra space.\n\n--------------------------------------------------------------------\n\n#### Reference Implementation  (C++17)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// ---------- small helper : check primality ----------\nbool isPrime(long long x) {\n    if (x < 2) return false;\n    if (x % 2 == 0) return x == 2;\n    if (x % 3 == 0) return x == 3;\n    for (long long d = 5; d * d <= x; d += 6) {\n        if (x % d == 0 || x % (d + 2) == 0) return false;\n    }\n    return true;\n}\n\n// ---------- main function ----------\nlong long skjkasdkd(const std::vector<long long>& lst) {\n    long long maxPrime = -1;\n    for (long long x : lst) {\n        if (isPrime(x) && x > maxPrime)\n            maxPrime = x;\n    }\n\n    // Sum digits of maxPrime\n    long long sum = 0;\n    long long tmp = maxPrime;\n    while (tmp > 0) {\n        sum += tmp % 10;\n        tmp /= 10;\n    }\n    return sum;\n}\n```\n\nThe code follows exactly the algorithm proven correct above and\nconforms to the GNU++17 compiler.", "**Explanation**\n\nFor a given vector of integers we need the largest element that is a prime number.\nOnce that number is found we return the sum of its decimal digits.\n\nThe algorithm is:\n\n1. Scan the vector and keep a variable `best` that stores the largest prime found so far  \n   (initially `-1` meaning \u201cnone\u201d).\n2. For each element `x` in the vector  \n   * If `x` is less than `2` it cannot be prime \u2013 skip it.  \n   * Otherwise test whether `x` is prime:\n     * For `x \u2264 3` the only primes are `2` and `3`.\n     * For larger numbers test divisibility by all integers from `2` up to `sqrt(x)` \u2013 if any divides `x` it is composite.\n   * If `x` is prime and larger than `best`, set `best = x`.\n3. If after the scan `best` is still `-1` (no prime was found) return `0`.  \n   (The problem statement does not specify what to do in that case \u2013 returning `0` is a safe default.)\n4. Compute the sum of the decimal digits of `best` \u2013 repeatedly take `best % 10` and divide by `10`.\n\nThe implementation below follows this approach and will compile in a standard C++ compiler.\n\n```cpp\n#include <vector>\n#include <cmath>\n\nbool isPrime(long n) {\n    if (n < 2) return false;\n    if (n <= 3) return true;          // 2 and 3 are prime\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    long limit = static_cast<long>(std::sqrt(static_cast<double>(n)));\n    for (long i = 5; i <= limit; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nlong skjkasdkd(std::vector<long> lst) {\n    long best = -1;\n    for (long x : lst) {\n        if (isPrime(x) && x > best) {\n            best = x;\n        }\n    }\n    if (best == -1) return 0;   // no prime found\n\n    // Sum of digits of best\n    long sum = 0;\n    long temp = best;\n    while (temp > 0) {\n        sum += temp % 10;\n        temp /= 10;\n    }\n    return sum;\n}\n```\n\n**Usage Example**\n\n```cpp\n#include <iostream>\nint main() {\n    std::vector<long> v = {1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1};\n    std::cout << skjkasdkd(v) << std::endl;   // outputs 25\n}\n```\n\nThe function works for all the examples given in the statement.", "```cpp\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\n/*  Function: skjkasdkd\n    --------------------\n    Given a vector of long integers, the function finds the largest\n    prime number present in the vector and returns the sum of its digits.\n    If the vector contains no prime numbers, the function returns 0.\n\n    Example:\n        std::vector<long> v = {0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181,\n                               32, 4, 32, 3, 2, 32, 324, 4, 3};\n        skjkasdkd(v)  // -> 10   (largest prime is 181, 1+8+1=10)\n*/\nlong skjkasdkd(std::vector<long> lst)\n{\n    auto is_prime = [](long n) -> bool {\n        if (n < 2)          return false;\n        if (n % 2 == 0)     return n == 2;\n        if (n % 3 == 0)     return n == 3;\n        long long lim = static_cast<long long>(std::sqrt((long double)n));\n        for (long long i = 5; i <= lim; i += 6) {\n            if (n % i == 0   || n % (i + 2) == 0)\n                return false;\n        }\n        return true;\n    };\n\n    long best_prime = -1;\n    for (long num : lst) {\n        if (is_prime(num) && num > best_prime) {\n            best_prime = num;\n        }\n    }\n\n    if (best_prime == -1) return 0;           // no prime found\n\n    long sum_digits = 0;\n    long temp = std::llabs(best_prime);        // handle negative numbers just in case\n    while (temp > 0) {\n        sum_digits += temp % 10;\n        temp /= 10;\n    }\n    return sum_digits;\n}\n```"]}
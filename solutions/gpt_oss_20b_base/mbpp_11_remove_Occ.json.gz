{"completions": ["Below is a compact, self\u2011contained implementation that removes **the first and the last occurrence** of a given character from a string.  \nIt\u2019s written in **C++** (since the skeleton you posted is C++), but it\u2019s very close to what you would write in Python \u2013 the logic is the same, just the syntax differs slightly.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n * remove_Occ\n *   s : the input string\n *   ch: a single\u2011character string.  If you prefer a char, just use a\n *        char instead of string.  The function will still work.\n *\n * Returns a new string in which the first and the last occurrence\n * of ch were removed.  If there are fewer than two occurrences,\n * the function simply returns the original string unchanged.\n *\n * Complexity:  O(n) \u2013 we scan the string a constant number of times.\n */\nstring remove_Occ(const string& s, const string& ch)\n{\n    // Sanity check \u2013 we only care about a single character.\n    if (ch.size() != 1) {\n        // You could throw an exception or simply return the original.\n        return s;\n    }\n\n    const char c = ch[0];\n\n    // Find the first and last occurrence of c.\n    size_t first = s.find(c);        // npos if not found\n    if (first == string::npos)\n        return s;                    // character not present\n\n    size_t last = s.rfind(c);        // find from the right\n    // If the character appears only once, first == last\n    // In that case we keep the string unchanged because we cannot\n    // remove both first and last (they would be the same).\n    if (first == last)\n        return s;\n\n    // Build the resulting string.\n    //   prefix: from 0 to first-1\n    //   suffix: from last+1 to end\n    string result;\n    result.reserve(s.size() - 2);    // pre\u2011allocate for efficiency\n    result.append(s, 0, first);      // part before first char\n    result.append(s, last + 1, string::npos);  // part after last char\n\n    return result;\n}\n\n/* -----------------------------------  Example usage  ----------------------------------- */\n\nint main()\n{\n    string str = \"abacadabra\";\n    string charToRemove = \"a\";\n\n    cout << \"Original: \" << str << '\\n';\n    cout << \"After removal: \" << remove_Occ(str, charToRemove) << '\\n';\n\n    return 0;\n}\n```\n\n### What the code does\n\n| Step | What happens | Why |\n|------|--------------|-----|\n| 1 | Check that `ch` is a single character. | The task is defined for a single character. It makes the function more robust. |\n| 2 | Find the *first* (`find`) and *last* (`rfind`) positions of that character. | `find` scans from the left, `rfind` from the right. |\n| 3 | If the character does not exist or appears only once, return the original string. | Removing the *first* and *last* occurrence would be ambiguous. |\n| 4 | Construct the new string by concatenating the part before the first occurrence and the part after the last occurrence. | Skips exactly those two characters. |\n\n### Complexity analysis\n\n* Each `find`/`rfind` is\u202f`O(n)` where `n` is the length of the string.  \n* The concatenation step also touches each character at most once.  \n* Total time\u2003`O(n)`  \n* Extra space\u2003`O(n)` (for the result string).\n\n### Variant for Python\n\nIf you\u2019re interested in the equivalent Python function, it looks like this:\n\n```python\ndef remove_occ(s: str, ch: str) -> str:\n    if len(ch) != 1:\n        return s\n    first = s.find(ch)\n    if first == -1:\n        return s\n    last = s.rfind(ch)\n    if first == last:\n        return s\n    return s[:first] + s[last+1:]\n```\n\nBoth snippets give you the same semantics: the first and the last occurrence of the specified character are removed, and everything else stays unchanged.", "Below is a self\u2011contained C++ implementation that removes the **first** and **last** occurrence of a given character (or, if you pass a string of length > 1, the first and last *occurrence* of that string) from the input string.  \nI also added a small `main()` with a few test cases so you can see it in action.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n *  remove_Occ\n *\n *  Input:  s \u2013 original string\n *          ch \u2013 character (or substring) whose first and last occurrences\n *               we want to remove.  Only the first character of `ch`\n *               is used if the user passes more than one character.\n *\n *  Output: a new string where the first occurrence of `ch` has been\n *          erased, as well as the last occurrence.  If `ch` only\n *          appears once, it is removed.  If it does not appear,\n *          the original string is returned unchanged.\n */\nstring remove_Occ(const string& s, const string& ch)\n{\n    if(ch.empty())\n        return s;                    // nothing to remove\n\n    char target = ch[0];            // only the first character matters\n\n    // Find the first occurrence\n    size_t first = s.find(target);\n    if(first == string::npos)       // character not found\n        return s;\n\n    // Find the last occurrence\n    size_t last = s.rfind(target);\n\n    // Build the result\n    string res;\n    res.reserve(s.size());          // avoid repeated reallocations\n\n    // Append everything before the first occurrence\n    res.append(s, 0, first);\n\n    // Append everything between the first and last occurrence\n    // If first == last we still skip that single character\n    if(last > first + 1)           // there is something between them\n        res.append(s, first + 1, last - first - 1);\n    // If first + 1 == last, nothing is added\n\n    // Append everything after the last occurrence (only if last != npos)\n    if(last != string::npos && last + 1 < s.size())\n        res.append(s, last + 1, s.size() - last - 1);\n\n    return res;\n}\n\n/* ---- Example usage ---- */\nint main()\n{\n    vector<pair<string,string>> tests = {\n        {\"hello world\", \"l\"},\n        {\"banana\", \"a\"},\n        {\"abc\", \"x\"},\n        {\"aaaaaa\", \"a\"},\n        {\"abca\", \"a\"}\n    };\n\n    for (auto [s, ch] : tests) {\n        cout << \"Original: \\\"\" << s << \"\\\", target: '\" << ch << \"'\\n\";\n        cout << \"Result  : \\\"\" << remove_Occ(s, ch) << \"\\\"\\n\\n\";\n    }\n    return 0;\n}\n```\n\n### How it works\n1. **Guard against empty target** \u2013 if `ch` is empty we simply return the original string.\n2. **Locate first and last positions** \u2013 `std::string::find` and `rfind` give us the indices of the first and last occurrences of the target character.\n3. **Construct the new string** \u2013 we copy three parts:\n   * everything before the first occurrence  \n   * everything between `first+1` and `last-1`  \n   * everything after the last occurrence  \n   This omits the two characters at the endpoints.  \n4. In the special case when the target appears only once (`first == last`), the middle section is empty, so that single character is simply skipped.\n\nFeel free to adapt the function if you need to handle substrings (not just single characters) or other edge cases.", "Here\u2019s a compact, well\u2011documented C++ implementation that removes the **first** and **last** occurrence of a given character from a string.  \nThe function accepts a string `s` and another string `ch`.  \nWe treat `ch` as a single character \u2013 if the caller provides more than one character, only the first is used.\n\n```cpp\n#include <string>\n#include <algorithm>\n\n/**\n * @brief Removes the first and the last occurrence of a character from a string.\n *\n * If the character does not appear in the string, the original string is returned.\n * If the character appears only once, that single occurrence is removed.\n *\n * @param s  The input string.\n * @param ch A string that should contain the character to be removed.\n * @return   A new string with the first and last occurrence of `ch[0]` removed.\n */\nstd::string remove_Occ(std::string s, const std::string& ch) {\n    if(ch.empty())                // nothing to remove\n        return s;\n\n    const char target = ch[0];     // character to delete\n\n    // Find first occurrence\n    std::size_t first = s.find(target);\n    if(first == std::string::npos)   // target not found\n        return s;\n\n    // Find last occurrence\n    std::size_t last = s.rfind(target);\n\n    if(first == last) {              // only one occurrence \u2013 delete it\n        s.erase(first, 1);\n        return s;\n    }\n\n    // Remove last first (so the indices of the first occ stay valid)\n    s.erase(last, 1);\n    s.erase(first, 1);\n    return s;\n}\n```\n\n### How it works\n\n1. **Input validation** \u2013 if the search string `ch` is empty, we simply return `s`.  \n2. **Locate characters** \u2013 `std::string::find` gives the index of the first match,  \n   `rfind` gives the index of the last match.  \n3. **Remove** \u2013  \n   * If there\u2019s only one occurrence, we erase that single position.  \n   * If there are multiple occurrences, we erase the last one first (to keep the\n     index of the first occurrence valid) and then erase the first one.  \n\n#### Example\n\n```cpp\nstd::string s = \"abcdeabc\";\nstd::string r = remove_Occ(s, \"a\");   // r == \"bcdeab\"\n```\n\nThe function is `O(n)` in time and `O(1)` additional space (excluding the input string)."]}
{"completions": ["Here is a minimal, self\u2011contained implementation that does what the comment says:  \nyou give it a vector of `std::any` objects and an integer **step** and it returns a vector of\nvectors, each sub\u2011vector having at most **step** elements (the last one can be shorter).\n\n```cpp\n#include <vector>\n#include <any>\n#include <cassert>\n\n/*\n   Splits the vector S into chunks of size *step* (except possibly the\n   last chunk which can be smaller).  For example:\n\n       S = {1, 2, 3, 4, 5, 6, 7}\n       step = 3\n\n   returns { {1,2,3}, {4,5,6}, {7} }\n*/\nstd::vector<std::vector<std::any>>\nlist_split(const std::vector<std::any>& S, std::size_t step)\n{\n    assert(step > 0 && \"step must be a positive integer\");\n\n    std::vector<std::vector<std::any>> result;\n    std::size_t n = S.size();\n\n    for (std::size_t i = 0; i < n; i += step)\n    {\n        // The end of the current chunk is either i+step or the\n        // end of the vector, whichever comes first.\n        std::size_t end = std::min(i + step, n);\n        result.emplace_back(S.begin() + i, S.begin() + end);\n    }\n\n    return result;\n}\n```\n\n### Highlights\n\n* **Type:** `std::vector<std::any>` is used to keep the original implementation\n  idea but the algorithm works completely generically \u2013 you could replace\n  `std::any` with any other type without changing the logic.\n* **Const\u2011reference input:** The input vector is taken by `const&` to avoid\n  unnecessary copies.\n* **Safety:** An `assert` ensures that `step` is not zero; in a production\n  environment you could replace this with error handling (throwing an\n  exception, returning an empty result, etc.).\n* **Efficiency:** The function constructs each sub\u2011vector only once\n  (`emplace_back` with a range constructor), so the overall complexity is\n  `O(n)` where `n` is the length of `S`.", "Here is a minimal, self\u2011contained implementation that will compile with a recent C++ compiler (C++17 or newer).  \nThe function simply walks through the input vector `S` and creates a new sub\u2011vector every `step` elements.\n\n```cpp\n#include <vector>\n#include <any>\n#include <cstddef>   // for std::size_t\n\n// ---------------------------------------------------------------------------\n// Splits a vector into sub\u2011vectors every `step` elements.\n//\n// Example:\n//   S    = {1,2,3,4,5,6,7,8,9}\n//   step = 3\n// Results in: {{1,2,3}, {4,5,6}, {7,8,9}}\n//\n// Parameters\n//  ---------\n//  S      \u2013 input vector of std::any (may contain any type)\n//  step   \u2013 number of elements per chunk (must be > 0)\n// ---------------------------------------------------------------------------\nstd::vector<std::vector<std::any>>\nlist_split(const std::vector<std::any>& S, std::size_t step)\n{\n    // Guard against an empty or invalid `step`\n    if (step == 0) {\n        throw std::invalid_argument(\"step must be > 0\");\n    }\n\n    std::vector<std::vector<std::any>> result;\n\n    // Loop over the source vector, pushing a new chunk every `step` items.\n    for (std::size_t i = 0; i < S.size(); i += step)\n    {\n        // Compute end index: do not exceed S.size()\n        std::size_t end = std::min(i + step, S.size());\n\n        // Create sub\u2011vector from [i, end)\n        std::vector<std::any> chunk(S.begin() + i, S.begin() + end);\n        result.push_back(std::move(chunk));\n    }\n\n    return result;\n}\n```\n\n### Notes\n\n* The function takes the source vector by **const reference** so it does not make a copy unless it has to (when building chunks).  \n* it throws an exception if `step == 0` to avoid an infinite loop or division errors.  \n* The implementation works with `std::any` (any type) because it never dereferences the contained value \u2013 it simply copies the `any` objects.  \n* If you want to use the helper, just add the usual header guards, include the needed headers and you\u2019re good to go.", "Below is a ready\u2011to\u2011compile implementation of `list_split`.  \nThe function takes a `std::vector<std::any>` and a splitting step `step`.  \nIt returns a `std::vector<std::vector<std::any>>` where each inner vector\ncontains at most `step` elements taken in order from the original vector.\n\n```cpp\n#include <any>\n#include <vector>\n#include <cassert>\n\n/*\n * Splits the input vector `S` into consecutive chunks of length `step`.\n * The last chunk may be shorter if the number of elements\n * in `S` is not an exact multiple of `step`.\n *\n * @param S     The vector to split (by value \u2013 a copy is made).\n * @param step  The number of elements per split (must be > 0).\n *\n * @return      A vector of vectors each of which contains up to `step`\n *              elements from `S`. If `S` is empty, an empty vector is\n *              returned.\n */\nstd::vector<std::vector<std::any>>\nlist_split(std::vector<std::any> S, long step)\n{\n    assert(step > 0 && \"split step must be positive\");\n\n    std::vector<std::vector<std::any>> result;\n\n    // Handle the trivial empty case\n    if (S.empty())\n        return result;\n\n    // Reserve space: at most ceil(S.size()/step)\n    result.reserve((S.size() + step - 1) / step);\n\n    for (size_t i = 0; i < S.size(); i += static_cast<size_t>(step)) {\n        size_t end = std::min(i + static_cast<size_t>(step), S.size());\n        // Construct a chunk using a half\u2011open range [i, end)\n        std::vector<std::any> chunk(S.begin() + i, S.begin() + end);\n        result.emplace_back(std::move(chunk));\n    }\n\n    return result;\n}\n```\n\n### Quick test\n\n```cpp\n#include <iostream>\n#include <string>\n\nint main() {\n    std::vector<std::any> input = { 1, 2.5, std::string(\"hello\"), 4, 5 };\n    auto parts = list_split(input, 2);\n\n    for (const auto& chunk : parts) {\n        std::cout << \"[ \";\n        for (const auto& el : chunk) {\n            if (el.type() == typeid(int))\n                std::cout << std::any_cast<int>(el) << \" \";\n            else if (el.type() == typeid(double))\n                std::cout << std::any_cast<double>(el) << \" \";\n            else if (el.type() == typeid(std::string))\n                std::cout << std::any_cast<std::string>(el) << \" \";\n        }\n        std::cout << \"]\\n\";\n    }\n}\n```\n\nOutput:\n\n```\n[ 1 2.5 ]\n[ hello 4 ]\n[ 5 ]\n```\n\nThe implementation is generic, safe (it uses `assert` to guard against an illegal step), and works for any non\u2011empty vector of `std::any`."]}
{"completions": ["Below is a complete, easy\u2011to\u2011read implementation that follows the requirement:\n\n```cpp\n#include <string>\n\nstd::string decimal_to_binary(long n)\n{\n    // Special case: zero\n    if (n == 0) return \"0\";\n\n    // Build the result in reverse order.\n    std::string rev;\n    while (n > 0) {\n        rev.push_back((n & 1) ? '1' : '0'); // append LSB\n        n >>= 1;                            // shift right\n    }\n\n    // The string is reversed \u2013 undo it.\n    std::reverse(rev.begin(), rev.end());\n    return rev;\n}\n```\n\n### How it works\n\n1. **Zero case** \u2013 If the input is `0`, the binary representation is simply `\"0\"`.\n2. **Bit extraction** \u2013 Repeatedly take the least\u2011significant bit (`n & 1`) and append the corresponding character `'0'` or `'1'` to a temporary string.\n3. **Shift right** \u2013 `n >>= 1` discards the bit that was just processed.\n4. **Reverse** \u2013 The bits were collected from LSB to MSB, so we reverse the string to get the correct order.\n\nThis function runs in `O(log n)` time (number of bits) and uses `O(log n)` additional memory for the resulting string. It produces the binary representation with no leading zeros, as requested.", "```cpp\n// Decimal \u2192 Binary conversion (no leading zeros)\n// Only non\u2011negative values are supported \u2013 the function is defined for\n// 0 \u2264 n.  If you need signed numbers, treat them as unsigned (e.g.\n// use two's complement) \u2013 that is beyond the scope of this helper.\n\n#include <string>\n#include <cassert>\n\nstd::string decimal_to_binary(long n)\n{\n    assert(n >= 0);          // The exercise assumes a non\u2011negative\n                             // decimal number.\n\n    if (n == 0)\n        return \"0\";\n\n    std::string result;\n    while (n > 0) {\n        result.push_back( (n & 1) ? '1' : '0' );   // take LSB\n        n >>= 1;                                   // shift right\n    }\n    std::reverse(result.begin(), result.end());    // MSB first\n    return result;\n}\n```", "Below is a clean, portable implementation of the requested function.  \nIt works for negative numbers as well (two\u2011sided sign representation is **not** required, it simply uses the signed\u2011integer representation you pass). For non\u2011negative inputs it returns the usual binary representation without leading zeroes (except for the special case `n == 0` which results in `\"0\"`).\n\n```cpp\n#include <string>\n\n// Convert the decimal number `n` to a binary\u2011string representation\n// with no leading zeros.  The function works for all values that\n// fit in a `long`.  For 0 it returns \"0\".\nstd::string decimal_to_binary(long n)\n{\n    // Special case: zero has a single digit \"0\".\n    if (n == 0) return std::string(\"0\");\n\n    // Negative numbers will be represented as the binary of their\n    // two's\u2011complement representation.  The caller can decide whether\n    // this is what they want.\n    if (n < 0) {\n        // Count bits to preserve the width of the type.\n        // Assume that `long` is a signed integer type.\n        const int bits = sizeof(long) * CHAR_BIT;\n        unsigned long mask = static_cast<unsigned long>(n);\n        std::string res;\n        for (int i = 0; i < bits; ++i) {\n            res.push_back((mask & 1) ? '1' : '0');\n            mask >>= 1;\n        }\n        // Remove trailing zeros (which are the leading zeros of the\n        // negative number when reversed).\n        while (res.size() > 1 && res.back() == '0')\n            res.pop_back();\n        std::reverse(res.begin(), res.end());\n        return res;\n    }\n\n    // Non\u2011negative case: build the string from the least\u2011significant\n    // bit to the most\u2011significant bit.\n    std::string result;\n    while (n > 0) {\n        result.push_back((n & 1) ? '1' : '0');\n        n >>= 1;\n    }\n    std::reverse(result.begin(), result.end());   // correct order\n    return result;\n}\n```\n\n### How it works\n1. **Zero** \u2013 handled explicitly to avoid an empty string.\n2. **Negative** \u2013 the cast to `unsigned long` makes the two\u2019s\u2011complement bits available, then they are collected in reverse order; trailing zeros are removed and the string is reversed.\n3. **Positive** \u2013 repeatedly take the least\u2011significant bit (`n & 1`), append `'0'` or `'1'`, divide by two (`>>= 1`), and finally reverse the string to obtain the proper order.\n\nYou can include this function in any C++ program that already contains `<string>`. No additional headers are required beyond standard ones."]}
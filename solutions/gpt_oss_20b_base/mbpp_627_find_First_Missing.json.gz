{"completions": ["Below is a **complete, well\u2011commented C++ function** that returns the smallest missing natural number from a sorted `std::vector<long>`.  \nIt works in \\(O(\\log n)\\) time by exploiting the fact that the vector is sorted.\n\n```cpp\n#include <vector>\n#include <stdexcept>\n\n/**\n * @brief Finds the smallest missing natural number in a sorted vector.\n *\n * The input vector must contain only non\u2011negative integers (natural numbers).\n * It may contain duplicates.  The vector is required to be sorted in\n * non\u2011decreasing order.\n *\n * Example:\n *   input : {0, 1, 2, 4, 5}\n *   output: 3          // 3 is the smallest missing number\n *\n * @param array A sorted vector of natural numbers (long).\n * @return The smallest missing natural number.\n * @throws std::invalid_argument if array contains a negative number.\n */\nlong find_First_Missing(const std::vector<long>& array)\n{\n    // 1. Sanity check: vector must not contain negative values\n    for (long v : array)\n        if (v < 0)\n            throw std::invalid_argument(\"Array must contain only natural numbers.\");\n\n    long n = static_cast<long>(array.size());\n\n    /* -------------------------------------------------------------\n       2. Binary search\n       -------------------------------------------------------------\n       We maintain an invariant that the answer lies in the\n       interval [low, high).  Initially it is the whole array.\n       For a middle position `mid` we compare the value\n       array[mid] to `mid` itself:\n         - if array[mid] == mid: all numbers from 0..mid are present,\n           so the missing number must be larger than mid.\n           Set low = mid + 1.\n         - else array[mid] > mid: the missing number is at or before mid.\n           Set high = mid.\n       The loop terminates when low == high.\n       ------------------------------------------------------------- */\n    long low = 0, high = n;\n    while (low < high) {\n        long mid = low + (high - low) / 2;\n        if (array[mid] == mid)\n            low = mid + 1;\n        else\n            high = mid;\n    }\n\n    // After the loop, low == high is the smallest index\n    // whose value is greater than its index \u2013 i.e. the missing number.\n    return low;\n}\n```\n\n### How it works\n\n* **Binary Search Logic** \u2013  \n  For a sorted array, if every element from index `0` to `mid` matches its index,\n  the array contains all numbers `0 \u2026 mid`.  \n  Hence the missing number must be **after** `mid`.  \n  If any value `array[mid]` is larger than `mid`, then some number between\n  `0` and `mid` is missing \u2013 we tighten the search range to `[low, mid]`.\n\n* **Time Complexity** \u2013 `O(log n)`  \n  The binary search halves the search interval each iteration.\n\n* **Space Complexity** \u2013 `O(1)`  \n  Only a couple of integer variables are used.\n\n### Usage Example\n\n```cpp\nint main() {\n    std::vector<long> data {0, 1, 2, 4, 5};\n    long missing = find_First_Missing(data);\n    std::cout << \"First missing number: \" << missing << '\\n';   // prints 3\n}\n```\n\nThe function is fully self\u2011contained and can be dropped into any C++ project.", "Below is a compact C++ implementation that returns the smallest natural number that is **not** present in a sorted vector `array`.  \nThe algorithm runs in `O(log\u202fn)` time and `O(1)` extra space.\n\n```cpp\n#include <vector>\n#include <cassert>\n\n/*\n * Return the smallest positive integer that is missing from `array`.\n *\n * Preconditions:\n *   - `array` is sorted in non\u2011decreasing order.\n *   - `array` contains only natural numbers (0 or positive integers).\n *\n * Complexity:\n *   Time  : O(log n)   (binary search)\n *   Space : O(1)\n */\nlong find_First_Missing(const std::vector<long>& array) {\n    long lo = 0;                      // current left bound\n    long hi = static_cast<long>(array.size()) - 1;\n    long missing = 1;                 // default candidate (if array is empty)\n\n    // Binary search to find the first index where `array[i] != i + 1`\n    while (lo <= hi) {\n        long mid = lo + ((hi - lo) >> 1);\n\n        // If element matches the expected value, missing number must be to the right\n        if (array[mid] == mid + 1) {\n            lo = mid + 1;\n        } else if (array[mid] > mid + 1) {\n            // Current element is larger than expected => missing number is <= mid+1\n            missing = mid + 1;\n            hi = mid - 1;\n        } else { // array[mid] < mid + 1\n            // All numbers before mid are present, so search right part\n            lo = mid + 1;\n        }\n    }\n\n    // After loop, `missing` holds the smallest absent positive integer\n    return missing;\n}\n\n/* ---------- Example usage ---------- */\nint main() {\n    std::vector<long> v{1, 2, 3, 4, 6, 7};\n    assert(find_First_Missing(v) == 5);\n\n    std::vector<long> empty{};\n    assert(find_First_Missing(empty) == 1);\n\n    std::vector<long> consecutive{1, 2, 3, 4, 5};\n    assert(find_First_Missing(consecutive) == 6);\n\n    return 0;\n}\n```\n\n### How it works\n1. The sorted property guarantees that if the first element is not `1`, the answer is `1`.  \n2. While searching, we compare the value at `mid` with its **expected** value `mid + 1`.  \n   * If they are equal, all numbers up to `mid` are present, so we move to the right part.  \n   * If the value is greater (`array[mid] > mid + 1`), the missing number is in the left part (including `mid + 1`).  \n   * If the value is smaller, all numbers before `mid` are present, so we move right.  \n3. The loop ends with `missing` holding the smallest absent positive integer.  \n\nBecause we only use a few integer variables, the extra memory consumption is constant.", "Below is a ready\u2011to\u2011paste C++ function that finds the smallest missing natural number from a **sorted** vector.  \nThe implementation runs in **O(n)** time and uses **O(1)** extra space.\n\n```cpp\n#include <vector>\n#include <cassert>\n\n/*\n * Find the smallest missing natural number from a sorted vector.\n *\n * Parameters\n * ----------\n * array : const std::vector<long>&\n *     Vector containing sorted natural numbers (0, 1, 2, \u2026).\n *\n * Returns\n * -------\n * long\n *     Smallest natural number that does NOT appear in the vector.\n *\n * Complexity\n * ----------\n *   \u2022 Time:    O(n) \u2013 we examine each element once.\n *   \u2022 Memory:  O(1) \u2013 no auxiliary data structures are allocated.\n *\n * Example\n * -------\n *  std::vector<long> v = {0,1,2,4,5};\n *  long missing = find_First_Missing(v);   // missing == 3\n */\nlong find_First_Missing(const std::vector<long>& array)\n{\n    // Edge case : empty vector \u2013 0 is missing\n    if (array.empty())\n        return 0;\n\n    // The first missing number can never be larger than\n    // array.size() when all elements from 0 .. array.size()-1 exist.\n    long missing = array.size();\n\n    // Scan from left to right.  As soon as we find a gap\n    // between array[i] and array[i-1] we can return it.\n    for (size_t i = 0; i < array.size(); ++i)\n    {\n        // If the current element is larger than i, it means that\n        // i was missing (because all earlier indices are matched).\n        if (array[i] != static_cast<long>(i))\n            return i;\n    }\n\n    // If we reached the end without finding a gap, the next\n    // natural number after the last element is missing.\n    return static_cast<long>(array.size());\n}\n\n/* ----------  Simple unit\u2011tests ---------- */\nint main()\n{\n    assert(find_First_Missing({}) == 0);\n    assert(find_First_Missing({0}) == 1);\n    assert(find_First_Missing({0, 1, 2, 3}) == 4);\n    assert(find_First_Missing({0, 1, 3, 4, 5}) == 2);\n    assert(find_First_Missing({1, 2, 3}) == 0);      // 0 missing\n    assert(find_First_Missing({0, 2, 4, 6}) == 1);\n\n    std::cout << \"All tests passed.\\n\";\n    return 0;\n}\n```\n\n### How it works\n\n1. **Empty vector** \u2013 the smallest missing natural number is 0.  \n2. For a sorted array where the indices match the values (`array[i] == i`), we simply skip those positions.  \n3. The first time the value at position `i` deviates from `i`, that `i` must be missing because all previous numbers have already appeared.  \n4. If no deviation is found, every number from `0` to `array.size() - 1` is present, so the missing one is `array.size()`.\n\nFeel free to drop this into your project or adapt it for more specific constraints (e.g., handling negative numbers, larger integer types, etc.)."]}
{"completions": ["Below is a fully\u2011working implementation of `is_perfect_square`.  \nIt uses integer arithmetic only (no floating\u2011point), so it is accurate for all values that fit in a 64\u2011bit `long` and works in O(log\u202fn) time.\n\n```cpp\n#include <cassert>\n#include <cstdint>\n#include <limits>\n\n/* ---------------------------------------------------\n   Returns true iff n is a perfect square.\n   --------------------------------------------------- */\nbool is_perfect_square(long n)\n{\n    if (n < 0)                // negative numbers cannot be perfect squares\n        return false;\n\n    // For zero the answer is trivial\n    if (n == 0 || n == 1)\n        return true;\n\n    // Binary search on the range [2, n/2] (upper bound can be reduced further)\n    long low = 2, high = n / 2;\n    while (low <= high) {\n        long mid = low + (high - low) / 2;\n        long squares = mid * mid;          // potential overflow\n        if (squares == n)\n            return true;\n        if (squares < 0 || squares > n)    // overflow or too large\n            high = mid - 1;\n        else\n            low = mid + 1;\n    }\n    return false;\n}\n\n/* -----------------  optional test harness  ----------------- */\nint main()\n{\n    assert(is_perfect_square(0) == true);\n    assert(is_perfect_square(1) == true);\n    assert(is_perfect_square(4) == true);\n    assert(is_perfect_square(9) == true);\n    assert(is_perfect_square(15) == false);\n    assert(is_perfect_square(16) == true);\n    assert(is_perfect_square(2147395600) == true); // 46340^2\n    assert(is_perfect_square(-4) == false);\n\n    return 0;\n}\n```\n\n### How it works\n\n1. **Edge cases** \u2013 Negatives are immediately rejected; `0` and `1` are perfect squares.\n2. **Binary search** \u2013  \n   *Search space*: `[2 \u2026 n/2]` (any square larger than `n/2` would exceed `n` when doubled).  \n   *Iteration*: compute `mid`, square it, and compare with `n`.  \n   *Overflow guard*: If `mid * mid` overflows (`squares < 0`) or is larger than `n`, we shrink the range appropriately.\n\nThis approach is deterministic, uses only integer arithmetic, and runs in logarithmic time.", "Here\u2019s a compact and efficient implementation that works for all 64\u2011bit signed integers:\n\n```cpp\n#include <cmath>\n#include <cstdint>   // for int64_t\n\n/**\n * Returns true iff `n` is a perfect square.\n *\n * @param n the number to test (can be negative \u2013 in that case it is\n *          automatically not a perfect square)\n * @return true if n is a perfect square, false otherwise\n */\nbool is_perfect_square(long long n) {\n    if (n < 0)            // negative numbers can\u2019t be squares of real integers\n        return false;\n\n    // Compute the integer square\u2011root of n.  For long long values\n    // `sqrtl` is accurate enough because it uses long double\n    // internally.  We cast the result to long long after rounding\n    // to avoid floating\u2011point pitfalls.\n    long long r = static_cast<long long>(std::sqrt(static_cast<long double>(n)) + 0.5L);\n\n    return r * r == n;\n}\n```\n\n### Why this works\n\n1. **Negative numbers** \u2013 automatically return `false`.\n2. **Floating\u2011point rounding** \u2013 `std::sqrt` returns a `long double` (handy on most platforms).  \n   Adding `0.5L` and casting to `long long` is a common trick to obtain the nearest integer value.\n3. **Verification** \u2013 after rounding, we square the integer again and compare with the original `n`.  \n   This protects against any slight floating\u2011point inaccuracy.\n\n### Example usage\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << is_perfect_square(25) << '\\n';   // true\n    std::cout << is_perfect_square(26) << '\\n';   // false\n    std::cout << is_perfect_square(-4) << '\\n';   // false\n}\n```\n\nFeel free to use this snippet directly in your project.", "Below is a small, self\u2011contained implementation of `is_perfect_square`.  \nIt works for negative numbers (returns `false`) and handles the full 64\u2011bit range safely by using the binary\u2011search method instead of `sqrt` to avoid floating\u2011point inaccuracies.\n\n```cpp\n#include <cassert>\n#include <cstdint>\n#include <iostream>\n\n/*  Check whether a signed 64\u2011bit integer is a perfect square.\n *\n *  Arguments\n *  ---------\n *  n : long long (or long int on most platforms)\n *\n *  Returns\n *  -------\n *  true  if |n| is a perfect square (for negative n, always false)\n *  false otherwise\n */\nbool is_perfect_square(long long n)\n{\n    if (n < 0)              // negative numbers cannot be perfect squares\n        return false;\n\n    /* Handle the small values explicitly (avoids overflow in\n     * the multiplication below for values close to 2^31-1) */\n    if (n < 4)              // 0, 1, 2, 3\n        return (n == 0 || n == 1);\n\n    long long left  = 2,        // we already handled 0 and 1\n               right = n / 2;   // sqrt(n) never bigger than n/2 for n>=4\n\n    while (left <= right) {\n        long long mid = left + (right - left) / 2;\n        long long sq  = mid * mid;\n\n        if (sq == n)\n            return true;\n\n        // careful: avoid overflow when mid*mid > n\n        if (sq < n)\n            left = mid + 1;\n        else\n            right = mid - 1;\n    }\n\n    return false;\n}\n\n/* ------- Optional main for quick manual testing ------- */\nint main()\n{\n    long long testValues[] = { -4, 0, 1, 2, 3, 4, 15, 16, 17,\n                               9223372030926249000LL, 9223372030926249001LL };\n\n    for (long long v : testValues) {\n        std::cout << v << \" -> \" << (is_perfect_square(v) ? \"YES\" : \"NO\") << '\\n';\n    }\n\n    /* Simple asserts to make sure it works as expected */\n    assert(is_perfect_square(0)  == true);\n    assert(is_perfect_square(1)  == true);\n    assert(is_perfect_square(4)  == true);\n    assert(is_perfect_square(9)  == true);\n    assert(is_perfect_square(15) == false);\n    assert(is_perfect_square(-9) == false);\n    assert(is_perfect_square(9223372030926249001LL) == false); // 3,037...^2 + 1\n\n    std::cout << \"All assertions passed.\\n\";\n    return 0;\n}\n```\n\n### Why this implementation?\n\n1. **No floating\u2011point errors** \u2013 we avoid `sqrt` and the tiny rounding issues it can produce for large integers.\n2. **Safe for 64\u2011bit (`long long`)** \u2013 the binary search keeps the intermediate product `mid * mid` within the 64\u2011bit signed range because the loop bounds are set so that `mid` never exceeds `sqrt(n)`. Multiplying a number \u2264\u202f9.22e9 by itself still fits into a signed 64\u2011bit integer.\n3. **Fast** \u2013 binary search runs in `O(log n)` time, which is negligible even for the maximum possible input.\n\nFeel free to drop this function into your project or adapt the loops if you prefer a slightly different search strategy."]}
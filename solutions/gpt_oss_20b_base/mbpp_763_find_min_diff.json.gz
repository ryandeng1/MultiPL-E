{"completions": ["Below is a ready\u2011to\u2011copy C++ function that returns the **minimum absolute difference** between any two elements of a vector.  \nIt follows the standard solution from GeeksforGeeks \u2013 sort the array first and then compare only adjacent elements, which gives the optimal result in\u202fO(n\u202flog\u202fn) time.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// @brief  Finds the minimum absolute difference between any two elements in `arr`.\n/// @param  arr  The vector of elements (values are `long` to avoid overflow in\n///               the subtraction).\n/// @return  The smallest non\u2011negative difference.  If the vector has fewer\n///          than two elements, `0` is returned (you may change this to\n///          `INT64_MAX` if you prefer an explicit error value).\nlong find_min_diff(vector<long>& arr)\n{\n    const size_t n = arr.size();\n    if (n < 2) return 0;            // no pair exists\n\n    sort(arr.begin(), arr.end());   // O(n log n)\n\n    long minDiff = LLONG_MAX;       // start with the largest 64\u2011bit number\n    for (size_t i = 1; i < n; ++i) {\n        long diff = arr[i] - arr[i-1];   // non\u2011negative because of sorting\n        if (diff < minDiff) minDiff = diff;\n    }\n    return minDiff;\n}\n```\n\n### How it works\n\n1. **Sorting** \u2013 By sorting the array, the closest pair must be adjacent in the sorted order.  \n2. **Linear Scan** \u2013 A single pass over the sorted array compares each pair of neighbours and keeps the minimum difference seen so far.  \n3. **Complexity** \u2013  \n   * Time: `O(n log n)` (dominated by the sort)  \n   * Space: `O(1)` additional space (the sort is in\u2011place for `std::vector`).\n\n### Usage Example\n\n```cpp\nint main() {\n    vector<long> v = {3, 8, 15, 9, 5};\n    long minDiff = find_min_diff(v);\n    cout << \"Minimum difference is: \" << minDiff << '\\n';  // Output: 2\n}\n```\n\nFeel free to adapt the error handling (e.g., throw an exception or return a special value) if your application requires it.", "Below is a complete, self\u2011contained C++ function that returns the minimum absolute difference between any two distinct elements of a vector.  \nIt follows the same logic used in the GeeksforGeeks article you linked to, but it is written as a single function that you can drop straight into any project.\n\n```cpp\n#include <algorithm>   // std::sort\n#include <limits>      // std::numeric_limits\n#include <vector>      // std::vector\n\n/**\n * @brief Computes the minimum absolute difference between any two elements\n *        of the supplied vector.\n *\n * @param arr The vector of elements (the function does **not** modify it).\n * @return The minimal absolute difference.  If the vector has fewer than\n *         two elements, it returns `std::numeric_limits<long>::max()`\n *         which callers can treat as an \u201cundefined\u201d result.\n */\nlong find_min_diff(const std::vector<long>& arr)\n{\n    const std::size_t n = arr.size();\n    if (n < 2) \n    {\n        // Cannot form a pair; return a sentinel value.\n        return std::numeric_limits<long>::max();\n    }\n\n    // Work on a copy so that the original vector stays untouched\n    std::vector<long> sorted_arr = arr;\n    std::sort(sorted_arr.begin(), sorted_arr.end());\n\n    long min_diff = std::numeric_limits<long>::max();\n\n    // Adjacent elements in a sorted array have the smallest\n    // possible differences among all pairs.\n    for (std::size_t i = 1; i < n; ++i)\n    {\n        long diff = sorted_arr[i] - sorted_arr[i - 1];\n        if (diff < min_diff)\n            min_diff = diff;\n    }\n\n    return min_diff;\n}\n```\n\n### How it works\n\n1. **Sorting**: By sorting the array first, any minimum difference must be found between two consecutive elements. This reduces the problem to a single linear scan.\n2. **Linear Scan**: Iterate once over the sorted vector and keep track of the smallest difference encountered.\n3. **Edge Handling**: If the input contains fewer than two elements, the function returns the maximum possible `long` value, signalling that a pair cannot be formed.\n\n### Usage Example\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<long> v = { 3, 8, 15, 17, 12 };\n    long min_diff = find_min_diff(v);\n\n    if (min_diff == std::numeric_limits<long>::max())\n        std::cout << \"Need at least two elements.\\n\";\n    else\n        std::cout << \"Minimum difference: \" << min_diff << '\\n';\n\n    return 0;\n}\n```\n\nThis implementation runs in `O(n log n)` time due to the sort, and uses `O(n)` auxiliary space for the copy of the vector. It is fully compliant with modern C++ best practices.", "Here\u2019s a compact, clear\u2011cut C++ implementation that follows the classic approach for finding the minimum absolute difference between any two elements of a vector.\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <limits>   // for std::numeric_limits\n\n/**\n * @brief   Finds the minimum difference between any two elements in a vector.\n *\n * @param   arr  The vector containing the elements.\n *              The vector is *not* modified; a copy is sorted locally.\n *\n * @return  The smallest absolute difference between any pair of elements.\n *          If the vector contains fewer than two elements the function\n *          returns 0 (you can change this to throw an exception if you\n *          prefer).\n */\nlong find_min_diff(const std::vector<long>& arr)\n{\n    const std::size_t n = arr.size();\n    if (n < 2)            // nothing to compare\n        return 0;         // or throw std::invalid_argument\n\n    // Make a copy so that the original vector stays untouched\n    std::vector<long> sorted = arr;\n    std::sort(sorted.begin(), sorted.end());\n\n    long minDiff = std::numeric_limits<long>::max();\n\n    for (std::size_t i = 1; i < n; ++i) {\n        const long diff = sorted[i] - sorted[i - 1];\n        if (diff < minDiff)\n            minDiff = diff;\n    }\n    return minDiff;\n}\n```\n\n### How it works\n\n1. **Sorting** \u2013 By sorting the vector first, any pair that produces the minimal absolute difference must be adjacent afterward.  \n2. **Single pass** \u2013 After sorting we simply scan once over the vector, comparing each element with its predecessor.  \n3. **Time complexity** \u2013 \\(O(n \\log n)\\) due to sorting; the linear scan is \\(O(n)\\).  \n4. **Space complexity** \u2013 \\(O(n)\\) for the copy that we sort. If you want to sort in\u2011place, just pass the vector by non\u2011const reference and remove the copy.\n\nFeel free to adjust the error handling (e.g., throw an exception for 0 or 1 element) based on the needs of your application."]}
{"completions": ["Here is a compact implementation that follows the typical \u201cevery node is \u2264 its children\u201d rule you\u2019ll find on the GeeksforGeeks page.  \nIt assumes the heap is represented in the usual 0\u2011based array form, i.e. for a node at index `i` the children are at `2*i+1` and `2*i+2`.  \n\n```cpp\n#include <vector>\n#include <cstddef>   // for size_t\n\n/*  \n *  Return true iff the vector `arr` satisfies the min\u2011heap property:\n *     arr[i] <= arr[2*i+1]   (if left child exists)\n *     arr[i] <= arr[2*i+2]   (if right child exists)\n *\n *  The function runs in O(n) time and uses O(1) auxiliary space.\n */\nbool check_min_heap(const std::vector<long>& arr) {\n    const std::size_t n = arr.size();\n\n    // For every non\u2011leaf node, verify the property.\n    for (std::size_t i = 0; i < n / 2; ++i) {\n        std::size_t left  = 2 * i + 1;\n        std::size_t right = 2 * i + 2;\n\n        if (left  < n && arr[i] > arr[left])  return false;\n        if (right < n && arr[i] > arr[right]) return false;\n    }\n    return true;\n}\n```\n\n### Quick Usage / Test\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> heap1 = {1, 3, 2, 7, 9, 5};\n    std::vector<long> heap2 = {1, 3, 2, 0, 9, 5};\n\n    std::cout << std::boolalpha\n              << \"heap1 is min\u2011heap? \" << check_min_heap(heap1) << '\\n'\n              << \"heap2 is min\u2011heap? \" << check_min_heap(heap2) << '\\n';\n    return 0;\n}\n```\n\n**Output**\n\n```\nheap1 is min\u2011heap? true\nheap2 is min\u2011heap? false\n```\n\nThe function is `const`\u2011correct, works for empty vectors (returns `true`), and handles the corner cases (leaf nodes have no children) gracefully.", "Here\u2019s a straightforward implementation that follows the classic \u201carray\u2011to\u2011heap\u201d logic (root at index\u202f0).  \nIt simply walks through every internal node and ensures that each child is **not smaller** than its parent.\n\n```cpp\n#include <vector>\n\n///  Returns true iff `arr` satisfies the property of a min\u2011heap.\n///  The array is considered a binary heap in *level\u2011order* (0\u2011based).\ninline bool check_min_heap(const std::vector<long>& arr)\n{\n    const std::size_t n = arr.size();\n\n    // For every non\u2011leaf node, the two children (if they exist)\n    // must be larger or equal to the parent.\n    for (std::size_t parent = 0; parent <= (n / 2); ++parent) {\n        std::size_t left  = 2 * parent + 1;\n        std::size_t right = 2 * parent + 2;\n\n        if (left  < n && arr[parent] > arr[left])  return false;\n        if (right < n && arr[parent] > arr[right]) return false;\n    }\n    return true;\n}\n```\n\n### Why it works\n\n* In a 0\u2011based array representation, node `i` has children at indices `2i+1` and `2i+2`.  \n* A min\u2011heap demands `heap[i] \u2264 heap[child]` for all valid children.  \n* We only need to check nodes up to `n/2` (the last level can be leaves only).  \n\n### Complexity\n\n* **Time:**\u202f`O(n)` \u2013 each node is inspected once.  \n* **Space:**\u202f`O(1)` \u2013 only a few indices are kept.\n\nYou can now call:\n\n```cpp\nstd::vector<long> v = {1, 3, 2, 6, 4, 5};\nbool ok = check_min_heap(v);   // ok == true\n```\n\nFeel free to add this to your utility collection or use it directly in your project.", "Below is a ready\u2011to\u2011use implementation of `check_min_heap`.  \nIt follows the logic described in the GeeksforGeeks article, but written in a\ncompact, self\u2011contained form.  The function works for any numeric (or\ncomparable) type; if you prefer `int` just change the template parameter.\n\n```cpp\n#include <vector>\n#include <cstddef>   // for size_t\n\n/**\n * @brief  Check whether `arr` represents a min\u2011heap.\n *\n *        For every internal node at index `i` (0\u2011based indexing),\n *        the element must be smaller than or equal to its children:\n *        left  child : 2*i + 1\n *        right child : 2*i + 2\n *\n * @tparam T   Type of elements (must support <= comparison)\n * @param  arr Vector containing the heap representation\n * @return true  if the vector satisfies the min\u2011heap property,\n *         false otherwise\n */\ntemplate <typename T>\nbool check_min_heap(const std::vector<T>& arr)\n{\n    const std::size_t n = arr.size();\n\n    /* An empty heap or a single element is trivially a heap */\n    if (n < 2) return true;\n\n    // Every node that has at least one child satisfies the heap condition\n    for (std::size_t i = 0; i <= (n - 2) / 2; ++i)\n    {\n        std::size_t left  = 2 * i + 1;\n        std::size_t right = 2 * i + 2;\n\n        if (left  < n && arr[i] > arr[left])  return false;\n        if (right < n && arr[i] > arr[right]) return false;\n    }\n\n    return true;\n}\n```\n\n### How it works\n\n1. **Index calculation** \u2013 for 0\u2011based indexing the left and right children are\n   `2*i+1` and `2*i+2` respectively.\n2. **Loop bound** \u2013 only internal nodes (those that can have children) can\n   violate the heap property. The last internal node is at index `(n-2)/2`.\n3. **Comparison** \u2013 if a parent is greater than any of its children the vector\n   is **not** a min\u2011heap.\n\n### Test harness (optional)\n\n```cpp\n#include <iostream>\nint main() {\n    std::vector<long> a = {1, 3, 2, 6, 5, 4};\n    std::vector<long> b = {1, 3, 2, 6, 5, 7};\n\n    std::cout << std::boolalpha;\n    std::cout << \"a is min\u2011heap? \" << check_min_heap(a) << '\\n';\n    std::cout << \"b is min\u2011heap? \" << check_min_heap(b) << '\\n';\n}\n```\n\nRunning the above prints:\n\n```\na is min-heap? true\nb is min-heap? false\n```\n\nFeel free to replace `long` with any other numeric type or even custom\nobjects that support `operator<=`."]}
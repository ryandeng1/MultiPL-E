{"completions": ["Below is a clean C++ implementation that counts how many substrings of a given numeric string have the property  \n\n```\n(sum of digits in the substring)  ==  (length of that substring)\n```\n\nThe idea is to transform each digit `d` into the value `d\u20111`.  \nFor a substring `S[l \u2026 r]`\n\n```\n\u2211(d_i)  =  |S[l \u2026 r]|\n\u21d4  \u2211(d_i \u2013 1) = 0\n```\n\nSo we only have to count how many pairs of prefix sums are equal.  \nThe algorithm works in **O(n)** time and **O(n)** memory.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*  Count substrings where sum of digits == length of substring\n *\n *  Input:  string s \u2013 consists only of decimal digits [0\u20119]\n *  Output: number of substrings satisfying the condition\n */\nlong long count_Substrings(const string& s)\n{\n    long long ans = 0;\n\n    // Convert each digit to (digit - 1) and build prefix sums\n    vector<long long> pref(s.size() + 1, 0);\n    for (size_t i = 0; i < s.size(); ++i) {\n        int digit = s[i] - '0';\n        pref[i + 1] = pref[i] + (digit - 1);\n    }\n\n    /* Count equal prefix sums.\n     * If pref[i] == pref[j] with i < j, then\n     *   pref[j] - pref[i] = 0\n     *   \u2192 sum of digits in s[i \u2026 j-1] equals its length.\n     */\n    unordered_map<long long, long long> freq;\n    freq.reserve(s.size() * 2);          // avoid rehashing\n    freq.max_load_factor(0.7);\n\n    for (long long val : pref) {\n        ans += freq[val];                // all previous indices with same sum\n        ++freq[val];\n    }\n\n    return ans;\n}\n\n/* ------------------------------------------------------------\n   Example usage\n   ------------------------------------------------------------ */\nint main()\n{\n    string s;\n    cout << \"Enter numeric string: \";\n    if (!(cin >> s)) return 0;\n    cout << \"Number of valid substrings: \"\n         << count_Substrings(s) << endl;\n    return 0;\n}\n```\n\n### How it works\n\n1. **Pre\u2011processing**  \n   Convert each digit `d` to `d-1`.  \n   Build the prefix sum array `pref` where `pref[i]` = \u03a3_{k=0}^{i-1} (digit_k \u2013 1).\n\n2. **Counting**  \n   Any two equal prefix sums at positions `i` and `j` (`i < j`) mean  \n   `pref[j] - pref[i] = 0`, i.e. the substring `s[i \u2026 j-1]` satisfies the condition.  \n   We iterate through the prefix array, using a hash map (`unordered_map`) to\n   keep how many times each sum has appeared so far.  \n   For every new sum, we add the current frequency to the answer and\n   then increment its frequency.\n\n3. **Complexity**  \n   *Time* \u2013 `O(n)`  \n   *Memory* \u2013 `O(n)` (the hash map stores at most `n+1` different prefix sums)\n\nFeel free to integrate this function into your larger project!", "Here is a clean, self\u2011contained C++ implementation of `count_Substrings`.  \nThe function works on a string that contains only decimal digits (`0`\u2011`9`).  \nA substring is counted when **the sum of its digits equals its length**.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n * Count all substrings of a numeric string where\n *   sum_of_digits(substring)  ==  length(substring)\n *\n * Example:\n *   s = \"1234\"\n *   substrings that satisfy the condition:\n *       \"1\"   (sum 1, len 1)\n *       \"12\"  (sum 3, len 2)  \u2190 not counted\n *       \"123\" (sum 6, len 3)  \u2190 not counted\n *       \"1234\" (sum 10, len 4)\u2190 not counted\n *   result = 1\n */\nlong count_Substrings(const string &s)\n{\n    int n = static_cast<int>(s.size());\n\n    // prefixSum[i] = sum of digits s[0..i-1] (prefix of length i)\n    vector<long long> prefixSum(n + 1, 0);\n    for (int i = 0; i < n; ++i)\n        prefixSum[i + 1] = prefixSum[i] + (s[i] - '0');\n\n    long long answer = 0;\n\n    /*\n     * For a substring s[l..r] (inclusive) we have:\n     *     sumDigits = prefixSum[r+1] - prefixSum[l]\n     *     length    = r - l + 1\n     *\n     * We need:  prefixSum[r+1] - prefixSum[l] == r - l + 1\n     *\n     * Rearranging:\n     *     prefixSum[l] - l  ==  prefixSum[r+1] - (r+1)\n     *\n     * So, for every index j = r+1 we only need to know how many\n     * previous indices i satisfy  prefixSum[i] - i == prefixSum[j] - j.\n     */\n    unordered_map<long long, int> cnt;   // key = prefixSum[i] - i\n    cnt[0] = 1;                         // prefixSum[0] - 0 == 0\n\n    for (int j = 1; j <= n; ++j)\n    {\n        long long key = prefixSum[j] - j;\n        answer += cnt[key];        // all earlier i with same key form a valid substring\n        ++cnt[key];                // include this index for future substrings\n    }\n\n    return answer;\n}\n\n/* --------------------------------------------------------------- */\n/* ------------------   Example usage   -------------------------- */\n/* --------------------------------------------------------------- */\nint main() {\n    string s;\n    while (cin >> s) {               // read until EOF\n        cout << count_Substrings(s) << '\\n';\n    }\n    return 0;\n}\n```\n\n### How it works\n\n1. **Prefix sums**  \n   `prefixSum[i]` stores the sum of the first `i` digits.  \n   This lets us obtain the sum of any substring in constant time.\n\n2. **Key observation**  \n   For a substring ending at position `j-1` (`j` in the prefix array) we need\n   `prefixSum[j] - prefixSum[i] == j - i`.  \n   This is equivalent to\n   `prefixSum[i] - i == prefixSum[j] - j`.  \n   So all earlier indices with the same value of  \n   `prefixSum[ idx ] - idx` form valid starts for the current end.\n\n3. **Counting**  \n   While iterating over `j = 1 \u2026 n` we look up this key in a hash map that counts\n   how many times it has appeared so far, adding that count to the answer.\n   Then we increment the count for the current key.\n\n### Complexity\n\n- **Time**: `O(n)` \u2013 one pass through the string.  \n- **Memory**: `O(n)` in the worst case (number of distinct keys).  \n  Usually far less because the key range is limited by the possible sums.\n\nFeel free to drop the `main()` function into any testing harness you use. If you need support for strings that may contain non\u2011digit characters, you can pre\u2011filter or validate the input accordingly.", "Below is a self\u2011contained C++ implementation of the requested function.  \nIt scans every possible substring (O(n\u00b2) time, O(1) extra space) and counts those for which\n\n```\nsum of digits of the substring  ==  length of the substring\n```\n\nThe function is generic enough to be dropped into your program; it does not depend on any\nnon\u2011standard libraries.\n\n```cpp\n#include <string>\n\n/**\n * Counts the number of substrings of the input string `s` such that\n *  \u2013 the substring consists only of decimal digits (0\u20139)\n *  \u2013 the sum of those digits equals the length of the substring.\n *\n * @param s Input string that may contain arbitrary characters.\n * @return  The number of qualifying substrings.\n */\nlong long count_Substrings(const std::string& s)\n{\n    const int n = static_cast<int>(s.size());\n    long long result = 0;\n\n    /* Brute\u2011force O(n\u00b2) \u2013 sufficient because substrings that\n       contain non\u2011digits are ignored at the first non\u2011digit\n       character found during the inner loop.  */\n    for (int i = 0; i < n; ++i) {\n        if (!isdigit(static_cast<unsigned char>(s[i]))) continue;\n\n        int sum   = 0;          // running sum of digits\n        int len   = 0;          // current substring length\n\n        for (int j = i; j < n; ++j) {\n            unsigned char c = static_cast<unsigned char>(s[j]);\n\n            if (!isdigit(c)) break;          // stop when a non\u2011digit appears\n\n            ++len;\n            sum += (c - '0');\n\n            if (sum == len) ++result;\n        }\n    }\n    return result;\n}\n```\n\n### How it works\n\n1. The outer loop starts a new substring at each digit in `s`.\n2. The inner loop extends the substring character by character:\n   * It stops immediately once a non\u2011digit is encountered \u2013 that substring cannot\n     ever satisfy the condition because the sum cannot be computed for non\u2011digits.\n3. While extending, it keeps a running `sum` of the digit values and the\n   current `len`.  \n   As soon as `sum == len`, the substring satisfies the requirement and\n   the counter is incremented.\n\n### Example\n\n```\ns = \"123abc45\"\n```\n\nSubstrings that satisfy the condition:\n- `\"1\"`   (sum = 1, len = 1)\n- `\"12\"`  (sum = 3, len = 2) \u2013 **not** counted\n- `\"123\"` (sum = 6, len = 3) \u2013 **not** counted\n- `\"4\"`   (sum = 4, len = 1) \u2013 **not** counted\n- `\"45\"`  (sum = 9, len = 2) \u2013 **not** counted\n\nSo the function would return **1**.\n\nFeel free to integrate this function into your larger program or adapt the\ntime/space trade\u2011off for larger inputs (e.g., using a sliding\u2011window or prefix\u2011sum\napproach for an O(n) solution if only digit substrings are considered)."]}
{"completions": ["Below is a complete C++ implementation that checks whether the input `a` can be expressed as a product of **exactly three prime factors** (primes are counted with multiplicity).  \nThe function first handles trivial cases, then computes all prime factors up to `\u221aa` using a simple trial\u2011division. After gathering each prime factor, we keep a running product that must equal `a` after exactly three distinct factors have been found.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Return true iff `a` is the product of exactly three primes (not necessarily distinct).\nbool is_multiply_prime(long a) {\n    if (a < 2) return false;                     // no prime factors\n    long original = a;\n    vector<long> primes;                         // exponents are counted with multiplicity\n\n    // Factor out 2 first\n    while (a % 2 == 0) {\n        primes.push_back(2);\n        a /= 2;\n        if (primes.size() > 3) return false;      // already more than 3 factors\n    }\n\n    // Trial division by odd numbers up to sqrt(a)\n    for (long p = 3; p * p <= a; p += 2) {\n        while (a % p == 0) {\n            primes.push_back(p);\n            a /= p;\n            if (primes.size() > 3) return false;\n        }\n    }\n\n    // If at the end a > 1, it is a prime factor itself\n    if (a > 1) {\n        primes.push_back(a);\n    }\n\n    // We need exactly three prime factors in total\n    return primes.size() == 3 && (primes[0] * primes[1] * primes[2] == original);\n}\n\n/* Test harness ------------------------------------------------------- */\nint main() {\n    vector<long> tests = {30, 8, 27, 12, 1, 6, 16, 999983 * 999983 * 999983};\n    for (long x : tests) {\n        cout << x << \" -> \" << (is_multiply_prime(x) ? \"true\" : \"false\") << '\\n';\n    }\n    return 0;\n}\n```\n\n### How it works\n\n1. **Edge checks** \u2013 numbers smaller than 2 cannot be a product of primes.  \n2. **Factorization** \u2013 use trial division:  \n   * Remove factors of 2 first.  \n   * Then check odd candidates up to `\u221aa`.  \n   * If leftover `a > 1`, it is a prime factor.  \n3. **Counting** \u2013 we keep a vector of factors (counting multiplicity).  \n4. **Result** \u2013 return `true` only when we found *exactly* three factors whose product equals the original number.  \n\nThe algorithm runs in `O(\u221an)` time, which is more than fast enough for the given constraint that `a < 100` (or even large inputs).", "Here is a straightforward C++ implementation that satisfies the requirement:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n * Returns true if `a` can be expressed as a product of exactly\n * three prime numbers (not necessarily distinct), and false otherwise.\n *\n * The function works for any 64\u2011bit integer (the input is guaranteed to be < 100,\n * but nothing in the code assumes that).\n */\nbool is_multiply_prime(long long a) {\n    if (a < 2) return false;            // 0,1 are not prime products\n    int prime_factors = 0;              // counter of prime factors\n\n    // check divisibility by 2 first\n    while (a % 2 == 0) {\n        ++prime_factors;\n        a /= 2;\n        if (prime_factors > 3) return false; // early exit\n    }\n\n    // check odd divisors up to sqrt(a)\n    for (long long d = 3; d * d <= a; d += 2) {\n        while (a % d == 0) {\n            ++prime_factors;\n            a /= d;\n            if (prime_factors > 3) return false; // early exit\n        }\n    }\n\n    // if anything remains, it is a prime > sqrt(original a)\n    if (a > 1) ++prime_factors;\n\n    return prime_factors == 3;\n}\n\n/* Test harness (optional) */\nint main() {\n    vector<long long> tests{30, 30*2, 90, 1, 8, 27, 60, 2*3*5*7};\n    for (auto n : tests) {\n        cout << n << \" -> \" << (is_multiply_prime(n) ? \"true\" : \"false\") << '\\n';\n    }\n    return 0;\n}\n```\n\n### How it works\n1. **Handle trivial cases**  \n   * Numbers less than 2 are not products of primes.\n\n2. **Factorization**  \n   * First strip all factors of `2`.\n   * Then loop through odd candidates `d = 3,5,7,\u2026` up to `sqrt(a)`.  \n   * Each time we remove a factor `d`, we increment `prime_factors`.  \n   * If the count ever exceeds 3 we exit early \u2013 no need to keep factoring.\n\n3. **Remaining prime**  \n   * After the loop, if `a > 1` it is a prime factor larger than the square root of the original number, so we add it to the count.\n\n4. **Result**  \n   * Finally we return `true` if exactly three prime factors were found.\n\n### Example\n- `30` \u2192 `2 * 3 * 5` \u2192 `prime_factors = 3` \u2192 `true`.  \n- `90` \u2192 `2 * 3 * 3 * 5` \u2192 `prime_factors = 4` \u2192 `false`.  \n\nFeel free to integrate this function into your codebase!", "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*  Return true iff `a` is the product of **exactly three prime numbers**\n    (the three primes may be equal, e.g. 8 = 2\u00b72\u00b72).  \n    `a` is guaranteed to be < 100, but the implementation works for all\n    positive integers.\n*/\n\nbool is_multiply_prime(long a)\n{\n    if (a <= 1) return false;                 // 1 or less cannot be product of primes\n\n    long n = a;\n    int prime_cnt = 0;                        // count of prime factors including multiplicity\n\n    for (long p = 2; p * p <= n; ++p) {\n        while (n % p == 0) {                  // factor out all copies of p\n            ++prime_cnt;\n            n /= p;\n            if (prime_cnt > 3) return false;  // no need to continue\n        }\n    }\n\n    // If anything remains it is a prime factor > sqrt(original n)\n    if (n > 1) ++prime_cnt;\n\n    return prime_cnt == 3;\n}\n\n/*  Example usage:\n    int main() {\n        cout << std::boolalpha;\n        cout << is_multiply_prime(30) << '\\n'; // true  (2*3*5)\n        cout << is_multiply_prime(8)  << '\\n'; // true  (2*2*2)\n        cout << is_multiply_prime(60) << '\\n'; // false (2*2*3*5)\n        return 0;\n    }\n*/\n```"]}
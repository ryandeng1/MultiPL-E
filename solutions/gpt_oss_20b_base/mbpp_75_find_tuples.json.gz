{"completions": ["Here is a complete, self\u2011contained implementation of the requested function.  \nThe function iterates over the input vector, checks the three elements of each `std::tuple<long,long,long>` with the modulus operator, and keeps only those tuples whose every element is divisible by `K`. The result is returned in a new vector.  \n\n```cpp\n#include <vector>\n#include <tuple>\n#include <cassert>\n\n// ---------------------------------------------------------------------\n//  Find tuples which have all elements divisible by K\n// ---------------------------------------------------------------------\nstd::vector<std::tuple<long, long, long>>\nfind_tuples(std::vector<std::tuple<long, long, long>> test_list, long K)\n{\n    // Guard against division by zero \u2013 we simply return an empty vector\n    // in that case.  (You can throw instead if you prefer.)\n    if (K == 0) {\n        return {};\n    }\n\n    std::vector<std::tuple<long, long, long>> result;\n    result.reserve(test_list.size());          // reserve once to avoid re\u2011alloc\n\n    for (const auto& t : test_list) {\n        long a = std::get<0>(t);\n        long b = std::get<1>(t);\n        long c = std::get<2>(t);\n\n        if (a % K == 0 && b % K == 0 && c % K == 0) {\n            result.push_back(t);               // keep the entire tuple\n        }\n    }\n    return result;\n}\n\n// ---------------------------------------------------------------------\n//  Optional test harness (uncomment to compile and run)\n// ---------------------------------------------------------------------\n// int main() {\n//     std::vector<std::tuple<long, long, long>> input = {\n//         {6, 12, 18},\n//         {7, 14, 21},\n//         {9, 3, 6},\n//         {10, 20, 30}\n//     };\n//\n//     auto output = find_tuples(input, 3);\n//     assert(output.size() == 2);  // {6,12,18} and {9,3,6}\n//\n//     for (const auto& tup : output) {\n//         std::cout << '(' << std::get<0>(tup) << \", \"\n//                   << std::get<1>(tup) << \", \"\n//                   << std::get<2>(tup) << \")\\n\";\n//     }\n//     return 0;\n// }\n```\n\n**Explanation of key points**\n\n1. **Robustness** \u2013 If `K` is zero the function simply returns an empty vector; you could also throw an exception if that fits your use\u2011case.\n2. **Efficiency** \u2013 `reserve()` pre\u2011allocates the maximum possible size, avoiding repeated dynamic resizes.\n3. **Clarity** \u2013 `std::get<index>(tuple)` fetches the individual elements for readability.\n4. **Portability** \u2013 Only standard headers `<vector>` and `<tuple>` are required; no need for `<bits/stdc++.h>`.", "Below is a small, self\u2011contained implementation that satisfies the requirement:\n\n```cpp\n#include <tuple>\n#include <vector>\n#include <cassert>\n\nusing Tup = std::tuple<long, long, long>;\n\n/**\n * @brief Returns all tuples from `test_list` whose every element is divisible by `K`.\n *\n * @param test_list Input vector of tuples.  The function makes no modifications to it.  \n * @param K          Divisor.  If K == 0 the behaviour is undefined (asserts in debug mode).\n * @return std::vector<std::tuple<long,long,long>>  All qualifying tuples in the same order as they appeared in `test_list`.\n */\nstd::vector<Tup> find_tuples(const std::vector<Tup>& test_list, long K)\n{\n    assert(K != 0 && \"K must be non\u2011zero\");\n\n    std::vector<Tup> out;\n    out.reserve(test_list.size());          // reserve max possible size\n\n    for (const Tup& t : test_list) {\n        long a = std::get<0>(t);\n        long b = std::get<1>(t);\n        long c = std::get<2>(t);\n\n        if (a % K == 0 && b % K == 0 && c % K == 0)\n            out.push_back(t);\n    }\n\n    return out;\n}\n\n/* -----------------------------------------------------------------------\n   Example usage (not part of the required function):\n\n   int main() {\n       std::vector<Tup> data = { {6,12,18}, {5,9,15}, {10,20,30} };\n       auto res = find_tuples(data, 6);\n       // res will contain (6,12,18) only.\n   }\n   ------------------------------------------------------------------------ */\n```\n\n### Points to note\n\n1. **Safety** \u2013 The function uses `assert` to guard against a zero divisor, which would otherwise cause a runtime error.  \n2. **Standard containers** \u2013 Only `<tuple>` and `<vector>` are required; no `<bits/stdc++.h>`.  \n3. **Passed\u2011by\u2011const\u2011reference** \u2013 The input vector is taken by reference and is not modified.  \n4. **Return value** \u2013 A new vector holds the matching tuples, preserving the original order.", "Here is a complete, ready\u2011to\u2011compile implementation.  \nThe function simply iterates through the supplied vector of tuples, checks that **each** of the three\u00a0`long` values is divisible by `K`, and collects those tuples that satisfy the condition.\n\n```cpp\n#include <tuple>\n#include <vector>\n#include <cstddef>   // for std::size_t\n\n/**\n * @brief   Returns a subset of `test_list` containing only those tuples\n *          whose three elements are all divisible by `K`.\n *\n * @param test_list  Vector of tuples to be filtered.\n * @param K          The divisor that all tuple elements must satisfy.\n *\n * @return A vector of tuples for which all three elements % K == 0.\n */\nstd::vector<std::tuple<long, long, long>>\nfind_tuples(const std::vector<std::tuple<long, long, long>>& test_list,\n            long K)\n{\n    // Guard against division by zero.\n    if (K == 0) {\n        return {};   // No tuple can satisfy divisibility by zero.\n    }\n\n    std::vector<std::tuple<long, long, long>> result;\n    result.reserve(test_list.size());   // minimal allocation\n\n    for (const auto& tup : test_list) {\n        long a = std::get<0>(tup);\n        long b = std::get<1>(tup);\n        long c = std::get<2>(tup);\n\n        if (a % K == 0 && b % K == 0 && c % K == 0) {\n            result.push_back(tup);\n        }\n    }\n\n    return result;\n}\n```\n\n### How it works\n1. **Guard clause** \u2013 If `K` is zero we immediately return an empty vector because no integer can be divisible by zero.\n2. **Reserve** \u2013 We reserve space in the result vector to avoid repeated reallocations.\n3. **Loop** \u2013 For every tuple we unpack the three `long` values with `std::get`.\n4. **Check** \u2013 All three values must have a remainder of zero when divided by `K`.\n5. **Collect** \u2013 Matching tuples are moved into the `result` vector.\n\nThis implementation is simple, efficient (linear in the number of tuples), and works with any vector of `std::tuple<long,long,long>` you provide."]}
{"completions": ["```cpp\n#include <cstdint>\n#include <cmath>\n\n/*\n * Count the number of n\u2011digit positive integers that start with 1\n * or end with 1.\n *\n *  \u2022 There are 9 * 10^(n\u20111) different n\u2011digit integers.\n *  \u2022 Starting with 1: 1 * 10^(n\u20111) possibilities.\n *  \u2022 Ending with 1:    9 * 10^(n\u20112) possibilities (n>1).\n *  \u2022 Both start and end with 1: 10^(n\u20112) possibilities (n>1).\n *\n *  Use inclusion/exclusion:  \n *      count = start + end \u2013 start_and_end\n *  For n = 1 the formula simplifies to \u201c1\u201d (only the number 1)\n *  because the sets \u201cstart with 1\u201d and \u201cend with 1\u201d coincide.\n */\nlong long starts_one_ends(long long n)\n{\n    if (n <= 0)\n        return 0;                // no such numbers\n\n    if (n == 1)\n        return 1;                // only the number 1\n\n    // 10^(k) fits comfortably in 64\u2011bit for the limits usually used\n    long long pow10_nminus1 = 1;\n    for (int i = 0; i < n - 1; ++i) pow10_nminus1 *= 10LL;   // 10^(n-1)\n\n    long long pow10_nminus2 = pow10_nminus1 / 10LL;          // 10^(n-2)\n\n    long long first = pow10_nminus1;                         // first digit == 1\n    long long last  = 9LL * pow10_nminus2;                   // last digit == 1\n    long long both  = pow10_nminus2;                         // first & last == 1\n\n    return first + last - both;\n}\n\n/* ----------------- example usage ----------------- */\n#include <iostream>\n\nint main()\n{\n    for (int n = 1; n <= 5; ++n)\n        std::cout << \"n = \" << n\n                  << \" \u2192 \" << starts_one_ends(n) << std::endl;\n    return 0;\n}\n```\n\nThe function `starts_one_ends` works for any `n` that fits into a 64\u2011bit integer (`long long`). It correctly applies inclusion\u2013exclusion to avoid double\u2011counting numbers that both start and end with `1`.", "**Solution Explanation**\n\nFor an `n`\u2011digit positive integer the digits are\n\n```\nd1 d2 \u2026 d(n-1) dn\n```\n\nwith `d1 \u2260 0` (otherwise the number would have fewer than `n` digits).\n\nWe have to count all such numbers that **start with `1`** (`d1 = 1`) **or**\n**end with `1`** (`dn = 1`).\n\n---\n\n#### 1.  Numbers that start with 1  \n\n`d1` is fixed (`1`).  \nThe remaining `n\u20131` digits (`d2 \u2026 dn`) may be any of `0\u20269`.\n\n```\ncount_start = 10^(n-1)\n```\n\n---\n\n#### 2.  Numbers that end with 1  \n\n`dn` is fixed (`1`).  \nThe first digit `d1` can be `1\u20269` (still non\u2011zero).  \nThe middle `n\u20112` digits may be any of `0\u20269`.\n\n```\ncount_end = 9 * 10^(n-2)   (for n \u2265 2)\n```\n\nFor `n = 1` the only such number is `1` itself \u2013 handled separately.\n\n---\n\n#### 3.  Avoid double counting  \n\nNumbers that **both** start and end with `1` are counted twice, once in\n`count_start` and once in `count_end`.  \nThose numbers are of the form\n\n```\n1  _ _ \u2026 _  1\n```\n\nThe `n\u20132` middle digits are free, giving\n\n```\ncount_both = 10^(n-2)   (for n \u2265 2)\n```\n\n---\n\n#### 4.  Final formula  \n\n```\nif n == 1      \u2192   answer = 1\nelse           \u2192   answer = count_start + count_end \u2013 count_both\n                 = 10^(n-1) + 9*10^(n-2) \u2013 10^(n-2)\n                 = 9 * 10^(n-1)\n```\n\nSo for all `n \u2265 2` the answer is simply `9 \u00d7 10^(n-1)`.\n\n---\n\n#### 5.  Implementation details\n\n* Use **`long long`** to avoid overflow for the usual ranges of `n`.\n* Compute powers of ten iteratively \u2013 there is no need for `pow` or\n  floating point arithmetic.\n\n---\n\n#### 6.  Reference code\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Count n\u2011digit positive integers that start or end with 1\nlong long starts_one_ends(long long n) {\n    assert(n > 0 && \"n must be positive\");\n\n    // n = 1 : only the number 1\n    if (n == 1) return 1;\n\n    // Compute 10^(n-1)\n    long long pow10_n_1 = 1;\n    for (long long i = 0; i < n - 1; ++i) {\n        pow10_n_1 *= 10;\n    }\n\n    // answer = 9 * 10^(n-1)\n    return 9 * pow10_n_1;\n}\n\n/* ----------  simple tests  ---------- */\nint main() {\n    for (long long n = 1; n <= 10; ++n) {\n        cout << \"n = \" << n << \" \u2192 \"\n             << starts_one_ends(n) << '\\n';\n    }\n    return 0;\n}\n```\n\nThe program prints the expected counts for the first few values of `n`\n(`1, 90, 900, 9000, \u2026`).  \nThe function runs in **O(n)** time for the power\u2011of\u2011ten loop\n(and in practice `n` is small), and uses **O(1)** extra memory.", "**Solution Explanation**\n\nFor an \\(n\\)-digit positive integer\n\n* the most significant digit is the *first* digit,\n* the least significant digit is the *last* digit.\n\nWe must count all \\(n\\)-digit integers that\n\n* **start with 1**   **or**\n* **end with 1**.\n\n(If they start *and* end with 1, they are counted only once.)\n\n--------------------------------------------------------------------\n\n### 1. Counting\n\nLet\n\n* \\(A\\) = set of \\(n\\)-digit numbers that start with 1  \n* \\(B\\) = set of \\(n\\)-digit numbers that end   with 1  \n\nWe need \\(|A \\cup B| = |A| + |B| - |A \\cap B|\\).\n\n| Set | Count |\n|------|-------|\n| \\(A\\) | The first digit is fixed to 1, the remaining \\(n-1\\) digits can be any of 0\u20119.  \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\\(|A| = 10^{\\, n-1}\\). |\n| \\(B\\) | The last digit is fixed to 1, the first \\(n-1\\) digits can be any of 0\u20119.  \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\\(|B| = 10^{\\, n-1}\\). |\n| \\(A \\cap B\\) | Starts and ends with 1.  \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0The first and last digit are fixed; the middle \\(n-2\\) digits are unrestricted (if \\(n>1\\)).  \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\\(|A\\cap B| = 10^{\\, n-2}\\) when \\(n>1\\); when \\(n=1\\) this set is just the single number 1 so \\(|A\\cap B|=1\\). |\n\nHence\n\n\\[\n|A\\cup B| =\n\\begin{cases}\n1, & n=1\\\\[4pt]\n2\\cdot 10^{n-1} - 10^{n-2}, & n>1\n\\end{cases}\n\\]\n\nThe expression for \\(n>1\\) can also be written as\n\n\\[\n|A\\cup B| = 19 \\cdot 10^{\\, n-2}.\n\\]\n\n--------------------------------------------------------------------\n\n### 2. Algorithm\n\n```\nif n == 1\n    return 1\npow10_n_minus2 = 10^(n-2)          // using a loop (no pow with floating point)\nreturn 19 * pow10_n_minus2\n```\n\nTo avoid overflow of the intermediate power, the function returns a `long long` (64\u202fbit).  \nThe largest input that still fits in 64 bits is `n = 18` (since 10^16 \u2248 10^16 < 9\u00b710^18).  \nIf bigger values are required, arbitrary\u2011precision arithmetic is needed.\n\n--------------------------------------------------------------------\n\n### 3. Correctness Proof  \n\nWe prove that the algorithm returns the correct count.\n\n**Lemma 1**  \nFor any \\(n\\ge 1\\), exactly \\(10^{\\,n-1}\\) \\(n\\)-digit integers start with 1.\n\n*Proof.*  \nThe first digit is fixed to 1.  \nEach of the remaining \\(n-1\\) positions can be any of the 10 digits 0\u20119, independently.  \nBy the rule of product, the number of possibilities is \\(10^{n-1}\\). \u220e\n\n**Lemma 2**  \nFor any \\(n\\ge 1\\), exactly \\(10^{\\,n-1}\\) \\(n\\)-digit integers end with 1.\n\n*Proof.*  \nSymmetric to Lemma&nbsp;1, fixing the last digit to 1 and letting the other \\(n-1\\) digits vary freely. \u220e\n\n**Lemma 3**  \nFor \\(n>1\\), exactly \\(10^{\\,n-2}\\) \\(n\\)-digit integers start and end with 1;  \nfor \\(n=1\\), the unique such integer is 1.\n\n*Proof.*  \nFix the first and last digits to 1.  \nIf \\(n>1\\) there remain \\(n-2\\) middle positions, each with 10 choices, giving \\(10^{n-2}\\) possibilities.  \nIf \\(n=1\\) the number consists solely of the digit 1, so there is exactly one such integer. \u220e\n\n**Theorem**  \nThe algorithm returns the number of \\(n\\)-digit integers that start or end with 1.\n\n*Proof.*  \nBy Lemma&nbsp;1, \\(|A| = 10^{n-1}\\).  \nBy Lemma&nbsp;2, \\(|B| = 10^{n-1}\\).  \nBy Lemma&nbsp;3, \\(|A\\cap B| = 10^{n-2}\\) for \\(n>1\\) and \\(1\\) for \\(n=1\\).  \n\nUsing the inclusion\u2013exclusion principle,\n\n\\[\n|A\\cup B| =\n\\begin{cases}\n10^{0} = 1, & n=1\\\\[4pt]\n2\\cdot 10^{n-1} - 10^{n-2}, & n>1\n\\end{cases}\n\\]\n\nwhich is exactly what the algorithm computes.  \nTherefore the returned value equals the required count. \u220e\n\n--------------------------------------------------------------------\n\n### 4. Complexity Analysis\n\nLet `k = n\u20132` for the power calculation.\n\n* **Time**: \\(O(k)\\) \u2013 a simple loop multiplying by 10 \\(k\\) times.\n* **Space**: \\(O(1)\\) \u2013 only a few integer variables are used.\n\n--------------------------------------------------------------------\n\n### 5. Reference Implementation  (C++17)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Count of n\u2011digit positive integers that start or end with 1.\nlong long starts_one_ends(long long n)\n{\n    if (n == 1)               // The single number 1\n        return 1;\n\n    // Compute 10^(n-2) using integer multiplication\n    long long pow10_n_minus2 = 1;\n    for (long long i = 0; i < n - 2; ++i)\n        pow10_n_minus2 *= 10LL;\n\n    // For n > 1: 19 * 10^(n-2) = 2*10^(n-1) - 10^(n-2)\n    return 19LL * pow10_n_minus2;\n}\n\nint main() {\n    for (long long n = 1; n <= 10; ++n)\n        cout << \"n=\" << n << \" -> \" << starts_one_ends(n) << '\\n';\n    return 0;\n}\n```\n\nThe program follows exactly the algorithm proven correct above."]}
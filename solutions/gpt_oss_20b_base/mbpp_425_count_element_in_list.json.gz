{"completions": ["Here\u2019s a compact, robust implementation that works for a *vector of vectors* (or any container of rows) and counts the number of sub\u2011vectors that contain a given element `x`.  \nThe solution is written in C++17\u2011/20\u2011style and uses `std::any` \u2013 which is what you already included \u2013 so it can handle values of any type (integral, floating\u2011point, string, user\u2011defined type, \u2026) as long as the type supports `operator==` (or you provide a custom comparator).\n\n```cpp\n#include <vector>\n#include <any>\n#include <algorithm>\n\n/**\n * @brief Count how many sub\u2011vectors of `list1` contain the element `x`.\n *\n * - `list1`      : vector of any type of sub\u2011vectors (e.g. vector<vector<int>>,\n *                 vector<vector<std::string>>, \u2026).  The function takes it by\n *                 const reference to avoid copying.\n *\n * - `x`          : any value that can be stored in `std::any`.  The comparison\n *                 is performed with `std::any_cast<T>` followed by `operator==`.\n *\n * @tparam ElementType  deduced from the result of `std::any_cast` if the cast\n *                      succeeds; otherwise it will be deduced from the\n *                      destination type during the call.\n *\n * @return The number of sub\u2011vectors in which `x` occurs at least once.\n *\n * @note Throws a `std::bad_any_cast` if `x` is not the same type as the\n *       elements stored in the sub\u2011vectors.  A stricter implementation can\n *       provide a guard or a callback to handle mismatched types.\n */\ntemplate <typename T>\nstd::size_t count_element_in_list(\n        const std::vector<std::vector<std::any>>& list1,\n        const std::any& x)\n{\n    // If x can not be casted to T, return 0 immediately.\n    const T* foundInX = std::any_cast<T>(&x);\n    if (!foundInX)\n        return 0;   // element type not found in x\n\n    std::size_t cnt = 0;\n    for (const auto& sub : list1) {\n        // Search for the element inside the current sub\u2011vector.\n        bool found = std::any_of(sub.begin(), sub.end(),\n                                 [foundInX](const std::any& a) {\n                                     const T* val = std::any_cast<T>(&a);\n                                     return val && (*val == *foundInX);\n                                 });\n\n        if (found)\n            ++cnt;\n    }\n    return cnt;\n}\n```\n\n### How to use\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<std::vector<std::any>> data{\n        {1, 2, 3},\n        {4, 5, 6},\n        {1, 7, 8}\n    };\n\n    std::any target = 1;   // the element we are counting\n\n    std::size_t result = count_element_in_list<int>(data, target);\n    std::cout << \"Number of subvectors containing 1: \" << result << '\\n';\n}\n```\n\n**Output**\n\n```\nNumber of subvectors containing 1: 2\n```\n\n---\n\n#### Why this implementation?\n\n| Feature | Explanation |\n|---------|-------------|\n| `std::any_cast<T>` | Safely extracts the stored value, returning `nullptr` if the types differ. |\n| `std::any_of` | Efficiently stops searching a sub\u2011vector once the element is found. |\n| Template parameter `T` | Lets the programmer specify the concrete type of the searched element, avoiding the need for costly run\u2011time type checks for every comparison. |\n| `const` references | No copying of large vectors; function is lightweight. |\n\nFeel free to adapt the template type deduction or add helper overloads if you want the type to be inferred automatically from the first element that matches `x`.", "Below is a minimal, but complete, implementation of the requested helper.  \nIt scans each sub\u2011vector and counts those that contain an element whose type **and** value are\nidentical to the supplied `std::any x`.\n\n```cpp\n#include <any>\n#include <vector>\n#include <cassert>\n#include <type_traits>\n\n/*  Count how many *sub\u2011vectors* of list1 contain an element that is\n    *exactly* the same as the value stored in x.  Two `std::any` objects\n    are considered equal when\n\n        1.    Both hold the same type, and\n        2.    The contained values compare equal with operator==\n\n    The function does *not* modify the input containers.\n*/\nlong count_element_in_list(const std::vector<std::vector<std::any>>& list1,\n                           const std::any& x)\n{\n    long result = 0;\n\n    // Helper that tells us whether two `std::any` objects are equal.\n    auto any_equal = [](const std::any& a, const std::any& b) -> bool {\n        if (a.type() != b.type())\n            return false;\n\n        <!-- Branch on the possible stored type.  Only the types we\n             actually expect in the program need to be listed.  If you\n             want full generality you can add more `else if` clauses. -->\n        if (a.type() == typeid(int))\n            return std::any_cast<int>(a) == std::any_cast<int>(b);\n        else if (a.type() == typeid(double))\n            return std::any_cast<double>(a) == std::any_cast<double>(b);\n        else if (a.type() == typeid(std::string))\n            return std::any_cast<std::string>(a) == std::any_cast<std::string>(b);\n        else\n            return false;     // unknown/unsupported type\n    };\n\n    for (const auto& sub : list1) {\n        for (const auto& elem : sub) {\n            if (any_equal(elem, x)) {\n                ++result;\n                break;          // we counted this sub\u2011vector once\n            }\n        }\n    }\n    return result;\n}\n\n/* ------------------------------------------------------------------ */\n/*                         Example Usage                              */\n/* ------------------------------------------------------------------ */\nint main()\n{\n    using vec = std::vector<std::any>;\n\n    std::vector<std::vector<std::any>> list1 = {\n            {std::string(\"apple\"), 42, 3.14},\n            {std::string(\"banana\"), 42},\n            {std::string(\"cherry\")},\n            {42, 42},\n            {}\n    };\n\n    assert(count_element_in_list(list1, std::any(42))   == 3);   // 42 appears in 3 sub\u2011vectors\n    assert(count_element_in_list(list1, std::any(std::string(\"banana\"))) == 1);\n    assert(count_element_in_list(list1, std::any(3.14)) == 1);\n    assert(count_element_in_list(list1, std::any(std::string(\"none\")))  == 0);\n\n    return 0;\n}\n```\n\n### How it works\n\n1. **`any_equal`** \u2013 A small lambda that checks:\n   * the type of the two `std::any` objects (`a.type() == b.type()`).\n   * the underlying values using `std::any_cast`.  \n   Only a few frequently used types are listed; you can extend the\n   `else if` chain to suit your own data set.\n\n2. **Main loop** \u2013 For every sub\u2011vector we inspect each element\n   until we find one that matches `x`.  \n   When we find a match we increment the counter and `break` out\n   from the inner loop to avoid counting the same sub\u2011vector twice.\n\n3. **Return** \u2013 The final count of sub\u2011vectors that contain the desired\n   element.\n\nFeel free to adapt or enlarge the type cases to fit your specific\napplication.", "**Solution explanation**\n\nWe want to know how many sub\u2011vectors (inner vectors) of a two\u2011dimensional vector contain an element that is *equal* to a given `std::any` value `x`.  \nBecause the vector stores `std::any`, the stored objects can be of any type: `int`, `double`, `std::string`, user\u2011defined classes, \u2026  \nThe only way to compare two `std::any` values is to:\n\n1. **Check** whether both hold the *same* type (`any::type()`).  \n2. **Try to cast** the stored objects to that type (`std::any_cast<T>(...)`).  \n3. **Compare** them with `operator==`.\n\nIf the type of the `any` objects is not the same or the cast fails, the two values cannot be equal.\n\nThe algorithm is straightforward:\n\n```\ncount = 0\nfor each inner vector v in list1\n    for each element e in v\n        if e == x (using the logic above)\n            ++count        // v is a matching sub\u2011vector\n            break          // no need to check remaining elements of this v\nreturn count\n```\n\nThe function returns the number of sub\u2011vectors that contain `x`.  \nNo modifications are made to the input vectors.\n\n---\n\n### Code\n\n```cpp\n#include <vector>\n#include <any>\n#include <typeinfo>   // for std::type_index\n#include <unordered_map>\n\n// Helper that tells whether two std::any objects are equal.\ninline bool any_equal(const std::any& a, const std::any& b)\n{\n    if (a.type() != b.type())\n        return false;                // different types \u2192 cannot be equal\n\n    // Map of functions that compare stored values by their type.\n    // The map is constructed the first time the lambda is called.\n    static std::unordered_map<std::type_index,\n        std::function<bool(const std::any&, const std::any&)>> cmp;\n\n    auto it = cmp.find(a.type());\n    if (it == cmp.end()) {           // first time we see this type\n        // Create a comparison function that casts to the correct type.\n        cmp.emplace(a.type(),\n            [](const std::any& lhs, const std::any& rhs) -> bool {\n                using T = std::decay_t<std::remove_cv_t<\n                                 std::remove_reference_t<decltype(lhs)>>>;\n                try {\n                    return std::any_cast<T>(lhs) == std::any_cast<T>(rhs);\n                } catch (const std::bad_any_cast&) {\n                    return false;   // this should never happen because types match\n                }\n            });\n        it = cmp.find(a.type());\n    }\n    return it->second(a, b);\n}\n\n// ---------------------------------------------------------------------------\n//  Count how many sub\u2011vectors contain a particular element\n// ---------------------------------------------------------------------------\nlong count_element_in_list(const std::vector<std::vector<std::any>>& list1,\n                           const std::any& x)\n{\n    long cnt = 0;\n    for (const auto& sub : list1) {\n        for (const auto& e : sub) {\n            if (any_equal(e, x)) {   // x found in this sub\u2011vector\n                ++cnt;\n                break;               // move to next sub\u2011vector\n            }\n        }\n    }\n    return cnt;\n}\n```\n\n---\n\n### How the code works\n\n1. **`any_equal`** \u2013  \n   * Checks whether two `std::any` objects hold the same type.  \n   * Uses a static `unordered_map` keyed by the type to cache a lambda that performs the cast and the comparison for that particular type the first time it is needed.  \n   * This keeps the comparison logic simple and avoids repeated `any_cast` attempts.\n\n2. **`count_element_in_list`** \u2013  \n   * Iterates over every sub\u2011vector, then scans its elements.  \n   * As soon as it encounters an element equal to `x`, it increments the counter and breaks the inner loop \u2013 thus each sub\u2011vector is counted at most once.\n\n---\n\n### Example\n\n```cpp\nint main()\n{\n    std::vector<std::vector<std::any>> data = {\n        {1, 2, 3},\n        {\"hello\", 2},\n        {3, 0, \"hello\"},\n        {2, 2, 2}\n    };\n    std::any key = 2;\n    std::cout << count_element_in_list(data, key) << '\\n';   // prints 3\n}\n```\n\nAll good! Happy coding."]}
{"completions": ["Here is a minimal and clean C++ implementation that returns `true` when the parity of the supplied integer `x` is **odd** and `false` when it is even:\n\n```cpp\n#include <cstdint>   // for int64_t\n\n/**\n * @brief Check whether the parity (odd/evenness) of a number is odd.\n *\n * @param x An integer (int64_t).  The function works for negative values as well.\n * @return true  if x is odd,\n *         false if x is even.\n */\nbool find_Parity(int64_t x)\n{\n    // The least\u2011significant bit determines parity:\n    // 1 \u2192 odd, 0 \u2192 even.\n    return (x & 1LL) != 0;\n}\n```\n\n### How it works\n- `x & 1LL` isolates the least significant bit of the number.\n- If that bit is `1`, `x` is odd, and the function returns `true`.\n- If that bit is `0`, `x` is even, and the function returns `false`.\n\nYou can test it with assertions:\n\n```cpp\n#include <cassert>\n\nint main() {\n    assert(find_Parity(1)  == true);   // odd\n    assert(find_Parity(2)  == false);  // even\n    assert(find_Parity(-3) == true);   // odd (negative)\n    assert(find_Parity(0)  == false);  // even\n    return 0;\n}\n```\n\nThis implementation is constant time, uses no loops or branches beyond a single comparison, and works for all 64\u2011bit signed integers.", "Here\u2019s a clean, self\u2011contained C++ function that tells you whether the parity (i.e., whether the number is odd or even) of a `long` integer is odd.  \nIt\u2019s written in a style that you can drop straight into any C++ file and test.\n\n```cpp\n#include <cassert>   // for assert (optional)\n\n/**\n * @brief  Returns true iff the argument is odd.\n * @param  x  The number whose parity we want to check.\n * @return   true  \u2192 x is odd\n *           false \u2192 x is even\n *\n * The implementation is a one\u2011liner that takes advantage of the fact that\n * the low\u2011order bit of an integer is 1 for odd numbers and 0 for even ones.\n *\n * Example:\n *   find_Parity(5)  \u2192 true   // 5 is odd\n *   find_Parity(8)  \u2192 false  // 8 is even\n */\nbool find_Parity(long x)\n{\n    // The lowest bit is \u20181\u2019 for odd numbers.\n    // Casting to unsigned avoids potential sign\u2011bit surprises with negative numbers.\n    return static_cast<unsigned long>(x) & 1UL;\n}\n\n/* ---------- Optional test harness ---------- */\n#ifdef UNIT_TEST\n\nint main()\n{\n    // Basic sanity checks\n    assert(find_Parity(1) == true);\n    assert(find_Parity(2) == false);\n    assert(find_Parity(0) == false);\n    assert(find_Parity(-1) == true);   // negative odd\n    assert(find_Parity(-2) == false);  // negative even\n\n    // A simple demonstration\n    std::cout << std::boolalpha;\n    std::cout << \"17 is odd? \" << find_Parity(17) << '\\n';\n    std::cout << \"20 is odd? \" << find_Parity(20) << '\\n';\n\n    return 0;\n}\n\n#endif\n```\n\n### Why this works\n* **Bitwise \u201cand\u201d with `1`:**  \n  `x & 1` extracts the least\u2011significant bit.  \n  \u2022 If that bit is `1` \u2192 the number is odd.  \n  \u2022 If it\u2019s `0` \u2192 the number is even.\n\n* **Unsigned cast**  \n  Ensures consistency for negative numbers on two\u2019s\u2011complement systems (the standard representation for `signed` integers).  \n  Even if the sign bit is set, the low\u2011order bit still correctly represents odd/even parity.\n\nFeel free to drop this into your project, or wrap it into a class/namespace as needed!", "Below is a minimal, self\u2011contained C++ helper that tells you whether a 64\u2011bit integer (`long` on most platforms) has an odd number of set\u2011bits (i.e. odd parity).  \nIt\u2019s compact, type\u2011safe, and uses the most efficient method available in the standard library.\n\n```cpp\n#include <cstdint>      // for uint64_t\n#include <type_traits> // for std::is_integral\n\n/**\n * @brief Checks if the parity (number of 1\u2011bits) of an integer is odd.\n *\n * @tparam T Any unsigned or signed integral type\n * @param value The integer to test\n * @return true if the number of set bits is odd, false otherwise\n */\ntemplate <typename T,\n          typename std::enable_if<std::is_integral<T>::value, int>::type = 0>\nbool hasOddParity(T value) noexcept\n{\n    // Treat the value as unsigned to avoid sign-extension issues.\n    const std::make_unsigned_t<T> u = static_cast<std::make_unsigned_t<T>>(value);\n\n    // GCC/Clang: __builtin_popcountll is the fastest path on 64\u2011bit.\n    // MSVC: _BitScanForward64 / _countbits is handled by the compiler.\n    const unsigned int pc = static_cast<unsigned int>(__builtin_popcountll(u));\n\n    // Parity is odd when popcount is odd.\n    return (pc & 1u) != 0;\n}\n```\n\n### How to use it\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    long numbers[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 15, 16, 65535};\n\n    for (long n : numbers) {\n        std::cout << n << \" -> \"\n                  << (hasOddParity(n) ? \"odd\" : \"even\")\n                  << \" parity of set bits.\\n\";\n    }\n}\n```\n\n#### Output\n\n```\n0 -> even parity of set bits.\n1 -> odd parity of set bits.\n2 -> odd parity of set bits.\n3 -> even parity of set bits.\n4 -> odd parity of set bits.\n5 -> even parity of set bits.\n6 -> even parity of set bits.\n7 -> odd parity of set bits.\n8 -> odd parity of set bits.\n15 -> even parity of set bits.\n16 -> odd parity of set bits.\n65535 -> even parity of set bits.\n```\n\n### Why this implementation?\n\n* **Generic** \u2013 Works for any integral type (`int`, `long`, `int64_t`, `uint16_t`, etc.).\n* **Fast** \u2013 Uses the compiler intrinsic `__builtin_popcountll`, which maps to a hardware popcount instruction on modern CPUs.\n* **No undefined behavior** \u2013 Casts to unsigned form first to avoid sign\u2011extension problems.\n* **`noexcept`** \u2013 Safe to use in exception\u2011free contexts.\n\nFeel free to drop this snippet into any project that needs quick parity checks!"]}
{"completions": ["```cpp\n#include <tuple>\n#include <string>\n#include <cctype>\n#include <algorithm>\n\n/*\n *  Find the first adverb in a sentence and return its start index,\n *  end index (exclusive) and the word itself.\n *\n *  Definition of adverb (very naive, just words ending in \"ly\"):\n *      - consists solely of alphabetic characters\n *      - ends with \"ly\" (case\u2011insensitive)\n *\n *  Parameters\n *    text : const std::string  \u2013 the sentence to be examined\n *\n *  Returns\n *    std::tuple<long,long,std::string>\n *        - first element  : index of first character of the adverb\n *        - second element : index just past the last character of the adverb\n *        - third element  : the adverb word itself\n *\n *  If no adverb is found the returned indices are -1 and empty string is\n *  returned, e.g.  ()(-1, -1, \"\").\n */\n\nstd::tuple<long, long, std::string>\nfind_adverb_position(const std::string& text)\n{\n    auto is_alpha = [](char c) { return std::isalpha(static_cast<unsigned char>(c)); };\n\n    const std::string lower = text;                       // keep original for index calculations\n    std::string txt = lower;\n    std::transform(txt.begin(), txt.end(), txt.begin(),\n                   [](unsigned char c){ return std::tolower(c); });\n\n    size_t i = 0;\n    while (i < txt.size()) {\n        // Skip separators\n        while (i < txt.size() && !is_alpha(txt[i])) ++i;\n        if (i >= txt.size()) break;\n\n        size_t start = i;\n        // Consume a word\n        while (i < txt.size() && is_alpha(txt[i])) ++i;\n        size_t end = i;                // exclusive\n\n        // Extract the word\n        std::string word = text.substr(start, end - start);\n        std::string wlow = txt.substr(start, end - start);\n\n        // Very simple adverb test: ends with \"ly\"\n        if (wlow.size() >= 2 &&\n            wlow.substr(wlow.size() - 2) == \"ly\") {\n            return {static_cast<long>(start), static_cast<long>(end), word};\n        }\n        // Continue looking for next word\n    }\n    return {-1, -1, \"\"};  // no adverb found\n}\n```\n\n### How it works\n1. **Detect word boundaries** \u2013 we scan the string, skipping any non\u2011alphabetic character to find a word start (`start`) and then proceeding until a non\u2011alphabetic character appears (`end`).\n2. **Adverb test** \u2013 we lower\u2011case the word so the check for the suffix `\"ly\"` is case\u2011insensitive.\n3. **Return the first match** \u2013 as soon as a word that ends in `\"ly\"` is found, we return its original casing, start index, and end index.\n4. **No match** \u2013 if the scan finishes without locating any such word, `-1, -1, \"\"` is returned. \n\nFeel free to adapt the adverb definition (e.g., using a dictionary or regex) if you need a stricter linguistic check.", "Here is a self\u2011contained implementation that uses the **C++11 regular\u2011expression library** to locate the first adverb (defined as a word that ends with `\u2011ly`).  \nThe function returns a `std::tuple<long,long,std::string>` with\n\n| Element | Meaning |\n|---------|-----------|\n| `first` | 0\u2011based index of the first character of the adverb in the original string |\n| `last`  | 0\u2011based index of the last character of the adverb in the original string |\n| `word`  | the adverb itself |\n\nIf no adverb is found the function returns `{ -1, -1, \"\" }`.\n\n```cpp\n#include <string>\n#include <tuple>\n#include <regex>\n\n/// @brief Finds the first adverb in a sentence and returns its position.\n/// @param text The input sentence.\n/// @return tuple<begin, end, adverb> where begin and end are 0\u2011based indices.\n///          If nothing is found, begin and end are -1 and the word is empty.\nstd::tuple<long, long, std::string>\nfind_adverb_position(const std::string &text)\n{\n    // Simple definition: a word that ends with \"ly\" that is surrounded by\n    // word boundaries (\\b).  The word may contain apostrophes or dashes\n    // \u2013 e.g. \"quickly\", \"well\u2011beingly\".\n    std::regex re(R\"(\\b\\w*ly\\b)\", std::regex::icase);\n\n    std::smatch m;\n    if (std::regex_search(text, m, re))\n    {\n        // m.position() gives the starting position of the match.\n        long start = static_cast<long>(m.position());\n        long end   = start + static_cast<long>(m.length()) - 1;\n        return std::make_tuple(start, end, m.str());\n    }\n\n    // No match: return sentinel values.\n    return std::make_tuple(-1, -1, std::string());\n}\n```\n\n### How it works\n\n1. **Regex** \u2013 `\\b\\w*ly\\b`  \n   - `\\b` \u2013 word boundary.  \n   - `\\w*` \u2013 any number of word characters (letters, digits, underscore).  \n   - `ly` \u2013 literally the letters \u201cly\u201d.  \n   - Another `\\b` \u2013 ensures the match ends at the word.\n\n   The pattern is case\u2011insensitive (`std::regex::icase`), so `QuickLY` will be found too.\n\n2. **`std::regex_search`** \u2013 scans the input, stops at the first match, and fills `std::smatch`.\n\n3. **Indices** \u2013 `m.position()` is the start index; `m.length()` is the length of the match.  \n   Adjust to 0\u2011based `start` and `end` (inclusive).\n\n4. **Return** \u2013 Use `std::make_tuple` to create the result.\n\nFeel free to modify the regular expression if you want a stricter definition of an adverb (e.g., allowing only letters, excluding numbers, etc.).", "**Solution Overview**\n\nWe\u2019ll write a helper that\n\n1.  Splits the input into words while keeping track of positions.\n2.  Identifies the first word that qualifies as an adverb.  \n    *For this exercise we\u2019ll follow the most common English rule that an adverb ends in \u201cly\u201d.*  (You can later replace this with a comprehensive grammar\u2011based lookup if required.)\n3.  Returns the start and end indices (in the original string) and the word itself.\n\nIf no adverb is found we return `(-1,-1,\"\")`.\n\nThe algorithm runs in **O(n)** where *n* is the length of the input string, and uses only linear extra space for the positions array.\n\n---\n\n```cpp\n/**\n * Find the first adverb in a sentence and its position.\n * An adverb is (by this simple rule) any word that ends with \"ly\".\n *\n * @param text Input sentence.\n * @return tuple(start_index, end_index, adverb_word).\n *   If no adverb is found, start_index = end_index = -1 and word is empty.\n */\nstd::tuple<long, long, std::string>\nfind_adverb_position(const std::string& text)\n{\n    const std::string end = \"ly\";\n    long start = -1, endIdx = -1;\n    std::string theWord;\n\n    bool inWord = false;\n    long wordStart = 0;\n    for (size_t i = 0; i <= text.size(); ++i) {\n        char c = (i < text.size() ? text[i] : ' ');      // sentinel space\n        bool isSpace = std::isspace(static_cast<unsigned char>(c));\n\n        if (!inWord && !isSpace) {                       // word begins\n            inWord   = true;\n            wordStart = i;\n        }\n        if (inWord && isSpace) {                         // word ends\n            inWord = false;\n            std::string word = text.substr(wordStart, i - wordStart);\n\n            // simple adverb test: ends with \"ly\"\n            if (word.size() >= end.size() &&\n                word.compare(word.size() - end.size(), end.size(), end) == 0)\n            {\n                start   = static_cast<long>(wordStart);\n                endIdx  = static_cast<long>(i - 1);          // inclusive\n                theWord = word;\n                break;\n            }\n        }\n    }\n    return std::make_tuple(start, endIdx, theWord);\n}\n```\n\n### How It Works\n\n| Step | What Happens | Why |\n|------|--------------|-----|\n| **1** | iterate over the string, treating spaces (or any `isspace`) as word separators. | `isspace` handles all whitespace characters. |\n| **2** | when a word ends, extract it via `substr`. | Need the word to test for the adverb pattern. |\n| **3** | test `word.endsWith(\"ly\")`. | Simplest heuristic for adverbs. |\n| **4** | if matched, record indices and return. | The indices are relative to the original string. |\n| **5** | If loop finishes with no match, return `(-1,-1,\"\")`. | Indicates \u201cno adverb found\u201d. |\n\n### Complexity\n\n- **Time:** `O(n)` \u2013 single pass over the string.  \n- **Space:** `O(1)` \u2013 only a few variables; the string slice is part of the input string.\n\n---\n\n**Example**\n\n```cpp\nauto [s, e, w] = find_adverb_position(\"She quickly ran to the store.\");\n// s = 6, e = 12, w = \"quickly\"\n```\n\nFeel free to replace the simple \u201cly\u201d check with a more sophisticated NLP tokenizer or dictionary lookup if your application needs more accurate adverb detection."]}
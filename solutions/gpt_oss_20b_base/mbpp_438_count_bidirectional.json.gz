{"completions": ["Below is a ready\u2011to\u2011copy implementation of `count_bidirectional`.  \nIt takes a vector of two\u2011element tuples `(long, long)` and returns the number of *unordered* tuple\u2011pairs that appear *in both directions* in the input.  \nThe function is fully self\u2011contained, uses only the C++ standard library (no\n`bits/stdc++`), and includes a handful of sanity checks with asserts.\n\n```cpp\n#include <vector>\n#include <tuple>\n#include <unordered_map>\n#include <cassert>\n\n/*\n * Count how many unordered pairs (a,b) exist in both directions in\n * 'test_list': i.e. where both (a,b) and (b,a) are present.\n *\n * Complexity:\n *      O(n) time, O(n) extra memory, where n = test_list.size()\n * Returns:\n *      The number of bidirectional pairs.\n */\nlong count_bidirectional(const std::vector<std::tuple<long,long>>& test_list)\n{\n    // Map a pair to the number of its occurrences.\n    std::unordered_map<long long, long> freq;\n    freq.reserve(test_list.size() * 2);\n\n    // Helper to turn (a,b) into a unique 64\u2011bit key.\n    auto key = [](long a, long b) noexcept -> long long {\n        // pack two 32\u2011bit signed ints into a 64\u2011bit key.\n        // We shift by 32 bits and mask to avoid sign\u2011extension issues.\n        return (static_cast<long long>(a + 2000000000LL) << 32) |\n               (static_cast<long long>(b + 2000000000LL) & 0xffffffffLL);\n    };\n\n    // Build the frequency map.\n    for (const auto& t : test_list) {\n        long a = std::get<0>(t);\n        long b = std::get<1>(t);\n        ++freq[key(a,b)];\n    }\n\n    long bidirectional_pairs = 0;\n\n    // Scan through the map and count pairs that appear in reverse.\n    for (const auto& [k, cnt] : freq) {\n        // Recreate a,b from the key.\n        int a = static_cast<int>((k >> 32) & 0xffffffffLL) - 2000000000;\n        int b = static_cast<int>(k & 0xffffffffLL) - 2000000000;\n\n        // Different tuples: ensure we don't double\u2011count.\n        if (a < b) {\n            auto rev_k = key(b,a);\n            auto it   = freq.find(rev_k);\n            if (it != freq.end()) {\n                // The number of bidirectional pairs contributed by\n                // (a,b)/(b,a) equals the minimum of the two counts.\n                bidirectional_pairs += std::min(cnt, it->second);\n            }\n        }\n    }\n\n    return bidirectional_pairs;\n}\n\n/* ------------------------------------------------------------------ */\n/* ---------- Optional: simple test harness (remove before prod) ---- */\n/* ------------------------------------------------------------------ */\n\n#ifdef UNIT_TEST\n#include <iostream>\nint main()\n{\n    // Example: {(1,2),(2,1),(1,3),(3,1),(2,3),(3,2),(3,4)}\n    std::vector<std::tuple<long,long>> v = {\n        {1,2},{2,1},{1,3},{3,1},{2,3},{3,2},{3,4}\n    };\n\n    assert(count_bidirectional(v) == 3); // pairs: (1,2),(1,3),(2,3)\n    std::cout << \"All tests passed!\\n\";\n}\n#endif\n```\n\n### How It Works\n1. **Key Generation**  \n   We map each `(a,b)` to a 64\u2011bit integer key.  \n   Using a large offset (`2000000000`) keeps indices positive and avoids\n   overflow when shifting.\n\n2. **Frequency Counting**  \n   Build a hash map `freq` that stores how many times each directed tuple\n   occurs.\n\n3. **Pair Counting**  \n   Iterate through the map; for each unique `(a,b)` where `a < b`\n   (to prevent double\u2011counting), look up the key for `(b,a)`.  \n   If found, add `min(cnt_ab, cnt_ba)` to the answer \u2013 the number of\n   complete unordered pairs that can be formed.\n\n4. **Return**  \n   The total count of bidirectional pairs is returned.\n\nFeel free to drop a quick test harness like the one guarded by `#ifdef UNIT_TEST`, or remove that block for production usage.", "Here is a full, self\u2011contained implementation of\u202f`count_bidirectional`.  \nIt counts the number of *unique unordered* bidirectional pairs that appear in the input vector.  \nIf only the count of the directed occurrences is required, you can simply change the logic to \u2013\u2011\n\n```cpp\nreturn countBidir;               // for counting directed pairs\n```\n\nbut the current version returns the number of *unordered* pairs `(a,b)` such that both `(a,b)` and `(b,a)` appear in the input.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// Counts how many unordered bidirectional pairs exist in `test_list`.\n/// Example:\n///      {(1,2),(2,1),(3,4),(4,3),(5,6)}  \u2192  2   // {(1,2),(3,4)}\n/// The pair (a,b) is considered the same as (b,a) and each unordered pair is counted only once.\nlong long count_bidirectional(const vector<tuple<long long, long long>>& test_list)\n{\n    // map every direction (a,b) to the number of times it occurs\n    unordered_map<long long, unordered_map<long long, int>> dirCnt;\n\n    for (const auto& t : test_list) {\n        long long a, b;\n        tie(a, b) = t;\n        ++dirCnt[a][b];\n    }\n\n    long long total = 0;\n\n    // iterate only on the first element of the key to avoid double\u2011counting\n    for (const auto& entry : dirCnt) {\n        long long a = entry.first;\n        const auto& inner = entry.second;\n\n        for (const auto& sub : inner) {\n            long long b = sub.first;\n            if (a < b) {                // ensure a<b, so we visit each unordered pair once\n                int cntAB = sub.second;\n                auto it = dirCnt.find(b);\n                if (it != dirCnt.end()) {\n                    auto it2 = it->second.find(a);\n                    if (it2 != it->second.end()) {\n                        int cntBA = it2->second;\n                        // Both directions are present \u2192 count this unordered pair\n                        ++total;\n                    }\n                }\n            }\n        }\n    }\n\n    return total;\n}\n\n// -----------------------------------------------------------------\n// Below is a small test harness that demonstrates how to use the\n// function. Feel free to remove it if you only need the function.\n\n#ifdef UNIT_TEST\nint main()\n{\n    vector<tuple<long long, long long>> v = {\n        {1, 2}, {2, 1}, {3, 4}, {4, 3}, {5, 6}, {6, 5},\n        {7, 8}               // unpaired\n    };\n\n    cout << \"Bidirectional unordered pairs: \" << count_bidirectional(v)\n         << '\\n';   // should output 3\n\n    return 0;\n}\n#endif\n```\n\n### How it works\n\n1. **Build a nested map**  \n   `dirCnt[a][b]` holds the number of times the directed pair `(a,b)` appears.\n2. **Iterate through `dirCnt`**  \n   For each directed pair `(a,b)` where `a < b` we look for the reverse pair `(b,a)` in the map.\n3. **Increment the count**  \n   If both directions are present, the unordered pair `{a,b}` is valid and we increment `total` exactly once.\n\nThe algorithm runs in `O(N)` time (processing each tuple once) and `O(N)` space for storing the map, where `N` is the number of tuples in `test_list`.", "Below is a compact, self\u2011contained implementation of the requested **`count_bidirectional`** function.  \nThe routine counts how many unordered pairs of numbers occur in both directions in the provided vector of two\u2011element tuples.  \n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// Count the number of distinct unordered pairs (a,b) such that\n/// both (a,b) and (b,a) appear in *test_list*.\n/// Each unordered pair is counted only once.\n///\n/// Example\n/// ------\n/// test_list = {(1,2), (2,1), (3,4), (4,3), (5,6)}\n/// return 2   // pairs {1,2} and {3,4}\n///\nlong count_bidirectional(const std::vector<std::tuple<long, long>>& test_list) {\n    // Store every directed tuple in a hash set for O(1) look\u2011ups.\n    unordered_set<std::string> dir;          // e.g. \"1#2\"\n    unordered_set<std::string> counted;      // already counted unordered pair\n\n    long result = 0;\n\n    for (const auto& t : test_list) {\n        long a = std::get<0>(t);\n        long b = std::get<1>(t);\n\n        // Normalise the key representation.\n        // The directed key is \"a#b\".\n        std::string key = std::to_string(a) + \"#\" + std::to_string(b);\n        // The unordered key normalises to the smaller first.\n        std::string undKey = (a < b) ? std::to_string(a) + \"#\" + std::to_string(b)\n                                    : std::to_string(b) + \"#\" + std::to_string(a);\n\n        // If the reverse direction already exists and we haven't counted this\n        // unordered pair yet, we found a bidirectional pair.\n        std::string revKey = std::to_string(b) + \"#\" + std::to_string(a);\n        if (dir.find(revKey) != dir.end() && counted.find(undKey) == counted.end()) {\n            ++result;\n            counted.insert(undKey);           // mark this pair as counted\n        }\n\n        dir.insert(key);\n    }\n\n    return result;\n}\n```\n\n### Why this works\n\n1. **Fast membership testing** \u2013 Both `dir` and `counted` are `unordered_set`s, giving constant\u2011time look\u2011ups for membership checks.\n2. **Unordered pair canonisation** \u2013 The string `undKey` always uses the smaller element first. That guarantees each unordered pair has exactly one canonical representation, so we never count the same pair twice.\n3. **No double\u2011counting** \u2013 Once a bidirectional pair is detected, its canonical key is inserted into `counted`. Subsequent occurrences of the same unordered pair are ignored.\n\nFeel free to integrate this function into your project; it requires only the standard library and works for any vector of `tuple<long,long>` that you pass to it."]}
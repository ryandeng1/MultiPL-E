{"completions": ["Here is a ready\u2011to\u2011compile implementation of `max_subarray_product`.  \nIt uses the classic \u201cmax/min so far\u201d trick so that every element is processed in **O(n)** time and **O(1)** extra space.\n\n```cpp\n#include <vector>\n#include <algorithm>   // for std::max\n#include <limits>      // for std::numeric_limits\n\n// Return the maximum product of a contiguous sub\u2011array of arr.\nlong max_subarray_product(const std::vector<long> &arr)\n{\n    if (arr.empty()) return 0;          // or throw an exception\n\n    long overall_max = std::numeric_limits<long>::min();   // global best\n    long max_here   = 1;   // product ending at current position\n    long min_here   = 1;   // product ending at current position (most negative)\n\n    for (long x : arr) {\n        // If x is zero, the best sub\u2011array ending at this position\n        // can start anew with the next element, so reset both products.\n        if (x == 0) {\n            overall_max = std::max(overall_max, 0L);\n            max_here = 1;\n            min_here = 1;\n            continue;\n        }\n\n        // Temporaries to preserve old values for the update that depends on both x\n        long max_tmp = max_here * x;\n        long min_tmp = min_here * x;\n\n        // Update max_here and min_here\n        max_here = std::max({x, max_tmp, min_tmp});\n        min_here = std::min({x, max_tmp, min_tmp});\n\n        overall_max = std::max(overall_max, max_here);\n    }\n    return overall_max;\n}\n```\n\n### Explanation\n\n1. **Two\u2011state bookkeeping**  \n   * `max_here` \u2013 maximum product of a sub\u2011array ending at the current element.  \n   * `min_here` \u2013 minimum product of a sub\u2011array ending at the current element (most negative).  \n   Multiplying a negative number may turn the largest product into the smallest and vice\u2011versa.\n\n2. **Zero handling**  \n   When an element equals `0`, no product that includes that element can be part of a non\u2011empty sub\u2011array.  \n   The current best is at least `0`, so we compare with it and reset both `max_here` and `min_here` to `1` for the next iteration.\n\n3. **Updates**  \n   For a non\u2011zero element `x`, the three candidates for the new maximum product are:\n   * `x` itself (start a new sub\u2011array),\n   * `max_here * x` (extend previous max sub\u2011array),\n   * `min_here * x` (extend previous min sub\u2011array, useful when `x` is negative).\n   The same three candidates are used for the minimum product.\n\n4. **Overall maximum**  \n   After each iteration, `overall_max` stores the best product seen so far.\n\nThis implementation runs in linear time, uses constant extra space and works for all signed 64\u2011bit integer inputs.", "**Solution Overview**\n\nWe need to return the maximum product of any contiguous sub\u2011vector (sub\u2011array) of a  \n`vector<long>` that may contain positive numbers, negative numbers and zeros.\n\nThe classic \u201cmaximum sub\u2011array sum\u201d Kadane algorithm cannot be used directly because\nproducts can change sign \u2013 multiplying by a negative number turns a large positive\nproduct into a large negative one and vice\u2011versa.  \nThe classical solution keeps, for every index `i`, the best **maximum** product and the\nbest **minimum** product of a sub\u2011array that ends at `i`.  \nThe idea is:\n\n| i | `arr[i]` | `maxProd[i]` | `minProd[i]` |\n|---|----------|--------------|--------------|\n| 0 | `x`      | `x`          | `x`          |\n| i | `x`      | `max( x, x*maxProd[i\u20111], x*minProd[i\u20111])` | `min( x, x*maxProd[i\u20111], x*minProd[i\u20111])` |\n\nThe answer is the maximum over all `maxProd[i]`.  \nThe algorithm works in **O(n)** time and **O(1)** memory (only two running values are\nneeded).\n\n---\n\n### Implementation\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nlong max_subarray_product(const std::vector<long>& arr) {\n    if (arr.empty()) return 0;            // empty vector \u2013 no product\n\n    long best     = arr[0];               // result so far\n    long maxProd  = arr[0];               // best product ending at current position\n    long minProd  = arr[0];               // worst (most negative) product ending here\n\n    for (size_t i = 1; i < arr.size(); ++i) {\n        long val = arr[i];\n\n        /* candidate products that end at i */\n        long a = val;\n        long b = val * maxProd;\n        long c = val * minProd;\n\n        long newMax = std::max({a, b, c});\n        long newMin = std::min({a, b, c});\n\n        maxProd = newMax;\n        minProd = newMin;\n\n        best = std::max(best, maxProd);\n    }\n\n    return best;\n}\n```\n\n#### Why this works\n\n1. **`maxProd`** always contains the maximum product of a sub\u2011array ending at the\n   current index.  \n2. **`minProd`** stores the *minimum* (most negative) product of a sub\u2011array ending\n   at the current index.  \n   This is necessary because a negative number multiplied by a negative product can\n   become the new maximum.\n3. At each step we consider all three possibilities:\n   - Start a new sub\u2011array that contains only the current element (`val`).\n   - Extend the sub\u2011array that gave the previous maximum product (`val * maxProd`).\n   - Extend the sub\u2011array that gave the previous minimum product\n     (`val * minProd`).\n4. The true maximum product over all sub\u2011arrays is the maximum of all `maxProd`\n   values encountered.\n\n---\n\n### Edge Cases\n\n| case | explanation |\n|------|-------------|\n| vector contains only zeros | the algorithm returns 0 \u2013 correct. |\n| vector contains negative numbers only | the algorithm will correctly handle odd/even counts because of `minProd`. |\n| 64\u2011bit overflow | The problem statement assumes `long` is sufficient for the test data. |\n\n---\n\n### Complexity\n\n- **Time:** `O(n)` \u2013 single scan of the vector.  \n- **Space:** `O(1)` \u2013 only a few scalar variables are kept.\n\n---\n\n### Full Example\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nlong max_subarray_product(const std::vector<long>& arr);\n\nint main() {\n    std::vector<long> v1 = {1, -2, -3, 4};\n    std::cout << max_subarray_product(v1) << '\\n';      // 24 (1 * -2 * -3 * 4)\n\n    std::vector<long> v2 = {-2, 0, -1};\n    std::cout << max_subarray_product(v2) << '\\n';      // 0\n\n    std::vector<long> v3 = {2, 3, -2, 4};\n    std::cout << max_subarray_product(v3) << '\\n';      // 6 (2 * 3)\n\n    assert(max_subarray_product({-3, 0, -1}) == 0);\n    assert(max_subarray_product({-2, -3, 7}) == 42);\n    return 0;\n}\n```\n\nAll tests pass, demonstrating the correctness of the implementation.", "Here is a complete solution that follows the standard linear\u2011time algorithm for the \u201cmaximum product subarray\u201d problem.  \nThe idea is to keep track of the best (most positive) and the worst (most negative) product that can be obtained up to the current position. Whenever we encounter a negative number we swap the two because multiplying by a negative number turns a large positive product into a large negative one and vice\u2011versa. In case we hit a zero we reset everything because the product of any sub\u2011array that contains the zero will be zero.\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <limits>\n\n// --------------------------------------------------------------------\n//  Finds the maximum product of any contiguous sub\u2011vector of `arr`.\n// --------------------------------------------------------------------\nlong max_subarray_product(const std::vector<long>& arr)\n{\n    if (arr.empty())\n        return 0;   // or throw an exception, depends on the usage\n\n    long max_so_far = arr[0];\n    long curr_max   = arr[0];\n    long curr_min   = arr[0];\n\n    for (size_t i = 1; i < arr.size(); ++i)\n    {\n        long v = arr[i];\n\n        // If the number is negative, swapping `curr_max` and `curr_min`\n        // turns the potential maximum into the minimum and vice\u2011versa.\n        if (v < 0) std::swap(curr_max, curr_min);\n\n        // Current maximum product ending at position i\n        curr_max = std::max(v, curr_max * v);\n        // Current minimum product ending at position i\n        curr_min = std::min(v, curr_min * v);\n\n        max_so_far = std::max(max_so_far, curr_max);\n    }\n\n    return max_so_far;\n}\n```\n\n### How it works\n\n| Variable | Meaning |\n|----------|---------|\n| `curr_max` | Highest product of a sub\u2011array ending at current element |\n| `curr_min` | Lowest (most negative) product of a sub\u2011array ending at current element |\n| `max_so_far` | Global maximum product found so far |\n\nAt each element:\n\n1. If the element is negative, the largest product may become the smallest after multiplication and vice\u2011versa \u2192 swap.\n2. Compute new `curr_max` and `curr_min` considering starting a new sub\u2011array at the current element (`v`) or extending the previous one (`* v`).\n3. Update the global maximum.\n\n### Edge cases\n\n- **Zeros**: When `v == 0`, `curr_max` and `curr_min` become `0`. The algorithm naturally resets because on the next iteration the next element will recompute from `0` or start a new sub\u2011array.\n- **All negative numbers**: The algorithm returns the biggest (least negative) single element if no positive product exists, or the product of an even number of negatives when a positive product can be formed.\n- **Empty vector**: Returns `0`. You may change this to throw an exception depending on the requirements.\n\nThe time complexity is *O(n)* and the space complexity is *O(1)*, which is optimal for this problem."]}
{"completions": ["Here is a compact implementation that works for all the example cases and counts overlapping matches:\n\n```cpp\n#include <string>\n\nlong how_many_times(const std::string& str, const std::string& sub)\n{\n    if (sub.empty() || str.empty() || sub.size() > str.size())\n        return 0;                 // empty substring, no occurrence\n\n    long count = 0;\n    size_t pos = 0;\n    while ((pos = str.find(sub, pos)) != std::string::npos) {\n        ++count;\n        // Move one character forward so we can catch overlapping matches\n        ++pos;\n    }\n    return count;\n}\n```\n\n**Explanation**\n\n* `std::string::find` returns the first position where `sub` occurs in `str` starting from `pos`.  \n* After a match is found we increment `count` and shift `pos` by **one** (instead of `sub.size()`) to allow overlapping occurrences to be counted.  \n* The loop stops when `find` returns `std::string::npos`.  \n* Edge cases \u2013 empty `sub`, empty `str`, or `sub` longer than `str` \u2013 all return `0`.\n\nThis matches your examples:\n\n```cpp\nhow_many_times(\"\", \"a\")   // 0\nhow_many_times(\"aaa\", \"a\")// 3\nhow_many_times(\"aaaa\", \"aa\")// 3\n```\n\nFeel free to drop this function into your code base.", "The task is to count how many times a **sub\u2011string** appears in a larger string, **including overlapping occurrences**.  \nA very straightforward, efficient way to do this is to slide a window of the size of the sub\u2011string over the original string, comparing each slice once.\n\n```cpp\n#include <string>\n\n// returns the number of times `pat` appears in `txt` (overlap allowed)\nlong how_many_times(const std::string& txt, const std::string& pat)\n{\n    // An empty pattern can never appear \u2013 return 0.\n    if (pat.empty()) return 0;\n\n    const std::size_t n = txt.size();\n    const std::size_t m = pat.size();\n\n    // If the pattern is longer than the text there can be no match.\n    if (m > n) return 0;\n\n    long count = 0;\n\n    // Loop over every possible starting position where the pattern can fit.\n    for (std::size_t i = 0; i + m <= n; ++i) {\n        if (txt.compare(i, m, pat) == 0) {\n            ++count;                // a match found\n        }\n    }\n    return count;\n}\n```\n\n### Why this works\n\n* We never skip any positions; for every index `i` in `[0, n-m]` we check if the slice `txt[i \u2026 i+m-1]` is equal to `pat`.  \n* Because we increment the start index by **one** each loop, overlapping matches are automatically counted (e.g. `\"aaa\"` with `\"aa\"` gives matches starting at 0 and 1).  \n* The routine runs in `O(n\u00b7m)` in the worst case (where each comparison scans `m` characters). In practice the standard library's `compare` is highly optimised and this is acceptable for typical input sizes. If even more performance is required, a linear\u2011time algorithm such as the Knuth\u2013Morris\u2013Pratt (KMP) algorithm can be employed.\n\n### Example usage\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << how_many_times(\"\", \"a\") << '\\n';      // 0\n    std::cout << how_many_times(\"aaa\", \"a\") << '\\n';    // 3\n    std::cout << how_many_times(\"aaaa\", \"aa\") << '\\n';  // 3\n}\n```\n\nAll three test cases return the expected results.", "**Solution**\n\nWe need to count how many times `substring` appears in `string`, **including overlapping matches**.  \nThe constraints are not specified, but the signature indicates a simple solution will suffice.  \nWe\u2019ll implement a linear\u2011time search using the **Knuth\u2011Morris\u2011Pratt (KMP)** algorithm.  \nKMP works in \\(O(n+m)\\) time (where \\(n = |string|\\), \\(m = |substring|\\)) and handles\noverlaps naturally.\n\nBelow is a self\u2011contained implementation that compiles with a standard C++ compiler.\n\n```cpp\n/**\n * Count the number of (possibly overlapping) occurrences of `substring`\n * inside `string`.\n *\n * Uses the KMP algorithm which runs in O(n+m).\n */\nlong how_many_times(std::string string, std::string substring) {\n    const int n = string.size();\n    const int m = substring.size();\n\n    if (m == 0 || n < m) return 0;               // nothing to find\n\n    /* ---- build prefix function (failure function) for pattern ---- */\n    std::vector<int> pi(m, 0);\n    for (int i = 1, j = 0; i < m; ++i) {\n        while (j > 0 && substring[i] != substring[j]) j = pi[j - 1];\n        if (substring[i] == substring[j]) ++j;\n        pi[i] = j;\n    }\n\n    /* ---- search: walk through the text, using the prefix array ---- */\n    long count = 0;\n    for (int i = 0, j = 0; i < n; ++i) {\n        while (j > 0 && string[i] != substring[j]) j = pi[j - 1];\n        if (string[i] == substring[j]) ++j;\n        if (j == m) {           // full match found\n            ++count;\n            j = pi[j - 1];        // prepare for next possible match (overlap)\n        }\n    }\n\n    return count;\n}\n```\n\n### How it works\n\n1. **Prefix array (`pi`)**  \n   For each position `i` in the pattern, `pi[i]` stores the length of the longest proper prefix that is also a suffix of `pattern[0 \u2026 i]`.  \n   This allows the algorithm to skip comparisons that would fail.\n\n2. **Search loop**  \n   While scanning the text, we keep a state `j` that denotes how many characters of the pattern are currently matched.  \n   When `j` reaches `m`, an occurrence is found:  \n   - Increment the counter.  \n   - Set `j = pi[j-1]` to allow overlapping matches to be counted.\n\n### Example\n```cpp\nhow_many_times(\"aaa\", \"a\")   // returns 3  (positions 0,1,2)\nhow_many_times(\"aaaa\", \"aa\") // returns 3  (positions 0,1,2)\n```\n\nThe implementation works for all edge cases: empty strings, pattern longer than text, etc., and follows the required signature."]}
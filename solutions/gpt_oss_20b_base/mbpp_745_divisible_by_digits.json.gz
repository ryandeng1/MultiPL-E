{"completions": ["Here\u2019s a straightforward implementation that satisfies the requirement.  \nIt walks through every integer in the interval `[startnum , endnum]` and keeps the numbers that are divisible by **every** of their digits (skipping any numbers that contain the digit `0`, because division by 0 is undefined).\n\n```cpp\n#include <vector>\n#include <cassert>\n\nstd::vector<long> divisible_by_digits(long startnum, long endnum)\n{\n    std::vector<long> result;\n\n    // Sanity check \u2013 the range must be logical\n    if (startnum > endnum) {\n        return result;          // empty vector if the interval is invalid\n    }\n\n    for (long n = startnum; n <= endnum; ++n) {\n        long temp = n;\n        bool ok = true;\n\n        // Check each digit of the current number\n        while (temp > 0) {\n            int digit = temp % 10;\n            temp /= 10;\n\n            // Numbers containing 0 cannot be considered\n            if (digit == 0) {\n                ok = false;\n                break;\n            }\n\n            // If the number isn\u2019t divisible by its digit, stop early\n            if (n % digit != 0) {\n                ok = false;\n                break;\n            }\n        }\n\n        if (ok) {\n            result.push_back(n);\n        }\n    }\n\n    return result;\n}\n\n/*-------------  Example usage  -------------*/\n#include <iostream>\nint main()\n{\n    long start = 1, end = 200;\n    std::vector<long> v = divisible_by_digits(start, end);\n\n    std::cout << \"Numbers between \" << start << \" and \" << end\n              << \" that are divisible by all of their digits:\\n\";\n    for (auto x : v) {\n        std::cout << x << ' ';\n    }\n    std::cout << '\\n';\n\n    return 0;\n}\n```\n\n### How it works\n1. **Range validation** \u2013 If the start number is larger than the end number, the function simply returns an empty vector.\n2. **Digit inspection** \u2013 For each candidate number `n`, it extracts digits one by one using `temp % 10`.  \n   - If a digit is `0`, the number is immediately disqualified.\n   - If `n` isn\u2019t divisible by that digit (`n % digit != 0`), the number is also disqualified.\n3. **Collecting results** \u2013 Numbers that pass the test are pushed into `result` and finally returned.\n\nThe algorithm runs in `O((endnum \u2013 startnum + 1) * log10(endnum))` time, which is perfectly fine for the typical ranges used in programming\u2011exercise problems.", "Here\u2019s a compact C++ implementation that follows the spirit of the linked problem.  \nThe function iterates through the interval `[startnum, endnum]`, checks whether a number is divisible by each of its decimal digits, and collects the qualifying numbers in a `std::vector<long>`.\n\n```cpp\n#include <vector>\n#include <cmath>\n#include <cassert>\n\n/*\n * Return all numbers in the inclusive interval [startnum, endnum]\n * that are divisible by each of their decimal digits.\n *\n * NOTE:\n *   * Numbers that contain the digit 0 are automatically excluded\n *     (division by zero is undefined).\n *   * For negative ranges we treat the digits of the absolute value\n *     but keep the original sign.\n */\nstd::vector<long> divisible_by_digits(long startnum, long endnum)\n{\n    std::vector<long> result;\n\n    for (long n = startnum; n <= endnum; ++n) {\n        bool ok = true;\n        long m   = std::llabs(n);          // work with the absolute value\n\n        if (m == 0) {                      // 0 is divisible by any non\u2011zero digit\n            ok = false;                    // but we skip it (digits are meaningless)\n        }\n\n        while (m > 0 && ok) {\n            int digit = static_cast<int>(m % 10);\n            m /= 10;\n            if (digit == 0 || (n % digit != 0))\n                ok = false;                 // contains 0 or not divisible\n        }\n\n        if (ok)\n            result.push_back(n);\n    }\n\n    return result;\n}\n\n/* Simple demo / unit test */\nint main()\n{\n    // Linear range test\n    auto v = divisible_by_digits(1, 20);\n    assert((v == std::vector<long>{1,2,3,4,5,6,7,8,9,11,12,15,18}));\n\n    // Inclusion of negative numbers\n    auto v2 = divisible_by_digits(-20, -1);\n    assert((v2 == std::vector<long>{-1,-2,-3,-4,-5,-6,-7,-8,-9,-11,-12,-15,-18}));\n\n    // Check that numbers containing 0 are omitted\n    assert(std::find(v.begin(), v.end(), 10) == v.end());\n\n    return 0;\n}\n```\n\n**Explanation**\n\n1. **Loop over the interval** \u2013 We use a simple `for` loop from `startnum` to `endnum` (inclusive).\n\n2. **Check each digit** \u2013 We peel off digits from the absolute value of the current number.  \n   * If a digit is `0`, the number automatically fails the test.  \n   * If the number is not divisible by that digit (`n % digit != 0`), it also fails.\n\n3. **Collect the candidates** \u2013 Numbers that pass all digit checks are pushed into `result`.\n\n4. **Return the vector** \u2013 The resulting vector contains all qualifying numbers in the requested order.\n\nThe example `main` demonstrates a few test cases and a simple unit\u2011test pattern using `assert`. Feel free to integrate this function wherever you need the \u201cself\u2011divisible by digits\u201d logic.", "**Solution Overview**\n\nThe task is to enumerate every integer in the closed interval `[startnum , endnum]` and keep only those that satisfy the following rule:\n\n*For every digit `d` contained in the decimal representation of the number, the number must be divisible by `d` (with the usual convention that the digit `0` is ignored \u2013 a number can never be divisible by zero, so a digit `0` automatically disqualifies the number).*\n\nThe most direct way is:\n\n1. Iterate over all numbers in the interval.  \n2. Extract the digits of the current number.  \n3. For each digit that is not `0` check `%` divisibility.  \n4. If all non\u2011zero digits divide the number, store the number in the result vector.\n\nThe problem statement mentions *lambda*, so the implementation also contains an inline lambda used to test a single digit against the current number. The lambda is written for clarity; it is **not** required for the algorithm.\n\nThe algorithm runs in **O((endnum\u2011startnum+1)\u202f\u00d7\u202fdigits)** which is fine for the typical limits shown in the linked resource (e.g. 1\u202f\u2264\u202fstartnum\u202f\u2264\u202fendnum\u202f\u2264\u202f10\u2076).\n\n---\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// -----------------------------------------------------------\n// Find all numbers between startnum and endnum (inclusive)\n// such that each number is divisible by every one of its digits.\n// Numbers containing a zero digit are automatically excluded.\n//\n// -----------------------------------------------------------\nvector<long> divisible_by_digits(long startnum, long endnum)\n{\n    vector<long> result;\n\n    // Lambda that tests whether a single digit 'd' divides 'num'\n    // (assuming d != 0)\n    auto divides = [](long num, int d) -> bool\n    {\n        return (num % d) == 0;\n    };\n\n    for (long num = startnum; num <= endnum; ++num)\n    {\n        long tmp = num;          // copy for digit extraction\n        bool ok  = true;         // true until a digit disqualifies it\n\n        // Extract digits from the least\u2011significant side\n        while (tmp > 0 && ok)\n        {\n            int digit = static_cast<int>(tmp % 10);\n            tmp /= 10;\n\n            if (digit == 0)      // a zero digit makes the number invalid\n            {\n                ok = false;\n                break;\n            }\n            if (!divides(num, digit))\n            {\n                ok = false;\n            }\n        }\n\n        if (ok)\n            result.push_back(num);\n    }\n\n    return result;\n}\n\n// -----------------------------------------------------------\n// Example usage\n// -----------------------------------------------------------\nint main()\n{\n    long start = 1, end = 100;\n    vector<long> ans = divisible_by_digits(start, end);\n\n    for (long v : ans)\n        cout << v << ' ';\n    cout << '\\n';\n\n    return 0;\n}\n```\n\n### Notes on the code\n\n* **Digit extraction** \u2013 By repeatedly taking `tmp % 10` we obtain the digits from right to left.\n* **Zero handling** \u2013 The rule that \u201cevery number is divisible by every digit it contains\u201d cannot be satisfied for a digit `0`. Hence a number that contains a `0` is immediately rejected.\n* **Lambda** \u2013 `divides` is a tiny helper that makes the main loop slightly clearer; it could as well be replaced by an inline `%` operation.\n* **Performance** \u2013 The routine is linear in the range size and only examines each digit once. For the common test ranges it completes instantly.\n\nThis implementation compiles under any modern C++ compiler (the included header `<bits/stdc++.h>` is a GNU extension; if you prefer standard headers, you can replace it by `#include <iostream>`, `#include <vector>` etc.)."]}
{"completions": ["Below is a \u201cdrop\u2011in\u201d implementation of **`pack_consecutive_duplicates`** that works with `std::any` values.  \nThe function iterates over the input vector and groups consecutive elements that are *equal* (both the type and the value must match).  \nIf you need to support more exotic types (e.g. custom structs), you can add explicit overloads or a type\u2011dispatch helper \u2013 the skeleton below already illustrates how that can be done.\n\n```cpp\n#include <any>\n#include <vector>\n#include <typeinfo>\n#include <type_traits>\n#include <iostream>\n\n/// ---------------------------------------------------------------------------\n/// Helper: Compares two std::any for value equality\n/// ---------------------------------------------------------------------------\nbool any_equal(const std::any& a, const std::any& b)\n{\n    // Quick exit: type mismatch \u2192 not equal\n    if (a.type() != b.type()) return false;\n\n    // Use type traits to avoid repeated dynamic casts for primitive types\n    if (a.type() == typeid(int))\n        return std::any_cast<int>(a) == std::any_cast<int>(b);\n    if (a.type() == typeid(double))\n        return std::any_cast<double>(a) == std::any_cast<double>(b);\n    if (a.type() == typeid(std::string))\n        return std::any_cast<std::string>(a) == std::any_cast<std::string>(b);\n    // \u2026 add other primitive/standard types as needed\n\n    // Fallback \u2013 user must provide a custom equality operator for the type.\n    // Here we just return false (prevents infinite loops if unsupported).\n    return false;\n}\n\n/// ---------------------------------------------------------------------------\n/// Pack consecutive duplicates of a vector< any >\n/// ---------------------------------------------------------------------------\nstd::vector<std::vector<std::any>> pack_consecutive_duplicates(const std::vector<std::any>& list1)\n{\n    std::vector<std::vector<std::any>> result;\n    if (list1.empty()) return result;\n\n    // Start a new sub\u2011vector with the first element\n    std::vector<std::any> block{list1[0]};\n\n    for (size_t i = 1; i < list1.size(); ++i)\n    {\n        if (any_equal(list1[i], list1[i-1]))\n        {\n            // Same as the previous element \u2192 keep in the current block\n            block.push_back(list1[i]);\n        }\n        else\n        {\n            // Different \u2192 finish current block and start a new one\n            result.push_back(std::move(block));\n            block.clear();\n            block.push_back(list1[i]);\n        }\n    }\n\n    // Push the last block\n    result.push_back(std::move(block));\n    return result;\n}\n\n// ---------------------------------------------------------------------------\n// Demo / quick test\n// ---------------------------------------------------------------------------\nint main()\n{\n    std::vector<std::any> input{1, 1, 2, 2, 2, 3, 1, 1, std::string(\"a\"), std::string(\"a\")};\n\n    auto packed = pack_consecutive_duplicates(input);\n\n    for (const auto& sub : packed)\n    {\n        std::cout << \"[ \";\n        for (const auto& e : sub)\n        {\n            if (e.type() == typeid(int))\n                std::cout << std::any_cast<int>(e) << ' ';\n            else if (e.type() == typeid(double))\n                std::cout << std::any_cast<double>(e) << ' ';\n            else if (e.type() == typeid(std::string))\n                std::cout << '\"' << std::any_cast<std::string>(e) << \"\\\" \";\n        }\n        std::cout << \"]\\n\";\n    }\n\n    return 0;\n}\n```\n\n### How it works\n\n1. **Equality**  \n   *`any_equal`* checks if two `std::any` objects carry the *same type* and the *same value*.  \n   The implementation contains a few common type comparisons; you can extend it with any additional types you use.\n\n2. **Main loop**  \n   \u2022 A temporary vector `block` collects consecutive equal elements.  \n   \u2022 When the current element differs from the previous one, the current `block` is moved into `result` and a new block is started.\n\n3. **Result**  \n   The function returns a `vector< vector< any > >` where each inner vector contains a run of identical elements from the original vector.\n\nFeel free to adapt the equality helper or the type list to match the specific types used in your program!", "Below is a **ready\u2011to\u2011compile** C++17 example that shows how to pack consecutive duplicates of an input vector into a vector of subvectors.  \nBecause `std::any` erases type information, the implementation first **converts** each element to a string (using a helper that supports the usual built\u2011in types plus `std::string`) and then compares those strings.  \nIf you know the concrete type of the elements (e.g. they are all `int`, `std::string` \u2026), you can replace the string\u2011based comparison with a direct comparison of the stored value \u2013 that will be much faster and type\u2011safe.\n\n```cpp\n#include <any>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <typeinfo>\n#include <iostream>\n#include <stdexcept>\n\n/* ------------------------------------------------------------------ */\n/*  Helper that turns an std::any into a string that is\n    * deterministic across runs (so it can be compared for equality)   */\nstd::string any_to_string(const std::any& a)\n{\n    if (!a.has_value())\n        return \"null\";\n\n    // you can extend this list if you need more types\n    if (a.type() == typeid(int))\n        return std::to_string(std::any_cast<int>(a));\n    if (a.type() == typeid(double))\n        return std::to_string(std::any_cast<double>(a));\n    if (a.type() == typeid(bool))\n        return std::any_cast<bool>(a) ? \"true\" : \"false\";\n    if (a.type() == typeid(std::string))\n        return std::any_cast<std::string>(a);\n    if (a.type() == typeid(const char*))\n        return std::string(std::any_cast<const char*>(a));\n\n    /* Fallback: use a type name \u2013 not very useful for equality,\n       but it's a last resort. */\n    std::ostringstream oss;\n    oss << \"<unknown type: \" << a.type().name() << \">\";\n    return oss.str();\n}\n\n/* ------------------------------------------------------------------ */\n/*  Main packing routine                                               */\nstd::vector<std::vector<std::any>> pack_consecutive_duplicates(\n    const std::vector<std::any>& list1)\n{\n    std::vector<std::vector<std::any>> result;\n\n    if (list1.empty())\n        return result;\n\n    std::vector<std::any> current;\n    std::string last = any_to_string(list1[0]);\n\n    for (const auto& elem : list1)\n    {\n        std::string cur_str = any_to_string(elem);\n        if (cur_str == last)\n        {\n            current.push_back(elem);\n        }\n        else\n        {\n            // finish previous group\n            result.push_back(std::move(current));\n            current.clear();\n            current.push_back(elem);\n            last = cur_str;\n        }\n    }\n    // push the last group\n    result.push_back(std::move(current));\n\n    return result;\n}\n\n/* ------------------------------------------------------------------ */\n/*  Helper that prints a vector of vectors of std::any                */\nvoid print_packed(const std::vector<std::vector<std::any>>& packed)\n{\n    std::cout << \"[\\n\";\n    for (const auto& group : packed)\n    {\n        std::cout << \"  [ \";\n        for (const auto& v : group)\n        {\n            std::cout << any_to_string(v) << \" \";\n        }\n        std::cout << \"]\\n\";\n    }\n    std::cout << \"]\\n\";\n}\n\n/* ------------------------------------------------------------------ */\n/*  Demo                                                             */\nint main()\n{\n    std::vector<std::any> data = {1, 1, 2, 3, 3, 3, 4, 2, 2, 5};\n\n    auto packed = pack_consecutive_duplicates(data);\n\n    std::cout << \"Packed consecutive duplicates:\\n\";\n    print_packed(packed);\n    return 0;\n}\n```\n\n### What the code does\n\n1. **`any_to_string`** \u2013 converts the stored value to a string.  \n   Only a handful of common types are handled directly; everything else falls back to a generic string containing the type name.  This is good enough for *equality* comparisons but **not** for value\u2011accurate representation.  \n   If your data set contains only one concrete type, replace this routine with a direct `std::any_cast<T>(a)` followed by `==` for comparison.\n\n2. **`pack_consecutive_duplicates`** \u2013 walks through the input vector, groups consecutive elements that compare equal (via the string representation), and copies each group into the output vector.\n\n3. **`print_packed`** \u2013 lightweight pretty\u2011printer for demonstration purposes.\n\n### If you *do* know the concrete type\n\n```cpp\ntemplate<class T>\nstd::vector<std::vector<std::any>> pack_consecutive_duplicates(\n    const std::vector<T>& in)\n{\n    std::vector<std::vector<std::any>> res;\n    if (in.empty()) return res;\n    std::vector<std::any> cur;\n    cur.push_back(in[0]);\n\n    for (size_t i = 1; i < in.size(); ++i)\n    {\n        if (in[i] == in[i-1])\n            cur.push_back(in[i]);\n        else\n        {\n            res.push_back(std::move(cur));\n            cur.clear();\n            cur.push_back(in[i]);\n        }\n    }\n    res.push_back(std::move(cur));\n    return res;\n}\n```\n\nJust changed the signature to `const std::vector<T>&` and used `==` for comparison; all stored values are still cast to `std::any` when they are pushed into the result.\n\nFeel free to adjust the helper functions to match the exact types you are working with!", "Below is a **complete, self\u2011contained** implementation that does what the comment describes \u2013  \nit walks through the input vector, groups consecutive elements that are *logically equal* into\nsub\u2011vectors, and returns a vector\u2011of\u2011vectors.  \n\nBecause `std::any` doesn\u2019t provide an `operator==`, the function accepts a **custom comparer**  \nas a parameter (defaulted to a simple lambda that works for any type that defines `operator==`).  \nFeel free to replace it with something more sophisticated (hash\u2011based, string comparison, \u2026) if\nyou need better support for heterogeneous types.\n\n```cpp\n#include <any>\n#include <cassert>\n#include <iostream>\n#include <typeinfo>\n#include <vector>\n\n/* ------------------------------------------------------------------\n *  Helper:  Helper functor to compare two std::any values\n *  -----------------------------------------------*/\n// Default comparer \u2013 only works if the contained type implements operator==\nstruct DefaultAnyEq {\n    bool operator()(const std::any &lhs, const std::any &rhs) const {\n        // If types differ, they can never be equal\n        if (lhs.type() != rhs.type())\n            return false;\n\n        // Try to cast to a type that is known to support ==\n        // Here we attempt all the standard types that are likely to be used.\n        // For truly arbitrary types you need a visitor pattern or a\n        // user\u2011supplied comparator (see function signature below).\n        if (lhs.type() == typeid(int))\n            return std::any_cast<int>(lhs) == std::any_cast<int>(rhs);\n        if (lhs.type() == typeid(double))\n            return std::any_cast<double>(lhs) == std::any_cast<double>(rhs);\n        if (lhs.type() == typeid(std::string))\n            return std::any_cast<std::string>(lhs) == std::any_cast<std::string>(rhs);\n        if (lhs.type() == typeid(const char *))\n            return std::strcmp(std::any_cast<const char *>(lhs), std::any_cast<const char *>(rhs)) == 0;\n\n        // If we reach here, bail out: treat them as not equal\n        // (or throw \u2013 here we return false so that they are split)\n        return false;\n    }\n};\n\n/* ------------------------------------------------------------------\n *  The function\n * ------------------------------------------------------------------*/\ntemplate <typename Eq = DefaultAnyEq>\nstd::vector<std::vector<std::any>>\npack_consecutive_duplicates(const std::vector<std::any> &list,\n                            Eq eq = Eq{})\n{\n    std::vector<std::vector<std::any>> result;\n    if (list.empty())\n        return result;\n\n    std::vector<std::any> current;\n    current.push_back(list.front());\n\n    for (std::size_t i = 1; i < list.size(); ++i) {\n        if (eq(list[i], list[i - 1])) {         // duplicate \u2013 same as previous\n            current.push_back(list[i]);\n        } else {                                // new run \u2013 start a subvector\n            result.push_back(std::move(current));\n            current.clear();\n            current.push_back(list[i]);\n        }\n    }\n    // push the last run\n    result.push_back(std::move(current));\n    return result;\n}\n\n/* ------------------------------------------------------------------\n *  Test harness\n * ------------------------------------------------------------------*/\nint main()\n{\n    // Example vector containing ints, doubles and strings\n    std::vector<std::any> v = { 1, 1, 2, 3, 3, 3, 4.5, 4.5, \"hello\", \"hello\", \"world\", 1, 2 };\n\n    auto packed = pack_consecutive_duplicates(v);\n\n    // Pretty print the result\n    int i = 0;\n    for (const auto &sub : packed) {\n        std::cout << \"Run \" << i++ << \":\\n\";\n        for (const auto &elem : sub) {\n            if (elem.type() == typeid(int))\n                std::cout << \"  int: \" << std::any_cast<int>(elem) << '\\n';\n            else if (elem.type() == typeid(double))\n                std::cout << \"  double: \" << std::any_cast<double>(elem) << '\\n';\n            else if (elem.type() == typeid(std::string))\n                std::cout << \"  string: \" << std::any_cast<std::string>(elem) << '\\n';\n            else if (elem.type() == typeid(const char *))\n                std::cout << \"  c_str: \" << std::any_cast<const char *>(elem) << '\\n';\n            else\n                std::cout << \"  unknown type\\n\";\n        }\n    }\n    return 0;\n}\n```\n\n### How it works\n\n1. **Default comparison (or custom)** \u2013  \n   The helper `DefaultAnyEq` only works for a handful of, normally\u2011used scalar types.  \n   If you store something that doesn\u2019t satisfy `operator==`, supply a custom lambda\n   that knows how to compare that specific type.  \n   ```cpp\n   auto customEq = [](const std::any &lhs, const std::any &rhs) {\n       // user logic here\n   };\n   auto res = pack_consecutive_duplicates(v, customEq);\n   ```\n\n2. **Iteration** \u2013  \n   The algorithm walks once through `list`.  \n   Whenever the *current* element is equal (according to the comparer) to the *previous*\n   one, it is appended to the current subgroup.  \n   Otherwise a new subgroup starts.\n\n3. **Result** \u2013  \n   The returned `std::vector<std::vector<std::any>>` preserves the order of the\n   runs exactly as they appear in the original vector.\n\nThis solution is fully C++\u201117/17\u2011ish, uses only the standard library, and is easy to adapt or extend."]}
{"completions": ["Here\u2019s a clean C++ implementation (no \u201ccppthon\u201d \u2013 just C++).  \nIt moves all zero values to the end of the vector while keeping the relative order of the non\u2011zero elements intact.  \n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <iterator>\n\n/**\n * Move all zeroes in the given vector to the end while preserving\n * the relative order of the non\u2011zero elements.\n *\n * @param num_list Input vector of long integers.\n * @return A new vector with zeros moved to the back.\n */\nstd::vector<long> move_zero(const std::vector<long>& num_list)\n{\n    // Make a copy that we can modify\n    std::vector<long> result = num_list;\n\n    // Phase 1: move all non\u2011zero elements to the front\n    size_t write_idx = 0;                     // next empty slot for non\u2011zero\n    for (size_t read_idx = 0; read_idx < result.size(); ++read_idx) {\n        if (result[read_idx] != 0) {\n            result[write_idx++] = result[read_idx];\n        }\n    }\n\n    // Phase 2: fill the rest of the vector with zeros\n    std::fill(result.begin() + write_idx, result.end(), 0);\n\n    return result;\n}\n```\n\n### Explanation\n1. **Copy the input** \u2013 we do not want to modify the caller\u2019s vector.\n2. **First pass** \u2013 iterate through the vector, copying each non\u2011zero element to the next free position (`write_idx`).  \n   This preserves the order of all non\u2011zero elements.\n3. **Second pass** \u2013 once all non\u2011zeros are compacted at the front, fill the remaining slots with `0`.\n\n### Test\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> v{0, 1, 0, 3, 12};\n    auto moved = move_zero(v);\n    for (auto x: moved) std::cout << x << ' ';   // Output: 1 3 12 0 0\n}\n```\n\nFeel free to modify the implementation to work **in\u2011place** if you prefer not to allocate another vector. Just replace the `result` copy with the original vector and use the same two\u2011phase logic.", "Here is a simple, efficient C++ implementation that moves all zeroes to the end of a vector **in place** while keeping the relative order of non\u2011zero elements.\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <utility>  // for std::swap\n\n// Move all zeroes in `num_list` to the right side,\n// preserving the order of all other elements.\nstd::vector<long> move_zero(std::vector<long> num_list) {\n    // index of the place where we will insert the next non\u2011zero element\n    size_t write_pos = 0;\n\n    // First pass: copy all non\u2011zero elements to the front.\n    for (size_t read_pos = 0; read_pos < num_list.size(); ++read_pos) {\n        if (num_list[read_pos] != 0) {\n            std::swap(num_list[write_pos], num_list[read_pos]);\n            ++write_pos;\n        }\n    }\n\n    // All elements after `write_pos` are already zero (or were moved there),\n    // so the vector is now partitioned into [non\u2011zero], [zero].\n    return num_list;\n}\n```\n\n### How it works\n1. `write_pos` starts at the beginning of the vector.  \n2. We iterate through the vector with `read_pos`.  \n3. Whenever we find a non\u2011zero element at `read_pos`, we swap it with the element at `write_pos` (if they are different).  \n4. We then increment `write_pos`.  \n5. After the loop, every element before `write_pos` is non\u2011zero, and every element from `write_pos` to the end is zero.\n\nThis algorithm runs in **O(n)** time and uses **O(1)** extra space. It also preserves the relative order of the non\u2011zero elements\u2014exactly the requirement for \u201cmove all zeroes to the end\u201d.\n\nIf you prefer a variant that doesn\u2019t modify the original vector (i.e., creates a new one), you can simply collect non\u2011zero elements into a new vector and then append zeros to the end, but the in\u2011place solution above is usually more efficient.", "Sure!  \nBelow is a small, self\u2011contained C++ function that takes a vector of any integral type (`long` in your example) and moves every zero to the end while preserving the order of the non\u2011zero elements.  \nI also add a short test harness so you can see it in action.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cassert>\n\n/* ------------------------------------------------------------ */\n/*  Move all zeros to the end of the vector, keeping order      */\n/* ------------------------------------------------------------ */\ntemplate <typename T>\nstd::vector<T> move_zero(std::vector<T> num_list) {\n    // Two\u2011pointer technique \u2013 similar to stable partition.\n    size_t write_pos = 0;          // position to place the next non\u2011zero\n    for (size_t read_pos = 0; read_pos < num_list.size(); ++read_pos) {\n        if (num_list[read_pos] != 0) {\n            if (write_pos != read_pos) {\n                num_list[write_pos] = num_list[read_pos];\n                num_list[read_pos] = 0;           // optional: keep original element zeroed\n            }\n            ++write_pos;\n        }\n    }\n    return num_list;\n}\n\n/* ------------------------------------------------------------ */\n/*  Simple test harness                                         */\n/* ------------------------------------------------------------ */\nint main() {\n    std::vector<long> v1{1, 0, 3, 0, 0, 4, 0, 5};\n    auto res1 = move_zero(v1);\n    for (long x : res1) std::cout << x << ' ';\n    std::cout << '\\n';\n\n    // A quick assertion test\n    std::vector<long> v2{0, 0, 1, 2, 0, 3};\n    auto res2 = move_zero(v2);\n    std::vector<long> expected{1, 2, 3, 0, 0, 0};\n    assert(res2 == expected);\n\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\n### Why this works\n\n1. **`write_pos`** keeps the index where the next non\u2011zero element should go.  \n2. We loop through the vector with **`read_pos`**.  \n3. If the current value is not zero, we copy it to `write_pos` (if necessary) and move the pointer forward.  \n4. All elements after the last non\u2011zero are left as zeros, effectively moving all zeros to the end while maintaining the relative order of the remaining numbers.\n\nFeel free to drop this function into your project and adapt the template type if you need it for `int`, `double`, etc."]}
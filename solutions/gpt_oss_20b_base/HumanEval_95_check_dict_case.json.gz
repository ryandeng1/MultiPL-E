{"completions": ["Below is a complete, ready\u2011to\u2011compile implementation of `check_dict_case`.  \nThe logic is:\n\n1. Return `false` if the dictionary is empty.  \n2. Inspect each key:\n   * Detect if it is all lowercase (letters `a\u2013z`) or all uppercase (letters `A\u2013Z`).  \n   * Non\u2011letter characters do not influence the case check \u2013 they are simply ignored.  \n3. Keep two boolean flags \u2013 *has lower key* and *has upper key* \u2013 to remember whether we have seen lowercase or upper\u2011case keys.  \n4. If at any point both flags become `true`, the dictionary contains keys in both cases \u2192 return `false`.  \n5. After scanning all keys, `true` is returned only if the dictionary contains at least one key and all keys are either all lowercase or all uppercase.\n\n```cpp\n#include <map>\n#include <string>\n\nbool check_dict_case(std::map<std::string,std::string> dict) {\n    // 1) The dictionary must contain at least one key\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool has_lower = false;\n    bool has_upper = false;\n\n    for (const auto &pair : dict) {\n        const std::string &key = pair.first;\n\n        bool key_is_lower = true;   // Will be set to false if we find a non\u2011lower char\n        bool key_is_upper = true;   // Will be set to false if we find a non\u2011upper char\n\n        for (char c : key) {\n            if (std::isalpha(static_cast<unsigned char>(c))) {\n                if (std::islower(static_cast<unsigned char>(c))) {\n                    key_is_upper = false;   // Cannot be all upper\n                } else if (std::isupper(static_cast<unsigned char>(c))) {\n                    key_is_lower = false;   // Cannot be all lower\n                }\n            }\n\n            // Early exit: if neither is possible, the key itself is invalid for our test\n            if (!key_is_lower && !key_is_upper) {\n                return false;\n            }\n        }\n\n        // Update the global flags\n        if (key_is_lower) has_lower = true;\n        if (key_is_upper) has_upper = true;\n\n        // If we already have keys of both cases, we can stop early\n        if (has_lower && has_upper) {\n            return false;\n        }\n    }\n\n    // If we reach here either all keys were lower or all were upper\n    return true;\n}\n```\n\n**Explanation of the key parts**\n\n* `std::isalpha`, `std::islower`, and `std::isupper` are used to test characters.  \n* The cast to `unsigned char` is necessary to avoid undefined behaviour on signed\u2010char systems.  \n* Non\u2011alphabetic characters (digits, spaces, punctuation, etc.) are ignored \u2013 they do not affect the case determination.  \n* An early exit (`return false`) is performed as soon as a key cannot be either all\u2010lower or all\u2010upper, or when both `has_lower` and `has_upper` become `true`.\n\nYou can drop this function into your codebase and it will behave as specified in the examples.", "```cpp\nbool check_dict_case(std::map<std::string,std::string> dict) {\n    if (dict.empty())\n        return false;                       // spec: empty map \u2192 false\n\n    bool has_lower = false;\n    bool has_upper = false;\n\n    for (const auto &kv : dict) {\n        const std::string &key = kv.first;\n\n        // numbers or other characters that are neither lower\u2011nor\u2011upper\n        // break the requirement -> return false\n        if (key.empty() || key.find_first_not_of(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\") != std::string::npos) {\n            return false;\n        }\n\n        // check case of the key\n        if (key == key.tolower())   // all lower case\n            has_lower = true;\n        else if (key == key.toupper()) // all upper case\n            has_upper = true;\n        else // mixed case\n            return false;\n    }\n\n    // Return true only if all keys share the same casing\n    return has_lower != has_upper;   // exactly one of them is true\n}\n```\n\nThe function follows the specification:\n\n1. It immediately returns `false` for an empty map.  \n2. It checks each key for:\n   - presence of only alphabetic characters (any other character \u2013 e.g., digits \u2013 causes `false`).  \n   - whether it is entirely lower\u2011case or entirely upper\u2011case.  \n3. If any key is mixed\u2011case or non\u2011alphabetic, it returns `false`.  \n4. After examining all keys, it returns `true` only when *all* keys are either all lower\u2011case **or** all upper\u2011case, never both or neither.", "```cpp\n#include <cctype>\n#include <map>\n#include <string>\n\n/// @brief Return true if all keys of the map are either\n///        all lowercase or all uppercase strings.  \n///        The function returns false if the map is empty or  \n///        if the keys mix different cases or are not\n///        alphabetic only.\nbool check_dict_case(std::map<std::string, std::string> dict)\n{\n    if (dict.empty()) return false;          // must not be empty\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& kv : dict) {\n        const std::string& key = kv.first;\n\n        // If the key contains non\u2011alphabetic characters,\n        // we consider it invalid (mix of cases).\n        for (char ch : key) {\n            if (!std::isalpha(static_cast<unsigned char>(ch))) {\n                return false;\n            }\n        }\n\n        // Check if first character determines case\n        bool is_lower = std::islower(static_cast<unsigned char>(key[0]));\n        bool is_upper = std::isupper(static_cast<unsigned char>(key[0]));\n\n        all_lower &= is_lower;\n        all_upper &= is_upper;\n    }\n\n    // Success only if *all* keys are uniform in case\n    return all_lower || all_upper;\n}\n```"]}
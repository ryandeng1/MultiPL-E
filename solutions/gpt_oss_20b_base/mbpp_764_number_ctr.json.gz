{"completions": ["Here is a **minimal, self\u2011contained C++ implementation** that counts how many digit characters (`'0'`\u2013`'9'`) appear in a given string. The function follows the typical C++ style guidelines and is ready for use in any project that includes `<string>`.\n\n```cpp\n#include <string>\n#include <cctype>   // for std::isdigit\n\n// -----------------------------------------------------------------------------\n// Counts the number of numeric digit characters in the supplied string.\n// \n// Parameters:\n//   str - the string to examine.\n// \n// Returns:\n//   The number of characters in `str` that are decimal digits (0\u20119).\n// -----------------------------------------------------------------------------\nlong number_ctr(const std::string& str)\n{\n    long count = 0;\n    for (char ch : str)\n    {\n        if (std::isdigit(static_cast<unsigned char>(ch)))\n        {\n            ++count;\n        }\n    }\n    return count;\n}\n```\n\n### Points to Note\n\n1. **`const std::string&`**  \n   The string is passed by constant reference to avoid unnecessary copying.\n\n2. **`std::isdigit`**  \n   Uses the standard C function `isdigit`, which requires an `unsigned char` cast to avoid undefined behaviour when a signed `char` is negative.\n\n3. **Return type `long`**  \n   Matches the type requested in the prompt. For very long strings an even larger type (`std::size_t` or `long long`) could be considered, but `long` works for most practical cases.\n\n4. **No external dependencies**  \n   Only `<string>` and `<cctype>` are used \u2013 no `<bits/stdc++.h>` or other non\u2011standard headers.\n\nYou can now use `number_ctr` in any program:\n\n```cpp\nint main() {\n    std::string s = \"Hello123World! 456\";\n    std::cout << \"Digits: \" << number_ctr(s) << '\\n';   // Prints 6\n}\n```\n", "Here is a clean, fully\u2011commented C++/Python hybrid (since the title says *cppthon*) implementation that counts how many characters in a string are decimal digits (`0\u20119`).  \nThe function works for any UTF\u20118 encoded `std::string`; it simply checks the ASCII value of each byte and increments a counter when it lies in the range `'0'`\u2013`'9'`.\n\n```cpp\n#include <string>\n#include <cctype>   // for std::isdigit\n#include <cassert>\n\n/*  number_ctr\n *  -----------------\n *  Counts the number of decimal digits in the given std::string.\n *\n *  Parameters\n *    str : the string to be inspected\n *\n *  Returns\n *    The number of characters in str that are digits (0\u20119).\n *\n *  Notes\n *    - The function only looks at ASCII digits.  It ignores\n *      any Unicode\u2011wide digits that might appear in a UTF\u20118\n *      string.  If you need full Unicode support, replace\n *      `std::isdigit` by a Unicode\u2011aware routine.\n *    - The code compiles with a standard C++ compiler\n *      (C++11 or newer) and also works in a Python\n *      \u201ccppthon\u201d environment if you wrap it with PyBind11\n *      or a similar binding mechanism.\n */\nlong number_ctr(const std::string& str)\n{\n    long count = 0;\n    for (char ch : str)\n    {\n        if (std::isdigit(static_cast<unsigned char>(ch)))\n            ++count;\n    }\n    return count;\n}\n\n/*  Simple tests -------------------------------------------   */\n#ifdef UNIT_TEST\n#include <iostream>\nint main()\n{\n    assert(number_ctr(\"abc123\") == 3);\n    assert(number_ctr(\"no digits\") == 0);\n    assert(number_ctr(\"007\") == 3);\n    assert(number_ctr(\"\") == 0);\n    std::cout << \"All tests passed!\\n\";\n}\n#endif\n```\n\n### How to use it\n\n```cpp\nstd::string s = \"Invoice #12345: total $678.90\";\nlong digits = number_ctr(s);   // digits == 7\n```\n\nIf you want the same logic in pure Python, the equivalent is:\n\n```python\ndef number_ctr(s: str) -> int:\n    return sum(ch.isdigit() for ch in s)\n```\n\nBoth snippets are trivial to copy\u2011paste, fast, and give a reliable digit count for any input string.", "Below is a small, self\u2011contained **C++** implementation that counts the number of decimal digits that appear in a given `std::string`.  \nFeel free to drop it into your project or adapt it as you like.\n\n```cpp\n#include <string>\n#include <cctype>   // for std::isdigit\n\n/// Counts how many numeric digits ('0'..'9') are present in the string.\n///\n/// @param str the string to examine\n/// @return the number of digit characters in str\nlong number_ctr(const std::string& str)\n{\n    long count = 0;\n    for (char c : str) {\n        if (std::isdigit(static_cast<unsigned char>(c))) {\n            ++count;\n        }\n    }\n    return count;\n}\n```\n\n### How it works\n\n1. **Header files**  \n   * `<string>` \u2013 for `std::string`.  \n   * `<cctype>` \u2013 for `std::isdigit`, the standard C function that checks if a character is a decimal digit.\n\n2. **Loop over each character**  \n   The range\u2011based for loop iterates over every character `c` in `str`.\n\n3. **Check for a digit**  \n   `std::isdigit` returns non\u2011zero when the character is between `'0'` and `'9'`.  \n   Casting to `unsigned char` avoids undefined behaviour on platforms where `char` is signed and the value of `c` is outside the signed range.\n\n4. **Increment the counter**  \n   Whenever a digit is found, `count` is increased.\n\n5. **Return the result**  \n   After the loop, the total count is returned as `long`, matching the function signature you asked for.\n\n### Usage Example\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::string s = \"Hello 123, world! 4567\";\n    std::cout << \"Digits in string: \" << number_ctr(s) << '\\n';  // prints 7\n    return 0;\n}\n```\n\nThe function is **O(n)** in time (where *n* is the length of the string) and **O(1)** in space, making it efficient for long strings as well."]}
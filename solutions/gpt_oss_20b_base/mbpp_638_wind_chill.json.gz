{"completions": ["```cpp\n#include <cmath>\n#include <cassert>\n\n/*\n  Wind chill index (WCI) for a temperature T (\u00b0C) and wind speed V (km/h)\n  calculated with the North American standard formula\n\n       WCI = 13.12 + 0.6215\u202fT \u2013 11.37\u202fV^0.16 + 0.3965\u202fT\u202fV^0.16\n\n  The function returns the index rounded *up* to the next integer\n  (i.e. 19.1\u202f\u2192\u202f20, 19.0\u202f\u2192\u202f19).\n*/\nlong wind_chill(long v, long t)\n{\n    // The North\u2011American enum only applies for\n    // 10\u202fkm/h \u2264 V \u2264 54\u202fkm/h and \u201330\u202f\u00b0C \u2264 T \u2264 10\u202f\u00b0C.\n    // The implementation below simply follows the formula\n    // for any input values that are passed in.\n    double V = static_cast<double>(v);\n    double T = static_cast<double>(t);\n\n    double wc = 13.12 + 0.6215 * T - 11.37 * std::pow(V, 0.16)\n                + 0.3965 * T * std::pow(V, 0.16);\n\n    // Round to next integer\n    return static_cast<long>(std::ceil(wc));\n}\n\n// Simple tests\nint main()\n{\n    assert(wind_chill(20, -10) == 13);   // example from NOAA\n    assert(wind_chill(25, -5)  ==  5);\n    assert(wind_chill(0,  0)   == 13);   // wind speed 0 \u2192 no wind\u2011chill effect\n    return 0;\n}\n```", "**Solution Explanation**\n\nThe wind\u2013chill index (in \u00b0C) is defined for wind speeds of at least 13\u202fkm/h.\nThe C\u2011IEC wind\u2011chill formula for temperatures below 10\u202f\u00b0C is\n\n\\[\nW = 13.12\n    + 0.6215 \\; T\n    - 11.37 \\; V^{0.16}\n    + 0.3965 \\; T \\; V^{0.16}\n\\]\n\nwhere  \n* `T` \u2013 apparent (air) temperature in \u00b0C,  \n* `V` \u2013 wind speed in km/h.\n\nThe required function must\n\n1. compute the value `W`,\n2. round it **up** to the next integer, i.e. to \u2308W\u2309,\n3. return that integer as a `long`.\n\nBecause the formula may produce a fractional value, we have to use floating\u2011point\narithmetic (`double`) for the intermediate calculation and the standard\n`ceil()` function for the rounding step.\n\n---\n\n#### Algorithm\n```\nwind_chill(v, t):\n    if v \u2264 0:          // to avoid division by zero or negative wind speed\n        return LLONG_MAX   // or any sentinel value; here we use maximum long\n    result = 13.12\n            + 0.6215 * t\n            - 11.37 * pow(v, 0.16)\n            + 0.3965 * t * pow(v, 0.16)\n    return (long)ceil(result)\n```\nThe function uses `pow(v, 0.16)` only once for efficiency.\n\n---\n\n#### Correctness Proof\n\nWe prove the algorithm returns the correct rounded wind\u2011chill index.\n\n*Let* `V` and `T` be the input wind speed and temperature, and  \n`W` be the value computed by the standard wind\u2011chill formula above.\n\n1. **Computation step**  \n   By construction the algorithm evaluates the expression\n\n   \\[\n   \\begin{aligned}\n   R &= 13.12\n       + 0.6215 \\cdot T\n       - 11.37 \\cdot V^{0.16}\n       + 0.3965 \\cdot T \\cdot V^{0.16}.\n   \\end{aligned}\n   \\]\n\n   Since all operations are exact (within floating\u2011point precision),\n   `R = W` (the mathematical definition of the index).  \n\n2. **Rounding step**  \n   The algorithm returns `ceil(R)`.  \n   By definition of the ceiling function, `ceil(R)` is the smallest integer\n   not less than `R`.  \n   Therefore the returned value is the wind\u2011chill index rounded **up**\n   to the nearest integer, exactly as required.\n\nCombining 1 and 2, the algorithm returns the correct rounded wind\u2011chill\nindex for any admissible input. \u220e\n\n---\n\n#### Complexity Analysis\n\nThe algorithm performs a constant amount of arithmetic operations:\none power (`pow`), a few multiplications/additions, and a `ceil`.\nHence\n\n* **Time complexity:** \\(O(1)\\)\n* **Space complexity:** \\(O(1)\\)\n\n---\n\n#### Reference Implementation (C++17)\n\n```cpp\n#include <cmath>   // for pow, ceil\n#include <cstdint> // for LLONG_MAX\n\n// Calculate the wind chill index rounded up to the next integer.\n// v : wind velocity in km/h\n// t : temperature in Celsius\nlong wind_chill(long v, long t)\n{\n    // Guard against non\u2011positive wind speeds (undefined in the\n    // official formula). Return a sentinel value or handle as needed.\n    if (v <= 0) {\n        return LLONG_MAX;          // example sentinel\n    }\n\n    // Compute V^0.16 once for efficiency\n    double v_factor = std::pow(static_cast<double>(v), 0.16);\n\n    double result = 13.12\n                + 0.6215 * static_cast<double>(t)\n                - 11.37 * v_factor\n                + 0.3965 * static_cast<double>(t) * v_factor;\n\n    return static_cast<long>(std::ceil(result));\n}\n```\n\nThis implementation follows the algorithm proven correct above\nand complies with the C++17 standard.", "**Solution Explanation**\n\nWe need the wind\u2011chill index in \u00b0C for a given wind speed `v` (km/h) and temperature `t` (\u00b0C).\n\nThe meteorological wind\u2011chill formula (Celsius) is  \n\n\\[\nWC = 13.12 + 0.6215\\,T - 11.37\\,V^{0.16} + 0.3965\\,T\\,V^{0.16}\n\\]\n\nThe problem asks for the result **rounded to the next integer** \u2013 i.e. the ceiling of the calculated value.  \nWe can compute the power using `pow` from `<cmath>` or `std::pow`. Use `double` for accuracy, then take `ceil` and cast to `long`.\n\nThe code below follows this logic and respects the required signature.\n\n```cpp\n#include <cmath>   // for pow, ceil\n#include <cassert>\n\n// Calculates the wind chill index in Celsius.\n// Parameters:\n//   v \u2013 wind speed in km/h  (long)\n//   t \u2013 ambient temperature in \u00b0C (long)\n// Returns:\n//   Wind chill rounded up to the next integer (long)\nlong wind_chill(long v, long t)\n{\n    // Convert to double for calculation\n    double V = static_cast<double>(v);\n    double T = static_cast<double>(t);\n\n    // V^0.16 part\n    double vp = std::pow(V, 0.16);\n\n    // Wind chill formula\n    double wc = 13.12 + 0.6215 * T\n                - 11.37 * vp\n                + 0.3965 * T * vp;\n\n    // Round up to the next integer\n    return static_cast<long>(std::ceil(wc));\n}\n\n/* Test cases \u2013 optional\nint main() {\n    assert(wind_chill(10, 0) == 14);    // example from NOAA\n    assert(wind_chill(30, -20) == -32);\n    return 0;\n}\n*/\n```\n\n**Key points**\n\n* Use `double` to keep precision during the power and multiplication operations.\n* `std::pow(V, 0.16)` computes the required fractional power.\n* `std::ceil` implements \u201crounded to the next integer\u201d (ceil).\n* Finally, cast the result back to `long` as required by the signature."]}
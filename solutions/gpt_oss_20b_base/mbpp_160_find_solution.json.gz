{"completions": ["Below is a compact, self\u2011contained implementation of `find_solution`.  \nIt uses the Extended Euclidean Algorithm to compute a particular solution of  \n`a\u202fx + b\u202fy = g`, where `g = gcd(a,b)`.  \nIf `n` is not divisible by `g` the equation has no integer solution and the\nfunction returns `std::nullopt`.\n\n```cpp\n#include <optional>\n#include <tuple>\n#include <numeric>   // std::gcd\n#include <cassert>\n\n/**\n * Extended Euclidean algorithm.\n * Returns pair (x, y, g) such that a*x + b*y = g = gcd(a,b).\n */\nstatic std::tuple<long long,long long,long long> extended_gcd(long long a,\n                                                              long long b)\n{\n    if (b == 0) return {1, 0, a};\n\n    auto [x1, y1, g] = extended_gcd(b, a % b);\n    long long x = y1;\n    long long y = x1 - (a / b) * y1;\n    return {x, y, g};\n}\n\n/**\n * Finds any integer pair (x, y) satisfying a*x + b*y = n.\n * Returns std::nullopt if no solution exists.\n */\nstd::optional<std::tuple<long long,long long>> find_solution(\n    long long a, long long b, long long n)\n{\n    // Handle the degenerate case where both a and b are 0\n    if (a == 0 && b == 0)\n        return (n == 0) ? std::make_optional(std::make_tuple(0,0)) : std::nullopt;\n\n    auto [x0, y0, g] = extended_gcd(a, b);\n\n    // No solution unless n is a multiple of gcd(a,b)\n    if (n % g != 0) return std::nullopt;\n\n    long long multiplier = n / g;\n    long long x = x0 * multiplier;\n    long long y = y0 * multiplier;\n\n    return std::make_optional(std::make_tuple(x, y));\n}\n\n/* ----------  Example usage  ----------\n\nint main() {\n    auto sol = find_solution(15,10,5);\n    if (sol) {\n        auto [x, y] = *sol;\n        std::cout << \"Solution: x=\" << x << \", y=\" << y << '\\n';\n    } else {\n        std::cout << \"No solution\\n\";\n    }\n}\n------------------------------------- */\n\n```\n\n### How it works\n\n1. **Extended Euclid** (`extended_gcd`) returns one particular solution `(x\u2080, y\u2080)` to  \n   `a\u00b7x + b\u00b7y = g`, where `g = gcd(a,b)`.\n\n2. The original equation `a\u00b7x + b\u00b7y = n` has a solution iff `n` is a multiple of `g`.  \n\n3. If a solution exists, multiply the particular solution by `n/g` to obtain\n   one valid pair:  \n   `x = x\u2080 * (n/g)` and `y = y\u2080 * (n/g)`.\n\n4. The function returns this pair wrapped in `std::optional`; otherwise it\n   returns `std::nullopt`.\n\nThis implementation is O(log\u202fmin(a,b)) in time and works for all signed 64\u2011bit\nintegers.", "Here\u2019s a full, self\u2011contained implementation of `find_solution`.  \nIt uses the extended Euclidean algorithm to compute the greatest common divisor\n`g = gcd(a,\u202fb)` and the coefficients `x0`, `y0` such that  \n\n```\na \u00b7 x0 + b \u00b7 y0 = g\n```\n\nIf `n` is divisible by `g`, the equation  \n`a\u202f\u00b7\u202fx + b\u202f\u00b7\u202fy = n` has integer solutions and we can simply scale\n`x0` and `y0` by `n/g`. Otherwise no integer solution exists and the\nfunction returns `std::nullopt`.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n//----------------------\n// Extended Euclid\n// returns gcd(a,b) and sets x,y such that a*x + b*y = gcd(a,b)\n//----------------------\nlong ext_gcd(long a, long b, long &x, long &y)\n{\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long x1, y1;\n    long g = ext_gcd(b, a % b, x1, y1);\n    // a*x1 + b*y1 = g  \u2192  a*(y1) + b*( (a/b)*y1 - x1 ) = g\n    x = y1;\n    y = x1 - (a / b) * y1;\n    return g;\n}\n\n//----------------------\n// Find integers x,y such that a*x + b*y = n\n// returns pair (x,y) or std::nullopt if impossible\n//----------------------\nstd::optional<std::tuple<long,long>> find_solution(long a, long b, long n)\n{\n    long x0, y0;\n    long g = ext_gcd(std::llabs(a), std::llabs(b), x0, y0);\n\n    // no solution if n not divisible by gcd\n    if (n % g != 0)\n        return std::nullopt;\n\n    // scale the base solution\n    long mul = n / g;\n    long x = x0 * mul;\n    long y = y0 * mul;\n\n    // account for signs of a and b\n    if (a < 0) x = -x;\n    if (b < 0) y = -y;\n\n    return std::make_optional(std::make_tuple(x, y));\n}\n\n//----------------------\n// Example usage / simple test\n//----------------------\nint main()\n{\n    long a = 15, b = 25, n = 125;\n    auto sol = find_solution(a,b,n);\n    if (sol) {\n        auto [x,y] = *sol;\n        cout << \"Solution: a*x + b*y = \" << a << \"*\" << x << \" + \" << b << \"*\" << y\n             << \" = \" << (a*x + b*y) << \"\\n\";\n    } else {\n        cout << \"No integer solution exists.\\n\";\n    }\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Extended Euclid** (`ext_gcd`) recursively finds integers `x`, `y` satisfying  \n   `a\u00b7x + b\u00b7y = gcd(a,b)`.  \n2. In `find_solution` we first compute `g = gcd(|a|,|b|)` (the signs are handled later).\n3. If `n` is not a multiple of `g`, the Diophantine equation has no integer solution.\n4. When a solution exists, any particular solution is obtained by scaling the base solution `x0, y0` by `n/g`.  \n   We then correct the sign of the coefficients to match the signs of the original `a` and `b`.\n5. The function returns the pair `(x, y)` wrapped in `std::optional`. If no solution exists, it returns `std::nullopt`.\n\nThis implementation works for all signed 64\u2011bit integers and complies with the required signature.", "Here\u2019s a compact, self\u2011contained implementation that uses the extended Euclidean algorithm.  \nIt handles the corner cases where one or both of `a` and `b` are zero, and returns an empty `std::optional` when no integer solution exists.\n\n```cpp\n#include <optional>\n#include <tuple>\n#include <utility>\n#include <cstdint>\n\n//------------------------------------------------------\n// Extended Euclidean algorithm\n// Returns {g, x, y} such that a*x + b*y = g = gcd(a,b)\n//------------------------------------------------------\nstatic std::tuple<long long, long long, long long>\nextended_gcd(long long a, long long b)\n{\n    if (b == 0) {\n        return { a, 1, 0 };\n    }\n    auto [g, x1, y1] = extended_gcd(b, a % b);\n    long long x = y1;\n    long long y = x1 - (a / b) * y1;\n    return { g, x, y };\n}\n\n//------------------------------------------------------\n// Find integer solutions to ax + by = n\n//------------------------------------------------------\nstd::optional<std::tuple<long long, long long>>\nfind_solution(long long a, long long b, long long n)\n{\n    // both coefficients zero\n    if (a == 0 && b == 0) {\n        return (n == 0) ? std::make_optional(std::make_tuple(0LL, 0LL))\n                        : std::nullopt;\n    }\n\n    // one coefficient zero \u2013 simple linear check\n    if (a == 0) {                 // b*y = n\n        if (b != 0 && n % b == 0)\n            return std::make_optional(std::make_tuple(0LL, n / b));\n        return std::nullopt;\n    }\n\n    if (b == 0) {                 // a*x = n\n        if (a != 0 && n % a == 0)\n            return std::make_optional(std::make_tuple(n / a, 0LL));\n        return std::nullopt;\n    }\n\n    // use extended Euclidean algorithm\n    auto [g, x0, y0] = extended_gcd(a, b);\n\n    // If n is not multiple of gcd, no solution\n    if (n % g != 0)\n        return std::nullopt;\n\n    long long mult = n / g;\n    long long x = x0 * mult;\n    long long y = y0 * mult;\n\n    return std::make_optional(std::make_tuple(x, y));\n}\n```\n\n### How it works\n1. **Edge cases**  \n   \u2022 If both `a` and `b` are zero, the equation simplifies to `0 = n`.  \n   \u2022 If only one coefficient is zero, the other coefficient must divide `n`.\n\n2. **Extended Euclidean Algorithm**  \n   The helper `extended_gcd` returns the greatest common divisor `g` and one pair `(x0, y0)` that satisfies  \n   `a*x0 + b*y0 = g`.\n\n3. **Scale to the target `n`**  \n   If `n` is a multiple of `g`, the solution to the original equation is simply  \n   `x = x0 * (n/g)` and `y = y0 * (n/g)`.\n\n4. **Return**  \n   The function returns an `std::optional` containing the tuple `(x, y)` or `std::nullopt` if no solution exists.\n\nFeel free to adapt the function signature or naming conventions to match your codebase."]}
{"completions": ["Here is a straightforward implementation of the `solve` function that follows the rules you described:\n\n```cpp\nstd::string solve(std::string s) {\n    bool hasLetter = false;\n    for (char c : s) {\n        if (std::isalpha(static_cast<unsigned char>(c)))\n        {\n            hasLetter = true;\n            break;\n        }\n    }\n\n    if (!hasLetter) {\n        std::reverse(s.begin(), s.end());\n        return s;\n    }\n\n    for (char &c : s) {\n        if (std::islower(static_cast<unsigned char>(c))) \n            c = std::toupper(static_cast<unsigned char>(c));\n        else if (std::isupper(static_cast<unsigned char>(c))) \n            c = std::tolower(static_cast<unsigned char>(c));\n    }\n    return s;\n}\n```\n\n**Explanation**\n\n1. **Check for letters**:  \n   We loop through the string once to see if there is at least one alphabetic character. If none are found, we simply reverse the string with `std::reverse` and return it.\n\n2. **Toggle case**:  \n   If the string contains letters, we iterate over the characters again and toggle the case:\n   - `std::tolower` \u2192 `std::toupper` for lower\u2011case letters.\n   - `std::toupper` \u2192 `std::tolower` for upper\u2011case letters.\n\n3. **Return**:  \n   The modified string is returned.\n\n**Test cases**\n\n```cpp\nassert(solve(\"1234\") == \"4321\");\nassert(solve(\"ab\")   == \"AB\");\nassert(solve(\"#a@C\") == \"#A@c\");\n```\n\nAll examples provided in your prompt produce the expected results.", "Here is a minimal, self\u2011contained implementation that follows the specification:\n\n```cpp\n#include <cctype>   // for isalpha, toupper, tolower\n#include <string>\n#include <algorithm> // for reverse\n\n/*\n * If the string contains at least one alphabetic character,\n * toggle the case of each alphabetic character (lower \u2192 upper,\n * upper \u2192 lower) and leave all other characters unchanged.\n *\n * If the string contains no alphabetic character, reverse the whole string.\n */\nstd::string solve(std::string s)\n{\n    // keep track whether we saw at least one letter\n    bool hasLetter = false;\n\n    for (char &c : s)\n    {\n        if (std::isalpha(static_cast<unsigned char>(c))) {\n            hasLetter = true;\n            if (std::isupper(static_cast<unsigned char>(c)))\n                c = static_cast<char>(std::tolower(static_cast<unsigned char>(c)));\n            else\n                c = static_cast<char>(std::toupper(static_cast<unsigned char>(c)));\n        }\n    }\n\n    if (!hasLetter)\n        std::reverse(s.begin(), s.end());\n\n    return s;\n}\n```\n\n**Explanation**\n\n1. We scan the string once, toggling the case of each alphabetic character.  \n2. `std::isalpha`, `std::isupper`, `std::tolower`, `std::toupper` are used for correctness with locale\u2011independent behavior (casting through `unsigned char`).  \n3. If no alphabetic character was found (`hasLetter` remains `false`), we reverse the whole string.  \n\nThe function is `O(n)` time, `O(1)` auxiliary space (in\u2011place editing).", "Below is a minimal implementation that follows the rules described in the problem statement.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring solve(string s)\n{\n    bool hasLetter = false;\n    for (char c : s) {\n        if (isalpha(static_cast<unsigned char>(c))) {\n            hasLetter = true;\n            break;\n        }\n    }\n\n    if (!hasLetter) {                 // case 1 \u2013 no alphabetic letters\n        reverse(s.begin(), s.end());   // reverse the whole string\n        return s;\n    }\n\n    // case 2 \u2013 contains at least one letter\n    for (char &c : s) {\n        if (islower(static_cast<unsigned char>(c)))\n            c = toupper(static_cast<unsigned char>(c));\n        else if (isupper(static_cast<unsigned char>(c)))\n            c = tolower(static_cast<unsigned char>(c));\n        // other characters stay untouched\n    }\n    return s;\n}\n```\n\n**Explanation**\n\n1. First, we detect whether the input string contains any alphabetic characters.  \n2. If no letters are found, we simply reverse the entire string.  \n3. If letters are present, we iterate over each character and flip its case:\n   * `islower` \u2192 `toupper`\n   * `isupper` \u2192 `tolower`\n   * other symbols remain unchanged.\n\nThe function then returns the processed string."]}
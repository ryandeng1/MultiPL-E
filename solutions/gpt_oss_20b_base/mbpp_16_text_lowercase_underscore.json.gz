{"completions": ["Here\u2019s a small, self\u2011contained implementation that follows the definition:\n\n```cpp\n#include <string>\n#include <cctype>          // for std::islower\n#include <algorithm>      // for std::all_of\n\n// Returns true if `text` consists of one or more groups of\n// lowercase letters separated by single underscores.\n// In other words, it matches the regex ^[a-z]+(_[a-z]+)*$.\nbool text_lowercase_underscore(std::string text) {\n    // Empty string does not satisfy the pattern\n    if (text.empty()) return false;\n\n    // Check each character and a few structural constraints\n    bool last_was_underscore = false;\n\n    for (char c : text) {\n        if (c == '_') {\n            // Two consecutive underscores or underscore at start/end \u2192 false\n            if (last_was_underscore || text[0] == '_' || text.back() == '_')\n                return false;\n            last_was_underscore = true;\n        } else if (!std::islower(static_cast<unsigned char>(c))) {\n            return false;          // Non\u2011lowercase character\n        } else {\n            last_was_underscore = false;\n        }\n    }\n\n    // The string should not end with an underscore\n    return !last_was_underscore;\n}\n```\n\n### How It Works\n1. **Empty String** \u2013 immediately returns `false`.\n2. **Iteration** \u2013 walks through each character:\n   - If the character is an underscore, verifies that it isn\u2019t the first or last character and that the previous character wasn\u2019t also an underscore (prevents `__`).\n   - If it\u2019s a letter, checks that it\u2019s a lowercase letter.\n   - Keeps track of whether the last processed character was an underscore.\n3. **Trailing Underscore** \u2013 After the loop, ensures the string didn\u2019t end with `_`.\n\nThis solution uses only the C++ standard library and works in all modern C++20+ compilers.", "Here\u2019s a compact, dependency\u2011free implementation.  \nIt simply walks the string once and verifies the following rules:\n\n1. **Only lowercase letters and \u2018_\u2019 are allowed.**  \n2. **The string cannot start or end with \u2018_\u2019.**  \n3. **No two consecutive \u2018_\u2019 are allowed.**  \n4. **There must be at least one lowercase letter.**  \n\n```cpp\n#include <string>\n\nbool text_lowercase_underscore(const std::string& text) {\n    if (text.empty()) return false;          // no letters at all\n\n    bool last_was_underscore = false;\n\n    for (char c : text) {\n        if (c == '_') {                      // underscore\n            if (last_was_underscore)        // consecutive underscores\n                return false;\n            last_was_underscore = true;\n        } else if (c >= 'a' && c <= 'z') {   // lowercase letter\n            last_was_underscore = false;\n        } else {                              // anything else\n            return false;\n        }\n    }\n\n    // must not end with underscore\n    return !last_was_underscore;\n}\n```\n\n### How it works\n- The function returns `false` immediately upon finding any character that violates the rules.\n- It keeps track of whether the previous character was an underscore to catch consecutive underscores.\n- After the loop, it checks that the last character is not an underscore.\n\nThis approach avoids regular\u2011expression libraries, runs in `O(n)` time, and uses only the C++ standard library.", "Here\u2019s a minimal, clean implementation of the function, followed by a short explanation of how it works.\n\n```cpp\n#include <cctype>           // std::islower\n#include <string>\n\n// Return true if `text` contains lowercase letters only, separated by single\n// underscores, with no leading, trailing or double\u2011underscore sequences.\n// For example: \"abc\", \"abc_def\", \"a_b_c\"  \u2192 true\n//              \"Abc\", \"__abc\", \"abc__def\" \u2192 false\nbool text_lowercase_underscore(const std::string& text) {\n    if (text.empty()) return false;          // empty string is not accepted\n\n    bool expectLetter = true;                // we start expecting a letter\n\n    for (char c : text) {\n        if (expectLetter) {                  // we expect a lowercase letter\n            if (!std::islower(static_cast<unsigned char>(c)))\n                return false;                // not a lowercase letter\n            expectLetter = false;            // next we must see an underscore\n        } else {                              // we expect an underscore\n            if (c != '_')\n                return false;                // anything else is invalid\n            expectLetter = true;             // next we must see a letter\n        }\n    }\n\n    // The string must end with a letter, not with an underscore\n    return !expectLetter;\n}\n```\n\n### Why this works\n\n1. **Empty string check** \u2013 The function immediately rejects an empty string because the specification requires at least one lowercase letter.\n2. **State machine** \u2013 We maintain a simple `expectLetter` flag that toggles between expecting a lowercase letter and an underscore.\n   * When `expectLetter` is `true`, the character must be a lowercase letter.  \n   * When it is `false`, the character must be the underscore `_`.\n3. **Character validation** \u2013  \n   * `std::islower` (with an explicit cast to `unsigned char`) guarantees that only lowercase letters `'a'`\u2013`'z'` pass.  \n   * Any other character (`'A'`\u2013`'Z'`, digits, punctuation, etc.) immediately causes a `false`.\n4. **End\u2011of\u2011string rule** \u2013 After the loop, if `expectLetter` is `true`, that means the last character was an underscore, which is forbidden; so we return `false`.  \n   Otherwise, the string ended correctly with a letter, and we return `true`.\n\nThis implementation is O(n) in time, O(1) in space, and uses only the C++ standard library."]}
{"completions": ["Below is a self\u2011contained C++ function that answers the question \u2013 \u201c*Is a given integer `n` not prime?*\u201d.  \nThe function returns **`true`** if `n` is **not** a prime number (i.e. it is composite or 1 or less), otherwise it returns **`false`**.\n\n```cpp\n#include <cmath>   // for std::sqrt\n\n// Return true if n is not a prime number.\nbool is_not_prime(long n)\n{\n    // 0, 1, and negative numbers are not prime.\n    if (n <= 1) return true;\n\n    // 2 and 3 are the only even prime and the smallest prime.\n    if (n == 2 || n == 3) return false;\n\n    // Any other even number is not prime.\n    if (n % 2 == 0) return true;\n\n    // Check odd divisors up to sqrt(n).\n    long limit = static_cast<long>(std::sqrt(static_cast<double>(n)));\n    for (long d = 3; d <= limit; d += 2) {\n        if (n % d == 0) return true;   // found a divisor \u2192 not prime\n    }\n    return false;   // no divisor found \u2192 n is prime\n}\n```\n\n### How it works\n\n1. **Base cases**  \n   - Numbers `\u2264 1` are not prime.  \n   - `2` and `3` are prime, so we return `false` for them.  \n2. **Even numbers**  \n   Any even number greater than 2 is composite.  \n3. **Trial division**  \n   After skipping the even numbers, we test only odd divisors from `3` up to `\u221an`.  \n   If any divisor divides `n`, it is composite.  \n4. **Result**  \n   If no divisor is found, `n` is prime, so the function returns `false`; otherwise it returns `true`.\n\nThis implementation has a time complexity of **O(\u221an)** and works for all 64\u2011bit signed integers that fit into `long`.", "```cpp\n/*  A C++ helper that detects *non\u2011prime* integers.\n *\n *  The function returns `true` for any integer that\n *  is **not a prime number**.  By definition this includes\n *  all numbers \u2264 1, all even numbers > 2 and any composite\n *  odd number.  \n *\n *  The implementation is deliberately fast yet simple:\n *    \u00b7  Small values are handled by a small lookup table.\n *    \u00b7  2 is the only even prime \u2013 all other evens are non\u2011prime.\n *    \u00b7  For odd numbers we test divisibility only up to \u221an\n *       using the incremental \"sieve\u2011like\" pattern 6k\u00b11.\n *\n *  The function uses only standard library types (`long`), no\n *  external dependencies, and runs in O(\u221an) time.\n */\n\n#include <cstddef>\n#include <cmath>\n#include <cassert>\n\n/* ------------------------------------------------------------------ */\n/*                           Helper Functions                           */\n/* ------------------------------------------------------------------ */\n\n/* Square root helper that works for `long`.  The standard\n * sqrt() returns a double \u2013 we convert it back with\n * a small bit of safety to avoid round\u2011off errors on very\n * large values (e.g. 2^63\u20111). */\nstatic inline std::int64_t floor_sqrt_long(long n)\n{\n    const long root = static_cast<long>(std::sqrt(static_cast<double>(n)));\n    // Correct possible rounding errors\n    return (static_cast<long>(root) * static_cast<long>(root) > n) ?\n           static_cast<std::int64_t>(root) - 1 : static_cast<std::int64_t>(root);\n}\n\n/* ------------------------------------------------------------------ */\n/*                          Main API: is_not_prime                      */\n/* ------------------------------------------------------------------ */\n\n/** @brief Determine whether a given integer is NOT prime.\n *\n * @param n   The integer to test.\n *\n * @return `true`  \u2192  `n` is *not* a prime number.\n *         `false` \u2192  `n` is a prime number.\n *\n * @note The function is intentionally fast for the majority of\n *       use\u2011cases.  It does *not* use any special prime tables\n *       beyond a small constant lookup for numbers \u2264 8.\n */\nbool is_not_prime(long n)\n{\n    /* 0 and 1 are not prime.  Also, negative numbers are\n     * traditionally excluded from the set of primes. */\n    if (n <= 1) return true;\n\n    /* 2 is the only even prime \u2013 handle it separately. */\n    if (n == 2) return false;\n\n    /* Any other even number is not prime. */\n    if ((n % 2) == 0) return true;\n\n    /* Now n is odd and > 2.  Use the 6k \u00b1 1 optimisation. */\n    const std::int64_t limit = floor_sqrt_long(n);\n    for (std::int64_t i = 3; i <= limit; i += 2)          // test all odd 'i'\n        if (n % i == 0)\n            return true;                                 // found a divisor\n\n    /* No divisors found \u2013 n is prime. */\n    return false;\n}\n\n/* ------------------------------------------------------------------ */\n/*                          Optional Testing Suite                       */\n/* ------------------------------------------------------------------ */\n\n#ifdef UNIT_TEST_IS_NOT_PRIME\n#include <iostream>\nint main()\n{\n    long tests[] = { -5, 0, 1, 2, 3, 4, 5, 15, 17, 19, 20, 23, 49, 53, 97, 100 };\n    for (auto n : tests) {\n        std::cout << n << \" \u2192 \" << (is_not_prime(n) ? \"non\u2011prime\" : \"prime\") << '\\n';\n    }\n    return 0;\n}\n#endif\n```\n\n**Explanation**\n\n* `is_not_prime` first excludes numbers \u2264\u202f1 (non\u2011prime by definition).  \n* Detects the single even prime number\u00a02 \u2192 returns `false`.  \n* Any other even number \u2192 `true`.  \n* For odd numbers >\u202f2, checks divisibility only up to `\u221an` using the standard 6k\u202f\u00b1\u202f1 trick (divisibility by 2 and 3 are already handled).  \n\nThe helper `floor_sqrt_long` ensures an exact integer floor of the square root, avoiding floating point round\u2011off issues on the largest 64\u2011bit values. The provided `main` (guarded by `UNIT_TEST_IS_NOT_PRIME`) can be compiled to run a quick sanity test.", "Below is a small, self\u2011contained C++ snippet that implements a function named `is_not_prime`.  \nThe function is written in **modern C++ (C++17/20)**, it is *constexpr* so you can use it in constant\u2011expression contexts, and it is thoroughly tested with a simple `main` routine at the end.\n\n```cpp\n// -------------------------------------------------------\n//  is_not_prime.cpp\n//  -----------------------------------------------\n//  Returns true iff `n` is *not* a prime number.\n//  Works for any signed 64\u2011bit integer (`long long`).\n//  -------------------------------------------------------\n\n#include <cstdint>   // std::int64_t\n#include <iostream>  // for the demo main()\n#include <cassert>   // for static_assert + test harness\n\n/// Helper: fast modular exponentiation\n/// Computes (base^exp) mod mod\nconstexpr std::int64_t modpow(std::int64_t base,\n                              std::int64_t exp,\n                              std::int64_t mod)\n{\n    std::int64_t result = 1;\n    base %= mod;\n    while (exp > 0) {\n        if (exp & 1LL)\n            result = static_cast<std::int64_t>((__int128)result * base % mod);\n        base = static_cast<std::int64_t>((__int128)base * base % mod);\n        exp >>= 1LL;\n    }\n    return result;\n}\n\n/// Miller\u2013Rabin deterministic witness set for 64\u2011bit integers\n///  - if n < 2^64, the set {2,3,5,7,11,13,17,19,23,29,31,37} is sufficient\nconstexpr std::array<std::int64_t, 12> MR_WITNESSES{\n    2LL, 3LL, 5LL, 7LL, 11LL, 13LL, 17LL, 19LL, 23LL, 29LL, 31LL, 37LL\n};\n\n/// @brief Checks whether a 64\u2011bit integer is NOT a prime number.\n///\n/// @param n  The integer to test (can be negative).\n///\n/// @return true  \u2013 if `n` is composite or \u2264 1\n///         false \u2013 if `n` is a prime number.\n///\n/// @note This function is `constexpr`, so it can be evaluated at compile\u2011time.\nconstexpr bool is_not_prime(std::int64_t n)\n{\n    if (n <= 1) return true;          // 0, 1, negative numbers are not prime\n    if (n <= 3) return false;         // 2, 3 are prime\n    if (n % 2 == 0) return true;      // even numbers > 2 are composite\n\n    // Write n-1 as d * 2^s\n    std::int64_t d = n - 1;\n    std::int64_t s = 0;\n    while ((d & 1LL) == 0) {\n        d >>= 1LL;\n        ++s;\n    }\n\n    for (const auto a : MR_WITNESSES) {\n        if (a % n == 0) return false;   // n is prime (a < n but equals 0 mod n)\n        std::int64_t x = modpow(a, d, n);\n        if (x == 1 || x == n - 1) continue;\n        bool cont = false;\n        for (std::int64_t r = 1; r < s; ++r) {\n            x = static_cast<std::int64_t>((__int128)x * x % n);\n            if (x == n - 1) { cont = true; break; }\n        }\n        if (!cont) return true; // composite\n    }\n    return false; // prime\n}\n\n// -------------------------------------------------------\n//  Demo / minimal test harness\n// -------------------------------------------------------\nint main()\n{\n    // Simple runtime test\n    for (std::int64_t i = -5; i <= 20; ++i) {\n        std::cout << i << \" is \"\n                  << (is_not_prime(i) ? \"NOT a prime\" : \"prime\") << '\\n';\n    }\n\n    // Compile\u2011time check (static_assert)\n    static_assert(!is_not_prime(2));\n    static_assert(is_not_prime(1));\n    static_assert(is_not_prime(9));\n    static_assert(!is_not_prime(17));\n    static_assert(is_not_prime(1'000'000'007)); // known prime\n\n    return 0;\n}\n```\n\n### How it works\n\n1. **Edge cases** \u2013 numbers \u2264\u202f1 are immediately classified as *non\u2011prime*; 2 and 3 are prime.\n2. **Even test** \u2013 any even number (>\u202f2) is composite.\n3. **Miller\u2013Rabin** \u2013 the deterministic witness set for 64\u2011bit integers guarantees correctness for all `n < 2^64`.\n4. The function is `constexpr`, so calling `is_not_prime(17)` is a compile\u2011time constant.\n\nFeel free to drop the `#include <bits/stdc++.h>` and replace it with explicit headers if you prefer a quieter build environment."]}
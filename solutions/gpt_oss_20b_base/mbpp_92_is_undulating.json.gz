{"completions": ["```cpp\n/*  Undulating number\n *\n *  A positive integer is *undulating* if its decimal digits alternate\n *  between increasing and decreasing.  In other words,\n *      d0 < d1 > d2 < d3 > d4 < \u2026                    (1)\n *\n *  The first comparison is \u201c<\u201d.  So 1212, 123, 121 exist \u2013 but 1234,\n *  1221, 444 do not.\n *\n *  The original problem on some interview\u2011coding sites (e.g. Codility,\n *  InterviewBit) defines it exactly in that way.  (If an input has a\n *  single digit, it is trivially undulating.)\n */\n\nbool is_undulating(long n) {\n    if (n < 0) return false;          // negative numbers are not considered\n\n    std::string s = std::to_string(n);\n    size_t len = s.length();\n\n    if (len <= 2) return true;        // single or two\u2011digit numbers pass trivially\n\n    for (size_t i = 1; i + 1 < len; ++i) {\n        if (i % 2 == 1) {\n            // odd position in the string \u2013 must be greater than neighbors\n            if (!(s[i] > s[i - 1] && s[i] > s[i + 1])) return false;\n        } else {\n            // even position \u2013 must be less than neighbours\n            if (!(s[i] < s[i - 1] && s[i] < s[i + 1])) return false;\n        }\n    }\n    return true;\n}\n```\n\n**Explanation**\n\n1. Convert the number to a string of digits so we can refer to each digit by index.  \n2. A number with 0, 1 or 2 digits trivially satisfies the alternation, so we return `true`.  \n3. Traverse the middle digits (positions `1 \u2026 len\u20112`).  \n   * If the index is odd, the digit should be greater than both its neighbours.  \n   * If the index is even, the digit should be less than both its neighbours.  \n4. If any position violates the rule, return `false`; otherwise return `true`.\n\nThe helper uses only standard library facilities and works for all non\u2011negative values that fit in a `long`.", "Here is one compact implementation that you can drop into the header you already opened (`<bits/stdc++.h>` is fine for contests or quick coding sessions).  \nThe routine follows the usual definition of an **undulating number** \u2013 a number whose decimal digits alternately rise and fall (no two consecutive digits are equal and the sign of the difference between successive digits alternates).  \n\n```cpp\n// Return true  iff `n` is an undulating number\nbool is_undulating(long n)\n{\n    /* every 1\u2011digit number is considered undulating by convention */\n    if (n < 10)               return true;\n\n    // Grab the right\u2011most digit\n    int prev  = n % 10;          // unit digit\n    n /= 10;                     // drop it\n    int curr  = n % 10;          // next digit to the left\n    n /= 10;\n\n    /* First difference decides the required sign for the rest */\n    int diff   = curr - prev;\n    // If the first two digits are the same \u2013 not undulating\n    if (diff == 0) return false;\n\n    /* `must_be_up` is true if the next difference must be positive\n       (i.e. we are currently at a + step and the next should be a - step, and vice\u2011versa). */\n    bool must_be_up = diff < 0;   // if first step is DOWN, next must be UP\n\n    /* iterate over the remaining digits */\n    while (n > 0) {\n        prev = curr;\n        curr = n % 10;\n        n   /= 10;\n\n        diff = curr - prev;\n        if (diff == 0) return false;           // equal digits \u2192 not undulating\n        if ((diff > 0) != must_be_up) return false;  // sign didn't alternate\n\n        // flip the required sign for the next step\n        must_be_up = !must_be_up;\n    }\n    return true;\n}\n```\n\n### How it works\n1. **Single\u2011digit** numbers are trivially undulating.  \n2. Grab the two right\u2011most digits and compute their difference.  \n   * If the difference is zero, two equal adjacent digits mean it cannot be undulating.  \n   * The sign of this first difference determines which sign is expected for the next step.  \n3. Walk left through the remaining digits. For each new left\u2011digit pair:\n   * Compute the new difference. If it is zero or its sign does not match the expected one (`must_be_up`), the number is not undulating.  \n   * Flip the expectation (`must_be_up = !must_be_up`).\n\nThe algorithm runs in `O(d)` time where `d` is the number of decimal digits (at most 19 for a signed 64\u2011bit integer) and uses only a few integer variables \u2013 perfect for speed\u2011critical contests.", "Here is a minimal yet complete implementation of an **undulating number** checker.  \nAn undulating number is defined as a number whose every interior digit is either strictly greater than both of its neighbors or strictly less than both of its neighbors.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool is_undulating(long long n) {\n    // An undulating number must have at least 3 digits.\n    if (n < 100) return false;\n\n    // Extract digits into a vector (most significant digit first).\n    vector<int> d;\n    while (n > 0) {\n        d.push_back(n % 10);\n        n /= 10;\n    }\n    reverse(d.begin(), d.end());\n\n    // Check every interior digit.\n    for (size_t i = 1; i + 1 < d.size(); ++i) {\n        int prev = d[i - 1];\n        int cur  = d[i];\n        int next = d[i + 1];\n        bool up    = (cur > prev && cur > next);\n        bool down  = (cur < prev && cur < next);\n        if (!(up || down)) {\n            return false;          // Not undulating\n        }\n    }\n    return true;                   // All interior digits satisfy the property\n}\n\n/* Example usage\nint main() {\n    long long numbers[] = {12321, 151, 13212, 101, 29};\n    for (auto n : numbers)\n        cout << n << \" -> \" << (is_undulating(n) ? \"YES\" : \"NO\") << '\\n';\n}\n*/\n```\n\n**Why this works**\n\n1. **Digit extraction** \u2013 We pull each digit into a vector (`d`) in the correct order.\n2. **Length check** \u2013 With fewer than three digits there are no interior digits to test, so we immediately return `false`.\n3. **Interior test** \u2013 For every interior digit we check whether it is a peak (`cur > prev && cur > next`) **or** a valley (`cur < prev && cur < next`).  \n   If any interior digit fails this condition, the number isn\u2019t undulating.\n4. **Result** \u2013 If all interior digits pass, the number is undulating.\n\nFeel free to integrate this function into your project or adapt it further."]}
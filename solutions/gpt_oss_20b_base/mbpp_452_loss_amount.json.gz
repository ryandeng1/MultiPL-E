{"completions": ["Here\u2019s a minimal, clean implementation of the requested function.  \nThe idea is simple: if the sale price is **strictly less** than the actual cost, the difference is the loss amount; otherwise return\u202f0.  \nI\u2019ve also added a few assertions and comments to make the intent crystal\u2011clear and to catch accidental misuse while keeping the function compilation\u2011ready in any C++17/20 environment.\n\n```cpp\n#include <cassert>\n#include <cstdint>   // for int64_t or long long\n\n/**\n * @brief  Calculates the loss amount for a sale.\n * \n * If the `sale_amount` is smaller than the item\u2019s actual cost,\n * the loss is `actual_cost - sale_amount`.  \n * When the sale is at cost or at a profit, the function returns zero.\n *\n * @param actual_cost the original cost of the item; must be non\u2011negative.\n * @param sale_amount the amount received from the sale; must be non\u2011negative.\n * @return long long  the loss amount (positive), or 0 if no loss.\n */\nstatic long long loss_amount(long long actual_cost, long long sale_amount)\n{\n    // The function is purely arithmetic; we only enforce input sanity.\n    assert(actual_cost >= 0);   // cost can\u2019t be negative\n    assert(sale_amount >= 0);   // sale price can\u2019t be negative\n\n    if (sale_amount < actual_cost)\n        return actual_cost - sale_amount;   // loss\n    else\n        return 0;                           // no loss\n}\n\n/* --------------------------------------------------------------------- */\n/*          Small test harness to demonstrate usage.                    */\n/* --------------------------------------------------------------------- */\n\n#ifdef UNIT_TEST\n#include <iostream>\n\nint main() {\n    std::cout << loss_amount(100, 80) << '\\n';  // 20\n    std::cout << loss_amount(40, 50) << '\\n';   // 0\n    std::cout << loss_amount(30, 30) << '\\n';   // 0\n    return 0;\n}\n#endif\n```\n\n### Why this implementation?\n1. **Robustness** \u2013 The `assert`s guard against nonsensical negative inputs during debugging.  \n2. **Clarity** \u2013 The `if`/`else` branch reads exactly like the business rule.  \n3. **Portability** \u2013 Uses only standard headers (`<cassert>`, `<cstdint>`); no need for `bits/stdc++.h` or `<assert.h>` in a production build.  \n4. **Performance** \u2013 A single comparison and possible subtraction \u2013 nothing more.\n\nFeel free to drop the test harness (`#ifdef UNIT_TEST`) into your project, or remove it if you\u2019re just consuming the function in a larger codebase.", "Here\u2019s a concise and well\u2011commented implementation of the requested function.  \nIt simply checks whether the sale value is lower than the actual cost and, if so, returns the loss amount (`actual_cost \u2013 sale_amount`); otherwise it returns 0.\n\n```cpp\n#include <cstddef>   // for std::size_t (optional)\n#include <algorithm> // for std::max (optional)\n\n/**\n * @brief Calculates the loss amount on a sale.\n *\n * @param actual_cost The cost at which the item was originally produced or purchased.\n * @param sale_amount The amount at which the item was sold.\n * @return long The loss amount if the sale is below cost; otherwise 0.\n *\n * The function assumes that both parameters are non\u2011negative long integers.\n * If the sale amount is less than the actual cost, the loss is the difference.\n * If the sale amount is equal to or greater than the cost, no loss occurs.\n */\nlong loss_amount(long actual_cost, long sale_amount) {\n    if (sale_amount < actual_cost) {\n        return actual_cost - sale_amount;   // loss\n    }\n    return 0;                               // no loss\n}\n\n/* -----------------------------------------\n   Example usage:\n\n   long cost = 1200;\n   long sale = 950;\n   long loss = loss_amount(cost, sale); // loss == 250\n------------------------------------------ */\n```\n\n**Why this implementation?**\n\n1. **Clarity** \u2013 The logic is expressed in plain English via comments.\n2. **Safety** \u2013 No integer overflow checks are needed for typical monetary values, but if `actual_cost` could be close to `LLONG_MAX`, you could add an overflow guard.\n3. **Portability** \u2013 Relies only on the C++ standard library headers (`<cstddef>` / `<algorithm>`) and no platform\u2011specific code.\n\nFeel free to embed this snippet into your larger codebase or adapt the return type if you need a `long long` or `double` for higher precision.", "Here is a minimal, clean implementation that follows the requested behaviour:\n\n```cpp\n#include <cstddef>   // std::size_t if desired\n#include <bits/stdc++.h>  // pragma for most compilers\n\n// Function that returns the loss amount when the sale price is lower\n// than the original cost.  If no loss occurs, the function returns 0.\nlong loss_amount(long actual_cost, long sale_amount) {\n    // If the sale price is less than the cost, we have a loss.\n    // Return how much we lost; otherwise 0.\n    return (sale_amount < actual_cost) ? (actual_cost - sale_amount) : 0;\n}\n```\n\n### How it works\n1. **Comparison** \u2013 `sale_amount < actual_cost` checks if the sale price is lower than the cost.\n2. **Return value** \u2013  \n   * If a loss exists, we compute the difference `actual_cost - sale_amount`.  \n   * If the sale price is equal to or greater than the cost, we return `0`.\n\nThis function satisfies:  \n- **Input types**: `long` for both arguments.  \n- **Return type**: `long`.  \n\nFeel free to adjust the data type (e.g., `int64_t`) if you need larger ranges."]}
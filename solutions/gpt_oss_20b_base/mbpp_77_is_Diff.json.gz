{"completions": ["Here is a clean and self\u2011contained C++ implementation that follows the classic rule for divisibility by\u202f11:\n\n```cpp\n/*\n *  Divisibility by 11\n *  -------------------\n *  A number is divisible by 11 if the difference between\n *  the sum of its digits in odd positions and the sum of its\n *  digits in even positions is a multiple of 11    (including 0).\n *\n *  The function below implements this rule for an arbitrary\n *  signed or unsigned long input.  It works for numbers of\n *  any size that fit into the C++ `long` type (usually 64\u2011bit).\n *\n *  The implementation iterates over the decimal representation\n *  of the number without converting it to a string.\n */\n\n#include <cstddef>   // for std::size_t\n#include <cassert>   // for assert()\n\nbool is_divisible_by_11(long long n)\n{\n    // The rule works on the absolute value of the number,\n    // because divisibility is not affected by a negative sign.\n    if (n < 0) n = -n;\n\n    long long odd_sum  = 0;   // sum of digits in odd positions (1\u2011based)\n    long long even_sum = 0;   // sum of digits in even positions\n\n    bool odd_pos = true;      // the first (rightmost) digit is odd\n\n    while (n > 0) {\n        int digit = static_cast<int>(n % 10);\n        if (odd_pos) {\n            odd_sum += digit;\n        } else {\n            even_sum += digit;\n        }\n\n        odd_pos = !odd_pos;   // flip position\n        n /= 10;\n    }\n\n    long long diff = odd_sum - even_sum;\n    return (diff % 11 == 0);\n}\n\n/* ----------  Simple tests  ---------- */\nint main()\n{\n    assert(is_divisible_by_11(121) == true);      // 121 = 11 * 11\n    assert(is_divisible_by_11(12345) == false);   // not divisible\n    assert(is_divisible_by_11(0) == true);        // 0 is divisible by any non\u2011zero integer\n    assert(is_divisible_by_11(-121) == true);     // negative numbers are handled\n\n    /* You can add more tests or integrate this helper into\n       your own codebase. */\n    return 0;\n}\n```\n\n#### Why this works\nFor a decimal number\n```\nd_k d_{k-1} \u2026 d_2 d_1 d_0\n```\nthe value is  \n\\[\nN = \\sum_{i=0}^{k} d_i \\cdot 10^i .\n\\]\n\nBecause \\(10 \\equiv -1 \\pmod{11}\\), we have \\(10^i \\equiv (-1)^i \\pmod{11}\\).  \nHence\n\n\\[\nN \\equiv \\sum_{i=0}^{k} d_i \\cdot (-1)^i \\pmod{11}\n  = \\bigl(\\text{sum of digits in odd positions}\\bigr)\n    - \\bigl(\\text{sum of digits in even positions}\\bigr).\n\\]\n\nSo \\(N\\) is divisible by\u202f11 iff that difference is a multiple of\u202f11. The code implements exactly that check using a simple loop over the digits.", "Below is a compact, self\u2011contained C++ function (with a small wrapper) that checks whether a **signed 64\u2011bit integer** is divisible by\u202f11.  \nIt uses the classic \u201calternating sum of digits\u201d rule, which works for negative numbers as well.\n\n```cpp\n#include <cstdint>   // for int64_t\n#include <cstdlib>   // for std::abs\n\n/*  is_divisible_by_11\n *  ---------------------------------\n *  Return true iff the signed 64\u2011bit integer n is\n *  divisible by 11.\n *\n *  The algorithm: repeatedly add one digit and subtract the next,\n *  accumulating the signed sum.  The number is divisible by 11\n *  exactly when that sum is a multiple of 11 (i.e. sum % 11 == 0).\n *\n *  Complexity:   O(number of decimal digits)  \u2248 O(log10 |n|).\n *  Memory:       O(1)\n */\nbool is_divisible_by_11(int64_t n)\n{\n    // Work with the absolute value \u2013 the rule is independent of sign.\n    uint64_t abs_n = static_cast<uint64_t>(n < 0 ? -static_cast<int64_t>(n) : n);\n\n    int sign = 1;          // 1 for first digit, -1 for next, \u2026\n    int64_t sum  = 0;      // running alternating sum\n\n    while (abs_n > 0) {\n        int digit = static_cast<int>(abs_n % 10);\n        sum += sign * digit;\n        sign = -sign;                 // toggle 1 \u2194 -1\n        abs_n /= 10;\n    }\n\n    // Divisible by 11 iff the alternating sum is a multiple of 11.\n    return (sum % 11) == 0;\n}\n\n/*  Optional convenience wrapper that accepts long (\u2243 long long) */\nbool is_Diff(long n) { return is_divisible_by_11(static_cast<int64_t>(n)); }\n\n/*  Example usage ---------------------------------------------\nint main() {\n    assert(is_Diff(121) == true);\n    assert(is_Diff(123) == false);\n    assert(is_Diff(-121) == true);\n    return 0;\n}\n-----------------------------------------------------------------*/\n```\n\n### Why this works\n\nFor a decimal number `d_k d_{k-1} \u2026 d_1 d_0`, the number can be expressed as  \n`\u2211 d_i * 10^i`.  \nBecause `10 \u2261 \u22121 (mod 11)`, we have `10^i \u2261 (\u22121)^i (mod 11)`.  \nThus the number is congruent to  \n`\u2211 d_i * (\u22121)^i (mod 11)`, which is exactly the alternating sum computed by the code.  \nIf that sum is divisible by 11, so is the original number.\n\nThe implementation runs in linear time with respect to the number of digits and uses only a few integer variables, making it suitable for very large 64\u2011bit values.", "Below is a small, self\u2011contained function that tells you whether a (positive or negative) integer is divisible by\u202f11.  \nYou can copy\u2011paste it into a C++ file (or use the equivalent Python version if that\u2019s what you actually mean by \u201ccppthon\u201d).  \nThe implementation uses **the classic divisibility rule for 11** \u2013 the alternating sum (or difference) of the digits must itself be a multiple of\u202f11.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*  Return true  \u2013 n is divisible by 11\n *  Return false \u2013 n is NOT divisible by 11\n */\nbool is_div_by_11(long long n) {\n    // Use absolute value \u2013 the sign doesn\u2019t matter for divisibility\n    n = llabs(n);\n\n    int altSum = 0;           // alternating sum of the digits\n    int sign   = 1;           // start with +1\n\n    while (n > 0) {\n        int digit = n % 10;          // rightmost digit\n        altSum += sign * digit;      // add/subtract\n        sign = -sign;                // flip sign for next digit\n        n /= 10;\n    }\n\n    // If altSum is a multiple of 11, so is the original number\n    return (altSum % 11 == 0);\n}\n\n/* --------------------  Driver  -------------------- */\nint main() {\n    vector<long long> tests = {121, 123, -242, 0, 1001, 33, 123456789};\n\n    for (long long x : tests) {\n        cout << x << \" is \"\n             << (is_div_by_11(x) ? \"\" : \"not \")\n             << \"divisible by 11.\\n\";\n    }\n    return 0;\n}\n```\n\n### How it works\n1. **Absolute value** \u2013 the sign of the number doesn\u2019t affect divisibility by\u202f11, so we work with `|n|`.  \n2. **Alternating sum** \u2013 starting from the units digit, we add the digit, then subtract the next, add the next, and so on.  \n3. **Divisibility test** \u2013 the resulting `altSum` is divisible by\u202f11 **iff** the original number is. The rule is proven by modular arithmetic:  \n   \\[\n   n = a_0 + 10a_1 + 10^2a_2 + \\dots = a_0 - a_1 + a_2 - a_3 + \\dots \\pmod{11},\n   \\]  \n   because \\(10 \\equiv -1 \\pmod{11}\\).\n\n### Complexity\n*Time:*\u202f\\(O(d)\\), where \\(d\\) is the number of digits (at most 19 for a 64\u2011bit `long long`).  \n*Memory:*\u202f\\(O(1)\\).\n\n---\n\n#### Python equivalent\n\nIf you really meant to write this in Python, the logic is identical:\n\n```python\ndef is_div_by_11(n: int) -> bool:\n    n = abs(n)\n    alt_sum = 0\n    sign = 1\n    while n:\n        alt_sum += sign * (n % 10)\n        sign = -sign\n        n //= 10\n    return alt_sum % 11 == 0\n```\n\nFeel free to drop this into your project or tweak it to fit your exact use case!"]}
{"completions": ["Below is a simple, self\u2011contained implementation of `extract_string`.  \nIt takes the first **l** characters from every string in the input vector and returns the resulting vector.  \n(If a string is shorter than **l** we simply return the whole string \u2013 this is the most natural behaviour; you can change it if you need truncation only when the string is longer.)\n\n```cpp\n#include <vector>\n#include <string>\n#include <cassert>\n\n/**\n * @brief  Take the first `l` characters of every string in `str`.\n *\n * @param str   Input vector of strings.\n * @param l     The number of characters to keep from each string.\n * @return      A vector containing the extracted substrings.\n */\nstd::vector<std::string> extract_string(const std::vector<std::string>& str, long l)\n{\n    std::vector<std::string> result;\n    result.reserve(str.size());          // allocate once for speed\n\n    for (const auto &s : str)\n    {\n        if (l <= 0)\n        {\n            // If l is non\u2011positive, return the empty string.\n            result.emplace_back();\n        }\n        else\n        {\n            // Keep at most l characters; substr will clip automatically\n            // if s.length() < l.\n            result.emplace_back(s.substr(0, static_cast<std::size_t>(l)));\n        }\n    }\n\n    return result;\n}\n```\n\n### Usage example\n\n```cpp\nint main()\n{\n    std::vector<std::string> vec = {\"hello\", \"world\", \"c++\", \"short\"};\n    long l = 3;\n    auto r = extract_string(vec, l);\n    // r == {\"hel\", \"wor\", \"c++\", \"sho\"}\n}\n```\n\nFeel free to tweak the behaviour (e.g., throw an exception when `l` is too big, silently ignore such strings, etc.) to match the exact requirements of your project.", "Below is a **minimal, self\u2011contained implementation** of `extract_string` that performs the two most common \u201csize\u2011based\u201d string extractions you\u2019re likely to need:\n\n1. **Return every string that is *exactly* of length `l`.**  \n   (`\"filter\"` variant)\n\n2. **Return the *first* `l` characters of each string in the input vector**.  \n   (`\"truncate\u2011to\u2011length\"` variant)\n\nYou can keep either both behaviours (guarded by a flag) or pick the one that matches your requirements.  \nThe code uses nothing beyond the standard library, so it compiles with any compiler that supports C++11 or newer.  \n\n```cpp\n#include <vector>\n#include <string>\n\n/* ------------------------------------------------------------------\n   extract_string\n   ------------------------------------------------------------------\n   Parameters:\n     - str : input vector of strings\n     - l   : target length\n     - keep_exactly (optional flag): \n           * true  -> keep only strings whose length is exactly l\n           * false -> keep the first l characters of each string\n           Default is true, which is the most common \u201csize filter\u201d use\u2011case.\n   Returns:\n     A new vector of strings that matches the requested behaviour.\n   ------------------------------------------------------------------ */\nstd::vector<std::string>\nextract_string(std::vector<std::string> const& str, long l,\n               bool keep_exactly = true)\n{\n    std::vector<std::string> result;\n    result.reserve(str.size());          // O(1) pre\u2011allocation\n\n    if (keep_exactly) {\n        for (const auto& s : str) {\n            if (static_cast<long>(s.size()) == l) {\n                result.push_back(s);\n            }\n        }\n    } else {\n        for (const auto& s : str) {\n            // If the string is shorter than l, keep it unchanged.\n            if (static_cast<long>(s.size()) <= l) {\n                result.push_back(s);\n            } else {\n                // take only the first `l` characters\n                result.push_back(s.substr(0, static_cast<std::size_t>(l)));\n            }\n        }\n    }\n\n    return result;\n}\n```\n\n### How to use it\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<std::string> vec{\"apple\", \"banana\", \"pear\", \"pineapple\", \"fig\"};\n    long l = 5;\n\n    // 1. Keep only strings with exactly 5 characters\n    auto exact = extract_string(vec, l);          // default keep_exactly = true\n    for (const auto& s : exact) std::cout << s << ' ';   // outputs: apple\n    std::cout << '\\n';\n\n    // 2. Truncate each string to length 5\n    auto truncated = extract_string(vec, l, false);\n    for (const auto& s : truncated)\n        std::cout << s << ' ';                     // outputs: apple banan pear pinea fig\n    std::cout << '\\n';\n}\n```\n\n### Remarks\n\n* The function is **const\u2011correct** except for the output vector \u2013 which we\n  naturally need to modify \u2013 so the input vector is passed by `const &`\n  reference.\n* `reserve` is called to avoid repeated reallocations when the result\n  size is large.\n* The flag `keep_exactly` makes the function flexible while keeping\n  the code simple. If your real requirement is exactly one of the\n  two behaviours, you can remove the flag and keep only the relevant\n  branch.", "Below is a **complete, minimal, and self\u2011contained implementation** of the requested function.  \nIt follows the most common C++ idioms (C++17/20 can be used, but the code is compatible with C++11 as well).\n\n```cpp\n#include <vector>\n#include <string>\n#include <algorithm>      // for std::transform, std::min\n#include <cstddef>        // for std::size_t\n\n/**\n * @brief  Extract the first `l` characters from each string in `str`.\n *\n * @param str  Vector of strings from which the prefixes are taken.\n * @param l    Desired length of each extracted substring.\n * @return     A new vector containing the extracted substrings.\n *\n * Notes:\n *  - If a string in `str` is shorter than `l`, the whole string is returned.\n *  - If `l` is zero or negative, an empty string is returned for every element.\n *  - The function does not modify the input vector.\n */\nstd::vector<std::string> extract_string(const std::vector<std::string>& str, std::ptrdiff_t l)\n{\n    std::vector<std::string> result;\n    result.reserve(str.size());                 // reserve to avoid reallocations\n\n    for (const auto& s : str) {\n        // `static_cast<std::size_t>(l)` keeps the warning level low\n        std::size_t take = static_cast<std::size_t>(\n                (l > 0) ? std::min<std::size_t>(static_cast<std::size_t>(l), s.size())\n                        : 0);                 // l <= 0 \u2192 empty prefix\n\n        result.emplace_back(s.substr(0, take));\n    }\n\n    return result;\n}\n```\n\n### Why this implementation?\n\n| Requirement | How it\u2019s satisfied |\n|-------------|--------------------|\n| **Do not alter the input vector** | The function takes `const std::vector<std::string>&` and never writes to it. |\n| **Support arbitrary vector sizes** | The loop runs over all elements; `reserve` creates enough capacity. |\n| **Handle short strings** | `std::min` ensures we never request more characters than the string holds. |\n| **Zero or negative `l`** | Returns an empty string for each element instead of throwing or underrunning. |\n| **Portable & generic** | Only standard library facilities are used; works with any compiler that supports C++11+. |\n\n### Usage Example\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<std::string> words = {\"C++\", \"is\", \"fun\", \"and\", \"powerful\"};\n    std::vector<std::string> prefixes = extract_string(words, 2);\n\n    for (const auto& p : prefixes)\n        std::cout << '\"' << p << \"\\\" \";\n    // Output: \"C+\" \"is\" \"fu\" \"an\" \"po\"\n}\n```\n\n### Testing & Assertions\n\nIf you like, you can add simple `assert` statements:\n\n```cpp\n#include <cassert>\n\nint main() {\n    std::vector<std::string> test = {\"hello\", \"world\", \"abc\"};\n    auto out = extract_string(test, 3);\n    assert(out.size() == 3);\n    assert(out[0] == \"hel\");\n    assert(out[1] == \"wor\");\n    assert(out[2] == \"abc\");   // string shorter than 3 \u2192 whole string\n}\n```\n\nThat\u2019s all you need! Feel free to tweak the signature (e.g., add `l` as `size_t` if you never pass negative values) depending on your coding style."]}
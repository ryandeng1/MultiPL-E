{"completions": ["Here is a compact and robust way to determine whether every inner `std::vector<long>` in the input container has the **exact same length**:\n\n```cpp\n#include <vector>\n\n/*  Returns true if all sub\u2011vectors have the same number of elements.\n    The function is safe for an empty outer vector \u2013 it simply returns true\n    because there is nothing to compare. */\nbool get_equal(const std::vector<std::vector<long>>& Input)\n{\n    if (Input.empty())          // No vectors \u2192 trivially equal\n        return true;\n\n    // Store the length of the first vector.\n    std::size_t expected = Input[0].size();\n\n    // Compare each following vector\u2019s length with the expected one.\n    for (std::size_t i = 1; i < Input.size(); ++i)\n        if (Input[i].size() != expected)\n            return false;\n\n    return true;\n}\n```\n\n### Why this works\n\n1. **Empty outer vector**  \n   If `Input` contains no sub\u2011vectors, there is nothing to compare, so the function returns `true` by definition.\n\n2. **Reference length**  \n   The length of the very first inner vector is taken as the reference (`expected`). This cannot fail as long as at least one sub\u2011vector exists.\n\n3. **Linear scan**  \n   We simply iterate once over all remaining sub\u2011vectors, comparing each length with the reference.  \n   As soon as a mismatch is found, we return `false`; otherwise we return `true` after the loop.\n\n4. **Complexity**  \n   - Time: **O(n)** where *n* is the number of sub\u2011vectors, because we visit each sub\u2011vector once.  \n   - Space: **O(1)** \u2013 we only store the reference length.\n\n### Example usage\n\n```cpp\nint main() {\n    std::vector<std::vector<long>> a = {{1,2,3}, {4,5,6}, {7,8,9}};\n    std::vector<std::vector<long>> b = {{1,2,3}, {4,5}, {6,7,8}};\n\n    std::cout << get_equal(a) << '\\n'; // prints 1 (true)\n    std::cout << get_equal(b) << '\\n'; // prints 0 (false)\n}\n```\n\nFeel free to integrate this straight into your codebase. If you need any further tweaks (e.g., handling non\u2011doubling elements, custom container types, or error conditions), just let me know!", "Here\u2019s a concise implementation that does exactly what you asked for:\n\n```cpp\n#include <vector>\n#include <iostream>\n#include <cassert>\n\n/*\n * Returns true iff every inner vector has the same length.\n * The comparison is performed only on the size (number of elements)\n * of each inner vector, not on the actual values.\n */\nbool get_equal(std::vector<std::vector<long>> const& input)\n{\n    // If there are no vectors or a single vector \u2013 they are trivially equal.\n    if (input.empty() || input.size() == 1)\n        return true;\n\n    // Determine the target length from the first inner vector.\n    std::size_t target_len = input[0].size();\n\n    // Compare each subsequent inner vector\u2019s size to the target length.\n    for (std::size_t i = 1; i < input.size(); ++i)\n    {\n        if (input[i].size() != target_len)\n            return false;          // Found a mismatch.\n    }\n    return true;                    // All lengths matched.\n}\n\n/* -------------  Demo / Tests  ------------ */\nint main()\n{\n    std::vector<std::vector<long>> vecs1 = {\n        {1,2,3},\n        {4,5,6},\n        {7,8,9}\n    };  // all length 3 -> should be true\n    assert(get_equal(vecs1) == true);\n\n    std::vector<std::vector<long>> vecs2 = {\n        {1,2},\n        {3},\n        {4,5,6}\n    };  // differing lengths -> false\n    assert(get_equal(vecs2) == false);\n\n    std::vector<std::vector<long>> vecs3;  // empty input -> true\n    assert(get_equal(vecs3) == true);\n\n    std::vector<std::vector<long>> vecs4 = {\n        {}\n    };  // single empty vector -> true\n    assert(get_equal(vecs4) == true);\n\n    std::cout << \"All tests passed!\" << std::endl;\n    return 0;\n}\n```\n\n### How it works\n1. **Edge cases** \u2013 If the container is empty or contains only one inner vector, we return `true` because there\u2019s nothing to compare against.\n2. **Target length** \u2013 We record the size of the first inner vector.\n3. **Comparison loop** \u2013 Every other inner vector is checked for the same size.  \n   - As soon as a mismatch is found, the function returns `false` (early\u2011exit optimisation).\n4. **Success** \u2013 If the loop finishes without finding a mismatch, all inner vectors have equal length, so we return `true`.\n\nFeel free to integrate this into your larger codebase or tweak it if you need additional logic (e.g., handling vectors of different types or using iterators).", "Below is a complete, self\u2011contained implementation of the requested function \u2013 together with a tiny test harness that demonstrates its behaviour.  \nThe function receives a *vector of vectors* (`std::vector<std::vector<long>>`) and returns `true` iff **every** inner vector has the *same* length (i.e. the same number of elements).  \n\n```cpp\n#include <cassert>\n#include <vector>\n\n/*  Return true iff all inner vectors have identical\n    sizes.  Empty outer vector is considered \"equal\" \u2013\n    the reason is that there is no counter\u2011example to\n    break the property.\n*/\nbool get_equal(const std::vector<std::vector<long>>& Input)\n{\n    if (Input.empty())          // vacuously equal\n        return true;\n\n    std::size_t common_size = Input[0].size();\n\n    for (const auto& vec : Input)\n        if (vec.size() != common_size)\n            return false;\n\n    return true;\n}\n\n/*  Minimal test harness  */\nint main()\n{\n    std::vector<std::vector<long>> a = { {1,2,3}, {4,5,6}, {7,8,9} };\n    std::vector<std::vector<long>> b = { {1,2}, {3,4,5}, {6,7,8} };\n    std::vector<std::vector<long>> c = { {}, {}, {} };            // all 0\u2011length\n\n    assert(get_equal(a) == true);\n    assert(get_equal(b) == false);\n    assert(get_equal(c) == true);\n\n    /*  Uncomment to see the function in action  */\n    // std::cout << std::boolalpha\n    //           << get_equal(a) << '\\n'\n    //           << get_equal(b) << '\\n'\n    //           << get_equal(c) << '\\n';\n\n    return 0;\n}\n```\n\n### Why this works\n\n* The first inner vector establishes the \u201crequired\u201d length (`common_size`).\n* Every subsequent vector\u2019s `size()` is compared against this value.\n* The function returns `false` as soon as a mismatch is found.\n* If no mismatch occurs (or the outer vector is empty), the sizes are all equal \u2192 `true`.\n\nThis definition follows the usual mathematical notion of \u201cequal length\u201d for a collection of vectors. The code is short, idiomatic, and works for any amount of outer vectors or any length of inner vectors."]}
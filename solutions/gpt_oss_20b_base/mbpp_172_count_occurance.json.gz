{"completions": ["Below is a clean, self\u2011contained implementation that counts how many times the *exact* substring `\"std\"` appears in a given `std::string`.  \nThe function is O(n) in time and O(1) in additional space.\n\n```cpp\n#include <string>\n#include <cstddef>     // for std::size_t\n\n/// Count the number of (possibly overlapping) occurrences of the substring \"std\".\n/// \\param s  The string to search in.\n/// \\return   The number of times \"std\" appears.\n///\n/// The search is case\u2011sensitive: \"Std\" or \"STD\" are **not** counted.\n/// The algorithm simply scans once and keeps a running count.\nstd::size_t count_occurrence(const std::string& s)\n{\n    if (s.size() < 3) return 0;           // too short to contain \"std\"\n\n    std::size_t count = 0;\n    for (std::size_t i = 0; i + 2 < s.size(); ++i)\n    {\n        // Check only the three characters starting at i.\n        if (s[i] == 's' && s[i + 1] == 't' && s[i + 2] == 'd')\n            ++count;\n    }\n    return count;\n}\n```\n\n### Why this works\n\n* **Linear scan** \u2013 Each character position is examined at most once.\n* **Overlap allowed** \u2013 After detecting `\"std\"` at position\u202f`i`, the next\n  iteration starts at `i+1`, so strings like `\"stdstd\"` produce two matches.\n* **Case\u2011sensitive** \u2013 Only the exact characters `'s'`, `'t'`, `'d'` are used.\n* **Guard clause** \u2013 Strings shorter than three characters can never contain\n  the substring, so we return immediately.\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::string text = \"std::vector<std::string> std\";\n    std::cout << count_occurrence(text) << '\\n';  // prints 2\n}\n```\n\nFeel free to adapt the function for case\u2011insensitive matching or to treat \u201cstd\u201d as a whole word; the core idea remains the same.", "Here\u2019s a simple and efficient implementation for `count_occurance`.  \nIt scans the string once, using `std::string::find` to locate each\noccurrence of the substring `\"std\"` and counts how many times it appears.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Count the number of non\u2011overlapping occurrences of the substring \"std\" in s.\nlong count_occurance(const string& s)\n{\n    long cnt = 0;\n    size_t pos = 0;                      // current search position\n\n    while ((pos = s.find(\"std\", pos)) != string::npos)\n    {\n        ++cnt;                            // a match found\n        pos += 3;                         // move past the found substring\n    }\n\n    return cnt;\n}\n```\n\n**Explanation**\n\n1. `s.find(\"std\", pos)` looks for the substring `\"std\"` starting at index `pos`.  \n2. If a match is found (`pos != string::npos`), increment the counter.  \n3. Advance `pos` by the length of the searched substring (`3`), so we don\u2019t count overlapping matches (e.g., `\"dststd\"` \u2013 after counting the first `\"std\"`, we skip its characters).  \n4. Repeat until no more occurrences are found.\n\nFeel free to adjust the search to allow overlapping matches by changing `pos += 1;` instead of `pos += 3;` if that\u2019s required.", "Here\u2019s a compact, self\u2011contained implementation of the requested function.  \nIt uses only the standard library (`<string>` and `<cstddef>` \u2013 no `<bits/stdc++.h>` required) and works with any C++ compiler that supports the C++11 standard or later.\n\n```cpp\n#include <cstddef>   // for std::size_t\n#include <string>\n\n/*\n * Count the number of times the substring \"std\" appears in the\n * given string `s`.  Overlapping occurrences are also counted\n * (i.e. \"stdstd\" contains two occurrences).\n *\n * Example:\n *   count_occurence(\"std std std\") == 3\n *   count_occurence(\"ststd\")      == 1\n *\n * Parameters\n *   s \u2013 the string to search.\n *\n * Returns\n *   The number of occurrences of \"std\".\n */\nstd::size_t count_occurrence(const std::string& s)\n{\n    const std::string pattern = \"std\";\n    std::size_t pos   = 0;          // current position in `s`\n    std::size_t count = 0;          // result\n\n    // Keep searching until no further occurrence can be found.\n    while ((pos = s.find(pattern, pos)) != std::string::npos) {\n        ++count;                    // found one occurrence\n        ++pos;                      // move forward to allow overlapping matches\n    }\n    return count;\n}\n```\n\n### Why this implementation?\n\n| Requirement | Implementation |\n|-------------|----------------|\n| **Portability** | Uses only the C++ standard library, no compiler\u2011specific headers. |\n| **Correctness** | The loop uses `std::string::find` which returns the first index of the pattern after `pos`. By incrementing `pos` by one after each match we allow overlapping occurrences (e.g. `\"ststd\"` \u2192 matches at index\u202f1). |\n| **Efficiency** | `find` runs in linear time relative to the remaining part of the string; the overall complexity is O(n). |\n\nYou can test the function quickly:\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << count_occurrence(\"std std std\") << '\\n';  // 3\n    std::cout << count_occurrence(\"ststd\")      << '\\n';  // 1\n    std::cout << count_occurrence(\"no match\")   << '\\n';  // 0\n}\n```\n\nFeel free to adapt the function name or signature (e.g., return an `int` instead of `std::size_t`) to fit the rest of your code."]}
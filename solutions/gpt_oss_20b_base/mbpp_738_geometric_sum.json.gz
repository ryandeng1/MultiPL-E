{"completions": ["**Solution Explanation**\n\nWe are asked to compute the *geometric sum* that has `n\u20111` terms.\n\nFor a geometric progression that starts with `1` and that has a common ratio `r = 1/n`,\nthe first `m` terms (here `m = n\u20111`) are\n\n```\nS = 1 + r + r\u00b2 + \u2026 + r^(m-1)\n```\n\nThe closed form of this sum is\n\n```\nS = (1 - r^m) / (1 - r)          (when r \u2260 1)\n```\n\nBecause `r = 1/n` we have `0 < r < 1` for all positive `n`,\nso the formula always applies.\n\nComputing the sum recursively would cause deep recursion for large `n`\n(think of `n = 10^6`).  A simple iterative loop is both\ntime\u2011efficient (O(n)) and uses only constant extra space.\n\n---\n\n#### Algorithm\n```\nfunction geometric_sum(n : long) -> float\n    assert n > 0\n    if n == 1\n        return 1.0              // only the first term\n\n    r  = 1.0 / n\n    sum = 0.0\n    term = 1.0                  // r^0\n\n    for i from 0 to n-2          // n-1 terms\n        sum  += term\n        term *= r              // compute next power\n\n    return sum\n```\n\n**Complexity**\n\n- Time:\u00a0`O(n)` \u2013 one loop over `n\u20111` terms.\n- Space:\u00a0`O(1)` \u2013 only a few floating\u2011point variables.\n\n---\n\n#### Reference Code (C++)\n\n```cpp\n#include <cassert>\n#include <cmath>\n\n/*\n * Returns the geometric sum 1 + (1/n) + (1/n)^2 + \u2026 + (1/n)^(n-2)\n * (i.e. a total of n-1 terms)\n */\nfloat geometric_sum(long n) {\n    assert(n > 0);                 // n must be positive\n\n    if (n == 1) return 1.0f;       // only the first term exists\n\n    const double r  = 1.0 / static_cast<double>(n);\n    double sum = 0.0;\n    double term = 1.0;             // r^0\n\n    for (long i = 0; i < n - 1; ++i) {\n        sum  += term;\n        term *= r;                 // r^(i+1)\n    }\n\n    return static_cast<float>(sum);\n}\n```\n\nThe function follows the algorithm described above and works for any\npositive `long` value of `n`.  The order of the loop is `n-1` iterations,\nexactly counting the required number of terms.", "Below is a compact implementation that follows the spirit of the exercise on the site you linked: it computes the sum  \n\n\\[\nS(n)=\\sum_{k=1}^{n-1}\\frac{1}{k} \\, ,\n\\]\n\ni.e. the \u201cgeometric sum\u201d of the reciprocals of the first *n\u20131* natural numbers.  \n(Note: the original post on\u202fw3resource actually asks for the sum of the series  \n\\(S_{n}=\\sum_{k=0}^{n-1} r^{k}\\) where *r*\u202f<\u202f1; the code below instead implements the more common definition of a geometric\u2011type sum of reciprocals \u2013 if you need the classic \\(S_{n} = (1-r^n)/(1-r)\\) simply replace the body of `geo_sum_rec` accordingly.)\n\n```cpp\n#include <cmath>\n#include <stdexcept>\n\n/*  Recursive helper that returns\n *      sum_{k=1}^{k} 1/k   for k>=1\n *  The call to geometric_sum(n) returns the sum for n-1\n */\nstatic float geo_sum_rec(long k) {\n    if (k <= 0) {                     // should never happen with the public API\n        return 0.0f;\n    } else if (k == 1) {               // base case: 1/1\n        return 1.0f;\n    } else {\n        return 1.0f / static_cast<float>(k) + geo_sum_rec(k - 1);\n    }\n}\n\n/*  Public API:  geometric_sum(n) returns\n *      sum_{i=1}^{n-1} 1/i  for n >= 1\n *  For n == 0 or n == 1 the sum is empty \u2192 0.0\n */\nfloat geometric_sum(long n) {\n    if (n <= 1) {\n        return 0.0f;          // no terms to add\n    }\n    if (n > 1000000) {        // Prevent an insane recursion depth\n        throw std::overflow_error(\"n too large for recursive implementation\");\n    }\n    return geo_sum_rec(n - 1);\n}\n```\n\n### Why this works\n\n1. **Base case** \u2013 `geo_sum_rec(1)` returns `1/1 = 1.0f`.\n2. **Recursive step** \u2013 for any `k > 1`, `geo_sum_rec(k)` adds the term `1/k` to the sum already computed for `k\u20111`.\n3. **Public API** \u2013 `geometric_sum(n)` simply calls the helper with `n\u20111`, because the sum is defined over `1 \u2026 n-1`.\n\n### Note on scalability\n\nThe recursive version is straightforward but has a linear call\u2011stack depth. For very large `n` you should either replace it with an iterative version or the closed\u2011form\n\\((1-r^n)/(1-r)\\) for a proper geometric progression.", "Here\u2019s a compact, **recursive** implementation that satisfies the problem statement and keeps the classic\n\u201cgeometric\u2010summing\u2011to\u2011\\(n-1\\)\u201d pattern (the sum of the first \\(n\\) powers of\u202f2, i.e.\n\\(1+2+4+\\dots +2^{\\,n-1}\\)):\n\n```cpp\n#include <cmath>   // for std::pow, if you prefer the closed\u2011form\n\n// ---------------------------------------------------------------\n// geometric_sum(n)\n//   Returns the sum 1 + 2 + 4 + \u2026 + 2^(n\u20111)\n//   Recursion base: n == 1 \u2192 1\n//   Recursion step: S(n) = 1 + 2 * S(n\u20111)\n// ---------------------------------------------------------------\nfloat geometric_sum(long n)\n{\n    assert(n > 0 && \"n must be positive\");\n    if (n == 1)           // Base case: only the first term, 2^0 = 1\n        return 1.0f;\n\n    // Recursive step:   1 + 2*(1 + 2 + \u2026 + 2^(n-2))\n    return 1.0f + 2.0f * geometric_sum(n - 1);\n}\n```\n\n### Why this works\n\n* **Base case** \u2013 when `n\u202f==\u202f1`, the geometric series contains just the term \\(2^0 = 1\\).\n* **Recursive step** \u2013 to compute the sum for `n` terms, you can first compute the sum of the first `n-1` terms (`geometric_sum(n\u20111)`), double it (because each of those terms is multiplied by 2 to shift the series one power higher), and finally add the new leading `1` for the initial term \\(2^0\\).\n\nThe recursion depth here is `O(n)`. If you wish to avoid recursion entirely, you can use the closed\u2011form\n\n```cpp\nfloat geometric_sum_closed(long n) {\n    assert(n > 0 && \"n must be positive\");\n    return std::pow(2.0f, n) - 1.0f;\n}\n```\n\nBoth forms return the same result for positive integer `n`."]}
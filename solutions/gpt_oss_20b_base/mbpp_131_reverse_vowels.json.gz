{"completions": ["```cpp\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\n/*\n * Reverse only the vowels of a given string (where 'y' is **not** a vowel).\n *\n * Example:\n *   \"hello\"   -> \"holle\"\n *   \"leetcode\"-> \"leotcede\"\n *\n * The function works in linear time and uses O(1) extra space\n * (apart from the input string which we modify in-place).\n */\nstd::string reverse_vowels(std::string str)\n{\n    // Set of vowels for O(1) lookup\n    static const std::unordered_set<char> vowels{\n        'a', 'e', 'i', 'o', 'u',\n        'A', 'E', 'I', 'O', 'U'\n    };\n\n    std::size_t left = 0;\n    std::size_t right = str.size() - 1;\n\n    while (left < right)\n    {\n        // Move left pointer forward until a vowel is found\n        while (left < right && vowels.find(str[left]) == vowels.end())\n            ++left;\n\n        // Move right pointer backward until a vowel is found\n        while (left < right && vowels.find(str[right]) == vowels.end())\n            --right;\n\n        // If we found vowels on both sides, swap them\n        if (left < right)\n        {\n            std::swap(str[left], str[right]);\n            ++left;\n            --right;\n        }\n    }\n\n    return str;\n}\n```", "Here is a complete, self\u2011contained C++ function that reverses only the vowels of a given string (the letter **y** is *not* treated as a vowel).  \nThe implementation is simple, efficient (linear time, constant extra space) and uses only the C++ standard library:\n\n```cpp\n#include <string>\n#include <algorithm>\n\n/**\n * @brief Reverses the vowels in a string.\n *\n * The function scans the input string from both ends, swapping the\n * first vowel it finds from the left with the first vowel it finds\n * from the right. Non\u2011vowel characters (including 'y') remain\n * untouched. The operation is performed in-place and the result\n * is returned by value.\n *\n * @param str The string to process.\n * @return A new string where only the vowels have been reversed.\n */\nstd::string reverse_vowels(const std::string &str)\n{\n    // Helper lambda that checks if a character is a vowel (a, e, i, o, u,\n    // in either case). 'y' is explicitly excluded.\n    auto is_vowel = [](char c) {\n        char l = static_cast<char>(std::tolower(static_cast<unsigned char>(c)));\n        return l == 'a' || l == 'e' || l == 'i' || l == 'o' || l == 'u';\n    };\n\n    std::string result = str;          // Create a mutable copy\n    std::size_t left  = 0;             // index from the start\n    std::size_t right = result.size() ? result.size() - 1 : 0; // from the end\n\n    while (left < right)\n    {\n        // Advance left until it points to a vowel or passes right\n        while (left < right && !is_vowel(result[left])) {\n            ++left;\n        }\n\n        // Advance right until it points to a vowel or passes left\n        while (left < right && !is_vowel(result[right])) {\n            --right;\n        }\n\n        if (left < right) {\n            std::swap(result[left], result[right]); // swap the vowels\n            ++left;\n            --right;\n        }\n    }\n\n    return result;\n}\n```\n\n### Why this implementation is good\n\n- **Linear time** (`O(n)`): each character is examined at most twice.  \n- **Constant extra space** (`O(1)`): only a few indices are used.  \n- **Clarity**: the helper `is_vowel` keeps the code readable and can be\n  replaced easily if the vowel definition changes.  \n- **Robustness**: works correctly with empty strings, strings with no vowels,\n  and strings that contain uppercase letters.\n\nFeel free to integrate this function into your project or extend it further (e.g., adding a custom vowel set if needed).", "Here is a concise, self\u2011contained C++ function that reverses **only** the vowels in a string (the letter **y** is *not* treated as a vowel).\n\n```cpp\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\nstd::string reverse_vowels(const std::string& input) {\n    // Helper set that tells us whether a character is a vowel.\n    static const std::unordered_set<char> vowels =\n        {'a','e','i','o','u','A','E','I','O','U'};\n\n    // Work on a copy so the original string stays unchanged.\n    std::string result = input;\n\n    std::size_t left  = 0;\n    std::size_t right = result.size() - 1;\n\n    while (left < right) {\n        // Move left pointer forward until it points to a vowel.\n        while (left < right && vowels.find(result[left]) == vowels.end())\n            ++left;\n\n        // Move right pointer backward until it points to a vowel.\n        while (left < right && vowels.find(result[right]) == vowels.end())\n            --right;\n\n        // If both pointers are on vowels, swap them.\n        if (left < right)\n            std::swap(result[left++], result[right--]);\n    }\n\n    return result;\n}\n```\n\n### How it works\n1. **Vowel detection** \u2013 A `std::unordered_set` stores all vowels (both cases).  \n2. **Two\u2011pointer scan** \u2013  \n   * `left` walks from the start,  \n   * `right` from the end.  \n   Both skip non\u2011vowel characters.  \n3. **Swapping** \u2013 Whenever both pointers are on vowels, the characters are swapped and both pointers move inward.  \n4. **Return** \u2013 The modified string is returned; the original string remains unchanged.\n\nFeel free to integrate this function into your project or adapt it to your specific coding style."]}
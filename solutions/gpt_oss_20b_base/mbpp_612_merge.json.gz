{"completions": ["Below is a minimal, self\u2011contained C++ implementation that satisfies the requirement.  \nIt accepts a `std::vector<std::vector<std::any>>` where each inner vector contains exactly two elements and returns a pair of vectors: the first one holds all the first elements of the sub\u2011vectors, the second one holds all the second elements.\n\n```cpp\n#include <any>\n#include <vector>\n#include <cassert>\n\n/*\n * merge(lst)\n *\n * Parameters:\n *   lst \u2013 a vector of vectors, each inner vector containing *exactly* two elements.\n *\n * Returns:\n *   A vector of two vectors:\n *        result[0] \u2013 vector with the first item of every inner vector\n *        result[1] \u2013 vector with the second item of every inner vector\n *\n * Example:\n *   std::vector<std::vector<std::any>> lst = {\n *       { std::string(\"alpha\"), 1 },\n *       { std::string(\"beta\"),  2 }\n *   };\n *\n *   auto out = merge(lst);\n *   // out[0] contains \"alpha\" and \"beta\"\n *   // out[1] contains 1 and 2\n */\nstd::vector<std::vector<std::any>> merge(const std::vector<std::vector<std::any>>& lst)\n{\n    // The input must be non\u2011empty and every inner vector must have exactly two elements.\n    assert(!lst.empty());\n    for (const auto& sub : lst) {\n        assert(sub.size() == 2);\n    }\n\n    std::vector<std::any> first;\n    std::vector<std::any> second;\n\n    first.reserve(lst.size());\n    second.reserve(lst.size());\n\n    for (const auto& sub : lst) {\n        first.push_back(sub[0]);\n        second.push_back(sub[1]);\n    }\n\n    return { std::move(first), std::move(second) };\n}\n```\n\n### How to use it\n\n```cpp\nint main()\n{\n    std::vector<std::vector<std::any>> data{\n        { std::string(\"apple\"),  10 },\n        { std::string(\"banana\"), 20 },\n        { std::string(\"cherry\"), 30 }\n    };\n\n    auto res = merge(data);\n\n    // Print the two result vectors\n    std::cout << \"First column: \";\n    for (const auto& v : res[0]) {\n        std::cout << std::any_cast<std::string>(v) << ' ';\n    }\n    std::cout << '\\n';\n\n    std::cout << \"Second column: \";\n    for (const auto& v : res[1]) {\n        std::cout << std::any_cast<int>(v) << ' ';\n    }\n    std::cout << '\\n';\n}\n```\n\nThe provided implementation is generic (`std::any` allows any type) and keeps the code short and readable. If you know the concrete types you can template the function for better type safety.", "Below is a **modern\u2011C++** implementation of the function you described.  \nIt keeps the type\u2011agnostic nature of the input (`std::any`) but works in a type\u2011safe way thanks to the use of `std::vector<std::any>`.\n\n```cpp\n#include <vector>\n#include <any>\n#include <stdexcept>\n\n/**\n * @brief  Split a vector of 2\u2011element sub\u2011vectors into two separate vectors.\n *\n * @param lst A vector of sub\u2011vectors.  Every element of `lst` must contain\n *            exactly two `std::any` objects.\n *\n * @return A vector containing two vectors:\n *         - The first vector holds the first element of every sub\u2011vector.\n *         - The second vector holds the second element of every sub\u2011vector.\n *\n * @throws std::invalid_argument if any sub\u2011vector does not have size 2.\n */\nstd::vector<std::vector<std::any>>\nmerge(const std::vector<std::vector<std::any>>& lst)\n{\n    std::vector<std::any> first;\n    std::vector<std::any> second;\n\n    first.reserve(lst.size());\n    second.reserve(lst.size());\n\n    for (const auto& sub : lst) {\n        if (sub.size() != 2) {\n            throw std::invalid_argument(\n                \"Each subvector must contain exactly two elements\");\n        }\n        first.push_back(sub[0]);\n        second.push_back(sub[1]);\n    }\n\n    return { first, second };\n}\n```\n\n### Why this version?\n\n| Feature | Why it matters |\n|---------|----------------|\n| **`const` reference parameter** | Prevents copying the whole input vector. |\n| **`reserve` calls** | Avoids multiple reallocations while filling the result. |\n| **Run\u2011time guard** | Makes the function fail fast if the input contract is violated. |\n| **Return type** | A single `std::vector<std::vector<std::any>>` containing exactly two sub\u2011vectors, just as requested. |\n\n---\n\n## Quick example\n\n```cpp\n#include <iostream>\n#include <any>\n\nint main()\n{\n    std::vector<std::vector<std::any>> data = {\n        { 10,   std::string(\"alpha\") },\n        { 20,   std::string(\"beta\")  },\n        { 30,   std::string(\"gamma\") }\n    };\n\n    auto result = merge(data);\n\n    // result[0] contains the first elements\n    std::cout << \"First column:\\n\";\n    for (const auto& a : result[0])\n        std::cout << std::any_cast<int>(a) << '\\n';\n\n    // result[1] contains the second elements\n    std::cout << \"Second column:\\n\";\n    for (const auto& a : result[1])\n        std::cout << std::any_cast<std::string>(a) << '\\n';\n}\n```\n\n**Output**\n\n```\nFirst column:\n10\n20\n30\nSecond column:\nalpha\nbeta\ngamma\n```\n\nFeel free to adapt the function to a specific type (e.g., `std::vector<std::pair<T,U>>`) if you know the element types in advance. The current implementation keeps the flexibility of `std::any`.", "Below is a concise **Python** implementation of what you described \u2013 i.e. a function that takes a list of 2\u2011element sub\u2011lists (or any iterable that behaves like a list of two items) and returns a list of two lists:\n\n```python\nfrom typing import List, Any\n\ndef split_pairs(lst: List[List[Any]]) -> List[List[Any]]:\n    \"\"\"\n    Split a list of paired items into two separate lists.\n\n    Parameters\n    ----------\n    lst : List[List[Any]]\n        A list where each element is a sub\u2011list (or other sequence) of length 2.\n\n    Returns\n    -------\n    List[List[Any]]\n        A 2\u2011list: the first inner list contains the first elements of all pairs,\n        the second inner list contains the second elements of all pairs.\n    \"\"\"\n    first, second = [], []\n\n    for item in lst:\n        # Basic sanity check \u2013 you can drop the assert in production\n        assert isinstance(item, (list, tuple)) and len(item) == 2, (\n            \"Each element must be a 2\u2011item list/tuple\"\n        )\n        first.append(item[0])\n        second.append(item[1])\n\n    return [first, second]\n\n\n# ------------------------------------------------------------------\n# Example usage\n# ------------------------------------------------------------------\nif __name__ == \"__main__\":\n    data = [[1, \"a\"], [2, \"b\"], [3, \"c\"]]\n    result = split_pairs(data)\n    print(result)   # Output: [[1, 2, 3], ['a', 'b', 'c']]\n```\n\n### Why this solution?\n\n| Feature | How we achieve it |\n|---------|-------------------|\n| **Type safety** | `typing` module + clear `assert` |\n| **Flexibility** | Accepts any `list`/`tuple` of length 2 |\n| **Clarity** | Two loops \u2013 one to unpack, one to append |\n| **Performance** | Uses two single passes \u2013 `O(n)` time, `O(n)` space |\n\nFeel free to tweak the assertion behaviour or add additional checks depending on where you use this function."]}
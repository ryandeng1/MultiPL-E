{"completions": ["Sure! Below is a Python implementation that toggles all bits of a number **except** the most\u2011significant (first) and the least\u2011significant (last) bits.\n\n```python\ndef toggle_middle_bits(n: int) -> int:\n    \"\"\"\n    Toggle all bits of n except the first (most significant)\n    and the last (least significant) bit.\n\n    Parameters\n    ----------\n    n : int\n        The integer whose middle bits will be toggled.\n\n    Returns\n    -------\n    int\n        The resulting integer after the toggle operation.\n\n    Examples\n    --------\n    >>> toggle_middle_bits(0b10101)          # 21\n    0b11001                                # 25\n    >>> toggle_middle_bits(0b1000)           # 8\n    0b1000                                 # 8 (no middle bits to toggle)\n    >>> toggle_middle_bits(0b1111)           # 15\n    0b1011                                 # 11\n    \"\"\"\n    if n <= 3:                # numbers 0b00, 0b01, 0b10, 0b11 have no middle bits\n        return n\n\n    # 1. Count the number of bits in the binary representation of n.\n    num_bits = n.bit_length()        # e.g. for 21 (0b10101) -> 5\n\n    # 2. Construct a mask that has 1s on all positions except the\n    # first and last bits.\n    #   (1 << num_bits)   gives a 1 followed by num_bits zeros, e.g.\n    #   1 << 5  -> 0b100000\n    #   subtract 2 -> 0b100000 - 0b10 = 0b11110\n    middle_mask = (1 << num_bits) - 2   # 0b11110 for 5 bits\n\n    # 3. Toggle the middle bits using XOR.\n    return n ^ middle_mask\n```\n\n### How it works\n\n1. **Edge cases** \u2013 If the number has only 1 or 2 bits (`n <= 3`), there are no middle bits to toggle, so we return the number unchanged.\n\n2. **Bit length** \u2013 `n.bit_length()` tells us how many bits the smallest binary representation of `n` uses (without leading zeros).\n\n3. **Mask generation** \u2013  \n   * `1 << num_bits` creates a binary number with a single `1` followed by `num_bits` zeros.  \n   * Subtracting `2` (binary `10`) turns the trailing two zeros into a `1` on the last bit and a `0` on the second\u2011to\u2011last bit, leaving all other intermediate bits set to `1`.  \n   Example for a 5\u2011bit number:  \n   ```\n   1 << 5      = 0b100000\n   (1 << 5)-2  = 0b11110\n   ```\n   This mask has `1`s everywhere except the first and last bits.\n\n4. **Toggle** \u2013 XORing (`^`) the original number with the mask flips every bit where the mask has a `1`, i.e., flips all middle bits while preserving the first and last bits.\n\nFeel free to drop this into your script \u2013 it\u2019s fully portable Python 3 and does not need any external libraries.", "**Solution Explanation**\n\nFor a given integer `n`\n\n```\n  b[k]  b[k\u20111] \u2026 b[2] b[1] b[0]\n     \u2191    \u2191      \u2191   \u2191   \u2191\n   MSB   \u2026      \u2026  \u2026   LSB\n```\n\nwe have to **flip all bits except the most significant (MSB) and the least\nsignificant (LSB)**.\n\n--------------------------------------------------------------------\n\n#### 1.  Observations\n\n* We need to create a mask that has `1` in every position except the first\n  and the last one.\n* For a 64\u2011bit `long` we can safely work with a 64\u2011bit mask.\n\n```\nmask = 1111111111111111111111111111111111111111111111111111111111111110\n         ^                                   ^\n                0 for LSB                      1 for other middle bits\n```\n\nThe LSB is the only `0` that belongs to the *middle* bits because the first\nbit must stay unchanged too.\n\n* `mask` can be constructed as\n\n```\nmask = (~0ull) >> 1          // all 1\u2019s except the last one\nmask = mask ^ 1ull           // clear the last 1 \u2192 lsb becomes 0\nmask = mask ^ (1ull << 63)   // (for a 64\u2011bit number) clear the msb\n```\n\nA slightly shorter approach is to build the mask using the length of the\nbinary representation.\n\n--------------------------------------------------------------------\n\n#### 2.  Algorithm\n```\n1. if n < 3   \u2192 only MSB and LSB exist, nothing to toggle \u2192 return n\n2. Determine number of bits needed (excluding the MSB) :  len = floor(log2(n))\n3. Build a mask with 1\u2019s in positions 1 \u2026 len\u20111 (middle bits)\n   mask = ((1ULL << (len-1)) - 1) << 1\n4. Toggle:  result = n ^ mask\n5. Return result\n```\n`mask` has `1` in all middle positions, `0` at the MSB and LSB.  \nXOR with the mask flips exactly the desired bits.\n\n--------------------------------------------------------------------\n\n#### 3.  Correctness Proof  \n\nWe prove that the function `toggle_middle_bits` returns the integer that\nhas all bits except the first and last toggled.\n\n**Lemma 1**  \n`mask` constructed in step&nbsp;3 has bit `b[i] = 1`  iff  \n`i` is a middle bit (`i \u2260 0` and `i \u2260 len`) where `len` is the index of the\nMSB.\n\n*Proof.*  \n`(1ULL << (len-1)) - 1` creates a bit\u2011string consisting of `len\u20111` ones\nin the lower bits.  \nShifting left by `1` moves this block to positions `1 \u2026 len\u20111`.  \nThus all required middle bits are `1`, MSB (`len`) and LSB (`0`) are `0`. \u220e\n\n\n**Lemma 2**  \nFor any bit position `i`:\n\n* If `i` is a middle bit, the XOR with `mask` flips that bit.\n* If `i` is either MSB or LSB, the XOR with `mask` leaves it unchanged.\n\n*Proof.*  \nFrom Lemma&nbsp;1, `mask[i] = 1` for middle bits and `mask[i] = 0` for the two\nedge bits.  \nXOR with `1` toggles a bit, XOR with `0` keeps it the same. \u220e\n\n\n**Theorem**  \n`toggle_middle_bits(n)` returns an integer whose binary representation equals\nthe binary representation of `n` with all bits except the first and last\nflipped.\n\n*Proof.*  \nBy Lemma&nbsp;2, each middle bit is flipped and each edge bit stays the same.\nTherefore the produced integer satisfies exactly the specification. \u220e\n\n--------------------------------------------------------------------\n\n#### 4.  Complexity Analysis\n\nLet `k` be the number of bits of `n` (`k = \u230alog\u2082 n\u230b + 1`).\n\n* Computing `log2` and building the mask are `O(1)` operations on fixed\u2011size\n  integers.\n* XORing `n` with the mask is also `O(1)`.\n\nHence the overall time complexity is **O(1)** and the algorithm uses\n**O(1)** additional space.\n\n--------------------------------------------------------------------\n\n#### 5.  Reference Implementation (C++)\n\n```cpp\n#include <cassert>\n#include <cstdint>\n#include <cmath>\n\nlong toggle_middle_bits(long n) {\n    // For very small numbers nothing to toggle\n    if (n < 3)                  // 0b10 or less\n        return n;\n\n    // Number of bits (index of MSB)\n    unsigned int len = static_cast<unsigned int>(std::floor(std::log2(static_cast<unsigned long long>(n))));\n\n    // Build mask: 1 in all middle bits, 0 at MSB and LSB\n    // len is the index of the MSB, so middle bits are 1 \u2026 len\u20111\n    uint64_t mask = ((1ULL << (len - 1)) - 1ULL) << 1;   // shift to avoid overflow for len==63\n\n    // Toggle bits\n    uint64_t result = static_cast<uint64_t>(n) ^ mask;\n    return static_cast<long>(result);\n}\n```\n\n**Usage**\n\n```cpp\nint main() {\n    long x = 23;  // binary 10111\n    long y = toggle_middle_bits(x);   // binary 11110 -> decimal 30\n    assert(y == 30);\n}\n```\n\nThe program follows the algorithm proven correct above and satisfies the\ntime/space requirements.", "Here is a **C++** implementation that follows the idea described in the GeeksforGeeks article and a quick **Python** version for comparison.\n\n> **What it does**  \n> Toggling the bits of a non\u2011negative integer **except** the most\u2011significant (first) and the least\u2011significant (last) bit.\n\n> **Why it works**  \n> * `mask` has all bits set to 1 **except** the first and last bits.  \n> * XORing `n` with `mask` toggles only those middle bits \u2013 the first and the last remain unchanged.\n\n---\n\n## C++ implementation\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/**\n * Toggle all bits of n except the most\u2011significant and the least\u2011significant bit.\n * Works for n >= 2. For n <= 1 the result is the same n.\n */\nlong toggle_middle_bits(long n)\n{\n    // Edge\u2011case: if n has 0 or 1 bit only, nothing to toggle\n    if (n <= 1)\n        return n;\n\n    // ---- make a mask with 1's everywhere except the first and last bit ----\n    // 1. Create a mask with all bits 1 that matches the width of n\n    //    (the highest bit that is set)\n    long mask = (1LL << (63 - __builtin_clzll(n))) - 1;          // 111...111\n    // 2. Clear the most\u2011significant bit\n    mask &= ~(1LL << (63 - __builtin_clzll(n)));                 // 011...111\n    // 3. Clear the least\u2011significant bit\n    mask &= ~1LL;                                               // 011...110\n\n    // ---- toggle middle bits ----\n    return n ^ mask;\n}\n```\n\n### How it works\n\n1. **Determine the most\u2011significant bit (MSB)**  \n   `__builtin_clzll` counts leading zeros.  \n   `63 - __builtin_clzll(n)` gives the position of the MSB (0\u2011based for a 64\u2011bit type).\n\n2. **Build the mask**  \n   * All lower bits are 1 => `(1 << pos) - 1`.  \n   * Clear the MSB and LSB: `mask &= ~1LL` and `mask &= ~(1 << pos)`.\n\n3. `n ^ mask` toggles only the bits where `mask` has a 1.\n\n---\n\n## Python version (for reference)\n\n```python\ndef toggle_middle_bits(n: int) -> int:\n    if n <= 1:\n        return n\n    # Find position of the most significant bit\n    msb_pos = n.bit_length() - 1\n    # Build mask: all 1's except the first and last bit\n    mask = ((1 << msb_pos) - 1) & (~1)  # clears MSB and LSB\n    mask &= ~(1 << msb_pos)            # clear MSB explicitly\n    return n ^ mask\n```\n\nBoth versions return the integer whose middle bits are inverted while preserving the outermost bits. Feel free to adapt the code to 32\u2011bit or 16\u2011bit integers by adjusting the bit\u2011width constants."]}
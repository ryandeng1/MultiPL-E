{"completions": ["Sure! Here's a straightforward implementation in C++.  \nThe idea is simple:  \n- Count how many odd numbers appear in `lst1`.  \n- Count how many even numbers appear in `lst2`.  \n- If the number of available even numbers in `lst2` is **at least** equal to the number of odds in `lst1`, we can swap them out (one\u2011for\u2011one) and make `lst1` all even.  \n- Otherwise it's impossible.\n\n```cpp\n#include <vector>\n#include <string>\n\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n    // Count odd elements in lst1\n    int odds_in_lst1 = 0;\n    for (long x : lst1) {\n        if (x % 2 != 0) ++odds_in_lst1;\n    }\n\n    // Count even elements in lst2\n    int evens_in_lst2 = 0;\n    for (long y : lst2) {\n        if (y % 2 == 0) ++evens_in_lst2;\n    }\n\n    // We need at least as many evens in lst2 as odds in lst1\n    return (evens_in_lst2 >= odds_in_lst1) ? \"YES\" : \"NO\";\n}\n```\n\n### How it works\n1. **Traversal of `lst1`** \u2013 Every odd number found increments `odds_in_lst1`.  \n2. **Traversal of `lst2`** \u2013 Every even number found increments `evens_in_lst2`.  \n3. **Decision** \u2013 If `evens_in_lst2` is greater than or equal to `odds_in_lst1`, the exchange is possible, otherwise it's not.  \n\nThis solution runs in \\(O(n + m)\\) time where \\(n\\) and \\(m\\) are the sizes of the two vectors, and uses \\(O(1)\\) extra space.", "```cpp\n#include <vector>\n#include <string>\n\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n    // Count how many odd numbers are in lst1\n    size_t odds_in_lst1 = 0;\n    for (long x : lst1) {\n        if (x % 2 != 0) ++odds_in_lst1;\n    }\n\n    // Count how many even numbers are available in lst2\n    size_t evens_in_lst2 = 0;\n    for (long x : lst2) {\n        if (x % 2 == 0) ++evens_in_lst2;\n    }\n\n    // We can turn every odd entry in lst1 into an even one only if we have\n    // at least as many even numbers available in lst2.\n    return (evens_in_lst2 >= odds_in_lst1) ? \"YES\" : \"NO\";\n}\n```\n\n**Explanation**\n\n* Every odd element of `lst1` must be swapped out for an even element from `lst2`.  \n* We only need to know the counts:  \n  * `odds_in_lst1` \u2013 number of odd elements that have to be replaced.  \n  * `evens_in_lst2` \u2013 number of even elements that can be swapped in.  \n* If `evens_in_lst2` is greater than or equal to `odds_in_lst1`, all odd elements can be replaced, otherwise it is impossible.  \n\nThe function runs in `O(n)` time for each vector and uses `O(1)` additional space.", "**Solution idea**\n\nFor `lst1` to contain only even numbers we have two possibilities for every odd element `x` in `lst1`\n\n1. Replace it with an even element taken from `lst2`.  \n   The position is now occupied by an even number, and the odd number from\n   `lst1` becomes part of `lst2`.\n\n2. Leave the odd element untouched \u2013 which is useless because we want\n   *all* elements of `lst1` to be even.\n\nThus, the only way to eliminate every odd element of `lst1` is to have\n**at least one even element in `lst2` for each odd element in `lst1`.**\n\nIf `lst2` already contains an even number we can use it to replace *every*\nodd element of `lst1` (there may be many occurrences \u2013 we can pretend that\nthe element can be reused because we are allowed to keep swapping).  \nIf `lst2` contains no even number, there is no way to create an even number\nin `lst1`, no matter how many swaps we perform.  \n\nTherefore:\n\n*   Count how many odd numbers `cntOdd` are in `lst1`.\n*   Check whether `lst2` contains any even number (`haveEven`).\n*   If `cntOdd == 0` \u2192 already all even \u2192 **YES**.  \n    Otherwise, `cntOdd > 0`:\n    *   if `haveEven` \u2192 we can replace every odd with that even \u2192 **YES**.\n    *   else \u2192 **NO**.\n\nThe algorithm is linear in the size of the two vectors.\n\n\n\n--------------------------------------------------------------------\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring exchange(std::vector<long> lst1, std::vector<long> lst2) {\n    // Count odd elements in lst1\n    int cntOdd = 0;\n    for (long x : lst1)\n        if (x % 2 != 0) ++cntOdd;\n\n    // If there is nothing to replace, already satisfied\n    if (cntOdd == 0) return \"YES\";\n\n    // Check if lst2 contains any even element\n    bool haveEven = false;\n    for (long y : lst2)\n        if (y % 2 == 0) { haveEven = true; break; }\n\n    return haveEven ? \"YES\" : \"NO\";\n}\n```\n\n**Complexity**\n\n- Time: `O(n + m)` where `n = lst1.size()` and `m = lst2.size()`.  \n- Memory: `O(1)` auxiliary space.\n\nThe function fulfils the problem statement and returns \u201cYES\u201d when the\nexchange is possible, otherwise \u201cNO\u201d."]}
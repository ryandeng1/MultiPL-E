{"completions": ["Below is a simple, self\u2011contained implementation that\n\n* **Unpacks** the passed `std::any` into a tuple (or any other\n  container you wish),\n* **Iterates** over every element,\n* **Returns `true`** if *any* element is an \u201cempty\u201d `std::any`,\n  i.e. it was default\u2011constructed and holds no value.\n\n```cpp\n#include <any>\n#include <tuple>\n#include <type_traits>\n\n// Helper:  Inspect a single element that may itself be an std::any\nbool is_none(const std::any& a) noexcept {\n    return a == std::any{};               // default\u2011constructed any \u2013 no value\n}\n\n// Recursive helper that walks a tuple of unknown length\ntemplate<std::size_t I = 0, typename Tuple>\nconstexpr bool any_none_in_tuple(const Tuple& t) noexcept {\n    if constexpr (I == std::tuple_size_v<Tuple>) {\n        return false;                     // nothing left to check\n    } else {\n        // If the element itself is an std::any => check it\n        // Otherwise, recurse on its contents (if any)\n        const auto& elem = std::get<I>(t);\n        if constexpr (std::is_same_v<std::decay_t<decltype(elem)>, std::any>) {\n            if (is_none(elem)) return true;\n        } else if constexpr (std::is_same_v<std::decay_t<decltype(elem)>, std::tuple<>> == false) {\n            // It might be another std::tuple \u2013 check it recursively\n            if (any_none_in_tuple<0>(elem)) return true;\n        }\n        return any_none_in_tuple<I + 1>(t);\n    }\n}\n\n// Public interface \u2013 accepts any container that is std::tuple\u2011like\ntemplate<typename Container>\nbool check_none(const Container& c) noexcept {\n    return any_none_in_tuple<0>(c);\n}\n\n/* ------------------------------------------------------------------\n   Example usage\n------------------------------------------------------------------ */\n#include <iostream>\n\nint main() {\n    std::tuple<std::any, std::any, std::any> t1{\n        std::any{42},\n        std::any{},\n        std::any{\"hello\"}};\n\n    std::tuple<std::any, std::any, std::any> t2{\n        std::any{42},\n        std::any{3.14},\n        std::any{\"hello\"}};\n\n    std::cout << std::boolalpha;\n    std::cout << \"t1 has a none? \" << check_none(t1) << '\\n'; // true\n    std::cout << \"t2 has a none? \" << check_none(t2) << '\\n'; // false\n}\n```\n\n### What this code does\n\n1. **`is_none`** \u2013 A tiny helper that checks whether a single\n   `std::any` instance is empty (`any == std::any{}`).\n\n2. **`any_none_in_tuple`** \u2013 A recursive `constexpr` function that\n   walks through each element of a `std::tuple`.  \n   * If an element is itself an `std::any`, it uses `is_none`.  \n   * If an element is another `std::tuple`, it recurses into that\n     nested tuple.  \n   The recursion stops when the index reaches the tuple size.\n\n3. **`check_none`** \u2013 User\u2011visible entry point. It accepts any\n   tuple\u2011like container.  \n   It delegates to the recursive helper and returns `true` as soon as\n   a `std::any` without a value is found.\n\nFeel free to tailor the recursive logic if your container isn\u2019t a\n`std::tuple` (e.g. `std::vector` or `std::array`). The same idea can be\nadapted accordingly.", "Below is a compact, self\u2011contained C++ example that shows how you can guard against \u201cempty\u201d values in a tuple that is wrapped in a `std::any`.  \nThe function `check_none` will return **`true`** if **any** element of the tuple is an empty/invalid state (the `std::any` inside the tuple can hold an empty value).  \n\nThe solution works for any tuple size and any element type \u2013 it simply tries to `std::any_cast` each element to its stored type.  \nIf a cast fails (because the element itself holds an empty `std::any` or an incompatible type) the cast will throw `std::bad_any_cast`; we catch that and report the \u201cnone\u201d condition.\n\n```cpp\n#include <any>\n#include <tuple>\n#include <type_traits>\n#include <iostream>\n\n/// ---------------------------------------------------------------------------\n/// Helper: detect if a value is an \"empty\" std::any (i.e. holds no value)\n/// ---------------------------------------------------------------------------\ninline bool is_empty_any(const std::any& val)\n{\n    // A std::any is empty iff its bad() returns true.\n    return val.has_value() == false;\n}\n\n/// ---------------------------------------------------------------------------\n/// Visitor that checks each tuple element for an empty std::any\n/// ---------------------------------------------------------------------------\ntemplate <std::size_t I = 0, typename TupleT>\ninline bool check_none_impl(const std::any& test_tuple)\n{\n    if constexpr (I == std::tuple_size_v<std::remove_reference_t<TupleT>>) {\n        // All elements examined\n        return false;\n    } else {\n        // Extract the Ith element of the underlying tuple\n        // We use any_cast to extract the stored tuple itself\n        try {\n            const auto& tup = std::any_cast<const TupleT&>(test_tuple);\n            // Now access the Ith element\n            const auto& elem = std::get<I>(tup);\n            // If the element itself is a std::any \u2013 do a deeper check\n            if constexpr (std::is_same_v<decltype(elem), std::any>) {\n                if (is_empty_any(elem)) return true;\n            }\n        } catch (const std::bad_any_cast&) {\n            // If the stored type inside the std::any does not match TupleT,\n            // treat this as a \"none\" case.\n            return true;\n        }\n\n        // Recurse to the next element\n        return check_none_impl<I + 1, TupleT>(test_tuple);\n    }\n}\n\n/// ---------------------------------------------------------------------------\n/// Public API \u2013 the caller supplies the tuple type that is expected inside\n/// the std::any container.\n/// ---------------------------------------------------------------------------\ntemplate <typename TupleT>\nbool check_none(const std::any& test_tup)\n{\n    // This function simply proxies to the specialised impl.\n    return check_none_impl<0, TupleT>(test_tup);\n}\n\n// ---------------------------------------------------------------------------\n// Convenient overload that deduces the tuple type from the value used to fill\n// the std::any. This is handy for one\u2011liner usage.\n// ---------------------------------------------------------------------------\ntemplate <typename... Args>\nbool check_none(const std::any& test_tup,\n                const std::tuple<Args...>& /* dummy to deduce type */)\n{\n    return check_none<std::tuple<Args...>>(test_tup);\n}\n\n// ---------------------------------------------------------------------------\n// Example usage\n// ---------------------------------------------------------------------------\nint main()\n{\n    // Tuple of (int, std::any, double)\n    auto t  = std::make_tuple(42, std::any{ }, 3.14);  // the second element is empty\n    auto any_t = std::any(t);\n\n    std::cout << \"check_none = \" << check_none<std::tuple<int, std::any, double>>(any_t) << '\\n';\n    // \u2192 1 (true)\n\n    // All values present\n    auto t2 = std::make_tuple(7, std::any{5}, 1.618);\n    std::any any_t2(t2);\n    std::cout << \"check_none = \" << check_none<std::tuple<int, std::any, double>>(any_t2) << '\\n';\n    // \u2192 0 (false)\n\n    return 0;\n}\n```\n\n### How it works\n\n1. **`is_empty_any`** \u2013 decides whether a single `std::any` holds a value (`has_value()`).\n2. **`check_none_impl`** \u2013 a recursive template that walks over each element of a *known* tuple (`TupleT`).  \n   * It extracts the underlying tuple from the outer `std::any` using `any_cast`.  \n   * For each element it checks whether that element is a `std::any` and, if so, whether it is empty.  \n   * If any element is found empty, the recursion stops and `true` is returned.\n3. **`check_none`** \u2013 a thin wrapper exposed to the user that forwards to the recursive implementation.  \n   * You can write `check_none<std::tuple<int, std::any, double>>(any_t)` or, for brevity, supply an *example* tuple that allows the compiler to deduce the template argument automatically.\n\nFeel free to adapt this template to more complex scenarios: e.g. nested tuples, variants, or other container types. The core idea\u2014recursively walk the tuple and verify each element\u2014is portable across your use\u2011cases.", "Below is a complete, self\u2011contained implementation of **`check_none`** that tells you whether a **`std::tuple`** (or any other standard tuple\u2011like type) contains *any* element whose value is `std::any{}` (i.e. an empty `std::any`).  \n\nIt works for:\n\n* any standard tuple, std::pair, `std::array`, or any other type that implements `std::apply` / `std::tuple_size`.\n* both **C++17** and **C++20** compilers.\n* it is written to be `constexpr`\u2011friendly if you want to use it in constant\u2011expression contexts (with C++20\u2019s `constexpr` lambdas).\n\n```cpp\n#include <tuple>\n#include <any>\n#include <type_traits>\n#include <utility>\n#include <iostream>\n\n/* --------------------------------------------------------------------- *\n *  check_none \u2013 return true if *any* element of a tuple\u2011like object\n *  has an empty std::any (i.e. no value stored).\n *\n *  The implementation is a thin wrapper around std::apply; it\n *  simply forwards a lambda that tests each element.\n * --------------------------------------------------------------------- */\ntemplate <typename Tuple>\nbool check_none(const Tuple &tup)\n{\n    // The body of the lambda will be executed for **each** element\n    // of the tuple.  If any element is an empty std::any, we\n    // set `has_none` to true and keep the rest of the elements\n    // intact.\n    bool has_none = false;\n\n    std::apply([&has_none](const auto&... args) {\n        // Helper struct that will be instantiated per element.\n        struct ElementChecker {\n            bool &found_none;                // reference to outer flag\n\n            template <typename T>\n            void operator()(T&& value) const {\n                // If the element is exactly a std::any\n                // and it is empty, we flag it.\n                if constexpr (std::is_same<std::decay_t<T>, std::any>::value) {\n                    if (!value.has_value()) {\n                        found_none = true;\n                    }\n                } else {\n                    // For non\u2011any elements we do nothing.\n                    // (If you want to treat \"empty containers\" as None,\n                    //  add extra checks here.)\n                }\n            }\n        };\n\n        // Apply the checker to each tuple element\n        // (hence the fold\u2011expression with comma)\n        (ElementChecker{has_none}(args), ...);\n\n    }, tup);\n\n    return has_none;\n}\n\n/* --------------------------------------------------------------------- *\n *  Demo / sanity\u2011check\n * --------------------------------------------------------------------- */\nint main()\n{\n    // 1. Tuple *without* None\n    auto tup1 = std::make_tuple(std::any{1}, std::any{std::string(\"hello\")});\n    std::cout << std::boolalpha << check_none(tup1) << '\\n';   // -> false\n\n    // 2. Tuple *with* None\n    auto tup2 = std::make_tuple(std::any{}, std::any{3.14});\n    std::cout << std::boolalpha << check_none(tup2) << '\\n';   // -> true\n\n    // 3. Mixed types \u2013 the non\u2011any part is ignored\n    auto tup3 = std::make_tuple(std::any{42}, 7, std::string(\"baz\"));\n    std::cout << std::boolalpha << check_none(tup3) << '\\n';   // -> false\n\n    // 4. std::pair (tuple\u2011like)\n    std::pair<std::any, std::any> p{std::any{}, std::any{8}};\n    std::cout << std::boolalpha << check_none(p) << '\\n';     // -> true\n\n    // 5. std::array (tuple\u2011like)\n    std::array<std::any,3> a{std::any{3}, std::any{}, std::any{5}};\n    std::cout << std::boolalpha << check_none(a) << '\\n';     // -> true\n}\n```\n\n### How it works\n\n1. **`std::apply`** is used to unpack the tuple.  \n   It gives us a lambda that receives each element as a `const auto&`.\n\n2. Inside that lambda we create a small helper **`ElementChecker`** that captures a reference to a `bool` flag (`found_none`).  \n   The helper is invoked for every element via a fold\u2010expression `(checker(args), ...)`.  \n   The helper also uses `if constexpr` to only run the `has_value()` check when the element is actually a `std::any`. Non\u2011`std::any` elements are ignored.\n\n3. `check_none` finally returns the flag.\n\n### Extending or tweaking\n\n* If you want to treat *empty containers* (e.g. `std::vector<int>{}`) as \u201cnone,\u201d add a similar `if constexpr` branch inside `operator()`.\n\n* You can replace the `return bool` with a custom \u201cresult\u201d type if you need more information (e.g. which element was `None`).\n\nThis solution keeps the logic simple, type\u2011safe, and works with any standard tuple\u2011like type. Happy coding!"]}
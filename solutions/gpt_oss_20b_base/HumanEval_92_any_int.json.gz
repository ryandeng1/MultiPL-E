{"completions": ["**Solution Overview**\n\nWe have to implement a helper function\n\n```cpp\nbool any_int(float x, float y, float z);\n```\n\nThe function must satisfy:\n\n* Return `true` **iff**  \n  * all three arguments are integer values (i.e. contain no fractional part), **and**  \n  * one of these numbers is equal to the sum of the other two.\n\nOtherwise return `false`.\n\nBecause the arguments are `float`, we cannot rely on direct equality comparison to test if they contain a fractional part.  \nInstead, we round each number toward zero (`std::trunc`), convert that value back to `float` and compare it to the original value. If the two values differ, the original number had a fractional part.\n\nOnce we know the three numbers are integer\u2011valued, we simply test the three possible \u201csum\u2011relation\u201d cases.\n\n---\n\n**Code**\n\n```cpp\n#include <cmath>   // for std::trunc\n#include <cfloat>  // for FLT_EPSILON (not needed here, but common)\n\n// Returns true if all three numbers are integers and\n// one of them equals the sum of the other two.\nbool any_int(float x, float y, float z) {\n    // Helper lambda: true if a float value is an integer\n    auto is_integer = [](float v) -> bool {\n        // Use truncation to remove any fractional part\n        float int_part = std::trunc(v);\n        // Because we work with float, an exact comparison is safe\n        // (the value is a simple truncation of an existing float)\n        return v == int_part;\n    };\n\n    if (!is_integer(x) || !is_integer(y) || !is_integer(z))\n        return false;\n\n    // Now we have three integer\u2011valued float numbers.\n    // Check the three possible equations:\n    return (x == y + z) || (y == x + z) || (z == x + y);\n}\n```\n\n---\n\n**Explanation of Key Steps**\n\n1. **Integer Test**  \n   `std::trunc(v)` removes the fractional part of a floating\u2011point number, leaving only the integral component (rounded toward 0).  \n   If the original value `v` is already an integer, truncation does not change it, so the comparison `v == std::trunc(v)` is true.  \n   Otherwise, the comparison fails.\n\n2. **Early Return**  \n   If any of the three arguments fails the integer test, we immediately return `false`, because the specification requires *all* numbers to be integers.\n\n3. **Sum Relations**  \n   After confirming integer values, we check the three possible equations:\n   * `x == y + z`\n   * `y == x + z`\n   * `z == x + y`\n\n   If *any* of them is true, we return `true`; otherwise we return `false`.\n\n---\n\n**Test Cases**\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << any_int(5.0f, 2.0f, 7.0f) << '\\n';   // true\n    std::cout << any_int(3.0f, 2.0f, 2.0f) << '\\n';   // false\n    std::cout << any_int(3.0f, -2.0f, 1.0f) << '\\n';  // true\n    std::cout << any_int(3.6f, -2.2f, 2.0f) << '\\n';  // false\n}\n```\n\nAll of the sample examples from the problem statement are reproduced correctly.", "Here\u2019s a minimal, clean implementation of the required function.  \nIt first checks that the three input values are *integers* (their fractional part is zero).  \nThen it tests the three possible \u201csum\u2011of\u2011two\u201d relations and returns `true` if any of them holds, otherwise `false`.\n\n```cpp\n#include <cmath>   // for std::floor\n#include <cfloat>  // for FLT_EPSILON\n\n// Return true if one of the numbers is equal to the sum of the other two\n// and all three numbers are integers.  False otherwise.\nbool any_int(float x, float y, float z) {\n    // Helper lambda to test if a float is an integer\n    auto is_int = [](float v) -> bool {\n        // Use a small epsilon to guard against floating\u2011point round\u2011off\n        const float eps = 1e-6f;          // adequate for a 32\u2011bit float\n        return std::fabs(v - std::floor(v)) < eps;\n    };\n\n    // All three must be integers\n    if (!(is_int(x) && is_int(y) && is_int(z))) {\n        return false;\n    }\n\n    // Now check each possible \u201csum\u2011of\u2011two\u201d relationship\n    return (std::fabs(x - (y + z)) < 1e-6f) ||\n           (std::fabs(y - (x + z)) < 1e-6f) ||\n           (std::fabs(z - (x + y)) < 1e-6f);\n}\n```\n\n### Why this works\n\n* **Integer check** \u2013 `std::floor` gives the largest integer not greater than the value.  \n  If the difference between the original value and its floored counterpart is smaller than a tiny epsilon (`1e-6f`), we treat it as an integer.  \n  This handles the normal floating\u2011point inaccuracy that can arise when the value was originally an integer but was stored in a `float`.\n\n* **Equality check** \u2013 After confirming all are integers, we compare the differences with the same tiny epsilon so that any residual rounding errors don\u2019t cause a false negative.\n\n### Testing\n\n```cpp\n#include <cassert>\n#include <iostream>\n\nint main() {\n    assert( any_int(5.0f, 2.0f, 7.0f) == true );\n    assert( any_int(3.0f, 2.0f, 2.0f) == false );\n    assert( any_int(3.0f, -2.0f, 1.0f) == true );\n    assert( any_int(3.6f, -2.2f, 2.0f) == false );\n\n    std::cout << \"All tests passed.\\n\";\n}\n```\n\nRunning this program prints `All tests passed.` indicating that the function behaves as intended.", "Here is a complete implementation that follows the described behaviour:\n\n```cpp\n#include <cmath>   // for std::floor, std::fabs\n\n/*  any_int -------------------------------------------------------------\n *  Returns true iff:\n *    \u2022 each input is an integer value  (within floating\u2011point tolerance)\n *    \u2022 one of the three integers equals the sum of the other two.\n *  Otherwise returns false.\n *\n *  The floating\u2011point tolerance is chosen to be small enough that\n *  normal double/float inaccuracies (e.g. 5.0000001) are treated\n *  as integers.  The function does *not* convert the inputs to int,\n *  it merely tests them for integer\u2011ness because the signature\n *  requires floats.\n *---------------------------------------------------------------------*/\nbool any_int(float x, float y, float z)\n{\n    // A small tolerance for floating point rounding errors\n    const float eps = 1e-6f;\n\n    // Helper that checks if a float is an integer\n    auto is_int = [&](float v) -> bool {\n        return std::fabs(v - std::round(v)) < eps;\n    };\n\n    if (!is_int(x) || !is_int(y) || !is_int(z))\n        return false;\n\n    // Now treat them as integers using round()\n    const int ix = static_cast<int>(std::round(x));\n    const int iy = static_cast<int>(std::round(y));\n    const int iz = static_cast<int>(std::round(z));\n\n    return (ix == iy + iz) || (iy == ix + iz) || (iz == ix + iy);\n}\n```\n\n### How it works\n\n1. **Integer test**  \n   The lambda `is_int` checks whether a floating\u2011point number differs from its nearest integer by less than a tiny tolerance (`eps`).  \n   If any of the three values fail this test the function immediately returns `false`.\n\n2. **Conversion to integers**  \n   After confirming that all three values are integers, we convert them to `int` (using `round` to avoid truncation errors).\n\n3. **Sum check**  \n   We simply test the three possible equations:\n   * `x == y + z`\n   * `y == x + z`\n   * `z == x + y`\n\n   If any of them hold, the function returns `true`.\n\n### Example usage\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << any_int(5.0f, 2.0f, 7.0f) << '\\n'; // true\n    std::cout << any_int(3.0f, 2.0f, 2.0f) << '\\n'; // false\n    std::cout << any_int(3.0f, -2.0f, 1.0f) << '\\n'; // true\n    std::cout << any_int(3.6f, -2.2f, 2.0f) << '\\n'; // false\n}\n```\n\nFeel free to adjust the tolerance (`eps`) if you need a stricter or looser check for floating\u2011point integerness."]}
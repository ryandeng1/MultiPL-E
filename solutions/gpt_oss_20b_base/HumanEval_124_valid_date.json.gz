{"completions": ["Here is a complete, self\u2011contained implementation of `valid_date`.  \nThe function checks:\n\n1. The string is non\u2011empty.  \n2. The format must be `mm-dd-yyyy` (`'-'` separator at positions 2 and 5).  \n3. The month, day and year parts contain only digits.  \n4. The month is in `[1,12]`.  \n5. The day is in the correct range for that month (taking leap\u2011year into account).  \n\n```cpp\n#include <string>\n#include <cctype>\n#include <iomanip>\n\nbool isLeapYear(int year)\n{\n    // Leap year rule: divisible by 400 or divisible by 4 but not by 100\n    return (year % 400 == 0) || (year % 4 == 0 && year % 100 != 0);\n}\n\nbool allDigits(const std::string &s)\n{\n    for (char c : s)\n        if (!std::isdigit(static_cast<unsigned char>(c)))\n            return false;\n    return true;\n}\n\nbool valid_date(const std::string &date)\n{\n    // 1) Not empty\n    if (date.empty())\n        return false;\n\n    // The string must be exactly 10 characters: mm-dd-yyyy\n    if (date.size() != 10 || date[2] != '-' || date[5] != '-')\n        return false;\n\n    // Extract month, day, year substrings\n    std::string month_s = date.substr(0, 2);\n    std::string day_s   = date.substr(3, 2);\n    std::string year_s  = date.substr(6, 4);\n\n    // 2) All parts must be digits\n    if (!allDigits(month_s) || !allDigits(day_s) || !allDigits(year_s))\n        return false;\n\n    // Convert to integers\n    int month = std::stoi(month_s);\n    int day   = std::stoi(day_s);\n    int year  = std::stoi(year_s);\n\n    // 3) Month range\n    if (month < 1 || month > 12)\n        return false;\n\n    // 4) Day limits per month\n    int max_day;\n    switch (month)\n    {\n        case 1: case 3: case 5: case 7:\n        case 8: case 10: case 12:\n            max_day = 31; break;\n        case 4: case 6: case 9: case 11:\n            max_day = 30; break;\n        case 2:\n            max_day = isLeapYear(year) ? 29 : 28;\n            break;\n        default:\n            return false; // unreachable, but keeps compiler happy\n    }\n\n    if (day < 1 || day > max_day)\n        return false;\n\n    return true;\n}\n```\n\n### How it works\n\n- `isLeapYear` handles the standard Gregorian leap\u2011year rule.  \n- `allDigits` verifies that a substring contains only decimal digits.  \n- The main `valid_date` function first checks the length and separator positions.  \n- It then extracts the month, day and year parts, checks digit\u2011only, converts them to integers, and finally checks the month and day ranges, respecting February\u201129 in leap years.\n\n### Example usage\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::cout << std::boolalpha;\n    std::cout << valid_date(\"03-11-2000\") << '\\n'; // true\n    std::cout << valid_date(\"15-01-2012\") << '\\n'; // false\n    std::cout << valid_date(\"04-0-2040\")  << '\\n'; // false\n    std::cout << valid_date(\"06-04-2020\") << '\\n'; // true\n    std::cout << valid_date(\"06/04/2020\") << '\\n'; // false\n}\n```\n\nThis implementation follows all the specified constraints and works correctly for the provided examples.", "Here is a compact and self\u2011contained implementation that follows the rules you listed:\n\n```cpp\n#include <string>\n#include <cctype>\n#include <cstdlib>\n\n// ---------------------------------------------------------------------\n// Helper \u2013 check that a string consists of exactly `cnt` digits\nstatic bool only_digits(const std::string &s, std::size_t cnt)\n{\n    if (s.size() != cnt) return false;\n    for (char c : s)\n        if (!std::isdigit(static_cast<unsigned char>(c))) return false;\n    return true;\n}\n\n// ---------------------------------------------------------------------\n// Main validation routine\nbool valid_date(std::string date)\n{\n    // 1. non\u2011empty\n    if (date.empty()) return false;\n\n    /* \n       4. format mm-dd-yyyy\n       We expect two digits, a '-', two digits, a '-', and four digits.\n    */\n    if (date.size() != 10) return false;\n    if (date[2] != '-' || date[5] != '-') return false;\n\n    // split parts\n    std::string month_str = date.substr(0, 2);\n    std::string day_str   = date.substr(3, 2);\n    std::string year_str  = date.substr(6, 4);\n\n    // 4. make sure all parts contain only digits\n    if (!only_digits(month_str, 2) ||\n        !only_digits(day_str,   2) ||\n        !only_digits(year_str,  4))\n        return false;\n\n    // convert to integer\n    int month = std::stoi(month_str);\n    int day   = std::stoi(day_str);\n    int year  = std::stoi(year_str);   // year is not restricted in the spec\n\n    // 3. month must be 1\u201112\n    if (month < 1 || month > 12) return false;\n\n    // 2. day bounds per month\n    // maximum days in each month\n    static const int max_day_per_month[13] = {\n        0, // dummy for 0\u2011index\n        31, // January\n        29, // February (leap\u2011year allowed \u2013 29 max)\n        31, // March\n        30, // April\n        31, // May\n        30, // June\n        31, // July\n        31, // August\n        30, // September\n        31, // October\n        30, // November\n        31  // December\n    };\n\n    if (day < 1 || day > max_day_per_month[month]) return false;\n\n    // All checks passed \u2013 the date is valid\n    return true;\n}\n```\n\n### How It Works\n\n1. **Empty Check** \u2013 The function immediately rejects an empty string.  \n2. **Format Check** \u2013 We require the string to be exactly 10 characters long with `'-'` at positions 2 and 5.  \n3. **Digit Verification** \u2013 Each part (`mm`, `dd`, `yyyy`) must contain only digits, so no letters or invisible characters slip through.  \n4. **Conversion** \u2013 Convert the parts to integers with `std::stoi`.  \n5. **Month Range** \u2013 The month must be between 1 and 12.  \n6. **Day Range** \u2013 A lookup table gives the maximum allowed days for each month (31, 30, 29 for February). The day must lie within `1 \u2013 max`.  \n7. **Result** \u2013 Return `true` if every check succeeds, otherwise `false`.  \n\nThis implementation is efficient, clear, and fully meets the specification you provided.", "Here\u2019s a compact, readable implementation that follows all the rules you listed:\n\n```cpp\n#include <cctype>\n#include <string>\n\nbool isLeapYear(int y)\n{\n    return (y % 4 == 0 && y % 100 != 0) || (y % 400 == 0);\n}\n\nbool valid_date(const std::string& date)\n{\n    // 1. Not empty\n    if (date.empty())\n        return false;\n\n    // 4. Format must be mm-dd-yyyy\n    //  Expected length 10, '-' at positions 2 and 5\n    if (date.size() != 10 || date[2] != '-' || date[5] != '-')\n        return false;\n\n    // Helper lambda to parse a substring to int (throws on non\u2011digits)\n    auto parse_int = [](const std::string& s, size_t p, size_t l) -> int {\n        int val = 0;\n        for (size_t i = 0; i < l; ++i)\n        {\n            char c = s[p + i];\n            if (!std::isdigit(c))\n                return -1;              // indicator of failure\n            val = val * 10 + (c - '0');\n        }\n        return val;\n    };\n\n    int month = parse_int(date, 0, 2);\n    int day   = parse_int(date, 3, 2);\n    int year  = parse_int(date, 6, 4);\n\n    if (month < 0 || day < 0 || year < 0)\n        return false;       // non\u2011digit found\n\n    // 3. Month in 1\u201312\n    if (month < 1 || month > 12)\n        return false;\n\n    // 2. Day limits\n    int max_day = 31;\n    switch (month)\n    {\n        case 4: case 6: case 9: case 11: max_day = 30; break;\n        case 2: max_day = isLeapYear(year) ? 29 : 28; break;\n    }\n    return day >= 1 && day <= max_day;\n}\n```\n\n### How it works\n\n1. **Empty string** \u2013 immediately rejects.\n2. **Format check** \u2013 verifies the string is exactly 10 characters, with `-` separators at positions 2 and 5.\n3. **Parsing** \u2013 the helper lambda reads the numeric parts, returning `-1` if any non\u2011digit is encountered.\n4. **Month & day validation** \u2013 checks the month range and calculates the maximum valid day for that month (considering leap years for February).\n\nYou can use the function like this:\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::cout << std::boolalpha;\n    std::cout << valid_date(\"03-11-2000\") << \"\\n\"; // true\n    std::cout << valid_date(\"15-01-2012\") << \"\\n\"; // false\n    std::cout << valid_date(\"04-0-2040\")  << \"\\n\"; // false\n    std::cout << valid_date(\"06-04-2020\") << \"\\n\"; // true\n    std::cout << valid_date(\"06/04/2020\") << \"\\n\"; // false\n}\n```\n\nThis implementation is efficient, easy to read, and covers all edge\u2011cases described in the problem statement."]}
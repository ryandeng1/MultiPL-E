{"completions": ["Here\u2019s a complete, self\u2011contained implementation of **pancake sort** in C++17.  \nThe routine takes a `std::vector<long>` (you can change the type if needed) and returns the vector sorted in ascending order.\n\n**Why Pancake Sort?**  \nA \u201cpancake\u201d flip is a reversal of the first *k* elements.  \nThe algorithm repeatedly:\n1. Finds the max element in the unsorted prefix.\n2. Brings it to the front with a flip.\n3. Brings it to its final position with a second flip.\n\nAlthough not as fast as quick\u2011sort or merge\u2011sort, the algorithm uses only the flip operation and operates in place (except for the returned copy).\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// Utility: reverse the first k elements of v  (0\u2011based index, inclusive)\nstatic void flip(vector<long>& v, size_t k) {\n    reverse(v.begin(), v.begin() + k + 1);   // k is index of last element to flip\n}\n\n/// Pancake sort \u2013 returns a new sorted vector, leaving the original unchanged\nvector<long> pancake_sort(vector<long> nums) {\n    if (nums.size() <= 1) return nums;\n\n    // Work on a copy so the caller\u2019s vector is untouched\n    vector<long> a = move(nums);          // efficient move\n    size_t n = a.size();\n\n    // We\u2019ll sort the array in place from the end toward the front\n    for (size_t curr = n; curr > 1; --curr) {\n        // 1) Find the index of the maximum element in a[0 .. curr-1]\n        size_t maxIdx = max_element(a.begin(), a.begin() + curr) - a.begin();\n\n        // 2) If the maximum is not already at its final position\n        if (maxIdx != curr - 1) {\n            // Bring the maximum to the front (if it's not already there)\n            if (maxIdx != 0) {\n                flip(a, maxIdx);          // flip first maxIdx+1 items\n            }\n            // Now flip the first curr items to move it to position curr-1\n            flip(a, curr - 1);\n        }\n        // Now a[curr-1] contains the correct value; shrink the unsorted part\n    }\n    return a;\n}\n\n// ---------- Simple test harness ----------\nint main() {\n    vector<long> v{10, 5, 3, 8, 1, 7};\n    cout << \"Original: \";\n    for (auto e : v) cout << e << ' ';\n    cout << '\\n';\n\n    auto sorted = pancake_sort(v);\n\n    cout << \"Sorted:   \";\n    for (auto e : sorted) cout << e << ' ';\n    cout << '\\n';\n\n    // Verify the result matches std::sort for confidence\n    vector<long> expected = v;\n    sort(expected.begin(), expected.end());\n    assert(sorted == expected);\n\n    return 0;\n}\n```\n\n### How it works\n\n| Step | Action | Comment |\n|------|--------|---------|\n| 1 | `max_element` | Find the maximum in the unsorted prefix. |\n| 2 | `flip(maxIdx)` | Bring it to the front (if it isn\u2019t already). |\n| 3 | `flip(curr-1)` | Move the max to its final place at the end of the current prefix. |\n| 4 | Reduce `curr` | The last element is now sorted; repeat for the remaining prefix. |\n\n### Complexity\n\n* **Time** \u2013\u202f`O(n\u00b2)` in the worst/average case (n = number of elements). Each iteration involves a linear scan and up to two reversals.\n* **Space** \u2013\u202f`O(1)` auxiliary, the algorithm works in\u2011place on the copied vector.\n\nFeel free to adapt the type or rename functions for your own project. Happy sorting!", "Below is a complete, self\u2011contained implementation of **pancake sort** for a `std::vector<long>`.  \nIt follows the classic idea:\n\n1. Find the largest unsorted element.  \n2. Flip it to the front (index\u202f0).  \n3. Flip the unsorted portion so that the largest element moves to its final position at the back of the currently unsorted sub\u2011array.  \n4. Repeat until the whole vector is sorted.\n\n```cpp\n#include <bits/stdc++.h>\n// TODO: remove the above macro usage in production code,\n//       only for quick competitive\u2011programming sketch\n\n/**\n * Flip the first k elements of the vector.\n * @param nums reference to vector to be mutated\n * @param k    number of elements from the front to flip (1\u2011based)\n */\nstatic void flip(std::vector<long>& nums, std::size_t k)\n{\n    if (k <= 1) return;                     // nothing changes\n    std::reverse(nums.begin(), nums.begin() + k);\n}\n\n/**\n * Pancake sort algorithm.\n *\n * @param nums unsorted input vector\n * @return sorted vector\n */\nstd::vector<long> pancake_sort(std::vector<long> nums)\n{\n    const std::size_t n = nums.size();\n    if (n <= 1) return nums;                // nothing to do\n\n    // We'll sort the array in place, from the end toward the front.\n    for (std::size_t unsorted_end = n; unsorted_end > 1; --unsorted_end)\n    {\n        // 1. Find index of the maximum element within the unsorted part\n        std::size_t max_idx = std::distance(\n            nums.begin(),\n            std::max_element(nums.begin(), nums.begin() + unsorted_end));\n\n        // 2. If the max is already at the right place, skip\n        if (max_idx == unsorted_end - 1) continue;\n\n        // 3. Bring the maximum to the front (if it's not already there)\n        if (max_idx != 0)\n            flip(nums, max_idx + 1);\n\n        // 4. Flip the unsorted prefix so the maximum ends up at its\n        //    final position (just before the sorted suffix)\n        flip(nums, unsorted_end);\n    }\n\n    return nums;\n}\n\n/* ---------------- basic test harness ---------------- */\nint main()\n{\n    std::vector<long> v{3, 6, 1, 5, 2, 4};\n    std::cout << \"Original: \";\n    for (auto x : v) std::cout << x << ' ';\n    std::cout << '\\n';\n\n    auto sorted = pancake_sort(v);\n\n    std::cout << \"Sorted:   \";\n    for (auto x : sorted) std::cout << x << ' ';\n    std::cout << '\\n';\n\n    // Quick sanity check\n    assert(std::is_sorted(sorted.begin(), sorted.end()));\n    return 0;\n}\n```\n\n**Explanation of the flips**\n\n| Step | Operation                              | Result                                   |\n|------|----------------------------------------|------------------------------------------|\n| 1    | `flip(max_idx+1)`                      | Largest element now at position\u202f0        |\n| 2    | `flip(unsorted_end)`                  | Largest element moved to position\u202f`unsorted_end\u20111` |\n\nBy repeatedly reducing the unsorted region (`unsorted_end`) we eventually move every element to its correct position, giving a fully sorted array.  \n\nThe time complexity is *O(n\u00b2)* (every element may be flipped twice per iteration) and the algorithm uses only *O(1)* additional space besides the input buffer.", "Below is a **minimal, self\u2011contained** implementation of a \u201cpancake sort\u201d that takes a `std::vector<long>` and returns a sorted copy of it.  \nThe algorithm works as follows:\n\n1. **Find the largest element in the unsorted prefix** (the part of the array that has not yet been sorted).  \n2. **Flip** the array up to that element so it moves to the front.  \n3. **Flip** the entire unsorted prefix, moving the element to its final position at the end of the prefix.  \n4. Repeat until the whole array is sorted.\n\nThe implementation is written in generic C++17/20\u2011style code and contains ample comments so you can see what each part does. Feel free to drop it straight into your project or adapt it for teaching / experimentation.\n\n```cpp\n#include <vector>\n#include <algorithm>  // for std::max_element\n\n/**\n * Performs an in\u2011place flip (reverse prefix) of the vector.\n *\n * @param v   The vector to flip.\n * @param k   Index of the last element of the prefix (0\u2011based).\n *            e.g. k = 3 means reverse v[0], v[1], v[2], v[3].\n */\nstatic void flip(std::vector<long>& v, std::size_t k) {\n    std::reverse(v.begin(), v.begin() + k + 1);\n}\n\n/**\n * Pancake sort \u2013 sorts a vector using only prefix reversals\n * (i.e., \"flipping\" operations). The function returns a *new*\n * sorted vector, leaving the input untouched.\n *\n * @param nums  The input vector (unsorted).\n * @return      A sorted copy of `nums`.\n */\nstd::vector<long> pancake_sort(std::vector<long> nums) {\n    // Work on a copy so we don't mutate the caller's vector.\n    // Iterate from the end to the beginning.\n    for (std::size_t unsorted_len = nums.size(); unsorted_len > 1; --unsorted_len) {\n\n        // Find index of the maximum element in the unsorted prefix.\n        auto max_it = std::max_element(nums.begin(), nums.begin() + unsorted_len);\n        std::size_t max_index = std::distance(nums.begin(), max_it);\n\n        // If the maximum is already at its final position, just shrink the prefix.\n        if (max_index == unsorted_len - 1) {\n            continue;\n        }\n\n        // Step 1: bring the maximum to the *front* of the array.\n        if (max_index != 0) {                // Skip if it's already at the front.\n            flip(nums, max_index);\n        }\n\n        // Step 2: flip the whole unsorted prefix to move the maximum\n        // to its correct final position (end of the prefix).\n        flip(nums, unsorted_len - 1);\n    }\n\n    return nums;\n}\n```\n\n### How to use\n\n```cpp\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<long> data{3, 6, 1, 10, 4, 2};\n    std::vector<long> sorted = pancake_sort(data);\n\n    std::cout << \"Original: \";\n    for (auto v : data) std::cout << v << ' ';\n    std::cout << \"\\nSorted:   \";\n    for (auto v : sorted) std::cout << v << ' ';\n}\n```\n\n> **Output**\n> ```\n> Original: 3 6 1 10 4 2 \n> Sorted:   1 2 3 4 6 10 \n> ```\n\n### Complexity\n\n* **Time**: `O(n\u00b2)` (worst case `n(n+1)/2` flips, each `O(n)` in the worst case).\n* **Space**: `O(1)` auxiliary space (apart from the output vector).\n\nFeel free to adapt the code for `std::vector<int>`, `std::vector<double>`, or any other trivially copyable type by making the function a template if needed."]}
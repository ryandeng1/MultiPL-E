{"completions": ["Here\u2019s a straightforward implementation of `modp` that computes \\((2^n) \\bmod p\\) safely, even for large values of `n`.  \nIt uses **binary exponentiation** (also called exponentiation\u2011by\u2011squaring), which runs in \\(O(\\log n)\\) time and keeps all intermediate numbers within the range of `long` by repeatedly taking the modulus.\n\n```cpp\n// Compute (2^n) % p\n// 0^0 is treated as 1 (consistent with the examples)\nlong modp(long n, long p) {\n    if (p == 1) return 0;          // everything mod 1 is 0\n    if (n == 0) return 1 % p;      // 2^0 = 1\n\n    long result = 1 % p;           // current result, start with 2^0\n    long base   = 2 % p;           // base of the exponentiation (2)\n\n    long exp = n;\n    while (exp > 0) {\n        if (exp & 1)                 // if the current bit of n is 1\n            result = (result * base) % p;\n        base = (base * base) % p;   // square the base for next bit\n        exp >>= 1;\n    }\n    return result;\n}\n```\n\n### Why this works\n1. **Binary exponentiation** breaks the exponent `n` into bits, reducing the number of multiplications to at most `log2(n)` steps.\n2. All intermediate multiplications are taken modulo `p`, so the values never overflow a `long` (assuming typical `long` ranges on your platform).\n\n### Quick test with the provided examples\n```cpp\n#include <iostream>\nint main() {\n    std::cout << modp(3,   5) << '\\n';   // 3\n    std::cout << modp(1101, 101) << '\\n'; // 2\n    std::cout << modp(0,   101) << '\\n'; // 1\n    std::cout << modp(3,   11) << '\\n';   // 8\n    std::cout << modp(100, 101) << '\\n'; // 1\n}\n```\n\nAll outputs match the expected results from the comments.", "Here is a quick and robust implementation \u2013 it uses fast exponentiation (binary exponentiation) so even very large exponents are handled efficiently in \\(O(\\log n)\\) time.\n\n```cpp\n#include <cassert>\n#include <bits/stdc++.h>\n/*\n   Return 2^n modulo p.\n   The function works for any non\u2013negative n and\n   any positive modulus p (p>0).  The time complexity\n   is O(log n) and it never overflows thanks to\n   the intermediate modular multiplications.\n*/\nlong modp(long n, long p) {\n    if (p == 1) return 0;                // everything mod 1 is 0\n    long long base = 2 % p;              // 2 mod p\n    long long result = 1 % p;            // start with 1 (2^0)\n    while (n > 0) {\n        if (n & 1)                       // if n is odd\n            result = (result * base) % p;\n        base = (base * base) % p;        // square the base\n        n >>= 1;                         // shift right\n    }\n    return static_cast<long>(result);\n}\n\nint main() {\n    assert(modp(3, 5) == 3);\n    assert(modp(1101, 101) == 2);\n    assert(modp(0, 101) == 1);\n    assert(modp(3, 11) == 8);\n    assert(modp(100, 101) == 1);\n    std::cout << \"All tests passed.\\n\";\n}\n```\n\n### Explanation\n\n- **Base case**:  \n  `2 % p` is the starting base; `1 % p` is the neutral element for multiplication.\n\n- **Loop**:  \n  We traverse the binary representation of `n`.  \n  Whenever a bit is `1`, we multiply the current result by the current base.  \n  Afterwards we square the base and continue.\n\n- **Modular multiplication**:  \n  All intermediate products are taken modulo `p`, so no overflow occurs even when `p` is large (within the range of `long long`).\n\n- **Edge cases**:  \n  * When `p==1`, every number modulo 1 is 0.  \n  * When `n==0`, the loop is skipped and we correctly return `1 % p`.\n\nFeel free to integrate this into your codebase.", "Here is a simple and safe implementation of `modp` that returns  \n\n\\[\n\\text{modp}(n,p)\\;=\\;\\;2^n\\pmod{p},\n\\]\n\nusing (iterative) binary exponentiation and 128\u2011bit multiplication to avoid overflow.\n\n```cpp\n#include <stdint.h>  // for uint64_t, uint128_t (via __int128)\n\n// Return 2^n modulo p.  Assumes p > 0.  Works for very large n.\nlong long modp(long long n, long long p) {\n    if (p == 1) return 0;                 // everything mod 1 is 0\n    if (n < 0) return 0;                  // undefined for negative exponents\n\n    long long result = 1 % p;             // 2^0 == 1\n    long long base   = 2 % p;             // the base is always 2\n\n    while (n > 0) {\n        if (n & 1) {\n            // (result * base) % p  \u2013 use 128\u2011bit intermediate to stay safe\n            result = (__int128)result * base % p;\n        }\n        // square the base for the next bit\n        base = (__int128)base * base % p;\n        n >>= 1;\n    }\n    return result;\n}\n```\n\n### Why this works safely\n\n* **Binary exponentiation** (also called exponentiation by squaring) reduces the number of multiplications from \\(O(n)\\) to \\(O(\\log n)\\), which is essential for large `n`.\n* Multiplying two 64\u2011bit numbers may overflow a 64\u2011bit type.  Using `__int128` (available on GCC/Clang/ICC/Clang\u201164) allows us to hold the intermediate product safely before taking the modulo.\n* The function is robust for all `p > 0`; for `p == 1` it returns `0`, matching the mathematical convention that any number mod\u202f1 is 0.\n\nYou can now use it in your examples:\n\n```cpp\nassert(modp(3,   5) == 3);\nassert(modp(1101, 101) == 2);\nassert(modp(0,   101) == 1);\nassert(modp(3,   11) == 8);\nassert(modp(100, 101) == 1);\n```\n\nFeel free to adapt the function signature (`int64_t`, `unsigned long long`, etc.) to your needs."]}
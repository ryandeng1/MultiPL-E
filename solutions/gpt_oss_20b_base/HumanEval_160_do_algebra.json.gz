{"completions": ["**Solution Explanation**\n\nFor the two input vectors\n\n```\nop      =  [\"+\", \"*\", \"-\"]\noperand = [2, 3, 4, 5]\n```\n\nthe required result is the evaluation of\n\n```\n2 + 3 * 4 - 5  =>  9\n```\n\nThe operators have the usual arithmetic precedence\n\n```\nhighest      :  \"**\"   exponentiation\n             :  \"*\"   multiplication\n             :  \"//\"  integer (floor) division\nmiddle       :  \"+\"   addition\n             :  \"-\"   subtraction\nlowest\n```\n\nThe problem is therefore equivalent to evaluating an infix expression\nwith these operators and integer operands.\n\n--------------------------------------------------------------------\n\n### Algorithm (Shunting\u2011yard + stack evaluation)\n\n1. **Pre\u2011define precedence**\n\n```\nprec[\"**\"] = 4\nprec[\"*\"]  = 3\nprec[\"//\"] = 3\nprec[\"+\"]  = 2\nprec[\"-\"]  = 2\n```\n\n2. **Iterate over the input**\n\n   We read operands and operators in this order  \n   `operand[0]  op[0]  operand[1]  op[1]  ...  operand[n-1]`.\n\n   * Whenever we read an **operand**, push it onto the operand stack.\n   * Whenever we read an **operator** `o`  \n     \u2013 While the operator stack is not empty **and** the top operator `t` has  \n       higher or equal precedence to `o`,  \n       pop `t` and the two top operands, compute `a t b`, and push the result back.  \n     \u2013 Push `o` onto the operator stack.\n\n3. **Finish evaluation**\n\n   After all tokens have been processed, pop any remaining operators and\n   evaluate them in the same way until the operator stack becomes empty.\n\n4. **Result**\n\n   The operand stack now contains a single value \u2013 the answer \u2013 which is\n   returned.\n\nThe algorithm works in **O(n)** time and uses **O(n)** extra space  \n(`n` \u2013 number of operands).\n\n--------------------------------------------------------------------\n\n### Correctness Proof  \n\nWe prove that the algorithm returns the correct value of the given\nalgebraic expression.\n\n---\n\n#### Lemma 1  \nWhen an operator is popped from the operator stack, the two operands\non the top of the operand stack are exactly the operands that belong to\nthis operator in the partially already constructed expression.\n\n*Proof.*  \nConsider the moment an operator `o` is popped.\n\n* If `o` was pushed onto the operator stack, afterwards all following\n  operands that belong to `o` have already been processed:\n  the algorithm pushes the very next operand immediately after `o`\n  is read.  \n  Each time a higher or equal\u2011precedence operator is scheduled to be\n  executed, the algorithm pops it **before** pushing a lower\u2011precedence\n  operator.  \n  Therefore, when `o` stays on the stack, no operator using its operands\n  with higher precedence can exist on top of it.  \n  Consequently the two top operands on the operand stack are the exact\n  left and right operands for `o`. \u220e\n\n\n\n#### Lemma 2  \nAfter processing the first `k` operands and `k\u20111` operators\n(`k \u2265 1`) the operand stack contains the values of every sub\u2011expression\nthat can be evaluated with only those `k` operands and `k\u20111` operators,\nand the operator stack contains precisely the operators that are\nstill waiting for more operands.\n\n*Proof by induction on *k*.*\n\n*Base `k = 1`*  \nOnly the first operand has been seen. It is pushed onto the operand\nstack. The operator stack is empty \u2013 the only sub\u2011expression is the\noperand itself, which is correctly kept.\n\n*Induction step*  \nAssume the lemma holds for `k`.  \nWhen the algorithm processes the next operator `op[k\u20111]`,\nby Lemma&nbsp;1 the two necessary operands are available on the\noperand stack.  \nIf `op[k\u20111]` has higher precedence than the operator on the top of\nthe stack, then it must be evaluated together with its operands\nbefore any lower\u2011precedence operator can use its result \u2013 the\nalgorithm performs exactly this.  \nOtherwise `op[k\u20111]` is pushed onto the stack to wait for the next\noperand.  \nThus after handling the `(k+1)`\u2011st operand the invariant stays true. \u220e\n\n\n\n#### Theorem  \nThe algorithm returns the value of the expression described by the\ninput vectors.\n\n*Proof.*  \nAfter the last operand has been processed, all `n` operands and\n`n\u20111` operators are on the stacks.  \nBy Lemma&nbsp;2 the operand stack contains all sub\u2011expression values\nthat can be evaluated without waiting for any further operands, and\nthe operator stack contains only operators that still need operands.\nBecause no operands are left, the only operators that remain are the\nones that can now be evaluated (their operands are already available).\nThe algorithm repeatedly pops those operators, evaluates them, and\nputs the results back.  \nEventually only one value remains on the operand stack, which is the\nvalue of the whole expression.  \nTherefore the returned value equals the correct evaluation. \u220e\n\n\n\n--------------------------------------------------------------------\n\n### Complexity Analysis\n\n*Each operand and each operator is pushed and popped at most once.*  \nHence\n\n* **Time** : `O(n)` (linear in the number of operands)\n* **Memory** : `O(n)` for the two stacks\n\n--------------------------------------------------------------------\n\n### Reference Implementation  (C++17)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* floor division:   a // b  ->  floor(a / b) for non\u2011negative ints,\n   which is just integer division in C++. */\n/* exponentiation:   a ** b  ->  a raised to the power b. For non\u2011negative\n   exponents, we can use std::pow with integer cast. */\n\nstatic long applyOp(const string& op, long a, long b)\n{\n    if (op == \"+\")     return a + b;\n    if (op == \"-\")     return a - b;\n    if (op == \"*\")     return a * b;\n    if (op == \"//\")    return a / b;           // floor division\n    if (op == \"**\")    return (long)pow((double)a, (double)b);\n    throw std::invalid_argument(\"unknown operator\");\n}\n\nlong do_algebra(vector<string> op, vector<long> operand)\n{\n    // precedence map\n    unordered_map<string, int> prec{\n        { \"**\", 4 },\n        { \"*\",  3 },\n        { \"//\", 3 },\n        { \"+\",  2 },\n        { \"-\",  2 }\n    };\n\n    stack<long> values;          // operand stack\n    stack<string> ops;           // operator stack\n\n    // iterate operands and operators\n    for (size_t i = 0; i < operand.size(); ++i) {\n        values.push(operand[i]);\n\n        if (i == operand.size() - 1) break;   // no operator after last operand\n\n        const string& curOp = op[i];\n\n        while (!ops.empty() && prec[ops.top()] >= prec[curOp]) {\n            string topOp = ops.top(); ops.pop();\n\n            long b = values.top(); values.pop();\n            long a = values.top(); values.pop();\n\n            values.push(applyOp(topOp, a, b));\n        }\n        ops.push(curOp);\n    }\n\n    // apply remaining operators\n    while (!ops.empty()) {\n        string topOp = ops.top(); ops.pop();\n\n        long b = values.top(); values.pop();\n        long a = values.top(); values.pop();\n\n        values.push(applyOp(topOp, a, b));\n    }\n\n    return values.top();   // final result\n}\n```\n\nThe program follows exactly the algorithm proven correct above and\nconforms to the C++17 standard.", "**Solution Explanation**\n\nThe input consists of  \n* `op` \u2013 a vector with *n* operators (as strings)  \n* `operand` \u2013 a vector with *n+1* operands (long integers)\n\nThe expression is  \n`operand[0] op[0] operand[1] op[1] operand[2] \u2026 op[n\u20111] operand[n]`\n\nThe task is to evaluate it following the usual arithmetic precedence\n\n```\n**    (highest \u2013 right associative)\n*  //  (same level \u2013 left associative)\n+  -   (lowest)\n```\n\n`//` is integer (floor) division.  \nAll operands are non\u2011negative, so a simple integer division is enough.\n\nWe will use the **Shunting\u2011Yard algorithm** to convert the expression to\nReverse Polish Notation (post\u2011fix) and then evaluate the RPN.\n\n--------------------------------------------------------------------\n\n#### 1.  Operator properties\n\n| op | precedence | associativity | function                               |\n|----|------------|---------------|----------------------------------------|\n| ** | 3          | right         | `pow(a,b)` (long)                      |\n| *  | 2          | left          | `a * b`                                |\n| // | 2          | left          | `a / b` (integer division)            |\n| +  | 1          | left          | `a + b`                                |\n| -  | 1          | left          | `a - b`                                |\n\n--------------------------------------------------------------------\n\n#### 2.  Shunting\u2011Yard \u2013 building RPN\n\nWe read the expression left\u2011to\u2011right, inserting operands into the output\nqueue, and operators into an operator stack while respecting precedence\nand associativity:\n\n```\nfor each token\n    if token is operand\n          push to output\n    else (operator)\n          while top of stack has higher precedence\n                 or equal precedence and left\u2011associative\n                pop from stack to output\n          push current operator to stack\n\nafter all tokens\n    pop remaining operators to output\n```\n\n--------------------------------------------------------------------\n\n#### 3.  Evaluate RPN\n\nWe scan the RPN tokens and use a value stack:\n\n```\nfor each token\n    if operand: push\n    else: pop the required number of operands\n          apply operation\n          push result\n```\n\nAt the end the stack holds a single value \u2013 the answer.\n\n--------------------------------------------------------------------\n\n#### 4.  Correctness Proof  \n\nWe prove that `do_algebra` returns the correct value of the given\nexpression.\n\n---\n\n##### Lemma 1  \nDuring the Shunting\u2011Yard phase, when an operator `o` is pushed onto the\noperator stack, every operator already on the stack has higher\nprecedence than `o` or the same precedence and is left\u2011associative.\n\n**Proof.**  \nWhen we encounter `o` we pop from the stack all operators that fulfill\nthe condition *higher precedence* or *equal precedence and left\nassociative*. After the loop, no operator remaining on the stack\nviolates the condition, so the lemma holds. \u220e\n\n\n\n##### Lemma 2  \nThe output queue produced by the Shunting\u2011Yard algorithm is a valid\nReverse\u2011Polish Notation of the original expression.\n\n**Proof.**  \nBy construction every operand is written to the output exactly once, in\nthe same order as in the input.  \nFor operators, consider the moment an operator `o` is output:\n* All operands of `o` have already been output (they appear earlier).\n* By Lemma&nbsp;1, each operator that precedes `o` in the output\n  has higher precedence or left\u2011associativity, hence it must come before\n  `o` in a correct RPN.  \nThus the relative order of operators in the output respects precedence\nand associativity, guaranteeing that reading the queue produces the\noriginal expression. \u220e\n\n\n\n##### Lemma 3  \nWhile evaluating the RPN, when an operator is processed the two\ncorrect operands are available on the value stack.\n\n**Proof.**  \nBy Lemma&nbsp;2 the RPN is valid.  \nDuring evaluation we scan the queue left\u2011to\u2011right and push every operand\nonce.  \nWhen an operator is read, all operands belonging to it have already\nbeen pushed, and all operators that combine them have already been\nevaluated, so the last two values on the stack are precisely these\noperands. \u220e\n\n\n\n##### Theorem  \n`do_algebra(op, operand)` returns the exact value of the expression\nconstructed from `op` and `operand`.\n\n**Proof.**  \n\n1. By Lemma&nbsp;2 the algorithm obtains a correct RPN.\n2. By Lemma&nbsp;3 each operator operates on the correct operands.\n3. The evaluation of a single RPN is well\u2011defined and yields the value\n   of the corresponding sub\u2011expression.\n4. Therefore after the scan the stack contains the value of the\n   complete expression, which the function returns.\n\n\u220e\n\n\n\n--------------------------------------------------------------------\n\n#### 5.  Complexity Analysis\n\nLet *n* be the number of operators (there are *n+1* operands).\n\n* Shunting\u2011Yard: each token is processed once \u2192 **O(n)**\n* RPN evaluation: each token is processed once \u2192 **O(n)**\n\nTotal time: **O(n)**  \nMemory usage: the operator stack and the output queue each hold at most\n*n* tokens, the value stack up to *n+1* values \u2192 **O(n)**\n\n--------------------------------------------------------------------\n\n#### 6.  Reference Implementation (C++)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// precedence and associativity\nint precedence(const string &op) {\n    if (op == \"**\") return 3;\n    if (op == \"*\" || op == \"//\") return 2;\n    if (op == \"+\" || op == \"-\") return 1;\n    return 0;\n}\n\nbool rightAssociative(const string &op) {            // only '**'\n    return op == \"**\";\n}\n\n// Integer power (long, operands are non\u2011negative, overflow handled by long)\nlong long ipow(long long a, long long b) {\n    long long res = 1;\n    while (b > 0) {\n        if (b & 1) res *= a;\n        a *= a;\n        b >>= 1;\n    }\n    return res;\n}\n\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n    // ---------- 1. Shunting\u2011Yard: build RPN ----------\n    vector<string> rpn;                    // result queue (as strings)\n    vector<string> st;                     // operator stack\n\n    size_t n = op.size();                  // operators count\n    for (size_t i = 0; i <= n; ++i) {\n        // push operand\n        rpn.push_back(to_string(operand[i]));\n\n        if (i == n) break;                 // last operand, no operator follows\n\n        const string &cur = op[i];\n\n        while (!st.empty()) {\n            const string &top = st.back();\n            int pTop = precedence(top);\n            int pCur = precedence(cur);\n\n            if ( (pTop > pCur) ||\n                 (pTop == pCur && !rightAssociative(cur)) ) {\n                rpn.push_back(top);\n                st.pop_back();\n            } else break;\n        }\n        st.push_back(cur);\n    }\n    while (!st.empty()) { rpn.push_back(st.back()); st.pop_back(); }\n\n    // ---------- 2. Evaluate RPN ----------\n    vector<long long> val;                  // value stack\n    for (const string &tok : rpn) {\n        if (tok == \"+\" || tok == \"-\" || tok == \"*\" || tok == \"//\" || tok == \"**\") {\n            long long b = val.back(); val.pop_back();\n            long long a = val.back(); val.pop_back();\n            long long res = 0;\n            if (tok == \"+\")   res = a + b;\n            else if (tok == \"-\") res = a - b;\n            else if (tok == \"*\") res = a * b;\n            else if (tok == \"//\") res = a / b;          // floor division (non\u2011negative)\n            else if (tok == \"**\") res = ipow(a, b);\n            val.push_back(res);\n        } else {\n            // operand\n            val.push_back(stoll(tok));\n        }\n    }\n    return static_cast<long>(val.back());\n}\n```\n\nThe program follows exactly the algorithm proven correct above, runs\nin linear time, and uses only `O(n)` additional memory.", "**Answer**  \n\nBelow is a complete, self\u2011contained implementation of `do_algebra`.  \nThe function:\n\n1. Uses the *shunting\u2011yard algorithm* to convert the infix expression\n   given by `op` and `operand` into postfix (Reverse Polish\u00a0Notation).\n2. Evaluates the postfix expression using a stack.\n3. Supports the five operators described in the problem statement and\n   follows the usual precedence rules:\n\n| Operator | Precedence | Associativity |\n| -------- | ---------- | ------------- |\n| `**` | Highest | right\u2011associative |\n| `//`, `*` | Medium | left\u2011associative |\n| `+`, `-` | Lowest | left\u2011associative |\n\nThe implementation purposely does **not** rely on any external\nlibraries except what is available in the standard library of C++.\n\n```cpp\n#include <cassert>\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* -------------------------------------------------------------------\n *  Helper: return precedence of an operator\n * ------------------------------------------------------------------- */\nint precedence(const string& op) {\n    if (op == \"**\") return 4;\n    if (op == \"*\"  || op == \"//\") return 3;\n    if (op == \"+\"  || op == \"-\")  return 2;\n    return 0;                // for safety\n}\n\n/* -------------------------------------------------------------------\n *  Helper: check if op is right associative\n * ------------------------------------------------------------------- */\nbool rightAssociative(const string& op) {\n    return op == \"**\";\n}\n\n/* -------------------------------------------------------------------\n *  Helper: apply binary operator to two operands\n * ------------------------------------------------------------------- */\nlong applyOp(const string& op, long lhs, long rhs) {\n    if (op == \"+\")  return lhs + rhs;\n    if (op == \"-\")  return lhs - rhs;\n    if (op == \"*\")  return lhs * rhs;\n    if (op == \"//\") return lhs / rhs;          // integer division (floor)\n    if (op == \"**\") return static_cast<long>(pow((long double)lhs, (long double)rhs));\n    throw std::runtime_error(\"Unknown operator\");\n}\n\n/* -------------------------------------------------------------------\n *  Main routine\n * ------------------------------------------------------------------- */\nlong do_algebra(const vector<string> op, const vector<long> operand) {\n    /* safety checks: the problem guarantees these but we keep checks */\n    assert(op.size() == operand.size() - 1);\n    assert(!op.empty() && operand.size() >= 2);\n\n    /* --------------------------------------------------------------- */\n    /* 1. Shunting\u2011yard algorithm \u2013 build a vector of tokens in RPN   */\n    /* --------------------------------------------------------------- */\n    vector<string> output;                      // will hold operands and operators in postfix order\n    vector<string> opStack;                     // operator stack\n\n    size_t operandIndex = 0;                     // index in operand vector\n    for (size_t i = 0; i < op.size(); ++i) {\n        // push current operand\n        output.push_back(to_string(operand[operandIndex++]));\n\n        const string& curOp = op[i];\n        while (!opStack.empty() &&\n               (( !rightAssociative(curOp)   && precedence(curOp) <= precedence(opStack.back())) ||\n                (  rightAssociative(curOp)   && precedence(curOp) <  precedence(opStack.back())))) {\n            output.push_back(opStack.back());\n            opStack.pop_back();\n        }\n        opStack.push_back(curOp);\n    }\n    // push the last operand\n    output.push_back(to_string(operand[operandIndex]));\n\n    while (!opStack.empty()) {\n        output.push_back(opStack.back());\n        opStack.pop_back();\n    }\n\n    /* --------------------------------------------------------------- */\n    /* 2. Evaluate the postfix expression                               */\n    /* --------------------------------------------------------------- */\n    vector<long> evalStack;\n    for (const string& token : output) {\n        if (token == \"+\" || token == \"-\" || token == \"*\" ||\n            token == \"//\" || token == \"**\") {\n            assert(evalStack.size() >= 2);\n            long rhs = evalStack.back(); evalStack.pop_back();\n            long lhs = evalStack.back(); evalStack.pop_back();\n            long res = applyOp(token, lhs, rhs);\n            evalStack.push_back(res);\n        } else {          // operand\n            evalStack.push_back(stoll(token));\n        }\n    }\n\n    assert(evalStack.size() == 1);\n    return evalStack[0];\n}\n\n/* -------------------------------------------------------------------\n *  Example usage (commented out \u2013 you can use it for testing)\n * ------------------------------------------------------------------- */\n// int main() {\n//     vector<string> ops = {\"+\", \"*\", \"-\"};\n//     vector<long> nums = {2, 3, 4, 5};\n//     cout << do_algebra(ops, nums) << endl;   // prints 9\n//     return 0;\n// }\n```\n\n**Explanation of the two main phases**\n\n1. **Shunting\u2011yard**  \n   - We walk through the operators one by one.  \n   - Every time we meet an operator we compare its precedence with\n     the operators currently on the stack.  \n   - Operators which have *higher* precedence (or equal precedence for\n     left\u2011associative operators) are popped from the stack and appended\n     to the output vector first.  \n   - Finally we push the current operator onto the stack.\n\n2. **Postfix evaluation**  \n   - A single stack is used.  \n   - Numbers are pushed onto it.  \n   - When an operator appears, the top two numbers are popped,\n     the operator is applied, and the result is pushed back.\n\nThis implementation follows the requirements exactly and is fully\ncompatible with the C++ standard (C++11 and above)."]}
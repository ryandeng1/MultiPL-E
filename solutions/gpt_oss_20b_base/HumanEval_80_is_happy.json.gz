{"completions": ["Here\u2019s a minimal, self\u2011contained implementation of `is_happy` that follows the specification:\n\n```cpp\n#include <string>\n\nbool is_happy(const std::string& s) {\n    // Must have at least 3 characters\n    if (s.size() < 3) return false;\n\n    // Check every consecutive triplet\n    for (std::size_t i = 0; i + 2 < s.size(); ++i) {\n        char a = s[i],   b = s[i+1],   c = s[i+2];\n        if (a == b || a == c || b == c) {\n            return false;   // not all distinct\n        }\n    }\n    return true;   // all triplets satisfied\n}\n```\n\n### How it works\n\n1. **Length check** \u2013 If the string has fewer than 3 characters, it immediately fails.\n2. **Triplet loop** \u2013 Iterate over every index `i` such that the triplet `s[i], s[i+1], s[i+2]` exists.\n3. **Distinctness test** \u2013 If any two of the three characters are equal, the string is not *hapcpp*.\n4. **Return** \u2013 If no violations are found, the string is *hapcpp*.\n\nYou can now use `is_happy` in your program or run the examples given in the prompt to verify its correctness.", "Here is a clean implementation of `is_happy` that follows the requirements:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool is_happy(const string& s) {\n    // 1. Length check\n    if (s.size() < 3) return false;\n\n    // 2. Slide a window of size 3 over the string\n    for (size_t i = 0; i + 2 < s.size(); ++i) {\n        // 3 consecutive letters must be pairwise distinct\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n**Explanation**\n\n1. **Length check** \u2013 If the string contains fewer than three characters, it cannot satisfy the rule, so we return `false` immediately.\n2. **Sliding window** \u2013 The `for` loop moves a window of three characters from the start of the string to the end (`i + 2 < s.size()` ensures we never go past the last valid window).\n3. **Distinct check** \u2013 Inside the loop we compare each pair of letters in the window. If any two are equal, the string is not *hapcpp*, so we return `false`.\n4. If the loop finishes without finding a duplicate pair, every trio is unique, and we return `true`.\n\n**Test cases**\n\n```cpp\n#include <cassert>\nint main() {\n    assert(is_happy(\"a\") == false);\n    assert(is_happy(\"aa\") == false);\n    assert(is_happy(\"abcd\") == true);\n    assert(is_happy(\"aabb\") == false);\n    assert(is_happy(\"adb\") == true);\n    assert(is_happy(\"xyy\") == false);\n}\n```\n\nAll the given examples pass.\n\n\n\n", "Here is a concise implementation of the requested `is_happy` function:\n\n```cpp\n#include <string>\n\nbool is_happy(const std::string& s) {\n    // Length must be at least 3\n    if (s.size() < 3) return false;\n\n    // Every three consecutive characters must be distinct\n    for (size_t i = 0; i + 2 < s.size(); ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2])\n            return false;\n    }\n    return true;\n}\n```\n\n### Explanation\n\n1. **Length check** \u2013 A single `if` guarantees the minimal length requirement.  \n2. **Sliding window** \u2013 We iterate from index `0` to `size() - 3`. In each step we look at the three characters `s[i]`, `s[i+1]`, and `s[i+2]`.  \n3. **Distinctness check** \u2013 If any of the three are equal, the string cannot be *hapcpp* and we return `false`.  \n4. **All windows valid** \u2013 If we finish the loop, every window has distinct letters, so we return `true`.\n\n### Test cases\n\n```cpp\n#include <cassert>\n\nint main() {\n    assert(is_happy(\"a\") == false);\n    assert(is_happy(\"aa\") == false);\n    assert(is_happy(\"abcd\") == true);\n    assert(is_happy(\"aabb\") == false);\n    assert(is_happy(\"adb\") == true);\n    assert(is_happy(\"xyy\") == false);\n    return 0;\n}\n```\n\nCompile with a C++17\u2011or\u2011newer compiler (`g++ -std=c++17 -Wall`), and it should pass all assertions."]}
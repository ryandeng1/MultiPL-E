{"completions": ["Here\u2019s a small, self\u2011contained implementation of `is_prime` that satisfies the examples you provided.  \nIt correctly handles all edge cases (`0`, `1`, even numbers, negative numbers, etc.) and runs in \\(O(\\sqrt{n})\\) time for `long` values.\n\n```cpp\n#include <cassert>\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*  Return true iff n is a prime number.\n    Works for negative numbers, 0, 1, and any non\u2011negative long.\n*/\nbool is_prime(long n) {\n    if (n < 2) return false;                // 0, 1, negative \u2192 not prime\n    if (n % 2 == 0) return n == 2;          // even numbers\n    if (n % 3 == 0) return n == 3;          // divisible by 3\n\n    // At this point n is odd and not divisible by 2 or 3.\n    // Use 6k \u00b1 1 optimization: all primes > 3 are of this form.\n    for (long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0) return false;\n        if (n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\n/*  Test cases that were included in the prompt  */\nint main() {\n    assert(is_prime(6) == false);\n    assert(is_prime(101) == true);\n    assert(is_prime(11) == true);\n    assert(is_prime(13441) == true);\n    assert(is_prime(61) == true);\n    assert(is_prime(4) == false);\n    assert(is_prime(1) == false);\n\n    // You can add more tests if you want.\n    cout << \"All asserts passed.\\n\";\n    return 0;\n}\n```\n\n### Explanation of the algorithm\n\n1. **Base checks**  \n   - Any number `< 2` is not prime.  \n   - Even numbers (`% 2 == 0`) are handled immediately.  \n   - Similarly, multiples of 3 are checked.\n\n2. **6k \u00b1 1 loop**  \n   - After removing multiples of 2 and 3, every prime larger than 3 is of the form `6k \u00b1 1`.  \n   - We iterate with a step of 6, checking both `i` and `i + 2` (i.e., `6k - 1` and `6k + 1`).  \n   - The loop stops when `i*i` exceeds `n`, which guarantees all possible divisors have been tested.\n\n3. **Return**  \n   - If no divisor was found, the number is prime.\n\nThis implementation is efficient for `long` values (typically up to 9\u00d710\u00b9\u2078) and passes all the test cases you listed.", "Here is a straightforward implementation of `is_prime` that checks whether a given number `n` is prime:\n\n```cpp\nbool is_prime(long n) {\n    // 0, 1 and all even numbers greater than 2 are not prime\n    if (n < 2)            return false;\n    if (n % 2 == 0)       return n == 2;\n\n    // Only check odd divisors up to sqrt(n)\n    for (long i = 3; i * i <= n; i += 2) {\n        if (n % i == 0)   return false;\n    }\n    return true;\n}\n```\n\n**Explanation**\n\n1. **Edge cases**  \n   - Numbers less than 2 are not prime.  \n   - Even numbers greater than 2 are not prime (handled via `n % 2` check).\n\n2. **Divisor search**  \n   - After removing the even case, we only need to test odd divisors.\n   - The loop runs while `i*i <= n` which is equivalent to checking divisors up to `sqrt(n)`, giving the algorithm a time complexity of **O(\u221an)**.\n\n3. **Return**  \n   - If any divisor is found, the number is not prime.\n   - If the loop completes without finding a divisor, the number is prime.\n\nThis function will correctly produce the outputs you expect:\n\n```cpp\nis_prime(6);     // false\nis_prime(101);   // true\nis_prime(11);    // true\nis_prime(13441); // true\nis_prime(61);    // true\nis_prime(4);     // false\nis_prime(1);     // false\n```\n\nFeel free to use or adapt this implementation in your code!", "Here is a simple, efficient, and easy\u2011to\u2011understand implementation of `is_prime` that works for any 64\u2011bit signed integer:\n\n```cpp\n#include <cassert>\n#include <cstdint>\n#include <cmath>\n\n/**\n * @brief Checks whether a given integer is prime.\n *\n * The function works for signed 64\u2011bit integers (`int64_t`/`long` on most\n * platforms) and returns `true` if n is a prime number, `false` otherwise.\n *\n * @param n The integer to test.\n * @return `true` if n is prime, `false` otherwise.\n */\nbool is_prime(long n) {\n    // Handle non\u2011positive numbers and 1 explicitly.\n    if (n <= 1) return false;\n\n    // 2 and 3 are prime\n    if (n <= 3) return true;\n\n    // Eliminate even numbers and multiples of 3 early.\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    // Check only numbers of the form 6k \u00b1 1 up to sqrt(n).\n    for (long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n```\n\n### How it works\n\n1. **Small\u2011number checks**  \n   * Numbers \u2264\u202f1 are not prime.  \n   * 2 and 3 are handled immediately.\n\n2. **Even and multiples of 3**  \n   * Any even number greater than 2 and any number divisible by 3 are composite.\n\n3. **6k\u202f\u00b1\u202f1 optimization**  \n   All primes greater than 3 are of the form `6k\u202f\u00b1\u202f1`.  \n   We test divisibility by `i` and `i+2` (which correspond to `6k\u20111` and `6k+1`) while incrementing `i` by 6.\n\n4. **Loop bound**  \n   We stop when `i * i > n`; at that point, if we haven't found a divisor, `n` is prime.\n\n### Inline tests\n\n```cpp\nint main() {\n    assert(is_prime(6)   == false);\n    assert(is_prime(101) == true);\n    assert(is_prime(11)  == true);\n    assert(is_prime(13441) == true);\n    assert(is_prime(61)  == true);\n    assert(is_prime(4)   == false);\n    assert(is_prime(1)   == false);\n\n    // Additional checks\n    for (int i = 2; i <= 1000; ++i) {\n        bool expected = std::isprime(i); // if using C++20 <numeric>\n        assert(is_prime(i) == expected);\n    }\n\n    return 0;\n}\n```\n\nThis implementation is fast enough for everyday use and easy to integrate into your code base."]}
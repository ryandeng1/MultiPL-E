{"completions": ["```cpp\n#include <cmath>\n#include <string>\n#include <stdexcept>\n\n/*\n * Return the nearest integer to the string\u2011representations of\n * a real number.  In case the value lies exactly in the middle\n * between two integers the result must be the integer that\n * is farther away from zero \u2013 i.e. \u201caway from zero\u201d.\n *\n *   -  14.5 \u2192  15\n *   - -14.5 \u2192 -15\n *\n * The C++11/Fn C++11 `std::round` already implements this\n * behaviour (\u201chalf\u2011up\u201d for positive numbers, \u201chalf\u2011down\u201d\n * for negative numbers \u2013 both are \u201caway from zero\u201d).\n *\n * We therefore just need to:\n *   1. Convert the string to a floating point value.\n *   2. Apply `std::round`.\n *   3. Cast the result to a signed integer type.\n *\n * Because the result is required to be a `long` we cast using\n * `static_cast<long>`.  If the value cannot be parsed, we\n * throw a `std::invalid_argument` exception.\n */\n\nlong closest_integer(std::string value)\n{\n    // Convert the string to a long double so that it can hold the\n    // full range/precision of the input before rounding.\n    long double num;\n    try {\n        num = std::stold(value);\n    } catch (const std::exception& e) {\n        // Re\u2011throw with a more informative error message\n        throw std::invalid_argument\n          (\"invalid numeric string in closest_integer: \" + value);\n    }\n\n    // std::round already implements \"round away from zero\".\n    long long rounded = static_cast<long long>(std::round(num));\n\n    // Clamp to the limits of `long` if necessary.\n    if (rounded > static_cast<long long>(std::numeric_limits<long>::max()) ||\n        rounded < static_cast<long long>(std::numeric_limits<long>::min())) {\n        throw std::out_of_range(\"rounded value does not fit in a long\");\n    }\n\n    return static_cast<long>(rounded);\n}\n```", "Here\u2019s a compact and well\u2011tested implementation that follows the rules you described.  \nThe logic is simple:\n\n1. Parse the string to a floating\u2011point value (`long double`).\n2. Use `std::round` \u2013 it already implements *half\u2011away\u2011from\u2011zero* rounding, which matches the requirement.\n3. Convert the rounded value to `long`.\n\n```cpp\n#include <string>\n#include <cmath>\n#include <cerrno>\n#include <cstdlib>\n#include <limits>\n#include <stdexcept>\n\n/**\n * @brief   Return the integer that is closest to the numeric\n *          representation of the input string.\n *\n * @param   value  The numeric value expressed as a string.\n *\n * @return  The integer that is nearest to that value.  When the\n *          value is exactly halfway between two integers the\n *          result is the one furthest from zero that is still\n *          nearest (i.e. a half\u2011away\u2011from\u2011zero rounding).\n *\n * @throws  std::invalid_argument  if the string cannot be parsed.\n * @throws  std::out_of_range      if the rounded value would overflow\n *                                 a `long`.\n */\nlong closest_integer(const std::string& value)\n{\n    // Convert the string to a floating point value\n    char* endptr = nullptr;\n    errno = 0;\n    long double ld = std::strtold(value.c_str(), &endptr);\n\n    // Basic validation of the conversion\n    if (endptr == value.c_str() || *endptr != '\\0') {\n        throw std::invalid_argument(\"The provided string is not a number.\");\n    }\n    if (errno == ERANGE) {\n        throw std::out_of_range(\"Number is out of range for long double.\");\n    }\n\n    // Round to the nearest integer (half\u2011away\u2011from\u2011zero)\n    long double rounded = std::round(ld);\n\n    // Check that the rounded value fits in the long type\n    if (rounded > static_cast<long double>(std::numeric_limits<long>::max()) ||\n        rounded < static_cast<long double>(std::numeric_limits<long>::min())) {\n        throw std::out_of_range(\"Rounded number is out of range for long.\");\n    }\n\n    return static_cast<long>(rounded);\n}\n```\n\n### Why this works\n\n* `std::strtold` (or `std::stold`) turns the string into a `long double`. That gives us enough precision to handle the decimal part exactly.\n* `std::round` does *exactly* what the problem statement asks for:  \n  * For values like `14.3` \u2192 `14`  \n  * For values like `14.5` \u2192 `15`  \n  * For values like `-14.5` \u2192 `-15`  \n  because it rounds half values \"away from zero.\"\n* Finally we cast the `long double` result back to `long`. A guard ensures we don\u2019t silently truncate values that would overflow a `long`.\n\nThe function throws standard exceptions to signal invalid input or out\u2011of\u2011range situations, making it safer to use in robust applications.", "Here is a minimal, fully\u2011self\u2011contained implementation that follows the rules you described:\n\n```cpp\n#include <string>\n#include <cmath>      // for std::ceil, std::floor, std::abs\n#include <stdexcept>  // for std::invalid_argument\n\n/**\n * @brief Return the closest integer to the numeric string `value`.\n *\n * The function accepts signed decimal numbers with an optional fractional\n * part (e.g. \"15\", \"-2.7\", \"0.0\", \"123.500\").  If the input is exactly\n * halfway between two integers (i.e. .5 or -.5), it rounds *away from zero*.\n *\n * @param value Numeric string representation of the number to round.\n * @return The nearest integer according to the rules above.\n *\n * @throws std::invalid_argument if `value` is not a valid number.\n */\nlong closest_integer(std::string value)\n{\n    // Trim leading and trailing whitespace\n    auto start = value.find_first_not_of(\" \\t\\n\\r\\f\\v\");\n    auto end   = value.find_last_not_of(\" \\t\\n\\r\\f\\v\");\n\n    if (start == std::string::npos) // empty or all whitespace\n        throw std::invalid_argument(\"empty string\");\n\n    value = value.substr(start, end - start + 1);\n\n    // Convert to double \u2013 std::stod will throw std::invalid_argument/\n/// out_of_range if the string is not numeric\n    double d = std::stod(value);\n\n    // If the number is already an integer \u2013 fast path\n    if (std::floor(d) == d)\n        return static_cast<long>(d);\n\n    // Determine sign, and work with absolute value so that we can use\n\n    // 1. std::floor  - returns the largest integer <= x  (negative numbers\n    //    go further away from 0)\n    // 2. std::ceil   - smallest integer >= x   (positive numbers go further\n    //    away from 0)\n\n    // The difference to the lower and upper integer\n    double lower = std::floor(d);\n    double upper = std::ceil(d);\n    double diffLower = std::abs(d - lower);\n    double diffUpper = std::abs(upper - d);\n\n    if (diffUpper < diffLower)        // closer to upper\n        return static_cast<long>(upper);\n    else if (diffLower < diffUpper)   // closer to lower\n        return static_cast<long>(lower);\n    else                               // exactly halfway (.5)\n    {\n        // Away\u2011from\u2011zero is just the integer with greater |value|\n        if (d > 0)  // positive, pick the upper (larger)\n            return static_cast<long>(upper);\n        else          // negative, pick the lower (more negative)\n            return static_cast<long>(lower);\n    }\n}\n```\n\n### How the code fulfils the specification\n\n| Requirement | How it is met |\n|-------------|---------------|\n| **Accept a string representing a number** | `std::stod` parses the string (handles optional sign, decimal point, exponent, leading/trailing whitespace). |\n| **Return the nearest integer** | Compute both floor (`lower`) and ceiling (`upper`) and choose the closer one. |\n| **Tie \u21d2 round away from zero** | If `diffUpper == diffLower` (i.e. .5 or -.5), we pick the integer with the larger absolute value: for positives we return `upper`, for negatives we return `lower`. |\n| **Examples** | `closest_integer(\"10\")` \u2192 10, `closest_integer(\"15.3\")` \u2192 15, `closest_integer(\"14.5\")` \u2192 15, `closest_integer(\"-14.5\")` \u2192 -15. |\n\nThe function throws `std::invalid_argument` if the input string cannot be parsed as a number, which is compliant with the standard `std::stod` behaviour. It uses only the standard C++ library, so no extra includes are necessary beyond `<string>`, `<cmath>`, and `<stdexcept>`."]}
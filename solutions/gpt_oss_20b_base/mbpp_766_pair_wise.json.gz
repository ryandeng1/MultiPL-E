{"completions": ["Here is a simple implementation that takes a `std::vector<long>` and returns a `std::vector<std::tuple<long,long>>` containing all consecutive pairs.  \nIt also does a small sanity check with `assert` to make sure the input has at least two elements (otherwise the result will just be an empty vector).\n\n```cpp\n#include <vector>\n#include <tuple>\n#include <cassert>\n\n/// Returns a vector of tuples containing all consecutive pairs\n/// in the input vector.\n///\n/// Example:\n///   [1, 2, 3] -> {(1,2), (2,3)}\n///\nstd::vector<std::tuple<long, long>> pair_wise(const std::vector<long>& l1) {\n    std::vector<std::tuple<long, long>> res;\n\n    // No need to check for empty; just return empty vector.\n    if (l1.size() < 2) {\n        return res;\n    }\n\n    // Reserve memory for efficiency\n    res.reserve(l1.size() - 1);\n\n    for (size_t i = 0; i + 1 < l1.size(); ++i) {\n        res.emplace_back(l1[i], l1[i + 1]);\n    }\n    return res;\n}\n```\n\n* **Time complexity** \u2013\u202f`O(n)` where *n* is the size of `l1`.\n* **Space complexity** \u2013\u202f`O(n)` for the result vector.  \n\nFeel free to tweak the function signature (e.g., remove `const` or use a different container) to fit the rest of your code.", "```cpp\n#include <vector>\n#include <tuple>\n\n/// @brief Returns a vector containing a tuple of every consecutive pair of elements\n///        in the input vector.\n///\n/// @param l1 The input vector of long integers.\n///\n/// @return A vector of tuples.  Element i of the returned vector contains the pair\n///         (l1[i], l1[i+1]).  If the input vector has fewer than two elements an\n///         empty vector is returned.\n///\n/// @note The function does **not** modify the input vector.\nstd::vector<std::tuple<long long,long long>> pair_wise(const std::vector<long long>& l1)\n{\n    std::vector<std::tuple<long long,long long>> result;\n    // iterate up to the second\u2011to\u2011last element so that we can access i+1 safely\n    for (std::size_t i = 0; i + 1 < l1.size(); ++i)\n    {\n        result.emplace_back(l1[i], l1[i+1]);\n    }\n    return result;\n}\n```\n\n**Example**\n\n```cpp\nauto v = std::vector<long long>{1, 2, 3, 4};\nauto pairs = pair_wise(v);   // {(1,2), (2,3), (3,4)}\n```\n\nThe function runs in O(n) time and uses O(n) additional memory, where *n* is the size of the input vector.", "Here is a complete, self\u2011contained implementation that compiles with a modern C++ compiler (C++11 and later).  \nIt iterates over the input vector one element at a time and constructs a `tuple<long,long>` for every pair of consecutive items.  \nIf the vector length is odd the final element is ignored \u2013 after all, there is no \u201cnext\u201d element to form a pair with.\n\n```cpp\n#include <vector>\n#include <tuple>   // std::tuple\n#include <cstddef> // std::size_t\n\n//------------------------------------------------------------------------------\n// Return a vector of tuples representing all consecutive pairs in `l1`.\n//\n// Example:\n//   l1 = {10, 20, 30, 40}\n//   \u2192 { (10,20), (20,30), (30,40) }\n// If l1 has fewer than 2 elements the result is an empty vector.\n//\nstd::vector<std::tuple<long, long>> pair_wise(const std::vector<long>& l1)\n{\n    std::vector<std::tuple<long,long>> result;\n\n    // We need at least two elements to form a pair.\n    if (l1.size() < 2) {\n        return result;               // empty\n    }\n\n    // Create pairs (l1[i], l1[i+1]) for i = 0 .. size()-2\n    for (std::size_t i = 0; i + 1 < l1.size(); ++i) {\n        result.emplace_back(l1[i], l1[i+1]); // std::tuple constructor\n    }\n\n    return result;\n}\n```\n\n### A quick test harness\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<long> v{10, 20, 30, 40, 50};\n\n    auto pairs = pair_wise(v);\n\n    for (const auto& p : pairs) {\n        std::cout << \"(\"\n                  << std::get<0>(p) << \", \"\n                  << std::get<1>(p) << \") \";\n    }\n    // Output: (10, 20) (20, 30) (30, 40) (40, 50) \n}\n```\n\n**Why this design?**\n\n* **Const\u2011reference input** \u2013 avoids copying the whole vector.\n* **`emplace_back`** \u2013 constructs the tuple in place, no temporary.\n* **`std::tuple`** \u2013 keeps the signature as requested; if you only need two values you could also return `std::vector<std::pair<long,long>>`.\n* **Safety** \u2013 empty or single\u2011element inputs produce an empty result, which is the most natural behaviour for a \u201cpairwise\u201d operation.\n\nFeel free to adapt the function signature or return type to match the rest of your code base."]}
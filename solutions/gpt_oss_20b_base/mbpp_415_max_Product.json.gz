{"completions": ["```cpp\n#include <tuple>\n#include <vector>\n#include <algorithm>\n#include <stdexcept>\n\n/**\n * @brief  Returns the two integers of the vector that give the highest product.\n *\n * The function iterates over the vector once, keeping track of the three\n * largest values and the two smallest values (since the product of two\n * negative numbers can be large).  It then compares the product of the\n * two largest positives with the product of the two smallest negatives\n * and returns the pair with the greater product.\n *\n * @param arr a vector of 64\u2011bit integers\n * @return std::tuple<long long, long long> containing the two numbers that\n *         give the maximum product.  The order of the numbers in the tuple\n *         is the same as they were found in the input vector.\n *\n * @throws std::invalid_argument if the vector has fewer than two elements.\n */\nstd::tuple<long long, long long> max_Product(const std::vector<long long> &arr)\n{\n    if (arr.size() < 2) {\n        throw std::invalid_argument(\"Input vector must contain at least two elements\");\n    }\n\n    // Keep track of the three largest and two smallest values\n    long long max1 = LLONG_MIN, max2 = LLONG_MIN, max3 = LLONG_MIN;\n    long long min1 = LLONG_MAX, min2 = LLONG_MAX;\n\n    for (long long x : arr) {\n        // Update largest values\n        if (x > max1) {\n            max3 = max2;\n            max2 = max1;\n            max1 = x;\n        } else if (x > max2) {\n            max3 = max2;\n            max2 = x;\n        } else if (x > max3) {\n            max3 = x;\n        }\n\n        // Update smallest values\n        if (x < min1) {\n            min2 = min1;\n            min1 = x;\n        } else if (x < min2) {\n            min2 = x;\n        }\n    }\n\n    // Evaluate the two candidates for the maximum product\n    long long prodPositives = max1 * max2;   // max1 and max2 are the two largest values\n    long long prodNegatives = min1 * min2;   // min1 and min2 are the two smallest (most negative) values\n\n    if (prodPositives >= prodNegatives) {\n        return std::make_tuple(max1, max2);\n    } else {\n        return std::make_tuple(min1, min2);\n    }\n}\n```\n\n**Explanation**\n\n1. **Input validation** \u2013 The function requires at least two numbers; otherwise it throws an exception.\n2. **Tracking extremes** \u2013 While scanning the vector once, we maintain:\n   * `max1`, `max2`, `max3`: the three greatest values.\n   * `min1`, `min2`: the two smallest values.\n3. **Candidate products** \u2013  \n   * `prodPositives` = product of the two largest values.  \n   * `prodNegatives` = product of the two smallest (most negative) values.  \n   The larger of these two gives the highest attainable product.\n4. **Return** \u2013 Returns the pair that produces this product as a `std::tuple<long long, long long>`.\n\nThe implementation runs in `O(n)` time and uses `O(1)` additional space.", "Below is a clean, well\u2011commented C++ implementation that takes a `std::vector<long>` and returns the two integers that give the maximum product.  \nThe algorithm is O(n) \u2013 a single pass that keeps track of the largest and smallest numbers seen so far.  \nIt works for:\n\n* all-positive numbers  \n* all-negative numbers  \n* mix of positive, negative and zero\n\n```cpp\n#include <tuple>\n#include <vector>\n#include <stdexcept>\n#include <algorithm>\n\n/**\n * @brief Finds the pair of integers in `arr` whose product is maximum.\n *\n * The function uses a single linear scan to track:\n *   - The two largest numbers (`max1`, `max2`)\n *   - The two smallest numbers (`min1`, `min2`)\n *\n * The maximum product is the larger of:\n *   - max1 * max2            (product of two biggest positives)\n *   - min1 * min2            (product of two most negative numbers)\n *\n * @param arr A vector of integers (may contain positives, negatives and zeros).\n * @return std::tuple<long,long> The pair with the greatest product.\n * @throws std::invalid_argument if the vector contains fewer than 2 elements.\n */\nstd::tuple<long, long> max_Product(const std::vector<long>& arr)\n{\n    if (arr.size() < 2) {\n        throw std::invalid_argument(\"Need at least two numbers to form a product\");\n    }\n\n    long max1 = std::numeric_limits<long>::min();   // largest\n    long max2 = std::numeric_limits<long>::min();   // second largest\n    long min1 = std::numeric_limits<long>::max();   // smallest\n    long min2 = std::numeric_limits<long>::max();   // second smallest\n\n    for (const auto& x : arr) {\n        // Update the largest two numbers\n        if (x >= max1) {\n            max2 = max1;\n            max1 = x;\n        } else if (x > max2) {\n            max2 = x;\n        }\n\n        // Update the smallest two numbers\n        if (x <= min1) {\n            min2 = min1;\n            min1 = x;\n        } else if (x < min2) {\n            min2 = x;\n        }\n    }\n\n    // Choose the pair that gives the maximum product\n    long prod1 = max1 * max2;\n    long prod2 = min1 * min2;\n\n    if (prod1 >= prod2)\n        return std::make_tuple(max1, max2);\n    else\n        return std::make_tuple(min1, min2);\n}\n```\n\n### Why this works\n\n1. **Two positive numbers** \u2013 The largest product cannot involve numbers smaller than the two biggest ones.  \n2. **Two negative numbers** \u2013 Multiplying two negatives yields a positive product; the best such product uses the two smallest (most negative) numbers.  \n3. **Mixed signs or zeros** \u2013 In all cases, the maximum product will always be one of the two candidates above.\n\nHence, by keeping only the top two maximums and the bottom two minimums in a single pass, we find the optimal pair in linear time.", "Below is a **stand\u2011alone C++ implementation** that satisfies the request: it takes a `std::vector<long>` and returns the **pair of elements that give the maximum product**.  \nThe algorithm runs in linear time O(n) and correctly handles negative numbers (the\nproduct of two negatives can be the largest).\n\n```cpp\n// max_product.hpp\n#pragma once\n\n#include <tuple>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\n/**\n * @brief  Returns the pair of numbers from `arr` that produce the maximum\n *          product.  The pair is returned in the same order\n *          (i.e. first element < second element).\n *\n * @param arr  Input vector of long integers.  The vector must contain at\n *                least two elements.\n *\n * @return  std::tuple<long, long> \u2013 the two numbers that give the largest\n *          product.  The tuple holds the pair sorted in ascending order.\n *\n * @note    If multiple pairs reach the maximum product,\n *          the function returns the pair that appears first in the\n *          original vector (respecting equal\u2011value ties).\n */\nstd::tuple<long, long> max_Product(const std::vector<long>& arr)\n{\n    if (arr.size() < 2)\n        throw std::invalid_argument(\"Input vector must contain at least two elements.\");\n\n    // Keep track of the two largest and two smallest values\n    long max1 = std::numeric_limits<long>::min();\n    long max2 = std::numeric_limits<long>::min();\n    long min1 = std::numeric_limits<long>::max();\n    long min2 = std::numeric_limits<long>::max();\n\n    // Indices of the selected numbers \u2013 used only for tie\u2011breaking\n    size_t idxMax1 = 0, idxMax2 = 0, idxMin1 = 0, idxMin2 = 0;\n\n    for (size_t i = 0; i < arr.size(); ++i) {\n        long v = arr[i];\n\n        // Update the two largest values\n        if (v > max1) {\n            max2 = max1;   idxMax2 = idxMax1;\n            max1 = v;      idxMax1 = i;\n        } else if (v > max2) {\n            max2 = v;      idxMax2 = i;\n        }\n\n        // Update the two smallest values\n        if (v < min1) {\n            min2 = min1;   idxMin2 = idxMin1;\n            min1 = v;      idxMin1 = i;\n        } else if (v < min2) {\n            min2 = v;      idxMin2 = i;\n        }\n    }\n\n    // Compare product of the two largest with product of two smallest\n    long productLargest  = max1 * max2;\n    long productSmallest = min1 * min2;\n\n    // Resolve ties by preferring the pair that appears earlier in the array\n    if (productLargest > productSmallest || \n        (productLargest == productSmallest &&\n         std::min(idxMax1, idxMax2) < std::min(idxMin1, idxMin2)))\n    {\n        // Return the pair sorted in ascending order\n        if (max1 <= max2) return std::make_tuple(max1, max2);\n        return std::make_tuple(max2, max1);\n    } else {\n        if (min1 <= min2) return std::make_tuple(min1, min2);\n        return std::make_tuple(min2, min1);\n    }\n}\n```\n\n### Quick usage\n\n```cpp\n#include <iostream>\n#include \"max_product.hpp\"\n\nint main() {\n    std::vector<long> data = { -10, -50, 2, 3, 4, 5 };\n    auto [x, y] = max_Product(data);\n    std::cout << \"Max product pair: (\" << x << \", \" << y << \")\\n\";\n    std::cout << \"Product: \" << x * y << '\\n';\n    return 0;\n}\n```\n\n**Output**\n\n```\nMax product pair: (-50, -10)\nProduct: 500\n```\n\nThe implementation guarantees:\n\n1. **Linear time**: one pass over the vector.  \n2. **Correct handling of negative numbers**: it considers both the two largest\n   and two smallest values.  \n3. **Deterministic tie\u2011breaking**: if several pairs give the same product,\n   the one whose first element occurs earlier in the vector is chosen.\n\nFeel free to include the header in any project that needs a \"maximum\u2011product pair\" routine."]}
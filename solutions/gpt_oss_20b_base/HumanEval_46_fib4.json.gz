{"completions": ["Below is a compact, non\u2011recursive C++ implementation that follows the recurrence exactly  \nand works in *O(n)* time and *O(1)* additional memory.\n\n```cpp\n#include <iostream>\n\nlong fib4(long n)\n{\n    if (n < 0)           // make the function more robust\n        throw std::invalid_argument(\"n must be >= 0\");\n\n    // base values\n    if (n == 0 || n == 1) return 0;\n    if (n == 2)            return 2;\n    if (n == 3)            return 0;\n\n    // only the four most recent values are needed\n    long a = 0;   // fib4(n-4)\n    long b = 0;   // fib4(n-3)\n    long c = 2;   // fib4(n-2)\n    long d = 0;   // fib4(n-1)\n\n    for (long i = 4; i <= n; ++i) {\n        long next = a + b + c + d;   // fib4(i)\n        a = b;                       // shift window\n        b = c;\n        c = d;\n        d = next;\n    }\n    return d;   // at the end d == fib4(n)\n}\n\n// simple test harness\nint main() {\n    std::cout << fib4(5) << '\\n';  // 4\n    std::cout << fib4(6) << '\\n';  // 8\n    std::cout << fib4(7) << '\\n';  // 14\n}\n```\n\n**Why it works**\n\n* The recurrence only needs the previous four numbers, so we keep a sliding window of  \n  `f(n-4), f(n-3), f(n-2), f(n-1)`.  \n* At each iteration we compute `f(n)` as the sum of those four values, then shift the window by one position.  \n* For `n = 0\u20263` we return the hard\u2011coded initial values.  \n* The loop runs `n\u20113` times, giving linear time while using constant space.\n\nFeel free to copy this snippet into your project.", "**Solution Explanation**\n\nThe sequence\n\n```\nfib4(0) = 0\nfib4(1) = 0\nfib4(2) = 2\nfib4(3) = 0\nfib4(n) = fib4(n\u20111) + fib4(n\u20112) + fib4(n\u20113) + fib4(n\u20114)    (n \u2265 4)\n```\n\nis a linear recurrence of order\u202f4.  \nWe can compute it iteratively in **O(n)** time and **O(1)** extra memory\n(the four most recent values are enough).\n\n---\n\n### Algorithm\n```\nfib4(n):\n    if n == 0 or n == 1:   return 0\n    if n == 2:             return 2\n    if n == 3:             return 0\n\n    a = 0          // fib4(0)\n    b = 0          // fib4(1)\n    c = 2          // fib4(2)\n    d = 0          // fib4(3)\n\n    for i from 4 to n:\n        e = a + b + c + d      // fib4(i)\n        a = b\n        b = c\n        c = d\n        d = e\n    return d\n```\n\n`a, b, c, d` always hold the last four computed values.\n\n---\n\n### Correctness Proof  \n\nWe prove that the algorithm returns `fib4(n)` for all `n \u2265 0` by induction.\n\n*Base cases*  \n`n=0,1,2,3` are handled explicitly and returned with the correct\ndefinitions of the sequence.\n\n*Induction step*  \nAssume the algorithm is correct for all indices `< k` where `k \u2265 4`.  \nDuring the iteration for `i = k` the variables hold:\n```\na = fib4(k-4), b = fib4(k-3), c = fib4(k-2), d = fib4(k-1)\n```\n(induction hypothesis).  \nThe algorithm computes `e = a + b + c + d = fib4(k)`, shifts the four\nvariables, and after the loop terminates `d = fib4(k)` is returned.\nThus the algorithm is correct for `k`.  \nBy induction the algorithm is correct for all `n`.\n\n---\n\n### Complexity Analysis\n\n*Time*: one loop iteration per `n \u2265 4` \u2192 **O(n)**.  \n*Space*: constant number of variables \u2192 **O(1)**.\n\n---\n\n### Reference Implementation (C++)\n\n```cpp\n#include <iostream>\n#include <cassert>\n\n// Efficient iterative computation of the fib4 sequence.\nlong fib4(long n) {\n    if (n < 0) throw std::invalid_argument(\"n must be non\u2011negative\");\n\n    if (n == 0 || n == 1) return 0;\n    if (n == 2)           return 2;\n    if (n == 3)           return 0;\n\n    long a = 0;   // fib4(0)\n    long b = 0;   // fib4(1)\n    long c = 2;   // fib4(2)\n    long d = 0;   // fib4(3)\n\n    for (long i = 4; i <= n; ++i) {\n        long e = a + b + c + d; // fib4(i)\n        a = b;\n        b = c;\n        c = d;\n        d = e;\n    }\n    return d;\n}\n\n// Simple tests\nint main() {\n    assert(fib4(0) == 0);\n    assert(fib4(1) == 0);\n    assert(fib4(2) == 2);\n    assert(fib4(3) == 0);\n    assert(fib4(5) == 4);\n    assert(fib4(6) == 8);\n    assert(fib4(7) == 14);\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\nThe program compiles with any C++17\u2011compatible compiler and prints\n\n```\nAll tests passed!\n```\n\n**End of solution**", "Here is a compact, non\u2011recursive implementation that builds the sequence iteratively and keeps only the last four values in memory.  \nIt handles all non\u2011negative indices and runs in *O(n)* time with *O(1)* extra space.\n\n```cpp\n#include <cassert>\n#include <bits/stdc++.h>\n\n// Fib4 definition:\n// fib4(0) = 0\n// fib4(1) = 0\n// fib4(2) = 2\n// fib4(3) = 0\n// fib4(n) = fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\nlong fib4(long n)\n{\n    if (n < 0) throw std::invalid_argument(\"n must be non\u2011negative\");\n\n    // base cases\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    // keep last four values\n    long a = 0; // fib4(0)\n    long b = 0; // fib4(1)\n    long c = 2; // fib4(2)\n    long d = 0; // fib4(3)\n\n    for (long i = 4; i <= n; ++i) {\n        long next = a + b + c + d;   // fib4(i)\n        a = b;   // shift window\n        b = c;\n        c = d;\n        d = next;\n    }\n    return d;   // d now holds fib4(n)\n}\n\nint main() {\n    assert(fib4(5) == 4);\n    assert(fib4(6) == 8);\n    assert(fib4(7) == 14);\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\n**Explanation**\n\n1. **Base cases** are returned immediately.  \n2. For `n \u2265 4`, we iterate from 4 to `n`.  \n3. In each iteration we compute `next` as the sum of the four previous values.  \n4. A simple sliding\u2011window technique updates the four stored values, keeping space usage constant.  \n\nThis implementation works efficiently even for large `n` (limited by the size of `long`)."]}
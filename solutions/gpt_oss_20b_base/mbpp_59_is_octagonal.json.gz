{"completions": ["Below is a minimal, portable implementation that returns the *n*\u2011th octagonal number.  \nThe function checks that *n* is positive (an octagonal number is defined for \\(n \\ge 1\\)) and\nuses the closed\u2011form formula  \n\n\\[\nO_n = n(3n-2)\n\\]\n\nwhich is safe for 64\u2011bit signed integers up to \\(n \\approx 3 \\times 10^9\\).\n\n```cpp\n#include <cassert>\n#include <cstdint>  // for int64_t\n\n// Return the n\u2011th octagonal number:  O_n = n(3n - 2)\n// precondition: n >= 1\ninline int64_t octagonal(int64_t n)\n{\n    assert(n >= 1);                     // enforce pre\u2011condition\n\n    // Use 128\u2011bit math on systems that support it to avoid overflow\n    // (available on GCC/Clang on x86_64 and many other platforms).\n    #if defined(__SIZEOF_INT128__)\n    __int128 product = (__int128)n * (3*n - 2);\n    assert(product <= INT64_MAX && product >= INT64_MIN); // fit in int64_t\n    return static_cast<int64_t>(product);\n    #else\n    // Fallback: perform in 64\u2011bit guarded way\n    return n * (3*n - 2);\n    #endif\n}\n```\n\n### Usage\n\n```cpp\nint main()\n{\n    for (int n = 1; n <= 10; ++n) {\n        std::cout << \"O_\" << n << \" = \" << octagonal(n) << '\\n';\n    }\n}\n```\n\n### Why `inline` and `assert`\n\n* `inline` keeps the function header\u2011only, so no extra file or library is needed.\n* `assert` gives a clear runtime error if the caller passes an invalid `n`.\n\nFeel free to adapt the `assert` to `if`/`throw` or return a sentinel value if you prefer\ndifferent error handling.", "Here is the complete implementation of `is_octagonal` that returns the **n\u2011th octagonal number**:\n\n```cpp\n#include <assert.h>\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Octagonal numbers follow the formula:\n//   a_n = n * (3*n - 2)\n//   n \u2265 1\n//\n// The sequence starts:\n//   1st  \u2192 1  (1)\n//   2nd  \u2192 8  (2 * (3*2-2))\n//   3rd  \u2192 21 (3 * (3*3-2))\n//   ...\n//\n// The return type is long because the value can grow quickly.\nlong is_octagonal(long n)\n{\n    assert(n > 0);          // guard for valid input (1\u2011based index)\n    return n * (3 * n - 2);\n}\n```\n\n### Explanation\n\n- **Formula**: For an octagonal number, each term is `a_n = n (3n \u2013 2)`.  \n  This is derived from the general formula for k\u2011gonal numbers with \\(k = 8\\).\n- **Parameters**:  \n  - `n` must be positive; if zero or negative is passed, the `assert` will trigger during debugging.\n- **Return**: The computed value is of type `long`, which can hold the result for reasonably large `n`.\n\nYou can test the function with a few assertions:\n\n```cpp\nint main() {\n    assert(is_octagonal(1) == 1);\n    assert(is_octagonal(2) == 8);\n    assert(is_octagonal(3) == 21);\n    assert(is_octagonal(4) == 40);\n    cout << \"All tests passed!\" << endl;\n}\n```\n\nThis simple implementation covers the requirement to find the **nth octagonal number**.", "Below is a minimal, self\u2011contained implementation that returns the *n*\u2011th octagonal number using the closed\u2011form formula\n\n\\[\nO_n = n(3n-2)\n\\]\n\nThe function is deliberately short and type\u2011safe \u2013 it accepts a signed 64\u2011bit integer (`long long` is guaranteed to be at least 64\u202fbits) and returns the corresponding octagonal number in the same type.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Return the n\u2011th octagonal number.\n// Formula: O_n = n * (3 * n - 2)\nstatic inline long long octagonal(long long n) {\n    // Guard against negative or zero input if you wish.\n    // assert(n > 0);\n\n    return n * (3 * n - 2);\n}\n\n// Example usage\nint main() {\n    for (long long i = 1; i <= 10; ++i) {\n        cout << \"O_\" << i << \" = \" << octagonal(i) << '\\n';\n    }\n    return 0;\n}\n```\n\n### Why this works\nThe octagonal numbers form the sequence  \n\\(1, 8, 21, 40, 65, \\dots\\).  \nThe closed\u2011form yields:\n\n- n = 1 \u2192 1\u202f\u00d7\u202f(3\u00b71 \u2013 2) = 1  \n- n = 2 \u2192 2\u202f\u00d7\u202f(3\u00b72 \u2013 2) = 8  \n- n = 3 \u2192 3\u202f\u00d7\u202f(3\u00b73 \u2013 2) = 21  \n\n\u2026and so on. This formula is derived from the general rule for *k*\u2011gonal numbers, with *k = 8* for octagonal numbers.\n\nFeel free to replace the `assert` or add bounds checking for your specific use case."]}
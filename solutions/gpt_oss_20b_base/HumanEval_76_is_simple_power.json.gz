{"completions": ["**Solution Explanation**\n\nWe have to decide whether  \n`x = n^k` for some non\u2011negative integer `k`.\n\n*Observations*\n\n* `k = 0` gives `n^0 = 1`.  \n  Therefore `x == 1` is *always* true (for any `n`).\n* The trivial case `n == 1` is special:\n  `1^k = 1` for all `k`, so the only possible value is `x == 1`.\n* For `n >= 2` we can generate the powers of `n` until we either\n  hit `x` or exceed it.\n\nTo avoid overflow while multiplying the current power by `n`,\nwe cap the multiplication with the check  \n\n```\nif (current > x / n)   // multiplying would overflow or exceed x\n```\n\nAfter the loop we simply compare the last computed power with `x`.\n\nThe algorithm runs in `O(log_n x)` time (because each step multiplies by `n`).\n\n---\n\n#### Correctness Proof  \n\nWe prove that the function returns `true` iff `x = n^k` for some `k \u2265 0`.\n\n**Lemma 1**  \nFor `n == 1` the function returns `true` exactly when `x == 1`.\n\n*Proof.*  \nThe code branches to the `n == 1` case and compares `x` to `1`.  \nThus it returns `true` iff `x == 1`. \u220e\n\n**Lemma 2**  \nFor `n >= 2` the loop invariant  \n`current = n^i` holds for the loop variable `current`\nwhere `i` is the number of iterations performed.\n\n*Proof.*  \n*Base:* Before the first iteration `i = 0` and `current = 1 = n^0`.  \n*Step:* Assume invariant holds for some `i`.  \nThe loop multiplies `current` by `n`, giving `current = n^i * n = n^{i+1}`.  \nThus the invariant holds for the next `i`. \u220e\n\n**Lemma 3**  \nFor `n >= 2` when the loop terminates, `current` is the largest power\n`n^i` that does not exceed `x`.\n\n*Proof.*  \nThe loop stops when `current > x / n` or when `current == x`.  \nIn the first case, multiplying by `n` would exceed `x`, so the current\nvalue is the largest non\u2011exceeding power.  \nIn the second case we already hit `x`. \u220e\n\n**Theorem**  \nThe function returns `true` iff `x = n^k` for some integer `k \u2265 0`.\n\n*Proof.*  \n\n*Case `n == 1`* \u2013 handled by Lemma&nbsp;1, which matches the definition\n(`1^k = 1`).\n\n*Case `n >= 2`* \u2013 By Lemma&nbsp;3, after the loop\n`current` is the largest power \u2264 `x`.  \nThe function returns `true` exactly when `current == x`.  \nThus `x` is equal to some `n^k`.  \nConversely, if `x = n^k`, the loop will reach that value\n(because the powers grow monotonically) and the equality test\nwill succeed, so the function returns `true`. \u220e\n\n---\n\n#### Complexity Analysis  \n\nLet `L = \u230alog_n x\u230b` be the largest exponent with `n^L \u2264 x`.\n\n* Each iteration multiplies by `n`, so there are `O(L)` iterations.  \n* All operations inside the loop are `O(1)`.\n\nHence the running time is `O(log_n x)` and the memory usage is `O(1)`.\n\n---\n\n#### Reference Implementation (C++17)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool is_simple_power(long x, long n) {\n    if (x < 1) return false;          // only positive powers produce 1 or larger\n\n    if (n == 1) return x == 1;        // 1^k is always 1\n\n    long long current = 1;            // use 64\u2011bit to avoid intermediate overflow\n    while (current < x) {\n        // If current * n would overflow or exceed x, we can stop\n        if (current > x / n) break;\n        current *= n;\n    }\n    return current == x;\n}\n\n/* Simple tests */\nint main() {\n    assert(is_simple_power(1, 4) == true);\n    assert(is_simple_power(2, 2) == true);\n    assert(is_simple_power(8, 2) == true);\n    assert(is_simple_power(3, 2) == false);\n    assert(is_simple_power(3, 1) == false);\n    assert(is_simple_power(5, 3) == false);\n    cout << \"All tests passed.\\n\";\n}\n```\n\nThe program follows exactly the algorithm proven correct above\nand compiles with any C++17 compiler.", "**Solution Outline**\n\nA number `x` is a *simple power* of `n` iff there exists an integer `k\u22650` such that  \n\n```\nx = n^k\n```\n\nThe easiest way to test this is to keep dividing `x` by `n` while the division leaves no remainder.\nIf we finally reach `1` then `x` was a power of `n`.  \nIf at any point the remainder is non\u2011zero, `x` cannot be written as a power of `n`.\n\n### Edge Cases\n\n* `n == 1`\u2003: only `1^0 = 1` is a power of 1 \u2192 `x` must be `1`.\n* `n == -1` (if allowed)\u2003: powers alternate between `1` and `-1`.  \n  Here `x` must be `1` or `-1`.  \n  (If only positive numbers are expected, this case can be ignored.)\n* `x < 1` or `n < 2` \u2192 return `false` (unless the special cases above apply).\n\n### Complexity\n\nThe loop runs at most `log_n(x)` iterations, i.e. `O(log x)` time and `O(1)` memory.\n\n```cpp\n#include <cmath>\n#include <cstdlib>\n\nbool is_simple_power(long x, long n)\n{\n    // Handle the special case n == 1\n    if (n == 1) {\n        return x == 1;\n    }\n\n    // Optional: handle n == -1 (if negative bases are allowed)\n    if (n == -1) {\n        return (x == 1) || (x == -1);\n    }\n\n    // For other n, we need x > 0\n    if (x < 1 || n < 2) return false;\n\n    while (x % n == 0) {\n        x /= n;\n    }\n    return x == 1;\n}\n```\n\nThis function satisfies all the examples given:\n\n```\nis_simple_power(1, 4) \u2192 true\nis_simple_power(2, 2) \u2192 true\nis_simple_power(8, 2) \u2192 true\nis_simple_power(3, 2) \u2192 false\nis_simple_power(3, 1) \u2192 false\nis_simple_power(5, 3) \u2192 false\n```\n\nFeel free to adjust the handling of negative bases or zero based on the problem domain.", "**Explanation**\n\nFor a *simple power* we have\n\n```\nx = n ** k        (k is an integer \u2265 1)\n```\n\nIn other words, repeatedly dividing `x` by `n` must finally give `1`.  \nIf at any division step the remainder is non\u2011zero, `x` cannot be a power of `n`.\n\n**Corner cases**\n\n| case | reasoning |\n|------|-----------|\n| `n` \u2264 1 | The problem statement defines `n > 1`. We return `false` for `n \u2264 1`. |\n| `x` < 1  | For positive powers `x` must be at least 1.  (`0` or negative numbers can\u2019t be a power). |\n| `n == 1` | `1 ** k` is always `1`. The statement says we should return `false` for (3,1). |\n| Overflow | We never multiply \u2013 we only divide \u2013 so over\u2011flow isn\u2019t a problem. |\n\n**Algorithm**\n\n```cpp\nbool is_simple_power(long x, long n) {\n    if (n <= 1)        return false;   // 1 or negative n is not allowed\n    if (x < 1)         return false;   // negative and 0 cannot be a power\n\n    while (x % n == 0)        // While divisible by n\n        x /= n;                // Remove one power of n\n\n    return (x == 1);          // If we reached 1 \u2192 simple power\n}\n```\n\nThe function works in `O(log_n(x))` time and `O(1)` space.\n\n**Complete code**\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Return true iff x is a simple power of n (n ** k == x for some integer k >= 1)\nbool is_simple_power(long x, long n) {\n    // Guard clauses for invalid / trivial inputs\n    if (n <= 1) return false;   // n must be > 1\n    if (x < 1)  return false;   // x must be positive\n\n    while (x % n == 0) {\n        x /= n;\n    }\n    return (x == 1);\n}\n\n// ==================\n// optional tests\n// ==================\nint main() {\n    vector<pair<long,long>> tests = {\n        { 1, 4 },\n        { 2, 2 },\n        { 8, 2 },\n        { 3, 2 },\n        { 3, 1 },\n        { 5, 3 }\n    };\n\n    for (auto [x, n] : tests) {\n        cout << \"is_simple_power(\" << x << \", \" << n << \") => \"\n             << (is_simple_power(x, n) ? \"true\" : \"false\") << '\\n';\n    }\n    return 0;\n}\n```\n\nThis satisfies the problem requirements and handles the edge cases properly."]}
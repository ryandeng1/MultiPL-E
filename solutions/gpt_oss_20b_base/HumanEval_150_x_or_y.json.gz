{"completions": ["Here is the complete implementation for `x_or_y`:\n\n```cpp\n#include <cmath>\n\n// Returns x if n is a prime number, otherwise returns y.\n// For n < 2 we consider it not prime.\nlong x_or_y(long n, long x, long y) {\n    if (n < 2) return y;          // 0 and 1 are not prime\n\n    // Check divisibility up to sqrt(n)\n    long limit = static_cast<long>(std::sqrt(static_cast<double>(n)));\n    for (long d = 2; d <= limit; ++d) {\n        if (n % d == 0) {\n            return y;            // composite\n        }\n    }\n    return x;                     // prime\n}\n```\n\n**Explanation**\n\n1. **Special cases** \u2013 0 and 1 are not prime, so we return `y` immediately.\n2. **Primality test** \u2013 We only need to check divisors up to `sqrt(n)`; any larger divisor would pair with a smaller one already checked.\n3. **Return value** \u2013 If any divisor is found, the number is composite and we return `y`; otherwise it is prime and we return `x`.\n\nThis function works for any `long` values of `n`, `x`, and `y`.", "**Solution Explanation**\n\nFor a given integer `n` we have to decide if it is a prime number.  \nIf it is prime return the value `x`, otherwise return `y`.\n\nThe number of test cases in the examples is tiny, but the function has to work for any long integer, so we use a simple deterministic primality test that is fast enough for 64\u2011bit integers:\n\n* 2 and 3 are primes.\n* Any even number or a multiple of 3 is composite.\n* Test potential divisors of the form `6k \u00b1 1` up to `\u221an`.\n\nThis runs in `O(\u221an)` time \u2013 fast enough for the usual ranges of `long`.  \nWe also guard against negative numbers: by definition primes are positive, so any non\u2011positive `n` is treated as composite.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong x_or_y(long n, long x, long y) {\n    // primes are positive integers greater than 1\n    if (n <= 1) return y;\n\n    if (n == 2 || n == 3) return x;\n    if (n % 2 == 0 || n % 3 == 0) return y;\n\n    for (long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return y;\n    }\n    return x;\n}\n```\n\n**Why it works**\n\n* The loop checks divisibility by all primes up to `\u221an`, because any composite number has a factor \u2264 `\u221an`.  \n* The pattern `6k \u00b1 1` captures every integer that can be prime (all primes > 3 are of this form).  \n* If none of the divisors divide `n`, the number is prime, so we return `x`; otherwise we return `y`.\n\n**Complexity**\n\n*Time* \u2013 `O(\u221an)`  \n*Space* \u2013 `O(1)`\n\n\n\n-------", "Here is a concise implementation of `x_or_y` that tests whether `n` is prime and returns the appropriate value. The primality check is done in `isPrime`, which works efficiently for ordinary 64\u2011bit integers.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Utility to test primality for a 64\u2011bit integer\nbool isPrime(long long n) {\n    if (n <= 1) return false;      // 0, 1 and negatives are not prime\n    if (n <= 3) return true;       // 2, 3 are prime\n    if (n % 2 == 0 || n % 3 == 0)  // eliminate multiples of 2 and 3\n        return false;\n\n    // Only need to test up to sqrt(n), step by 6k \u00b1 1\n    for (long long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\nlong x_or_y(long n, long x, long y) {\n    return isPrime(n) ? x : y;\n}\n\n/* Test harness\nint main() {\n    cout << x_or_y(7, 34, 12) << endl; // 34\n    cout << x_or_y(15, 8, 5)  << endl; // 5\n    return 0;\n}\n*/\n```\n\n### How it works\n\n1. **`isPrime`**  \n   - Handles small numbers and even divisibility quickly.  \n   - Uses the 6k\u00b11 optimization to test potential factors up to `\u221an`.  \n   - Returns `true` if `n` is prime, `false` otherwise.\n\n2. **`x_or_y`**  \n   - Calls `isPrime` on `n`.  \n   - Returns `x` if `n` is prime, otherwise returns `y`.\n\nFeel free to integrate this into your codebase or modify the primality test for larger integer ranges if needed."]}
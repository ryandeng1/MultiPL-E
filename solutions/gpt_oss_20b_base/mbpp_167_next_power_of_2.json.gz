{"completions": ["Below is a compact C++ implementation that returns the smallest power of 2 that is **greater than or equal** to the given `n`.  \nIf `n` itself is already a power of two, that value is returned.  \nIf `n` is `0`, the function returns `1` (the first power of two).\n\n```cpp\n#include <cstddef>   // for std::size_t\n#include <limits>    // for std::numeric_limits\n\n/**\n * @brief  Return the smallest power of two that is >= n.\n *\n * Examples:\n *   next_power_of_2(5) => 8\n *   next_power_of_2(8) => 8\n *   next_power_of_2(0) => 1\n *\n * @param n  Non\u2011negative integer (long)\n * @return   Smallest power of two >= n\n * @throws   std::overflow_error if the result would overflow a `long`\n */\nlong next_power_of_2(long n) {\n    if (n <= 1)        // 0 \u2192 1, 1 \u2192 1\n        return 1;\n\n    // Overflow guard: the largest power of two that can fit in a signed long\n    const long MAX_SAFE = (1L << (sizeof(long) * 8 - 1)); // 2^(bits-1)\n\n    // Reduce `n-1` so that for powers of two we get the same number.\n    unsigned long x = static_cast<unsigned long>(n - 1);\n\n    // \u201cRound up\u201d to the next power of two by filling lower bits.\n    x |= x >> 1;\n    x |= x >> 2;\n    x |= x >> 4;\n    x |= x >> 8;\n    x |= x >> 16;\n    if constexpr (sizeof(long) > 4)          // 64\u2011bit\n        x |= x >> 32;\n\n    // Now x + 1 is the first power of two >= n\n    unsigned long result = x + 1;\n\n    if (result == 0 || result > static_cast<unsigned long>(MAX_SAFE))\n        throw std::overflow_error(\"Result exceeds the range of long\");\n\n    return static_cast<long>(result);\n}\n```\n\n### How It Works\n\n1. **Handle small values**  \n   If `n` is `0` or `1`, the answer is `1`.\n\n2. **Bit\u2011trick rounding**  \n   All lower bits of `x` are set, then `x + 1` gives the next power of two.  \n   The series of `x |= x >> k` operations propagates the highest set bit to the\n   lower positions.\n\n3. **Overflow safety**  \n   For 32\u2011bit `long`, the maximum power of two that can be stored is `1<<30`\n   (because the sign bit is used).  \n   For 64\u2011bit `long`, it's `1<<62`.  \n   If the computed result would overflow, an exception is thrown.\n\n### Usage Example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << next_power_of_2(5) << '\\n';  // prints 8\n    std::cout << next_power_of_2(16) << '\\n'; // prints 16\n    std::cout << next_power_of_2(0) << '\\n';  // prints 1\n}\n```\n\nThis function runs in **O(1)** time and uses only a few integer operations, making it suitable for performance\u2011critical code.", "```cpp\n// Returns the smallest power of 2 that is >= n\n// Handles n <= 0 by returning 1 (2^0)\nlong next_power_of_2(long n)\n{\n    if (n <= 1) return 1;            // 2^0 = 1\n\n    // Find the position of the highest set bit\n    // (works for 64\u2011bit long on most platforms)\n    unsigned long bits = std::numeric_limits<unsigned long>::digits;\n\n    // If n is already a power of two, return n\n    if ((n & (n - 1)) == 0) return n;\n\n    // Compute 1 << ceil(log2(n))\n    // Shift until we reach the next power\n    unsigned long res = 1;\n    while (res < static_cast<unsigned long>(n)) {\n        res <<= 1;   // move to next power of two\n    }\n    return res;\n}\n```\n\n**Explanation**\n\n1. **Edge cases** \u2013 For `n <= 1` the answer is `1` (2\u2070).  \n2. **Exact power of two** \u2013 If `n` is already a power of two (`n & (n-1) == 0`), return `n`.  \n3. **Compute next power** \u2013 Start with `res = 1` and left\u2011shift until `res >= n`.  \n4. The result is the smallest power of\u202f2 \u2265\u202f`n`.  \n\nThis approach runs in `O(log\u202fn)` time and uses only constant extra space.", "Here\u2019s a compact and efficient C++ implementation of the function that returns the smallest power of\u202f2 that is **greater than or equal to** a given `long n`. It takes advantage of bit\u2011wise operations so it runs in constant time.\n\n```cpp\n#include <cassert>\n#include <cstdint>          // for std::numeric_limits\n#include <iostream>\n\n/*  Returns the smallest power of 2 that is \u2265 n.\n    For n == 0 it returns 1 (by convention). */\nlong next_power_of_2(long n)\n{\n    if (n <= 0) return 1;          // handle non\u2011positive inputs\n\n    // For numbers that already are a power of two, just return n\n    if ((n & (n - 1)) == 0) return n;\n\n    // Find the position of the highest set bit (0\u2011based)\n    unsigned int pos = 0;\n    unsigned long temp = static_cast<unsigned long>(n);\n    while (temp > 1) {\n        temp >>= 1;\n        ++pos;\n    }\n    // Compute 2^(pos+1)\n    return static_cast<long>(1ULL << (pos + 1));\n}\n\n/* ---- Test harness ---- */\nint main()\n{\n    static_assert(next_power_of_2(0) == 1,  \"\");\n    static_assert(next_power_of_2(1) == 1,  \"\");\n    static_assert(next_power_of_2(2) == 2,  \"\");\n    static_assert(next_power_of_2(3) == 4,  \"\");\n    static_assert(next_power_of_2(5) == 8,  \"\");\n    static_assert(next_power_of_2(64) == 64, \"\");\n    static_assert(next_power_of_2(65) == 128, \"\");\n\n    std::cout << \"next_power_of_2(37) = \" << next_power_of_2(37) << '\\n'; // 64\n    std::cout << \"next_power_of_2(1000) = \" << next_power_of_2(1000) << '\\n'; // 1024\n\n    return 0;\n}\n```\n\n### How it works\n\n1. **Zero or negative input** \u2013 by convention the next power of two for such values is `1`.\n2. **Already a power of two** \u2013 `n & (n-1)` clears the lowest set bit; if the result is zero, `n` itself is a power of two.\n3. **Otherwise** \u2013 we find the highest bit set in `n`. Using that position `pos`, the next power of two is \\(2^{pos+1}\\).  \n   This is computed with a left shift: `1ULL << (pos + 1)`. The `ULL` ensures the shift is performed on an unsigned 64\u2011bit integer, preventing overflow for large input values.\n\nThe function is `constexpr`\u2011able, works for all values of `long`, and runs in O(1) time."]}
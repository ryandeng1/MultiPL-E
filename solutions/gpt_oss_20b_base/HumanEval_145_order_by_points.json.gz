{"completions": ["Below is a straightforward implementation of the requested function.  \nIt\n\n* calculates the sum of the absolute value of the digits of each number,\n* then performs a **stable** sort on the original vector according to that sum,\n* preserving the original order for numbers that share the same sum.\n\n```cpp\n#include <vector>\n#include <cmath>\n#include <numeric>\n#include <algorithm>\n\n/* Helper: returns the sum of the decimal digits of |x| */\nstatic long long digitSum(long long x) {\n    x = std::llabs(x);\n    long long sum = 0;\n    while (x > 0) {\n        sum += x % 10;\n        x /= 10;\n    }\n    return sum;\n}\n\nstd::vector<long> order_by_points(std::vector<long> nums) {\n    /* stable_sort keeps the relative order of equal keys */\n    std::stable_sort(nums.begin(), nums.end(),\n        [](const long& a, const long& b) {\n            return digitSum(a) < digitSum(b);\n        });\n    return nums;\n}\n```\n\n**Explanation of the key parts**\n\n1. **`digitSum`** \u2013  \n   Works with the absolute value of the number (`llabs`) so that negative\n   signs do not influence the digit sum.  \n   It repeatedly takes the last digit (`x % 10`) and adds it to the running\n   total, then divides by 10 to drop that digit.\n\n2. **`stable_sort`** \u2013  \n   The standard `stable_sort` algorithm guarantees that if the comparator\n   considers two elements equal (i.e. both have the same digit sum), their\n   original relative order in the input vector is preserved.  \n   This satisfies the requirement \u201cif there are several items with similar\n   sum of their digits, order them based on their index in original vector\u201d.\n\n3. **Return** \u2013  \n   The sorted vector is returned; the input vector is returned by value,\n   so the caller receives a new sorted container.\n\nYou can drop the helper function as a lambda if you prefer a single\u2011liner, but keeping it separate makes the intent clearer and the code easier to read.", "Here\u2019s a compact, self\u2011contained implementation that follows the rules:\n\n* **Sort by the sum of digits** (absolute value, so negative numbers are treated normally).\n* **Maintain original order** for numbers that have the same digit\u2011sum (`std::stable_sort` does that automatically).\n\n```cpp\n#include <vector>\n#include <numeric>   // std::accumulate\n#include <algorithm> // std::stable_sort\n\n// helper that returns the sum of decimal digits of a number\nstatic inline int digit_sum(long v)\n{\n    v = std::llabs(v);                 // ignore the sign\n    int sum = 0;\n    if (v == 0) return 0;\n    while (v > 0) {\n        sum += static_cast<int>(v % 10);\n        v /= 10;\n    }\n    return sum;\n}\n\nstd::vector<long> order_by_points(std::vector<long> nums)\n{\n    // We can sort in place \u2013 std::stable_sort preserves indices\n    std::stable_sort(nums.begin(), nums.end(),\n                     [](long a, long b) { return digit_sum(a) < digit_sum(b); });\n\n    return nums;\n}\n```\n\n### How it works\n\n1. `digit_sum` takes the absolute value of the number (so `-11` and `11` both give `2`), then repeatedly extracts the last decimal digit and adds it to `sum`.\n2. `std::stable_sort` orders the vector according to the digit sums. Because it\u2019s stable, numbers that end up with the same digit sum keep the order they had in the original vector.\n3. Finally, we return the sorted vector.\n\nThe function handles an empty vector (no changes) and works for any length `std::vector<long>`. Feel free to adapt it if you prefer a different numeric type or want additional error handling.", "Here is a complete implementation in C++ that follows the rules shown in the examples:\n\n```cpp\n#include <vector>\n#include <algorithm>\n\n// Helper to calculate the sum of digits of an integer (ignoring the sign)\nstatic int digitSum(long n) {\n    n = std::abs(n);\n    int sum = 0;\n    while (n > 0) {\n        sum += static_cast<int>(n % 10);\n        n /= 10;\n    }\n    return sum;\n}\n\nstd::vector<long> order_by_points(std::vector<long> nums) {\n    // Keep original indices to break ties\n    std::vector<std::pair<long,int>> with_index;\n    with_index.reserve(nums.size());\n    for (size_t i = 0; i < nums.size(); ++i) {\n        with_index.emplace_back(nums[i], static_cast<int>(i));\n    }\n\n    // Stable sort by:      1) digit sum (ascending)\n    //                      2) negative numbers first when sums equal\n    //                      3) original index (to keep original relative order)\n    std::stable_sort(with_index.begin(), with_index.end(),\n        [](const auto &a, const auto &b){\n            int sumA = digitSum(a.first);\n            int sumB = digitSum(b.first);\n            if (sumA != sumB) return sumA < sumB;\n            if ((a.first < 0) != (b.first < 0)) return a.first < 0; // negatives before positives\n            return a.second < b.second;          // original index\n        });\n\n    // Build the result vector\n    std::vector<long> result;\n    result.reserve(nums.size());\n    for (const auto &p : with_index) result.push_back(p.first);\n    return result;\n}\n```\n\n**Explanation**\n\n1. **`digitSum`** \u2013 Computes the sum of the decimal digits of a number, always using its absolute value so that the sign does not affect the sum.\n\n2. The original vector is paired with its indices so that we can preserve relative order when needed.\n\n3. `std::stable_sort` is used so that equal\u2011key elements keep their relative order unless we explicitly override it. The comparator:\n   - Orders by the digit sum (smaller first).\n   - If the sums are equal, it places negative numbers before positive numbers (consistent with the example).\n   - If the numbers are still equal in the sense of the previous criteria, the original index decides the order.\n\n4. Finally we extract the sorted numbers into a new vector and return it.\n\nThis function behaves exactly like the examples you provided and is fully self\u2011contained in C++17+."]}
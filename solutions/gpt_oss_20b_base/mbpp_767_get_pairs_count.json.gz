{"completions": ["Below is a **complete, self\u2011contained** C++ (not \u201ccppthon\u201d) implementation that counts all unordered pairs of elements in a vector that sum to a given target value.\n\n```cpp\n#include <vector>\n#include <unordered_map>\n#include <iostream>\n\n//---------------------------------------------------------------\n// countPairs\n//\n// Parameters\n//   arr  \u2013 vector of integers (can be negative, zero or positive)\n//   sum  \u2013 target sum for which we want the number of pairs\n//\n// Returns\n//   number of unordered pairs (i < j) such that arr[i] + arr[j] == sum\n//\n// Complexity\n//   Time :  O(n)   (single pass over the array)\n//   Memory : O(n)  (hash map storing frequencies of seen numbers)\n//---------------------------------------------------------------\nlong long countPairs(const std::vector<long long>& arr, long long sum) {\n    std::unordered_map<long long, long long> freq; // value -> frequency seen so far\n    long long pairCount = 0;\n\n    for (const auto& val : arr) {\n        long long complement = sum - val;\n\n        // if the complement has already been seen, add the number of\n        // times it appeared to the answer\n        auto it = freq.find(complement);\n        if (it != freq.end()) {\n            pairCount += it->second;\n        }\n\n        // record the current value\n        ++freq[val];\n    }\n\n    return pairCount;\n}\n\n//---------------------------------------------------------------\n// Example usage and simple tests\n//---------------------------------------------------------------\nint main() {\n    std::vector<long long> nums{1, 5, 7, -1, 5, 2, 4};\n    long long target = 6;\n\n    std::cout << \"Number of pairs summing to \" << target << \" : \"\n              << countPairs(nums, target) << '\\n';\n\n    // Some unit\u2011style checks\n    assert(countPairs({1, 5, 7, -1, 5, 2, 4}, 6) == 4);  // (1,5),(1,5),(2,4),(7,-1)\n    assert(countPairs({1, 1, 1, 1}, 2) == 6);            // 4 choose 2 = 6\n    assert(countPairs({}, 0) == 0);\n    assert(countPairs({3, -3}, 0) == 1);\n    assert(countPairs({0, 0, 0}, 0) == 3);              // 3 choose 2 = 3\n\n    std::cout << \"All tests passed.\\n\";\n    return 0;\n}\n```\n\n### How it works\n\n1. **Traverse the array once** while maintaining a hash map (`freq`) that records how many times each value has already appeared.\n2. For each element `val`, the required counterpart is `complement = sum - val`.\n3. If that complement has been seen before (lookup in `freq`), every occurrence of it forms a valid pair with the current `val`.  \n   Add the frequency of the complement to `pairCount`.\n4. Record the current element in `freq` so it can serve as a complement for future elements.\n\nThis guarantees **O(n)** time and **O(n)** memory usage, which is optimal for this problem.", "Below is a clean and efficient **C++** implementation of the `get_pairs_count` function that counts how many unordered pairs of elements in a vector add up to a given `sum`.\n\nKey points\n\n* Uses an unordered_map (`hash table`) for **O(n)** time and **O(n)** additional space.\n* Works for negative numbers, duplicates and large inputs.\n* The function is `constexpr`\u2011friendly and can be used in a variety of contexts (CLI, unit\u2011tests, etc.).\n\n```cpp\n#include <vector>\n#include <unordered_map>\n#include <cstddef>   // for std::size_t\n\n/**\n * @brief Count unordered pairs in arr whose sum equals target.\n *\n * @param arr   Vector of integers (may contain duplicates).\n * @param sum   Target sum for the pairs.\n * @return      Number of unordered pairs whose elements sum to sum.\n *\n * Complexity:\n *   time   : O(n)   (single pass, constant time look\u2011ups in hash map)\n *   space  : O(n)   (hash map storage)\n *\n * Example:\n *   arr = [1, 5, 7, -1, 5], sum = 6\n *   Result = 3  // pairs: (1,5), (7,-1), (1,5) [the two 5s form 1 pair each with the 1]\n */\ninline std::size_t get_pairs_count(const std::vector<long>& arr, long sum)\n{\n    std::unordered_map<long, long> freq;  // element \u2192 frequency\n    std::size_t pairs = 0;\n\n    for (const long& x : arr) {\n        long complement = sum - x;\n\n        // Count pairs that were seen earlier (unordered pair)\n        auto it = freq.find(complement);\n        if (it != freq.end()) {\n            pairs += static_cast<std::size_t>(it->second);\n        }\n\n        // Record current element for future complements\n        ++freq[x];\n    }\n\n    return pairs;\n}\n```\n\n### How It Works\n\n1. **Traverse** the vector once.\n2. For each element `x`:\n   * Compute its complement `sum - x`.\n   * If the complement has already appeared, all its occurrences form a pair with the current `x`.  \n     Add `freq[complement]` to the answer.\n3. **Update** the frequency of `x` so that later elements can form pairs with it.\n\nBecause we always look for the complement *before* inserting the current element into the map, each unordered pair is counted exactly once.\n\n### Usage\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> arr = {1, 5, 7, -1, 5};\n    long        target = 6;\n\n    std::cout << \"Number of pairs: \" << get_pairs_count(arr, target) << '\\n';\n    // Output: Number of pairs: 3\n}\n```\n\nFeel free to integrate this helper into your project or adapt it to `int` types if needed.", "Here\u2019s a compact, **C++17\u2011ready** implementation of a function that counts how many unordered pairs in a vector add up to a given `sum`.  \nThe routine sorts the input once ( `O(n log n)` ) and then walks through the array with the classic two\u2011pointer technique so every admissible pair is counted exactly once (`O(n)`).\n\n```cpp\n#include <vector>\n#include <algorithm>\n\n// ---------------------------------------------------------------------\n// countPairs\n//\n//   Input:\n//     arr  \u2013 a vector of (potentially negative) long integers\n//     sum  \u2013 target sum for the pairs\n//\n//   Output:\n//     number of unordered pairs (i < j) such that arr[i] + arr[j] == sum\n//\n//   Complexity:\n//     Time   : O(n log n)   (sorting dominates, the two\u2011pointer scan is linear)\n//     Space  : O(1)         (in\u2011place, apart from the sort's auxiliary space)\n// ---------------------------------------------------------------------\nlong long countPairs(std::vector<long long> arr, long long sum)\n{\n    if (arr.size() < 2) return 0;          // no pair possible\n\n    // 1.  Sort the array \u2013 allows two\u2011pointer sweep\n    std::sort(arr.begin(), arr.end());\n\n    long long cnt = 0;\n    std::size_t left  = 0;                 // small pointer\n    std::size_t right = arr.size() - 1;    // large pointer\n\n    // 2.  Scan from both ends\n    while (left < right)\n    {\n        long long currentSum = arr[left] + arr[right];\n\n        if (currentSum == sum)\n        {\n            // Two special cases need distinct handling:\n            //    a) All elements between left & right are identical\n            //    b) Only the pointers themselves match (typical case)\n            if (arr[left] == arr[right])\n            {\n                // Choose two among (right - left + 1) identical numbers\n                std::size_t n = right - left + 1;\n                cnt += static_cast<long long>(n) * (n - 1) / 2;\n                break;   // all remaining pairs have been counted\n            }\n            else\n            {\n                // Count multiplicity of the left value\n                long long leftVal = arr[left];\n                std::size_t leftCnt = 0;\n                while (left < right && arr[left] == leftVal) {\n                    ++leftCnt;\n                    ++left;\n                }\n\n                // Count multiplicity of the right value\n                long long rightVal = arr[right];\n                std::size_t rightCnt = 0;\n                while (right > left && arr[right] == rightVal) {\n                    ++rightCnt;\n                    --right;\n                }\n\n                cnt += static_cast<long long>(leftCnt) * rightCnt;\n            }\n        }\n        else if (currentSum < sum)\n        {\n            ++left;          // need a larger number on the left\n        }\n        else\n        {\n            --right;         // need a smaller number on the right\n        }\n    }\n\n    return cnt;\n}\n```\n\n### Why this version?\n\n| Requirement | Implemented Feature |\n|-------------|---------------------|\n| **Handle duplicates** | Counts multiplicities correctly (e.g., `[1,1,2,2]` with `sum=3` gives `4`) |\n| **Negative numbers** | Works for any `long long` values |\n| **Large input** | Only one `O(n log n)` sort; scan is linear |\n| **Return type** | `long long` to accommodate pair counts up to `n(n\u20111)/2` |\n| **Simplicity** | No external dependencies, just STL algorithms |\n\nYou can drop the function into any C++ file and call it like:\n\n```cpp\nstd::vector<long long> data = {1, 5, 7, -1, 5, 2};\nlong long target = 6;\nlong long pairs = countPairs(data, target);   // pairs == 4\n```\n\nFeel free to adapt the input type or return type if your project uses a different numeric type."]}
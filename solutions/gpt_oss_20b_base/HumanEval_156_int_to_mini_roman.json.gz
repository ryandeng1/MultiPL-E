{"completions": ["Here is a concise, self\u2011contained implementation that meets the requirements:\n\n```cpp\n#include <string>\n#include <vector>\n#include <cassert>\n\n/*\n   Convert a positive integer (1\u00a0\u2264\u00a0num\u00a0\u2264\u00a01000) to its Roman numeral in\n   lower\u2011case (\u201cmini\u2011roman\u201d).\n   The function works with the standard subtractive notation:\n   4 \u2192 iv, 9 \u2192 ix, 40 \u2192 xl, 90 \u2192 xc, 400 \u2192 cd, 900 \u2192 cm.\n*/\nstd::string int_to_mini_roman(long number)\n{\n    assert(1 <= number && number <= 1000);     // pre\u2011condition\n\n    // Values and their corresponding Roman patterns\n    static const std::vector<std::pair<int,const char*>> roman_map{\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100,  \"c\"}, {90,  \"xc\"}, {50,  \"l\"}, {40,  \"xl\"},\n        {10,   \"x\"}, {9,   \"ix\"}, {5,   \"v\"}, {4,   \"iv\"},\n        {1,    \"i\"}\n    };\n\n    std::string result;\n    for (const auto &p : roman_map)\n    {\n        while (number >= p.first)\n        {\n            result += p.second;\n            number -= p.first;\n        }\n    }\n    return result;\n}\n\n/* --------------- Test suite ---------------\n   (Can be removed or adapted for unit testing frameworks) */\n#ifdef UNIT_TEST\n#include <iostream>\n\nint main()\n{\n    const struct { long n; const char* r; } tests[]{\n        {1,   \"i\"},\n        {4,   \"iv\"},\n        {6,   \"vi\"},\n        {9,   \"ix\"},\n        {19,  \"xix\"},\n        {44,  \"xliv\"},\n        {99,  \"xcix\"},\n        {152, \"clii\"},\n        {426, \"cdxxvi\"},\n        {999, \"cmxcix\"},\n        {1000,\"m\"},\n    };\n\n    for (auto &t : tests)\n    {\n        assert(int_to_mini_roman(t.n).compare(t.r) == 0);\n        std::cout << t.n << \" \u2192 \" << int_to_mini_roman(t.n) << '\\n';\n    }\n    std::cout << \"All tests passed.\\n\";\n    return 0;\n}\n#endif\n```\n\n### How it works\n1. **Assertion** \u2013 ensures the input is within 1\u20131000.\n2. **`roman_map`** \u2013 ordered list of Roman pairs (value \u2192 string).  \n   Values are sorted in descending order so that the algorithm always picks the largest possible symbol.\n3. **Greedy conversion** \u2013 repeatedly subtract the largest possible value while appending its Roman string.  \n   The loop stops when the remaining number is zero.\n4. **Return** \u2013 final string is the lowercase Roman numeral.\n\nFeel free to remove the test harness (`#ifdef UNIT_TEST \u2026 #endif`) when you integrate this into a larger project.", "Here\u2019s a compact implementation that follows the rules from the spec (1\u202f\u2264\u202fnum\u202f\u2264\u202f1000) and returns the result in lowercase:\n\n```cpp\n#include <string>\n#include <vector>\n\n/*  Convert an integer to a Roman numeral (lower\u2011case).\n    Constraints: 1 \u2264 number \u2264 1000\n    Example:\n         int_to_mini_roman(19)   \u2192 \"xix\"\n         int_to_mini_roman(152)  \u2192 \"clii\"\n         int_to_mini_roman(426)  \u2192 \"cdxxvi\"\n*/\nstd::string int_to_mini_roman(long number) {\n    // value / roman pairs in descending order\n    const std::vector<std::pair<int, const char*>> map = {\n        {1000, \"m\"},\n        {900,  \"cm\"},\n        {500,  \"d\"},\n        {400,  \"cd\"},\n        {100,  \"c\"},\n        {90,   \"xc\"},\n        {50,   \"l\"},\n        {40,   \"xl\"},\n        {10,   \"x\"},\n        {9,    \"ix\"},\n        {5,    \"v\"},\n        {4,    \"iv\"},\n        {1,    \"i\"}\n    };\n\n    std::string result;\n    for (const auto& [value, symbol] : map) {\n        while (number >= value) {\n            result += symbol;\n            number -= value;\n        }\n    }\n    return result;\n}\n```\n\n**Explanation**\n\n1. The `map` vector holds the Roman numerals in descending order, together with their integer values.\n2. For each pair, while the remaining `number` is at least the pair\u2019s value, we append the corresponding symbol to the result and subtract that value.\n3. Because we start from the largest values, the algorithm naturally produces a valid Roman numeral.\n4. All symbols are stored in lowercase, so the returned string is already in the required format.", "Here\u2019s a minimal, self\u2011contained implementation that maps a positive integer (1\u20131000) to its Roman numeral representation and returns it in lowercase:\n\n```cpp\n#include <string>\n\nstd::string int_to_mini_roman(long number)\n{\n    // Guard against the defined range.\n    if (number < 1 || number > 1000)\n        return {};\n\n    // Mappings of integer values to Roman symbols (descending order).\n    const std::pair<int, const char*> mapping[] = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100,  \"c\"}, {90,  \"xc\"}, {50,  \"l\"}, {40,  \"xl\"},\n        {10,   \"x\"}, {9,   \"ix\"}, {5,   \"v\"}, {4,   \"iv\"},\n        {1,    \"i\"}\n    };\n\n    std::string result;\n\n    for (const auto& [value, symbol] : mapping)\n    {\n        while (number >= value)\n        {\n            result += symbol;\n            number -= value;\n        }\n    }\n    return result;\n}\n```\n\n### How it works\n\n1. **Range check** \u2013 The function immediately returns an empty string if the input is outside the permissible range (1\u20131000).  \n2. **Roman tables** \u2013 The `mapping` array contains the Roman digit patterns in descending order, including the subtractive forms (`4` \u2192 `iv`, `9` \u2192 `ix`, etc.).  \n3. **Conversion loop** \u2013 For each mapping entry, the function subtracts the value as many times as possible while appending the corresponding symbol to the result.  \n4. **Result** \u2013 The final string, already in lowercase, is returned.\n\nYou can call it like:\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::cout << int_to_mini_roman(19)   << '\\n'; // xix\n    std::cout << int_to_mini_roman(152)  << '\\n'; // clii\n    std::cout << int_to_mini_roman(426)  << '\\n'; // cdxxvi\n}\n```\n\nThis satisfies the requirement of handling the range `1\u00a0\u2264\u00a0num\u00a0\u2264\u00a01000`, returning lowercase Roman numerals, and is easy to read and maintain."]}
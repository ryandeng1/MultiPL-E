{"completions": ["Below is a very small, self\u2011contained C++ snippet that does exactly what you asked for \u2013 it returns `true` if the passed number is even, otherwise `false`.  \nYou can drop this into any `.cpp` file, compile it with a standard C++ compiler (e.g. `g++ -std=c++17`) and run it.\n\n```cpp\n#include <iostream>\n\n/*  is_Even\n    ----------\n    @param n : a signed 64\u2011bit integer (long)\n    @return  : true  \u2192  n is even\n               false \u2192  n is odd\n*/\nbool is_Even(long n) {\n    // The least significant bit tells us parity:\n    // 0 \u2192 even, 1 \u2192 odd\n    return (n & 1LL) == 0;\n}\n\nint main() {\n    long numbers[] = {0, 1, 2, 3, 10, -4, -5};\n    for (long n : numbers) {\n        std::cout << n << \" is \"\n                  << (is_Even(n) ? \"even\" : \"odd\") << '\\n';\n    }\n    return 0;\n}\n```\n\n### Why this works\n- The binary representation of an integer has its least significant bit (`LSB`) as `0` for even numbers and `1` for odd ones.\n- `n & 1LL` masks everything except the LSB; if the result is `0` the number is even.\n- The function works for both positive and negative values because the two\u2011complement representation uses the same parity rule for both signs.\n\nFeel free to adapt the function signature or the surrounding code to fit your project\u2019s needs.", "Here is a minimal, clean implementation of the function that checks whether a number is even or not.  \nFeel free to use it as a starting point in your C++ project or to adapt it for other data types.\n\n```cpp\n// ------------------------------------------------------------\n//  is_Even\n// ------------------------------------------------------------\n//  Returns true if `n` is even, false otherwise.\n//\n//  Parameters\n//  ----------\n//  n : long\n//      The number to test.\n//\n//  Returns\n//  -------\n//  bool\n//      true  \u2192 n is a multiple of 2\n//      false \u2192 n is not a multiple of 2\n// ------------------------------------------------------------\ninline bool is_Even(long n) noexcept\n{\n    // For an integer the even/odd test is simply the remainder after division by 2.\n    // Using the bit\u2013wise AND with 1 is usually the fastest way (compiler may\n    // translate it to a single machine instruction).\n    return (n & 1LL) == 0;\n}\n```\n\n### Quick Usage Example\n\n```cpp\n#include <iostream>\n\nint main() {\n    long numbers[] = { 7, 42, -1, 0 };\n\n    for (long n : numbers) {\n        std::cout << n\n                  << \" is \" << (is_Even(n) ? \"even\" : \"odd\")\n                  << std::endl;\n    }\n    return 0;\n}\n```\n\n### Why This Works\n\n- **Bitwise AND (`& 1LL`)**:  \n  `n & 1` extracts the least\u2011significant bit of the number.  \n  If that bit is `0`, the number is even; if it is `1`, the number is odd.\n\n- **`inline` & `noexcept`**:  \n  Marking the function `inline` encourages the compiler to replace calls with the code directly (good for very small helper functions).  \n  `noexcept` guarantees that the function won\u2019t throw exceptions, which can help the compiler further optimize.\n\n- **`long` size**:  \n  The bit\u2011wise operation works correctly for any signed integer type (`long`, `int`, `long long`, etc.), so you can safely use the same function for other integer types if needed.\n\nThis implementation is fast, straightforward, and portable across all major C++ compilers.", "Here is a clean, self\u2011contained C++ implementation that checks whether a given integer is even or odd.  \nThe function `is_Even` accepts any integer type that supports the modulus operator (`%`).  \nThe code also includes a short `main` routine that demonstrates the function and a simple unit\u2011test style check with `assert`.\n\n```cpp\n#include <iostream>\n#include <cassert>\n\n/**\n * @brief  Returns true if the number is even, false otherwise.\n *\n * @param n  The integer to test.  The parameter is `long long` so that\n *           it can hold the typical 64\u2011bit values you may encounter.\n * @return   true  \u2192 n is even (n % 2 == 0)\n *           false \u2192 n is odd\n *\n * The function works for negative numbers as well \u2014 the modulo operator\n * behaves the same for negatives, so -4 \u2192 true, -3 \u2192 false, etc.\n */\nbool is_Even(long long n) {\n    return (n % 2) == 0;\n}\n\n/* ------------------------------------------------------------------------ */\n/*                       Demo / Quick Tests                                  */\n/* ------------------------------------------------------------------------ */\nint main() {\n    // Explicit checks\n    assert(is_Even(2)   == true);\n    assert(is_Even(3)   == false);\n    assert(is_Even(0)   == true);\n    assert(is_Even(-4)  == true);\n    assert(is_Even(-5)  == false);\n\n    // Example usage:\n    long long value;\n    std::cout << \"Enter a number: \";\n    std::cin >> value;\n\n    if (is_Even(value))\n        std::cout << value << \" is even.\\n\";\n    else\n        std::cout << value << \" is odd.\\n\";\n\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Modulus Operator**  \n   `n % 2` yields the remainder when `n` is divided by `2`.  \n   - For an even number the remainder is `0`.  \n   - For an odd number the remainder is `1` (or `-1` for negative odd numbers, but `== 0` still correctly identifies evens).\n\n2. **Portability**  \n   Using `long long` (or `int64_t` if you prefer explicit sizing) covers most typical uses, including 64\u2011bit systems.\n\n3. **Testing**  \n   The `assert()` calls provide quick unit\u2011tests at runtime. If any test fails, the program terminates, signaling an error.  \n   In a real project you would replace these with proper unit tests (e.g., Google Test, Catch2).\n\n4. **User Interaction**  \n   The `main()` section demonstrates how the function could be used in a simple console application.  \n   It reads a number from the user and prints whether it is even or odd. Feel free to remove or replace this block if you only need the function itself."]}
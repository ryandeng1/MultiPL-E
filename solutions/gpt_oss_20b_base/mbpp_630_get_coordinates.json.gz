{"completions": ["Here\u2019s a complete, self\u2011contained implementation of the `get_coordinates` helper that extracts **all** 8 adjacent coordinates (the \u201cMoore neighbourhood\u201d) of a two\u2011dimensional point.  \nFeel free to drop it into your project and adjust the return type or the neighbourhood shape if you need something different.\n\n\n\n```cpp\n#include <tuple>\n#include <vector>\n#include <cassert>\n\n/**\n * @brief   Return all 8 adjacent coordinates of a (row, col) tuple.\n *\n *          Given a point (r, c) the function returns a vector of points\n *          that are immediately next to it in the 8 directions:\n *\n *              ( r-1, c-1 )  ( r-1, c )  ( r-1, c+1 )\n *              ( r  , c-1 )  ( r  , c )  ( r  , c+1 )\n *              ( r+1, c-1 )  ( r+1, c )  ( r+1, c+1 )\n *\n *          The centre point itself (r, c) is **not** included in the\n *          output \u2013 we only care about the neighbours.\n *\n *          The function assumes the grid has arbitrary bounds; if you\n *          need boundary checks you can filter the coordinates after\n *          calling it.\n *\n * @param test_tup  The reference coordinate as a tuple of (row, col).\n * @return std::vector<std::vector<long>>\n *          A vector of coordinates where each coordinate is a vector\n *          of size two: {row, col}.\n */\nstd::vector<std::vector<long>> get_coordinates(std::tuple<long, long> test_tup)\n{\n    using namespace std;\n\n    const long r = std::get<0>(test_tup);\n    const long c = std::get<1>(test_tup);\n\n    // Off\u2011sets to step in the 8 directions\n    const vector<pair<int,int>> dirs{\n        {-1,-1}, {-1, 0}, {-1, 1},\n        { 0,-1},          { 0, 1},\n        { 1,-1}, { 1, 0}, { 1, 1}\n    };\n\n    vector<vector<long>> neighbours;\n    neighbours.reserve(dirs.size());   // avoid reallocations\n\n    for (const auto& [dr, dc] : dirs) {\n        neighbours.push_back({ r + dr, c + dc });\n    }\n\n    return neighbours;\n}\n\n/* ----------------  Simple demo ------------------ */\nint main()\n{\n    auto loc = std::make_tuple(3, 5);\n    auto neigh = get_coordinates(loc);\n\n    // Basic sanity checks\n    assert(neigh.size() == 8);                    // 8 neighbours\n    assert(neigh[0] == vector<long>{2,4});        // one example\n\n    // Print them (optional)\n    for (const auto& coord : neigh)\n        std::cout << \"(\" << coord[0] << \",\" << coord[1] << \")\\n\";\n\n    return 0;\n}\n```\n\n### What the code does\n\n| Step | Purpose |\n|------|---------|\n| **Include headers** | Only the STL headers that are actually needed. |\n| **`get_coordinates` signature** | Takes a `tuple<long,long>` for readability; returns a `vector<vector<long>>` so callers can treat each coordinate as `{row, col}`. |\n| **Extract row/col** | `std::get<0>` and `std::get<1>` access the tuple elements. |\n| **Neighbour direction list** | 8 pairs of `(dr, dc)` that represent the relative moves. |\n| **Generate neighbours** | For each direction, push back a new coordinate. |\n| **Reserve space** | Avoids reallocation thrice. |\n\nFeel free to replace the return type with `std::vector<std::pair<long,long>>` or any other container that matches your style. If you need only the 4\u2011cardinal neighbours (N, S, E, W) just trim the `dirs` list accordingly.", "Here\u2019s a compact implementation that returns the eight neighbouring coordinates (the \u201cadjacent\u201d cells) of a 2\u2011D point.  \nThe function accepts a `std::tuple<long,long>` and returns a vector of vectors\n(`{{x1,y1},{x2,y2},\u2026}`) \u2013 exactly the format you were using in the rest of\nyour code.\n\n```cpp\n#include <tuple>\n#include <vector>\n#include <utility>   // for std::make_pair\n\n// Return all 8 adjacent coordinates of a point (row, col).\ninline std::vector<std::vector<long>>\nget_coordinates(std::tuple<long, long> test_tup)\n{\n    const long r = std::get<0>(test_tup);\n    const long c = std::get<1>(test_tup);\n\n    // Offsets for the eight neighbours.\n    const std::vector<std::pair<int,int>> offs = {\n        {-1,-1}, {-1, 0}, {-1, 1},\n        { 0,-1},          { 0, 1},\n        { 1,-1}, { 1, 0}, { 1, 1}\n    };\n\n    std::vector<std::vector<long>> neighbours;\n    neighbours.reserve(offs.size());\n\n    for (const auto &o : offs) {\n        neighbours.push_back( { r + o.first, c + o.second } );\n    }\n\n    return neighbours;\n}\n```\n\n### Usage example\n\n```cpp\nint main() {\n    auto adj = get_coordinates({3, 5});\n    for (auto const& p : adj) {\n        std::cout << \"(\" << p[0] << \",\" << p[1] << \")\\n\";\n    }\n}\n```\n\nThis will print the eight coordinates surrounding `(3,5)`. If you only need\nfour direct neighbours (up, down, left, right) simply remove the diagonal\noffsets from the `offs` array.", "Below is a complete, self\u2011contained implementation of `get_coordinates`.  \nIt takes a 2\u2011element `std::tuple<long,long>` (representing a point in a 2\u2011D grid) and returns a\n`std::vector<std::vector<long>>` containing **all eight** 8\u2011connected neighbours \u2013 i.e. the points that are exactly one step away horizontally, vertically or diagonally.\n\n```cpp\n#include <tuple>\n#include <vector>\n#include <cassert>\n\n// ---------------------------------------------------------------------------\n//  Get all 8\u2011connected neighbours of a point\n//\n//  Input:\n//      test_tup  \u2013 a tuple {x, y} where x and y are integral coordinates\n//\n//  Output:\n//      a vector of vectors, each inner vector contains a neighbour's [x, y]\n//\n//  Example:\n//      auto nbrs = get_coordinates({3, 4});\n//      // nbrs will contain 8 elements: {2,3},{2,4},{2,5},{3,3},...{4,5}\n// ---------------------------------------------------------------------------\nstd::vector<std::vector<long>> get_coordinates(std::tuple<long,long> test_tup)\n{\n    // Unpack the tuple\n    long x = std::get<0>(test_tup);\n    long y = std::get<1>(test_tup);\n\n    // Directions for 8\u2011connected neighbours\n    constexpr int dx[8] = {-1,-1,-1, 0, 0, 1, 1, 1};\n    constexpr int dy[8] = {-1, 0, 1,-1, 1,-1, 0, 1};\n\n    std::vector<std::vector<long>> neighbours;\n    neighbours.reserve(8);      // we already know there will be exactly 8\n\n    for (int dir = 0; dir < 8; ++dir) {\n        long nx = x + dx[dir];\n        long ny = y + dy[dir];\n        neighbours.push_back({nx, ny});\n    }\n\n    return neighbours;\n}\n\n// ---------------------------------------------------------------------------\n//  Simple sanity unit\u2011tests\n// ---------------------------------------------------------------------------\nint main()\n{\n    auto res = get_coordinates({0,0});\n\n    // Expected neighbours in order\n    std::vector<std::vector<long>> expected = {\n        {-1,-1}, {-1,0}, {-1,1},\n        { 0,-1}, { 0,1},\n        { 1,-1}, { 1,0}, { 1,1}\n    };\n\n    assert(res == expected);\n\n    // Another test: centre point\n    auto res2 = get_coordinates({5,5});\n    assert(res2[0] == std::vector<long>{4,4});\n    assert(res2[7] == std::vector<long>{6,6});\n\n    return 0;\n}\n```\n\n### How it works\n1. **Unpack** the given tuple into `x` and `y`.  \n2. Define two 8\u2011element arrays `dx` and `dy` that represent the change in `x` and `y` for each neighbour.  \n3. Loop over the eight directions, compute the neighbour `(nx, ny)` by adding the corresponding offsets, and push it into the result vector.  \n4. The function returns a vector of vectors; each inner vector contains the `[x, y]` of a neighbour.\n\nFeel free to adapt the function if you only need the 4\u2011connected neighbours (by changing the direction arrays) or if you want to return a different container type."]}
{"completions": ["```cpp\n#include <cmath>   // for pow, round\n#include <limits>\n\n// Return true iff a is a perfect cube of an integer\nbool iscube(long a) {\n    if (a == 0) return true;          // 0\u00b3 = 0\n\n    // Work with absolute value, remember the sign later\n    long abs_a = a < 0 ? -a : a;\n\n    // The integer cube root of abs_a is at most the cube root of\n    // the largest 64\u2011bit signed long, which is far below the limits of long.\n    // Compute it by taking the real cube root, rounding to nearest int,\n    // and then squaring it to verify (avoid floating\u2011point drift).\n    double root_d = std::pow(static_cast<double>(abs_a), 1.0 / 3.0);\n    long root = static_cast<long>(std::llround(root_d));\n\n    // Because of rounding errors, the candidate may be off by \u00b11.\n    for (long r = root - 1; r <= root + 1; ++r) {\n        if (r >= 0) {\n            long long cube = (static_cast<long long>(r) *\n                              static_cast<long long>(r) *\n                              static_cast<long long>(r));\n            if (cube == abs_a) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```\n\n**Why this works**\n\n1. The cube root of a `long` is at most ~\\(3 \\times 10^6\\), far below the overflow limits of `long long`.  \n2. We compute the real cube root using `pow` (a `double`) and round to the nearest integer.  \n3. Because floating\u2011point inaccuracies can produce an off\u2011by\u2011one error, we check the candidate plus/minus one.  \n4. The final comparison is performed with 64\u2011bit integers (`long long`) to avoid overflow of the cube.  \n\nThis function runs in constant time and works for all valid `long` inputs, including negative values and zero.", "Here is a straightforward implementation that works for all 64\u2011bit signed integers:\n\n```cpp\n#include <cmath>        // for std::llround, std::cbrt\n#include <limits>\n\nbool iscube(long long a) {\n    // 1. Fast path for trivial cases\n    if (a == 0 || a == 1 || a == -1)\n        return true;\n\n    /* -------------------------------------------------------------\n       2. Compute the integer cube root (rounding towards zero).\n          We cannot simply use `std::cbrt` with `round()` because\n          `std::cbrt` may be slightly imprecise for large values.\n          The following method uses `std::cbrt` to get a good\n          approximation and then corrects it by adjusting \u00b11.\n    ------------------------------------------------------------- */\n\n    // `cbrt` works on `long double` for extra precision.\n    long double d = std::cbrt(static_cast<long double>(a));\n    long long r = static_cast<long long>(std::llround(d));\n\n    /* -------------------------------------------------------------\n       3. Adjust `r` in case the rounding produced an off\u2011by\u2011one.\n          Because a cube grows monotonically, the cube root of a\n          non\u2011zero integer is unique.\n    ------------------------------------------------------------- */\n    while (static_cast<long long>(r) * r * r < a) ++r;\n    while (static_cast<long long>(r) * r * r > a) --r;\n\n    return static_cast<long long>(r) * r * r == a;\n}\n```\n\n### How it works\n\n1. **Trivial cases** \u2013\u00a0`0`, `1`, and `-1` are cubes of themselves.\n2. **Approximation** \u2013 `std::cbrt` gives a very good starting point.\n3. **Correction** \u2013 We adjust the rounded result up or down until\n   `r^3` no longer straddles `a`.  \n   Because cubes are strictly increasing, at most one adjustment in\n   each direction is necessary.\n4. **Final check** \u2013 Compare the corrected cube with the input.\n\nThe function runs in constant time and handles the entire 64\u2011bit\ninteger range correctly.", "**Solution Explanation**\n\nFor an integer `a` we want to answer:\n\n```\nis a cube of some integer ?\n```\n\nThe straightforward way would be to loop over all integers `x` and check\nif `x\u00b3 == a`, but that would be `O(n)` and infeasible for large values.\n\nBecause the cube root of an integer is a single value (up to\nround\u2011off error) we can compute the real cube root and then test\nthe neighbouring integers.\n\n--------------------------------------------------------------------\n\n#### Algorithm\n```\n1. Compute the real cube root r of a (r may be negative).\n2. Let x = round(r)  (nearest integer).\n3. As the rounding can be off by 1, test also x-1 and x+1.\n4. For each candidate c in {x-1, x, x+1}\n       if c\u00b3 == a  \u2192  return true.\n5. return false.\n```\nThe cube of a 64\u2011bit integer can exceed `max(long)` during intermediate\nmultiplication, so we use `__int128` to avoid overflow.\n\n--------------------------------------------------------------------\n\n#### Correctness Proof  \n\nWe prove that the algorithm returns `true` exactly for integer cubes.\n\n*Lemma 1*:  \nLet `a` be an integer and `c*` the (unique) integer such that `c*\u00b3 = a`.\nThen `|c* \u2013 r| \u2264 1`, where `r = cbrt(a)` is the real cube root of `a`.\n\n*Proof of Lemma 1*  \nFor an integer cube the real cube root is exactly that integer:\n`r = c*`.  \nIf `a` is not an integer cube, let `m = floor(cbrt(a))`.  \nThen `m < cbrt(a) < m+1`.  \nSo `r` lies strictly between two consecutive integers, which implies\n`|r - m| < 1` and `|r - (m+1)| < 1`. \u220e\n\n*Lemma 2*:  \nFor any integer cube `a` the rounded integer `x = round(r)` is either\n`c*` or `c* \u00b1 1`.\n\n*Proof of Lemma 2*  \nFrom Lemma&nbsp;1, `|c* \u2013 r| \u2264 1`.  \nIf `r` is exactly halfway between two integers, `round` will choose one\nof them; in any case the integer closest to `r` differs from `c*` by at\nmost one. \u220e\n\n*Theorem*:  \n`iscube(a)` returns `true` **iff** `a` is the cube of an integer.\n\n*Proof*  \n\n- (**If**)  \n  Assume `a = k\u00b3` for some integer `k`.  \n  By Lemma&nbsp;2, one of `x-1, x, x+1` equals `k`.  \n  The algorithm checks all three candidates, and for the one equal to\n  `k` the test `c\u00b3 == a` succeeds, so the function returns `true`.\n\n- (**Only if**)  \n  Suppose the algorithm returns `true`.  \n  Then for some tested candidate `c`, `c\u00b3 == a`.  \n  Since `c` is an integer, `a` is a perfect cube. \u220e\n\n--------------------------------------------------------------------\n\n#### Complexity Analysis  \n\nAll operations are constant time:\ncube root, few arithmetic operations, and a constant number of checks.\nHence\n\n```\nTime   : O(1)\nMemory : O(1)\n```\n\n--------------------------------------------------------------------\n\n#### Reference Implementation  (C++17)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*  Return true iff 'a' is the cube of an integer. */\nbool iscube(long long a) {\n    // real cube root, may be negative\n    long double r = cbrtl(static_cast<long double>(a));\n    // nearest integer to r\n    long long x = llround(r);\n\n    // test x-1, x, x+1\n    for (long long c = x - 1; c <= x + 1; ++c) {\n        __int128 cube = (__int128)c * c * c;   // avoid overflow\n        if (cube == a) return true;\n    }\n    return false;\n}\n\n/* Test harness */\n#ifdef LOCAL\nint main() {\n    vector<long long> tests = {1, 2, -1, 64, 0, 180};\n    for (auto v : tests) {\n        cout << v << \" -> \" << (iscube(v) ? \"true\" : \"false\") << endl;\n    }\n}\n#endif\n```\n\nThe implementation follows exactly the algorithm proven correct above\nand is fully compliant with the C++17 standard."]}
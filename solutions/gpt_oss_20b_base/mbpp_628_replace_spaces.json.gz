{"completions": ["Here\u2019s a complete, self\u2011contained implementation that replaces every space character in the input string with \u201c%20\u201d.  \nThe solution works in **O(n)** time (single scan) and **O(1)** extra space when we modify the string in place (using the fact that `std::string` already owns a mutable buffer).  \n\n```cpp\n#include <iostream>\n#include <string>\n#include <cassert>\n\n/**\n * @brief Replace every space character in the input string with \"%20\".\n *\n * The function works in linear time and constant extra space by modifying\n * the string in place.  If the string has no spaces the original string\n * is returned unchanged.\n *\n * @param s The string to be processed (modified in place).\n * @return std::string reference to the processed string.\n */\nstd::string& replace_spaces(std::string &s) {\n    // Count how many spaces we need to replace.\n    size_t space_count = 0;\n    for (char c : s)\n        if (c == ' ') ++space_count;\n\n    if (space_count == 0) return s;          // nothing to do\n\n    // New length = old length + space_count * 2\n    size_t new_len = s.size() + space_count * 2;\n    s.resize(new_len);                       // make room\n\n    // Work from the end to avoid overwriting characters we have yet to process.\n    size_t i = s.size() - 1;      // index in the original string\n    size_t j = new_len - 1;       // index in the resized string\n\n    while (i > space_count) {\n        if (s[i] == ' ') {\n            s[j--] = '0';\n            s[j--] = '2';\n            s[j--] = '%';\n        } else {\n            s[j--] = s[i];\n        }\n        --i;\n    }\n\n    // Handle the very first characters (when i == 0..space_count-1)\n    while (i < space_count) {            // i is unsigned, so stop when i wraps\n        if (s[i] == ' ') {\n            s[j--] = '0';\n            s[j--] = '2';\n            s[j--] = '%';\n        } else {\n            s[j--] = s[i];\n        }\n        if (i == 0) break;                // prevent underflow\n        --i;\n    }\n\n    return s;\n}\n\nint main() {\n    std::string test = \"Mr John Smith\";\n    replace_spaces(test);\n    std::cout << test << '\\n';           // -> \"Mr%20John%20Smith\"\n\n    // Quick unit tests\n    assert(replace_spaces(std::string(\"\")) == \"\");\n    assert(replace_spaces(std::string(\"no spaces\")) == \"no%20spaces\");\n    assert(replace_spaces(std::string(\"   \")) == \"%20%20%20\");\n\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\n### How it works\n\n1. **Count spaces** \u2013 we first scan the string to know how many spaces will be replaced, so we can compute the required new length.\n2. **Resize** \u2013 we enlarge the string in place (`s.resize(new_len)`) to make room for the extra two characters for each space.\n3. **Reverse scan** \u2013 starting from the end of the original string and the end of the resized string, we copy characters.  \n   - If we encounter a space, we write `\"%\"`, `\"2\"`, `\"0\"` into the new positions.  \n   - Otherwise, we copy the current character.\n4. Because we work backward, no data is overwritten prematurely.\n\nThis implementation is straightforward, uses only the standard library, and is efficient for typical usage.", "Here is a complete, self\u2011contained implementation that replaces every space in a string with the substring `\"%20\"`.  \nThe function works for any `std::string` (including empty strings or those that contain no spaces), and it does *not* modify the original string but returns a new one.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// Replace all spaces in the given string with \"%20\".\n/// @param s The input string.\n/// @return A new string where every space has been replaced by \"%20\".\nstring replace_spaces(const string& s)\n{\n    // Count the number of spaces first so we can reserve the exact amount of memory.\n    size_t space_count = 0;\n    for (char ch : s)\n        if (ch == ' ')\n            ++space_count;\n\n    // If there are no spaces we can just return a copy of the original string.\n    if (space_count == 0)\n        return s;\n\n    // Each space will be replaced with 3 characters (\"%20\") instead of 1.\n    // Reserve enough space to avoid multiple reallocations.\n    string result;\n    result.reserve(s.size() + space_count * 2); // +2 because \"%20\" is 2 chars longer than a single space\n\n    for (char ch : s)\n    {\n        if (ch == ' ')\n            result.append(\"%20\");\n        else\n            result.push_back(ch);\n    }\n\n    return result;\n}\n\n// -----------------------------------------------------------------------------\n// Example usage and simple tests\n// -----------------------------------------------------------------------------\nint main()\n{\n    vector<string> tests = {\n        \"\",\n        \"no spaces\",\n        \"  leading\",\n        \"trailing  \",\n        \"multiple   spaces\",\n        \"a b c\",\n        \"   \",\n        \"no_space\"\n    };\n\n    for (const auto& original : tests) {\n        cout << \"Original: \\\"\" << original << \"\\\"\\n\";\n        cout << \"Result  : \\\"\" << replace_spaces(original) << \"\\\"\\n\";\n        cout << \"----\\n\";\n    }\n\n    // Extra assertion to satisfy the question\n    assert(replace_spaces(\"hello world\") == \"hello%20world\");\n    return 0;\n}\n```\n\n### How it works\n\n1. **Counting spaces** \u2013 We first iterate over the input once to count how many spaces there are.  \n2. **Early exit** \u2013 If there are no spaces, we simply return a copy of the original string.  \n3. **Reserve capacity** \u2013 Knowing how many spaces we need to replace allows us to reserve the exact amount of memory (`size() + 2 * space_count`) so that the `string` will not have to re\u2011allocate while we build the result.  \n4. **Building the result** \u2013 We iterate again, appending either `\"%20\"` when we hit a space or the original character otherwise.\n\nThe solution runs in **O(n)** time and uses **O(n)** additional space (the resulting string). It is easy to read, works for all character encodings that use the ordinary ASCII space (`' '`), and can be adapted to other separators simply by changing the constant we append.", "Here\u2019s a clean, idiomatic C++ implementation that does exactly what the problem asks for:\n\n```cpp\n#include <string>\n\n/// \\brief Replace every space character in a string with the literal string \"%20\".\n/// \\param s  The input string that may contain spaces.\n/// \\return   A new string where all spaces are replaced by \"%20\".\nstd::string replace_spaces(const std::string& s)\n{\n    // Reserve enough space for the worst\u2011case scenario:\n    // if every character is a space, we need 3 times as many characters.\n    std::string res;\n    res.reserve(s.size() * 3);\n\n    for (char c : s)\n    {\n        if (c == ' ')\n            res.append(\"%20\");\n        else\n            res.push_back(c);\n    }\n\n    return res;\n}\n```\n\n### Why this version?\n\n| Feature | Why it matters |\n|---------|----------------|\n| **`const std::string&` input** | No unnecessary copy of the input. |\n| **Pre\u2011reserved capacity** | Minimises re\u2011allocations when the output is longer. |\n| **`append` vs `push_back`** | `append(\"%20\")` is efficient for the three\u2011character literal. |\n| **No extra includes** | `<bits/stdc++.h>` is omitted; we only need `<string>`. |\n| **Readable code** | Comments explain the intention. |\n\n### How to test it\n\n```cpp\n#include <iostream>\n#include <cassert>\n\nint main()\n{\n    assert(replace_spaces(\"Mr John Smith\") == \"Mr%20John%20Smith\");\n    assert(replace_spaces(\" \") == \"%20\");\n    assert(replace_spaces(\"\") == \"\");\n\n    std::cout << replace_spaces(\"Hello  World\") << '\\n'; // Hello%20%20World\n    return 0;\n}\n```\n\nThe function runs in **O(n)** time and uses **O(n)** extra space, where *n* is the length of the input string. This is optimal for a single\u2011pass replacement without modifying the original string."]}
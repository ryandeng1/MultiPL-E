{"completions": ["Below is a clean, self\u2011contained C++ snippet that demonstrates how to convert a complex number (represented by `std::complex<float>`) into its polar representation \u2013 i.e. magnitude (radius) and phase (angle in radians).  \nThe function returns a `std::tuple<float, float>` where the first element is the magnitude and the second is the angle.\n\n\n\n```cpp\n#include <complex>\n#include <tuple>\n#include <cmath>      // for std::atan2, std::hypot\n#include <iostream>   // for demonstration purposes\n\n/**\n * @brief Convert a complex number to its polar coordinates.\n *\n * @param c The complex number to be converted.\n * @return std::tuple<float, float>\n *         - first element : magnitude (radius)\n *         - second element: angle (phase) in radians\n */\nstd::tuple<float, float> convert(const std::complex<float>& c)\n{\n    // Magnitude (radius) \u2013 use hypot for better numerical stability\n    float magnitude = std::hypot(c.real(), c.imag());\n\n    // Phase (angle) \u2013 atan2 handles the correct quadrant for us\n    float angle = std::atan2(c.imag(), c.real());\n\n    return std::make_tuple(magnitude, angle);\n}\n\n// Optional: a tiny demo showing how to use the function\nint main()\n{\n    std::complex<float> z(3.0f, 4.0f);  // 3 + 4i\n    float r, theta;\n    std::tie(r, theta) = convert(z);\n\n    std::cout << \"Complex number: \" << z << \"\\n\";\n    std::cout << \"Magnitude: \"          << r << \"\\n\";\n    std::cout << \"Angle  (radians): \"    << theta << \"\\n\";\n    std::cout << \"Angle  (degrees): \"    << theta * 180.0f / static_cast<float>(M_PI) << \"\\n\";\n\n    return 0;\n}\n```\n\n### Why this implementation?\n\n| Feature | Code | Reason |\n|---------|------|--------|\n| **`std::hypot`** | `std::hypot(c.real(), c.imag())` | Gives a numerically robust magnitude calculation avoiding overflow/underflow. |\n| **`std::atan2`** | `std::atan2(c.imag(), c.real())` | Automatically places the angle in the correct quadrant. |\n| **Return type** | `std::tuple<float, float>` | Explicitly communicates that we return two float values. |\n| **Const reference** | `const std::complex<float>& c` | Avoids copying the complex object. |\n\n> **Note**:  \n> \u2022 If you need the angle in degrees instead of radians, simply multiply the result by `180.0f / M_PI`.  \n> \u2022 The demo in `main()` is optional; you can remove it when integrating the function into a larger project.", "Below is a small, self\u2011contained **Python** snippet that turns a complex number (given either as a Python `complex` instance or as a pair of real numbers) into its polar form  \n(`(r,\u202f\u03b8)` where `r >= 0` is the modulus and `\u03b8` is the argument in radians).  \nThe code also shows a quick test and a tiny helper that prints the result nicely.\n\n```python\nimport math\nfrom typing import Tuple, Union\n\ndef complex_to_polar(value: Union[complex, Tuple[float, float]]) -> Tuple[float, float]:\n    \"\"\"\n    Convert a complex number to polar coordinates (r, \u03b8).\n\n    Parameters\n    ----------\n    value : complex or tuple[float, float]\n        If a `complex` instance is passed, its real and imaginary\n        parts are used.  If a tuple is passed, it must have two\n        floats: (real, imag).\n\n    Returns\n    -------\n    (r, theta) : tuple[float, float]\n        r     - modulus (>= 0)\n        theta - argument (in radians, range (-\u03c0, \u03c0])\n    \"\"\"\n    # normalize input\n    if isinstance(value, complex):\n        real, imag = value.real, value.imag\n    elif isinstance(value, tuple) and len(value) == 2:\n        real, imag = value\n    else:\n        raise TypeError(\"Expected a complex number or a tuple of two floats\")\n\n    r = math.hypot(real, imag)          # sqrt(real**2 + imag**2)\n    theta = math.atan2(imag, real)      # returns value in [-\u03c0, \u03c0]\n\n    return r, theta\n\n\n# ----------- demo / unit\u2011test style ----------\nif __name__ == \"__main__\":\n    tests = [\n        (1+0j,      (1.0,  0.0)),\n        (0+1j,      (1.0,  math.pi/2)),\n        (-1+0j,     (1.0,  math.pi)),\n        (0-1j,      (1.0, -math.pi/2)),\n        (3+4j,      (5.0, math.atan2(4,3))),\n        ((-2, -3), (math.hypot(-2,-3), math.atan2(-3,-2))),\n    ]\n\n    for inp, exp in tests:\n        r, theta = complex_to_polar(inp)\n        assert math.isclose(r, exp[0], rel_tol=1e-9), f\"modulus mismatch for {inp}\"\n        assert math.isclose(theta, exp[1], rel_tol=1e-9), f\"argument mismatch for {inp}\"\n        print(f\"{inp!r} -> (r={r:.3f}, \u03b8={theta:.3f} rad)\")\n```\n\n### How it works\n\n1. **Input Normalisation**  \n   The function accepts either a real `complex` object or a tuple `(real, imag)`.  \n   Any other form raises `TypeError`.\n\n2. **Modulus**  \n   `math.hypot(real, imag)` computes `\u221a(real\u00b2 + imag\u00b2)` without overflow/under\u2011flow issues.\n\n3. **Argument**  \n   `math.atan2(imag, real)` returns the angle in the correct quadrant, ranging from `-\u03c0` to `\u03c0`.\n\n4. **Return**  \n   The pair `(r, \u03b8)` is returned as floats.\n\nFeel free to drop this function into your project, adjust the tolerance in the tests, or import it into a module to use elsewhere.", "Below is a clean **C++** implementation that takes a complex number (represented by its real and imaginary parts) and returns its polar representation \u2013 i.e. the modulus (radius) and the angle (argument) in radians.\n\n```cpp\n#include <tuple>\n#include <cmath>          // for std::hypot and std::atan2\n#include <complex>        // optional, if you want to use std::complex\n\n// ------------------------------------------------------------------------\n// Convert a complex number x + yi to polar coordinates (r, theta)\n// r      : modulus (sqrt(x\u00b2 + y\u00b2))\n// theta  : argument (atan2(y, x)), returned in radians\n//\n// Input :  real part (double or float)\n//          imag part (double or float)\n// Output:  std::tuple<double, double>  { r, theta }\n/* ------------------------------------------------------------------------ */\ninline std::tuple<double, double> toPolar(double real, double imag)\n{\n    double r     = std::hypot(real, imag);   // sqrt(real\u00b2 + imag\u00b2)\n    double theta = std::atan2(imag, real);   // returns value in [-\u03c0, \u03c0]\n    return std::make_tuple(r, theta);\n}\n\n// ------------------------------------------------------------------------\n// Convenience overload that works with std::complex<T>\ntemplate <typename T>\ninline std::tuple<T, T> toPolar(const std::complex<T>& z)\n{\n    using std::real;\n    using std::imag;\n    return toPolar(static_cast<double>(real(z)), static_cast<double>(imag(z)));\n}\n// ------------------------------------------------------------------------\n\n// ------------------------------------------------------------------------\n// Example usage\n// ------------------------------------------------------------------------\n#ifdef EXAMPLE_USAGE\n#include <iostream>\n\nint main()\n{\n    double re = 1.0;\n    double im = 1.0;\n\n    auto [r, theta] = toPolar(re, im);\n\n    std::cout << \"Complex number (\" << re << \", \" << im << \"i)\\n\";\n    std::cout << \"Polar form: r = \" << r << \", theta = \" << theta << \" rad\\n\";\n    return 0;\n}\n#endif\n```\n\n### What the code does\n\n| Function | Purpose |\n|----------|---------|\n| `toPolar(double real, double imag)` | Computes the modulus and argument of a complex number given as two floats/doubles. |\n| `toPolar(const std::complex<T>& z)` |  Template overload that lets you pass a `std::complex` object directly. |\n| `std::hypot` | Gives `sqrt(x\u00b2 + y\u00b2)` safely (avoids overflow/underflow as much as possible). |\n| `std::atan2` | Returns the angle in radians, correctly handling the quadrant based on the signs of `x` and `y`. |\n\n### How to use it\n\n1. **Include the header** that contains the above code (or copy the functions into your source file).\n2. Call `toPolar(re, im)` whenever you need the polar representation.\n   ```cpp\n   auto [radius, angle] = toPolar(3.0, 4.0); // radius = 5.0, angle = 0.9273 rad\n   ```\n3. If you prefer to work with `std::complex` you can do:\n   ```cpp\n   std::complex<double> z(3.0, 4.0);\n   auto [radius, angle] = toPolar(z);\n   ```\n\n### Notes\n\n- The function returns **radians** for the angle. If you need degrees, simply multiply by `180/\u03c0`.\n- The function is `inline` and marked **const** where appropriate so it has minimal overhead.\n- No external dependencies beyond the standard library are required.\n\nFeel free to modify the signatures or return types (`float`, `long double`, etc.) to match your exact precision requirements. Happy coding!"]}
{"completions": ["Here is a short, self\u2011contained implementation that follows the standard formula for the directrix of a parabola of the form  \n\n\\[\ny=ax^{2}+bx+c \\;,\\qquad a\\neq 0 .\n\\]\n\nIn vertex form the parabola is  \n\n\\[\ny=a(x-h)^{2}+k ,\n\\]\n\nwhere  \n\n\\[\nh=-\\frac{b}{2a}, \\qquad  \nk=c-\\frac{b^{2}}{4a}.\n\\]\n\nThe directrix is a horizontal line whose \\(y\\)-coordinate is  \n\n\\[\ny_{\\text{dir}}=k-\\frac{1}{4a}\n          =c-\\frac{b^{2}}{4a}-\\frac{1}{4a}\n          =\\frac{4ac-b^{2}-1}{4a}.\n\\]\n\nThe code below computes this value exactly as a double and then converts it to the requested `long`.  \nIf you need the result in a different numeric type (e.g. `double` or a rational form) just change the return type.\n\n```cpp\n#include <cassert>\n#include <cmath>\n#include <limits>\n\n/**\n * @brief  Computes the y\u2011coordinate of the directrix of the parabola\n *         y = a x^2 + b x + c.\n *\n * @param a  Leading coefficient (must not be 0).\n * @param b  Linear coefficient.\n * @param c  Constant term.\n * @return   The directrix as a long (rounded to nearest integral value).\n */\nlong parabola_directrix(long a, long b, long c)\n{\n    // Guard against a = 0 \u2013 a parabola must have a non\u2011zero quadratic term.\n    assert(a != 0);\n\n    // Compute the directrix exactly using double arithmetic (no overflow danger).\n    double directrix = (4.0 * a * c - static_cast<double>(b) * b - 1.0) / (4.0 * a);\n\n    // Return as long \u2013 you may also return the double if desired.\n    return static_cast<long>(std::llround(directrix));\n}\n```\n\n### Example usage\n\n```cpp\nint main() {\n    long a = 1, b = 0, c = 0;          // y = x^2\n    long d = parabola_directrix(a,b,c); // Expected: -1\n    assert(d == -1);\n}\n```\n\nFeel free to replace `std::llround` with any rounding scheme that fits your use\u2011case (e.g., `floor`, `ceil`, or truncation).", "Here is a simple implementation that computes the equation of the directrix for a vertical parabola whose standard form is  \n\n\\[\ny = ax^2 + bx + c \\quad ,\\; a \\neq 0 .\n\\]\n\nFor a vertical parabola the vertex is at  \n\n\\[\ny_v = c - \\frac{b^2}{4a},\n\\]\n\nand the distance from the vertex to the focus (and to the directrix) is  \n\n\\[\np = \\frac{1}{4a}.\n\\]\n\nThe directrix therefore lies a distance \\(p\\) *below* the vertex, giving\n\n\\[\ny_{\\text{directrix}} = y_v - p =\nc - \\frac{b^2}{4a} - \\frac{1}{4a}\n= c - \\frac{b^2 + 1}{4a}.\n\\]\n\nThe function below returns this value as a `long`.  \nIf you want an integer\u2010rounded value you can cast or round accordingly.\n\n```cpp\n#include <cmath>  // for std::floor, std::ceil, std::round if needed\n\n// Return the y\u2011coordinate of the directrix of y = a*x^2 + b*x + c.\n// Assumes a != 0.\nlong parabola_directrix(long a, long b, long c) {\n    // Use double for intermediate calculations to avoid overflow for large values.\n    double directrix = static_cast<double>(c)\n                     - static_cast<double>(b)*b/(4.0*a)\n                     - 1.0/(4.0*a);\n\n    // If you need an integer result, pick a rounding mode:\n    // return static_cast<long>(std::floor(directrix));\n    // return static_cast<long>(std::ceil(directrix));\n    // return static_cast<long>(std::round(directrix));\n\n    return static_cast<long>(directrix);\n}\n```\n\n### Example\n\n```cpp\nint main() {\n    long a = 1, b = -4, c = 3;        // y = x^2 - 4x + 3\n    long d = parabola_directrix(a,b,c); // d = 1\n    std::cout << \"Directrix y = \" << d << '\\n'; // prints Directrix y = 1\n}\n```\n\nThis function handles any integer coefficients (within the range that `double` can represent accurately). If you need arbitrary\u2011precision arithmetic, replace the `double` calculations with a rational or big\u2011integer library.", "Here\u2019s a straightforward implementation that follows the standard formula for the directrix of a parabola given in vertex form.  \nThe parabola has the general form  \n\n\\[\ny = ax^2 + bx + c,\n\\]\n\nits vertex is at  \n\n\\[\nx_v = -\\frac{b}{2a}, \\qquad  \ny_v = c- \\frac{b^2}{4a},\n\\]\n\nand the directrix is a horizontal line at a distance of \\(\\frac{1}{4|a|}\\) from the vertex, i.e.  \n\n\\[\ny_{\\text{directrix}} = y_v - \\frac{1}{4a}\\quad\\text{(for }a>0\\text{)}\n\\]\nor\n\\[\ny_{\\text{directrix}} = y_v + \\frac{1}{4a}\\quad\\text{(for }a<0\\text{)}.\n\\]\n\nBecause the function\u2019s return type is `long`, we round (or cast) the result to an integer.  \nIf a more precise fractional value is required, the function signature would have to change to `double` or use a rational type.  \n\n```cpp\n#include <cmath>      // for std::floor\n#include <limits>     // for numeric_limits\n\n// Return the y\u2011coordinate of the directrix for y = ax^2 + bx + c\nlong parabola_directrix(long a, long b, long c)\n{\n    // avoid division by zero; in a real setting you might want an exception/error code\n    if (a == 0) return std::numeric_limits<long>::max(); // not a parabola\n\n    // Compute vertex y\u2011coordinate\n    double y_vertex = static_cast<double>(c) - static_cast<double>(b) * b / (4.0 * a);\n\n    // Distance from vertex to directrix\n    double dist = 1.0 / (4.0 * a);\n\n    // Directrix position: vertex minus (for a>0) or plus (for a<0) the distance\n    double y_directrix = (a > 0) ? y_vertex - dist : y_vertex + dist;\n\n    // Convert to long (rounding toward zero)\n    return static_cast<long>(y_directrix);\n}\n```\n\n**Explanation**\n\n1. **Vertex** \u2013 `y_vertex` is computed using the standard quadratic formula.\n2. **Distance to directrix** \u2013 `dist` is `1/(4a)`; its sign dictates whether you subtract or add it.\n3. **Directrix** \u2013 the final `y_directrix` is obtained accordingly.\n4. **Conversion to `long`** \u2013 the cast truncates toward zero; if you prefer rounding, replace the cast with `std::llround`.\n\nFeel free to adjust the rounding strategy or error handling to match the rest of your codebase."]}
{"completions": ["Below is a small, self\u2011contained implementation of the `common` function that satisfies all of the\nrequirements that were listed in your comment:\n\n```cpp\n#include <bits/stdc++.h>            // or <vector> <unordered_set> <algorithm>\nusing namespace std;\n\n/// Return the sorted list of unique elements that occur in **both** vectors.\n///\n/// The function\n///   * removes duplicates in each input vector,\n///   * keeps only the elements that are present in both vectors,\n///   * sorts the result and returns it.\n///\nvector<long> common(vector<long> l1, vector<long> l2) {\n    // 1.  Put both vectors into unordered_sets \u2013 this removes duplicates.\n    unordered_set<long> s1(l1.begin(), l1.end());\n    unordered_set<long> s2(l2.begin(), l2.end());\n\n    // 2.  Compute the intersection.\n    vector<long> result;\n    result.reserve(min(s1.size(), s2.size()));\n    for (const long &x : s1) {\n        if (s2.find(x) != s2.end())\n            result.push_back(x);\n    }\n\n    // 3.  Sort the unique common elements.\n    sort(result.begin(), result.end());\n    return result;\n}\n```\n\n### Example usage\n\n```cpp\nint main() {\n    vector<long> v1 = {1,4,3,34,653,2,5};\n    vector<long> v2 = {5,7,1,5,9,653,121};\n\n    auto res = common(v1, v2);\n    for (long x : res) cout << x << ' ';   // prints: 1 5 653\n    cout << '\\n';\n}\n```\n\nThe implementation uses only the C++ standard library (no external dependencies) and works for\nany size of the input vectors. If you prefer not to use `unordered_set`, you can use `std::set`\ninstead \u2013 the complexity stays `O(n log n)` and the solution remains clear and concise.", "Here\u2019s a concise implementation that:\n\n1. Builds sets from the input vectors to remove duplicates.\n2. Finds the intersection of those sets.\n3. Copies the result into a vector and sorts it.\n\n```cpp\n#include <vector>\n#include <unordered_set>\n#include <algorithm>\n\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n    // Build sets to discard duplicates\n    std::unordered_set<long> s1(l1.begin(), l1.end());\n    std::unordered_set<long> s2(l2.begin(), l2.end());\n\n    // Store intersection in a vector\n    std::vector<long> result;\n    result.reserve(std::min(s1.size(), s2.size()));\n\n    // Iterate over the smaller set for efficiency\n    if (s1.size() < s2.size()) {\n        for (const auto& val : s1)\n            if (s2.count(val)) result.push_back(val);\n    } else {\n        for (const auto& val : s2)\n            if (s1.count(val)) result.push_back(val);\n    }\n\n    // Sort the result\n    std::sort(result.begin(), result.end());\n    return result;\n}\n```\n\n> **Explanation**\n\n* The `unordered_set` removes duplicated elements from each input vector.\n* The intersection logic checks each element of the smaller set against the larger one, which keeps the algorithm fast even for large vectors.\n* Finally, we sort the result vector to meet the \u201csorted unique\u201d requirement.\n\nThis version runs in **O(n\u202f+\u202fm)** time (ignoring the cost of sorting, which is `O(k log k)` where `k` is the size of the intersection).", "Here\u2019s a compact, self\u2011contained implementation that meets the described behaviour:\n\n```cpp\n#include <vector>\n#include <unordered_set>\n#include <algorithm>\n\n// Return a sorted vector containing the unique elements that are present in both l1 and l2\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n    // Build a hash set from the first vector for O(1) membership checks\n    std::unordered_set<long> first(l1.begin(), l1.end());\n\n    // Second set to keep only unique matches\n    std::unordered_set<long> resultSet;\n\n    // Scan the second vector and keep elements that appear in the first set\n    for (auto &&v : l2) {\n        if (first.find(v) != first.end()) {\n            resultSet.insert(v);\n        }\n    }\n\n    // Convert the set into a vector so we can sort it\n    std::vector<long> result(resultSet.begin(), resultSet.end());\n    std::sort(result.begin(), result.end());\n\n    return result;\n}\n```\n\n**Key points**\n\n1. The implementation is *O(n + m)* in time (with `n` and `m` the sizes of the two vectors) thanks to the hash\u2011set lookups.  \n2. It guarantees **unique** items because we store matches in an unordered set (`resultSet`).  \n3. The final vector is **sorted** with `std::sort`.\n\nYou can plug this function into the snippet you posted \u2013 the doctest\u2011style examples will produce the expected outputs."]}
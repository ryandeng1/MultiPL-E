{"completions": ["Below is a short, self\u2011contained C++ routine that returns the **largest prime number that is strictly smaller than the given value\u202f`N`**.\n\n> **Why a prime?**  \n> In most interview\u2011style questions, \u201cthe closest smaller number\u201d refers to the next\u2011smaller **prime**. The code demonstrates a clean, efficient way to do that \u2013 it first handles trivial cases (N\u00a0\u2264\u202f3), then checks successive integers downward using a classic deterministic Miller\u2011Rabin test for 64\u2011bit inputs (fast for all inputs that fit in a `long`).  \n> The implementation works for the full 64\u2011bit signed range (`-9\u202f223\u202f372\u202f036\u202f854\u202f775\u202f808 \u2026 9\u202f223\u202f372\u202f036\u202f854\u202f775\u202f807`) and is fully compilable under any modern C++ compiler (the code is compliant with C++17).\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* -------------------------------------------------------------\n   Fast deterministic Miller\u2011Rabin primality test for 64\u2011bit integers\n   ------------------------------------------------------------- */\nstatic bool isPrime(uint64_t n) {\n    if (n < 2)                return false;\n    for (uint64_t p : {2,3,5,7,11,13,17,19,23,29,31,37}) {\n        if (n % p == 0) return n == p;\n    }\n\n    // write n-1 as d * 2^s\n    uint64_t d = n - 1, s = 0;\n    while ((d & 1) == 0) { d >>= 1; ++s; }\n\n    auto power_mod = [](uint64_t a, uint64_t e, uint64_t mod) {\n        __uint128_t r = 1, x = a % mod;\n        while (e) {\n            if (e & 1) r = (r * x) % mod;\n            x = (x * x) % mod;\n            e >>= 1;\n        }\n        return (uint64_t)r;\n    };\n\n    // Deterministic bases for n < 2^64\n    const uint64_t bases[] = {2ULL,325ULL,9375ULL,28178ULL,450775ULL,9780504ULL,1795265022ULL};\n\n    for (uint64_t a : bases) {\n        if (a % n == 0) continue;\n        uint64_t x = power_mod(a, d, n);\n        if (x == 1 || x == n - 1) continue;\n        bool composite = true;\n        for (uint64_t r = 1; r < s; ++r) {\n            x = (__uint128_t)x * x % n;\n            if (x == n - 1) { composite = false; break; }\n        }\n        if (composite) return false;\n    }\n    return true;\n}\n\n/* -------------------------------------------------------------\n   closest_num : returns the largest prime < N\n   ------------------------------------------------------------- */\nlong closest_num(long N) {\n    if (N <= 3) return 2;          // only primes < N are 2\n    long candidate = N - 1;\n    if (candidate % 2 == 0 && candidate > 2) --candidate; // skip even >2\n\n    while (candidate >= 2) {\n        if (isPrime((uint64_t)candidate))\n            return (long)candidate;\n        candidate -= 2;           // check next odd number\n    }\n    return 2; // fallback \u2013 never reached for N>3\n}\n```\n\n### Explanation\n\n| Step | What it does |\n| ---- | ------------ |\n| **Sieve\u2011like checks** | The initial for\u2011loop quickly rules out numbers divisible by small primes (`2\u202637`). |\n| **Write n\u20111 = d\u00b72^s** | Standard Miller\u2011Rabin preparation. |\n| **Deterministic bases** | For 64\u2011bit integers the seven bases (`2,325,\u2026`) are proven to be enough to test all numbers `<2^64`. |\n| **Odd\u2011step search** | After the boundary conditions, only odd numbers are examined, halving the work. |\n| **Return** | The first prime found is guaranteed to be the closest prime below `N`. |\n\nFeel free to drop this snippet into any project. It compiles with `g++ -std=c++17` (or higher) and runs in **O(log\u202fN)** per test.", "Below is a compact, self\u2011contained implementation that returns **the largest integer smaller than\u202f`N` that has the same number of 1\u2011bits as `N`**.  \n(The \u201cclosest smaller number\u201d in many interview/coding\u2011exercise contexts refers to this definition \u2013 i.e. the next permutation of the binary representation with the same pop\u2011count.)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n//--------------------------------------------------------------------------\n// Return the largest integer < N that has the same pop\u2011count as N.\n// If no such number exists (i.e. N is of the form 2^k \u2013 1 \u2192 all ones on the\n// right), the function returns -1 (you can change this behaviour if you\n// prefer some other sentinel value).\n//--------------------------------------------------------------------------\nlong closest_num(long N) {\n    if (N <= 1) return -1;          // nothing smaller with same 1\u2011bits\n\n    // 1) Find the rightmost sequence \"10\"  (i.e. a '0' that has a 1 to its left).\n    //    Let pos1 be the position of that '0', pos2 the adjacent '1' on its left.\n    long c = N;\n    int pos0 = -1, pos1 = -1; // positions of the flipped bits\n\n    // Find the first '0' that has a '1' bit to its left\n    for (int i = 0; i < 64; ++i) {\n        if ( (c & (1LL << i)) == 0 ) {          // bit i is 0\n            // Check for a '1' somewhere to the left of i\n            int j = i - 1;\n            while (j >= 0 && !(c & (1LL << j))) {\n                --j;\n            }\n            if (j >= 0) {                       // found the pattern 10\n                pos0 = i;   // the 0 that will become 1\n                pos1 = j;   // the 1 that will become 0\n                break;\n            }\n        }\n    }\n\n    if (pos0 == -1) return -1;   // no \u201c10\u201d pattern found \u2192 already the smallest\n\n    // 2) Flip those bits: 0->1 at pos0, 1->0 at pos1\n    long res = N;\n    res ^= (1LL << pos0);   // flip the 0 to 1\n    res ^= (1LL << pos1);   // flip the 1 to 0\n\n    // 3) Make sure all bits to the right of pos0 are arranged as\n    //    the maximal value with the remaining 1\u2011bits (i.e. all 1\u2011bits to\n    //    the far right).  That \u201crearrangement\u201d guarantees that the result\n    //    is the largest number smaller than the original with the same\n    //    population count.\n\n    // Count the number of 1\u2011bits that now appear right of pos0\n    int onesRight = __builtin_popcountll(res & ((1LL << pos0) - 1));\n\n    // Clear all bits right of pos0\n    res &= ~((1LL << pos0) - 1);\n\n    // Re\u2011set those 1\u2011bits at the very right side\n    res |= (1LL << onesRight) - 1;\n\n    return res;\n}\n\n//--------------------------------------------------------------------------\n// Simple test harness (remove or comment out when using in production)\n//--------------------------------------------------------------------------\nint main() {\n    vector<long> tests = {10, 7, 12, 1, 16, 26};\n    for (auto n : tests) {\n        long r = closest_num(n);\n        cout << \"N = \" << n << \" \u2192 closest smaller with same popcount = \"\n             << (r == -1 ? -1 : r) << '\\n';\n    }\n    return 0;\n}\n```\n\n### How it works\n\n1. **Find the rightmost \u201c10\u201d pattern**  \n   We scan the bits of `N` for the first `0` that has a `1` somewhere to its left.  \n   Let that `0` be at position `pos0` and the `1` be at `pos1`.\n\n2. **Flip the two bits** (`0 \u2192 1` at `pos0`, `1 \u2192 0` at `pos1`).  \n   This creates a number smaller than `N` but still with the same bit\u2011count.\n\n3. **Re\u2011arrange the lower bits** (right of `pos0`) to be as large as possible  \n   while keeping the same number of set bits.  \n   All remaining `1`\u2011bits are moved to the far right, producing the *largest*\n   number smaller than the original with the specified pop\u2011count.\n\nIf no \u201c10\u201d pattern exists (the number is of the form `000\u20260111\u20261`),\nthe function returns `-1`, indicating that no smaller number with the same\npop\u2011count exists (for example, for `N = 1`, `N = 2`, etc.).  \nYou can adjust this sentinel value as needed.", "Sure! Below is a complete implementation of the `closest_num` function.  \nThe goal is very simple: **return the largest integer that is strictly smaller than the given value `N`**.  \nSince we\u2019re dealing with `long` integers, the smallest possible value is `LLONG_MIN`, so we have to guard against underflow.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Return the largest long that is < N.\n// If N is already the minimum long, we cannot find a smaller value.\n// In that case, we simply return N (the caller can decide what to do).\nlong closest_num(long N) {\n    if (N == LLONG_MIN) {\n        // No smaller value exists; you could also throw or handle it differently.\n        return N;\n    }\n    return N - 1;\n}\n```\n\n### How it works\n\n1. **Underflow guard**  \n   If `N` is `LLONG_MIN` the subtraction `N - 1` would overflow and wrap\u2011around.  \n   We check this edge case and simply return `N` (or you could throw an exception if that suits your error\u2011handling policy).\n\n2. **Result**  \n   For any other value of `N`, `N - 1` is guaranteed to be the largest integer strictly less than `N`.\n\n### Example usage\n\n```cpp\nint main() {\n    cout << closest_num(10) << endl;     // outputs 9\n    cout << closest_num(LLONG_MIN) << endl;  // outputs LLONG_MIN (underflow protected)\n}\n```\n\nFeel free to adapt the error handling to fit the rest of your application!"]}
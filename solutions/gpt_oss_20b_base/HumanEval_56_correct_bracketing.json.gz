{"completions": ["Here\u2019s a succinct implementation that follows exactly the specification:\n\n```cpp\n#include <string>\n\nbool correct_bracketing(const std::string& brackets) {\n    int depth = 0;                 // How many unmatched '<' we have seen\n    for (char c : brackets) {\n        if (c == '<') {\n            ++depth;               // A new opening bracket\n        } else if (c == '>') {\n            --depth;               // Try to close one\n            if (depth < 0)         // No matching '<'\n                return false;\n        } else {\n            // Invalid character \u2013 according to the spec we ignore it,\n            // but we could also return false if only '<' and '>' are allowed.\n        }\n    }\n    return depth == 0;             // All openings must have been closed\n}\n```\n\n### How it works\n1. **Maintain a counter (`depth`)** that represents the number of unmatched opening brackets (`<`) seen so far.\n2. **Increment** `depth` for each `'<'`.\n3. **Decrement** `depth` for each `'>'`.  \n   - If `depth` becomes negative, it means we encountered a closing bracket before any matching opening one \u2192 **return `false`** immediately.\n4. After processing the whole string, **return `true` only if `depth` is zero** (every opening has been matched).\n\nThis runs in \\(O(n)\\) time, uses \\(O(1)\\) extra space, and matches the examples in the prompt.", "```cpp\n#include <string>\n#include <stack>\n\n/// @brief Checks whether each '<' has a matching '>' and vice\u2011versa.\n/// @param brackets A string containing only the characters '<' and '>'.\n/// @return true if the string is a correct bracket sequence,\n///         false otherwise.\n/// @note The algorithm runs in O(n) time and O(n) auxiliary space.\nbool correct_bracketing(const std::string& brackets) {\n    std::stack<char> st;          // holds the opening brackets seen so far\n\n    for (char c : brackets) {\n        if (c == '<') {\n            st.push(c);          // opening bracket \u2013 push it on the stack\n        } else if (c == '>') {\n            // closing bracket \u2013 stack must contain a matching '<'\n            if (st.empty() || st.top() != '<')\n                return false;    // too many closing brackets or mismatch\n            st.pop();\n        } else {\n            // extra safety: ignore characters other than '<' and '>'\n            // (or optionally return false)\n        }\n    }\n\n    // After processing all characters the stack must be empty\n    return st.empty();\n}\n```\n\n**How it works**\n\n* We use a stack to track unmatched opening brackets (`'<'`).\n* When an opening bracket is encountered, it\u2019s pushed onto the stack.\n* When a closing bracket (`'>'`) is seen, the top of the stack must be a matching opening bracket.  \n  If the stack is empty or the top is not `'<'`, the string is not properly bracketed \u2192 `false`.\n* After scanning the whole string, the stack must be empty (all openings matched).  \n  If it\u2019s not empty, there are unmatched openings \u2192 `false`.\n\n**Examples**\n\n```cpp\ncorrect_bracketing(\"<\");         // false\ncorrect_bracketing(\"<>\");        // true\ncorrect_bracketing(\"<<><>>\");    // true\ncorrect_bracketing(\"><<>\");      // false\n```\n\nThis implementation satisfies the specification and runs in linear time.", "Here is a straightforward implementation of `correct_bracketing` that uses a counter (or a stack) to keep track of unmatched \u201c\\<\u201d characters. Each \u201c\\<\u201d increments the counter, each \u201c\\>\u201d decrements it. If the counter ever becomes negative, we have a closing bracket without a matching opening bracket, so the string is incorrect. At the end the counter must be zero for all pairs to be matched.\n\n```cpp\n#include <string>\n\nbool correct_bracketing(const std::string& brackets) {\n    int open = 0;                // number of unmatched '<'\n    for (char ch : brackets) {\n        if (ch == '<') {\n            ++open;\n        } else if (ch == '>') {\n            if (open == 0) {     // no matching '<'\n                return false;\n            }\n            --open;\n        } else {\n            // For safety: if other characters appear, ignore or treat as error\n            // Here we just ignore them.\n        }\n    }\n    // All opening brackets must have been closed\n    return open == 0;\n}\n```\n\n**Explanation**\n\n* `open` counts how many `<` have not yet been matched.\n* When encountering a `<`, the count increases.\n* When encountering a `>`, we must have a previous `<` available. If `open` is zero, the string is invalid.\n* Decrease the count for each matched `>`.\n* After scanning the whole string, `open` must be zero; otherwise there are unmatched `<` left.\n\n**Test cases**\n\n```cpp\n#include <cassert>\n\nint main() {\n    assert(!correct_bracketing(\"<\"));          // false\n    assert(correct_bracketing(\"<>\"));           // true\n    assert(correct_bracketing(\"<<><>>\"));      // true\n    assert(!correct_bracketing(\"><<>\"));        // false\n    assert(correct_bracketing(\"\"));             // true (empty string)\n    return 0;\n}\n```\n\nThis implementation runs in O(n) time and O(1) extra space."]}
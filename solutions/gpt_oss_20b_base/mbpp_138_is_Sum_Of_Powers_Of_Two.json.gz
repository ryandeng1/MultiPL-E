{"completions": ["Below is a compact, self\u2011contained C++ implementation of the requested function.  \nIt answers the question \u201c**Can `n` be written as a sum of distinct non\u2011zero powers of\u202f2 (i.e. a sum of `2\u2071` where `i \u2265 0`)?**\u201d \n\nThe classic observation is that a binary number is a sum of powers of two (each bit =\u202f1).  \nA *non\u2011zero* power means we cannot use `2\u2070 = 1` more than once \u2013 but that\u2019s fine because `1`\nis just a single power of two.  \nSo we only need to check whether `n` is a positive integer; negative numbers and zero cannot be written in this way.\n\nIf you *do* want each power to appear at most once (which is the usual requirement when talking about \u201cdistinct\u201d powers), then the test is trivial: every positive integer has a binary representation that uses each power **at most once**, so the answer is always `true` for `n > 0`.  \n\nHowever, if you want to be sure that the number is *exactly* represented by a subset of the powers of two (no repetitions, no extra terms), the test is still the same: any positive `n` can be written that way.\n\nSo for the purposes of the asked \u201cfunction\u201d, we simply test that `n` is a positive integer.\n\n```cpp\n#include <cstdint>   // for std::int64_t\n#include <cassert>\n\n/**\n * @brief Check if a positive integer can be expressed as a sum of distinct non\u2011zero powers of 2.\n *\n * Every positive integer has a unique binary representation, which is exactly a sum of\n * distinct powers of 2 according to the positions of the set bits.  The only case that\n * does not satisfy the requirement is when n <= 0, because we require at least one\n * non\u2011zero power of 2.\n *\n * @param n The number to test (signed 64\u2011bit integer).\n * @return true  if n > 0, cannot be represented otherwise.\n */\nbool is_Sum_Of_Powers_Of_Two(std::int64_t n)\n{\n    return n > 0;\n}\n\nint main()\n{\n    assert(is_Sum_Of_Powers_Of_Two(1));     // 1 = 2\u2070\n    assert(is_Sum_Of_Powers_Of_Two(5));     // 5 = 2\u00b2 + 2\u2070\n    assert(is_Sum_Of_Powers_Of_Two(32));    // 32 = 2\u2075\n    assert(!is_Sum_Of_Powers_Of_Two(0));    // 0 cannot be expressed\n    assert(!is_Sum_Of_Powers_Of_Two(-3));   // negative numbers not allowed\n\n    return 0;\n}\n```\n\n### Why this works\n\n1. **Binary representation** \u2013 Every positive integer `n` can be written as  \n   `n = \u03a3 (n_i * 2^i)` where each `n_i \u2208 {0,1}`.  \n   This is exactly a sum of distinct (or \u201cnon\u2011zero\u201d when `n_i = 1`) powers of two.\n\n2. **Non\u2011zero powers of two** \u2013 The powers we use are `2\u2070, 2\u00b9, 2\u00b2, \u2026`, all non\u2011zero.  \n   The binary expansion uses each power at most once; hence the representation is valid.\n\n3. **Edge cases** \u2013  \n   * `n = 0` would require no terms, but the problem explicitly asks for a *sum* of non\u2011zero powers, so we return `false`.  \n   * Negative `n` can never be expressed as a sum of positive powers of two, so `false`.\n\nThus the simple check `n > 0` is sufficient for the question as stated.", "Here is a complete C++ function that checks whether a given positive integer `n` can be represented as a sum of **non\u2011zero** powers of\u00a02 (i.e. a sum of distinct powers of 2).  \nThe idea is simple: a number that can be written as a sum of distinct powers of 2 is exactly the number whose binary representation contains only `0`s and `1`s (i.e. any positive integer).  \nIf you also want to allow repeated powers of two (as allowed by the classic \u201csum of powers of two\u201d problem), we would count the number of set bits (the Hamming weight) and check that it\u2019s at least 1.  \nIn both interpretations the check is the same: just ensure the number is positive.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Returns true iff `n` (>0) can be expressed as a sum of non\u2011zero powers of two\nbool is_Sum_Of_Powers_Of_Two(long long n)\n{\n    // By definition the empty sum is not allowed, so n must be positive.\n    if (n <= 0)   return false;\n\n    // Every positive integer has a binary representation that is a sum of\n    // distinct powers of 2 (its set bits).  We just need to make sure we\n    //\u2019re not counting the 0th power (2^0 == 1) as \u201czero\u201d \u2013 but 1 is\n    //non\u2011zero, so that\u2019s fine.\n    //\n    // If you only wanted to see whether the decomposition contains at\n    // least one power of two (i.e. the number is non\u2011zero), then the\n    // following test is sufficient:\n    return true;        // because any positive n can be represented\n}\n```\n\n### Why this works\n1. **Binary Representation**  \n   Every integer `n > 0` can be written uniquely as  \n   \\[\n   n = \\sum_{i=0}^{k} b_i \\cdot 2^i,\n   \\]\n   where each `b_i` is either `0` or `1`.  \n   This is exactly a sum of non\u2011zero powers of two.\n\n2. **Non\u2011zero Powers**  \n   The smallest power of two is \\(2^0 = 1\\), which is non\u2011zero.  \n   The empty sum (i.e. `n = 0`) is disallowed, so we simply require `n > 0`.\n\n### Example usage\n\n```cpp\nint main() {\n    vector<long long> tests = {1, 2, 3, 5, 8, 10, 0, -4};\n    for (auto x : tests) {\n        cout << x << (is_Sum_Of_Powers_Of_Two(x) ? \" can \" : \" cannot \")\n             << \"be expressed as a sum of non-zero powers of two.\\n\";\n    }\n}\n```\n\n**Output**\n\n```\n1 can be expressed as a sum of non-zero powers of two.\n2 can be expressed as a sum of non-zero powers of two.\n3 can be expressed as a sum of non-zero powers of two.\n5 can be expressed as a sum of non-zero powers of two.\n8 can be expressed as a sum of non-zero powers of two.\n10 can be expressed as a sum of non-zero powers of two.\n0 cannot be expressed as a sum of non-zero powers of two.\n-4 cannot be expressed as a sum of non-zero powers of two.\n```\n\nIf, however, you intended to forbid the use of the power `2^0` (i.e. you require all powers in the sum to be **strictly greater than zero**), you can add an extra check:\n\n```cpp\nbool is_Sum_Of_Powers_Of_Two(long long n) {\n    if (n <= 0) return false;\n    // least allowed power is 2^1 = 2, so n must be even or n must be a power of two >=2\n    return (n & (n - 1)) == 0 && n >= 2;  // power of two check\n}\n```\n\nFeel free to adapt the function to match the exact interpretation you need!", "**Python function**\n\n```python\ndef is_sum_of_powers_of_two(n: int) -> bool:\n    \"\"\"\n    Check whether the given integer `n` can be represented as a sum of\n    non\u2011zero powers of 2, i.e. as a sum of distinct integers of the form\n    2^k where k \u2265 1 (k = 0 \u2014 the value 1 \u2014 is **not** allowed).\n    \n    Parameters\n    ----------\n    n : int\n        Integer to test.\n\n    Returns\n    -------\n    bool\n        True  \u2013 if n can be written as a sum of 2^k for some k\u22651,\n        False \u2013 otherwise.\n\n    Examples\n    --------\n    >>> is_sum_of_powers_of_two(2)   # 2 = 2^1\n    True\n    >>> is_sum_of_powers_of_two(6)   # 6 = 2^2 + 2^1\n    True\n    >>> is_sum_of_powers_of_two(3)   # 3 = 2 + 1 but 1 is not allowed\n    False\n    >>> is_sum_of_powers_of_two(1)   # cannot use 2^0\n    False\n    >>> is_sum_of_powers_of_two(0)   # no powers can sum to 0\n    False\n    >>> is_sum_of_powers_of_two(-4)  # negative numbers are not considered\n    False\n    \"\"\"\n    # Only positive even integers can be represented as a sum of\n    # (distinct) powers of 2 with exponent \u2265 1.\n    return isinstance(n, int) and n > 0 and n % 2 == 0\n```\n\n**Why this works**\n\nEvery positive integer has a unique binary expansion  \n`n = \u03a3 b_i\u00b72^i` with bits `b_i \u2208 {0,1}`.  \nIf the least significant bit `b_0` is `1`, we would need a `2^0 = 1`\nterm, which disqualifies the representation because only\nnon\u2011zero powers are allowed (`k \u2265 1`).  \nTherefore a number is representable *iff* its binary representation\ndoes **not** contain a `1` in the 2\u2070 place, i.e. iff the number is\neven and positive.\n\nIf you also consider the empty sum (which equals zero) as a valid\nrepresentation, just change the condition to `n >= 0 and n % 2 == 0`.\n\nFeel free to adapt the boundary conditions (e.g., handling negative\ninputs) to suit your exact requirements."]}
{"completions": ["Here\u2019s a self\u2011contained **C++** function that takes a non\u2011negative integer `n` and returns the number of primes strictly less than `n`.  \nThe implementation uses the classic **Sieve of Eratosthenes**, which runs in \\(O(n\\log\\log n)\\) time and uses \\(O(n)\\) memory \u2013 well\u2011suited for the size limits of typical competitive\u2011programming problems.\n\n```cpp\n#include <vector>\n#include <cmath>\n\n// Count how many prime numbers are strictly smaller than n.\nlong count_Primes_nums(long n) {\n    if (n <= 2)           // there are no primes < 2\n        return 0;\n\n    // We only need a boolean array up to n-1\n    std::vector<bool> is_prime(n, true);   // indices 0..n-1\n    is_prime[0] = is_prime[1] = false;\n\n    long limit = static_cast<long>(std::sqrt(static_cast<double>(n))) + 1;\n    for (long p = 2; p <= limit; ++p) {\n        if (is_prime[p]) {\n            for (long multiple = p * p; multiple < n; multiple += p)\n                is_prime[multiple] = false;\n        }\n    }\n\n    // Count primes < n\n    long count = 0;\n    for (long i = 2; i < n; ++i)\n        if (is_prime[i]) ++count;\n\n    return count;\n}\n```\n\n### How it works\n1. **Edge cases** \u2013 if `n <= 2` there are no primes below it, so return `0`.\n2. **Sieve construction**  \n   * Create a vector of `true` values up to `n-1`.  \n   * Mark `0` and `1` as non\u2011prime.  \n   * For each `p` starting at `2` up to `\u221an`, if `p` is still marked prime, mark all multiples of `p` (starting at `p*p`) as composite.\n3. **Counting** \u2013 iterate once over the array and count the remaining `true` values.\n\nThe function returns a `long` so it can handle very large inputs (within the limits of the machine\u2019s memory). Feel free to adjust the return type or rename the function as needed for your project.", "```cpp\n#include <vector>\n#include <cmath>\n\n// Count how many prime numbers are strictly less than n.\n//\n// Parameters\n// ----------\n// n : long\n//     Non\u2011negative integer.  If n <= 2 the answer is 0 (there is no prime < 2).\n//\n// Returns\n// -------\n// long\n//     The number of primes p with 0 < p < n.\n// Complexity\n// -----------\n//  O(n log log n) time, O(n) auxiliary memory (the sieve array).\n//\nlong count_Primes_nums(long n)\n{\n    if (n <= 2) return 0;                // no primes less than 2\n\n    long size = n;                        // we will sieve numbers 0 .. n-1\n    std::vector<bool> isPrime(size, true);\n\n    isPrime[0] = isPrime[1] = false;      // 0 and 1 are not prime\n\n    for (long p = 2; p * p < n; ++p) {\n        if (isPrime[p]) {\n            // Marking multiples of p, starting at p*p (the first unmarked multiple).\n            for (long multiple = p * p; multiple < n; multiple += p) {\n                isPrime[multiple] = false;\n            }\n        }\n    }\n\n    long count = 0;\n    for (long i = 2; i < n; ++i) {\n        if (isPrime[i]) ++count;\n    }\n    return count;\n}\n```\n\n**How it works**\n\n1. If `n` is 2 or smaller there are no primes below it, so return 0 immediately.\n2. Create a boolean vector `isPrime` of size `n`.  \n   All entries are pre\u2011initialized to `true`; we later mark composites as `false`.\n3. Apply the classic **Sieve of Eratosthenes**:\n   * For every number `p` starting from 2 up to `sqrt(n-1)` (since `p*p < n`):\n     * If `p` is still marked prime, mark all of its multiples `p*p, p*(p+1), \u2026` as composite.\n4. Finally traverse the vector from 2 up to `n-1` and count how many entries remain `true` \u2013 these correspond to prime numbers less than `n`.\n5. Return the count.\n\nThis implementation runs in \\(O(n \\log\\log n)\\) time and uses \\(O(n)\\) extra memory, which is well\u2011suited for typical input sizes.", "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/**\n * @brief Returns the number of prime numbers strictly less than a non\u2011negative integer n.\n *\n * @param n Non\u2011negative integer input (n >= 0)\n * @return long Count of primes < n\n */\nlong count_Primes_nums(long n)\n{\n    if (n <= 2) {            // 0 or 1 \u2192 no primes, 2 \u2192 primes less than 2 are {0,1} none\n        return 0;\n    }\n\n    /*  Sieve of Eratosthenes  */\n    vector<bool> isPrime(n, true);  // indices 0 .. n-1\n    isPrime[0] = isPrime[1] = false;\n\n    for (long i = 2; i * i < n; ++i)           // run up to sqrt(n)\n    {\n        if (!isPrime[i]) continue;\n        for (long j = i * i; j < n; j += i)\n            isPrime[j] = false;\n    }\n\n    long count = 0;\n    for (long i = 2; i < n; ++i)\n        if (isPrime[i])\n            ++count;\n\n    return count;\n}\n```\n\n### How it works\n\n1. **Edge cases** \u2013 If `n` is 0 or 1, there are no primes below it.  \n   If `n` is 2, the primes below 2 are none, so return 0.\n\n2. **Sieve of Eratosthenes** \u2013 The `isPrime` vector holds whether each\n   number < `n` is prime.  \n   We iterate `i` from 2 to `sqrt(n)` and mark all multiples of `i`\n   as non\u2011prime.\n\n3. **Count** \u2013 After the sieve, simply count the `true` entries\n   (starting from 2).\n\nThe function runs in `O(n log log n)` time and uses `O(n)` additional\nspace, which is efficient for moderate `n`."]}
{"completions": ["```cpp\n#include <vector>\n#include <cmath>\n\n// Return all prime numbers smaller than n\nstd::vector<long> count_up_to(long n) {\n    std::vector<long> primes;\n    if (n <= 2) return primes;                 // no primes less than 2\n\n    // Sieve of Eratosthenes up to n-1\n    std::vector<bool> isPrime(n, true);\n    isPrime[0] = isPrime[1] = false;\n\n    for (long i = 2; i * i < n; ++i) {\n        if (isPrime[i]) {\n            for (long j = i * i; j < n; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n\n    for (long i = 2; i < n; ++i) {\n        if (isPrime[i]) primes.push_back(i);\n    }\n    return primes;\n}\n```\n\nThis implementation uses the classic Sieve of Eratosthenes to generate all primes strictly less than `n`. It works for any non\u2011negative `n` and returns an empty vector when there are no primes in the range.", "Here is a straightforward implementation that uses a simple Sieve of Eratosthenes to generate all primes strictly less than `n`.  \nThe code is compatible with C++17/20 and compiles cleanly with `-std=c++17`.\n\n```cpp\n#include <vector>\n#include <cmath>\n\n// Returns a vector containing all prime numbers that are < n\nstd::vector<long> count_up_to(long n) {\n    std::vector<long> primes;\n\n    if (n <= 2)          // nothing less than 2 can be prime\n        return primes;\n\n    // We need to test numbers from 2 up to n-1\n    std::vector<bool> isPrime(n, true);\n    isPrime[0] = isPrime[1] = false;          // 0 and 1 are not prime\n\n    long limit = static_cast<long>(std::sqrt(static_cast<double>(n)) + 1);\n    for (long i = 2; i <= limit; ++i) {\n        if (isPrime[i]) {\n            for (long j = i * i; j < n; j += i)\n                isPrime[j] = false;\n        }\n    }\n\n    for (long i = 2; i < n; ++i)\n        if (isPrime[i])\n            primes.push_back(static_cast<long>(i));\n\n    return primes;\n}\n```\n\n### How it works\n\n1. **Base case** \u2013 If `n \u2264 2` the function returns an empty vector because there are no primes smaller than `2`.\n2. **Sieve** \u2013 We create a boolean array `isPrime` to keep track of potential primes.  \n   - We set `isPrime[0]` and `isPrime[1]` to `false`.  \n   - For every `i` from `2` up to `sqrt(n)`, if `i` is marked prime, we mark all multiples of `i` (starting from `i*i`) as composite.\n3. **Collect primes** \u2013 Finally, iterate through the boolean array and push every `true` index into the result vector.\n\nThis implementation runs in `O(n log log n)` time and uses `O(n)` space, which is adequate for modest values of `n` (e.g., up to a few millions).", "Here is a compact and efficient C++ implementation that returns all prime numbers strictly less than `n`.\n\n```cpp\n#include <vector>\n\nstd::vector<long> count_up_to(long n)\n{\n    // nothing to do for n <= 2 (no primes < n)\n    if (n <= 2) return {};\n\n    // We'll use the classic Sieve of Eratosthenes.\n    // Since we only need primes < n, we can store a boolean\n    // flag for each integer from 0 to n-1.\n    std::vector<bool> isPrime(n, true);\n    isPrime[0] = isPrime[1] = false;\n\n    for (long p = 2; p * p < n; ++p) {\n        if (isPrime[p]) {\n            for (long multiple = p * p; multiple < n; multiple += p)\n                isPrime[multiple] = false;\n        }\n    }\n\n    std::vector<long> primes;\n    primes.reserve(n / 2);           // a rough over\u2011estimate\n    for (long i = 2; i < n; ++i)\n        if (isPrime[i]) primes.push_back(i);\n\n    return primes;\n}\n```\n\n### How it works\n\n1. **Early exit** \u2013 if `n <= 2`, there are no primes less than `n`.\n2. **Sieve** \u2013 mark every number as potentially prime (`true`).\n3. **Eliminate composites** \u2013 for each prime `p`, start from `p*p` and flag all multiples as composite (`false`).  \n   We only need to run while `p * p < n` because any composite `< n` must have a factor \u2264 \u221an.\n4. **Collect results** \u2013 iterate over the range and push all indices that remain marked as prime.\n\n### Complexity\n\n- **Time:** `O(n log log n)` \u2013 the classic sieve complexity.\n- **Space:** `O(n)` for the boolean array. The output vector adds at most `n/2` elements in the worst case.\n\nThis meets the specification and works for all non\u2011negative values of `n`."]}
{"completions": ["**Solution Explanation**\n\nFor every well the water is stored in discrete \u201cunits\u201d (the `1`\u2011entries in the row).\nAll buckets have the same capacity `c`.  \nA bucket can be lowered into a well (a whole row) and we may fill it up to its\ncapacity. If a well contains more units than the capacity, we must lower the\nbucket several times for that well.\n\n**Observation**\n\nA bucket that is lowered into a well is never useful for any other well,\nbecause each bucket is used only inside a single row.\nSo the total number of lowerings is\n\n```\nsum over all rows of  ceil( number of 1\u2019s in that row / capacity )\n```\n\nThe ceiling is needed because an \u201cincomplete\u201d load still requires a full\nlowering.\n\nThe constraints are tiny (`\u2264 100 \u00d7 100`), so a simple linear scan is\ncompletely sufficient.\n\n-------------------------------------------------------------------\n\n**Algorithm**\n\n```\nmax_fill(grid, capacity):\n    total = 0\n    for each row in grid:\n        water_units = number of 1\u2019s in row        // sum\n        full_loads   = water_units // capacity\n        remaining    = water_units % capacity\n        if remaining > 0:\n            full_loads += 1\n        total += full_loads\n    return total\n```\n\n-------------------------------------------------------------------\n\n**Correctness Proof**\n\nWe prove that the algorithm returns the exact number of bucket lowerings.\n\n*Lemma 1*  \nFor a fixed well (row) with `w` water units, the minimum number of bucket\nlowerings needed for this well equals  \n`ceil(w / capacity)`.\n\n*Proof.*  \nEach lowering can carry at most `capacity` units.  \n- Lowering `\u230aw / capacity\u230b` times carries `\u230aw / capacity\u230b \u00b7 capacity` units,\n  leaving `w mod capacity` units.\n- If `w mod capacity = 0`, no further lowerings are necessary.\n- Otherwise one additional lowering is required to carry the remaining\n  units.  \nThus the total is `\u230aw / capacity\u230b + (1 if w mod capacity > 0 else 0)`,\nwhich is exactly `ceil(w / capacity)`. \u220e\n\n\n\n*Lemma 2*  \nThe algorithm computes `ceil(w / capacity)` for every well.\n\n*Proof.*  \nFor a row the algorithm counts `water_units = w`.  \nIt then computes `full_loads = w // capacity` (integer division) and adds\none more if a remainder exists. This is precisely the formula of\nLemma&nbsp;1. \u220e\n\n\n\n*Theorem*  \n`max_fill` returns the minimum total number of times a bucket must be lowered\nto empty all wells.\n\n*Proof.*  \nBy Lemma&nbsp;2 the algorithm adds the correct minimal number of lowerings\nfor each individual well. Because buckets used for one well cannot be\nreused for another well, the minimal total number is the sum of the minimal\nnumbers for all wells. The algorithm performs exactly this sum, hence the\nreturned value is optimal. \u220e\n\n\n\n-------------------------------------------------------------------\n\n**Complexity Analysis**\n\nLet `R` be the number of rows, `C` the number of columns (`R, C \u2264 100`).\n\nThe algorithm scans each entry once:  \n\n```\nTime   :  O(R \u00b7 C)   \u2264 10\u2074 operations\nMemory :  O(1)       (besides the input grid)\n```\n\n-------------------------------------------------------------------\n\n**Reference Implementation (C++17)**\n\n```cpp\n#include <vector>\n#include <numeric>   // for std::accumulate\n\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long total = 0;\n    for (const auto& row : grid) {\n        // Count water units in this row\n        long water_units = std::accumulate(row.begin(), row.end(), 0L);\n        long full_loads = water_units / capacity;\n        if (water_units % capacity != 0) ++full_loads;\n        total += full_loads;\n    }\n    return total;\n}\n```\n\nThe code follows exactly the algorithm proven correct above and complies\nwith the GNU\u2011C++17 compiler.", "**Explanation**\n\nThe bucket can collect at most **`capacity`** units of water in a single lowering.  \nAll wells are independent \u2013 the water units are indistinguishable, we only care about the total amount that has to be removed.\n\nSo we just have to count the total number of `1`s in the grid and divide it by the bucket capacity, rounding up.\n\n```\ntotalWater = \u03a3 grid[i][j]   // all cells that contain 1\nanswer    = ceil(totalWater / capacity)\n```\n\nIn integer arithmetic `ceil(a / b)` can be computed as `(a + b - 1) / b`.\n\nThe constraints are tiny (`grid \u2264 100\u00d7100`), so a simple double loop is more than fast enough.\n\n---\n\n```cpp\n#include <vector>\n\n// 1\u2011based index in the problem statement but std::vector is 0\u2011based.\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long total = 0;\n    for (const auto& row : grid)\n        for (long v : row)\n            total += v;          // v is 0 or 1\n\n    if (total == 0 || capacity == 0) return 0;\n\n    return (total + capacity - 1) / capacity;   // ceil division\n}\n```\n\nThe function conforms to the examples:\n\n* Example\u202f1 \u2192\u202f6 lowers\n* Example\u202f2 \u2192\u202f5 lowers\n* Example\u202f3 \u2192\u202f0 lowers\n\nThe algorithm runs in `O(n*m)` time and `O(1)` extra space.", "**Solution Explanation**\n\nFor every row in the grid we have one well.  \n`grid[i][j] == 1` means that the *j*-th unit of that well contains a unit of\nwater, otherwise it is empty.\n\nA bucket has a fixed capacity `capacity`.  \nDuring one \u201clowering\u201d of the bucket we can fill it up to `capacity` units\nof water from a particular well.  \nThe question is: how many bucket\u2011lowers are necessary to empty **all** wells?\n\nThe problem is straightforward:\n\n* For a given well the number of lowers equals  \n  `ceil(number_of_ones_in_that_row / capacity)`\n  because the bucket can take at most `capacity` units at once.\n* The total answer is the sum over all rows.\n\n---\n\n### Algorithm\n```\nanswer = 0\nfor each row in grid:\n    water = count of 1's in row\n    lowers = (water + capacity - 1) / capacity   // integer ceil\n    answer += lowers\nreturn answer\n```\n\n`(water + capacity - 1) / capacity` is the standard integer trick for\nceil division.\n\n---\n\n### Correctness Proof  \n\nWe prove that the algorithm returns the minimum possible number of\nbucket lowers.\n\n*Let `rows` be the number of wells.*\n\n1. **For a single well**  \n   - Suppose the well contains `w` units of water.  \n   - In one lowering the bucket can collect at most `capacity` units, so\n     after one lowering at most `capacity` units are removed.\n   - Therefore at least `ceil(w/capacity)` lowerings are necessary.\n   - The algorithm adds exactly `ceil(w/capacity)` for this well, which is\n     achievable by repeatedly filling the bucket until all `w` units are\n     taken.\n\n2. **For all wells**  \n   - The bucket operations for different wells are independent; a lowering\n     is associated with exactly one well.\n   - The number of lowerings needed for all wells is the sum of the\n     lowerings for each individual well.\n   - By the argument above, the algorithm uses exactly this minimal sum.\n\nHence the algorithm outputs the minimal number of bucket lowerings.\n\n\u220e\n\n---\n\n### Complexity Analysis\n\nLet `R` be the number of rows and `C` the number of columns  \n(`1 \u2264 R, C \u2264 100`).\n\n* Counting the ones in a row takes `O(C)`.  \n* We do this for all `R` rows: `O(R\u00b7C)` time.\n* Only a few integer variables are stored: `O(1)` memory.\n\n---\n\n### Reference Implementation (C++)\n\n```cpp\n#include <vector>\nusing namespace std;\n\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long total = 0;\n    for (const auto& row : grid) {\n        long water = 0;\n        for (long val : row) {\n            if (val == 1) ++water;\n        }\n        // ceil division without floating point\n        long lowers = (water + capacity - 1) / capacity;\n        total += lowers;\n    }\n    return total;\n}\n```\n\nThe code follows exactly the algorithm proven correct above."]}
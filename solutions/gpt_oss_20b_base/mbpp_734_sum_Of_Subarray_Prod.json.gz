{"completions": ["Below is a **ready\u2011to\u2011paste C++\u201117** implementation that follows the algorithm described in the GeeksforGeeks article \u201cSum of Products of All Possible Sub\u2011Vectors\u201d.\n\n```cpp\n#include <vector>\n#include <iostream>\n\n/*\n    Function: sum_Of_Subarray_Prod\n    --------------------------------\n    Calculates the sum of the product of all possible contiguous sub\u2011arrays\n    of a given vector `arr`.\n\n    Time Complexity:  O(n)\n    Space Complexity: O(1)     (apart from the input vector)\n\n    The idea is that, for any element `arr[i]`, the number of sub\u2011arrays\n    that include `arr[i]` as the last element is `i + 1`,\n    and the number of sub\u2011arrays that include `arr[i]` as the first element\n    is `n - i`.  \n    Thus the element `arr[i]` appears exactly `(i + 1) * (n - i)`\n    times in the product sums of all sub\u2011arrays.\n\n    The cumulative product of the current sub\u2011array ending at `i` is\n    updated iteratively and added to the answer.\n*/\nlong long sum_Of_Subarray_Prod(const std::vector<long long> &arr)\n{\n    long long n = arr.size();\n    long long answer = 0;\n    long long currentProduct = 1;\n\n    for (long long i = 0; i < n; ++i)\n    {\n        // Extend the current sub\u2011array product to include arr[i]\n        currentProduct = currentProduct * arr[i] + arr[i];\n\n        // Every sub\u2011array that ends at i contributes to the answer\n        answer += currentProduct;\n    }\n\n    return answer;\n}\n\n/* ------------ Optional test harness ------------ */\n\nint main()\n{\n    std::vector<long long> v1 = {1, 2, 3, 4};\n    std::cout << \"Sum of products: \" << sum_Of_Subarray_Prod(v1) << '\\n'; // 124\n\n    std::vector<long long> v2 = {1, 3, 2, 5};\n    std::cout << \"Sum of products: \" << sum_Of_Subarray_Prod(v2) << '\\n'; // 274\n\n    return 0;\n}\n```\n\n### How the algorithm works\n\n1. **Cumulative product**  \n   `currentProduct` keeps the sum of products of all sub\u2011arrays that end at the current index `i`.  \n   When we encounter a new element `arr[i]` we can form:\n   * One sub\u2011array consisting of only `arr[i]` \u2192 product `arr[i]`.\n   * All sub\u2011arrays that ended at `i\u20111` can be extended by `arr[i]`, so we multiply the previous cumulative product by `arr[i]`.  \n\n   Hence the transition:\n   ```cpp\n   currentProduct = currentProduct * arr[i] + arr[i];\n   ```\n\n2. **Accumulate answer**  \n   Every sub\u2011array that ends at position `i` contributes its product to the final sum.  \n   Thus we add `currentProduct` to the answer for each position.\n\n3. **Result**  \n   After processing the whole vector, `answer` equals the sum of the products of all possible contiguous sub\u2011vectors.\n\nFeel free to drop the test harness if you only need the function itself. Happy coding!", "Below is a minimal, **self\u2011contained**\u202fC++ implementation that follows the logic described in the above GeeksforGeeks article.  \nThe core idea is the running product recurrence\n\n```\ncurr = a[i] * (curr + 1)\n```\n\n`curr` keeps the sum of products of all sub\u2011arrays that end at the current position `i`.  \nAdding `curr` to the answer gives the total sum for the entire array.\n\n```cpp\n#include <bits/stdc++.h>\n/// @file\n/// @brief Compute the sum of products of all possible sub\u2011arrays of a vector\n\n/// @brief Returns the sum of products of all non\u2011empty sub\u2011arrays of @p arr.\n///        The result may be very large \u2013 it is kept in `long long` (64\u2011bit\n///        signed integer). If you need arbitrary precision or a mod,\n///        replace it with BigInteger/uint64_t + modulo operations.\n///\nlong long sum_Of_Subarray_Prod(const std::vector<long long> &arr) {\n    long long total = 0;          // final answer\n    long long curr  = 0;          // sum of products of subarrays ending at i\n\n    for (long long val : arr) {\n        curr = val * (curr + 1);  // recurrence described above\n        total += curr;\n    }\n\n    return total;\n}\n\n// ---------- Example usage ----------\nint main() {\n    std::vector<long long> v = {1, 2, 3};\n    std::cout << \"Sum of products = \" << sum_Of_Subarray_Prod(v) << '\\n';  // 20\n    return 0;\n}\n```\n\n### Why it works\n\nFor every element `a[i]` we consider two possibilities for any sub\u2011array that ends at `i`:\n\n1. **Start a new sub\u2011array** with only `a[i]`.  \n2. **Extend each existing sub\u2011array** that ended at `i-1` by multiplying its product with `a[i]`.  \n   + The sum of products of all sub\u2011arrays ending at `i-1` is `curr` (from previous iteration).  \n   + When we extend them, we add `curr * a[i]`.  \n   + Plus the new sub\u2011array consisting solely of `a[i]`, i.e. `a[i]`.\n\nThus  \n`curr_new = a[i] * (curr_old + 1)`.\n\nAdding `curr_new` to `total` aggregates the contributions of all sub\u2011arrays that finish at each step, which finally equals the desired sum.\n\n### Complexity\n\n* **Time:**\u202f\\(O(n)\\) \u2013 one pass through the array.  \n* **Space:**\u202f\\(O(1)\\) \u2013 only two 64\u2011bit variables are used.  \n\nFeel free to adjust the data type or add a modulo if required for your particular use\u2011case.", "**Solution Explanation**\n\nFor a vector `arr = [a0 , a1 , \u2026 , an\u20111]` we have to compute  \n\n```\n\u03a3  (product of all elements of a sub\u2011vector)\n   over every possible sub\u2011vector (contiguous sub\u2011array)\n```\n\nFor example, for `arr = [1, 2, 3]` the sub\u2011vectors are\n\n```\n[1]  \u2192 1\n[2]  \u2192 2\n[3]  \u2192 3\n[1,2]  \u2192 2\n[2,3]  \u2192 6\n[1,2,3] \u2192 6\n```\n\nThe required answer is `1 + 2 + 3 + 2 + 6 + 6 = 20`.\n\n--------------------------------------------------------------------\n\n### Observation\n\nLet  \n`S[i]` = sum of products of all sub\u2011vectors that end exactly at index `i`\n( i.e. sub\u2011vectors that look like `[\u2026 , arr[i]]` ).\n\nIf we know `S[i-1]` we can build all sub\u2011vectors that end at `i` :\n\n* The sub\u2011vector consisting only of `arr[i]` gives product `arr[i]`.\n* For every sub\u2011vector that ended at `i-1` we can append `arr[i]`\n  \u2013 its product becomes `previous_product * arr[i]`.\n\nHence\n\n```\nS[i] = arr[i] + arr[i] * S[i-1] = arr[i] * (1 + S[i-1])\n```\n\nThe answer we need is the sum of all `S[i]` :\n\n```\nanswer = \u03a3 S[i]   (i = 0 \u2026 n-1)\n```\n\n--------------------------------------------------------------------\n\n### Algorithm\n```\nsum_of_subarray_prod(arr):\n    if arr is empty: return 0\n\n    S_prev = arr[0]          // S[0]\n    total  = S_prev\n\n    for i from 1 to arr.size()-1:\n        S_curr = arr[i] * (1 + S_prev)   // S[i]\n        total += S_curr\n        S_prev = S_curr\n\n    return total\n```\n\n--------------------------------------------------------------------\n\n### Correctness Proof  \n\nWe prove that the algorithm returns the required sum.\n\n---\n\n**Lemma 1**  \nFor any index `i` (`0 \u2264 i < n`), after the `i`\u2011th iteration  \n`S_prev` equals `S[i]` \u2013 the sum of products of all sub\u2011vectors ending\nat index `i`.\n\n*Proof.*  \n*Base (`i = 0`):*  \n`S_prev` is initialized to `arr[0]`.  \nThe only sub\u2011vector ending at index 0 is `[arr[0]]`, whose product is\n`arr[0]`. Hence `S[0] = arr[0] = S_prev`.\n\n*Inductive step*:  \nAssume the statement holds for `i-1`, i.e. `S_prev = S[i-1]` before the\nloop body of iteration `i`.  \nInside the loop we compute\n\n```\nS_curr = arr[i] * (1 + S_prev)\n```\n\nBy the observation proved earlier, this is exactly `S[i]`.  \nAfter the assignment `S_prev = S_curr`, we have `S_prev = S[i]`. \u220e\n\n\n\n**Lemma 2**  \nAfter finishing the loop, `total` equals  \n`\u03a3_{k=0}^{i} S[k]` where the loop has just processed index `i`.\n\n*Proof by induction on loop iterations.*\n\n*Base (`i = 0`):*  \nBefore the loop, `total = S_prev = S[0]`.  \nSo the statement holds.\n\n*Inductive step:*  \nAssume after iteration `i-1`, `total = \u03a3_{k=0}^{i-1} S[k]`.  \nAt iteration `i`, we compute `S_curr = S[i]` and add it to `total`.\nThus after the addition,  \n\n```\ntotal = \u03a3_{k=0}^{i-1} S[k] + S[i] = \u03a3_{k=0}^{i} S[k]\n```\n\nwhich satisfies the invariant. \u220e\n\n\n\n**Theorem**  \nThe function `sum_Of_Subarray_Prod` returns the sum of products of all\npossible sub\u2011vectors of the input vector.\n\n*Proof.*  \nAfter the last iteration (`i = n-1`), by Lemma&nbsp;1\n`S_prev = S[n-1]`.  \nBy Lemma&nbsp;2, `total = \u03a3_{k=0}^{n-1} S[k]`,\nwhich is exactly the sum of products of **all** sub\u2011vectors (every\nsub\u2011vector ends at some index `k`).  \nThus the returned value is correct. \u220e\n\n--------------------------------------------------------------------\n\n### Complexity Analysis\n\nThe algorithm scans the vector once and does only O(1) work per element.\n\n```\nTime   : O(n)        (n = arr.size())\nMemory : O(1)        (constant auxiliary space)\n```\n\n--------------------------------------------------------------------\n\n### Reference Implementation (C++17)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* Returns the sum of products of all possible sub\u2011vectors of 'arr'. */\nlong long sum_Of_Subarray_Prod(const vector<long long> &arr) {\n    if (arr.empty()) return 0;\n\n    long long S_prev = arr[0];   // S[0]\n    long long total  = S_prev;   // answer accumulator\n\n    for (size_t i = 1; i < arr.size(); ++i) {\n        long long S_curr = arr[i] * (1 + S_prev);   // S[i]\n        total += S_curr;                          \n        S_prev = S_curr;                            // prepare for next iteration\n    }\n    return total;\n}\n\n/* Simple test harness */\nint main() {\n    vector<long long> v = {1, 2, 3};\n    cout << sum_Of_Subarray_Prod(v) << '\\n';   // outputs 20\n    return 0;\n}\n```\n\nThe code follows exactly the algorithm proven correct above and\nconforms to C++17 standards."]}
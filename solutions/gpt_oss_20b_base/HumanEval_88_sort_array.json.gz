{"completions": ["Here is a clean implementation of the requested `sort_array` function.  \nIt does **not** mutate the input vector; instead, it creates a copy and returns it sorted according to the parity of the sum of the first and last elements.\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <numeric>   // for std::accumulate if needed\n\n/**\n * @brief Return a sorted copy of the given vector.\n *\n * The sorting order is determined by the parity of the sum of the\n * first and last elements of the original vector:\n *   * If (first + last) is odd \u2192 ascending order.\n *   * If (first + last) is even \u2192 descending order.\n *\n * @param array Input vector (by value, so a copy is already made).\n * @return std::vector<long> Sorted vector according to the rule above.\n */\nstd::vector<long> sort_array(std::vector<long> array) {\n    // Empty or single\u2011element vectors are already sorted irrespective of order.\n    if (array.size() <= 1) {\n        return array;\n    }\n\n    // Determine whether we need ascending or descending order.\n    long first = array.front();\n    long last  = array.back();\n    bool ascending = ((first + last) % 2 != 0);   // odd -> ascending\n\n    // Sort a copy of the vector accordingly.\n    if (ascending) {\n        std::sort(array.begin(), array.end());\n    } else {\n        std::sort(array.begin(), array.end(), std::greater<long>());\n    }\n\n    return array;\n}\n```\n\n### How it works\n1. **Copy**: The function receives `array` by value, giving us a safe copy.\n2. **Edge cases**: Vectors with 0 or 1 elements are returned unchanged.\n3. **Parity check**: Compute `first + last` and test its parity.\n4. **Sorting**:  \n   * If odd \u2192 `std::sort` with default `<` comparator.  \n   * If even \u2192 `std::sort` with `std::greater<long>()` comparator for descending order.\n5. **Return**: The sorted copy.\n\nYou can include this function in your program and use it exactly as shown in the examples.", "Here is a small and clean implementation of `sort_array` that follows exactly the rules you described.  \nIt works for an empty vector, for a single element and for the general case. The input vector is **not modified** \u2013 a copy is sorted and returned.\n\n```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<long> sort_array(const std::vector<long>& input) {\n    // Make a copy \u2013 we must not change the original.\n    std::vector<long> sorted = input;\n\n    // Empty or single\u2011element vector is already \"sorted\".\n    if (sorted.size() <= 1) {\n        return sorted;\n    }\n\n    // Sum the first and last elements.\n    long sum = sorted.front() + sorted.back();\n\n    if (sum % 2 == 1) {          // odd \u2013 ascending order\n        std::sort(sorted.begin(), sorted.end());\n    } else {                      // even \u2013 descending order\n        std::sort(sorted.begin(), sorted.end(), std::greater<long>());\n    }\n    return sorted;\n}\n```\n\n### How it works\n\n1. **Copy** the input vector to preserve its original state.  \n2. **Check** the size \u2013 if it has 0 or 1 element there is nothing to do.  \n3. **Compute** `sum = first + last`.  \n4. Depending on the parity of `sum`:\n   * If `sum` is odd, sort the copy in ascending order.\n   * If `sum` is even, sort the copy in descending order.\n5. **Return** the sorted copy.\n\n---\n\n### Test cases (matches your examples)\n\n```cpp\n#include <iostream>\n\n// Helper to print a vector\nvoid print_vec(const std::vector<long>& v) {\n    std::cout << \"[\";\n    for (size_t i = 0; i < v.size(); ++i) {\n        std::cout << v[i];\n        if (i + 1 != v.size()) std::cout << \", \";\n    }\n    std::cout << \"]\\n\";\n}\n\nint main() {\n    auto v1 = sort_array({});\n    auto v2 = sort_array({5});\n    auto v3 = sort_array({2,4,3,0,1,5});\n    auto v4 = sort_array({2,4,3,0,1,5,6});\n\n    print_vec(v1); // []\n    print_vec(v2); // [5]\n    print_vec(v3); // [0, 1, 2, 3, 4, 5]\n    print_vec(v4); // [6, 5, 4, 3, 2, 1, 0]\n}\n```\n\nRunning the above program produces the expected outputs for all your examples.", "Here is a completed implementation of `sort_array`.  \nIt follows the rules you described:\n\n* If the size of the vector is 0 or 1 the function simply returns a copy of the input.\n* It calculates the sum of the first and last elements.  \n  * If that sum is **odd** \u2192 the copy is sorted in ascending order.  \n  * If that sum is **even** \u2192 the copy is sorted in descending order.\n\nThe original vector is never modified.\n\n```cpp\n#include <vector>\n#include <algorithm> // for std::sort\n\n// -----------------------------------------------------------------------------\n// sort_array\n//   Given a vector of non\u2011negative integers, create and return a sorted copy\n//   of the vector:\n//       * If (first element + last element) is odd  \u2192 sort ascending\n//       * If (first element + last element) is even \u2192 sort descending\n//   The input vector is left untouched.\n//\n// -----------------------------------------------------------------------------\n// Preconditions: vector elements are non\u2011negative integers\nstd::vector<long> sort_array(const std::vector<long>& input) {\n    // Make a copy so we do not modify the original vector.\n    std::vector<long> result = input;\n\n    // If the vector has 0 or 1 element, we are already sorted.\n    if (result.size() <= 1) {\n        return result;\n    }\n\n    long first = result.front();\n    long last  = result.back();\n\n    // Sum of first and last element.\n    long sum = first + last;\n\n    if (sum % 2 == 1) {\n        // Odd sum \u2013 ascending order\n        std::sort(result.begin(), result.end());\n    } else {\n        // Even sum \u2013 descending order\n        std::sort(result.begin(), result.end(),\n                  [](long a, long b){ return a > b; });\n    }\n\n    return result;\n}\n```\n\n**Usage Example**\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> v{2, 4, 3, 0, 1, 5};\n    auto sorted = sort_array(v);\n\n    for (long x : sorted)\n        std::cout << x << ' ';\n    std::cout << '\\n';   // prints: 0 1 2 3 4 5\n}\n```\n\nThis implementation satisfies all the examples provided:\n* Empty vector \u2192 unchanged.\n* Single element vector \u2192 unchanged.\n* Even sum of ends \u2192 descending.\n* Odd sum of ends \u2192 ascending."]}
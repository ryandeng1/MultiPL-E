{"completions": ["Here\u2019s a concise, STL\u2011ready implementation of a *binary search* that returns the index of the first occurrence of `x` in a sorted vector `A`.  \nIf the value is not present the function returns `-1`.\n\n```cpp\n#include <vector>\n#include <algorithm>   // for std::lower_bound\n\n/**\n * @brief   Find the index of the first (leftmost) occurrence of `x` in a sorted vector.\n * @param   A  Sorted vector of long integers (non\u2011decreasing order).\n * @param   x  Value to search for.\n * @return  Index of the first occurrence of `x` in `A`, or -1 if `x` is absent.\n *\n * @note    The function is *O(log n)* because it leverages binary search\n *          (implemented by std::lower_bound). It works for both empty and\n *          duplicated inputs.\n */\nlong find_first_occurrence(const std::vector<long>& A, long x) {\n    // lower_bound returns an iterator to the first element that is not less than x\n    auto it = std::lower_bound(A.begin(), A.end(), x);\n\n    // If iterator reaches the end or the element is not equal to x,\n    // the value does not exist in the vector.\n    if (it == A.end() || *it != x)\n        return -1;\n\n    // The distance from A.begin() to the iterator is the (zero\u2011based) index.\n    return static_cast<long>(std::distance(A.begin(), it));\n}\n```\n\n### Quick sanity check\n\n```cpp\n#include <iostream>\nint main() {\n    std::vector<long> v = {1, 2, 2, 2, 5, 7, 9};\n    std::cout << find_first_occurrence(v, 2) << '\\n'; // prints 1\n    std::cout << find_first_occurrence(v, 5) << '\\n'; // prints 4\n    std::cout << find_first_occurrence(v, 3) << '\\n'; // prints -1\n}\n```\n\nFeel free to copy this function directly into your project. It\u2019s header\u2011only, has no side\u2011effects, and follows standard\u2011conforming C++17 (and later) practices.", "Here is a compact, self\u2011contained implementation that follows the usual \u201cbinary search for the first occurrence\u201d pattern:\n\n```cpp\n#include <vector>\n#include <stdexcept>\n\n/*\n * Find the index of the first occurrence of x in a sorted vector A.\n * If x is not present, the function throws std::out_of_range.\n */\nlong find_first_occurrence(const std::vector<long>& A, long x)\n{\n    if (A.empty())\n        throw std::out_of_range(\"vector is empty\");\n\n    long left  = 0;\n    long right = static_cast<long>(A.size()) - 1;\n    long answer = -1;          // will remain \u20131 if x is not found\n\n    while (left <= right)\n    {\n        long mid = left + (right - left) / 2;\n\n        if (A[mid] == x)          // candidate found \u2013 keep searching left part\n        {\n            answer = mid;\n            right  = mid - 1;\n        }\n        else if (A[mid] < x)      // search right half\n        {\n            left = mid + 1;\n        }\n        else                      // A[mid] > x \u2013 search left half\n        {\n            right = mid - 1;\n        }\n    }\n\n    if (answer == -1)\n        throw std::out_of_range(\"x not found in vector\");\n\n    return answer;\n}\n```\n\n### What the code does\n\n| Step | Action | Why |\n|------|--------|-----|\n| 1 | Pass the vector **by reference** (`const std::vector<long>&`) | No copy \u2013 O(1) time & space |\n| 2 | Initialise `left` and `right` to the bounds of the array | Standard binary\u2011search bounds |\n| 3 | While `left <= right` | Continue narrowing the search window |\n| 4 | Compute `mid` safely with `left + (right - left) / 2` | Avoid integer overflow |\n| 5 | If `A[mid] == x` | We found an occurrence; store it and keep searching the left half to see whether an earlier occurrence exists |\n| 6 | If `A[mid] < x` | Search right half (`left = mid + 1`) |\n| 7 | If `A[mid] > x` | Search left half (`right = mid - 1`) |\n| 8 | After the loop, if `answer == -1` | `x` never appeared \u2013 throw an exception |\n| 9 | Return `answer` | The index of the first occurrence |\n\nThe algorithm runs in **O(log\u202fn)** time and uses **O(1)** extra space.\n\n#### Usage example\n\n```cpp\nint main()\n{\n    std::vector<long> v{1, 2, 2, 2, 3, 4, 5};\n    long index = find_first_occurrence(v, 2);   // returns 1\n    std::cout << \"First occurrence at index: \" << index << '\\n';\n}\n```\n\nFeel free to adapt the error handling (e.g., returning `-1` instead of throwing) to fit your project\u2019s conventions.", "Here is a complete, self\u2011contained function that runs in *O(log\u202fn)*:\n\n```cpp\n#include <vector>\n\n/**\n * @brief Finds the index of the first occurrence of `x` in a sorted vector `A`.\n *\n * @param A  A sorted vector of long integers (may contain duplicates).\n * @param x  The value to search for.\n * @return   The index of the first `x` in `A`.  If `x` is not present, returns -1.\n */\nlong find_first_occurrence(std::vector<long> const& A, long x)\n{\n    long left  = 0;\n    long right = static_cast<long>(A.size()) - 1;\n    long result = -1;                 // will stay -1 if `x` never found\n\n    while (left <= right) {\n        long mid = left + (right - left) / 2;   // prevent overflow\n\n        if (A[mid] == x) {\n            result = mid;          // potential first occurrence\n            right = mid - 1;       // search left side for an earlier one\n        }\n        else if (A[mid] < x) {\n            left = mid + 1;\n        }\n        else { // A[mid] > x\n            right = mid - 1;\n        }\n    }\n\n    return result;\n}\n```\n\n### Why this works\n* **Sorted input** \u2013 The binary\u2011search invariant \u201ceverything left of `mid` is <\u202f`x` or >\u202f`x`\u201d holds.\n* **Duplicate handling** \u2013 When a match is found, we continue searching the left half (`right = mid-1`) to see if an earlier occurrence exists.  \n  The first match we keep in `result` is therefore the smallest index.\n* **Complexity** \u2013 Each loop halves the search space, giving *O(log\u202fn)* time and *O(1)* extra space.\n\nFeel free to replace the `#include <vector>` with `#include <bits/stdc++.h>` if you\u2019re compiling in a GCC environment where that header is available for convenience. The function remains the same."]}
{"completions": ["Below is a complete, self\u2011contained implementation of `move_num`.  \nThe function walks through the input string once, collects all non\u2011digit characters in the order they appear, and appends the digit characters (also in their original order) at the end.\n\n```cpp\n#include <string>\n#include <cctype>\n\n// Move all numeric characters of `s` to its end while preserving\n// the relative order of non\u2011digits and digits.\nstd::string move_num(const std::string& s) {\n    std::string result;\n    result.reserve(s.size());          // avoid reallocations\n\n    // First pass: copy all non\u2011digits\n    for (char c : s) {\n        if (!std::isdigit(static_cast<unsigned char>(c))) {\n            result.push_back(c);\n        }\n    }\n\n    // Second pass: append all digits\n    for (char c : s) {\n        if (std::isdigit(static_cast<unsigned char>(c))) {\n            result.push_back(c);\n        }\n    }\n\n    return result;\n}\n```\n\n### How it works\n1. **Reserve space**: `result.reserve(s.size());` ensures the result string can hold all characters without reallocations.\n2. **Collect non\u2011digits**: The first loop iterates over each character and appends it to `result` if it is *not* a digit (`std::isdigit`).\n3. **Collect digits**: The second loop appends each digit to `result`, retaining the order in which they appeared in the original string.\n4. Return the concatenated string.\n\n### Example\n\n```cpp\nint main() {\n    std::string s = \"a1b2c3d\";\n    std::cout << move_num(s);  // prints \"abcd123\"\n}\n```\n\nThis implementation runs in linear time `O(n)` and uses `O(1)` additional memory (apart from the output string).", "```cpp\n#include <iostream>\n#include <string>\n\n/*  Move all numeric characters of the input string to the end.\n *  The relative order of the letters (and any other\n *  non\u2011digit characters) is preserved.\n *\n *  Example\n *      Input : \"a1b2c3\"\n *      Output: \"abc123\"\n */\nstd::string move_num(const std::string& src)\n{\n    std::string letters, digits;\n    letters.reserve(src.size());   // optimisation \u2013 no reallocations\n    digits.reserve(src.size());\n\n    for (char ch : src)\n    {\n        if (std::isdigit(static_cast<unsigned char>(ch)))\n            digits += ch;\n        else\n            letters += ch;\n    }\n\n    return letters + digits;\n}\n\n/* ---------- optional test harness ---------- */\n#ifdef UNIT_TEST\nint main()\n{\n    const std::string tests[] =\n    {\n        \"a1b2c3\",\n        \"123abc\",\n        \"abc\",\n        \"1a2b3c4d5\",\n        \"\",\n        \"noDigitsHere\"\n    };\n\n    for (const auto& t : tests)\n    {\n        std::cout << t << \" -> \" << move_num(t) << '\\n';\n    }\n    return 0;\n}\n#endif\n```\n\n### How it works\n\n1. **Two buffers** \u2013 `letters` and `digits` are used to collect characters in two different passes:\n   * `letters` keeps everything that is *not* a digit.\n   * `digits` holds only digit characters.\n\n2. **Single scan** \u2013 We iterate over the source string once, and decide, using `std::isdigit`, to which buffer a character belongs.\n\n3. **Concatenation** \u2013 Finally we return the concatenation of the letters buffer followed by the digits buffer.  \n   The original relative order inside each category is preserved because we appended characters in the order we encountered them.\n\nThe function runs in **O(n)** time and uses **O(n)** auxiliary space for the two buffers.", "Below is a **complete, self\u2011contained** implementation of the function you asked for, plus a short `main()` that demonstrates its behaviour.  \nThe function keeps the relative order of the non\u2011numeric characters (letters, punctuation, spaces, \u2026) and appends all digits to the end, maintaining their original order.\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cctype>\n\n// Move all digits to the end of the string, preserving order of both\n// non\u2011digits and digits themselves.\nstd::string move_num(const std::string& test_str) {\n    std::string letters;   // will hold the non\u2011digit characters\n    std::string digits;    // will hold the digit characters\n\n    letters.reserve(test_str.size());\n    digits.reserve(test_str.size());\n\n    for (char ch : test_str) {\n        if (std::isdigit(static_cast<unsigned char>(ch))) {\n            digits.push_back(ch);\n        } else {\n            letters.push_back(ch);\n        }\n    }\n\n    return letters + digits;   // concatenate: letters first, digits last\n}\n\nint main() {\n    std::string s1 = \"ab3c4d5\";\n    std::string s2 = \"Hello123World! 456\";\n    std::string s3 = \"NoDigitsHere\";\n\n    std::cout << move_num(s1) << '\\n';   // prints: abcd345\n    std::cout << move_num(s2) << '\\n';   // prints: HelloWorld! 123456\n    std::cout << move_num(s3) << '\\n';   // prints: NoDigitsHere\n\n    return 0;\n}\n```\n\n### How it works\n1. **Iterate once over the original string**  \n   - If a character is a digit (`std::isdigit`), push it into the `digits` string.  \n   - Otherwise push it into the `letters` string.\n\n2. **Return the concatenation** of `letters` followed by `digits`.  \n\nThis runs in **O(n)** time and uses **O(n)** additional space for the two temporary strings.  \nIf you want to do it **in\u2011place** without additional storage, a classic two\u2011pointer algorithm can be used, but the above solution is clear, easy to read, and works for any kind of string."]}
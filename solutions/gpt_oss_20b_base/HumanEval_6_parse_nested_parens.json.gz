{"completions": ["Here is a minimal, **stand\u2011alone, testable** C++ implementation of the function described in the prompt.  \nThe code follows the requested signature, uses only the C++ standard library, and is thoroughly commented so you can drop it into any project or use it as a reference.\n\n```cpp\n#include <string>\n#include <vector>\n#include <stdexcept>\n#include <sstream>\n\n// --------------------------------------------------------------------------\n// parse_nested_parens\n// --------------------------------------------------------------------------\n//   `paren_string` \u2013 a single string that may contain several space\u2011separated\n//   \u201cgroups\u201d.  Each group is a well\u2011formed parenthesis expression that\n//   may contain nested pairs e.g. \"(()())  ((()))  ()  ((())()())\".\n//\n//   The function returns a vector<long> containing, for each group,\n//   the *maximum nesting depth* of parentheses.\n//\n//   Errors:\n//     * If the input string is empty or contains only spaces \u2192 return an\n//       empty vector.\n//     * If any group is not a valid parenthesis expression (unequal\n//       numbers of '(' and ')', or a closing parenthesis before a\n//       matching opening one) \u2192 an exception of type std::invalid_argument\n//       is thrown.  This behaviour keeps the function well defined\n//       even when the caller accidentally feeds malformed input.\n//\n//   Example:\n//     parse_nested_parens(\"(()()) ((())) () ((())()())\") \u2192 {2, 3, 1, 3}\n// --------------------------------------------------------------------------\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    // Trim surrounding whitespace.  If after trimming nothing remains,\n    // return an empty vector as specified.\n    auto trim = [](std::string &s) {\n        const auto not_space = [](int ch) { return !std::isspace(ch); };\n        s.erase(s.begin(),\n                std::find_if(s.begin(), s.end(), not_space));\n        s.erase(std::find_if(s.rbegin(), s.rend(), not_space).base(),\n                s.end());\n    };\n    trim(paren_string);\n    if (paren_string.empty())\n        return {};\n\n    std::vector<long> depths;                 // result\n    std::stringstream iss(paren_string);     // split on whitespace\n\n    std::string group;\n    while (iss >> group) {                    // read each group\n        long current_depth = 0;               // nesting while scanning\n        long max_depth = 0;                   // deepest level found\n\n        for (char c : group) {\n            if (c == '(') {                   // open bracket: increase depth\n                ++current_depth;\n                if (current_depth > max_depth)\n                    max_depth = current_depth;\n            } else if (c == ')') {            // close bracket: decrease depth\n                --current_depth;\n                if (current_depth < 0)        // more ')' than '('\n                    throw std::invalid_argument(\n                        \"Unbalanced parentheses: too many closing brackets\");\n            } else {\n                // ignore any other character \u2013 the problem statement\n                // guarantees that only parentheses are present, but we\n                // keep the code robust.\n                continue;\n            }\n        }\n\n        if (current_depth != 0)              // unmatched '(' left\n            throw std::invalid_argument(\n                \"Unbalanced parentheses: unmatched opening brackets\");\n\n        depths.push_back(max_depth);\n    }\n\n    return depths;\n}\n\n/* ------------------------------------------------------------------------\n   Example usage (uncomment for a quick test):\n\nint main() {\n    std::string test = \"(()()) ((())) () ((())()())\";\n    try {\n        auto depths = parse_nested_parens(test);\n        for (size_t i = 0; i < depths.size(); ++i) {\n            std::cout << depths[i] << (i + 1 < depths.size() ? \" \" : \"\\n\");\n        }\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n}\n   ------------------------------------------------------------------------ */\n```\n\n### How it works\n1. **Trimming & split**  \n   The input string is stripped of leading/trailing whitespace.  \n   It is then tokenised by `stringstream` using the default whitespace\n   separator, so each \u201cgroup\u201d is treated independently.\n\n2. **Depth calculation**  \n   While scanning a group:\n   * `(` \u2192 increment the current depth, keep track of the maximum.\n   * `)` \u2192 decrement the current depth.  \n     A negative value indicates a closing bracket without a preceding\n     opening bracket \u2192 *unbalanced* \u2192 exception.\n\n3. **Post\u2011scan validation**  \n   After finishing a group, a non\u2011zero `current_depth` means an opening\n   bracket was never closed \u2192 *unbalanced* \u2192 exception.\n\n4. **Return**  \n   A `std::vector<long>` containing the maximum nesting depths of all groups.\n\nFeel free to replace the error handling policy with your own if the caller\nexpects a different behaviour (e.g., silently skip malformed groups).", "Here\u2019s a self\u2011contained implementation that does exactly what the docstring describes.  \nIt tokenises the input string by whitespace, then for each token iterates through the\ncharacters while keeping a *current depth* counter and records the maximum depth\nencountered.\n\n```cpp\n#include <cassert>\n#include <bits/stdc++.h>\n#include <string>\n#include <vector>\n\n/*\n * Input\n *   paren_string \u2013 a single string that contains several groups of\n *                   parentheses separated by whitespace.\n * Output\n *   vector<long> \u2013 the maximum depth of parentheses for each group.\n *\n * Example\n *   parse_nested_parens(\"(()()) ((())) () ((())()())\")\n *   -> {2, 3, 1, 3}\n */\nstd::vector<long> parse_nested_parens(const std::string& paren_string) {\n    std::vector<long> depths;\n\n    // Split the string into groups (tokens) separated by whitespace\n    std::istringstream iss(paren_string);\n    std::string group;\n    while (iss >> group) {\n        long current_depth = 0;   // depth of the current position\n        long max_depth = 0;       // maximum depth seen so far\n\n        for (char c : group) {\n            if (c == '(') {\n                ++current_depth;\n                if (current_depth > max_depth)\n                    max_depth = current_depth;\n            } else if (c == ')') {\n                // If a closing parenthesis appears before matching opening\n                // parentheses, the string is malformed.  We simply ignore\n                // it (or you could throw an exception).\n                if (current_depth > 0)\n                    --current_depth;\n            }\n            // Any other character is ignored \u2013 the specification assumes\n            // only '(' and ')' are present in each group.\n        }\n\n        depths.push_back(max_depth);\n    }\n\n    return depths;\n}\n\n/* ------------------------------------------------------------------ */\n/* ---------------------------  Unit tests  -------------------------- */\n/* ------------------------------------------------------------------ */\n\nvoid test(const std::string& input, const std::vector<long>& expected) {\n    auto result = parse_nested_parens(input);\n    assert(result == expected);\n}\n\nint main() {\n    test(\"(()()) ((())) () ((())()())\",\n         {2, 3, 1, 3});\n\n    test(\"(((())))\", {4});\n    test(\"() () ()\", {1, 1, 1});\n    test(\"((())((()))(()(())))\", {3});\n\n    // edge\u2011cases\n    test(\"\", {});                          // empty input\n    test(\"   \", {});                      // only spaces\n    test(\"() ( )\", {1, 0});               // stray space inside group\n    test(\"(())((()))\", {2});              // no spaces between groups\n    test(\"((\", {0});                      // malformed: missing closing\n    test(\"))\", {0});                      // malformed: missing opening\n\n    std::cout << \"All tests passed\\n\";\n    return 0;\n}\n```\n\n### How it works\n\n1. **Tokenisation** \u2013 `std::istringstream` splits the input on whitespace, producing\n   each group of parentheses.\n2. **Depth calculation** \u2013 For each group we walk the characters, incrementing\n   `current_depth` on `'('` and decrementing on `')'` (ignoring unbalanced\n   closings).  `max_depth` is updated whenever `current_depth` rises above it.\n3. **Result** \u2013 The vector `depths` holds the maximum depth for each group, in the\n   same order as they appear in the input string.\n\nThe included `main()` function demonstrates basic usage and runs a handful of\nassertions to verify correctness. Feel free to expand the test suite as needed!", "**Solution Explanation**\n\nThe input string contains several *groups* that are separated by spaces.  \nEach group consists only of the characters `'('` and `')'`.  \nFor every group we have to compute\n\n```\nthe highest value of the current nesting depth while scanning the group\n```\n\nand finally return a vector of these maximum depths (the order of the\ngroups is preserved).\n\nThe problem is a classic \u201cmatching parentheses\u201d problem:  \nwe walk through the string character\u2010by\u2011character and keep a counter\n`depth`.  \nWhen we see a `'('` we increase the counter; when we see a `')'` we\ndecrease it.  \nThe maximum value of `depth` that occurs during the walk is the answer\nfor that group.\n\nBecause the groups are separated by spaces we can split the input\nstring on whitespace (any amount of it) and then process every token\nindependently.\n\n### Algorithm\n```\n1. Split paren_string on white\u2011space \u2192 vector<string> groups\n2. For each group:\n      depth  = 0\n      maxDepth = 0\n      For each character c in group:\n            if c == '('   depth++ , maxDepth = max(maxDepth,depth)\n            else if c == ')'   depth--\n      Append maxDepth to result vector\n3. Return the result vector\n```\nThe input is guaranteed to contain only well\u2011formed parentheses, so the\ndepth counter will never become negative.\n\n### Correctness Proof\n\nWe prove that the algorithm returns the correct maximum nesting depth\nfor every group.\n\n**Lemma 1**  \nDuring the scan of a group, the variable `depth` always equals the\ncurrent nesting level (the number of unmatched `'('` seen so far).\n\n*Proof.*  \nInitially `depth = 0`, and before any character is processed there\nare no unmatched `'('`.  \nEach time a `'('` is read we increment `depth`; this matches the fact\nthat an unmatched `'('` has appeared, increasing the nesting level by\none.  \nEach time a `')'` is read we decrement `depth`; this matches the fact\nthat an unmatched `'('` has been closed, decreasing the nesting level\nby one.  \nThus after every character, `depth` equals the current nesting level. \u220e\n\n**Lemma 2**  \nFor a given group, `maxDepth` computed by the algorithm equals the\nmaximum nesting level that occurs in that group.\n\n*Proof.*  \nBy Lemma&nbsp;1, every time `depth` is updated it is the current nesting\nlevel. `maxDepth` is updated to be the maximum of all values seen in\n`depth`. Therefore after the scan finishes, `maxDepth` is exactly the\nmaximum nesting level encountered. \u220e\n\n**Theorem**  \nFor each group in the input, the algorithm outputs its greatest\nnesting depth, and the returned vector contains these depths in the\noriginal order.\n\n*Proof.*  \nFrom Lemma&nbsp;2 each individual group yields the correct maximum\ndepth. The outer loop processes all groups in order and appends each\nresult to the vector, preserving order. Therefore the final vector is\nexactly the desired output. \u220e\n\n### Complexity Analysis\n\nLet `n` be the total number of parentheses in the input string.\nThe split operation scans the string once, and each character is\nprocessed once during the walk.  \nHence:\n\n- **Time complexity:** `O(n)`\n- **Space complexity:** `O(n)` for storing the split groups\n  (the result vector uses `O(g)` where `g` is the number of groups,\n  which is at most `n`).\n\n### Reference Implementation (C++17)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n * Input to this function is a string represented multiple groups for\n * nested parentheses separated by spaces.\n * For each group, output the deepest level of nesting of parentheses.\n *\n * Example:\n *   parse_nested_parens(\"(()()) ((())) () ((())()())\")\n *   -> {2, 3, 1, 3}\n */\nvector<long> parse_nested_parens(string paren_string) {\n    vector<long> result;\n\n    // Split the input on whitespace (any amount).\n    stringstream ss(paren_string);\n    string group;\n    while (ss >> group) {\n        long depth = 0;\n        long maxDepth = 0;\n        for (char c : group) {\n            if (c == '(') {\n                ++depth;\n                if (depth > maxDepth) maxDepth = depth;\n            } else if (c == ')') {\n                --depth;          // given the input is valid, depth stays >= 0\n            }\n            // ignore any other characters \u2013 according to the spec there are none\n        }\n        result.push_back(maxDepth);\n    }\n\n    return result;\n}\n```\n\nThe function follows exactly the algorithm proven correct above and\nconforms to the requested signature."]}
{"completions": ["```cpp\n#include <string>\n\nstd::string solve(long N)\n{\n    if (N == 0) return \"0\";          // special case\n    std::string ans;\n    while (N > 0) {\n        ans.push_back('0' + (N & 1)); // take lowest bit\n        N >>= 1;\n    }\n    std::reverse(ans.begin(), ans.end());   // bits are reversed\n    return ans;\n}\n```\n\nThe function takes a non\u2011negative integer `N`.  \n- If `N` is `0`, it returns `\"0\"`.  \n- Otherwise it collects the bits using bitwise operations, reverses the order, and returns the resulting binary string.  \nThe algorithm runs in `O(log\u2082 N)` time and uses `O(log\u2082 N)` additional space for the string.", "**Explanation**\n\nThe task is to represent a non\u2011negative integer `N` in binary\nand return that representation as a string.\n\nThe standard way to get the binary representation is to repeatedly\nextract the least\u2011significant bit (LSB) by `N % 2` (or `N & 1`), add\nthe bit to a string, and then shift `N` right by one (`N /= 2` or\n`N >>= 1`).  \nAfter the loop the string is in reverse order, so we reverse it before\nreturning.  \nSpecial\u2011case `N == 0` because the while\u2011loop would otherwise\nreturn an empty string \u2013 the binary representation of zero is\n`\"0\"`.\n\n**C++ Code**\n\n```cpp\n#include <string>\n#include <algorithm>\n\nstd::string solve(long N) {\n    if (N == 0) return \"0\";                 // handle zero explicitly\n\n    std::string bits;\n    while (N > 0) {\n        bits.push_back((N & 1) ? '1' : '0'); // get LSB\n        N >>= 1;                            // shift right\n    }\n    std::reverse(bits.begin(), bits.end()); // reverse to correct order\n    return bits;\n}\n```\n\nThis function runs in \\(O(\\log_2 N)\\) time and uses only a small\namount of extra memory.", "**Solution Explanation**\n\nThe task is to convert a non\u2011negative integer `N` (\u00a00\u202f\u2264\u202fN\u202f\u2264\u202f10\u202f000\u00a0) into its binary representation and return it as a string.\n\nThe problem statement contains some example comments that do not match a clear\ndefinition \u2013 nevertheless the most direct interpretation that satisfies the\nname of the function (`solve`) and the given type signature is to\noutput the binary form of the input number.\n\n--------------------------------------------------------------------\n\n#### Algorithm\n```\nif N == 0          return \"0\"\nresult = empty string\nwhile N > 0\n        bit = N % 2              // least significant bit\n        prepend '0'+bit to result\n        N = N / 2\nreturn result\n```\n\nBecause we build the string from the most significant bit to the least,\nwe can simply prepend the new bit (or, in an implementation that appends\nand reverses at the end, emit bits in reverse order and reverse once).\n\n--------------------------------------------------------------------\n\n#### Correctness Proof  \n\nWe prove that the algorithm returns the binary representation of the\ninput integer `N`.\n\n*Invariant*:  \nAfter each iteration of the `while` loop,\n`result` contains the binary representation of the part of the\noriginal number `N` that has already been processed, written in\nthe correct order (most significant bit first).\n\n*Proof of invariant*:\n\n*Initialization*:  \nBefore the first iteration no bits have been processed.\n`result` is empty, which is the binary representation of `0`,\nhence the invariant holds.\n\n*Maintenance*:  \nAssume the invariant holds at the start of an iteration.\nLet `oldN` be the value of `N` at that point.\nDuring the iteration we compute `bit = oldN % 2`,\nwhich is the least significant bit of `oldN`.\nWe prepend this bit to `result`; thus `result` now represents\nthe concatenation of the previously processed bits (which is the\nbinary representation of the higher\u2011order part of `oldN`) and\nthe newly computed least significant bit \u2013 exactly the binary\nrepresentation of `oldN`.  \n`N` is updated to `oldN / 2`, i.e. the remaining higher\u2011order part,\nso the invariant holds for the next loop iteration.\n\n*Termination*:  \nThe loop stops when `N` becomes `0`. At that point the invariant\nmeans that `result` is the binary representation of the entire\noriginal integer (because all its bits have been processed).\nThe algorithm then returns `result`, which is therefore correct.\n\n--------------------------------------------------------------------\n\n#### Complexity Analysis\n\nThe loop runs once per binary digit of `N`.\nThe maximum number of digits for `N \u2264 10\u202f000` is `\u2308log\u2082(10\u202f000)\u2309 = 14`.\nThus:\n\n* **Time complexity**: `O(log N)` (at most 14 iterations).\n* **Space complexity**: `O(log N)` for the output string.\n\n--------------------------------------------------------------------\n\n#### Reference Implementation (C++17)\n\n```cpp\n#include <string>\n#include <algorithm>\n\nstd::string solve(long N) {\n    if (N == 0) return \"0\";\n\n    std::string res;\n    while (N > 0) {\n        char bit = '0' + (N & 1);   // (N % 2)\n        res.push_back(bit);          // build in reverse order\n        N >>= 1;                     // N = N / 2\n    }\n    std::reverse(res.begin(), res.end());\n    return res;\n}\n```\n\nThe implementation follows exactly the algorithm proven correct above\nand complies with the C++17 standard."]}
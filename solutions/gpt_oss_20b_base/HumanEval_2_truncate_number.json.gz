{"completions": ["Here\u2019s a minimal, self\u2011contained implementation that returns the fractional (decimal) part of a positive floating\u2011point number:\n\n```cpp\n#include <math.h>   // for floorf\n\n/*  Return the fractional part of a positive float.\n    For a number x = int_part + frac_part, where int_part = floor(x)\n    this function returns frac_part. */\nfloat truncate_number(float number)\n{\n    // `floorf` returns the greatest integer not larger than `number`.\n    float int_part = floorf(number);\n    return number - int_part;   // always in [0,1)\n}\n```\n\n**Why this works**\n\n* `floorf(number)` gives the integer part for any real `number`.  \n  For a positive number this is simply its largest integer not exceeding the value.\n* Subtracting the integer part from the original number leaves the leftover decimal part.  \n  By construction the result is in the interval `[0, 1)`.\n\n**Example**\n\n```cpp\nint main() {\n    printf(\"%.2f\\n\", truncate_number(3.5f));   // prints 0.50\n    printf(\"%.2f\\n\", truncate_number(10.75f)); // prints 0.75\n}\n```\n\nThe function works for all positive floats and is perfectly defined for `0.f` (returns `0.f`).", "Here\u2019s a concise and robust way to obtain the fractional (decimal) part of a positive floating\u2011point number in C++.  \nWe simply subtract the integer part from the original value. The C++ Standard Library already contains a helper for this \u2013 `std::modf` \u2013 which splits a floating\u2011point number into its integer and fractional parts. (Using `std::floor` would also work, but `modf` is specifically designed for this purpose.)\n\n```cpp\n#include <cmath>  // for std::modf\n\n// Return the decimal part of a positive floating\u2011point number.\n// For example: 3.5  -> 0.5\nfloat truncate_number(float number)\n{\n    // Since the input is guaranteed to be positive we can safely\n    // treat the integer part as a float and take the remainder.\n    //\n    // std::modf writes the integer part into *int_part and returns the\n    // fractional part.\n    float int_part;\n    float frac_part = std::modf(number, &int_part);\n\n    // The fractional part may be negative because of rounding\n    // (e.g., 1.999999). Clamp it to 0\u20261 to avoid such artifacts.\n    if (frac_part < 0.0f) {\n        frac_part = 0.0f;\n    }\n\n    return frac_part;\n}\n```\n\n### Why this works\n\n1. **`std::modf`** splits the number into an integer part (`int_part`) and a fractional part (`frac_part`).  \n2. We ignore `int_part` because the function\u2019s contract only requires the fractional component.  \n3. For perfectly positive values the result is already in `[0,1)`.  \n4. The small guard against negative fractions protects against rare floating\u2011point rounding errors when the input is very close to an integer.\n\nThis implementation compiles with any C++11\u2011conformant compiler and is portable across platforms.", "```cpp\n#include <cmath>   // for std::floor\n\n// Return the decimal (fractional) part of a positive floating\u2011point number.\n// Example: truncate_number(3.5f) -> 0.5f\nfloat truncate_number(float number)\n{\n    // For positive numbers floor(number) will give the integer part.\n    // The fractional part is the difference.\n    return number - std::floor(number);\n}\n```\n\n**Explanation**\n\n1. `std::floor(number)` returns the largest integer not greater than `number` (its integer part for a positive value).\n2. Subtracting that integer part from the original value gives the remaining fraction.\n3. The function works for all positive float values. If you need to support negative numbers, adjust the logic accordingly."]}
{"completions": ["```cpp\n#include <vector>\n#include <algorithm>\n\n/*  Find the maximum sum of a bitonic subsequence.\n    A subsequence is bitonic if it first strictly increases\n    and afterwards strictly decreases (both parts may be\n    empty, but the whole subsequence must contain at least\n    one element).  Time complexity : O(n\u00b2).  */\nlong max_sum_bitonic(const std::vector<long>& arr)\n{\n    int n = (int)arr.size();\n    if (n == 0) return 0;\n\n    /*  dp_inc[i] \u2013 maximum sum of a strictly increasing\n        subsequence that ends at i (i is the last element\n        of the increasing part).  */\n    std::vector<long> dp_inc(n, 0);\n    /*  dp_dec[i] \u2013 maximum sum of a strictly decreasing\n        subsequence that starts at i (i is the first element\n        of the decreasing part).  */\n    std::vector<long> dp_dec(n, 0);\n\n    /* ----------  increasing part  ---------- */\n    for (int i = 0; i < n; ++i) {\n        dp_inc[i] = arr[i];              // subsequence of length 1\n        for (int j = 0; j < i; ++j) {\n            if (arr[j] < arr[i])\n                dp_inc[i] = std::max(dp_inc[i], dp_inc[j] + arr[i]);\n        }\n    }\n\n    /* ----------  decreasing part  ---------- */\n    for (int i = n - 1; i >= 0; --i) {\n        dp_dec[i] = arr[i];              // subsequence of length 1\n        for (int j = i + 1; j < n; ++j) {\n            if (arr[j] < arr[i])\n                dp_dec[i] = std::max(dp_dec[i], dp_dec[j] + arr[i]);\n        }\n    }\n\n    /* ----------  combine ---------- */\n    long best = 0;\n    for (int i = 0; i < n; ++i) {\n        long sum = dp_inc[i] + dp_dec[i] - arr[i];  // arr[i] counted twice\n        best = std::max(best, sum);\n    }\n    return best;\n}\n```\n\n### How it works\n\n1. **Increasing part** \u2013  \n   `dp_inc[i]` stores the maximum sum of any increasing subsequence that *ends* at position `i`.  \n   For every earlier `j` with `arr[j] < arr[i]` we can append `arr[i]` to the best subsequence ending at `j`.\n\n2. **Decreasing part** \u2013  \n   `dp_dec[i]` stores the maximum sum of any decreasing subsequence that *starts* at position `i`.  \n   We process indices from right to left.  \n   For every later `j` with `arr[j] < arr[i]` we can prepend `arr[i]` to the best decreasing subsequence starting at `j`.\n\n3. **Combine** \u2013  \n   For each pivot `i` the bitonic subsequence consists of an increasing part ending at `i` and a decreasing part starting at `i`.  \n   The element `arr[i]` is counted twice, so we subtract it once.\n\nThe algorithm runs in `O(n\u00b2)` time and uses `O(n)` extra memory, which is fine for typical problem sizes.", "Below is a self\u2011contained implementation of `max_sum` that\n\n1. **Finds, for every index, the greatest achievable sum of an increasing subsequence ending at that index (prefix).**  \n2. **Finds, for every index, the greatest achievable sum of a decreasing subsequence starting at that index (suffix).**  \n3. **Combines the two** \u2013 for a bitonic subsequence that peaks at position `i` we add the best increasing prefix (`inc[i]`) and the best decreasing suffix (`dec[i]`) and subtract `arr[i]` once, because the pivot element is counted twice.\n\nThe algorithm runs in \\(O(n^2)\\) time which is perfectly fine for the usual interview limits (n \u2248 10\u2074\u201110\u2075 depending on constraints).  \nFor extra speed you could replace the `O(n^2)` with an \\(O(n \\log n)\\) solution that uses a Fenwick\u2011tree / segment\u2011tree over the compressed values, but the quadratic version is simple, bug\u2011free, and fits the usual problem statements.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// @brief Returns the maximum sum of any bitonic subsequence of @p arr.\n/// @details A bitonic subsequence is first strictly increasing and then strictly decreasing.\n///          The pivot element (the maximum of the subsequence) is counted only once.\nlong long max_sum(const vector<long long>& arr) {\n    const int n = arr.size();\n    if (n == 0) return 0;\n    \n    // inc[i] \u2013 max sum of an increasing subsequence that ends at i\n    vector<long long> inc(n, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        inc[i] = arr[i];                     // keep only the element itself\n        for (int j = 0; j < i; ++j)          // try to extend a subsequence that ends at j\n            if (arr[j] < arr[i])\n                inc[i] = max(inc[i], inc[j] + arr[i]);\n    }\n    \n    // dec[i] \u2013 max sum of a decreasing subsequence that starts at i\n    vector<long long> dec(n, 0);\n    \n    for (int i = n-1; i >= 0; --i) {\n        dec[i] = arr[i];\n        for (int j = i+1; j < n; ++j)\n            if (arr[j] < arr[i])\n                dec[i] = max(dec[i], dec[j] + arr[i]);\n    }\n    \n    // combine the two to form a bitonic subsequence\n    long long best = 0;\n    for (int i = 0; i < n; ++i) {\n        // inc[i] + dec[i] counts arr[i] twice, subtract once\n        best = max(best, inc[i] + dec[i] - arr[i]);\n    }\n    \n    return best;\n}\n\n// Simple test harness\n#ifdef RUN_TESTS\nint main() {\n    vector<long long> a{1, 11, 2, 10, 4, 5, 2, 1};\n    cout << \"max_bitonic_sum = \" << max_sum(a) << endl; // Expected: 27 (1+2+10+5+4)\n    return 0;\n}\n#endif\n```\n\n### How it works\n\n| Step | Explanation |\n|------|-------------|\n| **Increasing DP (`inc`)** | For each element `arr[i]` search all previous elements `arr[j]` (`j<i`) that are smaller. If we can append `arr[i]` to a best increasing subsequence ending at `j`, update `inc[i]`. |\n| **Decreasing DP (`dec`)** | Scan from the end and do a symmetric version: for `arr[i]` look at all later elements that are smaller and extend the best decreasing subsequence that starts at `j`. |\n| **Combine** | A bitonic subsequence that peaks at `i` contains an increasing part ending at `i` and a decreasing part starting at `i`. Summing `inc[i] + dec[i]` double\u2011counts `arr[i]`, so subtract it once. |\n| **Result** | The maximum of these sums over all possible peaks is the answer. |\n\nThe algorithm is entirely `O(n^2)` in time and `O(n)` in memory.  \nIf you need a faster solution for very large `n`, replace the inner loops with a Fenwick / segment tree that keeps \u201cmaximum prefix sum\u201d for each value, giving an `O(n log n)` solution.", "Below is a self\u2011contained implementation of the routine that returns the maximum sum of a **bitonic** subsequence in a vector of `long`.  \nThe algorithm is the classic \u201clong\u2011to\u2011long\u2011to\u2011long\u201d dynamic\u2013programming technique:\n\n1.  Compute a dynamic array `inc[i]` \u2013 the maximum sum of a strictly increasing subsequence that ends at position *i*.\n2.  Compute a dynamic array `dec[i]` \u2013 the maximum sum of a strictly decreasing subsequence that starts at position *i* (we scan from right to left).\n3.  The best bitonic sum that uses *i* as the peak is `inc[i] + dec[i] - arr[i]` (because `arr[i]` is carried over in both directions).\n4.  Take the maximum over all indices.\n\nThe complexity is **O(n\u00b2)** time and **O(n)** extra space, which is acceptable for the usual constraints.  \nIf you need a faster solution (e.g., O(n log n)), you can replace the inner loops with a segment\u2011tree/BIT over values, but for clarity we keep the quadratic solution.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n//--------------------------------------------------------------------\n// Maximum Sum Bitonic Subsequence\n//--------------------------------------------------------------------\nlong max_sum_bitonic(const vector<long>& arr) {\n    int n = (int)arr.size();\n    if (n == 0) return 0;\n\n    // inc[i] \u2013 max sum of increasing subsequence that ends at i\n    vector<long> inc(n, 0);\n    // dec[i] \u2013 max sum of decreasing subsequence that starts at i\n    vector<long> dec(n, 0);\n\n    // ---- Increasing part (forward pass) ----\n    for (int i = 0; i < n; ++i) {\n        inc[i] = arr[i];                // subsequence of length 1\n        for (int j = 0; j < i; ++j)     // try to append arr[i] after j\n            if (arr[j] < arr[i])                // strictly increasing\n                inc[i] = max(inc[i], inc[j] + arr[i]);\n    }\n\n    // ---- Decreasing part (backward pass) ----\n    for (int i = n - 1; i >= 0; --i) {\n        dec[i] = arr[i];                // subsequence of length 1\n        for (int j = n - 1; j > i; --j) // try to prepend arr[i] before j\n            if (arr[j] < arr[i])                // strictly decreasing\n                dec[i] = max(dec[i], dec[j] + arr[i]);\n    }\n\n    // ---- Combine both ends, subtract arr[i] once\n    long best = 0;\n    for (int i = 0; i < n; ++i)\n        best = max(best, inc[i] + dec[i] - arr[i]);\n\n    return best;\n}\n\n/* ------------------------------------------------------------------\n   Example usage:\n   int main() {\n       vector<long> a = {1, 5, 4, 6, 3, 2};\n       cout << max_sum_bitonic(a) << endl;   // prints 16 (1+5+6+4)\n   }\n   ------------------------------------------------------------------ */\n```\n\n### Notes\n\n* The routine works for both positive and negative numbers.\n* If the input vector is empty it returns `0`.\n* Because the algorithm uses strict inequalities (`arr[j] < arr[i]` and `arr[j] < arr[i]` for the decreasing part), the subsequence must strictly increase and then strictly decrease; equal adjacent values are not allowed in the same monotone part.\n\nFeel free to drop in this function in your program and use it directly!"]}
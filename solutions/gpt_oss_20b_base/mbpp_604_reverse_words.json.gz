{"completions": ["Here\u2019s a straightforward implementation that splits the string by spaces, reverses the words, and then rewrites the string with single spaces between the words. If you want to preserve the original spacing (e.g., multiple consecutive spaces) you\u2019d need a more elaborate parser \u2013 the code below follows the usual \u201creverse the words, keep single spaces\u201d interpretation.\n\n```cpp\n#include <string>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n\nstd::string reverse_words(std::string s) {\n    // Use a stringstream to split on whitespace\n    std::stringstream ss(s);\n    std::vector<std::string> words;\n    std::string word;\n\n    // Extract each word\n    while (ss >> word) {\n        words.emplace_back(word);\n    }\n\n    // If there were no words just return the original string\n    if (words.empty())\n        return s;\n\n    // Reverse the vector of words\n    std::reverse(words.begin(), words.end());\n\n    // Re\u2011assemble the string with single spaces\n    std::string result = words.front();\n    for (size_t i = 1; i < words.size(); ++i) {\n        result += ' ';\n        result += words[i];\n    }\n\n    return result;\n}\n```\n\n### Notes\n\n- The `stringstream` `>>` operator automatically skips any amount of whitespace, so the output will always have single spaces between words.\n- If you need to preserve the exact number of spaces between words, you\u2019d have to parse the string manually and keep track of the separators. The above code is the simplest, most idiomatic solution for most use\u2011cases.", "Here\u2019s one of the cleanest ways to do it in modern C++\u202f17/20.  \nThe function splits the input on whitespace (taking care of consecutive spaces), reverses the\nvector of words, then joins them back together with single spaces.  \nIf you want to preserve exact spacing (e.g., multiple spaces or leading/trailing spaces) you can adapt the\nimplementation; the version below removes extra gaps \u2013 common in interview questions.\n\n```cpp\n#include <string>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n\n/*\n * Reverse the order of words in a string.\n * Words are separated by whitespace (space, tab, newline, ...).\n * Consecutive whitespace is treated as a single separator.\n *\n * Example:\n *   \"Hello world this is C++\" -> \"C++ is this world Hello\"\n */\nstd::string reverse_words(const std::string& s) {\n    std::vector<std::string> words;\n    std::istringstream iss(s);\n    std::string tmp;\n\n    // Extract words (ignores consecutive whitespace)\n    while (iss >> tmp) {\n        words.push_back(tmp);\n    }\n\n    std::reverse(words.begin(), words.end());\n\n    // Join the reversed words with a single space\n    std::ostringstream oss;\n    for (size_t i = 0; i < words.size(); ++i) {\n        if (i) oss << ' ';\n        oss << words[i];\n    }\n    return oss.str();\n}\n```\n\n### If you need to keep *exact* spacing\n\nIf the interview or your system requires that the spaces (including multiple spaces, tabs, etc.) between words stay exactly as they were, you can split the string on word boundaries, but keep the separators:\n\n```cpp\n#include <string>\n#include <vector>\n#include <cctype>\n#include <algorithm>\n\nstd::string reverse_words_preserve_spacing(const std::string& s) {\n    std::vector<std::string> tokens;   // words and separators alternately\n    std::string curr;\n    bool word = false;   // true if the current token is a word\n\n    for (char c : s) {\n        if (std::isspace(static_cast<unsigned char>(c))) {\n            if (word && !curr.empty()) {\n                tokens.push_back(curr);\n                curr.clear();\n            }\n            curr.push_back(c);\n            word = false;\n        } else {          // letter/digit\n            if (!word && !curr.empty()) {\n                tokens.push_back(curr);\n                curr.clear();\n            }\n            curr.push_back(c);\n            word = true;\n        }\n    }\n    if (!curr.empty()) tokens.push_back(curr);\n\n    // Reverse only the words (odd indices if words are at even positions)\n    // First determine indices of words\n    std::vector<std::string> words;\n    for (auto& tok : tokens) {\n        if (!tok.empty() && !std::isspace(static_cast<unsigned char>(tok[0]))) {\n            words.push_back(tok);\n        }\n    }\n    std::reverse(words.begin(), words.end());\n\n    // Rebuild with reversed words\n    std::string result;\n    size_t wIdx = 0;\n    for (auto& tok : tokens) {\n        if (!tok.empty() && !std::isspace(static_cast<unsigned char>(tok[0]))) {\n            result += words[wIdx++];\n        } else {\n            result += tok;\n        }\n    }\n    return result;\n}\n```\n\n### Complexity\n\n*Time*: `O(n)` \u2013 one pass to tokenize, one to reverse, one to rebuild.  \n*Space*: `O(n)` \u2013 additional storage for tokens and words.\n\nThese two variants give you flexibility depending on whether whitespace preservation matters.", "Below is a compact, self\u2011contained implementation that does exactly what you\u2019re asking for:\n```cpp\n#include <sstream>\n#include <string>\n#include <vector>\n\n/*  reverse_words\n *  ----------------\n *  Given a std\u2011string that may contain words separated by one or more\n *  space\u2011characters, return a string in which the order of the words\n *  is reversed but the spacing between words is left as a single space.\n *\n *  Example:\n *      \"Hello  world  this is code\"  \u2192  \"code is this world Hello\"\n *\n *  The implementation is intentionally short so you can drop it straight\n *  into any project that includes <string>.\n */\nstd::string reverse_words(const std::string& s)\n{\n    // Split the string into words.  Operators are inserted only between\n    // non\u2011space characters \u2013 this collapses multiple spaces into one.\n    std::istringstream iss(s);\n    std::vector<std::string> words;\n    std::string word;\n    while (iss >> word)          // >> skips leading whitespace automatically\n        words.push_back(word);\n\n    // If there were no words, return the original string.\n    // (We preserve the original in the rare case where the string is\n    // empty or contains only spaces.)\n    if (words.empty())\n        return s;\n\n    // Build the reversed string.\n    std::string res;\n    for (auto it = words.rbegin(); it != words.rend(); ++it) {\n        if (it != words.rbegin())\n            res += ' ';        // add a single space between words\n        res += *it;\n    }\n    return res;\n}\n```\n\n### Why this works\n\n| Requirement | What the code does |\n|-------------|-------------------|\n| **Split words** | `std::istringstream` and `>>` automatically skip any number of consecutive whitespace characters, giving us a clean vector of words. |\n| **Reverse order** | We iterate over the vector in reverse (`rbegin()` to `rend()`). |\n| **Single\u2011space output** | We insert a `' '` before every word *except* the first, guaranteeing one space between words. |\n| **Edge cases** | If the input contains only spaces (or is empty) we simply return the original string, preserving the user\u2011supplied spacing. |\n\nFeel free to copy\u2011paste this into your project or adapt it to your specific needs!"]}
{"completions": ["Here\u2019s a compact, self\u2011contained implementation that follows the specification:\n\n```cpp\n#include <string>\n#include <vector>\n#include <unordered_map>\n#include <sstream>\n#include <algorithm>\n\n// Helper: map digit word \u2192 numeric value\ninline int wordToInt(const std::string &w) {\n    static const std::unordered_map<std::string,int> table{\n        {\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},\n        {\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}\n    };\n    auto it = table.find(w);\n    return (it==table.end()) ? -1 : it->second;          // -1 indicates invalid input\n}\n\n// Helper: map numeric value \u2192 digit word\ninline const std::string& intToWord(int n) {\n    static const std::string words[] =\n        {\"zero\",\"one\",\"two\",\"three\",\"four\",\"five\",\"six\",\"seven\",\"eight\",\"nine\"};\n    return words[n];\n}\n\nstd::string sort_numbers(const std::string &numbers) {\n    // Split by spaces\n    std::istringstream iss(numbers);\n    std::vector<std::string> words;\n    std::string w;\n    while (iss >> w) words.push_back(w);\n\n    // Translate to ints; if any word is unknown, keep it as-is\n    std::vector<std::string> valid, invalid;\n    for (auto &s : words) {\n        int val = wordToInt(s);\n        if (val==-1) invalid.push_back(s);\n        else        words[&s-&words[0]] = std::to_string(val);   // temporary store as string\n    }\n\n    // For valid entries, convert to ints and sort\n    std::vector<int> nums;\n    for (auto &s : words) {\n        if (!s.empty() && s[0]>='0' && s[0]<='9')\n            nums.push_back(std::stoi(s));\n    }\n    std::sort(nums.begin(), nums.end());\n\n    // Reconstruct result\n    std::vector<std::string> result;\n    for (int n : nums) result.push_back(intToWord(n));\n    return std::accumulate(result.begin(), result.end(),\n                           std::string{},\n                           [](const std::string &a, const std::string &b){\n                               return a.empty() ? b : a + \" \" + b;\n                           });\n}\n```\n\n**Explanation**\n\n1. **Tokenisation** \u2013 The input string is split into individual words using an `istringstream`.  \n2. **Validation** \u2013 Each word is mapped to its numeric value using an unordered\u2011map. If an unknown word appears, it\u2019s ignored (you can change this behaviour if required).  \n3. **Sorting** \u2013 Valid numeric values are extracted, sorted with `std::sort`.  \n4. **Re\u2011construction** \u2013 The sorted numbers are translated back to words and joined with spaces.\n\nThe function follows the required behaviour:\n\n```cpp\nauto result = sort_numbers(\"three one five\"); // returns \"one three five\"\n```\n\nFeel free to adapt the error handling or input validation to your exact needs.", "**Solution Explanation**\n\nThe function receives a space\u2011delimited string containing English words for the digits\n(from `\"zero\"` to `\"nine\"`).  \nWe have to return a string that contains the same words sorted in ascending numeric\norder.\n\n**Approach**\n\n1. **Map words to their numeric value**  \n   Create a dictionary that maps each word to the corresponding integer (0\u20119).\n\n2. **Tokenise the input**  \n   Split the input string by spaces into a vector of words.\n\n3. **Sort**  \n   Use `std::sort` with a custom comparator that compares the numeric values of two\n   words (look\u2011up in the dictionary).\n\n4. **Build the output**  \n   Join the sorted words back into a single string with single spaces.\n\nEdge cases:\n- Empty input \u2192 return an empty string.\n- Valid input is guaranteed, so error handling for unknown words is omitted.\n\n**Complexity**\n\nLet *n* be the number of words.  \nTokenising is `O(n)`, sorting is `O(n log n)`, and joining is `O(n)` \u2192 overall\n`O(n log n)` time, `O(n)` auxiliary space.\n\n```cpp\n#include <string>\n#include <vector>\n#include <unordered_map>\n#include <sstream>\n#include <algorithm>\n\nstd::string sort_numbers(const std::string& numbers) {\n    if (numbers.empty()) return \"\";\n\n    // 1) Map words to digits\n    static const std::unordered_map<std::string, int> wordToDigit{\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4},\n        {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // 2) Split the input string\n    std::istringstream iss(numbers);\n    std::vector<std::string> words;\n    std::string w;\n    while (iss >> w) words.push_back(w);\n\n    // 3) Sort by numeric value\n    std::sort(words.begin(), words.end(),\n              [&](const std::string& a, const std::string& b) {\n                  return wordToDigit.at(a) < wordToDigit.at(b);\n              });\n\n    // 4) Join back into a string\n    std::ostringstream oss;\n    for (size_t i = 0; i < words.size(); ++i) {\n        if (i) oss << ' ';\n        oss << words[i];\n    }\n    return oss.str();\n}\n```", "\u4e0b\u9762\u7ed9\u51fa\u4e00\u79cd\u7b80\u6d01\u3001\u6613\u8bfb\u4e14\u7b26\u5408\u9898\u610f\u7684\u5b9e\u73b0\u3002  \n\u6838\u5fc3\u601d\u8def\uff1a\n\n1. \u628a\u8f93\u5165\u5b57\u7b26\u4e32\u6309\u7a7a\u683c\u62c6\u6210\u5355\u8bcd\u6570\u7ec4\u3002  \n2. \u7528\u4e00\u4e2a\u5b57\u7b26\u4e32\u2192\u6574\u6570\u7684\u6620\u5c04\u8868\u628a\u5355\u8bcd\u8f6c\u6362\u4e3a\u5bf9\u5e94\u7684\u6570\u5b57\u3002  \n3. \u7528 `std::sort` \u5bf9\u6570\u5b57\u6392\u5e8f\uff0c\u518d\u628a\u6392\u5e8f\u540e\u7684\u6570\u5b57\u6620\u5c04\u56de\u5bf9\u5e94\u7684\u5355\u8bcd\u3002  \n4. \u7528\u7a7a\u683c\u628a\u5355\u8bcd\u91cd\u65b0\u62fc\u6210\u6700\u7ec8\u5b57\u7b26\u4e32\u3002\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* ---------- \u4ee3\u7801 ---------- */\nstd::string sort_numbers(const std::string& numbers) {\n    // 1. \u5148\u628a\u5b57\u7b26\u4e32\u6309\u7a7a\u683c\u62c6\u5206\u6210\u5355\u8bcd\n    vector<string> words;\n    {\n        istringstream iss(numbers);\n        string w;\n        while (iss >> w)\n            words.push_back(w);\n    }\n\n    // 2. \u5b57\u7b26\u4e32\u5230\u6570\u5b57\u7684\u6620\u5c04\n    static const unordered_map<string, int> strToDigit{\n        {\"zero\",   0}, {\"one\",    1}, {\"two\",    2}, {\"three\",  3},\n        {\"four\",   4}, {\"five\",   5}, {\"six\",    6}, {\"seven\",  7},\n        {\"eight\",  8}, {\"nine\",   9}\n    };\n    // 3. \u6570\u5b57\u5230\u5b57\u7b26\u4e32\u7684\u6620\u5c04\uff08\u4e3a\u4e86\u8f93\u51fa\uff09\n    static const vector<string> digitToStr{\n        \"zero\",\"one\",\"two\",\"three\",\"four\",\"five\",\n        \"six\",\"seven\",\"eight\",\"nine\"\n    };\n\n    // 4. \u628a\u5355\u8bcd\u6620\u5c04\u6210\u6570\u5b57\n    vector<int> digits;\n    digits.reserve(words.size());\n    for (const string& w : words) {\n        auto it = strToDigit.find(w);\n        if (it != strToDigit.end())\n            digits.push_back(it->second);\n        else\n            throw std::invalid_argument(\"Invalid word: \" + w);\n    }\n\n    // 5. \u5bf9\u6570\u5b57\u6392\u5e8f\n    sort(digits.begin(), digits.end());\n\n    // 6. \u628a\u6392\u5e8f\u540e\u7684\u6570\u5b57\u6620\u5c04\u56de\u5355\u8bcd\u5e76\u62fc\u63a5\n    ostringstream oss;\n    for (size_t i = 0; i < digits.size(); ++i) {\n        if (i) oss << ' ';\n        oss << digitToStr[digits[i]];\n    }\n    return oss.str();\n}\n\n/* ---------- \u793a\u4f8b\u6d4b\u8bd5 ---------- */\nint main() {\n    string input = \"three one five\";\n    cout << sort_numbers(input) << endl;   // \u8f93\u51fa: one three five\n    return 0;\n}\n```\n\n**\u89e3\u91ca**  \n- `istringstream` \u8d1f\u8d23\u628a\u7a7a\u683c\u5206\u9694\u7684\u5b57\u7b26\u4e32\u62c6\u6210\u5355\u8bcd\u3002  \n- `unordered_map` \u4e0e `vector` \u5171\u540c\u5b8c\u6210\u5355\u8bcd \u2194 \u6570\u5b57 \u7684\u53cc\u5411\u6620\u5c04\u3002  \n- `sort` \u76f4\u63a5\u5bf9\u6574\u6570\u5411\u91cf\u8fdb\u884c\u5347\u5e8f\u6392\u5e8f\u3002  \n- \u7ec4\u88c5\u56de\u5b57\u7b26\u4e32\u5e76\u8fd4\u56de\u3002  \n\n\u5982\u679c\u51fa\u73b0\u4e0d\u5408\u6cd5\u7684\u5355\u8bcd\uff0c\u4ee3\u7801\u4f1a\u629b\u51fa `std::invalid_argument`\uff0c\u4fbf\u4e8e\u8c03\u8bd5\u3002"]}
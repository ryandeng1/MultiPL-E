{"completions": ["Here is a straightforward implementation of `below_zero`.  \nIt walks through the vector, keeps a running total of the balance, and\nreturns `true` as soon as that balance dips below zero.  \n\n```cpp\n#include <vector>\n#include <cstdint>\n\n/*\n * Detect if the account ever goes negative.\n *\n * @param operations  Vector of signed long integers: positive for deposits,\n *                    negative for withdrawals.  The account starts at 0.\n *\n * @return            true  if the balance becomes negative at any point,\n *                    false otherwise.\n */\nbool below_zero(const std::vector<long> &operations)\n{\n    long balance = 0;                       // current account balance\n\n    for (const auto &op : operations) {     // iterate over all operations\n        balance += op;                      // apply operation\n\n        if (balance < 0)                    // negative balance \u2192 failure\n            return true;\n    }\n\n    return false;                           // never fell below zero\n}\n```\n\n**Explanation**\n\n1. We initialise `balance` to 0 because the account starts empty.\n2. For each operation in `operations` we add it to the balance\n   (positive values increase it, negative values decrease it).\n3. Immediately after the update, if `balance` is negative we return `true`.\n4. If we finish the loop without encountering a negative balance, we return `false`.\n\nThis satisfies the specification and runs in `O(n)` time with `O(1)` extra space.", "Here is a complete, minimal implementation of the `below_zero` function that does exactly what the prompt describes.  \nFeel free to copy it into your project or run it in an online compiler to test the examples.\n\n```cpp\n#include <vector>\n\n/*  Detects whether the running balance ever goes below zero.\n    operations : vector of deposit (+ve) or withdrawal (-ve) amounts.\n    The account starts with a zero balance.  The function scans the\n    vector, keeps a running sum and returns true as soon as the\n    balance drops below zero; otherwise it returns false.\n*/\nbool below_zero(const std::vector<long>& operations) {\n    long balance = 0;\n    for (long amount : operations) {\n        balance += amount;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> v1{1, 2, 3};\n    std::vector<long> v2{1, 2, -4, 5};\n\n    std::cout << std::boolalpha;\n    std::cout << \"v1 -> \" << below_zero(v1) << '\\n';   // prints: false\n    std::cout << \"v2 -> \" << below_zero(v2) << '\\n';   // prints: true\n}\n```\n\nThis program will output:\n\n```\nv1 -> false\nv2 -> true\n```\n\nThe implementation is linear in the number of operations (O(n)) and uses only a single `long` variable to track the balance.", "Here is a straightforward implementation in C++17.  \nThe function iterates through the vector, keeps a running balance and immediately returns `true` if the balance becomes negative. If the loop finishes without hitting a negative balance, the function returns `false`.\n\n```cpp\n#include <vector>\n\nbool below_zero(const std::vector<long>& operations) {\n    long balance = 0;\n    for (const long& op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;            // balance has fallen below zero\n        }\n    }\n    return false;                   // never fell below zero\n}\n```\n\n### Usage\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> ops1 = {1, 2, 3};\n    std::vector<long> ops2 = {1, 2, -4, 5};\n\n    std::cout << std::boolalpha;\n    std::cout << \"ops1: \" << below_zero(ops1) << '\\n'; // false\n    std::cout << \"ops2: \" << below_zero(ops2) << '\\n'; // true\n}\n```\n\nThe function runs in \\(O(n)\\) time and uses \\(O(1)\\) additional space."]}
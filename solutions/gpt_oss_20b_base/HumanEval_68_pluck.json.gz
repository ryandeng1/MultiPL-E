{"completions": ["Here is a minimal, self\u2011contained implementation of the `pluck` function that follows the specification:\n\n```cpp\n#include <vector>\n\n/*\n *  pluck\n *\n *  Given a vector of non\u2011negative integers, find the element that is:\n *     \u2022 the smallest *even* value,\n *     \u2022 and if there is a tie the one with the smallest index.\n *\n *  The result is returned as a vector of two elements:\n *     [smallest_even_value, index_of_that_value]\n *\n *  If there are no even values or the input vector is empty, an empty\n *  vector is returned.\n *\n *  Complexity:  O(n)    (single linear scan)\n *  Memory:     O(1)    (apart from the input vector)\n */\nstd::vector<long> pluck(const std::vector<long> &arr)\n{\n    long bestValue = -1;          // sentinel for \u201cnot found yet\u201d\n    std::size_t bestIdx  = 0;     // valid only when bestValue != -1\n\n    for (std::size_t i = 0; i < arr.size(); ++i) {\n        long v = arr[i];\n        if (v % 2 != 0)               // skip odd numbers\n            continue;\n\n        if (bestValue == -1 || v < bestValue) {\n            bestValue = v;\n            bestIdx   = i;\n        }\n        /* because we sweep from left to right we automatically\n           keep the earliest index when v == bestValue, so no\n           further check is necessary. */\n    }\n\n    if (bestValue == -1)      // no even value found\n        return {};\n\n    return {bestValue, static_cast<long>(bestIdx)};\n}\n```\n\n### How to use\n\n```cpp\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<long> v1 = {4, 2, 3};\n    auto r1 = pluck(v1);\n    // r1 == {2, 1}\n\n    std::vector<long> v2 = {5, 0, 3, 0, 4, 2};\n    auto r2 = pluck(v2);\n    // r2 == {0, 1}\n\n    std::vector<long> v3;          // empty\n    auto r3 = pluck(v3);\n    // r3 == {}\n\n    for(auto x : r1) std::cout << x << ' ';\n    std::cout << \"\\n\";\n}\n```\n\nThe function is fully compliant with the constraints (`1\u00a0\u2264\u00a0nodes.length\u00a0\u2264\u00a010000`, values are non\u2011negative) and works in linear time with minimal memory overhead.", "Here\u2019s a compact, self\u2011contained implementation that matches the specification.  \nIt scans the input once, keeping track of the smallest even value seen so far and its index.  \nIf no even value is found (or the vector is empty) an empty vector is returned.\n\n```cpp\n#include <vector>\n\nstd::vector<long> pluck(std::vector<long> arr)\n{\n    if (arr.empty()) return {};\n\n    long bestVal = std::numeric_limits<long>::max();\n    long bestIdx = -1;\n\n    for (long i = 0; i < static_cast<long>(arr.size()); ++i) {\n        long v = arr[i];\n        if (v % 2 == 0) {                // even?\n            if (v < bestVal) {           // smaller value\n                bestVal = v;\n                bestIdx = i;\n            }\n        }\n    }\n\n    if (bestIdx == -1)    // no even element\n        return {};\n\n    return {bestVal, bestIdx};\n}\n```\n\n### Quick test\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> a{4, 2, 3};\n    auto res = pluck(a);\n    if (!res.empty())\n        std::cout << res[0] << ' ' << res[1] << '\\n'; // 2 1\n}\n```\n\nThe function runs in **O(n)** time and uses **O(1)** extra space, honoring the constraints (`nodes.length \u2264 10000`).", "Here is a clean implementation of `pluck`.  \nThe algorithm simply scans the vector once:\n* keep track of the smallest even value seen so far (`minEven`) and its index (`minIdx`);\n* if a new smaller even value appears, update both;\n* if the value is equal to the current minimum, keep the earlier index (which we already did).\n\nIf no even number is found, we return an empty vector.\n\n```cpp\n#include <vector>\n#include <limits>\n\n// ------------------------------------------------------------------\n// Finds the smallest even value and returns it together with its index.\n// If no even value exists, an empty vector is returned.\n// ------------------------------------------------------------------\nstd::vector<long> pluck(std::vector<long> arr) {\n    // Use a flag to indicate that we have seen an even number.\n    bool found = false;\n    long minEven = 0;\n    std::size_t minIdx = 0;\n\n    for (std::size_t i = 0; i < arr.size(); ++i) {\n        long val = arr[i];\n        if (val % 2 == 0) {                  // even number\n            if (!found || val < minEven) {   // first even or better\n                found   = true;\n                minEven = val;\n                minIdx  = i;\n            }\n            // if val == minEven, we keep the earlier index (already stored)\n        }\n    }\n\n    if (!found) {\n        return {};               // empty vector\n    } else {\n        return {minEven, static_cast<long>(minIdx)};\n    }\n}\n```\n\n### How it works\n1. **Scan once** \u2013 O(n) time, O(1) extra space.  \n2. **Even check** \u2013 `val % 2 == 0`.  \n3. **Tie\u2011break** \u2013 because we only update on \u201cstrictly smaller\u201d, the first occurrence of the minimal value is preserved.\n\n### Test Cases\n```cpp\n#include <iostream>\n\nint main() {\n    auto v1 = pluck({4,2,3});          // {2,1}\n    auto v2 = pluck({1,2,3});          // {2,1}\n    auto v3 = pluck({});               // {}\n    auto v4 = pluck({5,0,3,0,4,2});    // {0,1}\n\n    for (auto &v : {v1, v2, v3, v4}) {\n        std::cout << '[';\n        for (size_t i = 0; i < v.size(); ++i) {\n            if (i) std::cout << ',';\n            std::cout << v[i];\n        }\n        std::cout << \"]\\n\";\n    }\n}\n```\n\nThe output matches the examples in the problem statement."]}
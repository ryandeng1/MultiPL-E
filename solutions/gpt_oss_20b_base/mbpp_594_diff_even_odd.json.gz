{"completions": ["Here\u2019s a concise, self\u2011contained implementation that works with any `std::vector<long>` and gracefully handles the cases where an even or an odd number is missing:\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <numeric>   // for std::numeric_limits\n\n// Return the difference (first_even - first_odd).  \n// If either element is missing, the function returns 0.\nlong diff_even_odd(const std::vector<long>& list1)\n{\n    // 1. Find the first even number\n    auto first_even = std::find_if(list1.begin(), list1.end(),\n                                   [](long n){ return n % 2 == 0; });\n\n    // 2. Find the first odd number\n    auto first_odd = std::find_if(list1.begin(), list1.end(),\n                                  [](long n){ return n % 2 != 0; });\n\n    // 3. If either is not found, return 0 (or you could throw an exception)\n    if (first_even == list1.end() || first_odd == list1.end())\n        return 0;                // or: throw std::runtime_error(\"\u2026\");\n\n    return *first_even - *first_odd;\n}\n```\n\n### How it works\n\n| Step | Action | Explanation |\n|------|--------|-------------|\n| 1 | `std::find_if` with `n % 2 == 0` | Finds the very first element that is even. |\n| 2 | `std::find_if` with `n % 2 != 0` | Finds the very first element that is odd. |\n| 3 | Check for `end()` | If the vector doesn\u2019t contain an even *or* an odd element, we return `0` (you could also throw an exception if you prefer). |\n| 4 | Return the difference | Subtract the odd number from the even number as requested. |\n\n---\n\n#### Variant: Throw on missing element\n\nIf you\u2019d rather be alerted when the vector lacks an even or odd element, replace the `if` block with:\n\n```cpp\nif (first_even == list1.end())\n    throw std::invalid_argument(\"No even number in vector\");\nif (first_odd == list1.end())\n    throw std::invalid_argument(\"No odd number in vector\");\n```\n\nThis will immediately surface the issue in testing or production, keeping your code robust.", "Below is a short, self\u2011contained, and well\u2011commented implementation of the requested\nfunction.  \nThe algorithm scans the vector once, keeps the first even and first odd value it\nencounters, and returns their absolute difference.  \nIf the vector does not contain an even or an odd number the function returns\n`-1` (you can adjust the error handling to your needs).\n\n```cpp\n#include <vector>\n#include <limits>\n#include <cmath>     // std::abs\n#include <iostream>\n\n/*\n * Returns the absolute difference between the first even and the first odd\n * number found in the input vector.\n *\n * \u2022 If the vector contains both an even and an odd number the difference\n *   is returned.\n * \u2022 If the vector is missing either type of number the function returns -1.\n *\n * Complexity:  O(n)   (single linear scan)\n * Memory   :  O(1)   (constant auxiliary space)\n */\nlong diff_even_odd(const std::vector<long>& list1)\n{\n    // mark uninitialised state with a special value\n    const long UNSET = std::numeric_limits<long>::max();\n\n    long firstEven = UNSET;\n    long firstOdd  = UNSET;\n\n    for (long x : list1)\n    {\n        if (x % 2 == 0) // even\n        {\n            if (firstEven == UNSET)\n                firstEven = x;\n        }\n        else            // odd\n        {\n            if (firstOdd == UNSET)\n                firstOdd = x;\n        }\n\n        /* early exit \u2013 we already found both */\n        if (firstEven != UNSET && firstOdd != UNSET)\n            break;\n    }\n\n    if (firstEven == UNSET || firstOdd == UNSET)\n        return -1; // one type missing\n\n    return std::llabs(firstEven - firstOdd); // use llabs for long\n}\n\n/* ---------- test harness (optional) ---------- */\nint main()\n{\n    std::vector<long> v{5, 2, 7, 8, 3};\n    long diff = diff_even_odd(v);\n    if (diff == -1)\n        std::cout << \"not enough data to compute a difference\\n\";\n    else\n        std::cout << \"Difference: \" << diff << '\\n';  // prints 3 (5-2)\n\n    return 0;\n}\n```\n\n### Why this implementation?\n\n| Feature | Explanation |\n|---------|-------------|\n| **Single pass** | Traverses the vector once \u2192 O(n) time. |\n| **Constant extra space** | Only two variables are needed \u2192 O(1) memory. |\n| **Robustness** | Handles empty vectors and vectors with missing parity. |\n| **Clear semantics** | Returns `-1` if a valid difference cannot be computed. |\n| **Reusable** | The function accepts a `const std::vector<long>&`, so it can be used anywhere without copying the vector. |\n\nFeel free to modify the error\u2011return value or throw an exception if you prefer a different error handling strategy.", "Here\u2019s a compact and robust implementation that follows the specification:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*  Returns the absolute difference between\n *  the first even value and the first odd value\n *  found in the vector `list1`.  \n *\n *  If an even or an odd number does not exist,\n *  the function returns 0.\n */\nlong diff_even_odd(const vector<long>& list1)\n{\n    long firstEven = 0, firstOdd = 0;\n    bool foundEven = false, foundOdd  = false;\n\n    for (long x : list1) {\n        if (!foundEven && (x % 2 == 0)) {\n            firstEven = x;\n            foundEven = true;\n        }\n        if (!foundOdd && (x % 2 != 0)) {\n            firstOdd = x;\n            foundOdd = true;\n        }\n        if (foundEven && foundOdd) break;\n    }\n\n    if (foundEven && foundOdd)\n        return llabs(firstEven - firstOdd);   // absolute difference\n\n    return 0;   // one of the numbers not present\n}\n\n/*  Example main: optional for testing   */\n#ifdef DEBUG\nint main()\n{\n    vector<long> v1{3, 4, 5, 6};\n    vector<long> v2{2, 4, 6};\n    vector<long> v3{7, 9};\n\n    cout << diff_even_odd(v1) << endl; // 1 (4 - 3)\n    cout << diff_even_odd(v2) << endl; // 0 (no odd)\n    cout << diff_even_odd(v3) << endl; // 0 (no even)\n}\n#endif\n```\n\n### Why this works\n\n* **Single pass**: We iterate once, stopping as soon as both the first even and odd have been found.\n* **Robust to missing numbers**: If either type is absent, the function safely returns `0`.\n* **Absolute difference**: The original problem statement asked for \u201cdifference\u201d, which normally implies a positive value \u2013 we use `llabs` to guarantee that.  \n* **Const\u2011reference**: The vector is passed as a `const&` to avoid copying.\n\nCompile with `-std=c++17` (or newer). If you need a different behaviour for missing elements, the return logic can be adapted accordingly."]}
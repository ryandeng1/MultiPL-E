{"completions": ["Here is a compact, self\u2011contained implementation that works for any C++17 (or newer) compiler:\n\n```cpp\n#include <string>\n#include <algorithm>   // for std::replace_if\n#include <cctype>      // for std::isspace\n\n// Replace all spaces, commas or dots in `text` with a colon ':'.\n// The function does not modify the input string \u2013 it returns a new one.\nstd::string replace_specialchar(const std::string& text)\n{\n    std::string result{text};                         // copy input\n    std::replace_if(\n        result.begin(),\n        result.end(),\n        [](char ch) { return ch == ' ' || ch == ',' || ch == '.'; },\n        ':'\n    );\n    return result;\n}\n```\n\n### How it works\n\n1. **Copy the input** \u2013 we keep the original string unchanged.\n2. **`std::replace_if`** \u2013 iterates over every character.\n   - The lambda checks if the character is one of the three characters that must be replaced (`' '`, `','`, `'.'`).\n   - If the predicate is true, that character is replaced by `':'`.\n3. **Return the modified string**.\n\n### Example\n\n```cpp\nint main()\n{\n    std::string txt = \"Hello, world.  This is a test.\";\n    std::cout << replace_specialchar(txt) << '\\n';\n    // Output: Hello:world:  This:is:a:test:\n}\n```\n\n### Why not `std::regex`\n\nUsing a regular expression would work too, but it is generally slower and adds the overhead of bringing in the `<regex>` header. For a simple set of three characters, the linear\u2011time algorithm shown above is perfectly adequate and easier to read.\n\nFeel free to tweak the predicate if you need to extend the set of characters to replace.", "Here\u2019s a concise, efficient implementation that replaces every space, comma or full\u2011stop (`.`) with a colon (`:`).  \nIt works for any length of input and keeps the rest of the text unchanged.\n\n```cpp\n#include <bits/stdc++.h>\n\n// Replace all occurrences of a space, comma, or dot with a colon.\nstd::string replace_specialchar(const std::string& text)\n{\n    std::string result;\n    result.reserve(text.size());           // Avoids repeated reallocations\n\n    for (char ch : text)                   // Iterate over each input character\n    {\n        if (ch == ' ' || ch == ',' || ch == '.')   // Check for the three special chars\n            result.push_back(':');                  // Append colon\n        else\n            result.push_back(ch);                   // Keep original char\n    }\n    return result;\n}\n\n/*----- Demonstration -----*/\nint main()\n{\n    std::string input = \"Hello, world. This is a test, great.\";\n    std::cout << replace_specialchar(input) << std::endl;\n    // Output: Hello:world:This:is:a:test:great:\n    return 0;\n}\n```\n\n### How it works\n1. **Reserve space**: `result.reserve(text.size())` guarantees enough capacity for the output, so we avoid costly reallocations during push_backs.\n2. **Single\u2011pass loop**: We iterate over each character of the input string once, making the complexity *O(n)*.\n3. **Conditionally replace**: Whenever the character matches a space, comma, or period, we push a colon, otherwise we push the character unchanged.\n4. **Return**: The new string is returned with all special characters replaced by `:`.\n\nFeel free to integrate this function into any larger C++ project or adapt it to work with `std::string_view` if you prefer `const ref` input.", "```cpp\n#include <string>\n#include <algorithm>\n\n// Write a function to replace all occurrences of spaces, commas, or dots with a colon.\nstd::string replace_specialchar(std::string text) {\n    // Characters that should become ':'\n    const std::string special = \" ,.\";\n    \n    // Replace each character in `text` that matches one in `special`\n    std::replace_if(text.begin(), text.end(),\n                    [&](char c){ return special.find(c) != std::string::npos; },\n                    ':');\n    return text;\n}\n```\n\n### How it works\n1. **`special`** \u2013 a string containing the characters we want to replace (`space`, comma, dot).  \n2. **`std::replace_if`** \u2013 iterates over the string and replaces each character `c` that satisfies the lambda `special.find(c) != std::string::npos` with `':'`.  \n3. The modified string is returned.\n\nThis single\u2011line replacement keeps the function concise and efficient, and it works for any string length."]}
{"completions": ["Sure! Here\u2019s a concise implementation of `sum_digits` that works for any non\u2011negative `long` value. It simply iterates over each digit of the number, adding it to a running total.\n\n```cpp\n// Get the sum of the digits of a non\u2011negative integer.\nlong sum_digits(long n) {\n    assert(n >= 0);          // guard against negative inputs\n    long sum = 0;\n    while (n > 0) {\n        sum += n % 10;       // add the last digit\n        n /= 10;             // remove the last digit\n    }\n    return sum;\n}\n```\n\n### How it works\n1. **Assertion** \u2013 We ensure the function is only called with a non\u2011negative number (`n >= 0`).  \n2. **Loop** \u2013 While there are remaining digits (`n > 0`), we:\n   - Take the last digit via `n % 10` and add it to `sum`.  \n   - Remove the last digit using integer division `n /= 10`.  \n3. **Return** \u2013 The accumulated `sum` of all digits is returned.\n\n### Example\n```cpp\n#include <iostream>\n\nint main() {\n    long num = 12345;\n    std::cout << \"Sum of digits of \" << num << \" is: \"\n              << sum_digits(num) << '\\n';   // outputs 15\n}\n```\n\nThis function works in constant space and linear time with respect to the number of digits in `n`.", "Here is a complete, simple implementation of `sum_digits`.  \nIt uses a straightforward loop to add each decimal digit of `n`.  \nThe function works for any non\u2011negative `long` value (including `0`).  \n\n```c\n#include <assert.h>\n#include <bits/stdc++.h>\n\n/* Return the sum of the decimal digits of a non\u2011negative integer.\n * The function is defined for all n \u2265 0 and returns 0 for n == 0.\n */\nlong sum_digits(long n)\n{\n    assert(n >= 0);          // guard against negative input\n\n    long sum = 0;\n    while (n > 0) {\n        sum += n % 10;        // add the last digit\n        n /= 10;              // remove the last digit\n    }\n    return sum;\n}\n\n/* Example usage */\nint main()\n{\n    long x = 12345;\n    std::cout << \"sum_digits(\" << x << \") = \" << sum_digits(x) << '\\n'; // 15\n    return 0;\n}\n```\n\nThis implementation runs in O(number\u202fof\u202fdigits) time and uses O(1) extra space.  \nFeel free to replace the `assert` with whatever error\u2011handling policy you prefer.", "Here is a simple, fully compliant C++ implementation that computes the sum of the decimal digits of a non\u2011negative `long` integer.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n * Function: sum_digits\n * --------------------\n *      Calculates the sum of the decimal digits of a non\u2011negative integer.\n *\n *      Parameters:\n *          n - a non\u2011negative long integer\n *\n *      Returns:\n *          The sum of the digits of n as a long integer\n *\n *      Example:\n *          n = 12345  -> 1+2+3+4+5 = 15\n */\nlong sum_digits(long n)\n{\n    // Guard against negative input (problem states non\u2011negative, but\n    // returning 0 for negative values keeps the function safe.)\n    if (n < 0) return 0;\n\n    long sum = 0;\n    while (n > 0)\n    {\n        sum += n % 10;   // add the least significant digit\n        n   /= 10;       // remove the least significant digit\n    }\n    return sum;\n}\n\n/* ---------- Optional test harness ----------\n   You can compile & run this with:\n   g++ -std=c++17 -O2 -pipe -static -s -o main main.cpp\n   ./main\n  ------------------------------------------------- */\n#ifdef UNIT_TEST\n#include <cassert>\n\nint main()\n{\n    assert(sum_digits(0) == 0);\n    assert(sum_digits(7) == 7);\n    assert(sum_digits(123) == 6);\n    assert(sum_digits(9999999999LL) == 90);\n    assert(sum_digits(1234567890LL) == 45);\n    cout << \"All tests passed.\\n\";\n    return 0;\n}\n#endif\n```\n\n### How it works\n1. **Input check** \u2013 The function immediately returns `0` if a negative number is supplied, avoiding undefined behaviour.  \n2. **Summation loop**  \n   * `n % 10` isolates the least significant decimal digit.  \n   * This digit is added to `sum`.  \n   * `n /= 10` discards the processed digit.  \n   * The loop continues until `n` becomes `0`.  \n3. **Return** \u2013 The total `sum` is returned.\n\nThe optional test harness demonstrates the function\u2019s correctness for a variety of cases. If you only need the function itself, simply remove or comment out the `#ifdef UNIT_TEST` section."]}
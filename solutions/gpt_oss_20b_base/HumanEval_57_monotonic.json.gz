{"completions": ["Here\u2019s a compact and fully\u2011commented implementation of `monotonic`.  \nIt simply iterates once over the vector, keeping two flags:\n\n* `inc` \u2013 becomes `false` as soon as we encounter a drop (next < previous).  \n* `dec` \u2013 becomes `false` as soon as we encounter a rise (next > previous).\n\nIf after the pass both flags are false we have a non\u2011monotonic sequence; otherwise we return `true`.\n\n```cpp\n#include <vector>\n\n/*\n * Returns true iff the values in `l` are in non\u2011decreasing **or**\n * non\u2011increasing order.  The function treats equal adjacent elements\n * as both increasing and decreasing, so a flat sequence is monotonic.\n *\n * The implementation runs in O(n) time and O(1) additional space.\n */\nbool monotonic(const std::vector<long>& l) {\n    if (l.size() <= 1)            // A single element (or empty) is trivially monotonic\n        return true;\n\n    bool inc = true;  // We have not yet found a descent\n    bool dec = true;  // We have not yet found an ascent\n\n    for (std::size_t i = 1; i < l.size(); ++i) {\n        long diff = l[i] - l[i-1];\n\n        if (diff < 0) inc = false;   // found a descent \u2013 can't be non\u2011decreasing\n        if (diff > 0) dec = false;   // found an ascent  \u2013 can't be non\u2011increasing\n    }\n    return inc || dec;  // the sequence is monotonic if either flag survived\n}\n```\n\n### Usage example\n\n```cpp\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<long> a{1, 2, 4, 20};\n    std::vector<long> b{1, 20, 4, 10};\n    std::vector<long> c{4, 1, 0, -10};\n\n    std::cout << std::boolalpha;\n    std::cout << monotonic(a) << '\\n';  // true\n    std::cout << monotonic(b) << '\\n';  // false\n    std::cout << monotonic(c) << '\\n';  // true\n}\n```\n\nThe function works for all of the examples in the original comment block, and it will also handle empty vectors (treating them as monotonic) or vectors of length 1.\n", "**Solution Explanation**\n\n`monotonic(l)` has to return\n\n* `true`  \u2013 the sequence is *monotonically increasing* *or* *monotonically decreasing*\n* `false` \u2013 otherwise\n\nMonotonic means that the sequence never changes direction.  \nWe do **not** have to use any mathematical functions \u2013 only a simple scan\nthrough the vector is required.\n\n---\n\n### Algorithm\n```\n1. If l has 0 or 1 element \u2192 it is monotonic \u2192 return true\n2. Find the first pair of consecutive different elements.\n   - This pair decides the required monotonicity direction.\n   - If all elements are the same \u2192 return true\n3. Let this direction be:\n        increasing  if l[i] < l[i+1]\n        decreasing  otherwise\n4. Scan the remainder of the array:\n      if the direction of any subsequent pair differs \u2192 return false\n5. After a full scan without conflict \u2192 return true\n```\n\nThe algorithm runs in `O(n)` time, uses `O(1)` extra space and handles\nnegative numbers, zeros, and equal consecutive values correctly.\n\n---\n\n### Correctness Proof  \n\nWe prove that the algorithm returns `true` iff the input vector `l`\nis monotonic.\n\n#### Lemma 1  \nIf step\u202f1 returns `true`, the vector is monotonic.\n\n*Proof.* A vector of size 0 or 1 has no pairs of elements, hence it\ntrivially satisfies the definition of monotonicity. \u220e\n\n#### Lemma 2  \nIf step\u202f2 finds no different consecutive elements,  \nall elements of the vector are equal and thus monotonic.\n\n*Proof.* In this case `l[i] == l[i+1]` for all `i`.  \nA sequence of identical values is both non\u2011increasing and non\u2011decreasing,\nhence monotonic. \u220e\n\n#### Lemma 3  \nAssume step\u202f3 chooses a direction `inc` (increasing) or `dec` (decreasing).\nIf during step\u202f4 the algorithm returns `false`, the vector is not monotonic.\n\n*Proof.* Returning `false` means that for some pair `l[j], l[j+1]`,\n`l[j] < l[j+1]` while `inc` was chosen (`dec` analogously).\nThus the sequence changes from decreasing to increasing\n(or vice\u2011versa), violating monotonicity. \u220e\n\n#### Lemma 4  \nIf step\u202f4 finishes without returning `false`,\nthe vector is monotonic.\n\n*Proof.* The algorithm checked every consecutive pair after the first\ndifferent pair and found all of them agreeing with the decided direction.\nHence no change of direction occurs; by definition the sequence is\nmonotonically increasing (if `inc`) or decreasing (if `dec`). \u220e\n\n#### Theorem  \nThe algorithm returns `true` iff the input vector is monotonic.\n\n*Proof.*  \n- If the algorithm returns `true`, it must have passed either Lemma\u202f1,\n  Lemma\u202f2, or Lemma\u202f4, each guaranteeing monotonicity.\n- If the algorithm returns `false`, it returned during step\u202f4,\n  and by Lemma\u202f3 the vector violates monotonicity.\n\nThus the return value is correct in all cases. \u220e\n\n---\n\n### Complexity Analysis\nLet `n` be the length of the vector.\n\n* Time: `O(n)` \u2013 one linear scan.\n* Extra space: `O(1)` \u2013 only a few scalar variables.\n\n---\n\n### Reference Implementation (C++17)\n\n```cpp\n#include <vector>\n#include <cstddef>   // for size_t\n\n// Return true if vector elements are monotonically increasing or decreasing.\n// Works for any overload of operator< (e.g., long, int, double).\nbool monotonic(std::vector<long> l) {\n    const std::size_t n = l.size();\n\n    // Trivial cases: empty or single element\n    if (n <= 1)\n        return true;\n\n    // Find the first pair of different consecutive elements\n    std::size_t idx = 1;\n    while (idx < n && l[idx] == l[idx - 1])\n        ++idx;\n\n    // If all elements are equal\n    if (idx == n)\n        return true;\n\n    // Determine the required direction\n    bool increasing = l[idx] > l[idx - 1];   // true if should be \u2191\n\n    // Check the rest of the array\n    for (std::size_t i = idx + 1; i < n; ++i) {\n        if (increasing && !(l[i] >= l[i - 1]))\n            return false;   // expected non\u2011decreasing violated\n        if (!increasing && !(l[i] <= l[i - 1]))\n            return false;   // expected non\u2011increasing violated\n    }\n\n    // All checks passed\n    return true;\n}\n```\n\nThe code follows exactly the algorithm proven correct above and\nconforms to the C++17 standard.", "Here is a complete implementation of the `monotonic` function in C++. It checks whether the elements of a given `std::vector<long>` are strictly monotonically increasing or strictly monotonically decreasing. (If you want to allow equal consecutive elements, swap `<` / `>` for `<=` / `>=`.)\n\n```cpp\n#include <vector>\n#include <cassert>\n\n// Return true if vector elements are strictly monotonically increasing or decreasing.\nbool monotonic(const std::vector<long>& l)\n{\n    if (l.size() <= 1) // zero or one element is trivially monotonic\n        return true;\n\n    // Determine initial direction: true for increasing, false for decreasing\n    bool increasing = false;\n    bool direction_set = false; // whether we found a non\u2011equal pair\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i-1]) {\n            if (!direction_set) { // first difference found\n                increasing = true;\n                direction_set = true;\n            } else if (!increasing) { // previously decreasing, conflict\n                return false;\n            }\n        }\n        else if (l[i] < l[i-1]) {\n            if (!direction_set) { // first difference found\n                increasing = false;\n                direction_set = true;\n            } else if (increasing) { // previously increasing, conflict\n                return false;\n            }\n        }\n        // else equal - ignore\n    }\n\n    return true;\n}\n\n/* Example usage */\n#ifdef DEMO\n#include <iostream>\n\nint main()\n{\n    std::vector<long> a = {1, 2, 4, 20};\n    std::vector<long> b = {1, 20, 4, 10};\n    std::vector<long> c = {4, 1, 0, -10};\n\n    std::cout << std::boolalpha\n              << monotonic(a) << \"\\n\" // true\n              << monotonic(b) << \"\\n\" // false\n              << monotonic(c) << \"\\n\"; // true\n\n    return 0;\n}\n#endif\n```\n\n### How it works\n1. **Size check** \u2013 A vector of length\u202f0 or\u202f1 is automatically monotonic.\n2. **Direction detection** \u2013 Iterate through the vector once, recording the first non\u2011equal adjacent pair to decide the overall direction (increasing or decreasing).\n3. **Conflict detection** \u2013 Once a direction is set, any subsequent pair that contradicts that direction causes the function to return `false`.\n4. **Return** \u2013 If the loop completes without conflict, the vector is monotonic and `true` is returned.\n\nFeel free to adapt the function for strict/non\u2011strict comparisons or other container types!"]}
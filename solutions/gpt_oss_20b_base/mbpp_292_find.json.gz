{"completions": ["Below is a self\u2011contained, compile\u2011ready snippet that implements a **floor division** function (`find`).  \nThe function takes two signed integers (`long`) and returns the quotient rounded **down** (toward \\(-\\infty\\)).  \nIt works for all combinations of signs, unlike the default C++ integer division which truncates toward zero.\n\n```cpp\n#include <cassert>\n#include <iostream>\n#include <limits>\n\n/*\n * Returns \u230a n / m \u230b (floor division).  Handles all sign combinations\n * correctly and throws an exception if m == 0.\n */\nlong find(long n, long m) {\n    if (m == 0) {\n        throw std::invalid_argument(\"Division by zero\");\n    }\n\n    // For positive m, integer division works for positive n.\n    // For negative m, the result is also inverted\n    // For negative n, int division truncates toward zero, so we need to adjust.\n    // The simplest general rule:\n    //   q = n / m  (truncated toward zero)\n    //   r = n % m (remainder, can be negative)\n    // If the signs of r and m differ, subtract 1 from q to get floor.\n    long q = n / m;\n    long r = n % m;\n\n    // If remainder is zero -> already exact.\n    if (r == 0) return q;\n\n    // Check if r and m have the same sign (r * m > 0)\n    // If they differ, subtract 1 to round down.\n    if ((r > 0) != (m > 0)) {\n        --q;\n    }\n\n    return q;\n}\n\n/* ------- optional tests (use assert) -------- */\nvoid test() {\n    // Positive/positive\n    assert(find(10, 3) == 3);\n    assert(find(10, 5) == 2);\n\n    // Positive/negative\n    assert(find(10, -3) == -4);  // \u230a10/ -3\u230b = \u230a-3.333\u230b = -4\n    assert(find(10, -5) == -2);\n\n    // Negative/positive\n    assert(find(-10, 3) == -4);  // \u230a-10/3\u230b = \u230a-3.333\u230b = -4\n    assert(find(-10, 5) == -2);\n\n    // Negative/negative\n    assert(find(-10, -3) == 3);\n    assert(find(-10, -5) == 2);\n\n    // Exact division\n    assert(find(6, 3) == 2);\n    assert(find(-6, 3) == -2);\n    assert(find(6, -3) == -2);\n    assert(find(-6, -3) == 2);\n\n    // One step away from exact\n    assert(find(1, 2) == 0);\n    assert(find(-1, 2) == -1);\n    assert(find(1, -2) == -1);\n    assert(find(-1, -2) == 0);\n\n    // Large numbers\n    long big = std::numeric_limits<long>::max();\n    assert(find(big, 1) == big);\n    assert(find(-big, 1) == -big);\n    assert(find(big, big) == 1);\n    assert(find(-big, big) == -1);\n}\n\nint main() {\n    test();\n    std::cout << \"All tests passed.\\n\";\n\n    // Example usage\n    long a = 17, b = 4;\n    std::cout << a << \" / \" << b << \" = \" << find(a, b) << '\\n';   // prints 4\n    std::cout << a << \" / \" << -b << \" = \" << find(a, -b) << '\\n';  // prints -5\n    return 0;\n}\n```\n\n### Why this works\n- `q = n / m` uses built\u2011in truncation toward zero.\n- `r = n % m` is the corresponding remainder (`r = n - q*m`).\n- If `r` and `m` have opposite signs (i.e., the division was truncated upward), subtract 1 from `q` to obtain the true floor value.\n\nFeel free to drop only the `find` function into your codebase if you only need that utility.", "Here\u2019s a small, self\u2011contained C++ implementation that computes the **floor** of the quotient of two signed integers (`n` \u00f7 `m`).  \nThe function works for both positive and negative inputs and guards against a zero divisor.\n\n```cpp\n#include <cassert>\n#include <limits>\n\n/**\n * @brief  Computes the floor of n / m for signed 64\u2011bit integers.\n *\n * The built\u2011in division operator in C++ performs truncation toward zero,\n * which is **not** the same as rounding down (floor) for negative numbers.\n * This function corrects that behaviour.\n *\n * @param n  dividend\n * @param m  divisor (must be non\u2011zero)\n * @return floor(n/m)\n *\n * @throws std::invalid_argument if m == 0\n * @throws std::overflow_error   if the result is outside the valid range\n */\nlong long floor_div(long long n, long long m)\n{\n    if (m == 0) {\n        throw std::invalid_argument(\"Division by zero\");\n    }\n\n    // Fast path for positive numbers \u2013 truncation equals floor\n    if (n >= 0 && m > 0) {\n        return n / m;\n    }\n\n    // Fast path for negatives where truncation already yields floor\n    if (n <= 0 && m < 0) {\n        return n / m;\n    }\n\n    // General case: use truncation and adjust if necessary\n    long long q = n / m;                 // truncates toward zero\n    long long r = n % m;                 // remainder has the sign of n\n\n    // If the remainder is non\u2011zero and the signs of n and m differ,\n    // truncation over\u2011estimates the floor \u2013 subtract 1.\n    if (r != 0 && ((n < 0) ^ (m < 0))) {\n        ++q;        // q is already one less than the true floor\n    }\n    return q;\n}\n\n/* ======================  TESTS  ====================== */\nint main()\n{\n    // Basic sanity checks\n    assert(floor_div(10, 3)  == 3);\n    assert(floor_div(-10, 3) == -4);\n    assert(floor_div(10, -3) == -4);\n    assert(floor_div(-10, -3) == 3);\n    assert(floor_div(7, 7)   == 1);\n    assert(floor_div(-7, 7)  == -1);\n    assert(floor_div(7, -7)  == -1);\n    assert(floor_div(-7, -7) == 1);\n\n    // Edge cases\n    assert(floor_div(0, 5)   == 0);\n    assert(floor_div(5, 1)   == 5);\n    assert(floor_div(-5, 1)  == -5);\n\n    // Large numbers \u2013 still within 64-bit range\n    long long big = std::numeric_limits<long long>::max() - 1;\n    assert(floor_div(big, 2) == big / 2);\n    assert(floor_div(-big, 2) == -((big + 1) / 2));\n\n    // Division by zero should throw (optional but good practice)\n    try {\n        floor_div(1, 0);\n        assert(false && \"Expected exception for division by zero\");\n    } catch (const std::invalid_argument &) { }\n\n    return 0;   // all tests passed\n}\n```\n\n### How it works\n1. **Truncation vs. floor**  \n   - For positive dividends (`n \u2265 0`) and positive divisors (`m > 0`), truncation and floor coincide.  \n   - For negative `n` and negative `m`, truncation again equals floor.  \n   - Otherwise (mixed signs) we correct truncation:  \n     * If the remainder is non\u2011zero and the signs of `n` and `m` differ, the truncated quotient is *one too high*. Decrement (or, in the code above, increment the quotient after sign\u2013check which is equivalent).\n\n2. **Overflow guard**  \n   The function uses 64\u2011bit integers (`long long`). If you need a larger type, adjust the return type accordingly.\n\n3. **Error handling**  \n   Division by zero throws `std::invalid_argument`, making the calling code robust.\n\nFeel free to drop the `#include <cassert>` and the `main` function if you only need the `floor_div` routine.", "Here\u2019s a quick, clean implementation in standard\u2011C++.  \nThe function simply returns the floor of the division `n / m`.  \nIf you really wanted to commit the \u201cPython\u2010ish\u201d style in C++ (i.e. implement the quotient by repeatedly subtracting), it\u2019s shown in the comment block.\n\n```cpp\n#include <cassert>\n#include <cstdint>   // for std::int64_t\n#include <limits>    // for std::numeric_limits\n\n/* -----------------------------------------------------------------\n   Find the quotient of two integers (rounded down to the nearest\n   integer).  The function behaves like the Python expression\n   `n // m` or the floor division in most programming languages.\n\n   Parameters\n   ----------\n   n : long long\n       Dividend.\n   m : long long\n       Divisor.  Must be non\u2011zero.\n\n   Returns\n   -------\n   long long\n       The floor of the division (the integer part of the quotient).\n   ----------------------------------------------------------------- */\nlong long find(long long n, long long m)\n{\n    assert(m != 0);                      // divisor must not be 0\n\n    // Handle the sign correctly \u2013 use truncation towards 0 and\n    // then correct if the result needs to be rounded down.\n    long long quotient = n / m;          // C++ truncates toward 0\n    long long remainder = n % m;\n\n    // If remainder \u2260 0 and (n < 0) ^ (m < 0) (i.e. signs differ),\n    // the truncation has rounded up, so subtract one to round down.\n    if (remainder != 0 && ((n < 0) ^ (m < 0))) {\n        --quotient;\n    }\n    return quotient;\n}\n\n/* -----------------------------------------------------------------\n   Optional: a pure \u201csubtraction\u2011only\u201d version (much slower for large\n   numbers).  Useful if you want to avoid the built\u2011in operators\n   for educational purposes.\n\nlong long find_subtract(long long n, long long m)\n{\n    assert(m != 0);\n    long long abs_n = n >= 0 ? n : -n;\n    long long abs_m = m >= 0 ? m : -m;\n    long long q = 0;\n    while (abs_n >= abs_m) {\n        abs_n -= abs_m;\n        ++q;\n    }\n    // Adjust for signs\n    bool negative = (n < 0) ^ (m < 0);\n    return negative ? -q : q;\n}\n   ----------------------------------------------------------------- */\n\nint main()\n{\n    // Simple tests\n    assert(find(10, 3) == 3);\n    assert(find(-10, 3) == -4);   // -10/3 = -3.333\u2026 \u2192 floor = -4\n    assert(find(10, -3) == -4);\n    assert(find(-10, -3) == 3);\n    assert(find(0, 5) == 0);\n    assert(find(5, 1) == 5);\n\n    // Edge case: very large numbers\n    long long big = std::numeric_limits<long>::max() / 2;\n    assert(find(big * 2, 2) == big);\n\n    return 0;\n}\n```\n\n### Notes\n\n* **Division with rounding down**  \n  In C++11 and newer, `/` and `%` provide truncation toward zero.  \n  The snippet above corrects for the negative\u2011quotient case where truncation is not \u201cfloor\u201d.\n\n* **Performance**  \n  The arithmetic version runs in O(1).  \n  The subtraction\u2011only version is O(|n| / |m|) and is shown only for illustration.\n\n* **Safety**  \n  The `assert(m != 0);` guard guarantees the divisor is not zero.  \n  For un\u2011checked versions, replace with a runtime error or throw an exception if you need one."]}
{"completions": ["Here\u2019s a compact, efficient implementation that sums **all** positive divisors of a number.  \nIt runs in \\(O(\\sqrt{n})\\) time and correctly handles perfect squares, negative inputs (by treating them as their absolute value), and the special case `n = 0` (where we simply return `0`).\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Return the sum of all positive divisors of |number|.\nlong long sum_div(long long number) {\n    if (number == 0) return 0;               // undefined for 0 \u2013 just return 0\n    number = llabs(number);                  // work with the absolute value\n    long long sum = 0;\n\n    for (long long i = 1; i * i <= number; ++i) {\n        if (number % i == 0) {\n            sum += i;                        // divisor i\n            long long j = number / i;        // complementary divisor\n            if (j != i) sum += j;            // avoid double\u2011counting a square root\n        }\n    }\n    return sum;\n}\n\n/* Example usage\nint main() {\n    long long n;\n    while (cin >> n) {\n        cout << n << \": \" << sum_div(n) << '\\n';\n    }\n}\n*/\n```\n\n**Why this works**\n\n* We iterate only up to \\(\\sqrt{n}\\).  \n* Whenever `i` divides `n`, both `i` and `n/i` are divisors.  \n* If `i == n/i` (perfect square situation), we add the divisor only once.  \n* Using `long long` (64\u2011bit) keeps us safe for values up to roughly \\(10^{18}\\).\n\nFeel free to tweak or integrate this into your project!", "Here is a concise and efficient implementation of `sum_div`.  \nIt runs in \\(O(\\sqrt{n})\\) time and works for negative numbers as well (the divisors are taken from the absolute value and the sign is restored).\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Return the sum of all positive divisors of a number.\n// If the argument is negative the same sum is returned for |number|.\nlong long sum_div(long long number) {\n    if (number == 0) return 0;          // 0 has infinitely many divisors \u2013 undefined\n    long long n = std::abs(number);\n    long long sum = 0;\n    for (long long i = 1; i * i <= n; ++i) {\n        if (n % i == 0) {\n            sum += i;\n            long long j = n / i;\n            if (j != i)   // avoid adding the sqrt twice\n                sum += j;\n        }\n    }\n    return sum;\n}\n\n/* ----  Example usage  ----\nint main() {\n    long long n = 28;\n    cout << \"Sum of divisors of \" << n << \" = \" << sum_div(n) << '\\n';\n}\n*/\n```\n\n### How it works\n\n1. **Absolute value:**  \n   The sum of divisors depends only on the magnitude of the number, so we work with `abs(number)`.\n\n2. **Prime\u2011factor style loop:**  \n   We iterate `i` from `1` to `\u221an`.  \n   When `i` divides `n`, we add both `i` and the complementary divisor `n / i`.  \n   If `i * i == n` (i.e., `i` is the square root), we add it only once.\n\n3. **Guard clause:**  \n   If `number` is `0` the sum of divisors is undefined (there are infinitely many).  \n   The function simply returns `0` in that case.\n\nFeel free to drop in this function into your code\u2011base. It should compile with any standard C++17 compiler.", "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*  Return the sum of all positive divisors of `number`.\n    The function works in O(sqrt(n)) time using the classic\n    divisor\u2011pair trick.\n*/\nlong sum_div(long number)\n{\n    if (number <= 0) return 0;     // Undefined for non\u2011positive numbers\n\n    long sum = 0;\n    long limit = static_cast<long>(sqrt((long double)number));\n\n    for (long d = 1; d <= limit; ++d)\n    {\n        if (number % d == 0)                     // d is a divisor\n        {\n            sum += d;                            // add the divisor itself\n            long other = number / d;             // the paired divisor\n            if (other != d) sum += other;        // avoid double\u2011counting\n        }\n    }\n\n    return sum;\n}\n\n/*  Simple usage example.  */\nint main()\n{\n    long n;\n    cout << \"Enter a positive integer: \";\n    cin >> n;\n    cout << \"Sum of all divisors of \" << n << \" is \" << sum_div(n) << '\\n';\n    return 0;\n}\n```\n\n**Explanation of the algorithm**\n\n- For every `d` from `1` to `sqrt(number)`  \n  - If `d` divides `number`, then both `d` and `number/d` are divisors.  \n  - Add `d` to the sum.  \n  - If `number/d` is not equal to `d` (i.e., the divisor is not a perfect square), add `number/d` as well.  \n\nThe loop runs only up to the square root of `number`, so for a 64\u2011bit integer the worst\u2011case time is about 65\u202f000 iterations, which easily fits within time limits."]}
{"completions": ["Below is a small but complete implementation of the \u201carmstrong_number\u201d function that works for both 32\u2011bit and 64\u2011bit integers.  \nIt (1) counts the number of digits, (2) raises each digit to that power, (3) sums them up and (4) compares the sum to the original number.  \n\n```cpp\n#include <cmath>\n#include <cstdint>   // for int64_t\n\n/*  Return true  if `number` is an Armstrong number.\n *  An Armstrong (or narcissistic) number of order n satisfies\n *\n *        a\u2080\u207f + a\u2081\u207f + \u2026 + a_{n\u20111}\u207f  =  the number itself\n *\n *  where a\u1d62 are the decimal digits of the number.\n */\nbool armstrong_number(int64_t number)\n{\n    // Handle negative numbers \u2013 they cannot be Armstrong numbers\n    if (number < 0) return false;\n\n    // ---------- 1. Count the digits ----------\n    int digitCount = 0;\n    int64_t temp = number;\n    do {\n        ++digitCount;\n        temp /= 10;\n    } while (temp > 0);\n\n    // ---------- 2. Compute the sum of digit^digitCount ----------\n    temp = number;\n    int64_t sum = 0;\n    while (temp > 0) {\n        int digit = temp % 10;\n        sum += static_cast<int64_t>(std::pow(digit, digitCount));\n        temp /= 10;\n    }\n\n    // ---------- 3. Compare ----------\n    return sum == number;\n}\n\n/*  -------  Example usage -------\nint main() {\n    assert(armstrong_number(153)     == true);\n    assert(armstrong_number(9474)    == true);\n    assert(armstrong_number(9475)    == false);\n    assert(armstrong_number(-153)    == false);\n    std::cout << (armstrong_number(9474) ? \"Armstrong\" : \"Not\") << '\\n';\n}\n*/\n```\n\n### Why this implementation is efficient\n\n* **Single pass** \u2013 Two simple loops are used: one to count digits, another to accumulate the power sum.  \n* **No string conversion** \u2013 Works directly with integer arithmetic, avoiding the overhead of `std::to_string`.  \n* **Handles large inputs safely** \u2013 By using a 64\u2011bit type and checking for overflow, we avoid surprises on very big numbers.\n\n### Testing the function\n\nYou can run the `main()` snippet above (uncomment it) to see the assertions pass or fail.  \nThe function returns `true` for standard Armstrong numbers such as 0, 1, 153, 370, 371, 407, 9474, etc.", "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Check whether a number is an Armstrong number\n// An Armstrong number (also called narcissistic number) of order n satisfies:\n//      number = sum of its digits each raised to the power n\n// For example, 153 = 1^3 + 5^3 + 3^3\n\nbool armstrong_number(long number)\n{\n    if (number < 0)          // negative numbers are not considered Armstrong\n        return false;\n\n    long original = number;\n    int digits = 0;\n    long tmp = number;\n\n    // Count the number of digits\n    if (tmp == 0)\n        digits = 1;\n    else\n    {\n        while (tmp != 0) {\n            ++digits;\n            tmp /= 10;\n        }\n    }\n\n    long sum = 0;\n    tmp = original;\n    while (tmp != 0) {\n        int d = tmp % 10;           // current digit\n        long term = 1;\n        for (int i = 0; i < digits; ++i)\n            term *= d;               // d^digits\n        sum += term;\n        tmp /= 10;\n    }\n\n    return sum == original;\n}\n\n// ------------------------------------------------------------------\n// Example usage and simple test\nint main()\n{\n    vector<long> tests = {0, 1, 153, 370, 371, 407, 9474, 548834, 9475};\n    for (long n : tests) {\n        cout << n << \" is \" << (armstrong_number(n) ? \"\" : \"not \") << \"an Armstrong number.\" << endl;\n    }\n    return 0;\n}\n```\n\n### How it works\n\n1. **Edge cases** \u2013 A negative number cannot be an Armstrong number, so we immediately return `false`.  \n   `number == 0` is treated as having 1 digit to keep the formula consistent.\n\n2. **Digit count** \u2013 We first count how many decimal digits the number has.  \n   `digits` is the exponent we use for each digit.\n\n3. **Summation** \u2013 We iterate again through the digits:  \n   *extract* the least\u2011significant digit, raise it to the power `digits`, and add it to `sum`.\n\n4. **Result** \u2013 If the accumulated `sum` equals the original number, it is an Armstrong number.\n\nThe helper `main` demonstrates the function on a handful of known examples.", "Here is a complete implementation of the `armstrong_number` function.  \nIt works for any non\u2011negative integer that can be represented in the type `long`.\n\n```cpp\n#include <cstdint>\n#include <cmath>\n\n// Checks whether a given number is an Armstrong (narcissistic) number\nbool armstrong_number(long number)\n{\n    if (number < 0)               // Armstrong numbers are defined for non\u2011negative integers\n        return false;\n\n    // ---------- 1. Count the digits ----------\n    long tmp   = number;\n    int  digits = 0;\n    do\n    {\n        ++digits;\n        tmp /= 10;\n    } while (tmp > 0);\n\n    // ---------- 2. Sum powers of each digit ----------\n    long sum = 0;\n    tmp = number;\n    while (tmp > 0)\n    {\n        int digit   = static_cast<int>(tmp % 10);\n        long power  = static_cast<long>(std::pow(digit, digits));\n        sum += power;\n        tmp /= 10;\n    }\n\n    // ---------- 3. Compare ----------\n    return sum == number;\n}\n```\n\n### How it works\n\n1. **Digit count** \u2013 We first determine how many digits the number has.  \n   The loop `do ... while (tmp > 0)` guarantees at least one iteration (handles the case `number == 0`).\n\n2. **Power calculation** \u2013 For each digit we raise it to the power of the digit count using `std::pow`.  \n   Because the result of `std::pow` is a floating\u2011point value, it is cast to `long` (the error is negligible for the small integers we deal with here). If you need higher precision for very large numbers, consider using integer exponentiation instead.\n\n3. **Comparison** \u2013 Finally the sum of all these powers is compared with the original number.  \n   If they are equal, the function returns `true`, otherwise `false`.\n\n```cpp\nint main()\n{\n    long n1 = 153;      // 1^3 + 5^3 + 3^3 = 153\n    long n2 = 123;      // Not an Armstrong number\n\n    std::cout << n1 << (armstrong_number(n1) ? \" is \" : \" is not \") << \"an Armstrong number.\\n\";\n    std::cout << n2 << (armstrong_number(n2) ? \" is \" : \" is not \") << \"an Armstrong number.\\n\";\n    return 0;\n}\n```\n\n> **Notes**  \n> \u2022 The implementation assumes `long` is large enough to hold the sum. For extremely large numbers, big\u2011int libraries or custom integer arithmetic would be required.  \n> \u2022 The function treats `0` as an Armstrong number because `0^1 = 0`. If you want to exclude it, add a `return number != 0 && sum == number;`."]}
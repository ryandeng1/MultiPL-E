{"completions": ["```cpp\n#include <cassert>\n#include <bits/stdc++.h>\n\n//  H_n = n ( 2n \u2013 1 )\nlong long hexagonal_num(long long n)\n{\n    // The formula is safe for all 64\u2011bit values of n\n    // that keep the result inside the range of long long.\n    return n * (2 * n - 1);\n}\n\n/*  Below is just a tiny demo (not required in the function itself)\n    to show how you can use the function and test it. */\nint main()\n{\n    for (long long i = 1; i <= 10; ++i)\n    {\n        long long h = hexagonal_num(i);\n        std::cout << \"Hexagonal number #\" << i << \" = \" << h << '\\n';\n    }\n    return 0;\n}\n```\n\nThe function `hexagonal_num` implements the closed\u2011form formula for the\u202f*n*\u2011th hexagonal number:  \n\n\\[\nH_n = n (2n - 1).\n\\]\n\nIt takes a 64\u2011bit integer `n` and returns the corresponding hexagonal number.", "Here is a complete, minimal implementation that follows the request:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// ------------------------------------------------------------------\n// Computes the nth hexagonal number.\n//\n// The formula for the nth hexagonal number is:\n//    H(n) = n * (2n \u2013 1)\n//\n// For n = 1 -> 1\n// For n = 2 -> 6\n// For n = 3 -> 15\n// ------------------------------------------------------------------\nlong hexagonal_num(long n) {\n    // Use long long to avoid overflow on very large n\n    long long nn = n;\n    return static_cast<long>(nn * (2 * nn - 1));\n}\n\n// ------------------------------------------------------------------\n// Optional: simple test harness\nint main() {\n    assert(hexagonal_num(1) == 1);\n    assert(hexagonal_num(2) == 6);\n    assert(hexagonal_num(3) == 15);\n    assert(hexagonal_num(4) == 28);\n    assert(hexagonal_num(10) == 190);\n\n    cout << \"All tests passed.\\n\";\n    return 0;\n}\n```\n\n**Explanation**\n\n* The mathematical formula for a hexagonal number is `H(n) = n * (2n \u2013 1)`.\n* We cast the intermediate calculation to `long long` to avoid overflow when `n` is large, then cast the result back to `long` to match the function\u2019s return type.\n* A small `main` with `assert` statements demonstrates the function\u2019s correctness.\n\nFeel free to remove the `main` if you only need the function for integration in another codebase.", "```cpp\n#include <cstdint>   // for int64_t\n#include <stdexcept>\n\n/* ---------------  Hexagonal Numbers  ----------------\n *  A hexagonal number counts the dots that can form a\n *  hexagon with side\u2011length `n` (consisting of `n` concentric\n *  hexagonal rings).  The nth hexagonal number is given by:\n *\n *        H(n) = n (2n \u2013 1)\n *\n *  The formula can be derived from the recurrence\n *  H(n) = H(n\u20111) + 6n \u2013 6 with H(1) = 1, but the closed form\n *  above is far more efficient.\n *\n *  The definition works for any positive integer n; for n \u2264 0\n *  we throw an exception because \u201cthe 0th\u201d or a negative\u2011indexed\n *  hexagonal number is not defined in the usual sense.\n */\nlong long hexagonal_num(long long n)\n{\n    if (n <= 0)\n        throw std::invalid_argument(\"hexagonal_num: n must be positive\");\n\n    // Use 128\u2011bit arithmetic to avoid overflow for very large n.\n    __int128 temp = static_cast<__int128>(n) * (2 * n - 1);\n    if (temp > static_cast<__int128>(LLONG_MAX))\n        throw std::overflow_error(\"Result does not fit in a 64\u2011bit integer\");\n\n    return static_cast<long long>(temp);\n}\n```\n\n### How to use\n\n```cpp\n#include <iostream>\n\nint main() {\n    for (long long i = 1; i <= 10; ++i) {\n        std::cout << \"H(\" << i << \") = \" << hexagonal_num(i) << '\\n';\n    }\n    return 0;\n}\n```\n\nOutput\n\n```\nH(1) = 1\nH(2) = 6\nH(3) = 15\nH(4) = 28\nH(5) = 45\nH(6) = 66\nH(7) = 91\nH(8) = 120\nH(9) = 153\nH(10) = 190\n```\n\nThe function runs in *O(1)* time and uses only a single arithmetic\noperation. It safely handles values up to about `9\u00d710^9` for 64\u2011bit\nsigned integers; larger inputs will trigger an overflow exception."]}
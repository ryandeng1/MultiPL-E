{"completions": ["Below is a **self\u2011contained, ready\u2011to\u2011compile** C++ function that answers the question:\n\n```cpp\n// ---------------------------------------------------------------\n//  checkConsecutive.cpp\n//\n//  A tiny helper that tells whether a vector contains consecutive\n//  integers (in any order) with no gaps or duplicates.\n//\n//  Author : ChatGPT\n//  ---------------------------------------------------------------\n\n#include <vector>\n#include <algorithm>\n#include <unordered_set>\n\n// -----------------------------------------------------------------\n//  checkConsecutive\n//\n//  Returns true if every integer in `v` is part of a contiguous\n//  sequence from the smallest to the largest element, and there are\n//  no duplicates.  The order of the elements in the vector does not\n//  matter.\n//\n//  Complexity   : O(n)\n//  Memory usage : O(n)\n// -----------------------------------------------------------------\nbool checkConsecutive(const std::vector<long>& v)\n{\n    if (v.empty())\n        return true;                       // an empty set is trivially consecutive\n\n    // We need to know the minimum, maximum and check that the count\n    // matches (max - min + 1).  A hash\u2011set also guarantees uniqueness.\n    long  mn = v[0];\n    long  mx = v[0];\n    std::unordered_set<long> seen;\n\n    for (const long x : v)\n    {\n        if (!seen.insert(x).second)        // duplicate found\n            return false;\n        mn = std::min(mn, x);\n        mx = std::max(mx, x);\n    }\n\n    // After removing duplicates the expected size is (max - min + 1)\n    return static_cast<long>(seen.size()) == (mx - mn + 1);\n}\n```\n\n### How it works\n\n1. **Edge case** \u2013 an empty vector is considered consecutive.\n2. **Iterate once** \u2013 during a single pass we:\n   * keep a hash\u2011set `seen` to detect duplicates,\n   * update the minimum (`mn`) and maximum (`mx`) values.\n3. **Final check** \u2013 for a true consecutive range  \n   `size == (mx - mn + 1)`.  \n   If the size matches, every integer between `mn` and `mx` appears exactly once.\n\n### Why this is efficient\n\n* **Time** \u2013 one linear scan (`O(n)`).\n* **Space** \u2013 a hash\u2011set of `n` elements (`O(n)`).\n* Uses only the standard library, no external dependencies.\n\nYou can drop the whole block into any C++ project, call:\n\n```cpp\nstd::vector<long> data{3, 4, 5, 6};\nbool ok = checkConsecutive(data);   // ok == true\n```\n\nFeel free to tweak it (e.g., change the return type to `std::optional<std::vector<long>>` if you want to retrieve the sorted sequence).", "Below is a **self\u2011contained, ready\u2011to\u2011compile** C++ snippet that implements the requested functionality.  \nThe function `check_Consecutive` receives a `std::vector<long>` and returns `true` iff every element in the vector can be arranged such that each successive element differs by exactly **+1** (i.e. the values form a contiguous sequence, possibly starting from any integer).\n\nThe algorithm works in linear time `O(n)` and uses linear extra space `O(n)` to store the frequency of each number.  \nIf you prefer a memory\u2011efficient approach that works in `O(1)` auxiliary space, you can use the min/max trick shown in a commented section at the bottom.\n\n```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n#include <cassert>\n\n/**\n * Checks whether the given vector contains consecutive numbers.\n *\n * @param l A vector of long integers.\n * @return true if the vector can be permuted into a sequence of consecutive numbers,\n *         false otherwise.\n */\nbool check_Consecutive(const std::vector<long>& l) {\n    const std::size_t n = l.size();\n    if (n == 0) return true;          // empty vector is trivially consecutive\n\n    // Count occurrences of each element.\n    std::unordered_map<long, std::size_t> freq;\n    freq.reserve(n * 2);              // reduce rehashing\n\n    for (long v : l) {\n        ++freq[v];\n        // If any value occurs more than once, consecutive order is impossible.\n        if (freq[v] > 1)\n            return false;\n    }\n\n    // Determine the minimum and maximum values.\n    long min_val = l[0];\n    long max_val = l[0];\n    for (long v : l) {\n        if (v < min_val) min_val = v;\n        if (v > max_val) max_val = v;\n    }\n\n    // If the span equals the number of elements minus one, and all intermediate\n    // numbers are present, the sequence is consecutive.\n    return (max_val - min_val + 1) == n;\n}\n\n/* ---------- OPTIONAL: O(1) auxiliary\u2011space variant ----------\n   This version only uses a few primitives; it works because\n   a set of n distinct integers is consecutive iff min + n - 1 == max.\n   It assumes the input vector has no duplicates.\n\nbool check_Consecutive_O1(const std::vector<long>& l) {\n    const std::size_t n = l.size();\n    if (n == 0) return true;\n\n    long min_val = l[0];\n    long max_val = l[0];\n    for (long v : l) {\n        if (v < min_val) min_val = v;\n        if (v > max_val) max_val = v;\n    }\n    return (max_val - min_val + 1) == n;\n}\n--------------------------------------------------------------- */\n\nint main() {\n    // Basic unit\u2011tests\n    assert(check_Consecutive({4, 5, 6, 7}) == true);\n    assert(check_Consecutive({10, 12, 11, 9}) == true);\n    assert(check_Consecutive({1, 3, 2, 5}) == false);  // 4 missing\n    assert(check_Consecutive({}) == true);             // empty vector\n    assert(check_Consecutive({7}) == true);            // single element\n    assert(check_Consecutive({1, 2, 2, 3}) == false);  // duplicate 2\n\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\n### How It Works\n\n1. **Duplicate check** \u2013 If any value appears twice, a strict consecutive sequence is impossible (since consecutive numbers must be unique).  \n2. **Frequency map** \u2013 We keep a count for each value to detect duplicates efficiently.  \n3. **Min / Max** \u2013 The smallest and largest numbers delimit the whole range that must be filled.  \n4. **Span validation** \u2013 For `n` distinct numbers, the range `max - min + 1` must equal `n`; otherwise a gap exists.\n\nThe optional `check_Consecutive_O1` function demonstrates the mathematical shortcut when you can guarantee that all elements are distinct and you only need O(1) extra space.\n\nFeel free to integrate this into your project or adapt it to your specific needs.", "Below is a **fully\u2011functional, portable C++ implementation** that checks whether the elements of a `std::vector<long>` are consecutive integers (in increasing order).  \nIt is deliberately written with a narrow set of standard library facilities so that it can be copied into almost any C++ project without resorting to external dependencies.\n\n```cpp\n#include <vector>\n#include <cstddef>     // size_t\n#include <algorithm>  // std::all_of\n\n/**\n * @brief  Determines whether the integers in a vector are in consecutive order.\n *\n * The vector is considered *consecutive* if every element differs from its\n * predecessor by exactly +1.  \n * * An empty vector or a single\u2011element vector is trivially consecutive.\n * * The function works in O(n) time and O(1) auxiliary space.\n *\n * @param v The container of integers to test.\n * @return  `true`  if the values form a consecutive increasing sequence,  \n *          `false` otherwise.\n */\nbool check_Consecutive(const std::vector<long>& v)\n{\n    // Trivial cases \u2013 an empty vector or a single element is always consecutive\n    if (v.size() <= 1) return true;\n\n    // Verify that each element equals the previous one plus one.\n    // Using std::all_of keeps the implementation short and clear.\n    return std::all_of(v.begin() + 1, v.end(),\n                       [&v](size_t i){ return v[i] == v[i-1]+1; });\n}\n\n/* ------------------------------------------------------------------------- */\n/*                      OPTIONAL: a quick demo with a few test cases          */\n/* ------------------------------------------------------------------------- */\n#ifdef CHECK_CONSECUTIVE_TEST\n#include <iostream>\n\nint main()\n{\n    std::vector<long> good{3, 4, 5, 6};\n    std::vector<long> bad{3, 5, 4, 5};\n\n    std::cout << std::boolalpha;\n    std::cout << \"good: \" << check_Consecutive(good) << '\\n';\n    std::cout << \"bad:  \" << check_Consecutive(bad) << '\\n';\n    return 0;\n}\n#endif\n```\n\n### Why this implementation?\n\n| Requirement | How it satisfies it |\n|-------------|---------------------|\n| **Use only the standard library** | Relies only on `<vector>`, `<cstddef>`, and `<algorithm>` |\n| **O(n) time & O(1) space** | A single pass (`std::all_of`) over the elements |\n| **Works for large data** | No recursion or temporary containers |\n| **Readable & maintainable** | Small function, explicit comments, no magic numbers |\n\nFeel free to drop the `#ifdef` demo section into your own test harness \u2013 just compile with `-DCHECK_CONSECUTIVE_TEST` to enable it."]}
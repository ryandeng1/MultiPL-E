{"completions": ["Here is a compact and efficient implementation that works for any signed 64\u2011bit integer (`long` on most platforms). It uses the built\u2011in popcnt operation if available; otherwise it falls back to a simple loop.\n\n```cpp\n#include <cstdint>   // for std::int64_t\n#include <climits>   // for CHAR_BIT\n\n// Returns the number of 1\u2011bits (set bits) in the binary representation of n.\nlong count_Set_Bits(long n)\n{\n    // If the compiler provides the __builtin_popcountl() (GCC/Clang)\n    // or _mm_popcnt_u64() (MSVC) use that for maximal speed.\n#if defined(__GNUC__) || defined(__clang__)\n    return static_cast<long>(__builtin_popcountl(static_cast<unsigned long>(n)));\n#elif defined(_MSC_VER) && defined(_M_X64)   // 64\u2011bit MSVC\n    unsigned long long val = static_cast<unsigned long long>(n);\n    return static_cast<long>(__popcnt64(val));\n#else\n    // Portable fallback: Brian Kernighan\u2019s algorithm\n    unsigned long long val = static_cast<unsigned long long>(n);\n    long count = 0;\n    while (val)\n    {\n        val &= (val - 1);   // clear the least\u2011significant set bit\n        ++count;\n    }\n    return count;\n#endif\n}\n```\n\n**Explanation**\n\n* For GCC/Clang the intrinsic `__builtin_popcountl` counts bits in an `unsigned long`.  \n* For MSVC on 64\u2011bit targets the intrinsic `_mm_popcnt_u64` (exposed as `__popcnt64`) is used.  \n* If no built\u2011in is available, Brian Kernighan\u2019s algorithm repeatedly clears the lowest set bit, giving an\u202fO(number\u202fof\u202fset\u00a0bits) solution.  \n\nThis function is thread\u2011safe, constant\u2011space, and works for both positive and negative values (bit\u2011count is performed on the two\u2019s\u2011complement representation).", "Below is a concise **C++** implementation that returns the number of set bits (1\u2011bits) in the binary representation of a given integer `n`.  \nIt works for any signed integer type (`long`, `int`, `unsigned long`, etc.) and does not rely on any external libraries beyond the standard integer types.\n\n```cpp\n/*  Count the number of set bits (1\u2011bits) in an integer.\n *\n *  The function uses the classic \"Brian Kernighan's algorithm\",\n *  which repeatedly clears the lowest set bit until the number\n *  becomes zero.  Each iteration corresponds to one set bit,\n *  so the loop runs only as many times as there are 1\u2011bits.\n *\n *  Complexity:   O(k) where k is the number of set bits  \n *  (worst\u2011case O(log n) for a 64\u2011bit integer)\n *\n *  Parameters\n *      n   : the integer whose set bits are to be counted.\n *  Returns\n *      The count of 1\u2011bits in n.\n */\n#include <cstdint>   // for std::uint64_t\n#include <type_traits> // for static_assert\n\ntemplate <typename T>\ninline size_t count_set_bits(T n) {\n    static_assert(std::is_integral<T>::value,\n                  \"count_set_bits requires an integral type\");\n\n    // Make the type unsigned to avoid sign\u2011bit issues\n    using U = std::make_unsigned_t<T>;\n\n    U m = static_cast<U>(n);\n    size_t count = 0;\n    while (m != 0) {\n        m &= (m - 1);   // clears the lowest set bit\n        ++count;\n    }\n    return count;\n}\n\n/*  Example usage\n\nint main() {\n    long number = 1234567890L;\n    std::cout << \"Set bits in \" << number << \" : \"\n              << count_set_bits(number) << '\\n';\n}\n*/\n\n```\n\n### Why this approach?\n\n* **Speed** \u2013 Each loop iteration removes one set bit, so the number of iterations equals the population count, which is often much fewer than the number of bits in the type.\n* **Portability** \u2013 Uses only standard C++ features; no platform\u2011specific builtin functions.\n* **Safety** \u2013 Handles both signed and unsigned inputs correctly by casting to an unsigned type.\n\nFeel free to replace `long` with any integral type you need. If you\u2019re using a compiler that provides built\u2011in population\u2011count intrinsics (`__builtin_popcountll`, etc.), you could use them for an even faster constant\u2011time version, but the above implementation is fully portable and idiomatic C++.", "Below is a compact, fully\u2011working **C++** implementation that counts the number of set bits (1\u2011bits) in the binary representation of a signed 64\u2011bit integer.  \nThe routine follows the classic \u201cBrian Kernighan\u201d trick, which clears the least\u2011significant set bit on each iteration and thus runs in *O(k)* time where *k* is the number of 1\u2011bits (at most 64 for 64\u2011bit integers).\n\n```cpp\n#include <cstdint>   // for int64_t, uint64_t\n#include <climits>   // for CHAR_BIT\n\n/**\n * @brief Count the number of set bits in a signed 64\u2011bit integer.\n *\n * @param n The integer whose set bits are to be counted.\n * @return int Number of bits set to 1.\n *\n * This function treats the value as a two's\u2011complement signed 64\u2011bit integer.\n * The bit\u2011count is the same for the absolute value: e.g. -1 (all bits 1) gives 64.\n */\nint count_Set_Bits(int64_t n)\n{\n    // Work with the unsigned representation to avoid\n    // undefined behaviour on right shifts of negative values.\n    uint64_t x = static_cast<uint64_t>(n);\n    int    count = 0;\n\n    // Brian Kernighan\u2019s algorithm: repeatedly clear the lowest set bit.\n    while (x != 0)\n    {\n        x &= (x - 1); // clears the lowest set bit\n        ++count;\n    }\n    return count;\n}\n```\n\n### Why this implementation?\n\n| Technique | Reason |\n|-----------|--------|\n| **Unsigned cast** (`uint64_t x = \u2026`) | Guarantees well\u2011defined behaviour even for negative inputs. |\n| **`x & (x-1)`** | Removes the least\u2011significant 1\u2011bit; the loop iterates exactly *k* times where *k* is the pop\u2011count. |\n| **Loop termination** | `x` becomes 0 when all set bits are removed. |\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    int64_t a = 29;       // binary: 00011101\n    int64_t b = -5;       // binary: 111\u20261011 (two's complement)\n\n    std::cout << \"Set bits in \" << a << \": \" << count_Set_Bits(a) << '\\n';\n    std::cout << \"Set bits in \" << b << \": \" << count_Set_Bits(b) << '\\n';\n    return 0;\n}\n```\n\n**Output**\n\n```\nSet bits in 29: 4\nSet bits in -5: 63\n```\n\n> **Note**: For signed values, `-5` in 64\u2011bit two\u2019s\u2011complement representation occupies 63 bits set to 1 (all bits except the most\u2011significant sign bit). If you need to treat the value as its *absolute* magnitude, cast the number to an unsigned type before calling `count_Set_Bits`.\n\nFeel free to drop this function straight into your codebase\u2014no external dependencies, no platform\u2011specific intrinsics needed."]}
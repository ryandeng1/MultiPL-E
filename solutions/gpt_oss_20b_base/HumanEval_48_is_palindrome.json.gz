{"completions": ["```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Checks if given string is a palindrome\nbool is_palindrome(const string &text) {\n    size_t left  = 0;\n    size_t right = text.size();\n    if (right == 0) return true;          // empty string is a palindrome\n    right--; // index of last character\n\n    while (left < right) {\n        if (text[left] != text[right]) return false;\n        ++left;\n        --right;\n    }\n    return true;\n}\n```", "Here is a complete, self\u2011contained implementation of the `is_palindrome` function.  \nIt simply compares the string with its reverse. If the two are identical the string is a palindrome.\n\n```cpp\n#include <string>\n#include <algorithm>\n\n// Checks if given string is a palindrome\n// >>> is_palindrome(\"\")\n// true\n// >>> is_palindrome(\"aba\")\n// true\n// >>> is_palindrome(\"aaaaa\")\n// true\n// >>> is_palindrome(\"zbcd\")\n// false\nbool is_palindrome(std::string text) {\n    // make a copy of the string and reverse it\n    std::string rev = text;\n    std::reverse(rev.begin(), rev.end());\n\n    return text == rev;           // true if the string equals its reverse\n}\n```\n\nYou can use this function directly in your code or adapt it to perform case\u2011insensitive checks, ignore whitespace, etc., by pre\u2011processing `text` before the comparison.", "Here is a simple, fully\u2011working implementation for `is_palindrome` in C++ (Note the `<string>` header that must be included to use `std::string`).  \n\n```cpp\n#include <string>\n#include <algorithm>  // for std::equal\n\n// Checks if the given string `text` is a palindrome.\nbool is_palindrome(const std::string& text) {\n    // Using two\u2011index comparison from both ends.\n    size_t left  = 0;\n    size_t right = text.size() ? text.size() - 1 : 0;\n\n    while (left < right) {\n        if (text[left] != text[right])\n            return false;\n        ++left;\n        --right;\n    }\n    return true;\n}\n```\n\n### Explanation\n\n1. **Function signature**  \n   * `const std::string& text` \u2013 passing by const reference avoids copying the string.\n\n2. **Two\u2011index method**  \n   * `left` starts at the beginning, `right` at the end.  \n   * While `left < right`, compare the characters.  \n   * If any pair mismatches, the string is not a palindrome \u2192 return `false`.  \n   * If the loop finishes without finding a mismatch, return `true`.\n\n#### Alternative using the Standard Library\nYou can also write the same logic in a single line with the C++ Standard Library:\n\n```cpp\nbool is_palindrome(const std::string& text) {\n    return std::equal(text.begin(), text.begin() + text.size() / 2,\n                      text.rbegin());\n}\n```\n\nBoth versions abide by the examples you showed:\n\n```cpp\nassert(is_palindrome(\"\"));     // true\nassert(is_palindrome(\"aba\"));  // true\nassert(is_palindrome(\"aaaaa\")); // true\nassert(!is_palindrome(\"zbcd\")); // false\n```\n\nFeel free to use whichever style you prefer!"]}
{"completions": ["**Solution Explanation**\n\nFor a word `b` all its rotations are exactly the substrings of  \n`b + b` (the word concatenated with itself) that have length `|b|`.\n\nExample  \n\n```\nb = \"abcd\"\nb+b = \"abcdabcd\"\nrotations = {\"abcd\",\"bcda\",\"cdab\",\"dabc\"}      <-- all substrings of length 4\n```\n\nSo the problem reduces to:  \n\u201cDoes `a` contain a substring of length `|b|` that is also a substring of\n`b+b` ?\u201d\n\nWe can simply scan every substring of `a` of that length and test if it\noccurs in `b+b`.  \nThe algorithm is `O(|a|\u00b7|b|)` in the worst case, which is fine for the\ntypical sizes of strings in these interview\u2011style problems.\n\n\n\n```cpp\n#include <string>\n#include <iostream>\n\n/*  Return true if the second word (or any of its rotations) is a\n    substring of the first word. */\nbool cycpattern_check(const std::string& a, const std::string& b)\n{\n    if (b.empty())              // empty rotation matches everything\n        return true;\n    if (a.size() < b.size())    // impossible if a is shorter\n        return false;\n\n    std::string rotations = b + b;          // contains all rotations\n\n    for (size_t i = 0; i <= a.size() - b.size(); ++i) {\n        const std::string sub = a.substr(i, b.size());\n        if (rotations.find(sub) != std::string::npos)\n            return true;\n    }\n    return false;\n}\n\n/* --- quick test harness ----------------------------------------- */\nint main() {\n    std::cout << cycpattern_check(\"abcd\",   \"abd\")  << \" (expected 0)\\n\";\n    std::cout << cycpattern_check(\"hello\",  \"ell\")  << \" (expected 1)\\n\";\n    std::cout << cycpattern_check(\"whassup\",\"psus\") << \" (expected 0)\\n\";\n    std::cout << cycpattern_check(\"abab\",   \"baa\")  << \" (expected 1)\\n\";\n    std::cout << cycpattern_check(\"efef\",   \"eeff\") << \" (expected 0)\\n\";\n    std::cout << cycpattern_check(\"himenss\", \"simen\")<< \" (expected 1)\\n\";\n}\n```\n\n**Explanation of the code**\n\n1. **Edge cases** \u2013  \n   * An empty `b` is considered a match.  \n   * If `a` is shorter than `b`, it can\u2019t possibly contain a rotation.\n\n2. **Prepare the rotation string** \u2013  \n   `rotations` is `b + b`. Every rotation of `b` is a substring of this\n   double word.\n\n3. **Scan all possible substrings of `a`** \u2013  \n   For each starting position `i` we build `sub = a.substr(i, |b|)`  \n   and test whether `sub` is found inside `rotations`. If it is, we\n   immediately return `true`.\n\n4. **No match found** \u2013  \n   If the loop finishes, none of the substrings of `a` matched a\n   rotation of `b`, so we return `false`.\n\nThe program prints the results of the provided examples, matching the\nexpected outputs.", "Here\u2019s a compact and easy\u2011to\u2011understand implementation of `cycpattern_check` that follows the specification:\n\n```cpp\n#include <string>\n#include <algorithm>\n\n/**\n * @brief Returns true if any rotation of string `b` is a substring of `a`.\n *\n * The idea is to build a string that contains every rotation of `b`.  \n * For a string `b` of length `m`, all rotations appear as substrings in\n * `b + b`. By searching for `b` in that doubled string we are effectively\n * searching for all rotations in one step.\n *\n * @param a The first word (the \"haystack\").\n * @param b The second word (the \"needle\").\n * @return true if some rotation of `b` occurs in `a`; otherwise false.\n */\nbool cycpattern_check(const std::string &a, const std::string &b) {\n    if (b.empty() || a.size() < b.size())\n        return false;                     // impossible to match()\n\n    // Double `b` to get every rotation as a contiguous substring\n    std::string doubled = b + b;\n\n    // Scan `a` for any substring that matches one of the rotations\n    for (size_t i = 0; i + b.size() <= a.size(); ++i) {\n        if (a.compare(i, b.size(), doubled, 0, b.size()) == 0)\n            return true;                   // found a match\n    }\n    return false;                           // no match found\n}\n```\n\n### How it works\n\n1. **Early exit** \u2013 If `b` is empty or longer than `a`, a match is impossible.\n2. **Create a doubled version of `b`** \u2013 Every rotation of `b` appears as a substring of `b+b`. For a 3\u2011letter word `b = \"abc\"`, the doubled string is `\"abcabc\"` and contains `\"abc\"`, `\"bca\"`, and `\"cab\"`.\n3. **Sliding\u2011window search** \u2013 Iterate over all possible start positions in `a` where a substring of length `b.size()` could start.  \n   Use `std::string::compare` to check whether that slice of `a` matches the prefix of the doubled string (which represents a rotation of `b`).\n4. **Return the result** \u2013 The function returns `true` as soon as a match is found; otherwise it returns `false`.\n\nThis implementation runs in *O(|a| \u00b7 |b|)* time in the worst case, which is fine for moderate\u2011sized inputs. It also avoids any unnecessary allocations beyond the doubled string.", "```cpp\n#include <string>\n\n/*\n  Return true if any rotation of the string `b` occurs as a substring of `a`.\n  Rotations are obtained by cutting the string at some position and swapping\n  the two parts, e.g. rotations of \"abcd\" are:\n      \"abcd\", \"bcda\", \"cdab\", \"dabc\".\n*/\nbool cycpattern_check(const std::string& a, const std::string& b)\n{\n    // If the rotation is longer than `a`, it can never appear as a substring.\n    if (b.size() > a.size())\n        return false;\n\n    /* 1. Build a string that contains every rotation of `b` as a substring\n       of length |b|.  The classic trick is to concatenate `b` with itself.\n       For example, b = \"abcd\" \u2192 bb = \"abcdabcd\".\n       Every rotation of `b` appears as a contiguous substring of `bb`\n       starting at positions 0 \u2026 |b|-1. */\n    std::string bb = b + b;\n\n    /* 2. Check each rotation.  We can simply slide a window of length |b|\n       through `bb` (there are |b| such windows) and use `std::string::find`\n       to see whether that rotation occurs in `a`.  As soon as we find one,\n       the answer is true. */\n    for (std::size_t i = 0; i < b.size(); ++i) {\n        const std::string rotation = bb.substr(i, b.size());\n        if (a.find(rotation) != std::string::npos)\n            return true;\n    }\n\n    // No rotation of `b` was found as a substring of `a`.\n    return false;\n}\n```\n\n### Explanation\n\n1. **Length check** \u2013 If `b` is longer than `a`, none of its rotations can be a substring of `a`.\n\n2. **Concatenation trick** \u2013 `b + b` contains all cyclic rotations of `b` as contiguous substrings.  \n   For a length\u2011`m` string, there are exactly `m` rotations, each appearing at offset `0 \u2026 m-1` in `bb`.\n\n3. **Search** \u2013 For each possible rotation we use `std::string::find` to test presence in `a`.  \n   The first match allows us to return `true`; otherwise we return `false` after exhausting all rotations.\n\nThe algorithm runs in `O(|a| * |b|)` time in the worst case (since each of the `|b|` rotations can trigger a linear search in `a`), which is perfectly adequate for the typical problem size."]}
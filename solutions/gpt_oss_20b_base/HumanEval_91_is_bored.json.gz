{"completions": ["**Solution Explanation**\n\nWe have to count how many sentences in a text start with the word `I`.  \nSentences are separated by the punctuation marks `.` `?` `!`.  \nAfter splitting we have to ignore leading/trailing blanks, because a sentence can begin with spaces after a delimiter.\n\n**Algorithm**\n\n```\ncount = 0\ncurr = \"\"                       // current token being read\n\nfor every character c in S together with a final sentinel '#':\n    if c is a delimiter ('.', '?', '!', '#'):     // we hit a sentence end\n        trim curr (remove leading/trailing spaces)\n        if curr is not empty and curr starts with \"I\":\n              count++\n        curr = \"\"\n    else:\n        curr += c\n\nreturn count\n```\n\nThe `'#'` sentinel at the end guarantees that the last sentence is processed\neven if the input does not end with a delimiter.\n\n**Correctness Proof**\n\nWe prove that the algorithm returns the exact number of sentences that\nstart with `\"I\"`.\n\n*Lemma 1*  \nThe loop processes each maximal substring of `S` that does not contain\n`'.', '?', or '!'` as one unit `curr` and then resets `curr` to the empty\nstring.  \n*Proof.*  \n`curr` is concatenated with every non\u2011delimiter character. When a delimiter\nis encountered, the algorithm executes the block that treats the accumulated\n`curr` as a sentence and clears it. Thus each maximal non\u2011delimiter\nsubstring becomes a sentence. \u220e\n\n*Lemma 2*  \nFor every processed `curr`, the algorithm declares it a \u201cboredom\u201d (i.e. it\nincrements `count`) **iff** the original sentence starts with the word\n`\"I\"`.  \n*Proof.*  \n`curr` is trimmed of surrounding spaces.  \nIf the trimmed string is non\u2011empty and its first character is `'I'`,\nthe sentence certainly begins with the word `I` (the next character is either a\nspace, another letter or the sentence end).  \nConversely, if a sentence begins with `\"I\"`, after trimming its first\ncharacter will be `'I'`. Hence the condition matches exactly these cases. \u220e\n\n*Theorem*  \nThe algorithm returns the number of sentences in `S` that start with `\"I\"`.  \n*Proof.*  \nBy Lemma&nbsp;1 every sentence is examined once, and by Lemma&nbsp;2 it is\ncounted precisely when it starts with `\"I\"`. Thus the final value of `count`\nequals the desired number. \u220e\n\n**Complexity Analysis**\n\nLet `n` be the length of `S`.  \nThe algorithm scans `S` once and does only constant\u2011time work per character.  \nHence the time complexity is `O(n)` and the auxiliary space usage is `O(1)`  \napart from the temporary string `curr`.\n\n**Reference Implementation (C++)**\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// Counts sentences that start with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// Leading/trailing spaces around a sentence are ignored.\nlong is_bored(const string& S) {\n    long count = 0;\n    string curr;                    // buffer for the current sentence\n    auto finish_sentence = [&](void) {\n        // trim leading/trailing spaces\n        size_t start = 0;\n        while (start < curr.size() && isspace(static_cast<unsigned char>(curr[start])))\n            ++start;\n        size_t end = curr.size();\n        while (end > start && isspace(static_cast<unsigned char>(curr[end-1])))\n            --end;\n\n        if (start < end) {\n            // check if the trimmed string starts with \"I\"\n            if (curr[start] == 'I')\n                ++count;\n        }\n    };\n\n    for (char c : S) {\n        if (c == '.' || c == '?' || c == '!') {\n            finish_sentence();\n            curr.clear();\n        } else {\n            curr.push_back(c);\n        }\n    }\n    /* process the last sentence if S does not end with a delimiter */\n    finish_sentence();\n\n    return count;\n}\n\n/* ---------- Optional main for quick testing ---------- */\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    string input = \"The sky is blue. The sun is shining. I love this weather\";\n    cout << is_bored(input) << '\\n';   // should output 1\n    return 0;\n}\n```\n\nThe code follows the algorithm proved correct above and adheres to modern\nC++ best practices.", "Here\u2019s a ready\u2011to\u2011use C++ implementation of `is_bored` that follows the specification:\n\n* Sentences are split on the characters `.` `?` `!`.\n* A sentence counts as a boredom only if the very first word after the delimiter (or at the beginning of the string) is `\"I\"`.\n* Leading spaces are ignored, and the comparison is case\u2011sensitive.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong is_bored(const string& S) {\n    long count = 0;\n    size_t pos = 0;                 // current position in the string\n    bool start_of_sentence = true;  // true when we are at a new sentence\n\n    while (pos < S.size()) {\n        char c = S[pos];\n\n        // If we\u2019re at the start of a new sentence, skip leading spaces\n        if (start_of_sentence) {\n            while (pos < S.size() && isspace(S[pos]))\n                ++pos;              // skip whitespace\n\n            // If we hit the end after skipping spaces, break\n            if (pos >= S.size())\n                break;\n\n            // Check if the sentence starts with the word \"I\"\n            if (S[pos] == 'I') {\n                // Ensure that it's a word boundary (either end or non\u2011alpha)\n                size_t j = pos + 1;\n                if (j == S.size() || !isalpha(S[j]))\n                    ++count;\n            }\n            start_of_sentence = false;\n        }\n\n        // Move forward until we find a sentence delimiter\n        if (c == '.' || c == '?' || c == '!') {\n            start_of_sentence = true; // next character starts a new sentence\n        }\n        ++pos;\n    }\n    return count;\n}\n```\n\n### How It Works\n| Step | What Happens | Why |\n|------|--------------|-----|\n| `start_of_sentence` flag | Indicates that we are at the start of a sentence. | It ensures we only check the first word after a delimiter. |\n| `while (isspace(S[pos])) ++pos;` | Skips any spaces or newlines right after the start of a sentence. | Sentences may be separated by spaces. |\n| `if (S[pos] == 'I')` | Checks if the first non\u2011space character is `I`. | Only `\"I\"` at the beginning qualifies. |\n| `size_t j = pos + 1;` & `if (j == S.size() || !isalpha(S[j]))` | Ensures that `I` is a whole word. | Prevents cases like `\"If\"` from being counted. |\n| `if (c == '.' || c=='?' || c=='!') start_of_sentence = true;` | Marks the next character as the start of a new sentence. | Delimiters separate sentences. |\n\n### Example Usage\n```cpp\nint main() {\n    cout << is_bored(\"Hello world\") << endl; // 0\n    cout << is_bored(\"The sky is blue. The sun is shining. I love this weather\") << endl; // 1\n    cout << is_bored(\"I am bored. I am not.\") << endl; // 2\n}\n```\n\nThis function runs in linear time relative to the size of the input string and uses only a constant amount of extra memory.", "**Solution Explanation**\n\nFor every sentence in the input text we have to decide whether it starts with the word **exactly** \"`I`\".  \nSentences are separated by one of the following characters:\n\n```\n.    !    ?\n```\n\nThe input is a single string `S`.  \nThe required function is:\n\n```cpp\nlong is_bored(std::string S);\n```\n\nIt must return the number of sentences that begin with the word `I`.\n\n\n\n--------------------------------------------------------------------\n\n#### 1.  Observations\n\n* We only have to look at *the first non\u2011space character* after a sentence\n  delimiter (or at the very start of the string).  \n  If this character is an `I`, we got a boredom.\n\n* A sentence *starts* only when the preceding character is a delimiter (or\n  the string starts).  \n  Spaces, tabs or newlines after the delimiter are allowed and must be\n  skipped.\n\n* The simple brute force plan\n  \u2013 split the string at the delimiters and analyse every fragment \u2013 is\n  perfectly fine, but we can also process the string in one pass, which\n  avoids any extra memory.\n\n--------------------------------------------------------------------\n\n#### 2.  Algorithm\n```\ncount  = 0\ninSentence = true             // we are at the start of a sentence\n\nfor each character c in S\n        // ignore all spaces after a delimiter\n        if inSentence\n                if c is a space or tab or newline\n                        continue\n                else\n                        // first non\u2011blank character of a new sentence\n                        if c == 'I'\n                                ++count\n                        inSentence = false\n        // once inside a sentence, look for a delimiter\n        if c == '.' or c == '?' or c == '!'\n                inSentence = true\nreturn count\n```\n\n--------------------------------------------------------------------\n\n#### 3.  Correctness Proof  \n\nWe prove that the algorithm returns exactly the number of boredom sentences.\n\n---\n\n##### Lemma 1  \n`inSentence` is *true* **iff** the current position in the string is immediately\nafter a sentence delimiter or at the very start of the string.\n\n**Proof.**\n\n*Initialization*: before the loop starts `inSentence = true`.  \nThe string begins before any character, so the property holds.\n\n*Maintenance*:  \nWhen a delimiter `.` `?` or `!` is read, `inSentence` is set to true\n-- therefore the property holds for the next character.  \nIn all other cases `inSentence` keeps its previous value.\nThus the property is preserved for every iteration. \u220e\n\n\n\n##### Lemma 2  \nWhen the algorithm executes `++count`, the sentence that has just been\nfinished starts with the word \"`I`\".\n\n**Proof.**\n\n`++count` is executed only in the branch that handles the *first non\u2011blank*\ncharacter of a sentence, namely when `inSentence` is true.  \nThe first non\u2011blank character of the sentence is `c`.  \nIf it equals `'I'`, we increment `count`.  \nThus a boredom is counted **iff** the first non\u2011blank character is `I`. \u220e\n\n\n\n##### Lemma 3  \nEvery sentence that starts with the word \"`I`\" is counted exactly once.\n\n**Proof.**\n\nConsider such a sentence.  \nAt its first non\u2011blank character the algorithm is in the branch of Lemma&nbsp;2,\ntherefore it increments `count`.  \nBecause after that the algorithm advances to the next character and the\nflag `inSentence` becomes `false`, the same sentence will never be counted\nagain. \u220e\n\n\n\n##### Theorem  \n`is_bored(S)` returns the exact number of sentences in `S` that begin with\nthe word \"`I`\".\n\n**Proof.**\n\n*Soundness*: By Lemma&nbsp;2 a sentence can be counted only if its first\nnon\u2011blank character is `I`.  \nTherefore every counted sentence satisfies the definition.\n\n*Completeness*: By Lemma&nbsp;3 each sentence that satisfies the definition\nis counted once.  \n\nThus the final value returned by the function equals the desired number. \u220e\n\n\n\n--------------------------------------------------------------------\n\n#### 4.  Complexity Analysis\n\nLet `n = |S|`.\n\nThe algorithm scans the string once, performing O(1) work per character.\n\n```\nTime   : O(n)\nMemory : O(1)\n```\n\n--------------------------------------------------------------------\n\n#### 5.  Reference Implementation (C++17)\n\n```cpp\n#include <string>\n\n/*  Count sentences that start with the word \"I\"  */\nlong is_bored(std::string S) {\n    long count = 0;\n    bool in_sentence = true;        // at start or after a delimiter\n\n    for (char c : S) {\n        // skip blanks when at the beginning of a sentence\n        if (in_sentence) {\n            if (c == ' ' || c == '\\t' || c == '\\n')\n                continue;\n\n            // first non\u2011blank character of a new sentence\n            if (c == 'I')\n                ++count;\n            in_sentence = false;\n        }\n\n        // look for sentence end markers\n        if (c == '.' || c == '?' || c == '!')\n            in_sentence = true;\n    }\n\n    return count;\n}\n```\n\nThe code follows exactly the algorithm proven correct above and\nconforms to the C++17 standard."]}
{"completions": ["Here\u2019s a minimal, self\u2011contained implementation that simply sorts every inner vector (the *sublists*) lexicographically and returns the resulting vector of vectors.  \nFeel free to drop it into your file and call `sort_sublists` with any `std::vector<std::vector<std::string>>`.\n\n```cpp\n#include <vector>\n#include <string>\n#include <algorithm>   // std::sort\n#include <cassert>\n\n/*\n * Sort each sub\u2011vector of strings in the given vector of vectors.\n * The original vector is left unchanged \u2013 we work on a copy.\n *\n * Example\n *   input  : { {\"cat\",\"dog\",\"apple\"}, {\"banana\",\"apple\"} }\n *   output : { {\"apple\",\"cat\",\"dog\"}, {\"apple\",\"banana\"} }\n */\nstd::vector<std::vector<std::string>> sort_sublists(\n    const std::vector<std::vector<std::string>>& list1)\n{\n    // Make a copy so we can return a sorted version without modifying the input\n    std::vector<std::vector<std::string>> result = list1;\n\n    for (auto& sublist : result) {\n        std::sort(sublist.begin(), sublist.end());\n    }\n\n    return result;\n}\n\n/* ---------- Small test harness ---------- */\n#ifdef UNIT_TEST_SORT_SUBLISTS\n#include <iostream>\n\nint main()\n{\n    std::vector<std::vector<std::string>> data{\n        {\"light\", \"blue\", \"orange\"},\n        {\"cat\", \"added\", \"banana\"},\n        {\"zebra\", \"aardvark\"}\n    };\n\n    auto sorted = sort_sublists(data);\n\n    // Check if each sublist is sorted\n    for (size_t i = 0; i < sorted.size(); ++i) {\n        std::vector<std::string> copy = sorted[i];\n        std::sort(copy.begin(), copy.end());\n        assert(copy == sorted[i]);               // pass if sorted\n        std::cout << \"Sublist \" << i << \" sorted correctly.\\n\";\n    }\n\n    return 0;\n}\n#endif\n```\n\n### Notes\n\n* The function accepts the vector of vectors **by const reference** to avoid an unnecessary copy of the input.  \n* We then create a copy (`result`) that we modify and return.  \n* `std::sort` uses the `<` operator on `std::string`, giving you lexicographical ordering.  \n* The test harness (guarded by `#ifdef UNIT_TEST_SORT_SUBLISTS`) shows how you could quickly verify the function. Compile with `-DUNIT_TEST_SORT_SUBLISTS` to run it.", "Below is a compact, self\u2011contained implementation of the function you asked for.  \nIt receives a `std::vector<std::vector<std::string>>` and returns a new vector in which\nevery inner vector has been sorted lexicographically. The implementation uses the\nstandard library\u2019s `std::sort`, so no extra headers beyond the usual ones are\nrequired.\n\n```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\n\n// -----------------------------------------------------------------------------\n// Sort every sub\u2011list in the supplied vector of vectors.\n// The function is marked `[[nodiscard]]` so the compiler will warn if the\n// returned value is ignored \u2013 a good practice for functions that produce a new\n// sorted container.\n// -----------------------------------------------------------------------------\n[[nodiscard]] std::vector<std::vector<std::string>>\nsort_sublists(const std::vector<std::vector<std::string>>& list1) {\n    // Copy the input so that we do not modify the caller\u2019s data.\n    std::vector<std::vector<std::string>> result = list1;\n\n    // Sort each inner vector independently.\n    for (auto& sublist : result) {\n        std::sort(sublist.begin(), sublist.end());\n    }\n\n    return result;\n}\n\n// -----------------------------------------------------------------------------\n// Simple unit tests (you can run them with any C++ compiler):\n// -----------------------------------------------------------------------------\n#ifdef UNIT_TEST\n#include <iostream>\n\nint main() {\n    using namespace std;\n\n    vector<vector<string>> test = {\n        {\"pear\", \"apple\", \"orange\"},\n        {\"blueberry\", \"apple\"},\n        {\"kiwi\", \"kiwi\", \"apple\"}\n    };\n\n    vector<vector<string>> expected = {\n        {\"apple\", \"orange\", \"pear\"},\n        {\"apple\", \"blueberry\"},\n        {\"apple\", \"kiwi\", \"kiwi\"}\n    };\n\n    auto got = sort_sublists(test);\n    assert(got == expected);\n\n    cout << \"All tests passed.\\n\";\n    return 0;\n}\n#endif\n```\n\n### How to use\n\nCompile the code. If you add the `-DUNIT_TEST` flag (or simply remove the `#ifdef\nUNIT_TEST` guard if you want the test in the same file) you will get a small\ntest program that verifies the implementation.\n\n```bash\ng++ -std=c++17 -Wall -Wextra -DUNIT_TEST yourfile.cpp && ./a.out\n```\n\nThe function itself is trivial: it copies the input, iterates over each inner\nvector, sorts it in place, and returns the sorted copy. You can replace the\n`std::string` type with any other type that has a `operator<` defined if you\nneed a more generic solution.", "Here\u2019s a straightforward implementation.  \nEach inner vector is sorted in\u2013place using `std::sort` (which uses `operator<` for `std::string`, i.e., lexicographic order).  \nThe function returns a new `vector<vector<string>>`, but if you prefer an in\u2011place modification you can simply return `void` and sort the parameter by reference.  \n\n```cpp\n#include <vector>\n#include <string>\n#include <algorithm>   // for std::sort\n\n// Sort each sub\u2011vector of strings lexicographically\nstd::vector<std::vector<std::string>>\nsort_sublists(std::vector<std::vector<std::string>> list1)\n{\n    for (auto& sublist : list1)          // iterate over each inner vector\n    {\n        std::sort(sublist.begin(), sublist.end()); // sort that sublist\n    }\n    return list1;                         // return the sorted collection\n}\n```\n\n### Usage example\n\n```cpp\nint main()\n{\n    std::vector<std::vector<std::string>> data = {\n        {\"orange\", \"apple\", \"banana\"},\n        {\"cat\", \"apple\", \"dog\"},\n        {\"bear\", \"ant\", \"caterpillar\"}\n    };\n\n    auto sorted = sort_sublists(data);\n\n    for (const auto& sublist : sorted)\n    {\n        for (const auto& word : sublist)\n            std::cout << word << ' ';\n        std::cout << '\\n';\n    }\n}\n```\n\nOutput:\n\n```\napple banana orange\napple cat dog\nant bear caterpillar\n```\n\nFeel free to adjust the function signature if you want in\u2011place sorting (`void sort_sublists(std::vector<std::vector<std::string>>& list1)`) or to use any custom comparison."]}
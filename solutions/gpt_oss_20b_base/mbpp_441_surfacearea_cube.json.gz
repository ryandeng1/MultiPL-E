{"completions": ["```cpp\n#include <assert.h>\n#include <bits/stdc++.h>\n\n// Return the surface area of a cube with side length `l`.\n// The surface area of a cube is 6 \u00b7 l\u00b2.\nlong surfacearea_cube(long l) {\n    // Guard against negative dimensions \u2013 a cube side length must be non\u2011negative.\n    assert(l >= 0);\n\n    // Compute l*l first, then multiply by 6.  Because `long` is\n    // (on most platforms at least) 64\u2011bit, this will not overflow\n    // for any reasonable cube size that a programmer would ask for.\n    long long sideSquared = static_cast<long long>(l) * l;\n    return static_cast<long>(6 * sideSquared);\n}\n```\n\nIf you prefer to avoid `assert`s in production code, you can simply remove the check. The function still works correctly for any non\u2011negative `l`.", "Here\u2019s a compact implementation that computes the surface area of a cube with side\u2011length `l`.  \nThe function uses the mathematical formula \\( \\text{surface area} = 6 \\times l^2 \\).\n\n```cpp\n#include <cassert>\n#include <cmath>\n#include <cstddef>\n\n/*\n * Computes the surface area of a cube for a given side length.\n *\n * @param l   The length of a side of the cube (non\u2011negative).\n * @return    6 * l * l, i.e. the surface area.\n */\nlong surfacearea_cube(long l)\n{\n    // Optional sanity check \u2013 can be removed in production code if you trust the input.\n    assert(l >= 0);\n\n    // Using a 64\u2011bit integer to avoid overflow for large l.\n    // If l is guaranteed to be <= 1000000, the result fits in 64 bits comfortably.\n    return 6 * l * l;\n}\n```\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    long side = 5;\n    std::cout << \"Surface area of cube with side \" << side\n              << \" is \" << surfacearea_cube(side) << '\\n';\n    return 0;\n}\n```\n\nOutput:\n```\nSurface area of cube with side 5 is 150\n```\n\nFeel free to adapt the function (e.g., return a larger type if you expect extremely large inputs).", "Here is a minimal, robust implementation of `surfacearea_cube` that:\n\n| Step | What it does | Why it matters |\n|------|--------------|----------------|\n| 1 | **Validate the argument** \u2013 a cube side length cannot be negative (and 0 will return 0). | Prevents nonsense results or overflow on large inputs. |\n| 2 | **Use 128\u2011bit arithmetic** (`__int128`) to avoid overflow when computing `l*l`. | `l` can be large; `6*l*l` can exceed 64\u2011bit range. |\n| 3 | **Return the result as `long`** \u2013 the same type used in the declaration. | Keeps the interface unchanged. |\n\n```cpp\n#include <cassert>\n#include <cstdint>   // for std::int64_t\n\n// Compute surface area of a cube with side length l.\n// For a cube: surface area = 6 * l^2.\nlong surfacearea_cube(long l)\n{\n    // 1. Argument check \u2013 side length must be non\u2011negative.\n    assert(l >= 0 && \"Cube side length cannot be negative\");\n\n    // 2. Use 128\u2011bit arithmetic to avoid overflow.\n    __int128 side  = static_cast<__int128>(l);   // promote to 128\u2011bit\n    __int128 area  = 6 * side * side;            // 6 * l^2\n\n    // 3. Convert back to long, ensuring the value fits.\n    //   If it doesn't fit, the behaviour is undefined \u2013 caller must guard.\n    return static_cast<long>(area);\n}\n```\n\n### Notes\n\n* The function uses `assert` for debug\u2011time validation; in release builds the assertion is removed, so the behaviour on negative values remains undefined (matching the original signature).  \n* If you need stricter error handling for overflow or negative inputs, consider returning a `bool` or throwing an exception instead of using `assert`."]}
{"completions": ["Below is a small, self\u2011contained C++ program that includes a function `find_adverbs` which scans the input string, looks for the first word that ends with **\u201cly\u201d**, and returns the word together with its start and end character indices (0\u2011based).  \nThe code also contains a `main` function with a few test cases so you can see it in action.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n *  Find the first adverb that ends with \u201cly\u201d in the given text.\n *\n *  Returns a string in the form:\n *      \"<adverb> <start_index> <end_index>\"\n *  where <start_index> and <end_index> are 0\u2011based positions of the\n *  first and last character of that adverb in the original text.\n *\n *  If no such adverb is found, the function returns an empty string.\n */\nstring find_adverbs(const string &text) {\n    // iterate over every word token in the string\n    size_t i = 0;\n    const size_t n = text.size();\n\n    while (i < n) {\n        // skip any whitespace or punctuation before the token\n        while (i < n && isspace(static_cast<unsigned char>(text[i]))) ++i;\n        if (i >= n) break;\n        const size_t word_start = i;\n\n        // read until we hit whitespace or punctuation\n        while (i < n && !isspace(static_cast<unsigned char>(text[i]))) ++i;\n        const size_t word_end = i;          // one past last character\n\n        if (word_end - word_start < 2) continue;   // too short to end with \"ly\"\n\n        // Check the last two characters of the token (case\u2011sensitively).\n        // If you want a case\u2011insensitive match, convert to lower case\n        // before comparing.\n        if (text[word_end - 2] == 'l' && text[word_end - 1] == 'y') {\n            // Found the first adverb ending in \"ly\".\n            string adverb = text.substr(word_start, word_end - word_start);\n            return adverb + \" \" + to_string(word_start) + \" \" + to_string(word_end - 1);\n        }\n    }\n    // none found\n    return \"\";\n}\n\nint main() {\n    vector<string> tests = {\n        \"He sang beautifully during the concert.\",\n        \"She runs fastly? Actually she runs FASTLY.\",\n        \"No adverbs here.\",\n        \"ally said something.\"\n    };\n\n    for (const auto &t : tests) {\n        string result = find_adverbs(t);\n        if (!result.empty())\n            cout << \"Input: \\\"\" << t << \"\\\"\\n\"\n                 << \"Result: \" << result << \"\\n\\n\";\n        else\n            cout << \"Input: \\\"\" << t << \"\\\"\\n\"\n                 << \"Result: no adverb ending with \\\"ly\\\" found.\\n\\n\";\n    }\n\n    return 0;\n}\n```\n\n**Explanation of the key parts**\n\n1. **Tokenisation** \u2013 The loop moves `i` along the string.  \n   - First it skips any white\u2011space.  \n   - Then it records the start of a word (`word_start`) and moves `i` until the next white\u2011space, giving the word\u2019s end (`word_end`).\n\n2. **Checking the suffix** \u2013 If the token is at least two characters long, we simply look at the last two characters.  \n   - `text[word_end-2] == 'l' && text[word_end-1] == 'y'` finds the exact \u201cly\u201d suffix.  \n   - If you want case\u2011insensitive matching, convert the two chars or the whole word to lowercase before comparing.\n\n3. **Return value** \u2013 The function returns a string containing the adverb followed by its start and end indices (inclusive).  \n   - The end index is `word_end-1` because `word_end` is one past the last character.\n\n4. **Testing** \u2013 The `main` function runs several sample strings and prints either the adverb with its indices or a message saying none was found.\n\nFeel free to drop this function into your project or adapt the output format to match your needs.", "Below is a self\u2011contained, **stand\u2011alone** implementation that satisfies the problem statement:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/**\n * @brief Finds the first adverb ending with \"ly\" in the given text.\n *\n * The function returns a string in the following format:\n *   \"<adverb> <startIndex> <endIndex>\"\n *\n * If no adverb is found, the function returns\n *   \"No adverb found\".\n *\n * The indices are zero\u2011based and count **characters**, not tokens.\n *\n * @param text The input text (can contain spaces, punctuation, etc.).\n * @return A formatted string describing the adverb and its positions.\n */\nstd::string find_adverbs(const std::string &text)\n{\n    // Regex that looks for a word ending with \"ly\".\n    // \\b - word boundary\n    // \\w+ - one or more word characters\n    // ly{2} - two consecutive 'ly' characters\n    static const std::regex re(R\"(\\b(\\w*ly\\w*)\\b)\",\n                               std::regex_constants::icase);\n\n    std::smatch match;\n    if (std::regex_search(text, match, re))\n    {\n        const std::string adverb = match.str(1);\n\n        // `match.position(1)` gives the position of the matched group\n        const size_t start = match.position(1);\n        const size_t end   = start + adverb.size() - 1; // inclusive\n\n        std::ostringstream out;\n        out << adverb << ' ' << start << ' ' << end;\n        return out.str();\n    }\n\n    return \"No adverb found\";\n}\n\n/* ----------  Test harness (not required for the judge)  ---------- */\n#ifdef RUN_TESTS\nint main()\n{\n    const vector<string> tests = {\n        \"She runs quickly and silently.\",\n        \"He walked slowly.\",\n        \"No adverb here.\",\n        \"Tightly, tightly, and tightly again.\"\n    };\n\n    for (const auto &s : tests) {\n        cout << '\"' << s << \"\\\" --> \" << find_adverbs(s) << '\\n';\n    }\n    return 0;\n}\n#endif\n```\n\n### How it works\n\n1. **Regex**  \n   We compile a regex that matches any word ending with `ly` (`\\b(\\w*ly\\w*)\\b`).  \n   `\\b` ensures we match whole words, `(\\w*ly\\w*)` captures the full word containing `ly`.\n\n2. **Search**  \n   `std::regex_search` scans the input string and returns the first match.\n\n3. **Positions**  \n   `match.position(1)` gives the zero\u2011based index of the first character of the captured group, and adding its length minus one yields the end index.\n\n4. **Output format**  \n   The function returns `\"adverb start end\"`.  \n   If the regex finds nothing, it returns the error message `\"No adverb found\"`.\n\nFeel free to drop the `#ifdef RUN_TESTS` block when submitting the function to a judge that only expects the `find_adverbs` function.", "Here is a small, self\u2011contained implementation that scans a string for the first word that ends with \"`ly`\" (case\u2011insensitive).  \nThe function returns a string describing the found adverb, its position (zero\u2011based index of the first character of the adverb) and the length of the word.  \nIf no adverb is found the function returns `\"No adverb found\"`.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// -----------------------------------------------------------------------------\n// Helper: return true if a string ends with \"ly\" (case\u2011insensitive)\n// -----------------------------------------------------------------------------\nstatic bool endsWithLy(const string &word)\n{\n    if (word.size() < 2) return false;\n    string suf = word.substr(word.size() - 2);\n    for (auto &c : suf) c = tolower(static_cast<unsigned char>(c));\n    return suf == \"ly\";\n}\n\n// -----------------------------------------------------------------------------\n// Main function\n// -----------------------------------------------------------------------------\nstd::string find_adverbs(std::string text)\n{\n    // Scan character by character, recording the start of each word\n    size_t i = 0;\n    const size_t n = text.size();\n\n    while (i < n)\n    {\n        // Skip any non\u2011alphabetic characters\n        while (i < n && !isalpha(static_cast<unsigned char>(text[i]))) ++i;\n        if (i >= n) break;\n\n        // Now i points to the first character of a word\n        size_t start = i;\n        while (i < n && isalpha(static_cast<unsigned char>(text[i]))) ++i;\n        size_t end = i;                       // one past the last char\n\n        string word = text.substr(start, end - start);\n        if (endsWithLy(word))\n        {\n            // Build the result: adverb, its start index, and its length\n            ostringstream oss;\n            oss << \"Adverb \\\"\" << word << \"\\\" found at position \" << start\n                << \" (length \" << word.size() << \")\";\n            return oss.str();\n        }\n    }\n\n    return \"No adverb found\";\n}\n\n// -----------------------------------------------------------------------------\n// Example usage (you can remove this in your own code)\n// -----------------------------------------------------------------------------\nint main()\n{\n    string s = \"She walked calmly along the shore, laughing loudly at the waves.\";\n    cout << find_adverbs(s) << '\\n';\n    return 0;\n}\n```\n\n**Explanation of the key steps**\n\n1. **Skipping separators** \u2013 Non\u2011alphabetic characters are treated as word separators.  \n2. **Word extraction** \u2013 Once the start of a word is found, read until the next separator to obtain the full word.  \n3. **Adverb check** \u2013 Function `endsWithLy` lowers the last two characters of the word and compares them to `\"ly\"`.  \n4. **Result formatting** \u2013 When the first adverb is found, we report the word, its starting index (zero\u2011based), and its length; otherwise we report that none was found.  \n\nFeel free to adjust the function signature or output format to match your project\u2019s conventions."]}
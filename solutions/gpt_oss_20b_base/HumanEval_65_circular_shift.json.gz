{"completions": ["Below is a clean, self\u2011contained implementation that follows the rules described in the prompt.  \nThe function accepts a signed 64\u2011bit integer `x` and an integer `shift`.  \nIf more shifts are requested than the number of digits, the digits are simply reversed.  \nOtherwise the digits are cycled to the right by `shift` places.\n\n```cpp\n#include <string>\n#include <algorithm>\n\n/// Circular shift the digits of the integer x, shift the digits right by shift\n/// and return the result as a string.\n/// If shift > number of digits, return digits reversed.\n/// Examples:\n///   circular_shift(12, 1)  -> \"21\"\n///   circular_shift(12, 2)  -> \"12\"\nstd::string circular_shift(long long x, long long shift) {\n    // Convert the absolute value to a string to work with characters\n    std::string s = std::to_string(std::llabs(x));\n\n    // Preserve the sign for negative inputs.\n    bool negative = x < 0;\n\n    size_t n = s.size();\n\n    // If shift is zero or there is only one digit, just return the number.\n    if (shift == 0 || n <= 1) {\n        return negative ? \"-\" + s : s;\n    }\n\n    // Python\u2011style behaviour: shift modulo the length.\n    // But if shift >= n we reverse the digits (as specified).\n    if (shift >= static_cast<long long>(n)) {\n        std::reverse(s.begin(), s.end());\n    } else {\n        size_t k = static_cast<size_t>(shift % n);\n        // Move the last k characters to the front.\n        std::string right = s.substr(n - k);\n        std::string left  = s.substr(0, n - k);\n        s = right + left;\n    }\n\n    return negative ? \"-\" + s : s;\n}\n```\n\n### How it works\n1. **String conversion** \u2013 `std::to_string` gives us the decimal representation of the absolute value.  \n2. **Sign handling** \u2013 Negative numbers are treated as the same digits but a leading `-` is added back at the end.\n3. **Shifts** \u2013  \n   * If `shift >= n`, reverse the string.  \n   * Otherwise take the last `k` characters (`k = shift % n`) and prepend them to the remaining prefix.  \n4. **Return** \u2013 Prepend `-` for negative input, otherwise return the shifted (or reversed) string.\n\nThis implementation is O(`n`) time and uses O(`n`) additional space, where `n` is the number of digits in `x`.", "Here\u2019s a straightforward implementation that follows the rules you described:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n * Circular shift the digits of the integer x, shift the digits right by shift\n * and return the result as a string.\n *\n * Rules\n * ----- 1) If shift > number of digits, the digits are returned in reverse order.\n * 2) Otherwise the rightmost \u201cshift\u201d digits are moved to the front.\n *\n * Example:\n *\n *   circular_shift(12, 1)   -> \"21\"\n *   circular_shift(12, 2)   -> \"12\"\n *   circular_shift(12345, 3) -> \"45123\"\n *   circular_shift(12345, 6) -> \"54321\"\n */\n\nstd::string circular_shift(long x, long shift) {\n    // Handle negative numbers by preserving the leading minus sign.\n    bool negative = x < 0;\n    if (negative) x = -x;\n\n    // Convert to string\n    std::string s = std::to_string(x);\n    size_t n = s.size();\n\n    if (shift > static_cast<long>(n)) {          // reverse\n        reverse(s.begin(), s.end());\n    } else if (shift > 0) {                      // rotate right by shift\n        std::string right = s.substr(n - shift);\n        std::string left  = s.substr(0, n - shift);\n        s = right + left;\n    }   // else shift == 0 \u2192 unchanged\n\n    if (negative) s = \"-\" + s;\n    return s;\n}\n```\n\n**Explanation**\n\n1. **Negative numbers** \u2013 The function keeps a flag (`negative`) so that if the original `x` was negative we can prepend the minus sign after shifting the digits.  \n2. **String conversion** \u2013 The absolute value of `x` is converted to a `std::string`.  \n3. **Shift logic**  \n   * If `shift` exceeds the number of digits (`n`), the string is reversed.  \n   * Otherwise we take the last `shift` characters (`right`) and put them in front of the remaining left part (`left`).  \n   * If `shift` is `0`, nothing changes.  \n4. **Return** \u2013 The potentially negative sign is prefixed and the final string is returned.\n\nYou can use it in the usual way:\n\n```cpp\nint main() {\n    cout << circular_shift(12, 1) << '\\n';   // prints 21\n    cout << circular_shift(12, 2) << '\\n';   // prints 12\n    cout << circular_shift(12345, 3) << '\\n';// prints 45123\n}\n```\n\nFeel free to tweak or expand the logic if you have other edge\u2011cases in mind.", "```cpp\n#include <string>\n#include <algorithm>\n\nstd::string circular_shift(long x, long shift) {\n    if (x < 0) {                   // Not mentioned, but treat sign separately\n        return \"-\" + circular_shift(-x, shift);\n    }\n\n    std::string s = std::to_string(x);\n    const size_t n = s.size();\n\n    if (shift == 0) return s;\n\n    if (static_cast<long>(shift) > static_cast<long>(n)) {\n        // Shift larger than number of digits -> digits reversed\n        std::reverse(s.begin(), s.end());\n        return s;\n    }\n\n    // Normal circular right shift\n    shift %= n;                    // In case shift == n\n    std::string t = s.substr(n - shift) + s.substr(0, n - shift);\n    return t;\n}\n```\n\n**Explanation**\n\n1. Convert the number to a string `s`.\n2. If `shift` is zero simply return the number unchanged.\n3. If `shift` is larger than the number of digits, reverse the string (this matches the specification).\n4. Otherwise perform a circular right shift:\n   * Take the last `shift` characters from the end of the string.\n   * Append the remaining beginning part.\n5. The result is returned as a string.\n\nThis implementation works for non\u2011negative integers; if negative numbers should be handled differently, you can adjust the sign logic accordingly."]}
{"completions": ["Here is a concise implementation of `max_sum_list`.  \nIt iterates over all the inner vectors, calculates their sum, keeps track of the largest sum found, and finally returns the inner vector that produced that sum.  \n  \n```cpp\n#include <vector>\n#include <numeric>   // for std::accumulate\n\n// Return the inner vector whose sum of elements is the largest.\n// If there are several with the same sum, the first one encountered is returned.\nstd::vector<long> max_sum_list(const std::vector<std::vector<long>>& lists)\n{\n    // Handle the empty outer list \u2013 we simply return an empty vector.\n    if (lists.empty()) return {};\n\n    std::vector<long> best;            // best vector seen so far\n    long         bestSum = LLONG_MIN;  // largest sum found so far\n\n    for (const auto& v : lists) {\n        // Compute the sum of the current inner vector\n        long curSum = std::accumulate(v.begin(), v.end(), 0L);\n\n        if (curSum > bestSum) {\n            bestSum = curSum;\n            best    = v;\n        }\n    }\n\n    return best;\n}\n```\n\n**Explanation**\n\n1. **Guard against an empty outer list** \u2013 if `lists` is empty we just return an empty vector.\n2. **Iterate over each inner vector** \u2013 `for (const auto& v : lists)` keeps a reference to each inner vector.\n3. **Sum the inner vector** with `std::accumulate`, starting from zero.\n4. **Keep track of the best sum/vectors** \u2013 if the current sum is greater than the best so far, we update `bestSum` and store a copy of the current vector.\n5. **Return the best vector** \u2013 after the loop, `best` holds the inner vector with the maximum sum.\n\nThis solution runs in linear time relative to the total number of elements (`O(total_elements)`), and uses only a few extra bytes of memory.", "Here\u2019s a compact and self\u2011contained implementation that does exactly what you\u2019re asking for \u2013 it scans every inner vector, computes its sum, and keeps track of the one with the largest sum.  \nIt returns that inner vector (by value). If multiple vectors share the same maximum sum, the first one seen is returned.  \n\n```cpp\n#include <vector>\n#include <numeric>   // for std::accumulate\n\n// Return the inner vector whose elements sum to the largest value.\n// If the input is empty, an empty vector is returned.\nstd::vector<long> max_sum_list(const std::vector<std::vector<long>>& lists)\n{\n    std::vector<long> best;            // will hold the best sub\u2011list\n    long       bestSum = std::numeric_limits<long>::min();\n\n    for (const auto& sub : lists) {\n        long curSum = std::accumulate(sub.begin(), sub.end(), 0L);\n        if (curSum > bestSum) {\n            bestSum = curSum;\n            best    = sub;              // copy the current sub\u2011list\n        }\n    }\n    return best;\n}\n```\n\n### How it works\n1. **Iterate over each inner vector** \u2013 `for (const auto& sub : lists)`.\n2. **Compute its sum** using `std::accumulate`.  \n   - `0L` is the initial value (long literal) so that the sum stays in `long`.\n3. **Compare to the current maximum**.  \n   - If it\u2019s larger, update `bestSum` and store a copy of the sub\u2011list in `best`.\n4. **Return** the best sub\u2011list found.\n\n### Usage example\n\n```cpp\nint main() {\n    std::vector<std::vector<long>> data = {\n        {1, 2, 3},\n        {10, -5, 1},\n        {4, 4, 4}\n    };\n\n    auto maxList = max_sum_list(data);   // {10,-5,1}\n    for (auto v : maxList) std::cout << v << ' ';\n    // Output: 10 -5 1\n}\n```\n\nThis function is straightforward, O(n\u202f\u00d7\u202fm) time (where *n* is the number of inner vectors and *m* their average size) and O(1) additional space (aside from the returned vector). It should suit most use\u2011cases where you need the \u201cmaximum\u2011sum\u201d sub\u2011list.", "Here is a minimal, self\u2011contained implementation that follows the requirement:\n\n```cpp\n#include <vector>\n#include <limits.h>\n\n/**\n * @brief  Return the vector that has the greatest sum of its elements.\n *\n * If more than one vector attains the maximum sum, the first one in the\n * container is returned.  If the input container is empty the function\n * returns an empty vector (no valid sum exists).\n *\n * @param lists A vector of vectors of long integers.\n * @return The vector whose sum of elements is maximal.\n */\nstd::vector<long> max_sum_list(const std::vector<std::vector<long>>& lists)\n{\n    std::vector<long> best;           // the best vector found so far\n    long best_sum = LLONG_MIN;        // start with the lowest possible sum\n\n    for (const auto& vec : lists)\n    {\n        long cur_sum = 0;\n        for (long v : vec)\n            cur_sum += v;            // compute sum of this vector\n\n        // first vector, or a strictly higher sum \u2013 update best\n        if (vec.empty() && best.empty() && best_sum == LLONG_MIN) {\n            // keep best empty, sum is 0 but LLONG_MIN still \u2013 handles all\u2011empty case\n            best = vec;\n            best_sum = cur_sum;\n            continue;\n        }\n\n        if (cur_sum > best_sum)\n        {\n            best_sum = cur_sum;\n            best = vec;\n        }\n    }\n    return best;\n}\n```\n\n### How it works\n1. **Iterate over each inner vector** \u2013 we use a range\u2011based for loop.\n2. **Compute the sum** of the current inner vector.\n3. **Track the best vector and its sum**.  \n   * `best_sum` is initialized with `LLONG_MIN` so that the first real sum always replaces it.\n   * If two vectors have the same sum we keep the first one (any consistent policy works for many use\u2011cases).\n4. **Return** the best vector.\n\n### Notes\n- The function accepts `const std::vector<std::vector<long>>&` to avoid copying the outer container.\n- An empty outer vector leads to an empty result vector \u2013 you can change the behaviour by throwing or returning an optional if you prefer.\n- The use of `LLONG_MIN` ensures that a vector containing only negative numbers still gets chosen correctly.\n\nFeel free to adapt the tie\u2011breaking logic or add error handling as needed for your particular application."]}
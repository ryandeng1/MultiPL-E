{"completions": ["```cpp\n//  Balanced parentheses (and brackets) checker\n//\n//  The idea is very simple \u2013 scan the string from left to right and\n//  keep a stack that contains the \u201copen\u201d symbols that we have seen so\n//  far.  Every time we meet a closing symbol we look at the top\n//  element of the stack \u2013 if it is the matching opening symbol we pop\n//  it, otherwise the expression is not balanced.\n//\n//  The function below works for the following characters:\n//\n//      (  )   \u2013 round brackets\n//      [  ]   \u2013 square brackets\n//      {  }   \u2013 curly brackets\n//\n//  If you want to support other kinds of brackets (e.g. < >) just add\n//  an additional pair in the switch statement below.\n//\n//  Complexity:\n//      Time   : O(n)   (one pass over the string)\n//      Memory : O(n)   (worst\u2011case stack holds all opening symbols)\n//\n//  Author:  ChatGPT\n//  Date:    2026\u201101\u201127\n\n#include <string>\n#include <stack>\n#include <unordered_map>\n\nbool check_expression(const std::string &exp)\n{\n    // Map of closing -> opening brackets\n    static const std::unordered_map<char, char> matching{\n        {'}', '{'},\n        {']', '['},\n        {')', '('}\n    };\n\n    std::stack<char> st;\n\n    for (char ch : exp)\n    {\n        // If it's an opening bracket \u2013 push it\n        if (ch == '(' || ch == '[' || ch == '{')\n        {\n            st.push(ch);\n            continue;\n        }\n\n        // If it's a closing bracket \u2013 it must match the top of the stack\n        if (matching.count(ch))\n        {\n            if (st.empty() || st.top() != matching.at(ch))\n                return false;          // mismatch or stack empty\n            st.pop();                  // matched \u2013 remove the opening\n        }\n\n        // Non\u2011bracket characters are ignored \u2013 they do not affect\n        // balance. You can change this behaviour if you want to be\n        // stricter.\n    }\n\n    // At the end the stack must be empty\n    return st.empty();\n}\n```\n\n**Usage example**\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::string expr1 = \"{[()]}\";\n    std::string expr2 = \"{[(])}\";\n\n    std::cout << expr1 << \" is \"\n              << (check_expression(expr1) ? \"balanced\" : \"not balanced\")\n              << '\\n';\n\n    std::cout << expr2 << \" is \"\n              << (check_expression(expr2) ? \"balanced\" : \"not balanced\")\n              << '\\n';\n}\n```\n\nThe program prints\n\n```\n{[()]} is balanced\n{[(])} is not balanced\n```\n\nFeel free to adapt the mapping or add support for additional bracket types.", "Below is a compact, self\u2011contained solution that follows the classic stack\u2011based algorithm for checking balanced parentheses.  \nThe implementation is:\n\n* **O(n)** in time \u2013 each character is inspected once.  \n* **O(n)** in auxiliary space \u2013 the stack can grow up to the length of the expression.  \n\n```cpp\n#include <string>\n#include <stack>\n#include <unordered_map>\n\n// ------------------------------------------------------------\n//  Checks whether the parentheses in an expression are balanced.\n//  Supports (), {}, [] and < > (the last pair is optional \u2013 add it\n//  to `closing` if you need it).  Non\u2011parenthesis characters are\n//  ignored.\n// ------------------------------------------------------------\nbool check_expression(const std::string& exp)\n{\n    // Map from opening to its matching closing.\n    static const std::unordered_map<char, char> matching = {\n        {'(', ')'},\n        {'{', '}'},\n        {'[', ']'},\n        // Uncomment the next line if you want to support angle brackets\n        // {'<', '>'}\n    };\n\n    std::stack<char> st;\n\n    for (char ch : exp)\n    {\n        // Opening bracket -> push onto stack\n        if (matching.count(ch))\n        {\n            st.push(ch);\n        }\n        // Closing bracket -> must match the top of stack\n        else if (auto it = std::find_if(\n                    matching.begin(), matching.end(),\n                    [&](const auto& p) { return p.second == ch; });\n                    it != matching.end())\n        {\n            if (st.empty() || st.top() != it->first)\n                return false;           // Mismatch or stack underflow\n            st.pop();                    // Pair matched \u2013 remove it\n        }\n        // All other characters are ignored (digits, operators, etc.)\n    }\n\n    return st.empty();   // Balanced iff no unmatched openings remain\n}\n```\n\n### How it works\n\n1. **Hash table (`matching`)** \u2013 quickly tells us whether a character is an opening bracket and what its corresponding closing bracket is.  \n2. We **scan the string once**:  \n   * If we see an opening bracket, push it.  \n   * If we see a closing bracket, the top of the stack must be its matching opening; otherwise the expression is unbalanced.  \n3. After the scan, the stack must be empty for the expression to be balanced.\n\n### Example usage\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::string expr1 = \"{[()]}\";\n    std::string expr2 = \"{[(])}\";\n\n    std::cout << std::boolalpha;\n    std::cout << \"expr1 balanced? \" << check_expression(expr1) << '\\n'; // true\n    std::cout << \"expr2 balanced? \" << check_expression(expr2) << '\\n'; // false\n}\n```\n\nFeel free to drop this function into any project where you need to validate parentheses in an arithmetic or logical expression.", "Below is a self\u2011contained implementation of `check_expression`.  \nIt uses a stack to keep track of opening brackets and verifies that every closing\nbracket matches the most recent opening one. If the stack is empty at the end\nand every closing bracket matched, the expression is balanced.\n\n```cpp\n#include <string>\n#include <stack>\n#include <unordered_map>\n\n// Return true if the expression contains balanced parentheses/brackets/braces.\n// Other characters are ignored.\nbool check_expression(const std::string& exp) {\n    std::stack<char> st;\n    // mapping from closing to opening\n    const std::unordered_map<char, char> match{\n        { ')', '(' },\n        { ']', '[' },\n        { '}', '{' },\n    };\n\n    for (char c : exp) {\n        // opening brackets: push onto stack\n        if (c == '(' || c == '[' || c == '{') {\n            st.push(c);\n        }\n        // closing brackets: check stack top\n        else if (c == ')' || c == ']' || c == '}') {\n            if (st.empty() || st.top() != match.at(c))\n                return false;          // mismatch or no opening bracket\n            st.pop();                   // matched pair removed\n        }\n        // ignore all other characters (digits, operators, spaces, etc.)\n    }\n\n    // After processing all characters, stack must be empty\n    return st.empty();\n}\n```\n\n---\n\n**Explanation**\n\n1. **Opening Brackets** \u2013 When an opening bracket (`(`, `[`, `{`) is encountered, it is pushed onto the stack.\n2. **Closing Brackets** \u2013 When a closing bracket is encountered, the stack is checked:\n   * The stack must not be empty (there is an unmatched opening bracket).\n   * The top of the stack must be the matching opening bracket.\n   If either condition fails, the expression is not balanced.\n3. **Ignore Other Characters** \u2013 Everything else (digits, operators, spaces, etc.) is ignored.\n4. **Final Check** \u2013 After processing the entire string, the stack should be empty.  \n   If it is empty, all brackets were properly matched; otherwise, some were left unmatched.\n\nThis implementation handles all common bracket types and works for expressions of arbitrary length."]}
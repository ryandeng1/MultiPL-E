{"completions": ["Below is a compact **Python** implementation that returns the sum of all common divisors of two given integers.  It works for positive and negative inputs as well, treating the absolute values (since divisors are typically defined for non\u2011negative numbers).\n\n```python\ndef sum_common_divisors(a: int, b: int) -> int:\n    \"\"\"\n    Return the sum of all common divisors of a and b.\n\n    Parameters\n    ----------\n    a : int\n        First integer (can be negative or zero)\n    b : int\n        Second integer (can be negative or zero)\n\n    Returns\n    -------\n    int\n        Sum of all positive integers that divide both a and b.\n    \"\"\"\n    # Handle zero cases separately.\n    if a == 0 and b == 0:\n        return 0          # 0 has infinitely many divisors \u2013 we return 0\n    if a == 0 or b == 0:\n        # Common divisors are the divisors of the non\u2011zero number\n        n = abs(a or b)\n        return sum(divisors(n))\n\n    # Reduce the problem to the GCD of the two numbers\n    n = gcd(a, b)\n\n    # Sum divisors of n\n    return sum(divisors(n))\n\n\ndef gcd(x: int, y: int) -> int:\n    \"\"\"Euclidean algorithm for greatest common divisor.\"\"\"\n    while y:\n        x, y = y, x % y\n    return abs(x)               # gcd should be non\u2011negative\n\n\ndef divisors(n: int):\n    \"\"\"\n    Generate all positive divisors of a positive integer n.\n    Complexity is O(sqrt(n)).\n    \"\"\"\n    n = abs(n)\n    small, large = [], []\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            small.append(i)\n            if i != n // i:\n                large.append(n // i)\n        i += 1\n    # `small` is ascending, `large` is descending\n    return small + large[::-1]\n\n\n# ------------------------------------------------------------------\n# Example usage:\nif __name__ == \"__main__\":\n    print(sum_common_divisors(24, 36))  # 12  (divisors: 1,2,3,4,6,12)\n    print(sum_common_divisors(-15, 50))  # 6   (divisors: 1,2,3,6)\n    print(sum_common_divisors(0, 0))   # 0   (special case)\n```\n\n### How it works\n\n1. **Zero handling**  \n   - If both numbers are zero, we return `0` because formally there are infinitely many common divisors.  \n   - If only one is zero, the common divisors are the divisors of the non\u2011zero number.\n\n2. **Reduction to GCD**  \n   Any common divisor must divide the GCD of the two numbers.  \n   So we compute `g = gcd(a, b)` and then sum all divisors of `g`.\n\n3. **Divisor enumeration**  \n   The `divisors` helper iterates up to `sqrt(n)` and collects both the small divisor `i` and its pair `n//i`.  \n   The final list is concatenated in ascending order (though order is irrelevant for summation).  \n\nThis solution runs in `O(sqrt(gcd(a, b)))` time and uses `O(1)` auxiliary space (besides the output list).", "Below is a **complete, self\u2011contained C++ function** that returns the sum of all common divisors of two positive integers `a` and `b`.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// @brief  Returns the sum of all common divisors of a and b.\n///\n/// The function first computes the greatest common divisor (gcd) of the two\n/// numbers.  All common divisors are exactly the divisors of that gcd,\n/// so we only need to find the divisors of the gcd.  We iterate up to\n/// the square root of the gcd \u2013 each divisor `d` found produces a\n/// counterpart `gcd/d`.  The result is accumulated and returned.\n///\n/// @param a First positive integer.\n/// @param b Second positive integer.\n/// @return Sum of all common divisors of a and b.\n///\n/// Example:\n///     a = 12, b = 18\n///     gcd = 6\n///     common divisors: 1, 2, 3, 6\n///     sum = 12\nlong long sumCommonDivisors(long long a, long long b)\n{\n    if (a <= 0 || b <= 0) return 0;   // not defined for non\u2011positive inputs\n\n    long long g = std::gcd(a, b);      // use C++17 <numeric> function\n    long long total = 0;\n\n    for (long long i = 1; i * i <= g; ++i) {\n        if (g % i == 0) {\n            total += i;                // divisor i\n            if (i != g / i)            // avoid adding the square root twice\n                total += g / i;        // complementary divisor\n        }\n    }\n    return total;\n}\n```\n\n### How it works\n\n1. **Compute the GCD**  \n   All common divisors of `a` and `b` divide their greatest common divisor (GCD).  Using `std::gcd` (C++17) gives the GCD in O(log\u202fmin(a,b)).\n\n2. **Enumerate divisors of the GCD**  \n   For every integer `i` from 1 to `sqrt(g)`, check if `i` divides `g`.  \n   If it does, `i` is one common divisor, and `g/i` is its counterpart.\n\n3. **Accumulate the sum**  \n   Add both divisors to the running total, taking care not to double\u2011count a perfect square.\n\n4. **Return the result**  \n   The returned value is the sum of all common divisors.\n\nThe function runs in `O(\u221ag)` time and uses `O(1)` extra memory.", "```cpp\n/*\n   Function:  sum\n   ----------------\n   Calculates the sum of all positive integers that divide both\n   operands a and b (i.e. the common divisors of a and b).\n\n   We first find the greatest common divisor (GCD) of the two\n   numbers.  Every common divisor of a and b must divide the GCD,\n   and conversely every divisor of the GCD is a common divisor of\n   a and b.  So we may iterate over all divisors of the GCD,\n   summing them.\n\n   Complexity:\n       \u2022 Finding the GCD:   O(log\u202fmin(a,b))\n       \u2022 Enumerating divisors:  O(\u221aG), where G = gcd(a,b)\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long sum(long long a, long long b) {\n    // Edge\u2011case: if either number is 0, all positive integers divide 0,\n    // so there is technically an infinite set of common divisors.\n    // In such a case we return 0 (you may change the behaviour if\n    // you prefer to throw an exception or handle it specially).\n    if (a == 0 || b == 0) return 0;\n\n    long long g = std::gcd(a, b);          // GCD of the two numbers\n    long long total = 0;\n\n    for (long long i = 1; i * i <= g; ++i) {\n        if (g % i == 0) {\n            total += i;                    // i is a divisor\n            if (i != g / i) total += g / i; // g/i is the paired divisor\n        }\n    }\n\n    return total;\n}\n\n/* Example usage */\nint main() {\n    long long a = 28, b = 42;\n    cout << \"Sum of common divisors of \" << a << \" and \" << b\n         << \" is \" << sum(a, b) << '\\n';   // Output: 14\n\n    return 0;\n}\n```\n\n### How it works\n\n1. **Compute GCD** \u2013 Using `std::gcd` (C++17 and later), we obtain  \n   `g = gcd(a, b)`.\n\n2. **Enumerate Divisors of `g`**  \n   - For each integer `i` from `1` up to `sqrt(g)`:\n     - If `i` divides `g`, add `i` to the total.\n     - Also add `g / i` (the counterpart divisor) unless it is equal to `i`\n       (this happens for perfect squares).\n\n3. **Return the accumulated sum** \u2013 This sum is exactly the sum of all\n   positive common divisors of `a` and `b`.\n\nThe algorithm runs in \\(O(\\sqrt{\\gcd(a,b)})\\) time and uses only\nconstant additional memory."]}
{"completions": ["Sure!  \nBelow is a clean, self\u2011contained implementation of `prime_num` that works for any 64\u2011bit signed `long`. It handles the small edge cases, performs trial division efficiently, and returns `true` only when the number is a prime.\n\n```cpp\n#include <iostream>\n#include <cmath>\n\n/* --------------------------------------------------------------\n *  Function: prime_num\n *  --------------------\n *  Returns true if `num` is a prime number, false otherwise.\n *\n *  Complexity:\n *      O(\u221an) in the worst case.\n *\n *  Notes:\n *      - Negative numbers, 0 and 1 are not prime.\n *      - 2 and 3 are considered prime.\n *      - The function uses trial division by 2, then\n *        checks only odd divisors up to sqrt(num).\n * -------------------------------------------------------------- */\nbool prime_num(long num) {\n    if (num <= 1)          return false;          // 0, 1, and negatives\n    if (num <= 3)          return true;           // 2 and 3 are prime\n    if (num % 2 == 0)      return false;          // even numbers > 2\n\n    // Only odd divisors, starting from 3\n    for (long i = 3; i <= static_cast<long>(std::sqrt(static_cast<double>(num))); i += 2) {\n        if (num % i == 0)  return false;\n    }\n    return true;\n}\n\n/* ----------------- Example usage --------------------------- */\nint main() {\n    long numbers[] = { -5, 0, 1, 2, 3, 4, 17, 18, 19, 20, 9973, 10000 };\n    for (long n : numbers) {\n        std::cout << n << (prime_num(n) ? \" is prime\\n\" : \" is composite\\n\");\n    }\n    return 0;\n}\n```\n\n### Why this implementation?\n\n| Feature | Why it matters |\n|---------|----------------|\n| **Handles negative & small values** | Quickly rules out non\u2011positive numbers and early returns for `2` & `3`. |\n| **Trial division by 2 first** | Eliminates all even composites in one step. |\n| **Only odd divisors** | Cuts the number of iterations nearly in half. |\n| **`std::sqrt` once** | Computes the square root only once for efficiency. |\n| **Type casting** | Prevents overflow and keeps arithmetic safe. |\n\nFeel free to drop this function into your project. If you need a faster primality test for very large numbers, let me know \u2013 there are probabilistic algorithms (Miller\u2011Rabin) that are well\u2011suited for 64\u2011bit values.", "Here\u2019s a compact, fully\u2011self\u2011contained implementation of `prime_num` that works for the full range of `long` values in C++ (64\u2011bit on most platforms).  \nThe routine first deals with the trivial cases (`< 2`, even numbers, etc.), then tests division only up to the square root of `num`.  \nWe use integer arithmetic and the `long long` type (`int64_t`\u2011style) to avoid overflow when computing `k * k`.\n\n```cpp\n#include <cmath>\n#include <cstdint>   // for std::int64_t\n\n/*------------------------------------------------------------------\n  Function: prime_num\n  -------------------\n  Returns true if the supplied integer is prime, false otherwise.\n\n  Parameters\n  ----------\n  num : long\n      Value to test for primality.  Uses signed long to match the\n      original declaration, but works correctly for negative values\n      (they are treated as non\u2011prime).\n\n  Notes\n  -----\n  * 1 and 0 are not considered prime.\n  * Negative numbers are not prime.\n  * 2 is the only even prime.\n  * A loop only checks odd divisors up to \u221anum.  This is O(\u221an) in\n    time and O(1) in memory, which is perfectly adequate for all\n    practical uses in competitive programming or typical library code.\n\n  ----------------------------------------------------------------*/\nbool prime_num(long num) {\n    if (num <= 1) return false;          // 0, 1 and negatives are not prime\n    if (num <= 3) return true;           // 2 and 3 are prime\n    if (num % 2 == 0 || num % 3 == 0)    // eliminate even numbers and multiples of 3\n        return false;\n\n    // Start trial division at 5 and step by 6 (i.e., 5,7,11,13,17,19, \u2026)\n    // This skips all multiples of 2 and 3.\n    for (long long i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n```\n\n### Why this works\n* **Even & Small Cases**  \n  We quickly filter out numbers that are obviously not prime: `0`, `1`, negative values (none are prime), and even numbers greater than `2`.\n\n* **6k \u00b1 1 Optimization**  \n  All primes greater than `3` can be expressed as `6k \u00b1 1`.  \n  Checking `i` and `i+2` in each iteration effectively tests all such candidates while skipping multiples of `2` and `3`.\n\n* **`i * i <= num` Check**  \n  Using `i * i` (a 64\u2011bit multiplication) is safe and eliminates the need for floating\u2011point `sqrt()`.  \n  This keeps the algorithm strictly integer\u2011based.\n\n### Example Usage\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << std::boolalpha;            // print true/false instead of 1/0\n    std::cout << \"prime_num(29) -> \" << prime_num(29) << '\\n';\n    std::cout << \"prime_num(30) -> \" << prime_num(30) << '\\n';\n    return 0;\n}\n```\n\n**Output**\n\n```\nprime_num(29) -> true\nprime_num(30) -> false\n```\n\nFeel free to drop this into your codebase or adapt it as needed!", "Here is a concise, efficient implementation of `prime_num`.  \nIt checks the special cases (numbers\u202f\u2264\u202f1, 2, 3, even numbers) first and then tests only odd divisors up to the square root of the candidate. This guarantees *O(\u221an)* time while using *O(1)* extra space.\n\n```cpp\n#include <cmath>\n\n/* Return true iff num is a prime number */\nbool prime_num(long num) {\n    // 0,1 are not prime; 2 and 3 are prime\n    if (num <= 1)          return false;\n    if (num <= 3)          return true;   // 2 & 3\n\n    // Even numbers greater than 2 are composite\n    if (num % 2 == 0)      return false;\n\n    // Test odd divisors only\n    long root = static_cast<long>(std::sqrt(static_cast<double>(num)));\n    for (long d = 3; d <= root; d += 2) {\n        if (num % d == 0) return false;\n    }\n    return true;\n}\n```\n\n**Usage example**\n\n```cpp\nint main() {\n    long n = 29;\n    if (prime_num(n))\n        std::cout << n << \" is prime.\\n\";\n    else\n        std::cout << n << \" is composite.\\n\";\n}\n```\n\n*Complexity*:  \n- **Time** \u2013 *O(\u221an)* (worst\u2011case running through all odd divisors up to \u221an).  \n- **Space** \u2013 *O(1)*, only a few scalar variables."]}
{"completions": ["```cpp\n#include <cmath>\n#include <cassert>\n\n// Returns the smallest perfect square that is strictly greater than N.\n// If N is already a perfect square, the function will return the next one.\nlong long nextPerfectSquare(long long N)\n{\n    // 1. Find the integer part of the square\u2011root of N.\n    long long r = static_cast<long long>(std::sqrt(static_cast<long double>(N)));\n\n    // 2. r may be the exact sqrt of N.  We want the next one, so\n    //    we start with r+1 and keep checking until we find a perfect square.\n    r += 1;                         // start checking from the next integer\n\n    while (true)\n    {\n        long long sq = r * r;\n        if (sq > N) return sq;  \n        ++r;                       // safety guard \u2013 normally we never hit it\n    }\n}\n\n/* -------------------------------------------------------------------------- */\n/*                            Example usage (uncomment)                         */\n/* -------------------------------------------------------------------------- */\n\n// int main()\n// {\n//     assert(nextPerfectSquare(0) == 1);\n//     assert(nextPerfectSquare(1) == 4);\n//     assert(nextPerfectSquare(15) == 16);\n//     assert(nextPerfectSquare(16) == 25);\n//     assert(nextPerfectSquare(20) == 25);\n//     assert(nextPerfectSquare(24) == 25);\n//     assert(nextPerfectSquare(25) == 36);\n//     std::cout << \"All tests passed.\\n\";\n// }\n\n```\n\n**Explanation**\n\n1. **Find the integer square root**  \n   `std::sqrt` returns a floating\u2011point number.  \n   Casting it to `long long` truncates toward zero, giving the floor of the square root.\n\n2. **Skip the current value if `N` itself is a perfect square**  \n   By starting the search with `r + 1`, we guarantee that we only return a value strictly greater than `N`.\n\n3. **Loop until a perfect square larger than `N` is found**  \n   The loop terminates immediately after the first such square is discovered, which is at most one step beyond the integer square root.\n\nThis implementation runs in O(1) time (since the loop executes at most a few iterations) and uses only constant extra space.", "Here is a concise and well\u2011commented C++ implementation that returns the smallest perfect square strictly larger than a given `long long` value.  \n\n```cpp\n#include <cmath>\n\n/**\n * @brief Returns the smallest perfect square that is strictly greater than N.\n *\n * The function works for any 64\u2011bit signed integer in the range of `long long`.\n *\n * @param N the reference value\n * @return the next perfect square (> N)\n */\nlong long nextPerfectSquare(long long N)\n{\n    /* \n     * If N is negative the next perfect square is just 1 (since 0\u00b2 is 0  \u2264 N).\n     * For N \u2265 0 we can use floor(sqrt(N)) to find the largest integer\n     * whose square is \u2264 N.  Adding 1 to that integer gives the next\n     * candidate, and squaring it yields the desired result.\n     */\n    if (N < 0)\n        return 1LL;                       // 1\u00b2 = 1 > any negative N\n\n    // sqrt may return a double that is slightly less than the exact sqrt,\n    // hence we cast to long long after adding 0.5 to avoid issues.\n    long long root = static_cast<long long>(std::sqrt(static_cast<long double>(N)));\n    if (root * root <= N)\n        ++root;                           // ensure strictly greater\n\n    return root * root;\n}\n```\n\n### How it works\n1. **Handling negatives** \u2013 For any negative `N`, the smallest perfect square greater than `N` is `1` (`1\u00b2 = 1`), so we return `1` immediately.\n2. **Finding the floor of \u221aN** \u2013 We compute the integer part of \u221aN using `std::sqrt`.  \n   *We cast to `long double` for extra precision, then cast back to `long long`.*  \n3. **Ensuring strict inequality** \u2013 If `root\u00b2` is still \u2264\u202f`N`, we increment `root` by one.  \n4. **Return the square** \u2013 Finally we return `root * root`, which is guaranteed to be the next perfect square larger than `N`.  \n\n### Example Usage\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << nextPerfectSquare(15) << '\\n';   // outputs 16\n    std::cout << nextPerfectSquare(16) << '\\n';   // outputs 25\n    std::cout << nextPerfectSquare(-5) << '\\n';   // outputs 1\n    return 0;\n}\n```\n\nThe function runs in O(1) time and uses only a few arithmetic operations, making it efficient for very large values of `N`.", "Below is a tiny helper that follows the specification you gave \u2013 it receives a 64\u2011bit integer `N` and returns the first perfect square that is strictly larger than `N`.\n\n```cpp\n#include <cmath>\n#include <cstdint>\n\n// Returns the smallest perfect square > N.\nlong long next_Perfect_Square(long long N) {\n    // In case N is negative, the next perfect square is 1 (1^2).\n    if (N < 0) return 1;\n\n    // Compute floor(sqrt(N)) as an integer.\n    // Use long double to avoid overflow for very large N.\n    long double root = std::sqrt((long double)N);\n    long long k = static_cast<long long>(std::floor(root));\n\n    // If k*k is still > N (possible when N is a perfect square),\n    // we need the next integer.\n    if (k * k <= N) ++k;\n\n    return k * k;\n}\n```\n\n### Why this works\n\n1. **Floor of the square root** \u2013 `k` is the largest integer such that `k\u00b2 \u2264 N`.\n2. **Increment if needed** \u2013 If `k\u00b2` is still `\u2264 N` (which is the case for all `N`), we increment `k` to get the *next* integer.\n3. **Return result** \u2013 `k\u00b2` is the smallest perfect square strictly larger than `N`.\n\nThe implementation uses `long double` for the square\u2011root calculation so that it stays accurate for the full range of 64\u2011bit integers. The final cast back to `long long` is safe because the next perfect square of a 64\u2011bit integer still fits in a 64\u2011bit type for all values of `N` that can be represented by `long long`."]}
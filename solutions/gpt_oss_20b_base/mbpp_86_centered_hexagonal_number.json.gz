{"completions": ["Below is a minimal and self\u2011contained implementation of the function that returns the *nth* centered hexagonal number.  \nThe closed\u2011form formula is  \n\n\\[\nC_n \\;=\\; 3n(n-1)+1\n\\]\n\nwhich can be written equivalently as \\(C_n = n(3n-2)\\).  \nBoth expressions are mathematically identical, but using `3n(n-1)+1` keeps the intermediate product small and is easier to read.\n\n```cpp\n#include <cassert>\n#include <cstdint>   // for std::int64_t\n\n//-----------------------------------------------------------------------------\n//  Return the nth centered hexagonal number\n//  Sequence (starting at n = 1): 1, 7, 19, 37, 61, ...\n//\n//  Formula:  C_n = 3*n*(n-1) + 1\n//\n//  Parameters:\n//      n \u2013 positive integer (n >= 1)\n//  Returns:\n//      C_n as a 64\u2011bit signed integer\n//-----------------------------------------------------------------------------\ninline std::int64_t centered_hexagonal_number(std::int64_t n)\n{\n    // Basic sanity check for the domain of the function.\n    assert(n >= 1);\n\n    // Compute with 64\u2011bit arithmetic to avoid overflow for typical n\n    // values that fit in std::int64_t. For astronomically large n,\n    // a larger integer type would be required.\n    return 3 * n * (n - 1) + 1;\n}\n```\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    for (std::int64_t i = 1; i <= 5; ++i) {\n        std::cout << \"C_\" << i << \" = \" << centered_hexagonal_number(i) << '\\n';\n    }\n}\n```\n\nOutput:\n\n```\nC_1 = 1\nC_2 = 7\nC_3 = 19\nC_4 = 37\nC_5 = 61\n```\n\nThe function is `inline` to suggest to the compiler that it can be expanded at the call site, which is cheap for a single arithmetic expression.  \nThe `assert` guarantees correct usage during debugging; it can be disabled in release builds.", "Here\u2019s a small but complete implementation that follows the usual definition of the centered hexagonal numbers.\n\n```cpp\n#include <cassert>\n\n/*  Centered hexagonal numbers\n *\n *  The k\u2011th centered hexagonal number is obtained by\n *      1  :   1\n *      2  :  7\n *      3  : 19\n *      ...\n *\n *  Closed form : 3\u00b7k\u00b7(k\u20111) + 1\n *\n *  Parameters\n *      n : the index (must be positive; index 1 corresponds to 1)\n *\n *  Returns\n *      the n\u2011th centered hexagonal number as a long\n */\nlong centered_hexagonal_number(long n)\n{\n    assert(n > 0);                       // Ensure a positive index\n\n    // 3 * n * (n - 1) + 1\n    return 3 * n * (n - 1) + 1;\n}\n```\n\n**Explanation**\n\n* The centered hexagonal number sequence is defined by the recurrence  \n  `C(n) = C(n\u20111) + 6(n-1)` with `C(1)=1`.  \n  Solving this recurrence gives the closed\u2011form  \n  `C(n) = 3\u00b7n\u00b7(n-1) + 1`.\n\n* The function simply computes that formula.  \n  The `assert` guards against invalid (non\u2011positive) indices \u2013 in a production\n  setting you might want to throw an exception or return an error code instead.\n\n**Test Example**\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    for (long i = 1; i <= 5; ++i)\n        std::cout << i << \": \" << centered_hexagonal_number(i) << '\\n';\n}\n```\n\nOutput:\n\n```\n1: 1\n2: 7\n3: 19\n4: 37\n5: 61\n```\n\nThese are the first five centered hexagonal numbers.", "Here\u2019s a compact implementation of the function that returns the *n*\u2011th centered hexagonal number.  \nThe sequence is defined by the recurrence\n\n\\[\nH(1)=1,\\qquad\nH(n)=H(n-1)+6\\,(n-1)\\ \\text{for}\\ n>1\n\\]\n\nwhich has the closed\u2011form\n\n\\[\nH(n)=3n(n-1)+1\n\\]\n\nThe latter is more efficient (O(1) time) and protects against integer overflow until the limit of the type.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Return the nth centered hexagonal number (1-indexed).\nlong long centered_hexagonal_number(long long n) {\n    // Guard against invalid input\n    assert(n >= 1 && \"n must be >= 1\");\n\n    // Use 64\u2011bit arithmetic to avoid overflow for larger n\n    // The formula: H(n) = 3*n*(n-1) + 1\n    long long result = 3 * n * (n - 1) + 1;\n    return result;\n}\n```\n\n### Why the formula works\nThe hexagonal tiles grow in concentric layers.  \nThe first layer contains 1 tile.  \nEach subsequent layer adds a ring of 6\u202f\u00d7\u202f(k\u20111) tiles to the previous count, where *k* is the current layer index. Summing that arithmetic series gives \\(3n(n-1)+1\\).\n\n### Usage example\n\n```cpp\nint main() {\n    for (long long i = 1; i <= 10; ++i)\n        cout << i << \" \u2192 \" << centered_hexagonal_number(i) << '\\n';\n}\n```\n\nOutput:\n\n```\n1 \u2192 1\n2 \u2192 7\n3 \u2192 19\n4 \u2192 37\n5 \u2192 61\n6 \u2192 91\n7 \u2192 127\n8 \u2192 169\n9 \u2192 217\n10 \u2192 271\n```\n\nThis implementation is concise, efficient, and safe for all `long long` values that fit into the 64\u2011bit range."]}
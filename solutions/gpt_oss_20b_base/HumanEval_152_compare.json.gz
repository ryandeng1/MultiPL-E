{"completions": ["Below is a minimal implementation that follows the specification.  \nIt iterates through both vectors, computes the absolute difference between the\ncorresponding scores and guesses, and returns a vector with the same length\ncontaining those differences (0 when the guess was correct).\n\n```cpp\n#include <vector>\n#include <cstdlib>   // for std::abs\n#include <cassert>   // optional: for debugging\n\n// ------------------------------------------------------------\n// compare\n//\n// Parameters:\n//   game  \u2013 the actual scores of the matches\n//   guess \u2013 the guessed scores\n//\n// Returns:\n//   A vector such that element i is:\n//       0            if guess[i] == game[i]\n//       |guess[i]-game[i]| otherwise\n//\n// Preconditions:\n//   game.size() == guess.size()\n//\nstd::vector<long> compare(const std::vector<long>& game,\n                          const std::vector<long>& guess)\n{\n    assert(game.size() == guess.size());   // defensive programming\n\n    std::vector<long> diff;\n    diff.reserve(game.size());            // avoid reallocations\n\n    for (size_t i = 0; i < game.size(); ++i) {\n        diff.push_back(std::abs(game[i] - guess[i]));\n    }\n\n    return diff;\n}\n```\n\n### How to use\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> real = {1,2,3,4,5,1};\n    std::vector<long> guess = {1,2,3,4,2,-2};\n\n    std::vector<long> result = compare(real, guess);\n\n    for (long v : result) std::cout << v << ' ';\n    // Output: 0 0 0 0 3 3\n}\n```\n\nFeel free to integrate or adapt this function to your project.", "Here\u2019s a straightforward implementation that follows the specification closely: for each match we compute the absolute difference between the real score and the guessed score.  \nIf the guess is perfect the difference is `0`; otherwise we return the positive distance.\n\n```cpp\n#include <vector>\n#include <cmath>    // for std::abs\n\n// Compare the actual scores with the guessed scores.\n// Both input vectors are guaranteed to have the same length.\nstd::vector<long> compare(std::vector<long> const& game,\n                          std::vector<long> const& guess)\n{\n    std::vector<long> result;\n    result.reserve(game.size());               // avoid reallocations\n\n    for (size_t i = 0; i < game.size(); ++i)\n    {\n        // The absolute value of the difference.  std::abs works for\n        // signed long (in C++11 or later).  If you want to avoid\n        // overload ambiguity you can cast to long long.\n        long diff = std::abs(game[i] - guess[i]);\n        result.push_back(diff);\n    }\n\n    return result;\n}\n```\n\n### How it works\n\n1. **Reserve capacity** \u2013 to keep the algorithm linear in time and stable in memory.\n2. **Pairwise processing** \u2013 iterate over indices and compute `abs(game[i] - guess[i])`.\n3. **Return** \u2013 the resulting vector contains the error for each match.\n\nThis satisfies the contract and matches the examples provided.", "#include <vector>\n#include <cstddef>\n#include <cstdlib>\n#include <cassert>\n\nstd::vector<long> compare(const std::vector<long> &game,\n                          const std::vector<long> &guess) {\n    assert(game.size() == guess.size());\n    std::vector<long> result;\n    result.reserve(game.size());\n    for (size_t i = 0; i < game.size(); ++i) {\n        long diff = game[i] - guess[i];\n        if (diff < 0) diff = -diff;\n        result.push_back(diff);\n    }\n    return result;\n}\n"]}
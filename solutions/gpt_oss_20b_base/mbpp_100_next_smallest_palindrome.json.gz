{"completions": ["Below is a complete, self\u2011contained implementation of the requested function in C++.  \nThe algorithm is a classic \u201cnext palindrome\u201d routine that works for any positive\n`long` (up to 9\u202f223\u202f372\u202f036\u202f854\u202f775\u202f807 on the usual 64\u2011bit builds).  \n\n```cpp\n#include <cassert>\n#include <string>\n\n/* ----------------------------------------------------------------------\n   next_smallest_palindrome\n   ----------------------------------------------------------------------\n   Input:  a positive integer (long)\n   Output: the smallest palindrome strictly larger than `num`\n   ----------------------------------------------------------------------\n   Notes\n   * The routine works entirely on decimal strings, so it can handle very\n     large numbers as long as they fit in a 64\u2011bit long.\n   * It first copies the left half, mirrors it to the right and checks\n     whether the resulting palindromic value is larger than the input.\n     If not, it increments the \"middle\" part (the left+middle digits)\n     and mirrors again.\n*/\nlong next_smallest_palindrome(long num)\n{\n    assert(num > 0);                      // function defined only for >0\n\n    std::string s = std::to_string(num);\n    int n = (int)s.size();\n\n    // ------------------------------------------------------------------\n    // 1. Try mirroring the left side to the right side\n    // ------------------------------------------------------------------\n    std::string left = s.substr(0, (n + 1) / 2);   // includes middle if odd\n    std::string rev_left = left;\n    std::reverse(rev_left.begin(), rev_left.end());\n\n    std::string candidate;\n    if (n % 2 == 0)                          // even length\n        candidate = left + rev_left;\n    else                                      // odd length\n        candidate = left + rev_left.substr(1);\n\n    long cand_value = std::stoll(candidate);\n\n    if (cand_value > num)\n        return cand_value;\n\n    // ------------------------------------------------------------------\n    // 2. Increment the middle (left + middle if odd) and mirror again\n    // ------------------------------------------------------------------\n    int inc_pos = (n - 1) / 2;                // index of the middle to carry\n    while (inc_pos >= 0 && left[inc_pos] == '9') {\n        left[inc_pos] = '0';\n        --inc_pos;\n    }\n    if (inc_pos < 0) {                       // all 9\u2019s -> 100...001\n        left = \"1\" + left;                   // prepend 1\n    } else {\n        left[inc_pos]++;                      // carry\n    }\n\n    rev_left = left;\n    std::reverse(rev_left.begin(), rev_left.end());\n\n    if (left.size() > (n + 1) / 2) {        // e.g. 999 -> 1001\n        if (n % 2 == 0)\n            candidate = left + rev_left;\n        else\n            candidate = left + rev_left.substr(1);\n    } else {\n        if (n % 2 == 0)\n            candidate = left + rev_left;\n        else\n            candidate = left + rev_left.substr(1);\n    }\n\n    return std::stoll(candidate);\n}\n```\n\n### How it works\n\n1. **Mirror the left side**  \n   *For a number `s`*:  \n   `left = first \u2308n/2\u2309 digits`.  \n   Mirror it to obtain a palindrome `candidate`.  \n   If `candidate > num`, we're done.\n\n2. **Increment and mirror**  \n   When `candidate \u2264 num`, the palindrome must be larger in the \u201cmiddle\u201d part.  \n   We increment the middle (which may involve carrying across all preceding\n   9\u2019s) and then mirror again.  \n   Special handling for the case all digits are `9` (`999\u2026999 \u2192 1000\u20260001`).\n\n### Example\n\n```\nInput :  12345\nStep 1:  Mirror -> 12321  (\u2264 12345)\nStep 2:  Increment middle  -> 12421  (return)\n```\n\nThis routine runs in O(d) time where *d* is the number of digits (\u226419 for 64\u2011bit `long`).", "**Solution Overview**\n\nThe task is to return the smallest palindrome strictly larger than a given positive integer `num`.  \nInstead of checking every number one\u2011by\u2011one we can construct the next palindrome directly from the decimal representation of `num`.  \n\nThe algorithm works for all positive 64\u2011bit integers (`num > 0`).  \n(It is safe with `long` because we never generate a number larger than `LLONG_MAX` \u2013 the inputs in the tests are far below that limit.)\n\n--------------------------------------------------------------------\n\n### 1.  Idea\n\nFor a number `S = d\u2080 d\u2081 \u2026 d_{k-1}` (k\u2011digits, `d\u2080` most significant)  \nthe next palindrome has the same length **unless** `S` is of the form\n\n```\n999...999           (all 9\u2019s)\n```\n\nIn that case the next palindrome is simply `1 0...0 1` (k+1 digits).\n\nOtherwise the next palindrome can be obtained in three steps\n\n1. **Mirror**: copy the left half of the number to the right half.  \n   The mirrored number is `M`.  \n   If `M > S` we are done \u2013 this is the next palindrome.\n\n2. **Increase the middle**:  \n   If `M \u2264 S`, we need to bump the middle (or the left \u201cpivot\u201d) by one and mirror again.  \n   This guarantees that the result is strictly larger than `S` and still a palindrome.\n\nThe tricky part is handling the \u201cincrease the middle\u201d step correctly when the middle digit(s) are 9 or when the length is even/odd.\n\n--------------------------------------------------------------------\n\n### 2.  Detailed Algorithm (string based)\n\n```text\nnext_smallest_palindrome(n):\n    if n <= 0        \u2192 return 0   // not defined for non\u2011positive numbers\n\n    s = decimal string of n\n    k = length(s)\n\n    # 2.1  all 9's \u2192 100...001\n    if every character of s == '9':\n        return 10^k + 1         // string \"1\" + k-1 zeros + \"1\"\n\n    # 2.2  create mirrored version\n    left = s[0 .. (k/2 - 1)]   // left half, excluding middle if k odd\n    middle = \"\"                // middle character(s)\n    if k is odd:\n        middle = s[k/2]              // the middle digit\n    right = reverse(left)          // right half\n\n    palindrome = left + middle + right\n    if palindrome > s:     // compare lexicographically = numeric comparison\n        return stoll(palindrome)\n\n    # 2.3  need to increment middle part\n    # Build a mutable string for prefix that will be incremented\n    if k is odd:\n        inc_prefix = left + middle   // includes middle digit\n    else:\n        inc_prefix = left            // no middle digit\n\n    # Increment inc_prefix as a decimal number (with possible carry)\n    i = length(inc_prefix) - 1\n    carry = 1\n    while i >= 0 and carry:\n        digit = inc_prefix[i] - '0' + carry\n        carry = digit / 10\n        inc_prefix[i] = char('0' + (digit % 10))\n        i -= 1\n\n    # If we still have carry after the most significant digit,\n    # it means we had 999\u20269 in the prefix (this case is already handled\n    # earlier, but we keep the code tidy).\n    if carry == 1:\n        inc_prefix = '1' + inc_prefix  // e.g. 999 -> 1000\n\n    # Build the final palindrome from the incremented prefix\n    if k is odd:\n        # inc_prefix contains left + new middle\n        new_left  = inc_prefix.substr(0, inc_prefix.size() - 1)\n        new_middle= inc_prefix.back()\n        new_right = reverse(new_left)\n        final_palindrome = new_left + new_middle + new_right\n    else:\n        new_left  = inc_prefix          // this is the whole left part\n        new_right = reverse(new_left)\n        final_palindrome = new_left + new_right\n\n    return stoll(final_palindrome)\n```\n\n*All string operations are `O(k)` and `k \u2264 19` for 64\u2011bit numbers, so the\ntime complexity is `O(1)` in practice.*\n\n--------------------------------------------------------------------\n\n### 3.  Correctness Proof\n\nWe prove that the algorithm returns the smallest palindrome greater than `n`.\n\n---\n\n#### Lemma 1  \nIf every digit of `n` is `9`, the algorithm returns `100\u2026001`, which is the\nsmallest palindrome greater than `n`.\n\n**Proof.**  \nFor `n = 99\u20269` (k 9\u2019s), any palindrome of length `k` must be \u2264 `99\u20269` (since the digits are at most 9).  \nThe next palindrome must have length `k+1` and start and end with `1`.  \nThe smallest such palindrome is `1` followed by `k-1` zeros and a trailing `1`. The algorithm returns exactly this number. \u220e\n\n\n\n#### Lemma 2  \nIf the mirrored number `M` (left \u2192 right) is > `n`, then `M` is the smallest\npalindrome greater than `n`.\n\n**Proof.**  \n`M` has the same length as `n` and only the right half differs.  \nAny palindrome larger than `n` but smaller than `M` would have the same left\nhalf as `n` but a right half lexicographically smaller than the mirrored\nright half, contradicting the definition of `M`.  \nThus no palindrome in the same length lies in the interval `(n, M)`. \u220e\n\n\n\n#### Lemma 3  \nIf the mirrored number `M` \u2264 `n`, then incrementing the middle part (as\ndescribed) yields a palindrome `P` that is the smallest palindrome > `n`.\n\n**Proof.**  \nBecause `M` \u2264 `n`, the left half of `n` is lexicographically\nlarger or equal to the left half of `M`.  \nThe algorithm increments the smallest divisor of `n` that can change the\npalindrome: the middle digit(s) + any preceding carry.  \nLet `inc` be the new middle part after increment.  \n*   All palindromes obtained by mirroring a left part **strictly smaller**\n    than the current left are \u2264 `n`.  \n*   All palindromes obtained by the same left part with a middle part\n    **strictly smaller** than `inc` are also \u2264 `n` (by construction\n    `M` \u2264 `n`).  \n*   The palindrome `P` constructed from the incremented prefix is > `n`\n    because the middle part was strictly increased.  \n*   Any other palindrome larger than `n` must have either the same left\n    part and a middle part \u2265 `inc`, or a larger left part.  \n    The smallest such palindrome is exactly `P`. \u220e\n\n\n\n#### Theorem  \nFor every positive integer `n`, the function `next_smallest_palindrome(n)`\nreturns the smallest palindrome strictly greater than `n`.\n\n**Proof.**  \nThree cases are considered:\n\n1. All digits 9 \u2192 Lemma&nbsp;1.  \n2. Mirrored number `M` > `n` \u2192 Lemma&nbsp;2.  \n3. `M` \u2264 `n` \u2192 Lemma&nbsp;3.\n\nThe algorithm always chooses the correct branch, therefore the returned\nvalue is the desired smallest palindrome. \u220e\n\n\n\n--------------------------------------------------------------------\n\n### 4.  Complexity Analysis\n\n`k` \u2013 number of decimal digits of `n` (`k \u2264 19` for 64\u2011bit `long`).\n\n*String operations* (`copy`, `reverse`) are `O(k)`.  \nAll other loops run at most `k` iterations.\n\n```\nTime   :  O(k)  \u2248  O(1)  for practical inputs\nMemory :  O(k)  \u2248  O(1)\n```\n\n--------------------------------------------------------------------\n\n### 5.  Reference Implementation (C++17)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// ------------------------------------------------------------\n// Return the smallest palindrome strictly larger than 'num'.\n// Assumes num > 0. For num <= 0 the function returns 0.\nlong long next_smallest_palindrome(long long num) {\n    if (num <= 0) return 0;\n\n    string s = to_string(num);\n    int k = static_cast<int>(s.size());\n\n    // ---------  case: all 9's ---------------------------------\n    bool all9 = true;\n    for (char c : s) if (c != '9') { all9 = false; break; }\n    if (all9) {\n        // 1 followed by k-1 zeros then 1\n        string res = \"1\";\n        res.append(k - 1, '0');\n        res.push_back('1');\n        return stoll(res);\n    }\n\n    // ---------  build mirrored string --------------------------\n    string left = s.substr(0, k / 2);\n    string middle = (k % 2 ? string(1, s[k / 2]) : string());\n    string right = left;                // will become reversed later\n    reverse(right.begin(), right.end());\n\n    string pal = left + middle + right;\n    if (pal > s)               // already larger\n        return stoll(pal);\n\n    // ---------  we need to increase the middle ----------------\n    string inc_prefix;\n    if (k % 2)                 // odd length : left + middle\n        inc_prefix = left + middle;\n    else\n        inc_prefix = left;     // even length : just left\n\n    // Increment inc_prefix as a decimal integer\n    int i = static_cast<int>(inc_prefix.size()) - 1;\n    int carry = 1;             // we want to add 1\n    while (i >= 0 && carry) {\n        int d = inc_prefix[i] - '0' + carry;\n        carry = d / 10;\n        inc_prefix[i] = char('0' + (d % 10));\n        --i;\n    }\n\n    if (carry) {               // e.g. 999\u20269 becomes 1000\u2026\n        inc_prefix.insert(inc_prefix.begin(), '1');\n    }\n\n    // Reconstruct the final palindrome\n    string final_pal;\n    if (k % 2) {\n        // inc_prefix = new_left + new_middle\n        string new_left  = inc_prefix.substr(0, inc_prefix.size() - 1);\n        string new_middle= inc_prefix.back();\n        string new_right = new_left;\n        reverse(new_right.begin(), new_right.end());\n        final_pal = new_left + new_middle + new_right;\n    } else {\n        // inc_prefix is the whole new left side\n        string new_left = inc_prefix;\n        string new_right = new_left;\n        reverse(new_right.begin(), new_right.end());\n        final_pal = new_left + new_right;\n    }\n\n    return stoll(final_pal);\n}\n// ------------------------------------------------------------\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    long long n;\n    while (cin >> n) {\n        cout << next_smallest_palindrome(n) << '\\n';\n    }\n    return 0;\n}\n```\n\nThe program follows exactly the algorithm proven correct above,\nand works for all 64\u2011bit positive integers.", "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*  Return the next smallest palindrome > num\n    The input is a positive long integer.\n\n    The algorithm works in O(d) time where d = number of digits.\n    It avoids overflow by never constructing a number that\n    is larger than the maximum value that fits into a `long` (2^63\u20111).\n*/\n\nlong next_smallest_palindrome(long num)\n{\n    if (num < 0) throw std::invalid_argument(\"num must be >= 0\");\n\n    // Special case for numbers that are all 9's (e.g. 9, 99, 999 \u2026)\n    // The next palindrome is 100\u2026001 which has one more digit.\n    long temp = num;\n    bool all9 = true;\n    while (temp > 0) {\n        if (temp % 10 != 9) { all9 = false; break; }\n        temp /= 10;\n    }\n    if (all9) {\n        // 999 -> 1001, 99 -> 101, 9 -> 11\n        return std::pow(10, static_cast<int>(log10(num)) + 1) + 1;\n    }\n\n    string s = to_string(num);\n    int n = (int)s.size();\n    string left = s.substr(0, (n + 1) / 2);   // left half + middle if odd\n    string rev_left = left;\n    reverse(rev_left.begin(), rev_left.end());\n\n    // Form palindrome by mirroring left side\n    string pal = left + rev_left.substr(n % 2);\n    if (stoll(pal) > num) {\n        return stoll(pal);\n    }\n\n    // Increment the left half (including middle digit if odd)\n    // and handle carry propagation.\n    int carry = 1;\n    for (int i = (int)left.size() - 1; i >= 0 && carry; --i) {\n        int digit = left[i] - '0' + carry;\n        carry = digit / 10;\n        digit %= 10;\n        left[i] = char('0' + digit);\n    }\n    // If carry remains, numbers like 12921 -> 13031, no need to extend length\n    // because we already handled all\u20119\u2019s case above.\n\n    string rev_left2 = left;\n    reverse(rev_left2.begin(), rev_left2.end());\n    string pal2 = left + rev_left2.substr(n % 2);\n    return stoll(pal2);\n}\n```\n\n**Explanation**\n\n1. **All\u20119\u2019s case** \u2013 When `num` consists solely of 9\u2019s, the next palindrome has one more digit: `100\u2026001`.  \n2. **Mirror** \u2013 Create the palindrome by mirroring the left half; if the resulting number is already larger than `num`, return it.  \n3. **Increment left half** \u2013 If mirroring gave a number `\u2264 num`, increment the left half (including the middle digit if the length is odd). Handle carry propagation.  \n4. **Mirror again** \u2013 Mirror the new left half to get the final answer.\n\nThe function works in linear time with respect to the number of digits and stays within the bounds of `long`."]}
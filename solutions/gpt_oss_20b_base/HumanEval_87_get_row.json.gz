{"completions": ["Here\u2019s a clean, self\u2011contained implementation that follows the rules you described:\n\n```cpp\n#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <cassert>\n\n/*\n * Find all coordinates of the integer `x` inside a jagged matrix `lst`.\n * Return a vector of std::tuple<row, col>.\n *\n * The result is sorted by:\n *   \u2013 row ascending\n *   \u2013 column descending (within the same row)\n */\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n    std::vector<std::tuple<long,long>> ans;\n\n    for (long r = 0; r < static_cast<long>(lst.size()); ++r) {\n        const auto &rowVec = lst[r];\n        for (long c = 0; c < static_cast<long>(rowVec.size()); ++c) {\n            if (rowVec[c] == x) {\n                ans.emplace_back(r, c);\n            }\n        }\n    }\n\n    /* required ordering:\n        first by row increasing\n        then by column decreasing */\n    std::sort(ans.begin(), ans.end(),\n        [](const auto &a, const auto &b) {\n            if (std::get<0>(a) != std::get<0>(b)) {\n                return std::get<0>(a) < std::get<0>(b); // row ascending\n            }\n            return std::get<1>(a) > std::get<1>(b);    // column descending\n        });\n\n    return ans;\n}\n\n/* ------------  quick sanity tests  ----------------- */\nvoid test_examples() {\n    std::vector<std::vector<long>> lst1{\n        {1,2,3,4,5,6},\n        {1,2,3,4,1,6},\n        {1,2,3,4,5,1}\n    };\n    auto r1 = get_row(lst1, 1);\n    assert((r1 == std::vector<std::tuple<long,long>>{\n        {0,0},\n        {1,4},\n        {1,0},\n        {2,5},\n        {2,0}\n    }));\n\n    auto r2 = get_row({}, 1);\n    assert(r2.empty());\n\n    std::vector<std::vector<long>> lst3{\n        {},\n        {1},\n        {1,2,3}\n    };\n    auto r3 = get_row(lst3, 3);\n    assert((r3 == std::vector<std::tuple<long,long>>{{2,2}}));\n}\n\nint main() {\n    test_examples();\n    std::cout << \"All tests passed.\\n\";\n    return 0;\n}\n```\n\n**Explanation of the key parts**\n\n1. **Looping through rows & columns**  \n   Since the matrix is jagged, we use `lst.size()` for the row count and `rowVec.size()` for the column count of each row.\n\n2. **Gathering coordinates**  \n   Whenever an element equals `x`, we `emplace_back` a tuple of its row and column indices.\n\n3. **Custom sorting**  \n   The lambda comparator sorts first by the row (`<`), then by the column in *descending* order (`>`), exactly the pattern requested.\n\n4. **Test harness**  \n   A small `main()` function runs the three given examples and throws an `assert` if any expectation fails.\n\nCompile with `-std=c++17` (or later) \u2013 no external dependencies needed.", "Here is a complete, clean implementation of the required function.  \nThe code parses the jagged matrix (`std::vector<std::vector<long>>`) and collects every occurrence of `x`.  \nThe collected coordinates are sorted first by ascending row index, then by descending column index.  \nFinally, it returns them as a `std::vector<std::tuple<long,long>>`.\n\n```cpp\n#include <vector>\n#include <tuple>\n#include <cstddef>\n#include <algorithm>\n\n/// @brief   Find all coordinates of `x` inside a jagged 2\u2011D vector.\n/// @details The matrix may have rows of different lengths.  \n///          The returned vector is sorted first by row (ascending),  \n///          then by column (descending) within each row.\n/// @param[in] lst  Jagged 2\u2011D vector (matrix).\n/// @param[in] x    Value to search for.\n/// @return        Vector of tuples (row, column) with the position of `x`.\nstd::vector<std::tuple<long,long>> get_row(\n    const std::vector<std::vector<long>>& lst,\n    long x)\n{\n    // Temporary container for found positions.\n    std::vector<std::tuple<long,long>> positions;\n\n    // Scan the jagged matrix.\n    for (std::size_t row = 0; row < lst.size(); ++row) {\n        const auto& current = lst[row];\n        for (std::size_t col = 0; col < current.size(); ++col) {\n            if (current[col] == x) {\n                positions.emplace_back(static_cast<long>(row),\n                                       static_cast<long>(col));\n            }\n        }\n    }\n\n    // Sort: rows ascending, columns descending.\n    std::sort(positions.begin(), positions.end(),\n        [](const std::tuple<long,long>& a,\n           const std::tuple<long,long>& b)\n        {\n            if (std::get<0>(a) != std::get<0>(b))\n                return std::get<0>(a) < std::get<0>(b);          // row asc\n            else\n                return std::get<1>(a) > std::get<1>(b);          // col desc\n        });\n\n    return positions;\n}\n\n/* Example usage:\n\nint main() {\n    std::vector<std::vector<long>> data = {\n        {1,2,3,4,5,6},\n        {1,2,3,4,1,6},\n        {1,2,3,4,5,1}\n    };\n    auto res = get_row(data, 1);\n    // res will contain (0,0), (1,4), (1,0), (2,5), (2,0)\n}\n*/\n\n```\n\n### Notes  \n- The function takes the input vector by **const reference** to avoid unnecessary copies.  \n- All indices are cast to `long` because the return type expects `long` tuples.  \n- The algorithm runs in `O(m + n)` where `m` is the total number of elements in the jagged matrix and `n` is the number of found occurrences.  \n- If the matrix is empty or `x` does not exist, the returned vector is empty.", "Here is a clean C++ implementation that follows the description in the problem statement:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// ------------------------------------------------------------------\n// Function: get_row\n//\n// Parameters:\n//   - lst : vector of vectors of long \u2013 a ragged \"matrix\"\n//   - x   : the value to search for\n//\n// Returns:\n//   - vector<tuple<long,long>> \u2013 all coordinates (row, col) where\n//     the value equals x.\n//\n// The result is sorted first by row ascending, and then by column\n// descending within each row.\n//\n// ------------------------------------------------------------------\nvector<tuple<long, long>> get_row(const vector<vector<long>>& lst, long x) {\n    vector<tuple<long, long>> res;\n    if (lst.empty()) return res;\n\n    for (long r = 0; r < (long)lst.size(); ++r) {\n        const auto& row = lst[r];\n        for (long c = 0; c < (long)row.size(); ++c) {\n            if (row[c] == x) {\n                res.emplace_back(r, c);\n            }\n        }\n    }\n\n    // Sort by row ascending, then column descending within the same row\n    sort(res.begin(), res.end(),\n         [](const auto& a, const auto& b) {\n             if (get<0>(a) != get<0>(b))\n                 return get<0>(a) < get<0>(b);          // row ascending\n             return get<1>(a) > get<1>(b);              // column descending\n         });\n\n    return res;\n}\n\n// ------------------------------------------------------------------\n// For demonstration purposes: a simple main that runs the examples\n// ------------------------------------------------------------------\nint main() {\n    vector<vector<long>> mat1 = {\n        {1, 2, 3, 4, 5, 6},\n        {1, 2, 3, 4, 1, 6},\n        {1, 2, 3, 4, 5, 1}\n    };\n\n    vector<tuple<long,long>> ans1 = get_row(mat1, 1);\n    for (auto [r,c] : ans1)\n        cout << \"(\" << r << \",\" << c << \") \";\n    cout << \"\\n\";\n\n    vector<vector<long>> mat2;                 // empty\n    vector<tuple<long,long>> ans2 = get_row(mat2, 1);\n    cout << \"size: \" << ans2.size() << \"\\n\";\n\n    vector<vector<long>> mat3 = {\n        {}, {1}, {1, 2, 3}\n    };\n    vector<tuple<long,long>> ans3 = get_row(mat3, 3);\n    for (auto [r,c] : ans3)\n        cout << \"(\" << r << \",\" << c << \") \";\n    cout << \"\\n\";\n}\n```\n\n### How it works\n\n1. **Iterate through the ragged matrix**  \n   For each row `r` and each element `c`, if the element equals `x`, push the pair `(r,c)` into `res`.\n\n2. **Sorting**  \n   `sort` is used with a lambda that:\n   - Orders pairs by the **row index** in ascending order (`<`).\n   - If the rows are equal, orders by the **column index** in **descending** order (`>`).\n\n3. **Return**  \n   The sorted vector of tuples is returned.\n\n### Complexity\n\n- **Time** \u2013 `O(N)` to scan all elements plus `O(K log K)` to sort, where `N` is the total number of elements and `K` is the number of matches.\n- **Space** \u2013 `O(K)` for the result vector. The algorithm does not use extra storage beyond that.\n\nFeel free to integrate `get_row` into any project that needs to find indices in a ragged 2\u2011D container."]}
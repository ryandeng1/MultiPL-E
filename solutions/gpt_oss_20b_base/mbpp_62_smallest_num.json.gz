{"completions": ["```cpp\n/*********************************************************************\n *  Function:  smallest_num\n *  Purpose:   Return the smallest value contained in a vector of\n *             integers (of type `long`).  \n *  Parameters:\n *      xs  \u2013 a non\u2011empty  vector<long>\n *\n *  Return:\n *      The smallest element of the vector.\n *\n *  Notes:\n *      \u2022 If the vector is empty the function will assert (debug build)\n *        because the behaviour is undefined for an empty container.\n *      \u2022 The implementation uses a single linear scan \u2013 O(n) time, \n *        O(1) extra space.\n *********************************************************************/\n\nlong smallest_num(const std::vector<long>& xs)\n{\n    assert(!xs.empty() && \"smallest_num requires a non\u2011empty vector\");\n\n    long min_val = xs.front();            // start with the first element\n    for (size_t i = 1; i < xs.size(); ++i)\n        if (xs[i] < min_val)\n            min_val = xs[i];\n\n    return min_val;\n}\n```\n\n**Usage example**\n\n```cpp\n#include <iostream>\n#include <vector>\n\nint main()\n{\n    std::vector<long> data{ 23, -5, 17, 0, 42 };\n    std::cout << \"Smallest: \" << smallest_num(data) << '\\n';   // prints -5\n}\n```\n\nThe function is linear in the number of elements, uses only a single temporary variable, and is safe for all sizes of `long` (as long as the vector is non\u2011empty).", "Here\u2019s a minimal, self\u2011contained C++ function that returns the smallest element in a `std::vector<long>`.  \nIt performs some defensive checks (throws an exception if the vector is empty) and uses standard library algorithms for clarity and efficiency.\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <stdexcept>\n\n/**\n * @brief Finds the smallest number in a vector of long integers.\n *\n * @param xs   The vector containing the numbers to inspect.\n * @return long The minimum value found in the vector.\n *\n * @throws std::invalid_argument if the vector is empty.\n */\nlong smallest_num(const std::vector<long>& xs)\n{\n    if (xs.empty())\n        throw std::invalid_argument(\"cannot find minimum of an empty vector\");\n\n    // std::min_element returns an iterator to the smallest element\n    return *std::min_element(xs.begin(), xs.end());\n}\n```\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> data = {10, -3, 7, 0};\n\n    try {\n        std::cout << \"Smallest: \" << smallest_num(data) << '\\n';\n    } catch (const std::invalid_argument& e) {\n        std::cerr << \"Error: \" << e.what() << '\\n';\n    }\n\n    return 0;\n}\n```\n\nThis implementation is O(n) in time\u2013complexity, uses only a single pass over the data, and is safe against an empty input.", "Here\u2019s a clean, header\u2011only C++ implementation that returns the smallest element of a vector.  \nIt does not depend on any non\u2011standard libraries and it properly handles the empty\u2011vector case by throwing an exception.\n\n```cpp\n// smallest_num.hpp\n#pragma once\n#include <vector>\n#include <algorithm>\n#include <stdexcept>\n\n/**\n * @brief Returns the smallest element in a vector of integers.\n *\n * @tparam T  The type stored in the vector (must support `<` comparison).\n * @param   xs  The vector from which to find the smallest value.\n * @return      The minimum value in xs.\n *\n * @throws std::invalid_argument if xs is empty.\n */\ntemplate <typename T>\nT smallest_num(const std::vector<T>& xs)\n{\n    if (xs.empty())\n        throw std::invalid_argument(\"Vector is empty\");\n\n    // Use std::min_element \u2013 O(n) time, O(1) extra space.\n    auto min_iter = std::min_element(xs.begin(), xs.end());\n    return *min_iter;\n}\n```\n\n### How to use it\n\n```cpp\n#include <iostream>\n#include \"smallest_num.hpp\"\n\nint main()\n{\n    std::vector<long> data{ 42, -7, 13, 8, 3 };\n    try {\n        long smallest = smallest_num(data);\n        std::cout << \"Smallest number: \" << smallest << '\\n';\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << '\\n';\n    }\n    return 0;\n}\n```\n\n**Explanation**\n\n1. **Empty check** \u2013 The function throws an `std::invalid_argument` if the vector is empty, so callers cannot read an undefined value.\n2. **`std::min_element`** \u2013 This standard library algorithm scans the range once, giving linear time `O(n)` and constant additional space.\n3. **Template** \u2013 The function is templated, so it works with any type that supports the `<` comparison (e.g., `int`, `long`, `double`, custom numeric types).\n\nFeel free to drop the implementation into any header or source file and include it where needed."]}
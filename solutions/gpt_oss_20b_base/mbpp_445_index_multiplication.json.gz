{"completions": ["**Solution Explanation**\n\nThe task is to multiply two 2\u2011D vectors \u201cindex wise\u201d.  \nThat means that for each position `(i , j)` we multiply the element from the first\nvector with the element from the second vector:\n\n```\nresult[i][j] = test_tup1[i][j] * test_tup2[i][j]\n```\n\nThe two input vectors must have the same number of rows and the same number of\ncolumns in every row.  \nThe function returns a new 2\u2011D vector containing the products.\n\n```cpp\n#include <vector>\n#include <cassert>\n\n// ------------------------------------------------------------------\n//   index_multiplication\n// ------------------------------------------------------------------\n/**\n * @brief  Element\u2011wise (index wise) multiplication of two 2\u2011D vectors.\n *\n * @param test_tup1 First 2\u2011D vector of long integers.\n * @param test_tup2 Second 2\u2011D vector of long integers.\n *\n * @return  New 2\u2011D vector containing the element\u2011wise products.\n *\n * @throws  std::invalid_argument if the input vectors are not of the same\n *          shape.\n *\n * Example:\n *   test_tup1 = {{1,2},{3,4}}\n *   test_tup2 = {{5,6},{7,8}}\n *   result   = {{5,12},{21,32}}\n */\nstd::vector<std::vector<long>> index_multiplication(\n    const std::vector<std::vector<long>>& test_tup1,\n    const std::vector<std::vector<long>>& test_tup2)\n{\n    // Basic validation ----------------------------------------------------\n    // 1. Both vectors must be non\u2011empty.\n    // 2. They must contain the same number of rows.\n    // 3. Every corresponding row must have the same number of columns.\n    if (test_tup1.empty() || test_tup2.empty())\n        throw std::invalid_argument(\"Input vectors must not be empty.\");\n\n    if (test_tup1.size() != test_tup2.size())\n        throw std::invalid_argument(\"Two vectors must have the same number of rows.\");\n\n    std::vector<std::vector<long>> result;\n    result.reserve(test_tup1.size());       // pre\u2011allocate for speed\n\n    // --------------------------------------------------------------------\n    // Converting row by row\n    // --------------------------------------------------------------------\n    for (size_t i = 0; i < test_tup1.size(); ++i)\n    {\n        const auto& row1 = test_tup1[i];\n        const auto& row2 = test_tup2[i];\n\n        if (row1.size() != row2.size())\n            throw std::invalid_argument(\"Each row in the two vectors must have the same length.\");\n\n        std::vector<long> prod;\n        prod.reserve(row1.size());\n\n        for (size_t j = 0; j < row1.size(); ++j)\n        {\n            // Index wise multiplication\n            prod.push_back(row1[j] * row2[j]);\n        }\n        result.push_back(std::move(prod));\n    }\n\n    return result;\n}\n```\n\n### Why did we choose this implementation?\n\n| Feature | Why it matters |\n|---------|----------------|\n| **Input validation** | Prevents silent failures and gives clear errors if shapes differ. |\n| **`const` references** | Avoids unnecessary copies of the input vectors. |\n| **Pre\u2011allocation (`reserve`)** | Improves performance for large matrices. |\n| **`std::invalid_argument`** | Standard exception type that clearly indicates an misuse of the API. |\n\n### Testing\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<std::vector<long>> a{{1, 2, 3},\n                                     {4, 5, 6}};\n\n    std::vector<std::vector<long>> b{{7, 8, 9},\n                                     {10, 11, 12}};\n\n    auto c = index_multiplication(a, b);\n\n    for (const auto& row : c) {\n        for (auto v : row) std::cout << v << ' ';\n        std::cout << '\\n';\n    }\n    // Output:\n    // 7 16 27\n    // 40 55 72\n}\n```\n\nThe function is ready to be integrated into any larger code base that needs element\u2011wise matrix multiplication.", "Here\u2019s a compact, self\u2011contained implementation that multiplies two matrices **index\u2011wise** (i.e. it multiplies each element with the element that has the same row/column indices in the other matrix).  \nThe function is defensive \u2013 it validates that the two matrices have the same shape before doing the multiplication.  \n\n```cpp\n#include <vector>\n#include <cassert>\n\n// -----------------------------------------------------------------------------\n// Performs element\u2011wise (index\u2011wise) multiplication of two 2\u2011D vectors (matrices)\n// -----------------------------------------------------------------------------\nstd::vector<std::vector<long>>\nindex_multiplication(const std::vector<std::vector<long>>& a,\n                     const std::vector<std::vector<long>>& b)\n{\n    // ---------------------------------------------------------------------\n    // Sanity checks \u2013 both matrices must be non\u2011empty and have identical shape\n    // ---------------------------------------------------------------------\n    assert(!a.empty() && !b.empty() && \"Input matrices must not be empty!\");\n\n    size_t rows_a = a.size();\n    size_t rows_b = b.size();\n\n    assert(rows_a == rows_b && \"Matrices must have the same number of rows!\");\n\n    // All rows in 'a' must have the same width, and the same must hold for 'b'.\n    // We\u2019ll capture the width of the first row and verify it for every row.\n    size_t cols_a = a[0].size();\n    size_t cols_b = b[0].size();\n    assert(cols_a == cols_b && \"Matrices must have the same number of columns!\");\n\n    for (size_t i = 0; i < rows_a; ++i) {\n        assert(a[i].size() == cols_a && \"All rows in first matrix must have identical width!\");\n    }\n    for (size_t i = 0; i < rows_b; ++i) {\n        assert(b[i].size() == cols_b && \"All rows in second matrix must have identical width!\");\n    }\n\n    // ---------------------------------------------------------------------\n    // Allocate the result matrix with the same shape as the inputs\n    // ---------------------------------------------------------------------\n    std::vector<std::vector<long>> result(rows_a,\n                                         std::vector<long>(cols_a, 0));\n\n    // ---------------------------------------------------------------------\n    // Element\u2011wise multiplication\n    // ---------------------------------------------------------------------\n    for (size_t r = 0; r < rows_a; ++r) {\n        for (size_t c = 0; c < cols_a; ++c) {\n            result[r][c] = a[r][c] * b[r][c];\n        }\n    }\n\n    return result;\n}\n```\n\n### How it works\n\n1. **Validation**  \n   * Checks that neither matrix is empty.  \n   * Confirms that both matrices have the same number of rows and columns.  \n   * Verifies that each row within a matrix has the same width \u2013 this guarantees a well\u2011formed rectangular matrix.\n\n2. **Allocation**  \n   * A matrix of the same dimensions is created, filled with zeros.\n\n3. **Multiplication**  \n   * Two nested loops traverse every row `r` and column `c`.  \n   * The product `a[r][c] * b[r][c]` is stored in the corresponding element of `result`.\n\n### Example usage\n\n```cpp\nint main() {\n    std::vector<std::vector<long>> m1 = {{1,2,3},\n                                         {4,5,6}};\n    std::vector<std::vector<long>> m2 = {{7,8,9},\n                                         {10,11,12}};\n\n    auto prod = index_multiplication(m1, m2);\n\n    for (const auto& row : prod) {\n        for (auto v : row) std::cout << v << ' ';\n        std::cout << '\\n';\n    }\n    // Output:\n    // 7 16 27\n    // 40 55 72\n}\n```\n\nFeel free to adapt or extend this function\u2014for instance, by supporting different numeric types or by removing the `assert`s in production builds.", "Below is a complete implementation of\u202f`index_multiplication`.  \nIt multiplies the elements at the same indices of the two 2\u2011D vectors (essentially element\u2011wise multiplication of two matrices).  \nThe function checks that the two input vectors have the same shape and then builds a new vector of the same shape containing the products.\n\n```cpp\n#include <vector>\n#include <cassert>\n\n/*\n *  Perform element\u2011wise (index\u2011wise) multiplication of two 2\u2011D vectors.\n *\n *  Parameters\n *  ----------\n *  test_tup1 : std::vector<std::vector<long>>\n *      First matrix.\n *  test_tup2 : std::vector<std::vector<long>>\n *      Second matrix (must have the same shape as `test_tup1`).\n *\n *  Returns\n *  -------\n *  std::vector<std::vector<long>>\n *      Matrix containing the product of corresponding elements.\n *\n *  Example\n *  -------\n *  auto A = {{1,2,3},\n *            {4,5,6}};\n *  auto B = {{7,8,9},\n *            {10,11,12}};\n *  // -> {{7,16,27},\n *  //     {40,55,72}}\n */\nstd::vector<std::vector<long>>\nindex_multiplication(const std::vector<std::vector<long>>& test_tup1,\n                     const std::vector<std::vector<long>>& test_tup2)\n{\n    // Ensure the matrices have the same number of rows\n    assert(test_tup1.size() == test_tup2.size());\n\n    std::vector<std::vector<long>> result;\n    result.reserve(test_tup1.size());\n\n    for (size_t i = 0; i < test_tup1.size(); ++i) {\n        // In each row, make sure the number of columns matches\n        assert(test_tup1[i].size() == test_tup2[i].size());\n\n        std::vector<long> row;\n        row.reserve(test_tup1[i].size());\n\n        for (size_t j = 0; j < test_tup1[i].size(); ++j) {\n            row.push_back(test_tup1[i][j] * test_tup2[i][j]);\n        }\n        result.push_back(std::move(row));\n    }\n\n    return result;\n}\n```\n\n### How It Works\n\n1. **Shape Check** \u2013 The function uses `assert` to make sure the two input matrices have the same number of rows and that each corresponding row has the same number of columns.\n2. **Pre\u2011allocation** \u2013 `reserve` is called both on the result vector and each row so the allocation overhead is minimized.\n3. **Element\u2011wise Multiplication** \u2013 Nested loops iterate over rows and columns, multiplying `test_tup1[i][j]` with `test_tup2[i][j]` and storing the product in the new row.\n4. **Return** \u2013 The fully populated result matrix is returned.\n\n### Usage Example\n\n```cpp\nint main()\n{\n    std::vector<std::vector<long>> a = {{1, 2, 3},\n                                        {4, 5, 6}};\n    std::vector<std::vector<long>> b = {{7, 8, 9},\n                                        {10, 11, 12}};\n\n    auto c = index_multiplication(a, b);\n\n    for (const auto& row : c) {\n        for (long v : row) std::cout << v << ' ';\n        std::cout << '\\n';\n    }\n}\n```\n\nOutput:\n\n```\n7 16 27 \n40 55 72 \n```\n\nFeel free to adapt the function for other data types or to replace `assert` with exception handling if you need runtime error checking."]}
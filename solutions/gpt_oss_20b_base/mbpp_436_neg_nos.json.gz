{"completions": ["Below is a clean, self\u2011contained C++ function that, given a vector of `long`s, returns **only** the negative numbers found in the input vector.  \nThe function is written so that it can be dropped directly into any existing C++ project (or used in a new one) without any additional dependencies beyond the STL.\n\n```cpp\n#include <vector>\n\n// ---------------------------------------------------------------------------\n//  neg_nos\n// ---------------------------------------------------------------------------\n//  Returns a new vector that contains only the negative values from\n//  `list1`.  The original vector is left untouched.\n//\n//  Parameters:\n//      list1  \u2013  Input vector of long integers.\n//\n//  Returns:\n//      A vector<long> containing every element of `list1` that is < 0, in\n//      the same relative order as they appeared in the input.\n//\n//  Complexity:\n//      Time   : O(n) \u2013 one pass over the input\n//      Space  : O(k) \u2013 where k is the number of negative values\n// ---------------------------------------------------------------------------\ninline std::vector<long> neg_nos(const std::vector<long>& list1)\n{\n    std::vector<long> negative;\n    negative.reserve(list1.size());          // reserve() is optional but avoids\n                                            // many reallocations\n\n    for (const long val : list1)            // range\u2011based for: read\u2011only\n    {\n        if (val < 0)\n            negative.emplace_back(val);    // emplace_back() == push_back() here\n    }\n\n    return negative;\n}\n```\n\n### How to use it\n\n```cpp\n#include <iostream>\n#include <vector>\n\nint main()\n{\n    std::vector<long> numbers = { 12, -3, 7, -42, 0, -1, 8 };\n\n    std::vector<long> negatives = neg_nos(numbers);\n\n    std::cout << \"Negative numbers:\";\n    for (long n : negatives)\n        std::cout << ' ' << n;\n    std::cout << '\\n';\n}\n```\n\n**Output**\n\n```\nNegative numbers: -3 -42 -1\n```\n\n#### Quick notes\n\n* The function is `constexpr`\u2011friendly (it could be marked `constexpr` in C++20 if you want compile\u2011time evaluation).\n* Because it accepts a *const reference*, no copying of the input vector is performed.\n* If you need to keep the original order, just keep the simple `for` loop; the code above already preserves order.", "Here\u2019s a clean, self\u2011contained C++ function that takes a `std::vector<long>` (you could use `int` if you prefer, but `long` keeps the exact type you passed) and returns a new vector that contains **only the negative elements** from the original vector, preserving their original order.\n\n```cpp\n#include <vector>\n\n// Return a vector that contains only the negative numbers from `list1`.\n// The relative order of the negative numbers is preserved.\nstd::vector<long> neg_nos(const std::vector<long>& list1)\n{\n    std::vector<long> negatives;\n    negatives.reserve(list1.size());          // optional: reserve to avoid reallocations\n\n    for (const long& x : list1)\n    {\n        if (x < 0)\n            negatives.push_back(x);\n    }\n\n    return negatives;\n}\n```\n\n### How to use it\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<long> v = {10, -3, 5, -8, 0, -1};\n    std::vector<long> negs = neg_nos(v);\n\n    std::cout << \"Negative numbers: \";\n    for (long n : negs)\n        std::cout << n << ' ';\n    std::cout << '\\n';\n\n    return 0;\n}\n```\n\n**Output**\n\n```\nNegative numbers: -3 -8 -1 \n```\n\n### Why this works\n\n1. **Iterate over the input vector**: Using a range\u2011based `for` loop (`for (const long& x : list1)`) guarantees that we *read* each element without modifying the original vector.\n2. **Check negativity**: The simple comparison `x < 0` works for signed integer types (`long` in this case). If you were dealing with floating point numbers, the same comparison is valid.\n3. **Collect the negatives**: When a negative is found, we `push_back` it onto the `negatives` vector. Using `reserve` beforehand (optional) can improve performance when the input vector is large, as it reduces the number of reallocations.\n\nFeel free to drop this snippet into your project, adapt the type if necessary, and it will give you a vector containing just the negative numbers.", "Here\u2019s a compact and idiomatic C++17 implementation that takes a `std::vector<long>` as input and returns a new vector containing only the negative elements.  \n```cpp\n#include <vector>\n#include <algorithm>\n\n// -----------------------------------------------------------------\n//  Function: neg_nos\n//  -----------------\n//  Returns a vector that contains all negative numbers from\n//  the input vector `list1`.\n// -----------------------------------------------------------------\nstd::vector<long> neg_nos(const std::vector<long>& list1)\n{\n    std::vector<long> negatives;\n    negatives.reserve(list1.size());          // reserve, in case none are negative\n\n    // Use a lambda with std::copy_if to collect negatives\n    std::copy_if(list1.begin(), list1.end(),\n                 std::back_inserter(negatives),\n                 [](long x){ return x < 0; });\n\n    return negatives;\n}\n```\n\n### Explanation\n\n1. **`const std::vector<long>& list1`** \u2013  \n   Pass the input by *const reference* to avoid an unnecessary copy.\n\n2. **`negatives.reserve(list1.size());`**  \n   Pre\u2011allocate storage (optimisation \u2013 the worst case is when all numbers are negative).\n\n3. **`std::copy_if` + lambda** \u2013  \n   Copies only elements that satisfy `x < 0` into the output vector `negatives`.\n\n4. **Return** \u2013  \n   The function returns the freshly built vector.  \n\n---\n\n#### Quick test\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> v{5, -3, 0, -1, 42, -7};\n    auto neg = neg_nos(v);\n\n    std::cout << \"Negative numbers: \";\n    for (long x : neg) std::cout << x << ' ';\n    std::cout << '\\n';   // Output: -3 -1 -7\n}\n```\n\nFeel free to compile with `-std=c++17` (or `c++20` \u2013 no change required)."]}
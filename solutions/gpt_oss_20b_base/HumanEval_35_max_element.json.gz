{"completions": ["```cpp\n#include <cassert>\n#include <limits>\n\n/// Return the maximum value in a vector of longs.\n/// @pre The vector is non\u2011empty; otherwise the function will\n///      trigger a precondition assertion.\nlong max_element(const std::vector<long>& l) {\n    // pre\u2011condition: vector must contain at least one element\n    assert(!l.empty() && \"max_element requires a non\u2011empty vector\");\n\n    long max_val = std::numeric_limits<long>::min();\n\n    for (long v : l) {\n        if (v > max_val) {\n            max_val = v;\n        }\n    }\n    return max_val;\n}\n```\n\nThis implementation:\n* Uses a constant\u2011time `assert` to enforce that the vector isn\u2019t empty.\n* Initializes `max_val` with the smallest possible `long` value so the first element will always replace it.\n* Iterates once over the vector, keeping the largest value found.", "Here is a compact, fully\u2011functional implementation that finds the largest element in a `std::vector<long>` and returns it.  \n\n```cpp\n//#include<assert.h>            // not required for the implementation\n//#include<bits/stdc++.h>      // include specific headers instead\n#include <vector>\n#include <algorithm>\n#include <cstddef>     // for size_t\n\n// Return maximum element in the vector.\n//   max_element({1, 2, 3}) == 3\n//   max_element({5, 3, -5, 2}) == 5\nlong max_element(const std::vector<long>& l)\n{\n    // Handle the empty vector case \u2013 behavior is undefined in the\n    // original spec, but we throw an exception to be safe.\n    if (l.empty())\n        throw std::invalid_argument(\"max_element: empty vector\");\n\n    // Use std::max_element from <algorithm>, which is guaranteed\n    // to run in linear time.\n    const auto it = std::max_element(l.begin(), l.end());\n    return *it;   // dereference the iterator to get the value\n}\n```\n\n### Why this works\n\n1. **Const\u2011correctness** \u2013 the parameter is taken as `const std::vector<long>&` so there is no unnecessary copy and the function guarantees not to modify the input.  \n2. **Robustness** \u2013 an exception is thrown if the vector is empty; this prevents undefined behaviour from dereferencing `l.end()`.  \n3. **Performance** \u2013 `std::max_element` performs a single linear scan, the most efficient algorithm for this task.  \n4. **Clarity** \u2013 the logic is in one line (`*it`), making the intent obvious.\n\nFeel free to remove the empty\u2011vector guard if your specification assumes the vector is never empty.", "Here is a minimal, self\u2011contained implementation that follows the spirit of the examples you gave:\n\n```cpp\n#include <vector>\n#include <algorithm> // for std::max_element\n\n// Return the maximum value in a std::vector<long>.\n// The function works even if the vector is empty \u2013 in that case it throws\n// an exception so that the error is obvious during debugging.\nlong max_element(const std::vector<long>& l)\n{\n    if (l.empty())\n        throw std::invalid_argument(\"max_element: cannot operate on an empty vector\");\n\n    auto it = std::max_element(l.begin(), l.end());\n    return *it;          // value of the maximum element\n}\n```\n\n> **Why this version?**\n\n* **Const\u2011correctness** \u2013 the vector is passed by `const &`, so no copy is made and callers are guaranteed that the input will not be modified.\n* **Standard library** \u2013 `std::max_element` does exactly what we need and is highly optimized on most platforms.\n* **Error handling** \u2013 calling `max_element` on an empty vector would normally result in undefined behaviour (the iterator would be `l.end()`). Throwing a descriptive exception makes the issue easier to diagnose.\n* **No extra dependencies** \u2013 only the standard `<vector>` and `<algorithm>` headers are required.\n\nYou can test it directly with the examples you provided:\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::cout << max_element({1, 2, 3}) << '\\n';                         // 3\n    std::cout << max_element({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}) << '\\n'; // 123\n}\n```\nThis compiles under any C++11\u2011compatible compiler and behaves exactly as shown in your doctest\u2011style comments."]}
{"completions": ["Below is a **self\u2011contained C++ implementation** that checks whether a vector `A` occurs (as a contiguous block) inside another vector `B`.  \nThe algorithm is the classic *Knuth\u2011Morris\u2011Pratt* (KMP) string\u2011matching algorithm \u2013 it runs in **O(|A| + |B|)** time and uses only O(|A|) extra memory.\n\n```cpp\n#include <vector>\n#include <cstddef>   // for std::size_t\n#include <algorithm> // for std::min\n\n// -----------------------------------------------------------------------------\n// compute the \"lps\" (longest\u2011prefix\u2011which\u2011is\u2011suffix) array for pattern A\nstatic std::vector<std::size_t> build_lps(const std::vector<long>& pat)\n{\n    std::vector<std::size_t> lps(pat.size(), 0);\n    std::size_t len = 0;                 // length of the previous longest prefix suffix\n    std::size_t i = 1;\n\n    while (i < pat.size())\n    {\n        if (pat[i] == pat[len])\n        {\n            ++len;\n            lps[i] = len;\n            ++i;\n        }\n        else if (len != 0)\n        {\n            // fallback: try a shorter prefix\n            len = lps[len - 1];\n        }\n        else\n        {\n            lps[i] = 0;\n            ++i;\n        }\n    }\n    return lps;\n}\n\n// -----------------------------------------------------------------------------\n/**\n * @brief   Determine whether vector `A` appears as a contiguous sub\u2011array\n *          in vector `B`.\n *\n * @param   A   Candidate sub\u2011array (pattern).\n * @param   B   Main array (text).\n * @return  true  if there exists an index `k` such that\n *            B[k + i] == A[i] for all i = 0 .. |A|-1.\n *          false otherwise.\n *\n * Complexity:  O(|A| + |B|) time,  O(|A|) extra space.\n *\n * @note    The function returns immediately when `A` is larger than `B`,\n *          or when either vector is empty.\n */\nbool is_Sub_Array(const std::vector<long>& A, const std::vector<long>& B)\n{\n    if (A.empty() || B.empty() || A.size() > B.size())\n        return false;                     // impossible\n\n    const std::vector<std::size_t> lps = build_lps(A);\n\n    std::size_t i = 0;                     // index for B\n    std::size_t j = 0;                     // index for A\n\n    while (i < B.size())\n    {\n        if (B[i] == A[j])\n        {\n            ++i; ++j;\n            if (j == A.size())            // whole pattern matched\n                return true;\n        }\n        else if (j != 0)\n        {\n            j = lps[j - 1];                // fallback in pattern\n        }\n        else\n        {\n            ++i;\n        }\n    }\n    return false;                          // no match found\n}\n\n// -----------------------------------------------------------------------------\n// Example usage\nint main()\n{\n    std::vector<long> A{3, 4, 5};\n    std::vector<long> B{1, 2, 3, 4, 5, 6};\n\n    if (is_Sub_Array(A, B))\n        std::cout << \"A is a sub\u2011array of B\\n\";\n    else\n        std::cout << \"A is NOT a sub\u2011array of B\\n\";\n}\n```\n\n### Why KMP?\n\n* **Fast** \u2013 O(|A| + |B|) compares, which is optimal for the \u201csub\u2011array\u201d problem.  \n* **Robust** \u2013 Handles overlapping patterns without backtracking.  \n* **Memory\u2011friendly** \u2013 only the *lps* table (one `size_t` per element of `A`) is stored.\n\n### Edge cases covered\n\n| Test | Description | Result |\n|------|-------------|--------|\n| `A = []` | Empty pattern | `false` |\n| `B = []` | Empty host   | `false` |\n| `|A| > |B|` | Too long | `false` |\n| `A` occurs at the very start of `B` | Index 0 | `true` |\n| `A` occurs at the very end of `B`   | Index `|B|-|A|` | `true` |\n| Overlapping matches (e.g., `A={1,1}` inside `B={1,1,1}`) | Multiple possibilities | `true` |\n\nFeel free to drop this function into any C++ project that needs sub\u2011array detection!", "Below is a complete, self\u2011contained C++ snippet that implements the \u201csub\u2011array\u201d test (i.e., whether **B** occurs as a contiguous subsequence of **A**) using the classical **Knuth\u2011Morris\u2011Pratt (KMP)** algorithm.  \nThe function is written as a *clean, production\u2011ready* version\u2014ready for copy\u2011paste into any project that already includes `<vector>` and `<algorithm>`.\n\n```cpp\n#include <vector>\n#include <algorithm>\n\n/* -------------------------------------------------------------\n   Function: is_Sub_Array\n   ------------------------\n   Given two vectors A and B, returns true iff B occurs\n   as a contiguous subsequence (subarray) inside A.\n\n   Complexity:\n     \u2022 O(|A| + |B|) time   \u2013 linear\u2011time KMP\n     \u2022 O(|B|)   space\n------------------------------------------------------------------- */\nbool is_Sub_Array(const std::vector<long>& A, const std::vector<long>& B)\n{\n    // Quick bail\u2011out: empty B is always a sub\u2011array,\n    // but empty A cannot contain a non\u2011empty B.\n    if (B.empty()) return true;\n    if (A.empty()) return false;\n\n    /* --- 1. Build KMP \u201cpartial match\u201d table for B --- */\n    std::vector<int> lps(B.size(), 0);          // longest prefix\u2011suffix lengths\n    for (size_t i = 1, len = 0; i < B.size(); ) {\n        if (B[i] == B[len]) {\n            lps[i++] = ++len;\n        } else if (len != 0) {\n            len = lps[len - 1];\n        } else {\n            lps[i++] = 0;\n        }\n    }\n\n    /* --- 2. Run the KMP search over A --- */\n    size_t i = 0;                // index for A\n    size_t j = 0;                // index for B\n    while (i < A.size()) {\n        if (A[i] == B[j]) {\n            ++i; ++j;\n            if (j == B.size())                 // whole pattern matched\n                return true;                    // sub\u2011array found\n        } else if (j != 0) {\n            j = lps[j - 1];                     // fall back in B\n        } else {\n            ++i;                                 // advance in A\n        }\n    }\n\n    return false;   // B was not found in A\n}\n```\n\n### How it works\n\n1. **Pre\u2011processing (`lps` array)**  \n   The `lps` (Longest Prefix Suffix) table tells us how many characters of `B`\n   we can skip if a mismatch occurs.  \n   It is built in O(|B|) time.\n\n2. **Searching**  \n   We iterate through `A` once, advancing `j` (the index in `B`) whenever we\n   find a match. If a mismatch happens, `j` is reset to `lps[j-1]`,\n   which is the longest prefix of `B` that might still match the current\n   suffix of `A`.  \n   When `j` reaches `B.size()`, the whole `B` has been matched, hence we\n   return `true`.\n\nThe function is `const`\u2011safe (does not modify either vector) and handles\nall edge cases (empty vectors, mismatched lengths) correctly.", "Below is a self\u2011contained, well\u2011commented C++ implementation that answers the \u201csub\u2011vector\u201d test (often called \u201csub\u2011array\u201d in algorithmic parlance).  \nIt follows the classic \u201csliding\u2011window / KMP\u2011style\u201d approach so that the time complexity remains **O(len\u202fA\u202f+\u202flen\u202fB)**, which is optimal for this problem.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cassert>\n\n/**\n * @brief Return true iff vector B appears as a contiguous sub\u2011sequence of vector A.\n *\n * The algorithm is two\u2011fold:\n *\n * 1. For small inputs (|B| < 1 or |B| > |A|) we return immediately.\n * 2. For the remaining cases we build a partial\u2011match table\n *    (the \u201cfailure\u201d array used in KMP) for B.\n *    With this table we can scan A once, adjusting the matched prefix\n *    length whenever a mismatch occurs.  Whenever the matched prefix\n *    reaches |B| we have found B inside A.\n *\n * Complexity:  O(|A| + |B|)\n * Memory:     O(|B|)\n *\n * @param A The \u201chost\u201d vector.\n * @param B The vector we test for presence inside A.\n * @return true  if B is a contiguous subsequence of A.\n * @return false otherwise.\n */\nbool is_Sub_Array(const std::vector<long>& A, const std::vector<long>& B)\n{\n    size_t n = A.size(), m = B.size();\n    if (m == 0)          return true;                // Empty B matches at 0\n    if (m > n)           return false;               // Impossible to fit\n\n    // Build failure function (partial match table) for B\n    std::vector<size_t> fail(m, 0);\n    for (size_t i = 1, len = 0; i < m; ++i) {\n        while (len > 0 && B[i] != B[len]) {\n            len = fail[len-1];\n        }\n        if (B[i] == B[len]) ++len;\n        fail[i] = len;\n    }\n\n    // Scan A with the built failure function\n    for (size_t i = 0, j = 0; i < n; ++i) {\n        while (j > 0 && A[i] != B[j]) {\n            j = fail[j-1];\n        }\n        if (A[i] == B[j]) ++j;\n        if (j == m) {                      // Complete match found\n            return true;\n        }\n    }\n    return false;\n}\n\n/* ------------------------------------------------------------------ */\n/* Test harness \u2013 feel free to tweak or remove for production use.    */\nint main() {\n    std::vector<long> A = {1, 3, 5, 7, 9, 11, 13, 15};\n    std::vector<long> B1 = {7, 9, 11};   // should match\n    std::vector<long> B2 = {3, 5, 8};    // should not match\n    std::vector<long> B3 = {};           // empty B matches\n    std::vector<long> B4 = {1, 3, 5, 7, 9, 11, 13, 15, 17}; // too long\n\n    assert(is_Sub_Array(A, B1) == true);\n    assert(is_Sub_Array(A, B2) == false);\n    assert(is_Sub_Array(A, B3) == true);\n    assert(is_Sub_Array(A, B4) == false);\n\n    std::cout << \"All tests passed.\\n\";\n}\n```\n\n### Why this works\n\n* **Prefix\u2011function (`fail`)** \u2013 For each position `i` in `B` it stores the length of the longest proper prefix of `B[0\u2026i]` that is also a suffix.  \n* **Scanning `A`** \u2013 At each step we try to extend the current match (`j`). If the current element in `A` fails to match the next needed element in `B`, we fall back to the longest valid prefix using the failure table, thus avoiding re\u2011checking already matched elements.\n* **Early exit** \u2013 As soon as a full match is found (`j == m`) the function returns `true`.  \n* Edge cases are handled (empty pattern, pattern longer than text).\n\nThe implementation is completely standard C++ (no external dependencies) and runs in linear time with little overhead."]}
{"completions": ["Below is a minimal, self\u2011contained implementation of the requested function along with a short test\u2011suite that demonstrates its usage.  \nThe function `sum_list` takes two `std::vector<long>` objects and returns a new vector that contains the element\u2011wise sum of the two input vectors.  \nIf the vectors are of unequal length we simply raise an `std::invalid_argument` exception \u2013 that is usually the safest and most explicit behaviour for a \u201cvector addition\u201d routine.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <stdexcept>\n#include <cassert>\n\n/**\n * @brief  Returns the element\u2011wise sum of two vectors.\n *\n * @param   lst1   First input vector (size n)\n * @param   lst2   Second input vector (size n)\n *\n * @return  A new vector of size n where each element is `lst1[i] + lst2[i]`.\n *\n * @throws  std::invalid_argument if the input vectors differ in size.\n */\nstd::vector<long> sum_list(const std::vector<long>& lst1,\n                           const std::vector<long>& lst2)\n{\n    if (lst1.size() != lst2.size()) {\n        throw std::invalid_argument(\"Vectors must have the same length\");\n    }\n\n    std::vector<long> res;\n    res.reserve(lst1.size());     // reserve memory up front (optional)\n    for (std::size_t i = 0; i < lst1.size(); ++i) {\n        res.emplace_back(lst1[i] + lst2[i]);\n    }\n    return res;\n}\n\n/* ---------- small test harness ---------- */\nint main()\n{\n    /* --- example 1 --- */\n    std::vector<long> v1{1, 2, 3};\n    std::vector<long> v2{4, 5, 6};\n    auto sum = sum_list(v1, v2);          // {5, 7, 9}\n    assert(sum == std::vector<long>{5, 7, 9});\n    std::cout << \"Example 1 OK\\n\";\n\n    /* --- example 2: non\u2011empty vectors of different lengths --- */\n    std::vector<long> v3{10, 20, 30, 40};\n    std::vector<long> v4{1, 2, 3};\n    try {\n        auto s = sum_list(v3, v4);         // throws\n        (void)s; // silence unused variable\n        assert(false && \"Expected exception not thrown\");\n    } catch (const std::invalid_argument& e) {\n        std::cout << \"Caught expected exception: \" << e.what() << '\\n';\n    }\n\n    /* --- example 3: empty vectors --- */\n    std::vector<long> empty1, empty2;\n    auto empty_sum = sum_list(empty1, empty2);   // {}\n    assert(empty_sum.empty());\n    std::cout << \"Example 3 (empty vectors) OK\\n\";\n\n    std::cout << \"All tests passed.\\n\";\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Signature**  \n   ```cpp\n   std::vector<long> sum_list(const std::vector<long>& lst1,\n                              const std::vector<long>& lst2)\n   ```\n   Using `const&` for the inputs prevents unnecessary copies and permits the function to work with rvalue or lvalue vectors.\n\n2. **Size check**  \n   The function verifies the two input vectors have the same length. If not, it throws a `std::invalid_argument`.  \n   This choice is deliberate: silently truncating or padding one vector can mask logical errors in the caller\u2019s code.\n\n3. **Summation loop**  \n   A simple `for` loop iterates over the indices, adding corresponding elements and pushing the result into the output vector.  \n   `res.reserve(lst1.size())` pre\u2011allocates the required capacity, which avoids repeated re\u2011allocations for large vectors.\n\n4. **Return**  \n   The resulting vector `res` is returned. Since C++17 it will be moved automatically if the caller stores it in a new vector.\n\n5. **Test harness**  \n   The `main()` function contains three tiny tests:\n   * Two non\u2011empty vectors of the same size \u2192 correct sum.\n   * Mismatched sizes \u2192 exception is thrown.\n   * Two empty vectors \u2192 returns an empty vector.\n\nCompile and run (use `-std=c++17` or newer):\n\n```bash\ng++ -std=c++17 -Wall -Wextra -O2 sum_list.cpp -o sum_list\n./sum_list\n```\n\nOutput:\n\n```\nExample 1 OK\nCaught expected exception: Vectors must have the same length\nExample 3 (empty vectors) OK\nAll tests passed.\n```\n\nFeel free to adapt the error handling or optimize further depending on your project\u2019s requirements!", "Here is a small, clean implementation of the requested function in C++17 (or later).  \nThe function simply adds element\u2011wise two input vectors and returns a new vector with the sums.  \nIf the vectors are of different lengths we throw an exception \u2013 you can change this to any behaviour you prefer.\n\n```cpp\n#include <vector>\n#include <stdexcept>   // std::length_error\n#include <cstddef>     // std::size_t\n\n// Add two vectors element\u2011wise.\n// If the vectors differ in size, a length_error is thrown.\nstd::vector<long> sum_list(const std::vector<long>& lst1,\n                           const std::vector<long>& lst2)\n{\n    if (lst1.size() != lst2.size()) {\n        throw std::length_error(\"Vectors must have the same length\");\n    }\n\n    std::vector<long> result;\n    result.reserve(lst1.size());          // pre\u2011allocate for speed\n\n    for (std::size_t i = 0; i < lst1.size(); ++i) {\n        result.push_back(lst1[i] + lst2[i]);\n    }\n\n    return result;\n}\n```\n\n### Usage example\n\n```cpp\nint main() {\n    std::vector<long> a{1, 2, 3};\n    std::vector<long> b{4, 5, 6};\n\n    auto c = sum_list(a, b);   // c == {5, 7, 9}\n}\n```\n\nFeel free to adjust error handling (e.g. return an empty vector or truncate) depending on your needs.", "**Solution Explanation**\n\nWe just need to add the elements of two vectors of equal length element\u2011by\u2011element and return the resulting vector.  \nThe function will\n\n1. check that the two input vectors have the same size (otherwise it will throw an exception),\n2. create a result vector of that size,\n3. add corresponding elements,\n4. return the result.\n\nBelow is a clean C++ implementation that also includes a small test in `main()`.\n\n```cpp\n#include <vector>\n#include <stdexcept>\n#include <iostream>\n\n// ----------------------------------------------------------------------\n// sum_list\n//\n// Adds two vectors element\u2011wise.\n//\n// Preconditions:\n//   - contents of the vectors are of type `long`\n//   - both vectors have the same size\n//\n// Postconditions:\n//   - returns a new vector where result[i] = lst1[i] + lst2[i]\n//   - if the sizes differ, std::invalid_argument is thrown\n// ----------------------------------------------------------------------\nstd::vector<long> sum_list(const std::vector<long>& lst1,\n                          const std::vector<long>& lst2) {\n    if (lst1.size() != lst2.size())\n        throw std::invalid_argument(\"Vectors must have the same size\");\n\n    std::vector<long> result;\n    result.reserve(lst1.size());                 // reserve capacity once\n\n    for (size_t i = 0; i < lst1.size(); ++i)\n        result.push_back(lst1[i] + lst2[i]);\n\n    return result;\n}\n\n// ----------------------------------------------------------------------\n// Demo: Reading two vectors, summing them and printing the result\n// ----------------------------------------------------------------------\nint main() {\n    // Example vectors\n    std::vector<long> a = {1, 2, 3, 4};\n    std::vector<long> b = {10, 20, 30, 40};\n\n    try {\n        std::vector<long> c = sum_list(a, b);\n\n        std::cout << \"Result: \";\n        for (auto val : c)\n            std::cout << val << ' ';\n        std::cout << '\\n';\n    } catch (const std::exception& ex) {\n        std::cerr << \"Error: \" << ex.what() << '\\n';\n        return 1;\n    }\n\n    return 0;\n}\n```\n\n### Key points\n\n- **Const\u2011reference parameters** avoid copying the input vectors.\n- **`reserve()`** improves performance by avoiding repeated reallocations.\n- The function is **exception safe**; it throws if the input sizes differ, ensuring callers handle the error explicitly.\n\nThis implementation is concise, follows modern C++ best practices, and can be used directly in any project."]}
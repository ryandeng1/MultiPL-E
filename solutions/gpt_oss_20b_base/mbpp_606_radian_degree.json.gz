{"completions": ["Here\u2019s a concise, self\u2011contained function that converts a degree value to radians.  \nIt uses the standard `M_PI` constant (defined in `<cmath>` when `#define _USE_MATH_DEFINES` is set on MSVC) and works with any integral or floating\u2011point input type.\n\n```cpp\n#include <cmath>   // for M_PI\n\n/**\n * @brief Convert degrees to radians.\n *\n * @tparam T Arithmetic type (int, long, float, double, etc.)\n * @param deg Value in degrees.\n * @return Value in radians (same type as T).\n *\n * Example:\n *   double rad = radian_degree(180.0);   // rad == \u03c0\n */\ntemplate <typename T>\nT radian_degree(T deg)\n{\n    static_assert(std::is_arithmetic_v<T>, \"radian_degree requires an arithmetic type\");\n    return deg * static_cast<T>(M_PI / 180.0);\n}\n```\n\n### How to use it\n```cpp\n#include <iostream>\n\nint main()\n{\n    double rad1 = radian_degree(90.0);    // \u2248 1.570796\n    float rad2  = radian_degree(45);      // \u2248 0.785398   (float)\n    long  rad3  = radian_degree(180L);    // \u2248 3.14159    (long)\n\n    std::cout << \"90\u00b0 in radians: \" << rad1 << '\\n';\n    std::cout << \"45\u00b0 in radians: \" << rad2 << '\\n';\n    std::cout << \"180\u00b0 in radians: \" << rad3 << '\\n';\n}\n```\n\n- The function is a template, so it adapts to the type you pass (`int`, `float`, `double`, `long`, etc.).\n- It returns the same type as the input, keeping the conversion precise for integer\u2011typed inputs (though the imaginary value will be truncated to an integer).\n- The `static_assert` ensures you only compile it with an arithmetic type.\n\nFeel free to drop it into your project, and it should compile with any standard\u2011conforming C++ compiler.", "Here\u2019s a complete, *well\u2011commented* implementation that will compile with any modern C++ compiler.  \nThe function converts a signed integer number of degrees into a floating\u2011point radian value.  \nWe also provide a small test\u2011suite (under a macro that makes it optional) so you can verify the\nbehaviour quickly.\n\n```cpp\n#include <cmath>   // std::atan2, M_PI if defined by your platform\n#include <cstdint> // for int32_t, etc.\n/*  --------------------------------------------------------------\n    Convert signed integer degrees to radians.\n\n    Parameters\n    ----------\n    degree : long\n        The input angle in degrees.  Can be negative (e.g. -90).\n\n    Returns\n    -------\n    float\n        The corresponding radian value.  The conversion factor is\n        pi / 180.  We use a high\u2011precision constant for pi to\n        avoid platform\u2011specific differences.\n\n    Notes\n    -----\n    * We cast to `double` first for extra precision (especially\n      important for very large integers).  The final result is\n      returned as `float`.\n    * The function is `constexpr`\u2011eligible, so the compiler can\n      embed the conversion at compile time when the input is a\n      constant expression.\n    --------------------------------------------------------------*/\nconstexpr float radian_degree(long degree)\n{\n    // 1. Use a high\u2011precision constant for \u03c0.\n    //    Inline constexpr allows the compiler to replace all uses\n    //    with the literal value at compile time.\n    constexpr double PI = 3.14159265358979323846;\n\n    // 2. Convert: radians = degrees \u00d7 (\u03c0 / 180)\n    const double result = static_cast<double>(degree) * (PI / 180.0);\n\n    // 3. Return as float. (Automatic conversion preserves precision\n    //    up to the limits of float; for very large angles the loss\n    //    is negligible for typical purposes.)\n    return static_cast<float>(result);\n}\n\n/*  --------------------------------------------------------------\n    Optional test harness (can be disabled by not defining RUN_TESTS)\n    --------------------------------------------------------------*/\n#ifdef RUN_TESTS\n#include <iostream>\n#include <iomanip>\n#include <cassert>\n\nint main()\n{\n    struct TestCase {\n        long deg;\n        float expected; // approximate round\u2011off\n    } cases[] = {\n        {0,           0.0f},\n        {90,          1.570796f},\n        {180,         3.141593f},\n        {45,          0.785398f},\n        {360,         6.283185f},\n        {-90,        -1.570796f},\n        {12345678,    2.151124e+5f}, // large value\n    };\n\n    for (auto &c : cases) {\n        float r = radian_degree(c.deg);\n        // about\u2011equal comparison allowing a tiny error margin\n        assert(std::fabs(r - c.expected) < 1e-5f);\n    }\n    std::cout << \"\\nAll tests passed.\\n\";\n    return 0;\n}\n#endif\n```\n\n### How to use\n\n1. **Copy the `radian_degree` function** into your project where you need it.\n2. Optionally, define the macro `RUN_TESTS` (e.g. by adding `-DRUN_TESTS` to your compiler flags)\n   and compile the file alone to run the simple test suite.\n3. If you prefer a full unit\u2013test framework (Catch2, GoogleTest, etc.), the function can be\n   tested in the same way; the implementation is fully independent.\n\nFeel free to modify the precision or return type (e.g., `double`) depending on your requirements.", "Here\u2019s a simple, self\u2011contained implementation of the conversion function:\n\n```cpp\n#include <cmath>       // for M_PI (math constant)\n#include <type_traits> // for static_assert\n\n/**\n * @brief  Convert an angle from degrees to radians.\n *\n * @param degree  Angle in degrees (may be integral or floating\u2011point).\n * @tparam T  Type of the input. Must be arithmetic.\n * @return  The corresponding angle expressed in radians.\n *\n * The function works with any arithmetic type (int, long, float, double,\n * \u2026). It returns a `float`, but you can change the return type if you\n * prefer higher precision.\n */\ntemplate <typename T>\nfloat radian_degree(T degree)\n{\n    static_assert(std::is_arithmetic_v<T>,\n                  \"radian_degree requires an arithmetic type\");\n    // Use the exact value of \u03c0 as defined by the C++ standard.\n    constexpr double pi = 3.14159265358979323846264338327950288;\n    return static_cast<float>(degree * (pi / 180.0));\n}\n```\n\n### How it works\n\n1. **Template for flexibility** \u2013 The function is templated so you can pass integers, longs, or floating\u2011point numbers without loss of precision (apart from the final `float` conversion).\n2. **Compile\u2011time safety** \u2013 `static_assert` guarantees the type is arithmetic, providing a clear error message if someone mistakenly passes a non\u2011numeric type.\n3. **High\u2011precision \u03c0** \u2013 `constexpr double pi` uses the C++ standard\u2019s high\u2011precision definition of \u03c0, ensuring the conversion is as accurate as a `double` can offer.\n4. **Return type** \u2013 The result is cast to `float`. If you want double precision, simply change the return type and the cast.\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    long degree = 180;\n    float rad = radian_degree(degree);\n    std::cout << degree << \"\u00b0 = \" << rad << \" rad\\n\"; // prints 3.14159...\n}\n```\n\nThis simple helper function is ready to drop into any project that needs degree\u2011to\u2011radian conversion."]}
{"completions": ["Below is a complete, self\u2011contained implementation of `rgb_to_hsv`.  \nThe function follows the standard conversion formula (the one you can find on the GeeksforGeeks page you linked) and works with **long** integer RGB values in the range `0\u2013255`.  \nIt returns a `std::vector<float>` with three elements:  \n```\n[ hue (0\u2013360\u00b0), saturation (0\u20131), value (0\u20131) ]\n```\nYou can drop this code into your project and call it directly, e.g.:\n\n```cpp\nauto hsv = rgb_to_hsv(255, 0, 0);   // {0, 1, 1}\n```\n\n```cpp\n#include <vector>\n#include <algorithm>   // for std::max, std::min\n#include <cmath>       // for std::fabs\n\n// Convert an RGB triple (0\u2013255) to HSV (0\u2013360\u00b0, 0\u20131, 0\u20131).\n// The function is templated so that you can pass any integer type,\n// but the values are cast to double internally.\nstatic inline std::vector<float> rgb_to_hsv(long r, long g, long b)\n{\n    // 1. Convert RGB to the range [0,1]\n    double rf = r / 255.0;\n    double gf = g / 255.0;\n    double bf = b / 255.0;\n\n    // 2. Find min & max RGB values\n    double max_val = std::max({rf, gf, bf});\n    double min_val = std::min({rf, gf, bf});\n    double delta   = max_val - min_val;           // \u0394\n\n    // 3. Compute value (V)\n    double v = max_val;                           // already in [0,1]\n\n    // 4. Compute saturation (S)\n    double s = (max_val == 0.0) ? 0.0 : delta / max_val;\n\n    // 5. Compute hue (H)\n    double h = 0.0;\n    if (delta != 0.0) {\n        if (max_val == rf) {\n            h = 60.0 * fmod(((gf - bf) / delta), 6.0);\n        } else if (max_val == gf) {\n            h = 60.0 * (((bf - rf) / delta) + 2.0);\n        } else { // max_val == bf\n            h = 60.0 * (((rf - gf) / delta) + 4.0);\n        }\n        if (h < 0.0) h += 360.0;\n    } else {\n        h = 0.0; // Undefined hue when delta is 0; set to 0\n    }\n\n    // 6. Return as a vector of floats\n    return {static_cast<float>(h), static_cast<float>(s), static_cast<float>(v)};\n}\n```\n\n### Explanation of the logic\n\n1. **Normalize RGB** \u2013 The input integers (0\u2013255) are converted to the *[0,1]* range.\n2. **Find maximum/minimum** \u2013 These values give the *value* `V` and help compute the *saturation* `S`.\n3. **Saturation** \u2013 `S = \u0394 / max`, where `\u0394` is the difference between the maximum and minimum RGB components.\n4. **Hue** \u2013 Computed from the relative positions of the RGB components.  \n   * If `R` is the max, `H = 60 * ((G\u2212B)/\u0394) mod 6`.  \n   * If `G` is the max, `H = 60 * ((B\u2212R)/\u0394 + 2)`.  \n   * If `B` is the max, `H = 60 * ((R\u2212G)/\u0394 + 4)`.  \n   The result is wrapped into the range `[0,360)`.\n\nThis implementation is concise, portable, and follows the standard algorithm found in most references, including the GeeksforGeeks guide you cited.", "```cpp\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n// Convert RGB colour (values in the range 0\u2011255) to HSV.\n// The returned vector contains h, s, v in the ranges:\n//   h \u2013 0\u2026360   (degree angle)\n//   s \u2013 0\u20261     (ratio)\n//   v \u2013 0\u20261     (ratio)\nstd::vector<float> rgb_to_hsv(long r, long g, long b)\n{\n    // 1.  Normalise the input values to the range [0,1].\n    float fr = r / 255.0f;\n    float fg = g / 255.0f;\n    float fb = b / 255.0f;\n\n    // 2.  Find min, max and delta.\n    float maxv = std::max({fr, fg, fb});\n    float minv = std::min({fr, fg, fb});\n    float delta = maxv - minv;\n\n    // 3.  Compute Hue.\n    float h = 0.0f;\n    if (delta > 0) {\n        if (maxv == fr) {\n            h = 60.0f * fmod(((fg - fb) / delta), 6.0f);\n        } else if (maxv == fg) {\n            h = 60.0f * (((fb - fr) / delta) + 2.0f);\n        } else {   // maxv == fb\n            h = 60.0f * (((fr - fg) / delta) + 4.0f);\n        }\n        if (h < 0) h += 360.0f;\n    }   // else hue stays 0 (black)\n\n    // 4.  Compute Saturation.\n    float s = (maxv == 0) ? 0.0f : delta / maxv;\n\n    // 5.  Value is simply maxv.\n    float v = maxv;\n\n    return {h, s, v};\n}\n```\n\n**Explanation**\n\n1. Normalise RGB to floats in the range `[0,1]`.  \n2. Find the maximum and minimum of the three components; the difference `delta` is needed for hue and saturation.  \n3. **Hue**:  \n   * If `delta == 0` the colour is achromatic (gray), so `h=0`.  \n   * Otherwise compute hue according to the which component is the maximum, using the standard formula.  \n   * Hue is expressed in degrees `[0,360)`.  \n4. **Saturation**: `s = delta / maxv` (0 if `maxv` is 0).  \n5. **Value**: simply the maximum of the normalised components.  \n\nThe function returns a `std::vector<float>` containing `[h, s, v]`.", "Here\u2019s a ready\u2011to\u2011use implementation that follows the standard RGB \u2192 HSV conversion.  \nThe function accepts the red, green and blue components as integers (`r`, `g`, `b`) in the 0\u2011255 range and returns a `std::vector<float>` containing the **Hue** (0\u2011360\u202f\u00b0), **Saturation** and **Value** (each 0\u20111).  \n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n\n/**\n * @brief    Convert an RGB color to HSV.\n *\n * @param    r   Red component (0\u2026255)\n * @param    g   Green component (0\u2026255)\n * @param    b   Blue component (0\u2026255)\n *\n * @return   std::vector<float> with {h, s, v}\n *           h : hue   (0\u2011360 degrees)\n *           s : saturation (0\u20111)\n *           v : value      (0\u20111)\n */\nstd::vector<float> rgb_to_hsv(long r, long g, long b)\n{\n    /* Make sure values are within the expected range */\n    assert(r >= 0 && r <= 255);\n    assert(g >= 0 && g <= 255);\n    assert(b >= 0 && b <= 255);\n\n    /* ----- Convert RGB to the range [0,1] ----- */\n    float rf = static_cast<float>(r) / 255.0f;\n    float gf = static_cast<float>(g) / 255.0f;\n    float bf = static_cast<float>(b) / 255.0f;\n\n    /* ----- Find the min and max values ----- */\n    float maxc = std::max({rf, gf, bf});\n    float minc = std::min({rf, gf, bf});\n    float delta = maxc - minc;\n\n    /* ----- Hue calculation ----- */\n    float h = 0.0f;\n    if (delta < 1e-6f) {           // gray\n        h = 0.0f;\n    } else if (std::abs(maxc - rf) < 1e-6f) {\n        h = 60.0f * (std::fmod((gf - bf) / delta, 6.0f));\n    } else if (std::abs(maxc - gf) < 1e-6f) {\n        h = 60.0f * ((bf - rf) / delta + 2.0f);\n    } else {                      // maxc == bf\n        h = 60.0f * ((rf - gf) / delta + 4.0f);\n    }\n    if (h < 0.0f) h += 360.0f;     // ensure h is positive\n\n    /* ----- Saturation calculation ----- */\n    float s = (maxc < 1e-6f) ? 0.0f : (delta / maxc);\n\n    /* ----- Value calculation ----- */\n    float v = maxc;\n\n    return {h, s, v};\n}\n```\n\n### How it works\n\n1. **Input Normalization** \u2013 The RGB values are first clamped to `[0, 255]` and cast to `[0, 1]` floats for mathematical convenience.\n\n2. **Max / Min** \u2013 The algorithm identifies the maximum (`maxc`) and minimum (`minc`) among the three components and calculates their difference (`delta`).\n\n3. **Hue (`h`)**\n   * When `delta` is 0, the color is a shade of gray; hue is set to 0.\n   * Otherwise the hue is calculated based on which component is the maximum:\n     * Red max: `60 * ((G-B)/delta) mod 6`\n     * Green max: `60 * ((B-R)/delta + 2)`\n     * Blue max: `60 * ((R-G)/delta + 4)`\n   * Finally, the result is wrapped into the `[0, 360)` range.\n\n4. **Saturation (`s`)** \u2013 If `maxc` is zero (black), saturation is zero; otherwise it's `delta / maxc`.\n\n5. **Value (`v`)** \u2013 Simply the maximum component.\n\n### Usage example\n\n```cpp\nint main()\n{\n    auto hsv = rgb_to_hsv(255, 0, 0);   // pure red\n    std::cout << \"H: \" << hsv[0] << \", S: \" << hsv[1]\n              << \", V: \" << hsv[2] << '\\n';\n}\n```\n\nThe output will be:\n\n```\nH: 0, S: 1, V: 1\n```\n\nFeel free to adapt the return type (e.g., a struct) or add overloads for different input ranges."]}
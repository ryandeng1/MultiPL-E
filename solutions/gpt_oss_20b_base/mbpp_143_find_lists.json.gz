{"completions": ["Here is a complete, self\u2011contained implementation that does exactly what you\u2019re looking for:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <any>\n#include <typeinfo>\n\n/*  -------------------------------------------------------------\n    find_lists\n    -------------\n    The function receives an std::vector<std::any> and returns\n    the number of elements that are *vectors* (i.e. std::vector<...>).\n    The implementation checks the dynamic type of each std::any\n    object with a small helper that tries to cast it to any std::vector\n    specialization.  If the cast succeeds we have found a vector.\n    ----------------------------------------------------------------------*/\nsize_t find_lists(const std::vector<std::any>& input)\n{\n    size_t counter = 0;\n\n    for (const auto& elem : input)\n    {\n        // We don't care what kind of vector it is.\n        // If std::any_cast succeeds with any std::vector<...> (any element type),\n        // we consider it to be a vector.\n        try\n        {\n            // The cast template parameter only specifies the container:\n            // we use `auto` to absorb any elemental type.\n            // This requires C++17 or newer for std::any.\n            using V = std::vector<int>;          // dummy type just to make the\n            (void)std::any_cast<V>(elem);        // cast compile\u2011time type.\n            // If we reach here, the cast succeeded.\n            ++counter;\n        }\n        catch (const std::bad_any_cast&)\n        {\n            // Element is not a vector \u2192 ignore.\n        }\n    }\n\n    return counter;\n}\n\n/*  -------------------------------------------------------------\n    Helper for testing\n    -------------------------------------------------------------*/\nvoid test()\n{\n    std::vector<std::any> a;                 // empty vector \u2192 0 vectors\n    std::cout << \"0 vectors? \" << find_lists(a) << '\\n';\n\n    std::vector<std::any> b = { 1, 2.5f, std::vector<int>{3,4}, std::string(\"foo\") };\n    std::cout << \"1 vector? \" << find_lists(b) << '\\n';\n\n    std::vector<std::any> c = { std::vector<double>{1.0,2.0}, std::vector<int>{5}, 7 };\n    std::cout << \"2 vectors? \" << find_lists(c) << '\\n';\n}\n\nint main()\n{\n    test();\n    return 0;\n}\n```\n\n### How it works\n\n1. **Iterate over the input** \u2013 We examine every `std::any` element in the supplied vector.\n2. **Attempt a cast to any vector** \u2013 By writing `std::any_cast<V>(elem)` with `V` a dummy `std::vector<int>`, the compiler will instantiate the cast for *any* instantiation of `std::vector`.  \n   - If the dynamic type stored inside the `std::any` is a vector of any element type, the cast succeeds and no exception is thrown.  \n   - If not, a `std::bad_any_cast` exception is thrown and we simply ignore the element.\n3. **Count successes** \u2013 Every successful cast increments our counter.\n\nThis approach is straightforward, works with any `std::vector<T>` regardless of `T`, and requires only C++17 (for `std::any`).\n\nFeel free to adapt or expand it \u2013 for example, you could return the types of the vectors found or filter by a particular element type.", "Below is a **self\u2011contained** implementation that will compile with a modern C++ compiler (C++17/20).  \nThe idea is to walk through the input `std::vector<std::any>` recursively:  \n\n* if an element is itself a `std::vector<std::any>` we count one \u201clist\u201d and then recurse into that inner vector;  \n* otherwise we just skip it.  \n\n```cpp\n#include <any>\n#include <vector>\n#include <typeindex>\n#include <typeinfo>\n\n/// \\brief Counts the number of std::vector<std::any> objects that appear\n///        (directly or indirectly) inside the given vector.\n///\n/// The function treats every nested std::vector<std::any> as a \u201clist\u201d\n/// and returns how many such lists are present (including the outer\n/// vector itself).\n///\n/// Example:\n/// ```cpp\n/// // { 1, { 2, 3 }, { {4}, 5 } }\n/// std::vector<std::any> v = { 1,\n///                             std::vector<std::any>{ 2, 3 },\n///                             std::vector<std::any>{ std::vector<std::any>{4},\n///                                                   5 } };\n/// long count = find_lists(v);\n/// // count == 4   // v, {2,3}, {{4},5}, and {4}\n/// ```\n///\nlong find_lists(const std::vector<std::any>& input)\n{\n    // A tiny helper that returns true iff `a` is a std::vector<std::any>.\n    auto is_vec_of_any = [](const std::any& a) noexcept -> bool {\n        // std::any::type() returns a std::type_info.  We compare it to\n        // the type_info of vector<any>.  On some platforms / ABIs\n        // `typeid` may contain compiler\u2011specific decorations, so we\n        // use std::type_index for a stable comparison.\n        return std::type_index(a.type())\n                == std::type_index(typeid(std::vector<std::any>));\n    };\n\n    long count = 0;            // How many vectors we have seen so far\n\n    // Queue (or stack) for non\u2011recursive DFS \u2013 keeps the algorithm\n    // extra\u2011lightweight and safe for deeply nested structures.\n    std::vector<const std::vector<std::any>*> stack;\n    stack.push_back(&input);   // start with the outer vector\n\n    while (!stack.empty()) {\n        const auto* vec_ptr = stack.back();\n        stack.pop_back();\n\n        ++count;          // the vector we are currently visiting\n\n        for (const auto& element : *vec_ptr)\n            if (is_vec_of_any(element))\n                // `any_cast` is safe here because we just tested the type\n                stack.push_back(&std::any_cast<const std::vector<std::any>&>(element));\n    }\n\n    return count;\n}\n\n/* ----------  Optional: a recursive version -----------------\n   It is easier to read but can cause stack overflows on very deep\n   nesting.  Uncomment if you prefer the classic recursive style. -----------------\n\n   long find_lists(const std::vector<std::any>& input)\n   {\n       long cnt = 1; // count this vector\n       for (const auto& e : input)\n           if (e.type() == typeid(std::vector<std::any>))\n               cnt += find_lists(std::any_cast<const std::vector<std::any>&>(e));\n       return cnt;\n   }\n\n-------------------------------------------------------------------------- */\n\n```\n\n### How it works\n1. **Type check** \u2013 We use a lambda `is_vec_of_any` that checks whether a `std::any` holds a\n   `std::vector<std::any>`.  `std::type_index` allows a stable comparison across ABIs.\n2. **Iterative DFS** \u2013 A simple stack holds pointers to the vectors that still need to be processed.\n   Each time we pop a vector we:\n   * increment the counter (this vector itself),\n   * iterate over its elements and push any nested vectors onto the stack.\n3. The algorithm runs in *O(n)* time where *n* is the total number of `std::any` objects encountered, and uses *O(m)* auxiliary space where *m* is the maximum depth of nesting.\n\n### Edge cases handled\n* **Empty vector** \u2013 returns `1` (the outer vector itself).\n* **No nested vectors** \u2013 returns `1`.\n* **Deeply nested structures** \u2013 safe even if depth is in the thousands because it is iterative.\n\nThis compact solution will compile with any standard\u2011conforming compiler that supports C++17 or newer.", "**Solution Explanation**\n\nThe task is to count how many standard library `std::vector` objects are stored inside a\n`std::vector<std::any>`.  \nThe argument can contain not only vectors but any type, so we must inspect every\nelement of the input vector and try to cast it to a vector.  \nWhen we succeed we have found one vector, and we also need to *look inside* this\nvector because it can contain further vectors (the input may be nested).\n\nBecause the elements are all wrapped in `std::any`, we need to try a cast for\nevery possible container type we might encounter.  The most common containers that\ncan be put inside a `std::vector` are:\n\n* `std::vector<X>` \u2013 the things we are interested in.\n* `std::deque<X>` \u2013 sometimes people use deques instead of vectors.\n* `std::list<X>` \u2013 and other containers that also hold a sequence of values.\n\nFor each container that we recognise, we add one to the counter and then recurse\nover its elements.\n\nThe implementation uses a helper lambda that can be called recursively.\n\n---\n\n**Code**\n\n```cpp\n#include <any>\n#include <vector>\n#include <deque>\n#include <list>\n#include <type_traits>\n\n/// Count how many std::vector objects are stored inside the given vector.\n/// The function also counts nested vectors \u2013 i.e. it traverses vectors that\n/// are inside other vectors.\nlong find_lists(const std::vector<std::any>& Input)\n{\n    long count = 0;                           // result\n\n    // Recursive helper: it can process any type of container\n    auto process = [&](auto&& container, auto&& self) -> void {\n        // Count this container itself (we only call self for inner containers)\n        // Nothing to do here \u2013 the caller decides whether to count.\n        for (auto&& elem : container) {\n            // Try to cast the element to a vector\n            if (auto* vp = std::any_cast<std::vector<std::any>>(&elem)) {\n                ++count;                      // found a vector\n                // recurse inside the vector\n                self(*vp, self);\n            }\n            // Likewise for a deque of any\n            else if (auto* dp = std::any_cast<std::deque<std::any>>(&elem)) {\n                ++count;                      // found a deque\n                self(*dp, self);\n            }\n            // Likewise for a list of any\n            else if (auto* lp = std::any_cast<std::list<std::any>>(&elem)) {\n                ++count;                      // found a list\n                self(*lp, self);\n            }\n            // Add more container types here if required\n        }\n    };\n\n    // start the recursion on the outer vector\n    process(Input, process);\n\n    return count;\n}\n```\n\n**Explanation of the key steps**\n\n| Step | What happens | Why |\n|------|--------------|-----|\n| 1 | The function receives a `std::vector<std::any>`. | This is the input container. |\n| 2 | A recursive lambda `process` is defined. | We need to be able to descend into nested containers. |\n| 3 | For every element in the current container, we try `std::any_cast` to one of the supported container types (`vector`, `deque`, `list`). | `any_cast` succeeds only if the stored type matches exactly, which allows us to detect vectors. |\n| 4 | When a cast succeeds, we increment the counter and call the lambda recursively on that inner container. | Counts this vector and continues searching inside it. |\n| 5 | The initial call `process(Input, process)` begins the traversal. | Starts counting from the top\u2011level vector. |\n| 6 | The final count is returned. | Result of the traversal. |\n\nThe implementation is generic in the sense that it can be extended to other container\ntypes by adding more `else if` branches in the lambda.  It handles nested\nstructures of arbitrary depth because each time a vector is found we recurse\ninside it."]}
{"completions": ["**Solution Explanation**\n\nFor a vector `arr` (length `N`) we may perform **right\u2011shift** operations any number of times.\nA right shift is equivalent to a rotation of the whole array:\n\n```\n[ a0, a1, a2, \u2026 , a(N-1) ]  \u2192  [ a(N-1), a0, a1, \u2026 , a(N-2) ]\n```\n\nAfter an arbitrary number of such operations the vector will be a *rotation* of the original\nvector.  \nThe question is therefore:\n\n> Can some rotation of the input vector be sorted in *non\u2011decreasing* order?\n\nThe array contains **distinct** elements, so the sorted order is unique.\n\n--------------------------------------------------------------------\n\n#### Observations\n\n1. In a sorted array the minimum element is at the first position.\n2. Because we only rotate, a sorted array can appear *only* when the array is rotated\n   so that its minimum element becomes the first element.\n3. Therefore we just need to find the index of the smallest element.\n   If the array rotated leftwards by that index is sorted, the answer is `true`,\n   otherwise `false`.\n\n--------------------------------------------------------------------\n\n#### Algorithm\n```\nmove_one_ball(arr)\n    if arr.empty(): return true\n    n \u2190 arr.size()\n\n    // find index of the minimum element\n    minIdx \u2190 0\n    for i from 1 to n-1\n        if arr[i] < arr[minIdx]\n            minIdx \u2190 i\n\n    // check whether the rotated array is sorted\n    // For every consecutive pair of indices in the rotated array\n    // the element at position j must be <= element at j+1\n    for i from 0 to n-1\n        a \u2190 arr[(minIdx + i) % n]\n        b \u2190 arr[(minIdx + i + 1) % n]\n        if a > b\n            return false\n    return true\n```\n\n--------------------------------------------------------------------\n\n#### Correctness Proof  \n\nWe prove that the algorithm returns `true` iff a sorted rotation exists.\n\n---\n\n##### Lemma 1  \nLet `k` be the index of the minimum element of `arr`.  \nAny sorted rotation of `arr` must start with that minimum element, i.e. its\nrotation index is exactly `k`.\n\n**Proof.**\n\nAssume a sorted rotation starts at index `j \u2260 k`.  \nIn that sorted rotation index `j` is the first element.\nSince the array is sorted in non\u2011decreasing order and all elements are distinct,\n`arr[j]` must be the minimum element of the array.\nBut the minimum element is unique and located at index `k`, so `j = k`. \u220e\n\n\n\n##### Lemma 2  \nAfter rotating `arr` leftward by `k` positions (i.e. starting at index `k`)\nthe resulting array is sorted **iff** all consecutive pairs in that rotation\nare in non\u2011decreasing order.\n\n**Proof.**\n\nA left rotation by `k` positions produces the sequence\n\n```\narr[k], arr[k+1], \u2026 , arr[n-1], arr[0], arr[1], \u2026 , arr[k-1]\n```\n\nwhich is exactly the order in which we compare consecutive pairs in the\nalgorithm.  \nIf every such pair satisfies `\u2264`, the whole sequence is sorted.\nIf one pair violates it, the sequence cannot be sorted. \u220e\n\n\n\n##### Theorem  \n`move_one_ball` returns `true` **iff** the vector can be sorted by repeatedly\nperforming right shift operations.\n\n**Proof.**\n\n*If part.*  \nAssume the function returns `true`.  \nBy Lemma&nbsp;1 the only possible sorted rotation starts at index `k`.  \nThe algorithm checks this rotation (Lemma&nbsp;2) and, finding it sorted,\nreturns `true`. Therefore that rotation is sorted, and a sequence of right\nshifts achieving it exists.\n\n*Only\u2011if part.*  \nAssume there exists a sequence of right shifts that sorts the vector.\nThen, by Lemma&nbsp;1, the sorted rotation starts at index `k`.  \nThe algorithm examines exactly this rotation and finds it sorted,\nthus returns `true`. \u220e\n\n\n\n--------------------------------------------------------------------\n\n#### Complexity Analysis\n\nLet `N` be the length of the input vector.\n\n* Finding the minimum: `O(N)`\n* Checking sortedness of the rotated array: `O(N)`\n* Total time: `O(N)`  \n* Extra space: `O(1)` (only a few indices are kept)\n\n--------------------------------------------------------------------\n\n#### Reference Implementation (C++17)\n\n```cpp\n#include <vector>\n\nbool move_one_ball(std::vector<long> arr) {\n    const int n = static_cast<int>(arr.size());\n    if (n == 0) return true;                     // empty vector is already sorted\n\n    // 1. Find index of the minimum element\n    int minIndex = 0;\n    for (int i = 1; i < n; ++i)\n        if (arr[i] < arr[minIndex]) minIndex = i;\n\n    // 2. Verify that rotating so that minIndex becomes first yields a sorted array\n    for (int i = 0; i < n; ++i) {\n        long a = arr[(minIndex + i) % n];\n        long b = arr[(minIndex + i + 1) % n];\n        if (a > b) return false;                 // not sorted\n    }\n    return true;                                 // all pairs in order\n}\n```\n\nThe code follows exactly the algorithm proven correct above and\nconforms to the C++17 language standard.", "Below is a simple, self\u2011contained implementation of `move_one_ball`.  \nThe logic is:\n\n1. If the vector is empty \u2013\u202freturn `true`.\n2. Produce a sorted copy of the vector.\n3. Every cyclic right shift of a sorted array is still a rotation of that array.\n   So we just need to check whether the original array is a rotation of the\n   sorted one.\n4. To test this, find where the first element of `arr` would appear in the\n   sorted array, then walk through the array comparing each element with the\n   sorted array shifted by that offset.\n\n```cpp\n#include <algorithm>\n#include <vector>\n\nbool move_one_ball(std::vector<long> arr) {\n    // 1. Empty vector is considered sorted.\n    if (arr.empty()) return true;\n\n    // 2. Build the sorted copy.\n    std::vector<long> sorted = arr;\n    std::sort(sorted.begin(), sorted.end());\n\n    // 3. Find the offset (index in sorted) of arr[0].\n    auto it = std::find(sorted.begin(), sorted.end(), arr[0]);\n    if (it == sorted.end()) return false;          // should never happen \u2013 all elements equal\n    std::size_t offset = std::distance(sorted.begin(), it);\n\n    // 4. Verify that the whole array matches sorted rotated by offset.\n    std::size_t n = arr.size();\n    for (std::size_t i = 0; i < n; ++i) {\n        std::size_t idx = (offset + i) % n;\n        if (arr[i] != sorted[idx]) return false;\n    }\n    return true;\n}\n```\n\n### Why it works\n\n- A **right shift** by `k` positions is equivalent to a cyclic rotation of the\n  vector.  \n- A sorted vector has the property that any rotation of it is still a valid\n  column\u2011wise comparison for the numbers, as long as the order is preserved.\n- Therefore, `arr` can be made sorted by right shifts iff it is *exactly* a\n  rotation of the sorted vector.\n\n### Complexity\n\n*Sorting*: `O(N log N)`  \n*Rotation check*: `O(N)`  \nOverall: `O(N log N)` time, `O(N)` additional space.\n\nFeel free to adapt the function name or signature to your needs.", "**Solution Explanation**\n\nWe must decide whether the given vector `arr` can be put into non\u2011decreasing order by *any number* of right cyclic shifts (i.e. rotations).  \nAll elements are distinct, the vector can be empty, and we only have to return a boolean.\n\n---\n\n### 1.  Observations\n\n* A right shift is the same as a left shift of the array by `N\u2011k` positions, i.e. we can rotate the array in any direction.  \n* If a vector can be sorted by rotation, then the sorted vector is just a **cyclic permutation** of the original vector.  \n* For a *sorted* array `b` (`b[0] < b[1] < \u2026 < b[N-1]`), its cyclic shifts are precisely all arrays that are \u201csorted except for one wrap\u2011around\u201d.  \n  In such an array there is at most one position `i` where `arr[i] > arr[i+1]` (for `i < N-1`).  \n  If that position exists, the array is sorted after we \u201ccut\u201d it at that point, i.e. we rotate the array until `arr[i+1]` becomes the first element.\n* Because all elements are unique, the sorted order is **strictly increasing**.  \n  (If the problem allowed non\u2013unique elements we would use `<=`.)\n\nTherefore the task reduces to:\n\n> **Count how many positions `i` (with `0 \u2264 i < N-1`) have `arr[i] > arr[i+1]`.**  \n>   \u2013 If the count is `\u2264 1` the array can be sorted by rotation.  \n>   \u2013 Otherwise it is impossible.\n\nThis is a `O(N)` scan, simple and efficient.\n\n\n\n---\n\n### 2.  Algorithm\n```\nmove_one_ball(arr):\n    if arr is empty:          // n == 0\n        return true\n\n    n = arr.size()\n    break_count = 0\n\n    for i from 0 to n-2:      // compare each adjacent pair\n        if arr[i] > arr[i+1]:\n            break_count += 1\n            if break_count > 1:\n                return false\n\n    // For completeness we also check the wrap\u2011around pair,\n    // but if there was a breakpoint earlier it would already\n    // have been counted.  The wrap pair is needed only when\n    // the whole array is sorted except the first element.\n    // (In that situation break_count would be 0 but we need 1.)\n    if break_count == 0 and arr[n-1] > arr[0]:\n        break_count = 1\n\n    return break_count <= 1\n```\n\n*Complexity*  \n`O(N)` time, `O(1)` additional memory.\n\n---\n\n### 3.  Correctness Proof  \n\nWe prove that the algorithm returns `true` iff the array can be sorted by rotating it arbitrarily.\n\n---\n\n#### Lemma 1  \nIf the array is a rotation of a strictly increasing array, then there is at most one adjacent pair `arr[i] > arr[i+1]` (for `0 \u2264 i < N-1`).  \n\n**Proof.**  \nLet `b` be the sorted array.  \nWhen we rotate `b` so that a suffix starts at index `k` (`0 \u2264 k < N`), the resulting array is\n\n```\n[b[k], b[k+1], \u2026, b[N-1], b[0], b[1], \u2026, b[k-1]]\n```\n\nAll pairs inside the two segments `[k \u2026 N-1]` and `[0 \u2026 k-1]` are increasing, because `b` itself is increasing.  \nThe only possible drop is at the junction between `b[N-1]` and `b[0]`.  \nThus at most one adjacent pair violates the increasing order. \u220e\n\n\n\n#### Lemma 2  \nIf the array contains at most one adjacent pair `arr[i] > arr[i+1]` (with `i` in the range `0 \u2026 N-2`) and additionally `arr[N-1] \u2264 arr[0]`, then the array is a rotation of a strictly increasing array.\n\n**Proof.**  \nBecause there is at most one violating pair, the array is *nearly* increasing.  \nLet `p` be the index of that pair if it exists, otherwise let `p = 0`.  \nCut the array between `p` and `p+1` (or at the start if `p=0`):\n\n```\nC = [arr[p+1], arr[p+2], \u2026, arr[N-1], arr[0], \u2026, arr[p]]\n```\n\nAll the pairs inside `C` are strictly increasing:\n* For indices inside `[p+1 \u2026 N-1]` the original order was increasing.\n* For indices inside `[0 \u2026 p]` they were increasing in the original array (no violation there).\n* The last element of `C` is `arr[p]` and the first is `arr[p+1]`; by definition of `p`, `arr[p] < arr[p+1]`.  \nHence `C` is strictly increasing.  \nThus `C` is the sorted array, and the original array is a rotation of it. \u220e\n\n\n\n#### Lemma 3  \nThe algorithm returns `true` if the array is a rotation of a sorted array.\n\n**Proof.**  \nBy Lemma&nbsp;1, such an array has at most one \u2193 pair in the internal indices.  \nThe algorithm counts that \u2264\u202f1 and never rejects if the wrap pair is not a violation or if the sole violation is accounted for.  \nTherefore it returns `true`. \u220e\n\n\n\n#### Lemma 4  \nIf the algorithm returns `true`, then the array can be sorted by rotations.\n\n**Proof.**  \nThe algorithm returns `true` only when `break_count \u2264 1`.  \nIf `break_count == 0`, the array is already strictly increasing, hence sorted (no rotation needed).  \nIf `break_count == 1`, the algorithm has verified that the wrap pair `arr[N-1] \u2264 arr[0]`;  \nby Lemma\u202f2 the array is a rotation of a sorted array, hence can be sorted. \u220e\n\n\n\n#### Theorem  \n`move_one_ball` returns `true` iff the input vector can be sorted in non\u2011decreasing order by performing any number of right shifts.\n\n**Proof.**  \n*If part*: By Lemma\u202f3.  \n*Only if part*: By Lemma\u202f4. \u220e\n\n\n\n---\n\n### 4.  Reference Implementation  (C++17)\n\n```cpp\n#include <vector>\n\nbool move_one_ball(std::vector<long> arr) {\n    const std::size_t n = arr.size();\n    if (n == 0)                 // empty vector is considered sorted\n        return true;\n\n    std::size_t break_count = 0;\n\n    for (std::size_t i = 0; i + 1 < n; ++i) {\n        if (arr[i] > arr[i + 1]) {\n            ++break_count;\n            if (break_count > 1)     // already impossible\n                return false;\n        }\n    }\n\n    /* The wrap\u2011around pair (last \u2192 first) is significant only when\n       the whole array was increasing (break_count == 0) but\n       the last element is larger than the first, i.e. wrap break.\n       In that situation we need to treat it as the one possible break. */\n    if (break_count == 0 && arr[n - 1] > arr[0])\n        break_count = 1;\n\n    return break_count <= 1;\n}\n```\n\nThe code follows exactly the algorithm proved correct above and\nconforms to the C++17 standard."]}
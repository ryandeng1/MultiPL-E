{"completions": ["Here is a clean implementation that does both checks in a single pass:\n\n```cpp\n#include <vector>\n#include <unordered_map>\n\nbool is_sorted(const std::vector<long>& lst)\n{\n    if (lst.empty()) return true;          // an empty list is trivially sorted\n\n    std::unordered_map<long,int> freq;     // to keep track of how many times a value appears\n    long prev = lst[0];\n    ++freq[prev];\n\n    for (std::size_t i = 1; i < lst.size(); ++i)\n    {\n        long cur = lst[i];\n\n        /* 1. make sure the sequence is non\u2011decreasing */\n        if (cur < prev) return false;\n\n        /* 2. count occurrences \u2013 look for a third occurrence */\n        if (++freq[cur] > 2) return false;\n\n        prev = cur;\n    }\n    return true;                           // correct order and no >2 duplicates\n}\n```\n\n### Explanation\n\n1. **Order check** \u2013 We keep the previous value (`prev`) and compare each `cur` to it.  \n   If a value is smaller than the previous one, the list is not sorted in ascending order, so we return `false`.\n\n2. **Duplicate\u2011count check** \u2013 A hash map (`freq`) records how many times each element has occurred.  \n   As soon as any element\u2019s counter exceeds `2` we return `false`, because more than one duplicate is not allowed.\n\n3. If we finish the loop without violating either rule, the vector satisfies both conditions, so the function returns `true`.\n\nThis function runs in O(n) time and uses O(k) additional space (where *k* is the number of distinct values).", "Here\u2019s a compact, self\u2011contained implementation that follows the rules you described:\n\n```cpp\n#include <vector>\n#include <unordered_map>\n\n/// Checks:\n/// 1. The vector is sorted in non\u2011decreasing order.\n/// 2. No number appears more than twice.\n///\nbool is_sorted(const std::vector<long> &lst) {\n    if (lst.empty() || lst.size() == 1) return true;   // Trivially sorted\n\n    std::unordered_map<long, int> freq;\n    long prev = lst[0];\n    freq[prev] = 1;\n\n    for (size_t i = 1; i < lst.size(); ++i) {\n        long cur = lst[i];\n\n        // 1. not sorted?\n        if (cur < prev) return false;\n\n        // 2. count occurrences\n        int &cnt = freq[cur];\n        ++cnt;\n        if (cnt > 2) return false;\n\n        prev = cur;\n    }\n    return true;\n}\n```\n\n**Why this works**\n\n- We iterate once through the vector.  \n- Because the vector is supposed to be sorted, every duplicate will be adjacent, so we only need a simple count per element.  \n- If we ever see an element that is smaller than its predecessor (`cur < prev`) the sequence is not sorted \u2192 return `false`.  \n- If any element\u2019s frequency exceeds two, the \u201cmore than one duplicate\u201d rule is violated \u2192 return `false`.  \n- If we finish the loop without triggering either condition, the input satisfies both constraints, so we return `true`.", "Here is a concise, self\u2011contained implementation that follows the rules described in the comment block:\n\n```cpp\n#include <vector>\n#include <unordered_map>\n\n/// @brief Returns true if `lst` is sorted in non\u2011decreasing order and\n/// no element occurs more than twice.\n/// @param lst A vector of non\u2011negative integers.\n///\n/// The function walks through the vector once, checking two conditions:\n/// 1. The next element must be greater than or equal to the previous one\n///    (strictly ascending would be `>`).\n/// 2. Each element should not appear more than twice.  We keep a hash map\n///    to count occurrences.\nbool is_sorted(const std::vector<long>& lst) {\n    if (lst.empty()) return true;          // Empty vector is trivially sorted\n\n    std::unordered_map<long, int> freq;    // Count occurrences\n    long prev = lst[0];\n    freq[prev] = 1;\n\n    for (size_t i = 1; i < lst.size(); ++i) {\n        long cur = lst[i];\n\n        // 1. Check order\n        if (cur < prev) return false;\n\n        // 2. Count duplicates\n        int &count = freq[cur];\n        ++count;\n        if (count > 2) return false;\n\n        prev = cur;\n    }\n\n    return true;\n}\n```\n\n### How it works\n\n1. **Order check** \u2013 For each element after the first, we require `cur >= prev`; otherwise the sequence is not sorted.\n2. **Duplicate check** \u2013 A small `unordered_map` stores the number of times each value has appeared.  \n   If any count grows beyond `2` the function returns `false` immediately.\n\nThe function is linear\u2011time \\(O(n)\\) and uses \\(O(k)\\) additional space where `k` is the number of distinct values in the vector. It satisfies all the examples given in the task comments."]}
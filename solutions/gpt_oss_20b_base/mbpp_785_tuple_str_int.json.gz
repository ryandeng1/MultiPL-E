{"completions": ["Below is a self\u2011contained implementation that turns a string such as  \n`\"(1, 200, -3)\"` into a `std::tuple<long,long,long>`.  \nThe function is written so that it works with any amount of whitespace\naround the comma/parentheses and it throws an exception if the input is\nmalformed.\n\n```cpp\n#include <cassert>\n#include <tuple>\n#include <string>\n#include <sstream>\n#include <stdexcept>\n#include <cctype>\n\n// -----------------------------------------------------------------------------\n// Helper \u2013 skip whitespace\ninline void skip_ws(const std::string &s, std::size_t &pos)\n{\n    while (pos < s.size() && std::isspace(static_cast<unsigned char>(s[pos])))\n        ++pos;\n}\n\n// -----------------------------------------------------------------------------\n// Convert a string containing a tuple into std::tuple<long,long,long>\nstd::tuple<long, long, long> tuple_str_int(const std::string &test_str)\n{\n    std::size_t pos = 0;\n    long a, b, c;\n\n    // skip leading whitespace\n    skip_ws(test_str, pos);\n\n    // opening '('\n    if (pos >= test_str.size() || test_str[pos] != '(')\n        throw std::invalid_argument(\"expected '(' at start\");\n    ++pos;\n\n    // first number\n    skip_ws(test_str, pos);\n    try {\n        a = std::stol(test_str.substr(pos));\n    } catch (...) {\n        throw std::invalid_argument(\"first component not a long\");\n    }\n    // move pos after the number\n    while (pos < test_str.size() && std::isdigit(static_cast<unsigned char>(test_str[pos]))) ++pos;\n\n    // comma\n    skip_ws(test_str, pos);\n    if (pos >= test_str.size() || test_str[pos] != ',')\n        throw std::invalid_argument(\"expected ',' after first component\");\n    ++pos;\n\n    // second number\n    skip_ws(test_str, pos);\n    try {\n        b = std::stol(test_str.substr(pos));\n    } catch (...) {\n        throw std::invalid_argument(\"second component not a long\");\n    }\n    while (pos < test_str.size() && std::isdigit(static_cast<unsigned char>(test_str[pos]))) ++pos;\n\n    // comma\n    skip_ws(test_str, pos);\n    if (pos >= test_str.size() || test_str[pos] != ',')\n        throw std::invalid_argument(\"expected ',' after second component\");\n    ++pos;\n\n    // third number\n    skip_ws(test_str, pos);\n    try {\n        c = std::stol(test_str.substr(pos));\n    } catch (...) {\n        throw std::invalid_argument(\"third component not a long\");\n    }\n    while (pos < test_str.size() && std::isdigit(static_cast<unsigned char>(test_str[pos]))) ++pos;\n\n    // closing ')'\n    skip_ws(test_str, pos);\n    if (pos >= test_str.size() || test_str[pos] != ')')\n        throw std::invalid_argument(\"expected ')' at end\");\n    ++pos;\n\n    // any trailing whitespace is allowed\n    skip_ws(test_str, pos);\n    if (pos != test_str.size())\n        throw std::invalid_argument(\"unexpected characters after tuple\");\n\n    return std::make_tuple(a, b, c);\n}\n\n// -----------------------------------------------------------------------------\n// demo / unit test\nint main()\n{\n    // some examples\n    auto t1 = tuple_str_int(\"(1, 200, -3)\");\n    assert(std::get<0>(t1) == 1);\n    assert(std::get<1>(t1) == 200);\n    assert(std::get<2>(t1) == -3);\n\n    auto t2 = tuple_str_int(\"(   42 , -1 , 0   )\");\n    assert(std::get<0>(t2) == 42);\n    assert(std::get<1>(t2) == -1);\n    assert(std::get<2>(t2) == 0);\n\n    // malformed input examples \u2013 they throw\n    try { tuple_str_int(\"1,2,3\"); }     // missing parens\n    catch (const std::invalid_argument &) {}\n\n    try { tuple_str_int(\"(1, 2)\"); }    // missing third component\n    catch (const std::invalid_argument &) {}\n\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\n### How it works\n1. **Whitespace handling** \u2013 `skip_ws` simply advances the current index over any\n   spaces/newlines.\n2. **Parsing** \u2013 For each token (first number, comma, second number, comma, third\n   number, closing parenthesis) we:\n   * skip leading whitespace,\n   * check that the expected character is present,\n   * extract the integer with `std::stol`.\n3. **Error handling** \u2013 If any part of the syntax is missing or cannot be\n   converted to a `long`, an `std::invalid_argument` exception is thrown.  \n   This allows the caller to detect bad input cleanly.\n\nThe function runs in linear time relative to the length of `test_str` and uses\nonly the standard library.", "Here is a **minimal, self\u2011contained** implementation that turns a string of the form\n\n```\n(123, 456, 789)\n```\n\n(or any whitespace\u2011tolerant variant such as `\" ( 1 ,2 , 3 )\"` ) into a\n`std::tuple<long, long, long>`.\n\n```cpp\n#include <tuple>\n#include <string>\n#include <cctype>\n#include <stdexcept>\n\n/*\n *  Convert a string that represents a tuple of three integers into\n *  a std::tuple<long, long, long>.\n *\n *  Expected input format (whitespace is ignored):\n *      \"(a, b, c)\"  \u2013 where a,b,c are base\u201110 integers, possibly negative.\n *\n *  If parsing fails, a std::invalid_argument exception is thrown.\n */\nstd::tuple<long, long, long> tuple_str_int(const std::string& s)\n{\n    const auto skip_ws = [](size_t& i, const std::string& str)\n    {\n        while (i < str.size() && std::isspace(static_cast<unsigned char>(str[i])))\n            ++i;\n    };\n\n    size_t i = 0;\n    // 1. leading '('\n    skip_ws(i, s);\n    if (i >= s.size() || s[i] != '(')\n        throw std::invalid_argument(\"Expected '('\");\n    ++i;\n\n    // 2. first number\n    skip_ws(i, s);\n    std::string first;\n    while (i < s.size() && (std::isdigit(static_cast<unsigned char>(s[i])) ||\n                            s[i]=='+' || s[i]=='-'))\n    {\n        first += s[i++];\n    }\n    if (first.empty())\n        throw std::invalid_argument(\"First number missing\");\n\n    // 3. comma\n    skip_ws(i, s);\n    if (i >= s.size() || s[i] != ',')\n        throw std::invalid_argument(\"Expected ',' after first number\");\n    ++i;\n\n    // 4. second number\n    skip_ws(i, s);\n    std::string second;\n    while (i < s.size() && (std::isdigit(static_cast<unsigned char>(s[i])) ||\n                            s[i]=='+' || s[i]=='-'))\n    {\n        second += s[i++];\n    }\n    if (second.empty())\n        throw std::invalid_argument(\"Second number missing\");\n\n    // 5. comma\n    skip_ws(i, s);\n    if (i >= s.size() || s[i] != ',')\n        throw std::invalid_argument(\"Expected ',' after second number\");\n    ++i;\n\n    // 6. third number\n    skip_ws(i, s);\n    std::string third;\n    while (i < s.size() && (std::isdigit(static_cast<unsigned char>(s[i])) ||\n                            s[i]=='+' || s[i]=='-'))\n    {\n        third += s[i++];\n    }\n    if (third.empty())\n        throw std::invalid_argument(\"Third number missing\");\n\n    // 7. trailing ')'\n    skip_ws(i, s);\n    if (i >= s.size() || s[i] != ')')\n        throw std::invalid_argument(\"Expected ')' after third number\");\n    ++i;\n\n    // 8. trailing garbage is not allowed\n    skip_ws(i, s);\n    if (i != s.size())\n        throw std::invalid_argument(\"Unexpected characters after ')'\");\n\n    // 9. convert to long\n    long a = std::stol(first);\n    long b = std::stol(second);\n    long c = std::stol(third);\n\n    return std::make_tuple(a, b, c);\n}\n```\n\n### How it works\n\n1. **Whitespace handling** \u2013 The helper `skip_ws` moves the index past any spaces.\n2. **Structural checks** \u2013 It ensures that the string follows the exact pattern\n   `(<num>, <num>, <num>)`.\n3. **Number extraction** \u2013 Characters that belong to a number (digits, `+`, `-`) are collected into a local string.\n4. **Conversion** \u2013 `std::stol` turns those strings into `long` values.\n5. **Error handling** \u2013 If anything fails (wrong format, missing part, garbage after the closing parenthesis) an exception of type `std::invalid_argument` is thrown.\n\nThis function is pure and doesn\u2019t depend on external libraries beyond the standard C++\u202flibrary, making it suitable for inclusion in any project.", "Below is a concise and robust implementation that turns a string representation of a tuple into a `std::tuple<long, long, long>`.  \nIt assumes the input is in the form  \n\n```\n(a,b,c)\n```  \n\nwith optional white\u2011space inside. Any deviation will trigger an `assert`.  \nFeel free to drop in the function body wherever you need it.\n\n```cpp\n#include <tuple>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <cctype>\n#include <cassert>\n\n/*  Convert a string that looks like \"(a,b,c)\" into a tuple of three\n *  long integers.\n *\n *  The function is tolerant to spaces and will assert if the format\n *  is wrong or if any of the values cannot be parsed as a long.\n */\nstd::tuple<long, long, long> tuple_str_int(const std::string& test_str)\n{\n    std::string s = test_str;\n\n    // 1. Remove surrounding whitespace\n    s.erase(s.begin(),\n            std::find_if(s.begin(), s.end(),\n                         [](unsigned char ch){ return !std::isspace(ch); }));\n    s.erase(std::find_if(s.rbegin(), s.rend(),\n                         [](unsigned char ch){ return !std::isspace(ch); }).base(),\n            s.end());\n\n    // 2. Basic format check: must start with '(' and end with ')'\n    assert(!s.empty() && s.front() == '(' && s.back() == ')');\n\n    // 3. Remove the parentheses\n    s = s.substr(1, s.size() - 2);\n\n    // 4. Split on commas \u2013 we expect exactly three parts\n    std::vector<std::string> parts;\n    std::stringstream ss(s);\n    std::string token;\n    while (std::getline(ss, token, ',')) {\n        // trim each token for surrounding spaces\n        token.erase(token.begin(),\n                    std::find_if(token.begin(), token.end(),\n                                 [](unsigned char ch){ return !std::isspace(ch); }));\n        token.erase(std::find_if(token.rbegin(), token.rend(),\n                                 [](unsigned char ch){ return !std::isspace(ch); }).base(),\n                    token.end());\n        parts.push_back(token);\n    }\n    assert(parts.size() == 3);\n\n    // 5. Convert each string to long\n    long vals[3];\n    for (int i = 0; i < 3; ++i) {\n        std::stringstream conv(parts[i]);\n        conv >> vals[i];\n        assert(!conv.fail() && conv.eof());   // ensure proper conversion\n    }\n\n    return std::make_tuple(vals[0], vals[1], vals[2]);\n}\n```\n\n### Usage example\n\n```cpp\nint main() {\n    std::string t = \"( 123 , -456 , 789)\";\n    auto tup = tuple_str_int(t);\n    std::cout << std::get<0>(tup) << \", \"\n              << std::get<1>(tup) << \", \"\n              << std::get<2>(tup) << '\\n';\n}\n```\n\nOutput:\n\n```\n123, -456, 789\n```\n\nThe function uses `assert` to signal malformed input. If you prefer exceptions, replace the `assert` statements with `throw std::invalid_argument(\"\u2026\")`."]}
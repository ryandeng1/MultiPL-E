{"completions": ["```cpp\nlong count_nums(std::vector<long> arr) {\n    long cnt = 0;                     // number of elements satisfying the condition\n\n    for (const long &x : arr) {\n        if (x == 0)           // 0 has no digits \u2192 sum = 0 \u2192 not counted\n            continue;\n\n        long n      = llabs(x);          // absolute value for digit extraction\n        long sum    = 0;\n        bool first  = true;              // flag for the most\u2011significant digit\n        int sign    = (x < 0) ? -1 : 1;  // sign applies only to the first digit\n\n        // Extract digits from least\u2011significant to most\u2011significant\n        while (n > 0) {\n            int digit = n % 10;\n            if (first) {\n                sum += sign * digit;     // sign of the first digit\n                first = false;\n            } else {\n                sum += digit;            // remaining digits are always positive\n            }\n            n /= 10;\n        }\n\n        if (sum > 0)\n            ++cnt;\n    }\n\n    return cnt;          // number of elements whose (signed) digit sum > 0\n}\n```\n\n### How it works\n1. **Zero\u2011check** \u2013 `0` has no digits and a sum of 0, so it\u2019s skipped.\n2. **Digit extraction** \u2013 Use `llabs` to work with the absolute value of each number.\n3. **Sign handling** \u2013  \n   - The most significant (first) digit carries the sign of the original number (`-1` if the number is negative).  \n   - All other digits are added positively.\n4. **Summation** \u2013 Build `sum` while iterating through the digits.\n5. **Count** \u2013 If the resulting `sum` is greater than zero, increment the counter.\n\nThis implementation handles all edge cases covered by the examples:\n- An empty vector yields `0`.  \n- For `{-1, 11, -11}` only `11` qualifies \u2192 `1`.  \n- For `{1, 1, 2}` all three qualify \u2192 `3`.", "Here\u2019s a clean implementation that follows the rules described in the prompt:\n\n```cpp\nlong count_nums(std::vector<long> arr) {\n    long count = 0;\n\n    for (long n : arr) {\n        long tmp = n;\n        long sum = 0;\n        bool first_digit_processed = false;\n\n        // Handle the case n == 0 separately (no digits, sum stays 0)\n        if (tmp == 0) {\n            // 0 has a digit sum of 0 \u2192 not counted\n            continue;\n        }\n\n        // Work with the absolute value for digit extraction.\n        long abs_val = std::llabs(tmp);\n\n        // Extract digits from least\u2011to\u2011most significant.\n        // We\u2019ll keep track of the most\u2011significant digit once it\u2019s seen.\n        std::vector<int> digits;\n        while (abs_val > 0) {\n            digits.push_back(static_cast<int>(abs_val % 10));\n            abs_val /= 10;\n        }\n\n        // The most\u2011significant digit is the last element (since we built from LSB\u2192MSB)\n        int msd = digits.back();\n\n        // Apply the sign rule: only the first (most\u2011significant) digit is signed.\n        sum += (tmp < 0 ? -msd : msd);\n\n        // Remaining digits are always positive\n        for (size_t i = digits.size() - 1; i-- > 0; ) {\n            sum += digits[i];\n        }\n\n        if (sum > 0) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```\n\n### Why this does what the examples expect\n\n| Input vector | Computed sums | Counted? |\n|--------------|---------------|----------|\n| `{}` | none | 0 |\n| `{-1, 11, -11}` | `-1` (sum\u202f\u22121); `11` (sum\u202f2); `-11` (sum\u202f0) | Only `11` \u2192 1 |\n| `{1, 1, 2}` | `1`, `1`, `2` (all >\u202f0) | 3 |\n\nThe algorithm properly handles negative numbers by signing only the most significant digit (e.g., `-123` \u2192 sum\u202f4), while positive numbers are summed normally. It also treats zero correctly (digit sum\u202f0, so it is not counted).", "```cpp\n#include <vector>\n#include <cmath>\n\nlong count_nums(std::vector<long> arr) {\n    long count = 0;\n\n    for (long n : arr) {\n        if (n == 0) continue;            // 0 has no signed digit \u2192 sum = 0\n\n        long sum = 0;\n        long abs_val = std::llabs(n);\n\n        // Determine sign of the first digit\n        int first_digit_sign = (n < 0) ? -1 : 1;\n\n        // Extract digits from right to left\n        // We'll process the most\u2011significant digit first\n        // by collecting digits in a vector, then reversing.\n        std::vector<int> digits;\n        while (abs_val > 0) {\n            digits.push_back(static_cast<int>(abs_val % 10));\n            abs_val /= 10;\n        }\n        // digits are currently least\u2011significant first\n        for (auto it = digits.rbegin(); it != digits.rend(); ++it) {\n            int d = *it;\n            if (it == digits.rbegin()) {   // most\u2011significant digit\n                sum += first_digit_sign * d;\n            } else {\n                sum += d;                  // other digits are always positive\n            }\n        }\n\n        if (sum > 0) ++count;\n    }\n\n    return count;\n}\n```\n\nThis implementation follows the rules:\n\n* Handles negative numbers by making the most significant digit negative.\n* Counts only those numbers whose digit\u2011sum is strictly > 0.\n* Ignores `0` (since its digit\u2011sum is 0)."]}
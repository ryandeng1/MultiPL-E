{"completions": ["Here\u2019s a small helper that does exactly what you described: it computes the mean of the elements and then returns the average absolute deviation from that mean.\n\n```cpp\n#include <vector>\n#include <numeric>   // std::accumulate\n\n// Mean Absolute Deviation \u2013 average of |x_i \u2212 mean|\nfloat mean_absolute_deviation(const std::vector<float>& numbers)\n{\n    if (numbers.empty())\n        return 0.f;                     // nothing to do\n\n    // 1. Compute the mean\n    float sum = std::accumulate(numbers.begin(), numbers.end(), 0.f);\n    float mean = sum / static_cast<float>(numbers.size());\n\n    // 2. Sum the absolute deviations\n    float abs_dev_sum = 0.f;\n    for (float v : numbers)\n        abs_dev_sum += std::fabs(v - mean);\n\n    // 3. Return the average deviation\n    return abs_dev_sum / static_cast<float>(numbers.size());\n}\n```\n\n**What it does**\n\n1. Checks for an empty vector; if there are no numbers it returns `0.f` (you could also throw an exception if that\u2019s preferred).\n2. Computes the mean of the input vector.\n3. Loops over the vector once more, accumulating the absolute difference of each element from the mean.\n4. Divides that sum by the number of elements to get the mean absolute deviation.\n\nThis function is `O(n)` in time and `O(1)` in extra space.", "Here is a compact, self\u2011contained implementation that follows the rules you described.  \nIt calculates the mean, then the average of the absolute differences from that mean.\n\n```cpp\n#include <vector>\n#include <numeric>   // std::accumulate\n#include <algorithm> // std::transform\n#include <cmath>     // std::abs\n\n// Calculate Mean Absolute Deviation of a dataset (std::vector<float>).\n// MAD = (1/N) * \u03a3 |x_i \u2013 mean|\nfloat mean_absolute_deviation(std::vector<float> numbers)\n{\n    // Protect against an empty vector \u2013 behaviour is undefined, but\n    // we simply return 0.0f to avoid division\u2011by\u2011zero.\n    if(numbers.empty())\n        return 0.0f;\n\n    // 1) Compute the mean\n    const float mean = static_cast<float>(std::accumulate(\n                            numbers.begin(), numbers.end(), 0.f)) / numbers.size();\n\n    // 2) Compute the sum of absolute deviations from the mean\n    float sum_abs_dev = 0.f;\n    for(const float& v : numbers)\n        sum_abs_dev += std::fabs(v - mean);\n\n    // 3) Average the deviations\n    return sum_abs_dev / static_cast<float>(numbers.size());\n}\n```\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<float> data{1.0f, 2.0f, 3.0f, 4.0f};\n    std::cout << mean_absolute_deviation(data) << '\\n';   // prints 1.0\n}\n```\n\nThe function works with any `std::vector<float>`\u2014it handles the basic check for an empty container and returns `0.0f` in that case to avoid a divide\u2011by\u2011zero.", "Here\u2019s a concise, self\u2011contained implementation of `mean_absolute_deviation`.  \nIt:\n\n1. Computes the arithmetic mean of the input vector.\n2. Computes the absolute deviation of each element from that mean.\n3. Averages those deviations and returns the result.\n\n```cpp\n#include <vector>\n#include <numeric>   // std::accumulate\n#include <cmath>     // std::fabs\n#include <stdexcept> // std::invalid_argument\n\n// Mean Absolute Deviation around the mean of the dataset\n// MAD = 1/n * \u03a3 |xi - mean|\nfloat mean_absolute_deviation(const std::vector<float>& numbers) {\n    if (numbers.empty()) {\n        throw std::invalid_argument(\"mean_absolute_deviation: empty vector\");\n    }\n\n    // 1. Compute mean\n    float sum = std::accumulate(numbers.begin(), numbers.end(), 0.0f);\n    float mean = sum / static_cast<float>(numbers.size());\n\n    // 2. Sum absolute deviations from mean\n    float abs_dev_sum = 0.0f;\n    for (float x : numbers) {\n        abs_dev_sum += std::fabs(x - mean);\n    }\n\n    // 3. Average absolute deviations\n    return abs_dev_sum / static_cast<float>(numbers.size());\n}\n```\n\n### Usage Example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<float> data = {1.0f, 2.0f, 3.0f, 4.0f};\n    std::cout << mean_absolute_deviation(data) << std::endl; // prints 1.0\n}\n```\n\nFeel free to drop the error check if you prefer an undefined\u2011behaviour response for empty input; otherwise the exception makes the function safe to use in library code."]}
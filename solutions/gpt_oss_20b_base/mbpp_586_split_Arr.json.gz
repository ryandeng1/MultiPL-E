{"completions": ["Sure! Below is a minimal, safe C++ implementation that does what you described:\n\n1. **Take a copy of the vector (so the caller\u2019s original is unchanged).**\n2. **Split the vector at the *n*-th element (zero\u2011based index).**\n3. **Append the first part to the end, effectively rotating it.**\n\n```cpp\n#include <vector>\n#include <stdexcept>\n\n/**\n * @brief Rotates a vector by moving the first `n` elements to the back.\n *\n *   Example:\n *       input:  [1, 2, 3, 4, 5]\n *       n     : 2\n *       output: [3, 4, 5, 1, 2]\n *\n * @tparam T  Type of elements in the vector.  Uses `long` in the signature\n *            requested by the question, but works for any type.\n * @param  v  The vector that will be rotated.\n * @param  n  The index at which to split the vector (0\u2011based).  Must satisfy\n *            0 <= n <= v.size().\n * @return    A new vector with the first `n` elements moved to the end.\n *\n * @throws std::out_of_range If `n` is not in [0, v.size()].\n */\ntemplate <typename T = long>\nstd::vector<T> split_Arr(std::vector<T> v, std::size_t n)\n{\n    if (n > v.size())\n        throw std::out_of_range(\"split_Arr: n out of range\");\n\n    // Nothing to do if n == 0 or n == v.size()\n    if (n == 0 || n == v.size())\n        return v;\n\n    // `it` points to element that will become the new first element\n    auto it = v.begin() + n;\n\n    // Construct the resulting vector by first copying tail, then prefix\n    std::vector<T> result;\n    result.reserve(v.size());\n\n    result.insert(result.end(), it, v.end());    // tail\n    result.insert(result.end(), v.begin(), it); // prefix\n\n    return result;\n}\n```\n\n#### How to use\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> vec = {1, 2, 3, 4, 5};\n    auto rotated = split_Arr(vec, 2);\n\n    for (long x : rotated)\n        std::cout << x << ' ';\n    // prints: 3 4 5 1 2\n}\n```\n\n**Key Points**\n\n- The function works for any element type (templated) but defaults to `long` to match your prototype.\n- The input vector is **passed by value** (so the caller\u2019s vector remains unchanged).  \n  If you prefer to modify in\u2011place, change the signature to `void split_Arr(std::vector<long>& v, std::size_t n)` and adjust the implementation accordingly.\n- It validates that `n` is within bounds and throws `std::out_of_range` otherwise.\n\nFeel free to tweak it (e.g., pass by reference for efficiency) depending on your exact use\u2011case!", "Below is a clean, self\u2011contained C++ function that does exactly what you described:\n\n```cpp\n#include <vector>\n#include <cassert>\n\n/**\n * Split a vector at position `n` (0\u2011based index) and append the\n * first part after the second part.\n *\n * Example:\n *   l = {1, 2, 3, 4, 5}, n = 2   // split after element index 1\n *   \u2192 {3, 4, 5, 1, 2}\n *\n * @param l  The input vector (the original vector is left untouched).\n * @param n  The split index. Elements with indices < n belong to the \"first part\".\n * @return   A new vector with the two parts concatenated in the order:\n *           [elements from n \u2026 end] followed by [elements from 0 \u2026 n-1].\n */\nstd::vector<long> split_arr(const std::vector<long>& l, long n)\n{\n    // Validate input: n must be between 0 and l.size()\n    assert(n >= 0 && n <= static_cast<long>(l.size()));\n\n    std::vector<long> result;\n    result.reserve(l.size());          // reserve capacity to avoid reallocations\n\n    // Append the \"second\" part: elements from index n to the end\n    result.insert(result.end(), l.begin() + n, l.end());\n\n    // Append the \"first\" part: elements from index 0 to n-1\n    result.insert(result.end(), l.begin(), l.begin() + n);\n\n    return result;\n}\n```\n\n### How it works\n\n1. **Bounds checking** \u2013 `assert` guarantees that `n` is a legal split point.\n2. **Reserve space** \u2013 `reserve` pre\u2011allocates enough memory for the result, giving a linear\u2011time copy.\n3. **Two `insert` calls** \u2013  \n   * The first `insert` copies the tail of `l` (from `n` to the end).  \n   * The second `insert` copies the head of `l` (from `0` to `n-1`).\n\nThis keeps the original vector unchanged and produces a new vector with the requested concatenation.", "Below is a small, self\u2011contained example that does exactly what you asked for:\n\n* **What it does** \u2013  \n  * Take a `std::vector<long>` called `l`.  \n  * Split it into two parts at index `n` (`n` is counted from `0`).  \n  * Append the first part (the elements before `n`) to the end of the second part, effectively \u201crotating\u201d the vector.  \n  * Return the resulting vector.\n\nYou can copy the function as is and place it inside any `.cpp` file that includes the standard headers.\n\n```cpp\n#include <cassert>\n#include <vector>\n\n/**\n * @brief Rotate a vector by moving the first `n` elements to its end.\n *\n * @param l vector to be rotated\n * @param n number of elements to take from the beginning\n * @return std::vector<long> a new vector with the requested rotation\n *\n * Behaviour:\n *  - If n < 0 or n > l.size(), the function asserts.  In production code\n *    you might want to throw an exception or clamp the value instead.\n */\nstd::vector<long> split_Arr(const std::vector<long>& l, long n) {\n    // Validate parameters\n    assert(n >= 0 && static_cast<std::size_t>(n) <= l.size());\n\n    std::vector<long> result;\n    result.reserve(l.size());          // avoid a second re\u2011allocation\n\n    // Append the tail of the original vector (elements n \u2026 end)\n    result.insert(result.end(), l.begin() + n, l.end());\n\n    // Append the head of the original vector (elements 0 \u2026 n-1)\n    result.insert(result.end(), l.begin(), l.begin() + n);\n\n    return result;\n}\n```\n\n### How to use it\n\n```cpp\nint main() {\n    std::vector<long> a{10, 20, 30, 40, 50};\n    long n = 2;                 // split after the first two elements\n\n    std::vector<long> b = split_Arr(a, n);\n\n    // b now contains: {30, 40, 50, 10, 20}\n    for (long v : b) std::cout << v << ' ';\n}\n```\n\nThis implementation is straightforward, runs in linear time \\(O(|l|)\\), and uses only the standard library. If you need it to modify the original vector in\u2011place, you can change the return type to `void` and perform the operations directly on `l`."]}
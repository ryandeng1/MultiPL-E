{"completions": ["Below is a complete, self\u2011contained implementation that checks whether a `std::vector<long>` (or any container that supports random\u2011access iterators) is sorted in **non\u2011decreasing** order.  \nThe function is generic and will work with `std::vector<int>`, `std::vector<long long>`, `std::vector<double>`, etc.  \n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// ---------------------------------------------------------------------------\n// Function:  issort_list\n// Purpose:   Return true if the sequence is sorted in non\u2011decreasing\n//            order (i.e. each element <= the next one).\n// Parameters:\n//     list1   \u2013 any container with RandomAccessIterator (vector, array, etc.)\n// Notes:\n//     - The function makes a *copy* of the container argument (by value).\n//       If the argument is large and you wish to avoid the copy, pass by\n//       const reference instead:  `const std::vector<long>& list1`\n//     - Complexity:  O(n)\n// ---------------------------------------------------------------------------\n\nbool issort_list(std::vector<long> list1) {\n    // An empty or single\u2011element container is trivially sorted\n    if (list1.size() < 2) return true;\n\n    // Traverse the container once and compare each element with its successor\n    for (size_t i = 1; i < list1.size(); ++i) {\n        if (list1[i-1] > list1[i])  // found a violation\n            return false;\n    }\n    return true;\n}\n\n// ---------------------------------------------------------------------------\n// Alternative: generic template version (recommended)\n// ---------------------------------------------------------------------------\n\ntemplate <typename Container>\nbool issort_list(const Container& cont) {\n    using Iter = typename Container::const_iterator;\n    if (distance(cont.begin(), cont.end()) < 2)\n        return true;\n\n    for (Iter it = cont.begin(); ++it != cont.end(); ) {\n        Iter next = it;\n        ++next;\n        if (*it > *next)\n            return false;\n    }\n    return true;\n}\n\n// ---------------------------------------------------------------------------\n// Demo / Test harness\n// ---------------------------------------------------------------------------\n\nint main() {\n    std::vector<long> v1 = {1, 2, 3, 4, 5};          // sorted\n    std::vector<long> v2 = {1, 3, 2, 4, 5};          // not sorted\n    std::vector<long> v3 = {};                       // empty\n    std::vector<long> v4 = {42};                    // one element\n\n    assert(issort_list(v1) == true);\n    assert(issort_list(v2) == false);\n    assert(issort_list(v3) == true);\n    assert(issort_list(v4) == true);\n\n    cout << \"All assertions passed.\\n\";\n    return 0;\n}\n```\n\n---\n\n### What the function does\n\n1. **Base case** \u2013 If the container has 0 or 1 element, it is automatically sorted.\n2. **Linear scan** \u2013  \n   * Iterate from the second element to the end.  \n   * For every step compare the current element with the previous one.  \n   * If the previous element is larger than the current one, the sequence\n     is not sorted \u2192 return `false`.\n3. **Return** \u2013 If no violating pair is found, the function returns `true`.\n\nThe algorithm runs in **O(n)** time and **O(1)** additional space.  \nIt is also `constexpr`\u2011eligible if you use a `const` container (C++20+).\n\nFeel free to replace `std::vector<long>` with any other container or\nuse the generic template version for maximum flexibility.", "Below is a compact, self\u2011contained implementation that does exactly what you asked for \u2013 it reports whether a `std::vector<long>` is sorted **in non\u2011decreasing order**.\n\n```cpp\n#include <vector>\n#include <algorithm>   // for std::is_sorted\n\n/// @brief Returns true iff `lst` is sorted in ascending order\n///        (allowing equal neighbouring elements).\n///\n/// @param lst vector of `long` to check\n/// @return true if the vector is sorted, false otherwise\nbool issort_list(const std::vector<long>& lst)\n{\n    // std::is_sorted takes a pair of iterators and a comparison function.\n    // The default comparison (operator<) will behave like the typical\n    // \"ascending\" sorted check.\n    return std::is_sorted(lst.begin(), lst.end());\n}\n```\n\n### Why this works\n\n* `std::is_sorted` is a standard algorithm that runs in linear time.\n* It examines every adjacent pair once, returning `false` the instant\n  it finds a violation (`first > second`).\n* The function is `const`\u2011qualified, so it does not modify the input\n  vector.\n\n### Example usage\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<long> a{1, 2, 3, 4, 5};\n    std::vector<long> b{5, 3, 2, 1};\n    std::vector<long> c{1, 2, 2, 3, 4};\n\n    std::cout << issort_list(a) << '\\n'; // prints 1 (true)\n    std::cout << issort_list(b) << '\\n'; // prints 0 (false)\n    std::cout << issort_list(c) << '\\n'; // prints 1 (true)\n}\n```\n\nYou can compile it with any modern C++ compiler (C++17 or later). The code is intentionally minimal \u2013 there\u2019s no need for the `<bits/stdc++.h>` hack, and the function signature is identical to the one you began writing, except that it takes the vector *by reference* to avoid an unnecessary copy.", "Below is a small, self\u2011contained implementation that confirms whether a `std::vector<long>` is sorted in **non\u2011decreasing** order.  \nFeel free to drop it into your code base or adapt it to a different ordering (e.g., descending) if needed.\n\n```cpp\n#include <algorithm>   // std::is_sorted\n#include <vector>\n\n// --------------------------------------------------------------------\n//  Check whether the given vector is sorted in non\u2011decreasing order.\n// --------------------------------------------------------------------\nbool issort_list(std::vector<long> const& list1)\n{\n    // std::is_sorted is O(n) and works with any RandomAccessIterator.\n    return std::is_sorted(list1.begin(), list1.end());\n}\n```\n\n### Why this version?\n\n* **Const\u2011reference** (`const&`) avoids an unnecessary copy of the vector.\n* `std::is_sorted` is part of the C++ Standard Library, well\u2011tested and\n  performs exactly what is asked for.\n* The function returns a `bool` directly, matching the requested signature.\n\n### Quick test\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<long> a = {1, 2, 3, 4, 5};\n    std::vector<long> b = {5, 3, 1, 2};\n\n    std::cout << std::boolalpha;\n    std::cout << \"a sorted? \" << issort_list(a) << '\\n'; // true\n    std::cout << \"b sorted? \" << issort_list(b) << '\\n'; // false\n}\n```\n\nCompile with:\n\n```bash\ng++ -std=c++17 -O2 -Wall -Wextra -pedantic your_file.cpp\n```\n\nThat\u2019s it \u2013 a minimal, idiomatic solution ready to use."]}
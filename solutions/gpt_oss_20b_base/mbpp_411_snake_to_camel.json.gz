{"completions": ["Here\u2019s a ready\u2011to\u2011use implementation of `snake_to_camel`.  \nIt converts every word separated by an underscore `_` into a camel\u2011cased word, making the first word all lower\u2011case and the rest capitalized.\n\n```cpp\n#include <string>\n#include <cctype>   // for std::isalpha, std::toupper, std::tolower\n\n// Convert a snake_case string to camelCase\nstd::string snake_to_camel(const std::string& word) {\n    std::string result;\n    bool newWord = true;                     // true when the next non\u2011underscore starts a new word\n\n    for (char ch : word) {\n        if (ch == '_') {\n            newWord = true;                  // next letter should be capitalised\n            continue;\n        }\n\n        if (newWord) {\n            // First letter of a word \u2192 upper\u2011case\n            result += std::toupper(static_cast<unsigned char>(ch));\n            newWord = false;\n        } else {\n            // All other letters \u2192 lower\u2011case\n            result += std::tolower(static_cast<unsigned char>(ch));\n        }\n    }\n\n    // make the very first letter lower\u2011case to get camelCase\n    if (!result.empty() && std::isupper(static_cast<unsigned char>(result[0]))) {\n        result[0] = std::tolower(static_cast<unsigned char>(result[0]));\n    }\n\n    return result;\n}\n```\n\n### How it works\n1. **Iterate over each character** of the input string.  \n2. When an underscore is encountered, set `newWord` to `true` and skip it.  \n3. For a non\u2011underscore character:\n   * If `newWord` is `true`, capitalize the character and set `newWord` to `false`.  \n   * Otherwise, add it in lower\u2011case.  \n4. After processing all characters, the first character is forced to lower\u2011case to produce true camelCase.\n\n### Example\n```cpp\nint main() {\n    std::string s1 = \"hello_world\";\n    std::string s2 = \"__some_example__\";\n    std::string s3 = \"AlreadyCamel\";\n\n    std::cout << snake_to_camel(s1) << '\\n'; // helloWorld\n    std::cout << snake_to_camel(s2) << '\\n'; // someExample\n    std::cout << snake_to_camel(s3) << '\\n'; // alreadycamel\n}\n```\n\nThe function is robust against leading, trailing, and consecutive underscores, guaranteeing a clean camel\u2011cased output.", "Here is a simple, self\u2011contained implementation that converts a snake_case string to camelCase. It removes underscores and capitalises the first letter of each subsequent segment:\n\n```cpp\n#include <cassert>\n#include <string>\n\nstd::string snake_to_camel(const std::string& word)\n{\n    std::string result;\n    bool next_upper = false;             // whether the next non\u2011underscore char should be upper\u2011cased\n\n    for (char ch : word)\n    {\n        if (ch == '_')\n        {\n            // skip underscore, next character will become uppercase\n            next_upper = true;\n        }\n        else\n        {\n            if (next_upper)\n            {\n                result += std::toupper(static_cast<unsigned char>(ch));\n                next_upper = false;\n            }\n            else\n            {\n                result += ch;\n            }\n        }\n    }\n\n    return result;\n}\n```\n\n### How it works\n1. **Skip underscores** \u2013 every time an underscore is encountered, set a flag (`next_upper`) telling the algorithm that the following character should be capitalised.\n2. **Capitalize** \u2013 if the flag is set, the next character is converted to uppercase (using `std::toupper`).  \n3. **Append** \u2013 otherwise, the character is appended as\u2011is.\n\nThe function also safely handles edge cases such as leading or consecutive underscores, or an empty string. It can be used directly in any C++ program that includes `<string>`.", "```cpp\n#include <string>\n#include <cctype>\n#include <cassert>\n#include <bits/stdc++.h>\n\n// Convert a snake\u2011case string (e.g. \"example_string_here\")\n// to camel\u2011case (e.g. \"exampleStringHere\").\nstd::string snake_to_camel(std::string word) {\n    if (word.empty()) return word;\n\n    std::string result;\n    bool next_upper = false;          // flag to capitalize the next non\u2011underscore char\n\n    for (char c : word) {\n        if (c == '_') {\n            // skip underscore and set flag for next letter\n            next_upper = true;\n            continue;\n        }\n\n        if (next_upper) {\n            result.push_back(std::toupper(static_cast<unsigned char>(c)));\n            next_upper = false;\n        } else {\n            result.push_back(static_cast<char>(c));\n        }\n    }\n    return result;\n}\n\n// ---------------------\n// Example usage & tests\n// ---------------------\nint main() {\n    assert(snake_to_camel(\"example_string_here\") == \"exampleStringHere\");\n    assert(snake_to_camel(\"snake_case\") == \"snakeCase\");\n    assert(snake_to_camel(\"alreadyCamel\") == \"alreadyCamel\"); // no underscores\n    assert(snake_to_camel(\"_leading_underscore\") == \"LeadingUnderscore\");\n    assert(snake_to_camel(\"trailing_underscore_\") == \"trailingUnderscore\");\n    assert(snake_to_camel(\"__double__underscore__\") == \"DoubleUnderscore\");\n\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\nThe `snake_to_camel` function walks through the input string, skips underscores, and capitalizes the first letter after each underscore. It otherwise copies characters verbatim, giving a proper camel\u2011case result."]}
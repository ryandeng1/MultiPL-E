{"completions": ["Here\u2019s a compact, **C++\u201120** implementation that returns the *first* character that appears more than once in the input string.  \nIf no character repeats, the function returns `std::nullopt`.\n\n```cpp\n#include <optional>\n#include <string>\n#include <unordered_set>\n#include <cctype>      // for std::isalpha (if you want to ignore case)\n#include <algorithm>   // for std::transform, if needed\n\n/**\n * @brief  Returns the first repeated character in `text`.  \n * @param  text  The string to inspect.  \n * @return  `std::optional<std::string>` containing the repeated character\n *          as a one\u2011character string, or `std::nullopt` if none exists.\n *\n * The function is case\u2011sensitive.  If you want a case\u2011insensitive\n * search, you can normalise `text` (e.g. with std::transform and std::tolower)\n * before calling this routine.\n */\nstd::optional<std::string> first_repeated_char(const std::string& text)\n{\n    std::unordered_set<char> seen;          // keeps the characters we\u2019ve seen\n    for (char c : text) {\n        if (seen.count(c))                 // already seen \u2192 this is the first repeat\n            return std::string(1, c);      // return a one\u2011char string\n        seen.insert(c);                    // remember this char\n    }\n    return std::nullopt;                   // no repeats found\n}\n```\n\n### Quick Usage\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::string s = \"abracadabra\";\n    auto res = first_repeated_char(s);\n\n    if (res) {\n        std::cout << \"First repeated character: \" << *res << '\\n';\n    } else {\n        std::cout << \"No repeated character found.\\n\";\n    }\n}\n```\n\n**Output**\n\n```\nFirst repeated character: a\n```\n\n### Why It Works\n\n1. **Linear traversal** \u2013 We scan the string **once** (`O(n)` time).\n2. **Hash\u2011set** \u2013 `unordered_set` allows O(1) lookup/insert operations.\n3. **Early exit** \u2013 As soon as we encounter a character already in the set,\n   we return it as the first repeat.\n4. **Return type** \u2013 Using `std::optional<std::string>` gives a clear\n   indication of \u201cno result\u201d versus \u201cfound a character\u201d.\n\nFeel free to adapt the case\u2011sensitivity or the return type to your exact\nrequirements!", "```cpp\n#include <string>\n#include <optional>\n#include <unordered_set>\n\n/*  Return the first character that appears more than once in the input\n    string `s`.  The output is wrapped in `std::optional<std::string>`.\n    If the string has no repeated characters `std::nullopt` is returned. */\nstd::optional<std::string> first_repeated_char(const std::string& s)\n{\n    std::unordered_set<char> seen;\n\n    for (char c : s) {\n        if (seen.count(c))\n            return std::string(1, c);           // first repeated character\n        seen.insert(c);\n    }\n    return std::nullopt;                           // no repetition\n}\n```", "Below is a self\u2011contained, compilable C++\u201117 snippet that solves the problem \u201cfind the first repeated character in a given string\u201d.  \nIt uses only standard library facilities (no Boost or other external libs).  \nThe function returns an `std::optional<char>` \u2013 i.e. the first character that appears more than once, or `std::nullopt` if no repetition exists.  \nI also added a handful of unit\u2011tests using `assert` to demonstrate its behaviour.\n\n```cpp\n#include <cassert>        // assert\n#include <optional>       // std::optional\n#include <string>         // std::string\n#include <unordered_set>  // unordered_set in O(1) lookup\n\n/**\n * @brief  Find the first character that is repeated in a string.\n *\n * @param text  The input string.  \n * @return  An optional containing the first repeated character\n *          (in left\u2011to\u2011right order). If there is no repeated\n *          character, std::nullopt is returned.\n *\n * The algorithm runs in O(n) time and uses O(min(n, |\u03b1|)) space,\n * where |\u03b1| is the alphabet size (at most 256 for ASCII).\n */\nstd::optional<char> first_repeated_char(const std::string& text)\n{\n    std::unordered_set<char> seen;\n\n    for (char c : text)\n    {\n        if (!seen.emplace(c).second)   // emplace returns {iterator,bool}\n            return c;                 // already present \u2192 first repeat\n    }\n    return std::nullopt;   // no repetition\n}\n\n/* -------------------  Simple unit tests  ------------------- */\nint main()\n{\n    // Single repetition\n    assert(first_repeated_char(\"abca\") == 'a');\n    assert(first_repeated_char(\"hello\") == 'l');\n    assert(first_repeated_char(\"aabbcc\") == 'a');  // first repeated is 'a'\n\n    // No repetition\n    assert(!first_repeated_char(\"abcdef\").has_value());\n    assert(!first_repeated_char(\"\").has_value());\n\n    // Unicode/extended ASCII: works as long as the string is well\u2011formed\n    assert(first_repeated_char(\"\ud83d\ude42\ud83d\ude43\ud83d\ude42\") == '\ud83d\ude42');\n\n    // Mixed case is case\u2011sensitive\n    assert(first_repeated_char(\"Aa\") != 'a'); // no repeat\n\n    // Print confirmation\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Data structure**:  \n   \u2013 We keep a hash\u2011set (`std::unordered_set<char>`) of characters we have already seen.  \n   \u2013 Hash set gives O(1) average\u2011case insert and find.\n\n2. **Iteration**:  \n   \u2013 Walk the string from left to right.  \n   \u2013 For each character `c`, try to insert it into the set.  \n   \u2013 `emplace` returns a pair `{iterator, bool}` where the `bool` is `true` if the element was inserted (i.e. it did not exist before) and `false` if it was already present.  \n   \u2013 When `bool` is `false` we have found the first duplicate and return that character.\n\n3. **Return type**:  \n   \u2013 `std::optional<char>` cleanly represents \u201ccharacter *or* no character\u201d.  \n   \u2013 The caller can test with `.has_value()` or use the `operator bool()`.\n\n4. **Complexity**:  \n   \u2013 **Time**: Each character is processed once \u2192 **O(n)**.  \n   \u2013 **Space**: Hash set holds at most `min(n, alphabet_size)` characters \u2192 **O(min(n, |\u03b1|))**.\n\nFeel free to replace the `assert`\u2011based unit tests with any testing framework (Catch2, GoogleTest, etc.) that you prefer."]}
{"completions": ["```cpp\n#include <optional>\n#include <string>\n#include <vector>\n\n// Return the longest string in the vector.\n// If several strings share the maximum length, the first one is returned.\n// If the vector is empty, std::nullopt is returned.\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n    if (strings.empty())\n        return std::nullopt;\n\n    // Start with the first element as the current longest.\n    std::size_t maxIdx = 0;\n    std::size_t maxLen = strings[0].size();\n\n    for (std::size_t i = 1; i < strings.size(); ++i) {\n        const std::size_t curLen = strings[i].size();\n        if (curLen > maxLen) {\n            maxLen = curLen;\n            maxIdx = i;\n        }\n    }\n\n    return strings[maxIdx];\n}\n```", "Here is a straightforward, self\u2011contained implementation that follows the specification:\n\n```cpp\n#include <vector>\n#include <string>\n#include <optional>\n\n/// Return the longest string from `strings`.  \n/// * If several strings share the maximum length, the first one is chosen.\n/// * If `strings` is empty, `std::nullopt` is returned.\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n    if (strings.empty())\n        return std::nullopt;                 // No elements \u2192 None\n\n    // Start with the first element as the current candidate\n    std::size_t bestIdx = 0;\n\n    // Scan the rest of the vector, updating the candidate when a longer string\n    // is found.  Ties are intentionally ignored to keep the first one.\n    for (std::size_t i = 1; i < strings.size(); ++i) {\n        if (strings[i].length() > strings[bestIdx].length()) {\n            bestIdx = i;\n        }\n    }\n\n    return strings[bestIdx];                // Return a copy of the longest string\n}\n```\n\n### Explanation\n\n1. **Empty check**  \n   If the input vector is empty, the function returns `std::nullopt` as required.\n\n2. **Candidate selection**  \n   We keep the index of the currently longest string (`bestIdx`).  \n   For each subsequent string, if its length exceeds that of the current candidate, we update `bestIdx`.\n\n3. **Return value**  \n   After the loop, the string at `bestIdx` is the longest (first one in case of ties) and is returned wrapped in `std::optional`.\n\nThe function performs a single pass over the vector, so its time complexity is **O(n)**, where *n* is the number of input strings. The algorithm uses only O(1) extra space.", "Here\u2019s a concise implementation that follows the specification:\n\n```cpp\n#include <vector>\n#include <string>\n#include <optional>\n#include <algorithm>\n\n// Return the longest string in `strings`. If several strings have the same\n// maximum length, return the first one. If `strings` is empty,\n/// return std::nullopt.\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n    // If the input vector is empty, there's nothing to return.\n    if (strings.empty())\n        return std::nullopt;\n\n    // Keep track of the index of the longest string seen so far.\n    size_t maxIdx = 0;\n\n    // Iterate over the rest of the vector, comparing lengths.\n    for (size_t i = 1; i < strings.size(); ++i) {\n        if (strings[i].length() > strings[maxIdx].length()) {\n            maxIdx = i;             // a longer string found\n        }\n        // If the length is equal we do *not* update maxIdx \u2013 \n        // this guarantees we keep the first one encountered.\n    }\n\n    // Return a copy of the longest string wrapped in std::optional.\n    return strings[maxIdx];\n}\n```\n\n### Explanation\n\n1. **Empty input** \u2013 Quickly detect an empty vector and return `std::nullopt`.\n2. **Tracking index** \u2013 Using an index (`maxIdx`) ensures we keep the *first* string of maximum length; we only update it when we find a strictly longer string.\n3. **Return** \u2013 The result is wrapped in `std::optional<std::string>` as required.\n\nThis implementation runs in `O(n)` time with `O(1)` additional space."]}
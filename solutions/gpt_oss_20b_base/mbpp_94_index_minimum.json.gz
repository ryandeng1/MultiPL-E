{"completions": ["```cpp\n#include <string>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <cassert>\n\n/**\n * @brief  Return the first element of the tuple that has the\n *         smallest second element.\n *\n * @param  test_list  a vector of std::tuple<std::string,long>.\n * @return The string that comes first in the tuple whose second\n *         value is minimal. If the vector is empty an\n *         assertion failure occurs.\n */\nstd::string index_minimum(std::vector<std::tuple<std::string,long>> test_list)\n{\n    // Sanity check \u2013 the function is defined only for non\u2011empty input\n    assert(!test_list.empty());\n\n    // Find the iterator to the tuple with the smallest `second` value.\n    // std::min_element will keep the *first* such tuple if several are equal.\n    auto it = std::min_element(\n        test_list.begin(),\n        test_list.end(),\n        [](const std::tuple<std::string,long>& a,\n           const std::tuple<std::string,long>& b)\n        {\n            return std::get<1>(a) < std::get<1>(b);\n        });\n\n    // Return the first component of the found tuple.\n    return std::get<0>(*it);\n}\n```\n\n**Explanation**\n\n1. **Input validation** \u2013 The function assumes that the vector is non\u2011empty; an `assert` guarantees that the program halts with a clear message if it is empty.\n\n2. **Finding the minimum** \u2013 `std::min_element` iterates once over the vector and keeps the tuple whose second element (`std::get<1>`) is the smallest. If several tuples share the same minimal second value, the first one encountered is returned \u2013 this matches the usual behaviour of `min_element`.\n\n3. **Return value** \u2013 Once the desired tuple is found, `std::get<0>` extracts its first component, which is then returned.", "Here is a compact, well\u2011commented C++17 implementation that does exactly what you described:\n\n```cpp\n#include <vector>\n#include <tuple>\n#include <string>\n#include <stdexcept>\n#include <limits>\n\n/**\n * @brief Returns the first string of the tuple that has the smallest second value.\n *\n * @param test_list a vector of `std::tuple<std::string, long>` where the first element is\n *                  the string and the second element is the key to compare.\n *\n * @return The string part of the tuple with the minimum second value.\n *\n * @throws std::invalid_argument if the input vector is empty.\n */\nstd::string index_minimum(const std::vector<std::tuple<std::string, long>>& test_list)\n{\n    if (test_list.empty()) {\n        throw std::invalid_argument(\"index_minimum: input vector is empty\");\n    }\n\n    // initialise with the first element\n    auto      best   = test_list[0];\n    long      best_c = std::get<1>(best);\n\n    // scan the rest of the vector\n    for (const auto& item : test_list) {\n        const long c = std::get<1>(item);\n        if (c < best_c) {\n            best   = item;\n            best_c = c;\n        }\n    }\n\n    return std::get<0>(best);\n}\n```\n\n### Why this solution?\n\n* **Readability** \u2013 The code is easy to follow: we keep track of the current best tuple.\n* **Safety** \u2013 It throws an exception if the caller passes an empty vector; you can replace this with a default return value if you prefer.\n* **Standard\u2011library only** \u2013 No external dependencies beyond the C++ standard library.\n* **Performance** \u2013 One linear pass over the vector (`O(n)`), which is optimal for this task.\n\nFeel free to tweak the exception handling or the return type according to the conventions of your codebase.", "Here\u2019s a complete, self\u2011contained implementation of the requested function.  \nThe routine simply looks for the tuple that has the smallest *second* component (the `long` value) and returns the corresponding *first* component (`std::string`).  If the input vector is empty an empty string is returned \u2013 you could also throw an exception or use `std::optional<std::string>` if you prefer a stricter error handling policy.\n\n```cpp\n#include <string>\n#include <tuple>\n#include <vector>\n#include <algorithm>   // std::min_element\n#include <stdexcept>   // std::invalid_argument\n\n/**\n * @brief  Return the first value of the tuple with the smallest second value.\n *\n * @param test_list  Vector of tuples (std::string, long).  The function\n *                   considers only the second element for comparison.\n *\n * @return The string stored in the tuple that has the minimal long value.\n *\n * @throws std::invalid_argument if the vector is empty (you can change\n *                               to another error signaling mechanism).\n */\nstd::string index_minimum(const std::vector<std::tuple<std::string, long>>& test_list)\n{\n    if (test_list.empty()) {\n        // Either throw or return an empty string \u2013 choose whatever fits your\n        // error\u2011handling strategy.  Here we throw because an empty collection\n        // can't yield a meaningful minimum.\n        throw std::invalid_argument(\"index_minimum: input vector is empty\");\n    }\n\n    // Find the iterator to the tuple with the smallest 'second' element.\n    auto it = std::min_element(\n        test_list.begin(), test_list.end(),\n        [](const std::tuple<std::string, long>& a,\n           const std::tuple<std::string, long>& b)\n        {\n            // Compare by the second field only\n            return std::get<1>(a) < std::get<1>(b);\n        });\n\n    // It is guaranteed that 'it' is valid since the vector was not empty.\n    return std::get<0>(*it);\n}\n```\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<std::tuple<std::string, long>> data{\n        {\"alpha\",  10},\n        {\"beta\",   5},\n        {\"gamma\", 20}\n    };\n\n    try {\n        std::cout << \"Min key: \" << index_minimum(data) << '\\n'; // prints \"beta\"\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << '\\n';\n    }\n\n    return 0;\n}\n```\n\n#### Why this implementation?\n- `std::min_element` gives a linear\u2011time scan, which is optimal for unsorted data.\n- The lambda compares only the second component, exactly as requested.\n- Using `const` reference avoids copying the vector.\n- The function is safe for empty input (throws) and easily replaceable with an `optional` return type if you want a non\u2011throwing API."]}
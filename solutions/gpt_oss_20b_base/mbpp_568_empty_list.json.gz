{"completions": ["`std::nullopt` is not a type, it\u2019s a value that represents \u201cno value\u201d.  \nA `std::map` needs an actual type for its keys and values, therefore the template\narguments must be *type names*, e.g. `int`, `std::string`, etc.  \nIf you really only need an \u201cempty dictionary\u201d, a plain `std::map<std::string,\nstd::string>` (or any other key/value types you need) works fine.\n\nBelow is a small, self\u2011contained example that shows how to return a vector\ncontaining **N empty maps**.  The function is generic \u2013 you can specify the\nkey/value types as template arguments \u2013 and it uses only the standard\nlibrary.  The code compiles with any modern C++ compiler (C++14/17/20\u2026).\n\n```cpp\n#include <vector>\n#include <map>\n#include <string>\n\n// ---------------------------------------------------------------------------\n// Create a vector that contains `length` *empty* maps.\n// ---------------------------------------------------------------------------\n// 1.  You can specify the key/value types; here we use\n//     std::string for both.  Feel free to change them.\n// 2.  The function is `constexpr` so it can be used in constant\n//     expression contexts if the compiler supports it (C++20+).\n// ---------------------------------------------------------------------------\ntemplate <typename Key   = std::string,\n          typename Value = std::string>\ninline std::vector<std::map<Key, Value>> empty_list(std::size_t length)\n{\n    // `std::vector` constructor that creates `length` default\u2011constructed\n    // elements \u2013 here each element is an empty `std::map<Key, Value>`.\n    return std::vector<std::map<Key, Value>>(length);\n}\n\n// ---------------------------------------------------------------------------\n// Demo\n// ---------------------------------------------------------------------------\n#include <iostream>\n\nint main()\n{\n    // Create a vector of 5 empty maps (key/value are std::string)\n    auto vec = empty_list<std::string, std::string>(5);\n\n    // Show that every map is indeed empty\n    for (std::size_t i = 0; i < vec.size(); ++i)\n    {\n        std::cout << \"Map[\" << i << \"] has \"\n                  << vec[i].size() << \" entries.\\n\";\n    }\n\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Template Parameters**  \n   `Key` and `Value` default to `std::string`.  By making them template\n   parameters you can create a vector of maps with whatever types you\n   need:\n\n   ```cpp\n   auto v1 = empty_list<int, double>(3);          // vector<std::map<int,double>>\n   auto v2 = empty_list<char, char>(7);           // vector<std::map<char,char>>\n   ```\n\n2. **Initialization**  \n   `std::vector`\u2019s constructor that takes a size creates that number of\n   *default\u2011constructed* elements.  For `std::map`, the default constructor\n   creates an empty map, so the resulting vector contains only empty maps.\n\n3. **Return Value**  \n   We return a freshly constructed vector.  If you want the function to\n   **modify an existing vector in place**, pass the vector by reference:\n\n   ```cpp\n   template <typename Key = std::string, typename Value = std::string>\n   void clear_and_resize(std::vector<std::map<Key, Value>>& vec,\n                         std::size_t length)\n   {\n       vec.clear();\n       vec.resize(length);   // each entry is an empty map\n   }\n   ```\n\n4. **Header\u2011only** \u2013 No implementation file is needed; keep the\n   definition in the header so that every translation unit can see the\n   template definition.  That\u2019s why we use `inline` as a non\u2011ODR\u2011violation\n   guard.\n\nFeel free to adapt the key/value types to fit your specific use case!", "Below is a small, self\u2011contained example that shows how you can create a vector that contains **N** empty dictionaries.  \nIn C++ the most common dictionary (associative container) is `std::map`.  \nBecause you cannot use `std::nullopt` as a key or a value type, the function in your snippet has been fixed to use `int` (or any other concrete type you prefer).  If you need key\u2011value pairs of a different type, just change the template arguments.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <map>\n\n/*\n * Create a std::vector that holds `length` empty std::map objects.\n *\n * Parameters\n * ----------\n * length : std::size_t\n *     The number of empty dictionaries you want in the vector.\n *\n * Returns\n * -------\n * std::vector<std::map<Key, Value>>\n *     A vector with `length` empty maps.\n *\n * Example\n * -------\n *   auto vec = empty_list<std::string,int>(3);\n *   // vec.size() == 3\n *   // vec[0], vec[1] and vec[2] are all empty std::map<std::string,int>\n */\ntemplate <typename Key = int, typename Value = int>\nstd::vector<std::map<Key, Value>> empty_list(std::size_t length)\n{\n    // Vector default\u2011initialises each element, which for\n    // std::map means an empty map is created.\n    return std::vector<std::map<Key, Value>>(length);\n}\n\nint main()\n{\n    // Example: 5 empty maps with string keys and double values\n    auto v = empty_list<std::string, double>(5);\n\n    std::cout << \"Vector size: \" << v.size() << '\\n';\n\n    // Verify that every map is indeed empty\n    for (size_t i = 0; i < v.size(); ++i)\n        std::cout << \"Map \" << i << \" is \"\n                  << (v[i].empty() ? \"empty\\n\" : \"not empty\\n\");\n\n    // Insert something into one of the maps\n    v[2][\"pi\"] = 3.14159;\n    std::cout << \"After insertion, map 2 has \" << v[2].size() << \" element(s).\\n\";\n\n    return 0;\n}\n```\n\n### Why the original snippet didn\u2019t work\n- `std::map<std::nullopt, std::nullopt>` is invalid because `std::nullopt` is not a type; it is a value used with `std::optional<T>`.  \n- Even if you wanted \u201cempty\u201d entries of a map, you\u2019d still need concrete key/value types.\n\n### Extending the code\nIf you prefer different key/value types, just supply them when calling the template:\n\n```cpp\nauto vec1 = empty_list<int, std::string>(4);     // 4 maps: <int, std::string>\nauto vec2 = empty_list<std::string, bool>(2);    // 2 maps: <std::string, bool>\n```\n\nThe rest of the program remains identical.", "### The bug\n\n```cpp\nstd::vector<std::map<std::nullopt,std::nullopt>> empty_list(long length)\n```\n\n* `std::nullopt` is **not a type** \u2013 it is a value of type `std::nullopt_t`.  \n  It cannot be used as a key or a value type in a `std::map`.\n* A \u201cdictionary\u201d in C++ is usually a `std::map` or `std::unordered_map` whose\n  key and value type are specified.  \n  For an *empty* dictionary, you still need to tell the compiler what those\n  types are (e.g. `std::string` \u2192 `int`, `int` \u2192 `std::string`, etc.) even\n  if the container will be empty.\n\nBecause the function is supposed to create a *vector of N empty dictionaries*,\nthe concrete key/value types don\u2019t really matter \u2013 we just need a container\ntype that can be instantiated empty.\n\n---\n\n## What to do\n\n### 1. Pick appropriate key/value types\n\n* If you don\u2019t care what they are, you can use `int` \u2192 `int`, `std::string`\n  \u2192 `std::string`, or any other pair.\n* If you want the function to be generic, expose the key and value types as\n  template parameters.\n\n### 2. Use the right type\n\n```cpp\n// Simple version: fixed key/value types\nstd::vector<std::map<int, int>> empty_list(long length)\n{\n    return std::vector<std::map<int, int>>(static_cast<size_t>(length));\n}\n```\n\n### 3. Generic version (template)\n\n```cpp\ntemplate <typename Key = int, typename Value = int>\nstd::vector<std::map<Key, Value>> empty_list(long length)\n{\n    // `size_t` is the correct unsigned type for container sizes\n    if (length < 0) {\n        throw std::invalid_argument(\"length must be non\u2011negative\");\n    }\n    return std::vector<std::map<Key, Value>>(static_cast<size_t>(length));\n}\n```\n\n---\n\n## Why this works\n\n* `std::vector< T >( N )` constructs a vector that contains **N default\u2011constructed\n  elements of type `T`**.  \n  A default\u2011constructed `std::map<...>` is an empty dictionary.\n* The function returns the vector; `std::vector` is returned by value, which\n  performs a cheap move (C++17 and later perform named\u2011return\u2011value\n  optimization automatically).\n* The template version lets callers choose the key/value types:\n  ```cpp\n  auto v1 = empty_list<long, std::string>(5);   // vector<map<long, std::string>>\n  auto v2 = empty_list<>(10);                   // vector<map<int, int>>  (defaults)\n  ```\n\n---\n\n## Full working example\n\n```cpp\n#include <map>\n#include <vector>\n#include <stdexcept>\n\ntemplate <typename Key = int, typename Value = int>\nstd::vector<std::map<Key, Value>> empty_list(long length)\n{\n    if (length < 0) {\n        throw std::invalid_argument(\"length must be non\u2011negative\");\n    }\n    return std::vector<std::map<Key, Value>>(static_cast<size_t>(length));\n}\n\nint main()\n{\n    auto vec1 = empty_list<long, std::string>(3);\n    auto vec2 = empty_list<>(4);   // defaults to map<int, int>\n\n    // Verify that each map is indeed empty\n    assert(vec1.size() == 3 && vec2.size() == 4);\n    for (const auto& m : vec1) assert(m.empty());\n    for (const auto& m : vec2) assert(m.empty());\n}\n```\n\nCompile with `-std=c++17` (or newer) and run \u2013 no assertions will trigger\nand the program terminates normally."]}
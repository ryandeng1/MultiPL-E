{"completions": ["The code you posted is almost there \u2013 you just need to finish the implementation and make sure it\u2019s safe (handles empty subvectors).  \nBelow is a self\u2011contained, minimal `Extract` function that does what you described:\n\n```cpp\n#include <vector>\n#include <cassert>\n\n// Return a vector that contains the first element of each non\u2011empty sub\u2011vector\nstd::vector<long> Extract(const std::vector<std::vector<long>>& lst)\n{\n    std::vector<long> result;\n    result.reserve(lst.size());          // avoid reallocations\n\n    for (const auto& sub : lst) {\n        if (!sub.empty()) {              // skip empty sub\u2011vectors\n            result.push_back(sub.front());   // first element\n        }\n    }\n\n    return result;\n}\n\n// Optional: a quick sanity check\nint main() {\n    std::vector<std::vector<long>> data = {{5, 1, 2}, {}, {9, -3}, {7}};\n    auto firsts = Extract(data);\n    for (long x : firsts) {\n        std::cout << x << ' ';   // prints \"5 9 7 \"\n    }\n}\n```\n\n### Why this works\n- `const std::vector<std::vector<long>>& lst` \u2013 the function receives a **const reference** to avoid copying the whole container.\n- `reserve(lst.size())` \u2013 pre\u2011allocates enough space for the result, improving efficiency.\n- `for (const auto& sub : lst)` \u2013 iterates over each sub\u2011vector.\n- `if (!sub.empty()) { ... }` \u2013 ensures we never try to access the first element of an empty sub\u2011vector, which would be undefined behaviour.\n- `sub.front()` \u2013 gives the first element of a sub\u2011vector in constant time.\n\nFeel free to integrate this snippet into your larger project. If you need further tweaks (e.g., handling different numeric types, ignoring `nullptr` elements, etc.), just let me know!", "Here\u2019s a concise, self\u2011contained C++ solution that does exactly what you asked for:  \n* **`Extract`** takes a `std::vector<std::vector<long>>` and returns a new `std::vector<long>` containing the *first* element of every sub\u2011vector.  \n* If a sub\u2011vector is empty, the function ignores it (you can change this behaviour to, for example, push a sentinel value).  \n* The implementation is written in modern C++17 style, uses no external libraries, and includes a brief test harness in `main()` to illustrate its usage.\n\n```cpp\n#include <vector>\n#include <iostream>\n\n// ---------------------------------------------------------------------\n// Extract: returns the first element of each sub-vector.\n// If a sub-vector is empty, it is skipped.\n// ---------------------------------------------------------------------\nstd::vector<long> Extract(const std::vector<std::vector<long>>& lst)\n{\n    std::vector<long> result;\n    result.reserve(lst.size());               // pre\u2011allocate for efficiency\n\n    for (const auto& sub : lst) {\n        if (!sub.empty()) {                   // guard against empty sub\u2011vectors\n            result.push_back(sub.front());    // sub[0] == sub.front()\n        }\n    }\n    return result;\n}\n\n// ---------------------------------------------------------------------\n// Demo / simple test\n// ---------------------------------------------------------------------\nint main()\n{\n    // Example data\n    std::vector<std::vector<long>> data{\n        {10, 20, 30},\n        {40, 50},\n        {},                 // empty sub-vector (will be skipped)\n        {60}\n    };\n\n    auto firsts = Extract(data);\n\n    // Print the result\n    std::cout << \"First elements: \";\n    for (auto v : firsts) std::cout << v << ' ';\n    std::cout << '\\n';\n\n    return 0;\n}\n```\n\n### How it works\n\n1. **Reservation** \u2013 `reserve(lst.size())` ensures we allocate exactly enough space for the worst\u2011case (every sub\u2011vector is non\u2011empty).  \n2. **Loop** \u2013 Iterate over each sub\u2011vector with a range\u2011based loop.  \n3. **Empty check** \u2013 `if (!sub.empty())` guarantees we don\u2019t dereference an empty container.  \n4. **Add first element** \u2013 `sub.front()` (or `sub[0]`) gives the first element, which we push into `result`.  \n5. **Return** \u2013 The gathered vector of first elements is returned to the caller.\n\nFeel free to adjust the empty\u2011sub\u2011vector policy (e.g., inserting a sentinel value or throwing an exception) depending on your exact requirements.", "Below is a small, self\u2011contained C++17/20 function that takes a vector of vectors of `long` (you can also template it if you want) and returns a new `std::vector<long>` which contains the first element of every sub\u2011vector.  \nIf a sub\u2011vector is empty we skip it \u2013 you can change that behaviour if you need an exception or a sentinel value.\n\n```cpp\n#include <vector>\n\n/*  Extract \u2013 return the first element of each inner vector\n *  ------------------------------------------------------------------------\n *  We expect:\n *    lst[i]   \u2192 std::vector<long>\n *    result   \u2192 std::vector<long>  (size == number of non\u2011empty inner vectors)\n *\n *  Example:\n *    std::vector<std::vector<long>> x{{3,5},{1,2,3},{}, {7}};\n *    auto r = Extract(x);  // r == {3, 1, 7}\n */\nstd::vector<long> Extract(const std::vector<std::vector<long>>& lst) {\n    std::vector<long> result;\n    result.reserve(lst.size());              // reserve max possible capacity\n\n    for (const auto& sub : lst) {\n        if (!sub.empty()) {                  // skip empty sub-vectors\n            result.push_back(sub.front());   // first element\n        }\n    }\n    return result;\n}\n```\n\n### Why this implementation\n\n| Requirement | Implementation |\n|-------------|----------------|\n| **Generic for any `std::vector<std::vector<T>>`** | Use `long` as requested; to make it generic you could template over `T`. |\n| **Performance** | `reserve` avoids repeated reallocations; `front()` is `O(1)` for `std::vector`. |\n| **Safety** | Works safely with empty inner vectors (`sub.empty()` guard). |\n| **Portability** | Uses only the C++ Standard Library \u2013 works on GCC, Clang, MSVC, etc. |\n\n### Optional Enhancements\n\n| Feature | How |\n|---------|-----|\n| **Throw on empty sub\u2011vector** | Replace the guard with `if (sub.empty()) throw std::out_of_range{...};` |\n| **Keep index info** | Return `std::vector<std::pair<size_t, long>>` instead. |\n| **Support other container types** | Make the function a template that accepts any `Container` whose value type is itself a container. |\n\nFeel free to drop this snippet into your project or adapt it to meet any extra constraints you have. Happy coding!"]}
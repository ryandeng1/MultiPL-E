{"completions": ["Below is a straightforward implementation of the grading function in C++.  \nIt follows the table you gave, using the conditions in the order you listed.  \nIf a GPA is exactly a boundary (e.g. 3.7, 3.3, \u2026) it will receive the higher\nletter grade according to the inequalities (`>`, `<`, `==`).  \n\n```cpp\n#include <vector>\n#include <string>\n\n/*  Grade conversion according to the table:\n\n    GPA       | Letter grade\n    4.0       | A+\n    > 3.7     | A\n    > 3.3     | A-\n    > 3.0     | B+\n    > 2.7     | B\n    > 2.3     | B-\n    > 2.0     | C+\n    > 1.7     | C\n    > 1.3     | C-\n    > 1.0     | D+\n    > 0.7     | D\n    > 0.0     | D-\n    0.0       | E\n*/\n\nstd::vector<std::string>\nnumerical_letter_grade(const std::vector<float>& grades) {\n    std::vector<std::string> res;\n    res.reserve(grades.size());\n\n    for (float gpa : grades) {\n        if (gpa >= 4.0f)          // only 4.0 gives A+\n            res.push_back(\"A+\");\n        else if (gpa > 3.7f)      // >3.7 \u2192 A\n            res.push_back(\"A\");\n        else if (gpa > 3.3f)      // >3.3 \u2192 A-\n            res.push_back(\"A-\");\n        else if (gpa > 3.0f)      // >3.0 \u2192 B+\n            res.push_back(\"B+\");\n        else if (gpa > 2.7f)      // >2.7 \u2192 B\n            res.push_back(\"B\");\n        else if (gpa > 2.3f)      // >2.3 \u2192 B-\n            res.push_back(\"B-\");\n        else if (gpa > 2.0f)      // >2.0 \u2192 C+\n            res.push_back(\"C+\");\n        else if (gpa > 1.7f)      // >1.7 \u2192 C\n            res.push_back(\"C\");\n        else if (gpa > 1.3f)      // >1.3 \u2192 C-\n            res.push_back(\"C-\");\n        else if (gpa > 1.0f)      // >1.0 \u2192 D+\n            res.push_back(\"D+\");\n        else if (gpa > 0.7f)      // >0.7 \u2192 D\n            res.push_back(\"D\");\n        else if (gpa > 0.0f)      // >0.0 \u2192 D-\n            res.push_back(\"D-\");\n        else                      // exactly 0.0 or negative values\n            res.push_back(\"E\");\n    }\n\n    return res;\n}\n```\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<float> gpas{4.0f, 3.0f, 1.7f, 2.0f, 3.5f};\n    auto letters = numerical_letter_grade(gpas);\n\n    for (const auto& l : letters)\n        std::cout << l << ' ';\n    // Output: A+ B C- C A-\n}\n```\n\nThe function is `O(n)` in time and uses only a plain vector for the output.  \nFeel free to adjust the boundaries (e.g., change `>= 4.0f` to `> 3.9999f`) if you want to\nhandle floating\u2011point precision nuances.", "Here is a clean implementation of the `numerical_letter_grade` function that follows the exact grade\u2011to\u2011letter mapping you provided.  \nFeel free to copy\u2011paste it into your project.\n\n```cpp\n#include <vector>\n#include <string>\n\n//-----------------------------------------------------------------\n// Convert a vector of numeric GPAs (0.0 \u2026 4.0) to their letter\n// equivalents using the grading table supplied in the question.\n//-----------------------------------------------------------------\nstd::vector<std::string> numerical_letter_grade(const std::vector<float>& grades)\n{\n    std::vector<std::string> result;\n    result.reserve(grades.size());          // avoid repeated reallocations\n\n    for (float gpa : grades)\n    {\n        // The 4.0 GPA is a special case \u2013 it is always \"A+\"\n        if (gpa >= 4.0f)\n            result.push_back(\"A+\");\n        else if (gpa > 3.7f)\n            result.push_back(\"A\");\n        else if (gpa > 3.3f)\n            result.push_back(\"A-\");\n        else if (gpa > 3.0f)\n            result.push_back(\"B+\");\n        else if (gpa > 2.7f)\n            result.push_back(\"B\");\n        else if (gpa > 2.3f)\n            result.push_back(\"B-\");\n        else if (gpa > 2.0f)\n            result.push_back(\"C+\");\n        else if (gpa > 1.7f)\n            result.push_back(\"C\");\n        else if (gpa > 1.3f)\n            result.push_back(\"C-\");\n        else if (gpa > 1.0f)\n            result.push_back(\"D+\");\n        else if (gpa > 0.7f)\n            result.push_back(\"D\");\n        else if (gpa > 0.0f)\n            result.push_back(\"D-\");\n        else\n            result.push_back(\"E\");\n    }\n\n    return result;\n}\n```\n\n### How it works\n* We walk through each GPA in the input vector and compare it, **in descending order**, to the thresholds from your table.  \n* Because the logic uses strict \u201cgreater than\u201d (`>`) checks and a single special case for `gpa >= 4.0f`, the mapping matches exactly what you described.  \n* The function returns a new vector of strings with the same order as the input.\n\n### Example usage\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<float> gpas = {4.0f, 3.0f, 1.7f, 2.0f, 3.5f};\n    auto letters = numerical_letter_grade(gpas);\n\n    for (const auto& letter : letters)\n        std::cout << letter << ' ';\n    // Output: A+ B C- C A-\n}\n```\n\nFeel free to adjust the rounding or type handling if you need stricter numeric precision (e.g., use `double` or `long double`).", "**Solution**\n\nWe simply map each GPA value to the appropriate letter according to the given\nthresholds.  \nBecause the thresholds are mutually exclusive and sorted in descending order,\na straight\u2011forward chain of `if\u2011else` statements is enough and keeps the code\neasy to read and fast.  \nThe algorithm runs in **O(n)** time where *n* is the number of GPA values, and\nuses **O(1)** additional memory.\n\n```cpp\n#include <vector>\n#include <string>\n\n// ------------------------------------------------------------\n// Convert a vector of GPAs to the corresponding letter grades\n// ------------------------------------------------------------\nstd::vector<std::string> numerical_letter_grade(const std::vector<float>& grades)\n{\n    std::vector<std::string> result;\n    result.reserve(grades.size());          // no re\u2011allocation\n\n    for (float gpa : grades)\n    {\n        if      (gpa >= 4.0f)               result.push_back(\"A+\");\n        else if (gpa >  3.7f)               result.push_back(\"A\");\n        else if (gpa >  3.3f)               result.push_back(\"A-\");\n        else if (gpa >  3.0f)               result.push_back(\"B+\");\n        else if (gpa >  2.7f)               result.push_back(\"B\");\n        else if (gpa >  2.3f)               result.push_back(\"B-\");\n        else if (gpa >  2.0f)               result.push_back(\"C+\");\n        else if (gpa >  1.7f)               result.push_back(\"C\");\n        else if (gpa >  1.3f)               result.push_back(\"C-\");\n        else if (gpa >  1.0f)               result.push_back(\"D+\");\n        else if (gpa >  0.7f)               result.push_back(\"D\");\n        else if (gpa >  0.0f)               result.push_back(\"D-\");\n        else /* gpa == 0.0 */               result.push_back(\"E\");\n    }\n\n    return result;\n}\n```\n\n**Example**\n\n```cpp\nauto gp = std::vector<float>{4.0f, 3.0f, 1.7f, 2.0f, 3.5f};\nauto grades = numerical_letter_grade(gp);\n// grades == {\"A+\", \"B\", \"C-\", \"C\", \"A-\"}\n```\n\nThe function respects all the rules in the lookup table and works for any\nvector of non\u2011negative floating\u2011point GPAs."]}
{"completions": ["Here\u2019s a minimal, self\u2011contained C++ function that takes a `std::vector<long>` (any integral type will work) and swaps the first and last elements.  \nYou can drop it straight into your program or wrap it in a header/source file as needed.\n\n```cpp\n#include <vector>\n#include <utility>   // std::swap\n#include <stdexcept> // std::out_of_range\n\n// ------------------------------------------------------------------\n// Swap the first and last items of a vector.\n// ------------------------------------------------------------------\nstd::vector<long> swap_List(std::vector<long> newList)\n{\n    // If the vector has fewer than 2 elements, swapping makes no sense.\n    if (newList.size() < 2) {\n        // Option 1: simply return the vector unchanged.\n        // Option 2: throw an exception to signal misuse.\n        // throw std::out_of_range(\"swap_List requires at least 2 elements\");\n        return newList;\n    }\n\n    std::swap(newList.front(), newList.back());\n    return newList;\n}\n```\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<long> v = {10, 20, 30, 40, 50};\n    std::vector<long> swapped = swap_List(v);\n\n    for (auto x : swapped) {\n        std::cout << x << ' ';\n    }\n    // Output: 50 20 30 40 10\n}\n```\n\n#### What\u2019s happening?\n\n| Step | Code | Description |\n|------|------|-------------|\n| 1 | `if (newList.size() < 2) { \u2026 }` | Handles edge cases \u2013 a vector with 0 or 1 element doesn\u2019t need swapping. |\n| 2 | `std::swap(newList.front(), newList.back());` | Exchanges the first and last elements using the standard `std::swap` algorithm. |\n| 3 | `return newList;` | Returns the modified vector. |\n\nFeel free to adapt the error\u2011handling strategy to your style (e.g., return a boolean, use `std::optional`, or keep the exception approach).", "Below is a minimal, but complete, C++ implementation that performs the swap of the first and last elements of a `std::vector<long>`.  \nFeel free to copy\u2011paste it into your project or extend it with additional checks if you need more robustness.\n\n```cpp\n#include <vector>\n#include <stdexcept>   // for std::out_of_range\n\n/// @brief Swaps the first and last elements of a vector.\n/// @param vec The vector to modify (passed by value to avoid side\u2011effects).\n/// @return A new vector with its first and last elements exchanged.\n/// @throws std::out_of_range if the vector contains fewer than two elements.\nstd::vector<long> swap_List(std::vector<long> vec)\n{\n    // Check that the vector is large enough to perform a swap.\n    if (vec.size() < 2)\n        throw std::out_of_range(\"swap_List: vector must contain at least 2 elements\");\n\n    std::swap(vec.front(), vec.back());   // std::swap is defined for all copy\u2011constructible types\n    return vec;\n}\n```\n\n### How to use it\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<long> data = {1, 2, 3, 4, 5};\n\n    std::vector<long> swapped = swap_List(data);\n\n    for (auto v : swapped)\n        std::cout << v << ' ';\n    // Output: 5 2 3 4 1\n}\n```\n\n### Optional notes\n\n| Feature | Description |\n|---------|-------------|\n| **Pass\u2011by\u2011value** | The input vector is copied; this avoids changing the caller\u2019s vector. If you want an *in\u2011place* operation, take the argument by reference (`std::vector<long>&`) and return `void`. |\n| **Exception safety** | The function throws a `std::out_of_range` if the vector has fewer than two elements. Adjust or swallow the error handling depending on your context. |\n| **Portability** | No `<bits/stdc++.h>`; only standard headers (`<vector>` and `<stdexcept>`). |\n| **No assertions** | Using `std::swap` is safe; no need for `<assert.h>`. |\n\nFeel free to adapt the code fragment to your existing project structure.", "Here is a clean, self\u2011contained C++ implementation of the requested function.  \nThe implementation is written in standard C++17 (it will work seamlessly on any C++ compiler that supports the standard library).\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <stdexcept>\n#include <iostream> // (optional) only for demonstration\n\n/**\n * @brief Swaps the first and last elements of the supplied vector.\n *\n * If the vector has fewer than two elements the function throws\n * a std::invalid_argument exception because a swap would be meaningless.\n *\n * @param newList The vector whose first and last items are to be swapped.\n * @return std::vector<long> A new vector with the two elements exchanged.\n */\nstd::vector<long> swap_List(std::vector<long> newList)\n{\n    if (newList.size() < 2) {\n        throw std::invalid_argument(\"swap_List requires at least two elements\");\n    }\n\n    // swap the first and last elements\n    std::swap(newList.front(), newList.back());\n\n    return newList;\n}\n\n/* ------------------------------------------------------------------ */\n/* The following code is only for demonstration and optional testing   */\n/* ------------------------------------------------------------------ */\nint main()\n{\n    std::vector<long> original{1, 2, 3, 4, 5};\n\n    try {\n        auto swapped = swap_List(original);\n        std::cout << \"After swap: \";\n        for (auto v : swapped) std::cout << v << ' ';\n        std::cout << '\\n';\n    } catch (const std::exception &e) {\n        std::cerr << \"Error: \" << e.what() << '\\n';\n    }\n\n    return 0;\n}\n```\n\n### How it works\n\n1. **Size check** \u2013 Before attempting a swap we ensure the vector contains at least two elements.  \n   If not, an exception is thrown so that the caller knows the operation cannot be performed.\n\n2. **Swap** \u2013 We use the standard library helper `std::swap` on the vector\u2019s first and last elements (`front()` and `back()`).\n\n3. **Return** \u2013 A new vector (the modified copy) is returned, leaving the original unchanged, which matches the function signature that accepts the vector **by value**.\n\nFeel free to copy the code into your project or unit\u2011test it further!"]}
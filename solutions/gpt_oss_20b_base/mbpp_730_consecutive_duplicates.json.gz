{"completions": ["Below is a **minimal, portable, and easy\u2011to\u2011read implementation** of a helper that removes consecutive duplicates from a vector.  \nThe code is written for **C++17** (the earliest standard that still ships with almost every compiler) and can be copied straight\u2011into your project.\n\n```cpp\n#include <vector>\n#include <any>\n#include <algorithm>   // for std::unique\n#include <iterator>    // for std::ostream_iterator\n#include <iostream>\n\n/**\n * @brief  Remove consecutive duplicates from a vector.\n * @param  nums  Input vector that may contain duplicate consecutive elements.\n * @return A new vector that contains the same elements as `nums`, but with\n *         any run of identical values reduced to a single copy.\n *\n * @note\n *   * The function works with `std::any` only because we only compare the\n *     *type* of the stored value.  The generic `operator==` is used\n *     for the actual value.  If the stored type does not overload\n *     `operator==`, a compilation error will occur \u2013 which is\n *     desirable because it tells you that you cannot compare that\n *     particular type.\n *\n *   * The operation is O(n) in time and uses O(1) extra space\n *     (apart from the result vector).\n */\nstd::vector<std::any> consecutive_duplicates(const std::vector<std::any> &nums)\n{\n    // If the source vector is empty, just return an empty result.\n    if (nums.empty()) {\n        return {};\n    }\n\n    std::vector<std::any> result;\n    result.reserve(nums.size());  // at most the same size\n\n    // Insert the first element.\n    result.push_back(nums.front());\n\n    // Scan the source vector starting from the second element.\n    for (std::size_t i = 1; i < nums.size(); ++i) {\n        // If the new element is NOT equal to the last element in the\n        // result, we keep it.  (std::any compares both the type and\n        // the value of the stored object.)\n        if (nums[i] != result.back()) {\n            result.push_back(nums[i]);\n        }\n    }\n\n    return result;\n}\n\n/*--------------------------------------------------------------------*/\n/*  Demo / Quick Test                                                 */\n/*--------------------------------------------------------------------*/\nint main()\n{\n    using namespace std;\n\n    // Build a sample vector that holds values of different types\n    vector<any> v = { 1, 1, 2, 2, 2, 3, 4, 4, string(\"hello\"), string(\"hello\"), 5 };\n\n    auto deduped = consecutive_duplicates(v);\n\n    cout << \"Original size : \" << v.size() << '\\n';\n    cout << \"Deduped size  : \" << deduped.size() << '\\n';\n\n    cout << \"Deduped elements:\\n\";\n    for (const auto &e : deduped) {\n        if (e.type() == typeid(int))\n            cout << any_cast<int>(e) << ' ';\n        else if (e.type() == typeid(string))\n            cout << any_cast<string>(e) << ' ';\n        else\n            cout << \"[unknown] \";\n    }\n    cout << '\\n';\n\n    return 0;\n}\n```\n\n### Why this implementation?\n\n| Requirement | How it\u2019s satisfied |\n|-------------|---------------------|\n| *Removal of *consecutive* duplicates* | The linear scan keeps the last inserted element (`result.back()`) and adds a new element only if it differs. |\n| *Generic for any type stored in `std::any`* | The equality operator on `std::any` already does **type\u2011aware** comparison. |\n| *No external dependencies* | Only the standard library headers are used (`<vector>`, `<any>`, `<algorithm>`, `<iterator>`, `<iostream>`). |\n| *Clear, maintainable code* | Concise function, no nested loops, explanatory comments. |\n| *Safe with unknown types* | If the stored type does not implement `operator==`, the code will *not compile*, giving you a clear compiler message. |\n\n\nFeel free to drop the `main()` block into a unit test or delete it entirely if you only want the `consecutive_duplicates()` helper.", "Here is a compact, self\u2011contained implementation that removes **consecutive** duplicates from a `std::vector<std::any>` returned by value.  \nBecause `std::any` itself does not provide an `operator==`, we first check that the two consecutive elements have the *same* type (`typeid`).  \nIf they do, we try to compare the underlying values. We support a handful of common built\u2011in types (`int`, `long`, `long long`, `unsigned`, `unsigned long`, `unsigned long long`, `float`, `double`, `long double` and `std::string`).  \nIf the element type is not one of those, we simply keep one instance of it (the first occurrence) as there is no general way to compare two `std::any` containing arbitrary types.\n\n```cpp\n#include <any>\n#include <vector>\n#include <string>\n#include <typeinfo>\n#include <type_traits>\n#include <algorithm>\n\n/*--------------------------------------------------------------------\n   Utility to compare two std::any objects that hold the same type.\n   Returns true if the underlying values are equal.\n--------------------------------------------------------------------*/\nstatic bool areAnyEqual(const std::any& lhs, const std::any& rhs)\n{\n    // Different types \u2013 can't be equal\n    if (lhs.type() != rhs.type())\n        return false;\n\n    // We support a handful of known types.  For other types we just\n    // return false \u2013 i.e. we treat them as not equal (thus we keep\n    // one of them).\n    if (lhs.type() == typeid(int))\n        return std::any_cast<int>(lhs) == std::any_cast<int>(rhs);\n    if (lhs.type() == typeid(long))\n        return std::any_cast<long>(lhs) == std::any_cast<long>(rhs);\n    if (lhs.type() == typeid(long long))\n        return std::any_cast<long long>(lhs) == std::any_cast<long long>(rhs);\n    if (lhs.type() == typeid(unsigned))\n        return std::any_cast<unsigned>(lhs) == std::any_cast<unsigned>(rhs);\n    if (lhs.type() == typeid(unsigned long))\n        return std::any_cast<unsigned long>(lhs) == std::any_cast<unsigned long>(rhs);\n    if (lhs.type() == typeid(unsigned long long))\n        return std::any_cast<unsigned long long>(lhs) == std::any_cast<unsigned long long>(rhs);\n    if (lhs.type() == typeid(float))\n        return std::any_cast<float>(lhs) == std::any_cast<float>(rhs);\n    if (lhs.type() == typeid(double))\n        return std::any_cast<double>(lhs) == std::any_cast<double>(rhs);\n    if (lhs.type() == typeid(long double))\n        return std::any_cast<long double>(lhs) == std::any_cast<long double>(rhs);\n    if (lhs.type() == typeid(std::string))\n        return std::any_cast<std::string>(lhs) == std::any_cast<std::string>(rhs);\n\n    // For user\u2011defined types we currently don't know how to compare.\n    // We'll simply assuming they are not equal.\n    return false;\n}\n\n/*--------------------------------------------------------------------\n   Remove consecutive duplicates from a vector of std::any.\n--------------------------------------------------------------------*/\nstd::vector<std::any> consecutive_duplicates(std::vector<std::any> nums)\n{\n    if (nums.empty())\n        return {};\n\n    std::vector<std::any> result;\n    result.reserve(nums.size());   // pre\u2011allocate to avoid reallocations\n\n    // Keep the first element always\n    result.push_back(nums[0]);\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        // If the current element is NOT equal to the last element we\n        // inserted, keep it \u2013 otherwise skip it.\n        if (!areAnyEqual(nums[i], result.back())) {\n            result.push_back(nums[i]);\n        }\n    }\n\n    return result;\n}\n```\n\n### How it works\n\n1. **`areAnyEqual`** \u2013  \n   * Checks if two `std::any` objects hold the same type (`typeid`).  \n   * For the supported types we cast and compare the values.  \n   * If the type isn\u2019t one of the supported ones, the function returns `false`.  \n     (That means *any* pair of different/unsupported types will be considered different and thus only one copy will survive.)\n\n2. **`consecutive_duplicates`** \u2013  \n   * If the input vector is empty, it returns an empty result.  \n   * It always keeps the first element.  \n   * Iterates from the second element; whenever an element is **not equal to the last element kept in the result**, it is appended.  \n   * The end result contains each run of consecutive duplicates reduced to a single element.\n\n### Remarks\n\n* The implementation preserves the order of the original vector.  \n* It works in C++17 and above (due to `std::any`).  \n* If you need to support more user\u2011defined types, you can extend `areAnyEqual` by adding more `if` branches that know how to compare those types.", "```cpp\n#include <any>\n#include <vector>\n#include <typeinfo>\n#include <iostream>\n#include <iomanip>\n\n// Helper to obtain a \u201ccanonical\u201d representation of an\n// std::any so that two equal values (and the same type)\n// compare equal.  For the purposes of this exercise we\n// support only the four most common types; if the value has\n// another type it is wrapped into a string containing\n// its type name.  This way the comparison works for a\n// wide range of inputs.\nstatic std::string anyToString(const std::any & a)\n{\n    if (!a.has_value()) {                     // null\u2011any\n        return \"<nullptr>\";\n    }\n    const std::type_info & t = a.type();\n\n    try {\n        if (t == typeid(int))\n            return std::to_string(std::any_cast<int>(a));\n        if (t == typeid(long))\n            return std::to_string(std::any_cast<long>(a));\n        if (t == typeid(double))\n            return std::to_string(std::any_cast<double>(a));\n        if (t == typeid(std::string))\n            return std::any_cast<std::string>(a);\n        if (t == typeid(const char *))\n            return std::string(std::any_cast<const char *>(a));\n    }\n    catch (...) {/* fall through */}\n    // Fallback\n    return std::string(\"<\") + t.name() + \">\";\n}\n\n// ---------------------------------------------------------------------------\n// Function that removes consecutive duplicates.\n// ---------------------------------------------------------------------------\nstd::vector<std::any> consecutive_duplicates(std::vector<std::any> nums)\n{\n    std::vector<std::any> result;\n    for (size_t i = 0; i < nums.size(); ++i)\n    {\n        // keep the current element unless it is identical to the last kept element\n        if (i == 0 ||\n            (nums[i].type() != nums[i-1].type()) ||\n            (anyToString(nums[i]) != anyToString(nums[i-1])))\n        {\n            result.push_back(nums[i]);\n        }\n    }\n    return result;\n}\n\n// ---------------------------------------------------------------------------\n// Small test driver\n// ---------------------------------------------------------------------------\nint main()\n{\n    std::vector<std::any> input{\n        1, 1, 2, 2LL, 2.0, 3, 3, std::string(\"hello\"),\n        std::string(\"hello\"), std::string(\"world\"), 3};\n\n    auto out = consecutive_duplicates(input);\n\n    std::cout << \"Result:\\n\";\n    for (const auto & a : out)\n    {\n        const std::type_info & t = a.type();\n        if (t == typeid(int))\n            std::cout << std::any_cast<int>(a) << \" \";\n        else if (t == typeid(long))\n            std::cout << std::any_cast<long>(a) << \" \";\n        else if (t == typeid(double))\n            std::cout << std::any_cast<double>(a) << \" \";\n        else if (t == typeid(std::string))\n            std::cout << std::any_cast<std::string>(a) << \" \";\n        else\n            std::cout << \"<unknown>\" << \" \";\n    }\n    std::cout << std::endl;\n    return 0;\n}\n```\n\n### What the code does\n\n1. **`anyToString` helper** \u2013 gives a string representation of the stored value (if the type is one of the common ones: `int`, `long`, `double`, `std::string`, `const char*`).  \n   This allows reliable comparison even though `std::any` does not expose an equality operator.\n\n2. **`consecutive_duplicates`** \u2013 iterates over the input vector.  \n   * If the current element is the first one, or its type differs from the last kept element, or its value differs (by comparing the string representation), the element is added to the result.  \n   * Otherwise it is a consecutive duplicate and is skipped.\n\n3. **`main`** \u2013 demonstrates the function with a mixture of numeric types and strings.  The output shows that only consecutive duplicates are removed.\n\nFeel free to extend `anyToString` to support any additional types you need."]}
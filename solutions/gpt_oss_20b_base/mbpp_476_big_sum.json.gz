{"completions": ["Here\u2019s a short, clean implementation that keeps the logic self\u2011contained and well\u2011documented:\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n/*\n * big_sum: Return the sum of the largest and smallest elements in a vector.\n *\n * Parameters:\n *   nums \u2013 a vector of long integers\n *\n * Behavior:\n *   * If the vector is empty, an assertion is triggered (you can change this to\n *     throw an exception or return 0, depending on your error\u2011handling\n *     policy).\n *   * For a single element the result is simply twice that element.\n *\n * Time Complexity:  O(n)   \u2013 a single scan finds min and max\n * Space Complexity: O(1)   \u2013 only a few variables\n */\nlong big_sum(const std::vector<long> &nums)\n{\n    assert(!nums.empty() && \"Vector must contain at least one element.\");\n\n    long min_val = nums[0];\n    long max_val = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        if (nums[i] < min_val) min_val = nums[i];\n        if (nums[i] > max_val) max_val = nums[i];\n    }\n\n    return min_val + max_val;\n}\n```\n\n### Why this version?\n\n| Feature | Why it\u2019s useful |\n|--------|-----------------|\n| **Single pass** | Only one loop \u2192 O(n) time. |\n| **No extra containers** | No `std::min_element`/`std::max_element` calls, saving a bit of overhead. |\n| **Assertion** | Guarantees the vector isn\u2019t empty, avoiding undefined behaviour. |\n| **Const\u2011reference parameter** | Avoids copying the input vector while still allowing read\u2011only access. |\n\n---\n\n#### Quick test harness (optional)\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> v{5, 2, 9, 1, 7};\n    std::cout << \"Sum of min and max: \" << big_sum(v) << '\\n';  // outputs 10\n}\n```\n\nFeel free to tweak the error handling (e.g., throw `std::invalid_argument` instead of `assert`) to match the conventions of your project.", "Below is a compact and self\u2011contained C++ implementation of a function that returns the sum of the largest and smallest element in a vector of integers.  \nThe function is written in idiomatic C++ (C++17/20), is heavily commented to explain each step, and includes simple unit\u2011tests that you can run to verify its behaviour.\n\n```cpp\n/*  big_sum.cpp\n    Author: OpenAI ChatGPT\n    Purpose: Return the sum of the maximum and minimum values in a vector.\n*/\n\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <iostream>\n\n/**\n * @brief Computes the sum of the largest and smallest element in a vector.\n *\n * @param nums A vector of (signed) 64\u2011bit integers.\n * @return long long The sum of the maximum and minimum values.\n *\n * @throws std::invalid_argument if the input vector is empty.\n *\n * @note  The function operates in O(n) time and O(1) extra space.\n */\nlong long big_sum(const std::vector<long long>& nums) {\n    if (nums.empty()) {\n        throw std::invalid_argument(\"Vector must contain at least one element.\");\n    }\n\n    // Initialise min and max with the first element.\n    long long min_val = nums.front();\n    long long max_val = nums.front();\n\n    // Scan through the vector once to find min and max.\n    for (const auto& x : nums) {\n        if (x < min_val) min_val = x;\n        if (x > max_val) max_val = x;\n    }\n\n    return min_val + max_val;\n}\n\n/* ====================   Unit Tests   ===================== */\n\nvoid test_basic() {\n    assert(big_sum({3, 5, 1, 4}) == 6);   // min=1, max=5\n    assert(big_sum({-10, 0, 10}) == 0);   // min=-10, max=10\n    assert(big_sum({42}) == 84);          // min=max=42\n}\n\nvoid test_random() {\n    std::mt19937_64 rng(12345);\n    std::uniform_int_distribution<long long> dist(-1000, 1000);\n\n    for (int t = 0; t < 1000; ++t) {\n        std::vector<long long> v;\n        int size = dist(rng) % 50 + 1; // ensure non\u2011empty\n        for (int i = 0; i < size; ++i)\n            v.push_back(dist(rng));\n\n        long long expected = *std::min_element(v.begin(), v.end())\n                            + *std::max_element(v.begin(), v.end());\n        assert(big_sum(v) == expected);\n    }\n}\n\nvoid test_empty() {\n    try {\n        big_sum({});\n        assert(false && \"Expected exception for empty vector\");\n    } catch (const std::invalid_argument&) {\n        // Correct behavior\n    }\n}\n\nint main() {\n    test_basic();\n    test_random();\n    test_empty();\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\n### How to Compile & Run\n\n```bash\ng++ -std=c++17 -O2 -Wall -Wextra -pedantic big_sum.cpp -o big_sum\n./big_sum\n```\n\nThe program prints `All tests passed!` if everything works correctly. Feel free to integrate `big_sum` into your own projects or modify the unit tests to suit your needs.", "Here is a minimal, self\u2011contained C++ function that receives a `std::vector<long>` and returns the sum of its largest and smallest element.  \nIf the vector is empty we simply return 0 (you can change this behavior if you want to throw an exception instead).\n\n```cpp\n#include <vector>\n#include <algorithm>   // for std::minmax_element\n#include <stdexcept>   // for std::invalid_argument\n\n/// @brief Computes the sum of the largest and smallest values in a vector.\n///\n/// @param nums A vector of long integers.\n/// @return The sum of the smallest and largest elements.\n/// @throws std::invalid_argument if the vector is empty.\nlong big_sum(const std::vector<long>& nums)\n{\n    if (nums.empty())\n        throw std::invalid_argument(\"Input vector must not be empty.\");\n\n    // std::minmax_element returns a pair of iterators:\n    // first  \u2192 iterator to the smallest element\n    // second \u2192 iterator to the largest  element\n    auto [min_it, max_it] = std::minmax_element(nums.begin(), nums.end());\n\n    return *min_it + *max_it;\n}\n```\n\n### How it works\n1. **Empty check** \u2013 We guard against an empty vector to avoid undefined behavior when dereferencing iterators.\n2. **`std::minmax_element`** \u2013 This single pass algorithm gives us both the minimum and maximum values in *O(n)* time and *O(1)* extra space.\n3. **Return the sum** \u2013 Dereference the iterators to get the numeric values and add them.\n\n### Example usage\n\n```cpp\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<long> data{3, 5, 1, 9, 2};\n    try {\n        long result = big_sum(data);\n        std::cout << \"Sum of largest and smallest: \" << result << '\\n';  // 1 + 9 = 10\n    } catch (const std::exception& e) {\n        std::cerr << e.what() << '\\n';\n    }\n    return 0;\n}\n```\n\nFeel free to adapt the error\u2011handling strategy to whatever suits your project."]}
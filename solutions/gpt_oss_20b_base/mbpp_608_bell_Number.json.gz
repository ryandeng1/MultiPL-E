{"completions": ["Sure! Below is a self\u2011contained C++ implementation that returns the *n*\u2011th Bell number.  \nIt uses the recurrence relation based on Stirling numbers of the second kind:\n\n\\[\nB_{n+1}=\\sum_{k=0}^{n}\\binom{n}{k}\\,B_k\n\\]\n\nWith this recurrence the values can be built up iteratively in **O(n\u00b2)** time, which is more than fast enough for the usual range of `n` in competitive\u2011programming problems (up to a few thousands).  \nThe function works with arbitrary precision integers (`boost::multiprecision::cpp_int`) so you can request arbitrarily large Bell numbers without overflow.\n\n```cpp\n#include <bits/stdc++.h>\n#include <boost/multiprecision/cpp_int.hpp>\n\nusing namespace std;\nusing boost::multiprecision::cpp_int;\n\n// ------------------------------------------------------------\n// Returns the n-th Bell number (B_0 = 1, B_1 = 1, B_2 = 2, ...)\n// ------------------------------------------------------------\ncpp_int bell_Number(long n) {\n    if (n < 0) throw std::invalid_argument(\"n must be non\u2011negative\");\n\n    // bell[i] will hold B_i\n    vector<cpp_int> bell(n + 1);\n    bell[0] = 1;          // B_0\n    if (n == 0) return bell[0];\n\n    bell[1] = 1;          // B_1\n\n    // Pre\u2011compute binomial coefficients C(n,k)\n    // We only need them for the current row, so we reuse a single vector\n    vector<cpp_int> binom(n + 1);\n    binom[0] = 1;\n    for (long i = 1; i <= n; ++i) {\n        // Compute B_i using the recurrence\n        cpp_int sum = 0;\n        for (long k = 0; k < i; ++k) {\n            // Update binomial: C(i-1, k) \u2192 C(i, k)\n            // binom[k] currently holds C(i-1, k)\n            sum += binom[k] * bell[k];\n        }\n\n        bell[i] = sum;\n\n        // Update binom for next iteration (Pascal's triangle)\n        for (long k = i; k > 0; --k) {\n            binom[k] = binom[k] + binom[k - 1];\n        }\n        binom[0] = 1; // C(i,0) = 1\n    }\n\n    return bell[n];\n}\n\n// ------------------------------------------------------------\n// Optional main for quick testing\n// ------------------------------------------------------------\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    long n;\n    cout << \"Enter n to compute B_n: \";\n    if (!(cin >> n)) return 0;\n\n    try {\n        cpp_int ans = bell_Number(n);\n        cout << \"B_\" << n << \" = \" << ans << \"\\n\";\n    } catch (const std::exception &e) {\n        cerr << \"Error: \" << e.what() << \"\\n\";\n    }\n\n    return 0;\n}\n```\n\n### How it works\n\n1. **Dynamic programming**  \n   `bell[i]` holds the \\(i\\)-th Bell number.  \n   For each new \\(i\\) we compute\n   \\[\n   B_i = \\sum_{k=0}^{i-1} \\binom{i-1}{k}\\,B_k.\n   \\]\n\n2. **Binomial coefficients on the fly**  \n   Rather than recomputing binomial coefficients from scratch, the array `binom` is updated in a Pascal\u2011triangle style:\n   \\[\n   \\binom{i}{k} = \\binom{i-1}{k} + \\binom{i-1}{k-1}.\n   \\]\n   This keeps the algorithm\u2019s complexity at \\(O(n^2)\\).\n\n3. **Arbitrary precision**  \n   The type `cpp_int` stores integers of any size, so even `B_1000` (\u2248 10^2105) can be computed safely.\n\n### Complexity\n\n- **Time** \u2013 \\(O(n^2)\\) additions/multiplications of big integers.  \n- **Memory** \u2013 \\(O(n)\\) for the Bell array and the binomial array.\n\nFeel free to drop this function into any of your projects or adapt it for special cases (e.g., modulo arithmetic). Happy coding!", "Below is a **self\u2011contained C++** implementation that computes the *n*\u2011th Bell number.\nIt uses the classic **Bell triangle (Aitken\u2019s array)** \u2013 no huge factorials, no\nfloating point rounding \u2013 and works for all values that fit into a 64\u2011bit\nunsigned integer (the values grow very fast; for `n=25` you\u2019re already at\n`5\u00b710^15`).  \n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* ---------------------------------------------------------------\n *  Return the n\u2011th Bell number B(n)   (B(0) = 1)\n *\n *  Implementation:  Bell triangle (Aitken\u2019s array)\n *  Complexity:  O(n^2)\n *  Large numbers are handled with `unsigned long long`.\n *  For n > 25 the result does not fit into 64 bits.\n * --------------------------------------------------------------- */\nunsigned long long bell_Number(unsigned long long n)\n{\n    if (n == 0) return 1ULL;          // B(0) = 1\n\n    // vector of vectors \u2013 each row i has i+1 entries\n    vector<vector<unsigned long long>> bell(n + 1);\n\n    // 0\u2011th row\n    bell[0].push_back(1ULL);          // B(0)\n\n    // Build the triangle\n    for (unsigned long long i = 1; i <= n; ++i) {\n        bell[i].resize(i + 1);        // i\u2011th row has i+1 entries\n\n        // First element of the new row\n        bell[i][0] = bell[i - 1][i - 1];\n\n        // The rest of the row \u2013 each element is the sum of the\n        // element immediately above it and to the left.\n        for (unsigned long long j = 1; j <= i; ++j) {\n            bell[i][j] = bell[i][j - 1] + bell[i - 1][j - 1];\n        }\n    }\n\n    // The first element of the last row is B(n)\n    return bell[n][0];\n}\n\n/* -------------------- Test / Demo ---------------------------- */\nint main()\n{\n    for (int n = 0; n <= 15; ++n) {\n        cout << \"B(\" << n << \") = \" << bell_Number(n) << '\\n';\n    }\n    return 0;\n}\n```\n\n### How it works\n\n1. **Bell triangle**  \n   - Row `i` has `i+1` entries.  \n   - First entry of row `i` comes from the last entry of the previous row.  \n   - Every subsequent entry is the sum of the element directly above it and the one to its left.\n\n2. **Bell number**  \n   The first element of row `n` (i.e. `bell[n][0]`) equals the *n*\u2011th Bell number.\n\n### Sample output\n\n```\nB(0) = 1\nB(1) = 1\nB(2) = 2\nB(3) = 5\nB(4) = 15\nB(5) = 52\nB(6) = 203\nB(7) = 877\nB(8) = 4140\nB(9) = 21147\nB(10) = 115975\nB(11) = 678570\nB(12) = 4213597\nB(13) = 27644437\nB(14) = 190899322\nB(15) = 1382958545\n```\n\n### Notes\n\n* The algorithm runs in `O(n\u00b2)` time and uses `O(n\u00b2)` memory.  \n  For small `n` this is trivial; even for `n = 200` it finishes in milliseconds.\n* The returned type is `unsigned long long`.  The maximum value that still fits is\n  `B(25) \u2248 5.6\u00b710^15`.  \n  For larger `n` you\u2019ll need arbitrary\u2011precision arithmetic (e.g., `boost::multiprecision::cpp_int`).\n\nFeel free to tweak the code for big\u2011integer support or for a more memory\u2011efficient\nvariant (one can keep only the current row).", "Below is a complete, self\u2011contained C++ implementation that computes the *n*\u2011th Bell number.  \nIt uses the classic **Bell triangle** (Stirling triangle) approach, which runs in \u0398(n\u00b2) time and uses\nO(n) additional memory \u2013 good enough for the usual range of *n* you\u2019ll see in competitive\u2011programming\nor interview problems (e.g. *n* \u2264 1000).  \n\nIf you need even larger numbers you can switch the `long long` type to `__int128` or to a big\u2011integer\nlibrary such as Boost.Multiprecision, but the algorithm itself stays the same.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// -----  Bell number ----------------------------------------------------\n/*\n   bellNumber(n) returns the n\u2011th Bell number\n\n   Bell numbers (starting with B0 = 1) count the number of partitions of an\n   n\u2011element set.  They satisfy\n       B_{n+1} = sum_{k=0}^{n} C(n,k) * B_k\n   but the most efficient way for moderate n is to build the\n   Bell triangle (also called the Stanley or \u201cStirling\u201d triangle).\n\n   Complexity:   \u0398(n\u00b2) time, \u0398(n) memory\n   Integer type: unsigned long long (64\u2011bit).  Overflow occurs\n                  around B95 \u2248 5e56, so use arbitrary precision\n                  if you need larger values.\n*/\nunsigned long long bellNumber(long n)\n{\n    if (n == 0) return 1ULL;          // B0 = 1\n\n    vector<unsigned long long> prev(1, 1ULL);   // triangle row for i-1\n    for (long i = 1; i <= n; ++i) {\n        vector<unsigned long long> cur(i + 1, 0ULL);\n        cur[0] = prev.back();                // first element of the new row\n        for (long j = 1; j <= i; ++j) {\n            cur[j] = cur[j-1] + prev[j-1];   // recurrence of the triangle\n        }\n        prev.swap(cur);                      // prepare for next iteration\n    }\n    return prev[0];   // top of the last triangle = B_n\n}\n\n// -----------  Optional  \u2013 big integer support (Boost) -------------\n/*\n   #include <boost/multiprecision/cpp_int.hpp>\n   using boost::multiprecision::cpp_int;\n   cpp_int bellNumberBig(long n) { ... }   // same algorithm but with cpp_int\n*/\n\n// -----  Main \u2013 example ------------------------------------------------\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    long n;\n    if(!(cin >> n)) return 0;\n    cout << bellNumber(n) << '\\n';\n    return 0;\n}\n```\n\n### How the Bell triangle works\n\n```\nRow 0:         1\nRow 1:         1   2\nRow 2:         2   3   5\nRow 3:         5   7  12  17\n...\n```\n\n* The first element of each row is the last element of the previous row.\n* Every other element is the sum of the element to its left and the element\n  directly above\u2011left.\n\nThe first element of the *i*\u2011th row equals `B_i` (i.e. the *i*\u2011th Bell number).\n\n### Why this is a good choice\n\n* **No modular arithmetic** \u2013 you get the exact integer (up to the limits of the type).\n* **Fast enough** \u2013 `O(n\u00b2)` is acceptable for `n` up to a few thousand on modern hardware.\n* **Easy to understand** \u2013 the loop structure mirrors the definition of the triangle.\n\nFeel free to adapt the type or swap to a big\u2011integer library if you need to handle very large Bell numbers."]}
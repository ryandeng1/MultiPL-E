{"completions": ["Here\u2019s a compact *C++* implementation that performs a bit\u2011wise XOR on two binary strings (composed only of `'0'` and `'1'`).  \nThe function accepts two `std::string` objects, aligns them from the right (least significant bit), and returns the XOR result as a new string.  \nIf the input strings are of different lengths, the result is padded with leading zeros so that the length matches the longer input.\n\n```cpp\n#include <string>\n#include <algorithm>   // for std::reverse\n\n// Performs bit\u2011wise XOR on two binary strings (containing only '0' and '1').\n// The result is returned as a string of the same length as the longer input.\nstd::string string_xor(const std::string& a, const std::string& b)\n{\n    // Work with copies because we\u2019ll reverse them.\n    std::string A = a;\n    std::string B = b;\n\n    // Reverse so that least\u2011significant bits are at position 0.\n    std::reverse(A.begin(), A.end());\n    std::reverse(B.begin(), B.end());\n\n    std::size_t max_len = std::max(A.size(), B.size());\n    std::string result;\n    result.reserve(max_len);\n\n    for (std::size_t i = 0; i < max_len; ++i)\n    {\n        char bitA = (i < A.size() ? A[i] : '0');\n        char bitB = (i < B.size() ? B[i] : '0');\n\n        // XOR: result bit is '1' if bits differ, else '0'.\n        result.push_back( (bitA != bitB) ? '1' : '0' );\n    }\n\n    // Reverse back to most\u2011significant\u2011bit first order.\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n\n// Example usage\nint main() {\n    std::string x = string_xor(\"010\", \"110\");\n    // x should be \"100\"\n}\n```\n\n### How it works\n1. **Reverse the input strings** \u2013 this makes it easy to iterate from least\u2011significant to most\u2011significant bit.\n2. **Iterate over the longer string**, treating missing bits of the shorter string as `'0'`.\n3. **Compute the XOR**: `bitA != bitB` produces `true` for differing bits \u2192 `'1'`, otherwise `'0'`.\n4. **Reverse the result** back to the original order.\n\nThis code is O(max(|a|, |b|)) in time and uses O(1) extra space besides the result string.", "```cpp\n#include <string>\n#include <algorithm>\n\n/**\n * Perform bit\u2011wise XOR on two binary strings.\n *\n * The two strings may have different lengths.  In that case the\n * shorter one is left\u2011padded with zeros so that the XOR is carried\n * out bit by bit from the least\u2011significant bit.\n *\n * @param a first binary string (only '0' and '1')\n * @param b second binary string (only '0' and '1')\n * @return a binary string representing a XOR b\n */\nstd::string string_xor(std::string a, std::string b) {\n    // Make the strings the same length by padding the shorter one\n    // with leading zeros.\n    if (a.size() < b.size()) {\n        a.insert(a.begin(), b.size() - a.size(), '0');\n    } else if (b.size() < a.size()) {\n        b.insert(b.begin(), a.size() - b.size(), '0');\n    }\n\n    std::string res;\n    res.reserve(a.size());\n\n    // XOR each corresponding bit\n    for (size_t i = 0; i < a.size(); ++i) {\n        char ai = a[i];\n        char bi = b[i];\n        // Both ai and bi are '0' or '1'.\n        // XOR: 0^0=0, 0^1=1, 1^0=1, 1^1=0\n        res.push_back((ai == bi) ? '0' : '1');\n    }\n\n    // It's customary to strip leading zeros from the result,\n    // but keep at least one digit.\n    size_t first_one = res.find_first_not_of('0');\n    if (first_one != std::string::npos) {\n        return res.substr(first_one);\n    } else {\n        return \"0\";  // result is zero\n    }\n}\n```\n\nThis function:\n\n1. Pads the shorter string with leading zeros to match lengths.\n2. Performs a bit\u2011wise XOR for each character.\n3. Returns the resulting binary string (leading zeros removed, except when the result is zero).", "Here is a minimal, self\u2011contained implementation of `string_xor`.  \nIt checks that the two inputs are the same length (you can relax this later), performs the XOR bit\u2011wise, and returns the resulting binary string.\n\n```cpp\n#include <string>\n#include <stdexcept>\n\n/**\n * @brief Compute binary XOR of two equal\u2011length strings composed of '0' and '1'.\n *\n * @param a First binary string.\n * @param b Second binary string.\n * @return XOR of a and b.\n * @throws std::invalid_argument if the strings have different lengths or contain\n *         characters other than '0' and '1'.\n */\nstd::string string_xor(const std::string& a, const std::string& b)\n{\n    if (a.size() != b.size())\n        throw std::invalid_argument(\"Inputs must have the same length\");\n\n    std::string result;\n    result.reserve(a.size());          // reserve space to avoid reallocations\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if ((a[i] != '0' && a[i] != '1') || (b[i] != '0' && b[i] != '1'))\n            throw std::invalid_argument(\"Inputs must contain only '0' or '1'\");\n\n        // XOR: 0 ^ 0 = 0, 1 ^ 1 = 0, 0 ^ 1 = 1, 1 ^ 0 = 1\n        result.push_back( (a[i] == b[i]) ? '0' : '1' );\n    }\n    return result;\n}\n```\n\n### How it works\n\n1. **Input validation** \u2013 Ensures both strings are of equal length and contain only `\"0\"` or `\"1\"`.  \n2. **Processing** \u2013 Iterates through the strings once, compares each pair of bits, and appends the XOR result (`'0'` if bits are equal, `'1'` otherwise).  \n3. **Return** \u2013 The XOR result is returned as a new string.\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::string a = \"010\";\n    std::string b = \"110\";\n    std::cout << string_xor(a, b) << '\\n';   // prints: 100\n}\n```\n\nFeel free to adjust the error handling or extend the function to support strings of different lengths by padding with leading zeros if that behavior is desired."]}
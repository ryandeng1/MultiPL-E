{"completions": ["Below is a complete, self\u2011contained implementation of `find_kth`.  \nIt works for any two sorted vectors (ascending order) and returns the *k*\u2011th **1\u2011based** element that would appear if the two vectors were merged into a single sorted array.\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <stdexcept>\n\n/*\n * Find the k\u2011th element (1\u2011based) from the union of two sorted vectors.\n *\n * Parameters:\n *   arr1, arr2 \u2013 sorted (ascending) vectors\n *   k          \u2013 1 \u2264 k \u2264 arr1.size() + arr2.size()\n *\n * Return:\n *   The k\u2011th smallest element in the merged sequence.\n *\n * Throws:\n *   std::invalid_argument if k is out of bounds.\n *\n * Complexity:\n *   O(log(min(n1, n2))) time, O(1) extra space.\n */\nlong find_kth(std::vector<long> const& arr1,\n              std::vector<long> const& arr2,\n              long k)\n{\n    const long n1 = arr1.size(), n2 = arr2.size();\n\n    // sanity check\n    if (k < 1 || k > n1 + n2)\n        throw std::invalid_argument(\"k is out of bounds\");\n\n    // ensure arr1 is the shorter array to keep the binary\u2011search range small\n    if (n1 > n2)\n        return find_kth(arr2, arr1, k);\n\n    long left  = std::max(0LL, k - n2);          // smallest possible index in arr1\n    long right = std::min(n1, k);                // largest possible index in arr1\n\n    while (left <= right) {\n        long i = left + (right - left) / 2; // partition index in arr1\n        long j = k - i;                     // partition index in arr2\n\n        // guard values for boundary conditions\n        long A_left  = (i == 0)      ? LLONG_MIN : arr1[i - 1];\n        long A_right = (i == n1)     ? LLONG_MAX : arr1[i];\n        long B_left  = (j == 0)      ? LLONG_MIN : arr2[j - 1];\n        long B_right = (j == n2)     ? LLONG_MAX : arr2[j];\n\n        if (A_left <= B_right && B_left <= A_right) {\n            // we have found the correct partition\n            return std::max(A_left, B_left);\n        } else if (A_left > B_right) {\n            // need to move i left\n            right = i - 1;\n        } else { // B_left > A_right\n            // need to move i right\n            left = i + 1;\n        }\n    }\n\n    // unreachable under correct pre\u2011conditions, but return something to keep\n    // the compiler happy\n    throw std::runtime_error(\"Unexpected error in find_kth\");\n}\n```\n\n### How it works\n1. **Binary Search on the smaller array**  \n   We binary\u2011search over the number of elements taken from `arr1` (`i`).  \n   The remaining `k-i` elements come from `arr2`.\n\n2. **Partition Check**  \n   For a candidate `i` we compute\n   ```\n   A_left  = arr1[i-1] (or -\u221e if i == 0)\n   A_right = arr1[i]   (or +\u221e if i == n1)\n   B_left  = arr2[j-1] (or -\u221e if j == 0)\n   B_right = arr2[j]   (or +\u221e if j == n2)\n   ```\n   `i` is correct if `A_left \u2264 B_right` **and** `B_left \u2264 A_right`.  \n   Then the answer is `max(A_left, B_left)`.\n\n3. **Adjust Search Range**  \n   \u2013 If `A_left > B_right`, we need fewer elements from `arr1` \u2192 move left.  \n   \u2013 Else we need more \u2192 move right.\n\n### Example\n```cpp\nstd::vector<long> a = {1, 3, 5};\nstd::vector<long> b = {2, 4, 6, 8};\nstd::cout << find_kth(a, b, 5); // prints 5\n```\n\nThe function is fully `O(log\u202fmin(n1,\u202fn2))` and uses only a handful of variables.", "Below is a complete, self\u2011contained implementation of the function `find_kth`.  \nThe idea is to use the classic **divide\u2011and\u2011conquer** approach that runs in  \n`O(log\u202fk)` time (logarithmic in the rank we\u2019re looking for) and uses only\nconstant extra space.\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <stdexcept>\n\n/**\n * @brief   Returns the k\u2011th smallest element in the union of\n *          two sorted vectors.\n *\n * @param   arr1   First sorted vector (by non\u2011decreasing values).\n * @param   arr2   Second sorted vector (by non\u2011decreasing values).\n * @param   k      1\u2011based rank (1 \u2264 k \u2264 arr1.size()+arr2.size()).\n *\n * @return The k\u2011th smallest element.\n *\n * @throws std::out_of_range if k is outside the valid range.\n */\nlong find_kth(std::vector<long> const& arr1,\n              std::vector<long> const& arr2,\n              long k)\n{\n    size_t n1 = arr1.size();\n    size_t n2 = arr2.size();\n\n    if (k < 1 || k > static_cast<long>(n1 + n2))\n        throw std::out_of_range{\"k is out of bounds\"};\n\n    size_t index1 = 0;          // current start index in arr1\n    size_t index2 = 0;          // current start index in arr2\n\n    while (true) {\n        /* Handle corner cases */\n        if (index1 == n1)  // arr1 is exhausted\n            return arr2[index2 + k - 1];\n        if (index2 == n2)  // arr2 is exhausted\n            return arr1[index1 + k - 1];\n        if (k == 1)        // we want the smallest of the two current elements\n            return std::min(arr1[index1], arr2[index2]);\n\n        /* Divide k into two parts.  We look at the k/2\u2011th element in\n           each array if it exists; otherwise we use the last element. */\n        size_t step = k / 2;\n\n        size_t newIndex1 = std::min(index1 + step, n1) - 1;\n        size_t newIndex2 = std::min(index2 + step, n2) - 1;\n\n        long pivot1 = arr1[newIndex1];\n        long pivot2 = arr2[newIndex2];\n\n        /* Eliminate a portion of one array and adjust k accordingly */\n        if (pivot1 <= pivot2) {\n            // discard elements arr1[index1 .. newIndex1]\n            k -= (newIndex1 - index1 + 1);\n            index1 = newIndex1 + 1;\n        } else {\n            // discard elements arr2[index2 .. newIndex2]\n            k -= (newIndex2 - index2 + 1);\n            index2 = newIndex2 + 1;\n        }\n    }\n}\n```\n\n### Why this works\n\n* Because both input vectors are sorted, the `k`\u2011th element of their union must\n  lie in the first `k` elements when the two vectors are virtually merged.\n* In each iteration we discard at least `k/2` elements.  \n  Thus the number of elements we still have to examine halves each time,\n  giving a logarithmic time complexity.\n\n### Complexity\n\n* **Time:** `O(log\u202fk)` (worst case when `k` is close to the total length)\n* **Space:** `O(1)` (only a few indices and variables)\n\n### Usage example\n\n```cpp\nint main() {\n    std::vector<long> a = {1, 3, 5, 7};\n    std::vector<long> b = {2, 4, 6, 8, 10};\n\n    long kth = find_kth(a, b, 5);   // 5th smallest element\n    std::cout << kth << '\\n';       // prints 5\n}\n```\n\nThis function handles all edge cases correctly: when one vector is empty,\nwhen `k` is 1, or when `k` equals the total size of the two vectors.", "**Solution Explanation**\n\nFor two sorted arrays `A` and `B` (length `m` and `n`) we have to obtain the\n*k*-th smallest element in the union of both arrays  \n(`k` is **1\u2011based**, i.e. `k = 1` \u2192 the smallest element).\n\nWe must keep the total complexity better than *O(m + n)*:  \n`O(log(min(m,n)))` is enough.  \nThe classic technique is a binary search over the \u201csplit point\u201d of one array.\n\n--------------------------------------------------------------------\n\n### 1.  Idea\n\nAssume we take `i` elements from `A` (the first `i` elements, `0 \u2264 i \u2264 m`).\nThe remaining `k \u2013 i` elements must come from `B`.  \nFor a valid partition we need\n\n```\ni + (k-i) = k\n```\n\nand the last element taken from `A` must be \u2264 the first element not taken\nfrom `B`, and vice versa.\n\n```\n   A[i-1] <= B[(k-i)]          (1)\n   B[k-i-1] <= A[i]            (2)\n```\n\n(When an index is out of bounds we treat the corresponding value as\n`-\u221e` or `+\u221e`.)\n\nIf both inequalities hold we found the correct split \u2013 the answer is  \n\n```\nmax( A[i-1], B[k-i-1] )          // the largest among the chosen prefix\n```\n\nThe task reduces to finding an `i` that satisfies the conditions.\nBecause `i` is bounded by `m`, a binary search over `0 \u2026 m` works.\n\n--------------------------------------------------------------------\n\n### 2.  Algorithm\n\n```text\nfunction kth(arr1, arr2, k)\n    m \u2190 size(arr1); n \u2190 size(arr2)\n    // Ensure arr1 is the smaller one\n    if m > n\n        return kth(arr2, arr1, k)\n\n    lo \u2190 max(0, k - n)          // cannot take more than n from B\n    hi \u2190 min(k, m)              // cannot take more than m from A\n\n    while lo \u2264 hi\n        i \u2190 (lo + hi) / 2          // take i from A\n        j \u2190 k - i                  // take j from B\n\n        Aleft  \u2190 (i == 0)  ?  -\u221e : arr1[i-1]\n        Aright \u2190 (i == m) ?  +\u221e : arr1[i]\n        Bleft  \u2190 (j == 0)  ?  -\u221e : arr2[j-1]\n        Bright \u2190 (j == n) ?  +\u221e : arr2[j]\n\n        if Aleft > Bright\n            // i is too big \u2192 shrink hi\n            hi \u2190 i - 1\n        else if Bleft > Aright\n            // i is too small \u2192 grow lo\n            lo \u2190 i + 1\n        else\n            // perfect partition\n            return max(Aleft, Bleft)\n    end while\n\n    // Should never reach here if k is valid\n    throw error\nend\n```\n\n--------------------------------------------------------------------\n\n### 3.  Correctness Proof  \n\nWe prove that the algorithm returns the *k*-th smallest element.\n\n---\n\n#### Lemma 1  \nDuring the binary search the invariant  \n`lo \u2264 i \u2264 hi` is maintained, i.e. the searched `i` is always between `lo`\nand `hi`.\n\n*Proof.*  \nInitially, `lo = max(0, k-n)` and `hi = min(k, m)`.  \nBoth satisfy `0 \u2264 i \u2264 m` and `i \u2264 k`, hence any feasible split `i` lies\ninside `[lo, hi]`.  \n\nAt each step we adjust either `hi \u2190 i-1` or `lo \u2190 i+1` after checking a\npartition that does **not** satisfy the conditions.  \nBecause such a partition forces the correct `i` to lie strictly on the\nopposite side (see Lemma&nbsp;2), the new interval still contains the\ncorrect split. \u220e\n\n\n\n#### Lemma 2  \nIf `Aleft > Bright`, the correct split has `i` smaller than the current\n`i`.  \nIf `Bleft > Aright`, the correct split has `i` larger than the current\n`i`.\n\n*Proof.*  \n\n*Case 1:* `Aleft > Bright`  \nThe element just before the cut in `A` is larger than the element right\nafter the cut in `B`.  \nSo, at current `i`, an element from `B` is missing in the first `k`\nelements of the merged array (since it should be before `Aleft`).\nDecreasing `i` increases the number taken from `B` and can move the cut\nto the right place.\n\n*Case 2:* `Bleft > Aright`  \nSymmetric reasoning: the element from `A` is too large, we need to take\nmore from `A`, so increase `i`. \u220e\n\n\n\n#### Lemma 3  \nWhen the algorithm returns, the conditions (1) and (2) are satisfied\nand `max(Aleft,Bleft)` is the k-th smallest element.\n\n*Proof.*  \nThe loop terminates only when neither inequality in Lemma&nbsp;2 holds,\nhence `Aleft \u2264 Bright` and `Bleft \u2264 Aright`.  \nThus the first `k` elements of both arrays are exactly the first `i`\nelements of `A` and the first `k-i` elements of `B`.  \nAll remaining elements are greater or equal to `max(Aleft, Bleft)`.  \nTherefore this maximum is the last of the first `k` elements \u2013 i.e. the\n*k*-th smallest. \u220e\n\n\n\n#### Theorem  \n`kth(arr1, arr2, k)` returns the *k*-th smallest element of the union of\n`arr1` and `arr2`, provided `1 \u2264 k \u2264 m+n`.  \n\n*Proof.*  \nBy Lemma&nbsp;1 the binary search always keeps the true split candidate\ninside the search interval.  \nLemmas&nbsp;2 and 3 show that the algorithm eventually finds a valid\nsplit and returns the correct element. \u220e\n\n\n\n--------------------------------------------------------------------\n\n### 4.  Complexity Analysis\n\nLet `m = |arr1|`, `n = |arr2|`.\n\n* The binary search runs for `O(log min(m,n))` iterations.\n* Each iteration does constant work.\n\n```\nTime   : O(log min(m, n))\nMemory : O(1)   (besides input arrays)\n```\n\n--------------------------------------------------------------------\n\n### 5.  Reference Implementation (C++17)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/**\n * @brief  Return the k-th smallest element of the union of two ascendingly\n *         sorted vectors.\n *\n * @param arr1  first sorted vector\n * @param arr2  second sorted vector\n * @param k     1\u2011based rank (1 <= k <= arr1.size() + arr2.size())\n * @return      value of the k\u2011th element\n */\nlong find_kth(vector<long> arr1, vector<long> arr2, long k) {\n    size_t m = arr1.size();\n    size_t n = arr2.size();\n\n    // Guard against wrong k\n    assert(k >= 1 && k <= static_cast<long>(m + n));\n\n    // Make arr1 the smaller array to keep the binary search small\n    if (m > n) {\n        return find_kth(arr2, arr1, k);\n    }\n\n    // lo = min elements we have to take from arr1\n    // hi = max elements we can take from arr1\n    long lo = max<long>(0, k - static_cast<long>(n));\n    long hi = min<long>(k, static_cast<long>(m));\n\n    const long INF = numeric_limits<long>::max();\n    const long NINF = numeric_limits<long>::min();\n\n    while (lo <= hi) {\n        long i = (lo + hi) / 2;          // elements from arr1\n        long j = k - i;                  // elements from arr2\n\n        long Aleft  = (i == 0) ? NINF : arr1[i - 1];\n        long Aright = (i == static_cast<long>(m)) ? INF : arr1[i];\n        long Bleft  = (j == 0) ? NINF : arr2[j - 1];\n        long Bright = (j == static_cast<long>(n)) ? INF : arr2[j];\n\n        if (Aleft > Bright) {\n            // need fewer elements from arr1\n            hi = i - 1;\n        } else if (Bleft > Aright) {\n            // need more elements from arr1\n            lo = i + 1;\n        } else {\n            // proper split found\n            return max(Aleft, Bleft);\n        }\n    }\n\n    // If k is valid we should never fall through\n    throw std::logic_error(\"Invalid input: k out of bounds\");\n}\n\n/* ------- optional test harness --------\nint main() {\n    vector<long> a = {1, 3, 5, 7};\n    vector<long> b = {2, 4, 6, 8, 9};\n\n    for (int k = 1; k <= a.size() + b.size(); ++k) {\n        cout << \"k=\" << k << \": \" << find_kth(a, b, k) << endl;\n    }\n    return 0;\n}\n*/\n```\n\nThe code follows exactly the algorithm proven correct above and\nconforms to the C++17 standard."]}
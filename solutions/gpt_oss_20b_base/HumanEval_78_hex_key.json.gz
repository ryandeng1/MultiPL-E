{"completions": ["```cpp\n#include <string>\n\nlong hex_key(const std::string &num)\n{\n    // Set of hex digits that correspond to prime numbers\n    // 2,3,5,7,B(11),D(13)\n    static const std::string primes = \"2357BD\";\n    long count = 0;\n\n    for (char c : num) {\n        // Since the input guarantees uppercase A\u2013F, we can search directly\n        if (primes.find(c) != std::string::npos)\n            ++count;\n    }\n    return count;\n}\n```\n\n**Explanation**\n\n- The prime hex digits are `{2, 3, 5, 7, B, D}`.  \n- We iterate through each character of the input string, checking whether it exists in the `primes` string.  \n- `std::string::find` returns `std::string::npos` when the character isn\u2019t found, so a simple `if` statement counts only the prime digits.  \n- The function returns the final count (as `long` per the original signature). No other checks are needed because the problem guarantees that the input string is either empty or contains only correct hexadecimal symbols.", "Here is a simple, self\u2011contained implementation in C++.  \nThe function follows the specification exactly: it receives a (possibly empty) string that contains only valid hexadecimal digits (0\u20119,\u202fA\u2011F, all uppercase), counts the digits that represent prime numbers (2,\u202f3,\u202f5,\u202f7,\u202fB,\u202fD) and returns that count.\n\n```cpp\n#include <string>\n#include <unordered_set>\n\n/**\n * @brief Counts the number of hexadecimal digits that are prime.\n *\n * @param num A string containing a hexadecimal number (may be empty).\n * @return int The count of prime digits.\n */\nint hex_key(const std::string &num)\n{\n    // Set of prime digits in hexadecimal notation.\n    // 2, 3, 5, 7 are prime decimal digits; B (=11) and D (=13) are the only\n    // prime values from A\u2013F.\n    static const std::unordered_set<char> primes =\n    { '2', '3', '5', '7', 'B', 'D' };\n\n    int count = 0;\n    for (char c : num)\n    {\n        if (primes.find(c) != primes.end())\n            ++count;\n    }\n    return count;\n}\n```\n\n### Usage examples\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::cout << hex_key(\"AB\")          << '\\n'; // 1\n    std::cout << hex_key(\"1077E\")       << '\\n'; // 2\n    std::cout << hex_key(\"ABED1A33\")    << '\\n'; // 4\n    std::cout << hex_key(\"123456789ABCDEF0\") << '\\n'; // 6\n    std::cout << hex_key(\"2020\")        << '\\n'; // 2\n    std::cout << hex_key(\"\")            << '\\n'; // 0\n}\n```\n\nThe function has **O(n)** time complexity with *n* being the length of the input string, and it uses only a small constant amount of additional memory.", "To finish the implementation you just need to count how many of the characters in the input string belong to the set of hexadecimal primes  \n\n`{ '2', '3', '5', '7', 'B', 'D' }`.  \nThe string is guaranteed to be lower\u2011case clean and possibly empty.\n\n```cpp\n#include <string>\n#include <unordered_set>\n\nlong hex_key(std::string num) {\n    // Set of hex digits that represent prime numbers\n    const std::unordered_set<char> primes = {\n        '2', '3', '5', '7', 'B', 'D'\n    };\n\n    long count = 0;\n    for (char c : num) {\n        if (primes.count(c)) ++count;\n    }\n    return count;\n}\n```\n\nThis runs in `O(n)` time with `O(1)` extra space, easily satisfying the problem constraints."]}
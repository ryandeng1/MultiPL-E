{"completions": ["**Solution Explanation**\n\nFor a string that contains only parentheses\n\n```\nbalance   : total number of '(' minus ')'\nmin_prefix: the minimum value of the running balance while scanning the string left \u2192 right\n```\n\n`balance` tells how many more open parentheses the string needs (if negative) or\nhow many unmatched close\u2011parentheses it has.  \n`min_prefix` tells whether an inner prefix ever goes below zero which would\nbreak a correct parenthesis sequence.\n\nFor two strings **A** and **B** we want to know if\n\n```\nA+B  (A first, then B)\nB+A  (B first, then A)\n```\n\nis a balanced parenthesis string.  \nThe condition for a correct concatenation is\n\n```\n1. the running balance never becomes negative during the whole walk\n2. the final running balance after the whole walk is 0\n```\n\n--------------------------------------------------------------------\n\n#### 1.  Prefix rule\n\nWhile scanning **A** we let `bal_one` be the running balance.\n`bal_one` must never be negative \u2013 that is exactly `min_prefixA >= 0`.\n\nWhen we start **B** the current balance is `balanceA`.\nDuring the walk of **B** the running balance becomes\n\n```\nbalanceA + running_balance_of_B\n```\n\nThe smallest value this can take is\n\n```\nbalanceA + min_prefixB\n```\n\nSo for the concatenation `A+B` the two necessary conditions are\n\n```\nmin_prefixA                         \u2265 0\nbalanceA + min_prefixB              \u2265 0\nbalanceA + balanceB                 == 0\n```\n\nThe same reasoning gives the conditions for `B+A`.\n\n--------------------------------------------------------------------\n\n#### 2.  Algorithm\n```\nfor each string s in the list:\n    compute balance(s) and min_prefix(s)\n\nfor the two strings s0 , s1:\n    if  (min_pref0 >= 0 and balance0 + min_pref1 >= 0 and balance0+balance1 == 0)\n        return \"Yes\"\n    if  (min_pref1 >= 0 and balance1 + min_pref0 >= 0 and balance0+balance1 == 0)\n        return \"Yes\"\nreturn \"No\"\n```\n\nComplexity is linear in the length of the two strings \u2013  \n`O(|s0| + |s1|)` time and `O(1)` extra space.\n\n--------------------------------------------------------------------\n\n#### 3.  Correctness Proof  \n\nWe prove that the algorithm returns \u201cYes\u201d iff a good concatenation exists.\n\n---\n\n##### Lemma 1  \nFor a string `S`, `min_prefixS >= 0` iff every prefix of `S` has\nnon\u2011negative running balance.\n\n**Proof.**  \n`min_prefixS` is defined as the minimum of all prefix balances.\nIf this minimum is non\u2011negative, all prefixes are non\u2011negative.\nConversely, if every prefix is non\u2011negative, that minimum can\u2019t be negative. \u220e\n\n\n\n##### Lemma 2  \nFor two strings `A` and `B` the string `A+B` is balanced  \niff  \n`min_prefixA \u2265 0`  and  \n`balanceA + min_prefixB \u2265 0`  and  \n`balanceA + balanceB = 0`.\n\n**Proof.**\n\n*Necessity.*  \nIf `A+B` is balanced, each prefix of it is non\u2011negative.  \nThe prefix inside `A` gives `min_prefixA \u2265 0`.  \nThe first prefix that starts inside `B` has balance  \n`balanceA + running_balance_of_B`.  \nIts minimum value is `balanceA + min_prefixB`, so that must be\nnon\u2011negative.  \nFinally, after the whole walk the balance is `balanceA+balanceB`,\nwhich must be zero.\n\n*Sufficiency.*  \nAssume the three equalities hold.  \nDuring the walk inside `A` no prefix becomes negative by the first inequality\n(Lemma&nbsp;1).  \nDuring the walk inside `B` the current balance is  \n`balanceA + running_balance_of_B`; the smallest possible value of the right\nhand side is non\u2011negative by the second inequality, again using\nLemma&nbsp;1.  \nAt the end we have total balance 0 by the third equality.\nThus all prefixes are non\u2011negative and the final balance is zero \u2013\nexactly the definition of a balanced parenthesis string. \u220e\n\n\n\n##### Lemma 3  \nThe algorithm outputs \u201cYes\u201d exactly when one of the two concatenations\n`A+B` or `B+A` satisfies the conditions of Lemma&nbsp;2.\n\n**Proof.**  \nThe algorithm checks simultaneously the three inequalities for\n`A+B` and then for `B+A`.  \nIf any of those checks succeed it returns \u201cYes\u201d; otherwise it returns\n\u201cNo\u201d. \u220e\n\n\n\n##### Theorem  \nThe function `match_parens` returns \u201cYes\u201d iff it is possible to\nconcatenate the two input strings in some order to obtain a balanced\nparenthesis string.\n\n**Proof.**  \n\n*If part:*  \nAssume the function returns \u201cYes\u201d.  \nBy Lemma&nbsp;3 one of the two tested concatenations satisfies\nLemma&nbsp;2\u2019s conditions, hence by Lemma&nbsp;2 that concatenation is balanced.\nThus a good string can be formed.\n\n*Only\u2011if part:*  \nAssume a balanced string can be formed by some ordering of the two\nstrings.  \nThe only two permutations are `A+B` or `B+A`.  \nBy Lemma&nbsp;2, the chosen permutation satisfies the three inequalities\nfor that order, so the algorithm will find it successful and return\n\u201cYes\u201d. \u220e\n\n\n\n--------------------------------------------------------------------\n\n#### 4.  Reference Implementation  (C++17)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic pair<int,int> analyse(const string& s)\n{\n    int bal = 0, min_pref = 0;\n    for(char c : s){\n        if(c=='(') ++bal; else --bal;\n        min_pref = min(min_pref, bal);\n    }\n    return {bal, min_pref};          // {balance, min_prefix}\n}\n\nstring match_parens(const vector<string> &lst)\n{\n    auto [bal0, min0] = analyse(lst[0]);\n    auto [bal1, min1] = analyse(lst[1]);\n\n    // A+B ?\n    if (min0 >= 0 && bal0 + min1 >= 0 && bal0 + bal1 == 0)\n        return \"Yes\";\n\n    // B+A ?\n    if (min1 >= 0 && bal1 + min0 >= 0 && bal0 + bal1 == 0)\n        return \"Yes\";\n\n    return \"No\";\n}\n\n/* ---------- Example usage ----------\nint main(){\n    cout << match_parens({\"()(\", \")\"}) << endl;   // Yes\n    cout << match_parens({\")\",\")\"}) << endl;       // No\n}\n*/\n```\n\nThe program follows exactly the algorithm proven correct above\nand is fully compliant with the C++17 standard.", "Here is a full implementation that follows the logic described above.  \nThe function first builds a helper that, given a string, remembers two pieces of information:\n\n* `balance` \u2013 how many more opening parentheses are left after reading the whole string.  \n  A positive value means we have that many unmatched \u201c(\u201c left at the end, a negative value means we ended up with \u201c)\u201ds that need to be compensated somewhere else.\n\n* `min_pref` \u2013 the minimal value of the running balance while scanning the string from left to right.  \n  This is the deepest \u201cnegative stack depth\u201d that would occur if this string was written from the very beginning of the final result.\n\nWith those two values we can test any concatenation `first + second` in O(|first|+|second|) by just walking once:\nif at any point the balance dips below zero \u2013 i.e. we see more closing brackets than opening ones \u2013 the concatenation is impossible.\n\nThe answer is `Yes` if either `a+b` or `b+a` works.\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct ParenInfo\n{\n    int balance;   // net '(' minus ')' after the whole string\n    int min_pref;  // minimal prefix balance while scanning\n};\n\nParenInfo analyse(const string& s)\n{\n    ParenInfo res{0, 0};\n    int bal = 0;\n    for(char c: s)\n    {\n        bal += (c == '(' ? 1 : -1);\n        res.min_pref = min(res.min_pref, bal);\n    }\n    res.balance = bal;\n    return res;\n}\n\nbool can_concat(const string& a, const string& b)\n{\n    int bal = 0;\n    for(char c: a)\n    {\n        bal += (c == '(' ? 1 : -1);\n        if(bal < 0) return false;\n    }\n    for(char c: b)\n    {\n        bal += (c == '(' ? 1 : -1);\n        if(bal < 0) return false;\n    }\n    return bal == 0;\n}\n\nstring match_parens(vector<string> lst)\n{\n    assert(lst.size() == 2);\n    const string& a = lst[0];\n    const string& b = lst[1];\n\n    if(can_concat(a,b) || can_concat(b,a))\n        return \"Yes\";\n    else\n        return \"No\";\n}\n\n/* To make the file compile standalone (optional main) */\n#ifdef UNIT_TEST\nint main()\n{\n    vector<string> v1 = {\"()(\", \")\"};\n    cout << match_parens(v1) << endl; // Yes\n\n    vector<string> v2 = {\")\", \")\"};\n    cout << match_parens(v2) << endl; // No\n\n    return 0;\n}\n#endif\n```\n\n**Explanation of the key steps**\n\n1. *Balancing check*: During concatenation we keep a running `bal`.  \n   If `bal` ever becomes negative, more closing brackets have appeared than opening ones \u2013 impossible to balance \u2192 return `false`.\n\n2. *Final balance*: After processing both strings, if the running `bal` is zero we ended up with equal numbers of both parentheses, i.e. a correct sequence.\n\nBecause the input guarantees exactly two strings, we only need to test the two possible orders.  \nThe run\u2011time complexity is linear in the total length of the two strings, and the memory usage is O(1).", "```cpp\n#include <string>\n#include <vector>\n#include <algorithm>\n\n/// @brief Check if two parenthesis strings can be concatenated in some order\n///        to produce a balanced string.\n/// @param lst a vector that contains exactly two strings. Each string contains\n///            only '(' and ')'.\n/// @return \"Yes\" if there exists an order of concatenation that yields a\n///         balanced string, otherwise \"No\".\nstd::string match_parens(const std::vector<std::string> lst)\n{\n    if (lst.size() != 2)          // safety: the problem guarantees 2 strings\n        return \"No\";\n\n    // For every string we need two pieces of information:\n    //   1) The total balance  (open \u2013 close) at the end of the string.\n    //   2) The smallest balance encountered while scanning from left to right\n    //      (i.e. the minimum prefix sum).  The string by itself is \"good\"\n    //      only if this minimum is non\u2011negative.\n    struct Info {\n        int total;   // final balance\n        int min_pref;  // minimal prefix sum\n    };\n\n    auto analyze = [](const std::string& s) -> Info {\n        int bal = 0, mn = 0;\n        for (char c : s) {\n            bal += (c == '(') ? 1 : -1;\n            mn = std::min(mn, bal);\n        }\n        return {bal, mn};\n    };\n\n    Info a = analyze(lst[0]);\n    Info b = analyze(lst[1]);\n\n    // To form a balanced final string we need the total sum to be zero.\n    if (a.total + b.total != 0)\n        return \"No\";\n\n    // Check the two possible concatenation orders.\n\n    // Order:  a followed by b\n    bool ok_ab = (a.min_pref >= 0)                // a alone never goes negative\n                 && (b.min_pref + a.total >= 0); // b with offset a.total\n\n    // Order:  b followed by a\n    bool ok_ba = (b.min_pref >= 0)\n                 && (a.min_pref + b.total >= 0);\n\n    if (ok_ab || ok_ba)\n        return \"Yes\";\n    return \"No\";\n}\n```\n\n**Explanation**\n\n1. `analyze` scans a string once, keeping the running balance (`bal`) and the smallest balance seen (`mn`).  \n2. For a string to be usable in the concatenation it must never be negative in its own prefix, but remember we only need that later when checking a particular order.  \n3. For a particular order (say `A+B`), the whole string is balanced iff:\n   * the prefix of `A` never goes below `0` (`min_pref >= 0`),\n   * when we start scanning `B`, the running balance is already `total_A`; therefore every prefix of `B` plus this offset must stay non\u2011negative, i.e. `min_pref_B + total_A >= 0`,\n   * and the overall final balance is zero (checked once for both strings together).\n\n4. We check both possible orders (`A+B` and `B+A`) and return `\"Yes\"` if any succeeds. Otherwise `\"No\"`.\n\nThe algorithm runs in linear time in the total length of the two strings and uses only O(1) extra space."]}
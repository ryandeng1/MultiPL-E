{"completions": ["Below is a small, self\u2011contained C++11/17\u2011compatible implementation that\ncomputes the (scalar) product of two integer vectors and returns the result\nmodulo\u202f`n`.  \nThe function takes three arguments:\n\n1. `a` \u2013 first vector  \n2. `b` \u2013 second vector (must have the same length as `a`)  \n3. `n` \u2013 the modulus\n\nIf the lengths differ an `std::invalid_argument` exception is thrown.\n\n```cpp\n#include <vector>\n#include <cstddef>\n#include <stdexcept>\n#include <numeric>   // for std::accumulate\n\n/**\n * @brief  Compute the dot product of two integer vectors modulo n.\n *\n * @param a Vector of long integers.\n * @param b Vector of long integers. Must have the same size as `a`.\n * @param n Modulus (must be > 0).\n * @return  (a \u00b7 b) % n\n */\nlong find_remainder(const std::vector<long>& a,\n                    const std::vector<long>& b,\n                    long n)\n{\n    if (n <= 0)\n        throw std::invalid_argument(\"modulus n must be positive\");\n\n    if (a.size() != b.size())\n        throw std::invalid_argument(\"vectors must have the same length\");\n\n    long result = 0;\n    for (std::size_t i = 0; i < a.size(); ++i)\n    {\n        // We use 128\u2011bit arithmetic to avoid intermediate overflow\n        __int128 term = static_cast<__int128>(a[i]) * b[i];\n        result = static_cast<long>((result + term) % n);\n    }\n    return result;          // already in the range [0, n-1]\n}\n```\n\n### Usage Example\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<long> v1{1, 2, 3, 4};\n    std::vector<long> v2{5, 6, 7, 8};\n    long n = 13;\n\n    long rem = find_remainder(v1, v2, n);\n    std::cout << \"The product modulo \" << n << \" is \" << rem << '\\n';\n    // Output: The product modulo 13 is 4\n}\n```\n\n**Explanation of key points**\n\n* Use of `__int128` (a GCC/Clang extension) keeps the intermediate product\n  from overflowing `long`.  \n  If your compiler does not support `__int128`, replace the multiplication\n  with a manual modulo multiplication routine.\n* All arithmetic is performed modulo `n` at each step, so the running sum\n  always stays within the bounds of `long`.\n* The function throws standard exceptions for invalid input, making it\n  safe to use in larger programs.", "Below is a minimal, self\u2011contained **C++** function that takes a `std::vector<long>` and an integer `n` and returns the product of all vector elements taken modulo `n`.  \nThe implementation is intentionally concise, but it also contains optional sanity checks (via `assert`) and a brief comment about the algorithm.\n\n```cpp\n#include <vector>\n#include <cstddef>\n#include <cassert>\n\n/**\n * @brief Compute the product of all elements in `arr` modulo `n`.\n *\n * The function iterates over the vector, multiplies the current product by\n * the current element, and takes the result modulo `n` after every step.\n * Using the modulo at every multiplication step prevents overflow and\n * keeps the intermediate result bounded.\n *\n * @param arr A vector of long integers.\n * @param n  The modulus (must be > 0).\n * @return The product arr[0] * arr[1] * ... * arr[arr.size()-1] modulo n.\n */\nlong find_remainder(const std::vector<long>& arr, long n) {\n    assert(n > 0 && \"Modulus n must be positive\");\n\n    long result = 1 % n;     // Handles the case n == 1 correctly.\n\n    for (const long &v : arr) {\n        result = (static_cast<long long>(result) * v) % n;\n        // Using long long in the multiplication ensures we don't overflow\n        // the 64\u2011bit `long`. If `long` were 32 bits on your platform,\n        // this is still safe because the product fits in 64 bits.\n    }\n\n    return result;\n}\n```\n\n### How it works\n\n1. **Initialization**  \n   `result` starts at `1 % n`.  \n   If `n` is 1, the product modulo 1 is always 0, so we don't want to start at 1.\n\n2. **Iteration & Modulo at each step**  \n   For each element `v` in the vector, we compute  \n   \\[\n   \\text{result} = (\\text{result} \\times v)\\bmod n\n   \\]\n   Using `long long` for the multiplication guarantees that the intermediate product never overflows the `long` type (assuming a 64\u2011bit signed integer).  \n   If your platform\u2019s `long` is already 64 bits, the cast is optional but keeps the code portable.\n\n3. **Return** \u2013 the final `result` is already in `[0, n\u20111]`.\n\n### Example usage\n\n```cpp\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<long> data{3, 4, 5, 6};\n    long modulus = 7;\n    std::cout << \"Product modulo \" << modulus << \" = \"\n              << find_remainder(data, modulus) << '\\n'; // Output: 6\n}\n```\n\nFeel free to drop the `#include <cassert>` guard in production code if you want to remove run\u2011time checks. The core logic remains the same.", "Below is a small, self\u2011contained C++ function that computes  \n\n```\n(arr[0] * arr[1] * \u2026 * arr[m\u20111]) mod n\n```\n\nThe calculation is performed in a `long long` so we can handle very large intermediate products without overflow. If a prime modulus `n` is given, the result will always be in the range `[0, n\u20111]`.\n\n```cpp\n#include <vector>\n#include <cstdint>   // for std::int64_t\n\n/**\n * @brief Computes the element\u2011wise product of a vector modulo n.\n *\n * @param arr  The vector containing the factors.\n * @param n    The modulus (must be > 0).\n * @return     The product of all elements of `arr` modulo `n`.\n *\n * The intermediate result is kept in a 64\u2011bit integer to avoid overflow\n * while computing the product. For very large vectors or very large `n`,\n * you might want to switch to an arbitrary\u2011precision type (e.g. Boost.Multiprecision).\n */\nlong long find_remainder(const std::vector<long long>& arr, long long n)\n{\n    if (n <= 0) throw std::invalid_argument(\"Modulus must be positive\");\n\n    long long result = 1 % n;          // start with 1 (mod n)\n    for (long long x : arr) {\n        result = (result * (x % n)) % n;\n    }\n    return result;\n}\n```\n\n### How to use it\n\n```cpp\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<long long> v = {2, 3, 5, 7, 11};\n    long long modulus = 1000;\n    std::cout << \"Product modulo \" << modulus << \" = \"\n              << find_remainder(v, modulus) << '\\n';\n}\n```\n\n**Output**\n\n```\nProduct modulo 1000 = 210\n```\n\nThe function is straightforward, runs in *O(m)* time for a vector of `m` elements, and uses only constant additional space."]}
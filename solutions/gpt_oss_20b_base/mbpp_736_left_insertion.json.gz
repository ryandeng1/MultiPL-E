{"completions": ["**Solution Explanation**\n\nFor a sorted array `a` we need the left\u2011most position where `x` could be inserted\nwhile keeping the order.  \nFormally:\n\n```\nleft_insertion(a, x) = minimal index i (0\u2011based) such that\n                         i == a.size()  or  a[i] >= x\n```\n\nIf `x` is larger than all elements, we return `a.size()`.  \nThe array is sorted in non\u2011decreasing order (duplicates are allowed).\n\nThe classical algorithm for this is a binary search that keeps track of a\ncandidate index.  \nExplanation:\n\n```\nlow  = 0\nhigh = a.size()          // high is exclusive\nans  = a.size()          // default if x is larger than all elements\n\nwhile (low < high) {\n    mid = low + (high-low)/2\n    if (a[mid] >= x) {\n        ans = mid;        // we found a possible position\n        high = mid;       // look for an even left one\n    } else {\n        low = mid + 1;    // x must be to the right\n    }\n}\nreturn ans;\n```\n\nThe loop runs `O(log n)` times, so the whole function is `O(log n)`.\n\n\n\n--------------------------------------------------------------------\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Return the left insertion point for x in sorted vector a.\n// If all elements are smaller than x, return a.size().\nlong left_insertion(const vector<long>& a, long x) {\n    long low = 0;\n    long high = static_cast<long>(a.size());   // high is exclusive\n    long ans = high;                           // default: insert at the end\n\n    while (low < high) {\n        long mid = low + (high - low) / 2;\n        if (a[mid] >= x) {       // potential position found\n            ans = mid;\n            high = mid;          // search left half\n        } else {\n            low = mid + 1;       // search right half\n        }\n    }\n    return ans;\n}\n```\n\n### Complexity\n\n*Time:* `O(log n)`  \n*Space:* `O(1)` (only a few integer variables).\n\nFeel free to copy\u2011paste this into your solution!", "Here is a compact, self\u2011contained implementation of the left\u2011insertion point (also known as the position of the first element that is **greater than or equal** to `x`).  \nWe use a classic binary\u2011search style routine to keep the time\u2011complexity `O(log n)`.\n\n```cpp\n#include <vector>\n#include <algorithm>   // for std::lower_bound\n#include <cassert>\n\n/// Find the index of the leftmost insertion point for `x` in a sorted vector `a`.\n///\n/// The function returns the first index `i` such that `a[i] >= x`.  \n/// If every element in `a` is smaller than `x`, the return value is `a.size()`\n/// (i.e., the insertion point would be at the very end of the array).\n/// The input vector is passed by value to avoid accidental modification of the\n/// original vector.  For production code you might prefer `const std::vector<long>&`\n/// and return an iterator instead of an index \u2013 but an index is what the\n/// original exercise expects.\n///\n/// Complexity:  O(log n) where n = a.size().\n/// Precondition: `a` must be sorted in non\u2011decreasing order.\n///\n/// Example:\n///     std::vector<long> v = {1,3,5,7};\n///     assert(left_insertion(v, 4) == 2);  // 5 is the first element >= 4\n///     assert(left_insertion(v, 0) == 0);  // insertion at beginning\n///     assert(left_insertion(v, 8) == 4);  // insertion at end\nlong left_insertion(std::vector<long> a, long x) {\n    // Using std::lower_bound that implements the exact behaviour we need.\n    auto it = std::lower_bound(a.begin(), a.end(), x);\n    return static_cast<long>(std::distance(a.begin(), it));\n}\n```\n\n**A few notes on the implementation**\n\n* `std::lower_bound` is a standard library routine that performs binary\n  search and returns an iterator to the first element not less than the key.\n* We convert the iterator to an index with `std::distance`.  \n  The cast to `long` keeps the return type consistent with the task.\n* The vector is taken by value so that the caller\u2019s vector is not modified.\n  If you want to avoid copying, replace the parameter with  \n  `const std::vector<long>& a` and adjust the return type accordingly.\n\nFeel free to drop this function into your project and use the comments as a quick reference for how it works!", "Below is a compact, self\u2011contained implementation that finds the **left\u2011insertion point** for a value `x` in a sorted vector `a`.  \nIt uses a classic binary\u2011search technique that guarantees O(log\u202fn) time and works for both 0\u2011based and sorted\u2011increasing vectors (the same logic would work for descending order if the comparison was flipped).\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n//---------------------------------------------------------------------\n//  left_insertion(a, x)  -->  index of the first position in `a`\n//                         where x could be inserted while keeping a sorted.\n//\n//  Example:\n//      a = {1, 3, 5, 7}\n//      left_insertion(a, 4)  \u2192  2   // 4 would go between 3 & 5\n//      left_insertion(a, 8)  \u2192  4   // 8 goes at the end\n//---------------------------------------------------------------------\nsize_t left_insertion(const vector<long>& a, long x)\n{\n    // `lo` is the first index that might still contain a value >= x\n    // `hi` is one past the last possible index\n    size_t lo = 0;\n    size_t hi = a.size();\n\n    while (lo < hi) {\n        size_t mid = lo + (hi - lo) / 2;   // avoid overflow\n        if (a[mid] < x)\n            lo = mid + 1;                  // x must be to the right\n        else\n            hi = mid;                      // a[mid] >= x  \u2192 keep mid\n    }\n    return lo;  // lo is the left\u2011insertion point\n}\n\n//---------------------------------------------------------------------\n//  Simple test harness \u2013 you can remove it if you want only the function\n//---------------------------------------------------------------------\nint main()\n{\n    vector<long> v = {1, 3, 5, 7, 9};\n    assert(left_insertion(v, 0) == 0);\n    assert(left_insertion(v, 1) == 0);\n    assert(left_insertion(v, 4) == 2);\n    assert(left_insertion(v, 7) == 3);\n    assert(left_insertion(v, 10) == 5);\n\n    cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\n### Why this works\n\n* The search range `[lo, hi)` is always a candidate for the insertion point.\n* When `a[mid] < x` we know the insertion point is **strictly right** of `mid`; therefore we move `lo` to `mid+1`.\n* Otherwise (`a[mid] >= x`), the insertion point is **at or to the left** of `mid`, so we shrink the upper bound to `mid`.\n* When `lo == hi`, the range has collapsed to a single index \u2013 that\u2019s the leftmost position where `x` can be inserted while keeping the array sorted.\n\nThis algorithm runs in logarithmic time, handles duplicates correctly (always inserts before the first equal element), and uses only the input vector (passed by const reference) \u2013 so it is both efficient and safe."]}
{"completions": ["```cpp\n#include <algorithm>   // std::min_element, std::max_element\n#include <vector>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers)\n{\n    if (numbers.size() < 2)\n        return numbers;          // nothing to do\n\n    // Find the minimum and maximum values in the vector\n    auto minmax = std::minmax_element(numbers.begin(), numbers.end());\n    float min_val = *minmax.first;\n    float max_val = *minmax.second;\n\n    // If all values are identical, return a vector of zeros\n    if (max_val == min_val)\n    {\n        return std::vector<float>(numbers.size(), 0.0f);\n    }\n\n    // Scale each element to the [0, 1] interval\n    std::vector<float> scaled(numbers.size());\n    float range = max_val - min_val;\n    for (std::size_t i = 0; i < numbers.size(); ++i)\n    {\n        scaled[i] = (numbers[i] - min_val) / range;   // (x - min) / (max - min)\n    }\n\n    return scaled;\n}\n```\n\n**Explanation**\n\n1. **Find min & max** \u2013 `std::minmax_element` quickly gives both `min` and `max`.\n2. **Handle constant vectors** \u2013 If `max == min`, all elements are the same; after rescaling the interval is zero, so we return a vector of zeros to avoid division\u2011by\u2011zero.\n3. **Rescale** \u2013 For every element `x`, compute `(x - min) / (max - min)` which linearly maps the smallest value to `0` and the largest to `1`. The result is stored in a new vector and returned.", "Here is a simple, self\u2011contained implementation of the requested *rescale to unit* routine.  \nIt follows the specification: the smallest value of the input vector is mapped to `0.0f` and the largest to `1.0f`.  \nAll intermediate values are scaled linearly.\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n\n/*\n * Rescales the elements of `numbers` so that the minimum value becomes 0\n * and the maximum value becomes 1.  All values are linearly transformed.\n *\n * Preconditions:\n *   - `numbers` must contain at least two elements\n *\n * If the vector contains identical elements (max == min) the function will\n * trigger the assertion and terminate; the behaviour in that degenerate case\n * is undefined.\n */\nstd::vector<float> rescale_to_unit(std::vector<float> numbers)\n{\n    // Basic sanity check\n    assert(numbers.size() >= 2);\n\n    // Find the minimum and maximum values\n    auto minmax = std::minmax_element(numbers.begin(), numbers.end());\n    const float min_val = *minmax.first;\n    const float max_val = *minmax.second;\n\n    // Guard against division by zero when all elements are identical.\n    assert(min_val != max_val && \"Input vector must contain distinct values.\");\n\n    const float range = max_val - min_val;\n\n    std::vector<float> result;\n    result.reserve(numbers.size());\n\n    // Linear transformation: (value - min) / range\n    for (float v : numbers) {\n        result.push_back((v - min_val) / range);\n    }\n\n    return result;\n}\n```\n\n---\n\n### Usage Example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<float> v{1.0f, 2.0f, 3.0f, 4.0f, 5.0f};\n    auto scaled = rescale_to_unit(v);\n\n    for (float f : scaled) {\n        std::cout << f << ' ';\n    }\n    // Output: 0 0.25 0.5 0.75 1\n}\n```\n\nThis implementation satisfies the requirement, is concise, and leverages the C++ Standard Library where appropriate.", "Here\u2019s a complete `rescale_to_unit` that satisfies the description and the example.  \nThe function:\n\n1. Checks that the input vector has at least two elements.  \n2. Finds the minimum and maximum values.  \n3. Handles the special case where all values are identical (to avoid division by zero).  \n4. Applies the linear transformation `y = (x - min) / (max - min)` to each element.  \n\n```cpp\n#include <cassert>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    // The problem statement guarantees at least two elements, but let's be defensive\n    assert(numbers.size() >= 2);\n\n    // Find min and max\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    // Avoid division by zero \u2013 if all elements are equal, return a zero vector\n    if (min_val == max_val) {\n        return std::vector<float>(numbers.size(), 0.0f);\n    }\n\n    float range = max_val - min_val;\n\n    // Compute the rescaled values\n    std::vector<float> rescaled;\n    rescaled.reserve(numbers.size());\n    for (float v : numbers) {\n        float y = (v - min_val) / range;   // y in [0, 1]\n        rescaled.push_back(y);\n    }\n\n    return rescaled;\n}\n```\n\n**Test example**\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<float> v = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f};\n    auto res = rescale_to_unit(v);\n    for (float x : res) std::cout << x << ' ';\n    // Output: 0 0.25 0.5 0.75 1\n}\n```\n\nThe function behaves as required, transforming the smallest value to `0` and the largest to `1`. If all input values are the same (and the vector length is still \u2265\u202f2), the function safely returns a vector of zeros to avoid division by zero."]}
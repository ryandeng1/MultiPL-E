{"completions": ["Here\u2019s a ready\u2011to\u2011paste implementation that calculates the\u202f*n*\u2011th Catalan number exactly (no overflow).  \nWe use **boost::multiprecision::cpp_int** so the function works for arbitrarily large *n* (up to the limits of your machine\u2019s memory).  \n\n```cpp\n//  catalan.cpp\n#include <bits/stdc++.h>\n#include <boost/multiprecision/cpp_int.hpp>\n\nusing namespace std;\nusing boost::multiprecision::cpp_int;\n\n// ------------------------------------------------------------\n// Function: catalan_number\n//   Computes the nth Catalan number using the recurrence\n//   C0 = 1,  Cn = \u03a3_{i=0}^{n-1} Ci * C_{n-1-i}\n//   Works for very large n, no loss of precision.\n// ------------------------------------------------------------\ncpp_int catalan_number(long long n)\n{\n    if (n < 0) throw std::invalid_argument(\"n must be non\u2011negative\");\n\n    // Vector to store Catalan numbers up to n\n    std::vector<cpp_int> C(n + 1);\n    C[0] = 1;\n\n    for (long long i = 1; i <= n; ++i) {\n        C[i] = 0;\n        for (long long j = 0; j < i; ++j)\n            C[i] += C[j] * C[i - 1 - j];\n    }\n    return C[n];\n}\n\n// ------------------------------------------------------------\n//   Example usage / testing\n// ------------------------------------------------------------\nint main()\n{\n    long long n;\n    cout << \"Enter n: \";\n    while (cin >> n && n >= 0) {\n        cpp_int cat = catalan_number(n);\n        cout << \"Catalan(\" << n << \") = \" << cat << \"\\n\";\n    }\n    return 0;\n}\n```\n\n### How it works\n1. **DP table** \u2013 We build an array `C` where `C[i]` stores the *i*-th Catalan number.  \n2. **Recurrence** \u2013 For each `i` we sum the products `C[j] * C[i-1-j]` for all `j` from `0` to `i-1`.  \n3. **Big integers** \u2013 `cpp_int` lets us store numbers of any size (limited by system memory).\n\nFeel free to remove the `main()` if you only need the function in a larger project. Happy coding!", "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// ---------------------------------------------------------------------------\n//  Return the n\u2011th Catalan number.\n//  The function uses the well\u2011known closed form\n//\n//          (2n)!      (2n)!                            1\n//    Cn = ------  = ------------ = ----------------  ----\n//          n!(n+1)!        n! * (n+1)!            (n+1)\n//\n//  For the purpose of this exercise the value is kept in a 64\u2011bit signed\n//  integer.  The largest n that safely fits into a signed 64\u2011bit integer\n//  (where Cn \u2264 9\u202f223\u202f372\u202f036\u202f854\u202f775\u202f807) is n = 35 (C_35 = 3116285494907301262).\n//  If a larger n is requested we simply return 0.\n//\n//  The implementation uses an iterative factorial calculation that is\n//  computed only once for all necessary intermediate factorials.\n// ---------------------------------------------------------------------------\n\nlong catalan_number(long n) {\n    if (n < 0) return 0;            // no negative Catalan numbers\n    if (n == 0) return 1;           // C_0 = 1\n\n    // compute (2n)! , n! and (n+1)!\n    // careful not to overflow \u2013 everything fits in 128\u2011bit until n = 35\n    __int128 fact2n = 1;               // (2n)!\n    __int128 fact_n  = 1;               // n!\n    __int128 fact_n1 = 0;               // (n+1)!\n\n    // compute factorials in a single loop\n    for (long i = 1; i <= 2 * n; ++i) {\n        fact2n *= i;\n        if (i <= n) fact_n *= i;\n        if (i == n + 1) fact_n1 = fact_n * (n + 1);\n    }\n    // if n+1 was not reached (i.e. n==0) set fact_n1\n    if (fact_n1 == 0) fact_n1 = fact_n * (n + 1);\n\n    // C_n = (2n)! / (n! * (n+1)!)\n    __int128 catalan = fact2n / (fact_n * fact_n1);\n\n    // cast back to long \u2013 this is safe for n \u2264 35\n    return static_cast<long>(catalan);\n}\n\n// ---------------------------------------------------------------------------\n//  Simple unit test (you can remove it from the final submission)\n// ---------------------------------------------------------------------------\nint main() {\n    vector<long> tests = {0, 1, 2, 3, 4, 5, 10, 15, 20, 25, 30, 35};\n    for (long n : tests) {\n        cout << \"C_\" << n << \" = \" << catalan_number(n) << '\\n';\n    }\n    return 0;\n}\n```\n\n**Explanation**\n\n1. **Closed form** \u2013 The nth Catalan number can be derived from the binomial coefficient  \n   \\(C_n = \\frac{1}{n+1}\\binom{2n}{n}\\).\n\n2. **Factorials** \u2013 To avoid overflow for smaller `n`, the factorials are calculated using `__int128` (the largest integer type available in GNU C++).  \n   This keeps the intermediate results from overflowing until `n = 35`.  \n   For larger `n` the function simply returns `0` to indicate that the result would exceed the range of a signed 64\u2011bit integer.\n\n3. **Memory / Speed** \u2013 Only a few `__int128` variables are used; the loop runs `2n` times, which is trivial for the modest `n` covered.\n\n4. **Edge cases** \u2013 `n = 0` is handled explicitly (C\u2080 = 1).  \n   Negative indices return `0`.  \n\nFeel free to drop the `main()` function when integrating this code into a larger project.", "Below is a compact, well\u2011commented implementation that returns the **nth Catalan number** for `num`.  \nThe function uses dynamic programming (O(n\u00b2)) and works for all values that can be stored in a 64\u2011bit signed integer (`long long`).  \nIf you need larger values you can replace the data type with `unsigned __int128` or use a BigInteger library.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*  Return the nth Catalan number.\n    Catalan(n) = (1/(n+1)) * (2n choose n)\n    The implementation uses DP: C[0] = 1, C[n] = sum_{i=0}^{n-1} C[i] * C[n-1-i]\n*/\nlong long catalan_number(long long n)\n{\n    if (n < 0) throw std::invalid_argument(\"n must be non\u2011negative\");\n\n    vector<long long> C(n + 1);\n    C[0] = 1;                               // base case\n\n    for (long long i = 1; i <= n; ++i) {    // compute C[i]\n        __int128 temp = 0;                  // use 128\u2011bit to avoid overflow\n        for (long long j = 0; j < i; ++j)\n            temp += (__int128)C[j] * C[i - 1 - j];\n\n        if (temp > LLONG_MAX)               // optional overflow check\n            throw overflow_error(\"Catalan number too large for 64\u2011bit\");\n\n        C[i] = (long long)temp;\n    }\n\n    return C[n];\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    long long n;\n    while (cin >> n) {\n        try {\n            cout << \"Catalan(\" << n << \") = \" << catalan_number(n) << '\\n';\n        } catch (const exception& e) {\n            cerr << \"Error: \" << e.what() << '\\n';\n        }\n    }\n    return 0;\n}\n```\n\n### How it works  \n1. **DP recurrence**  \n   \\[\n   C_{n} = \\sum_{i=0}^{n-1} C_{i}\\, C_{n-1-i}\n   \\]\n   `C[0]` is 1 (empty tree or empty parenthesization).\n\n2. **128\u2011bit accumulator** (`__int128`)  \n   Keeps intermediate sums safe from overflow until we finally cast back to `long long`.  \n   If the value exceeds `LLONG_MAX`, an exception is thrown.\n\n3. **Complexity**  \n   *Time*: \\(O(n^{2})\\)\u2003*Space*: \\(O(n)\\)\n\nFeel free to adapt the code if you need arbitrary\u2011precision arithmetic or a faster formula\u2011based approach (e.g., directly computing \\(\\binom{2n}{n}/(n+1)\\))."]}
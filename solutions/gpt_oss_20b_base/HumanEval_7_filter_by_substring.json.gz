{"completions": ["Below is a **complete, self\u2011contained** C++ program that implements the requested\n`filter_by_substring` function.  \nThe function accepts a vector of strings and a substring, then returns a new\nvector that contains only those strings that actually contain the given\nsubstring (anywhere inside them).  The implementation uses only the C++\u202fStandard\nLibrary \u2013 nothing beyond `<iostream>`, `<vector>`, `<string>`, and\n`<algorithm>` \u2013 so it will compile with any modern compiler.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\n// \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n//  filter_by_substring\n//\n//  Parameters\n//      strings   \u2013 the input vector of strings\n//      substring \u2013 the substring we are looking for\n//\n//  Returns\n//      A new vector that contains exactly the strings from `strings` that\n//      contain `substring` somewhere inside them (case\u2011sensitive).\n// \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nstd::vector<std::string>\nfilter_by_substring(const std::vector<std::string> &strings,\n                    const std::string &substring)\n{\n    std::vector<std::string> result;\n\n    // Reserve capacity to avoid repeated reallocations \u2013  the maximum\n    // needed capacity is the size of the input vector.\n    result.reserve(strings.size());\n\n    for (const auto &s : strings)\n    {\n        if (s.find(substring) != std::string::npos)\n        {\n            result.push_back(s);\n        }\n    }\n\n    return result;\n}\n\n// ---------------------------------------------------------------------\n// Helper to print a vector ; useful for the demo below\n// ---------------------------------------------------------------------\nvoid print_vector(const std::vector<std::string> &v)\n{\n    std::cout << '(';\n    for (size_t i = 0; i < v.size(); ++i)\n    {\n        if (i > 0) std::cout << \", \";\n        std::cout << '\"' << v[i] << '\"';\n    }\n    std::cout << ')' << std::endl;\n}\n\n// ---------------------------------------------------------------------\n// Demo / simple tests\n// ---------------------------------------------------------------------\nint main()\n{\n    // Test 1 \u2013 empty input\n    std::vector<std::string> ints1;\n    auto out1 = filter_by_substring(ints1, \"a\");\n    std::cout << \"Test 1: \";\n    print_vector(out1);            // Expected: ()\n\n    // Test 2 \u2013 typical case\n    std::vector<std::string> ints2 = {\"abc\", \"bacd\", \"cde\", \"array\"};\n    auto out2 = filter_by_substring(ints2, \"a\");\n    std::cout << \"Test 2: \";\n    print_vector(out2);            // Expected: (\"abc\", \"bacd\", \"array\")\n\n    // Test 3 \u2013 substring not present\n    auto out3 = filter_by_substring(ints2, \"xyz\");\n    std::cout << \"Test 3: \";\n    print_vector(out3);            // Expected: ()\n\n    return 0;\n}\n```\n\n### How it works\n1. **Iteration** \u2013 We iterate over each string in the input vector.\n2. **Substring check** \u2013 Using `std::string::find`, we see whether the\n   `substring` occurs; if `find` returns anything other than `std::string::npos`,\n   the substring was found.\n3. **Accumulate** \u2013 Every matching string is pushed into the result vector.\n4. **Return** \u2013 The function returns the vector containing the filtered\n   results.\n\nThe provided `main()` function demonstrates the expected behavior with a few\nbasic tests.  You can replace or extend these tests with a proper unit\ntesting framework (e.g., Google Test) if you wish.", "Here is a complete, self\u2011contained implementation of `filter_by_substring` with the required includes, a concise implementation, and some simple test cases that emulate the doctest\u2011style examples you provided.\n\n```cpp\n// filter_by_substring.hpp\n#pragma once\n\n#include <string>\n#include <vector>\n#include <algorithm>\n\n/**\n * @brief Return only those strings that contain the given substring.\n *\n * @param strings The vector of input strings (moved into the function).\n * @param substring The substring to search for.\n * @return std::vector<std::string> The filtered vector.\n */\ninline std::vector<std::string>\nfilter_by_substring(std::vector<std::string> strings, const std::string& substring)\n{\n    // Fast\u2011path for an empty search pattern \u2013 every string qualifies.\n    if (substring.empty())\n        return strings;\n\n    auto it = std::remove_if(\n        std::begin(strings), std::end(strings),\n        [&substring](const std::string& s) { return s.find(substring) == std::string::npos; });\n\n    // Erase the \u201cremoved\u201d elements.\n    strings.erase(it, std::end(strings));\n    return strings;\n}\n```\n\n### Usage\n\n```cpp\n#include \"filter_by_substring.hpp\"\n#include <iostream>\n\nint main()\n{\n    std::vector<std::string> v1 = {};\n    auto res1 = filter_by_substring(v1, \"a\");\n    std::cout << \"Result 1: size=\" << res1.size() << '\\n';\n\n    std::vector<std::string> v2 = {\"abc\", \"bacd\", \"cde\", \"array\"};\n    auto res2 = filter_by_substring(v2, \"a\");\n\n    std::cout << \"Result 2: \";\n    for (const auto& s : res2)\n        std::cout << s << ' ';\n    std::cout << '\\n';\n}\n```\n\n### Output\n\n```\nResult 1: size=0\nResult 2: abc bacd array \n```\n\n### Why this works\n\n* **O(n\u00b7m)** time: each string is scanned once for the substring (`std::string::find`).\n* **O(1)** extra space: we mutate the input vector in place and only keep a few iterators.\n\nFeel free to drop this header into any project that needs this utility.", "Here is a compact implementation that meets the stated requirements:\n\n```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\n// Filter an input vector of strings, returning those that contain the given substring.\nstd::vector<std::string>\nfilter_by_substring(const std::vector<std::string>& strings,\n                    const std::string& substring)\n{\n    std::vector<std::string> result;\n    result.reserve(strings.size());   // avoid repeated reallocations\n\n    for (const auto& s : strings)\n        if (s.find(substring) != std::string::npos)\n            result.push_back(s);\n\n    return result;\n}\n```\n\n### Explanation\n- **Signature**: Takes the input vector *by const reference* to avoid unnecessary copying, and similarly for the `substring`. The result is returned by value.\n- **Algorithm**:\n  - Iterate over each string in the input.\n  - Use `std::string::find()` which returns `std::string::npos` when the substring isn\u2019t found.\n  - If the substring is present, copy the string into `result`.\n- **Efficiency**: Reserving space for the output vector avoids extra memory allocations. The algorithm runs in `O(total number of characters)` time, i.e., linear in the size of the input.\n\n### Usage Examples\n```cpp\nauto empty = filter_by_substring({}, \"a\");   // empty vector\n\nauto filtered = filter_by_substring(\n    {\"abc\", \"bacd\", \"cde\", \"array\"}, \"a\");\n// filtered == {\"abc\", \"bacd\", \"array\"}\n```\n\nFeel free to adapt the function for move semantics or other performance tweaks if your use\u2011case demands it."]}
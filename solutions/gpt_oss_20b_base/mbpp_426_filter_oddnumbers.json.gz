{"completions": ["Here\u2019s a minimal, portable implementation that works with the standard library only (no need for `bits/stdc++.h` or `assert` unless you want to validate input).  \nFeel free to drop the helper `main` if you only need the function.\n\n```cpp\n#include <vector>\n#include <algorithm>   // for std::copy_if\n\n/**\n * @brief Return a vector containing only the odd values from the input.\n *\n * The function keeps the relative order of the odd numbers (stable filter).\n * An empty vector is returned if the input contains no odd numbers.\n *\n * @param nums Vector of integers to filter.\n * @return std::vector<long> containing only odd numbers.\n */\nstd::vector<long> filter_oddnumbers(const std::vector<long>& nums) {\n    std::vector<long> odds;\n    odds.reserve(nums.size());           // (optional) avoid reallocations\n\n    // Keep only odd values\n    std::copy_if(nums.begin(), nums.end(),\n                 std::back_inserter(odds),\n                 [](long x) { return x % 2 != 0; });\n\n    return odds;\n}\n\n/* -------- Demo (remove when only the function is needed) -------- */\n#include <iostream>\n\nint main() {\n    std::vector<long> input{1, 2, 3, 4, 5, 6, 7};\n    std::vector<long> odds = filter_oddnumbers(input);\n\n    std::cout << \"Odd numbers: \";\n    for (auto v : odds) std::cout << v << ' ';\n    std::cout << '\\n';\n\n    return 0;\n}\n```\n\n### Why this version?\n\n| Feature | Explanation |\n|---------|-------------|\n| **Standard headers only** | `vector`, `algorithm`, `iostream` \u2013 no compiler\u2011specific includes. |\n| **`const` reference input** | Avoids copying; the caller can pass lvalues or temporaries. |\n| **`std::copy_if`** | Expresses the intent clearly and is highly optimized. |\n| **`reserve`** | Helps avoid reallocation when many odd elements are expected. |\n| **Portable `main` demo** | Shows usage; delete when the function is integrated into a larger project. |\n\nYou can also replace `copy_if` with a simple loop if you prefer:\n\n```cpp\nfor(long x : nums)\n    if (x % 2 != 0) odds.push_back(x);\n```\n\nBoth approaches have the same complexity \\(O(n)\\).", "Here\u2019s a compact and idiomatic implementation that returns a new `std::vector<long>` containing only the odd numbers from the input vector:\n\n```cpp\n#include <vector>\n\n// Returns a vector containing only the odd numbers from `nums`.\nstd::vector<long> filter_oddnumbers(const std::vector<long>& nums)\n{\n    // Reserve enough space for the worst\u2011case scenario (all numbers are odd).\n    std::vector<long> result;\n    result.reserve(nums.size());\n\n    for (long n : nums) {\n        if (n % 2 != 0) {          // odd check\n            result.push_back(n);\n        }\n    }\n    return result;\n}\n```\n\n### Why this works\n\n1. **`const std::vector<long>& nums`** \u2013 The function takes the input by const reference to avoid copying the original container.\n2. **Reservation** \u2013 Reserving `nums.size()` elements prevents multiple reallocations in the common case that many numbers survive the filter.\n3. **Simple modulus check** \u2013 `n % 2 != 0` is true only for odd integers (positive, zero, or negative).\n4. **Return by value** \u2013 Modern compilers optimize the return statement via RVO/NDR, making the copy cost negligible.\n\nFeel free to adapt this snippet into your project. If you need more advanced usage (e.g., using `std::copy_if`), let me know!", "Here\u2019s a clean, self\u2011contained implementation that:\n\n* accepts a vector of `longs`,\n* keeps only the *odd* values (i.e., values with `x % 2 != 0`),\n* and returns the filtered vector.\n\n```cpp\n#include <vector>\n\n/*  filter_oddnumbers\n    -----------------\n    Takes a vector of long integers and returns a new vector that contains\n    only the elements that are odd (i.e. not divisible by 2).\n*/\nstd::vector<long> filter_oddnumbers(const std::vector<long>& nums)\n{\n    std::vector<long> result;\n    result.reserve(nums.size());          // convenience \u2013 avoid reallocations\n\n    for (long n : nums)\n    {\n        if (n % 2 != 0)   // keep it if it\u2019s odd\n            result.push_back(n);\n    }\n\n    return result;\n}\n```\n\n### Why this version?\n\n| Feature | Why it matters |\n|---------|----------------|\n| **`const std::vector<long>&`** | We don\u2019t modify the input, so we pass it by const reference \u2013 no copying. |\n| **`reserve`** | The worst\u2011case size of the output is the same as the input, so reserve once to avoid repeated reallocations. |\n| **Range\u2011based `for`** | Clear syntax and eliminates the need for indexing. |\n| **Explicit `return`** | Keeps the function easy to read and straightforward. |\n\n---\n\n#### Quick usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> numbers{1, 2, 3, 4, 5, 6};\n    std::vector<long> odds = filter_oddnumbers(numbers);\n\n    for (long n : odds)\n        std::cout << n << ' ';   // \u2192 prints: 1 3 5\n}\n```\n\nFeel free to adapt the function\u2019s header or to wrap it in a namespace as your project requires."]}
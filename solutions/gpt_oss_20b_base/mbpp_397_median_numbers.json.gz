{"completions": ["Below is a minimal, self\u2011contained example that implements a `median_numbers()` function for three 64\u2011bit integers and demonstrates its usage in `main()`.  The code is intentionally short, portable, and follows good C++\u2011style practices.\n\n```cpp\n// median_three.cpp\n#include <cassert>\n#include <iostream>\n\n/* ------------------------------------------------------------------\n * Function: median_numbers\n * ------------------------\n * Computes the median (middle) value of three 64\u2011bit signed integers.\n *\n * Parameters:\n *   a \u2013 first number\n *   b \u2013 second number\n *   c \u2013 third number\n *\n * Returns:\n *   The median value.  For distinct inputs a, b, c it is the one that is\n *   neither the maximum nor the minimum.\n *\n *   If two or more inputs are equal, the function simply returns that\n *   value \u2013 which is mathematically the median as well.\n *\n * Complexity:\n *   O(1) \u2013 a constant amount of comparisons.\n *\n * Example:\n *   median_numbers(10, 20, 15)   // returns 15\n *   median_numbers(7, 7, 3)      // returns 7\n * ------------------------------------------------------------------*/\nlong long median_numbers(long long a, long long b, long long c)\n{\n    // Use the standard library algorithm to keep the code short & clear\n    long long arr[3] = {a, b, c};\n    std::nth_element(arr, arr + 1, arr + 3);   // arr[1] is the median\n    return arr[1];\n}\n\nint main()\n{\n    // Some quick sanity checks\n    assert(median_numbers(1, 2, 3) == 2);\n    assert(median_numbers(3, 2, 1) == 2);\n    assert(median_numbers(5, 5, 2) == 5);\n    assert(median_numbers(10, 10, 10) == 10);\n\n    // Demo on user input\n    long long x, y, z;\n    std::cout << \"Enter three numbers separated by spaces: \";\n    std::cin >> x >> y >> z;\n\n    std::cout << \"Median is: \" << median_numbers(x, y, z) << '\\n';\n    return 0;\n}\n```\n\n### How It Works\n\n1. **`nth_element`**  \n   The call  \n   ```cpp\n   std::nth_element(arr, arr + 1, arr + 3);\n   ```  \n   partially sorts the array so that the element at index\u202f1 (`arr[1]`) is the element that would be in that position if the array were fully sorted.  \n   This element is the median of the three values.\n\n2. **Portability**  \n   No external headers beyond the C++ Standard Library are used, so the code compiles on any modern compiler.\n\n3. **Testing**  \n   `assert()` statements in `main()` document the expected behaviour.  \n   If one of the assertions fails (e.g., on a buggy compiler or with compiler bugs), the program will abort immediately during debug builds.  In release builds, `assert` is typically disabled, so the function remains efficient.\n\n4. **User Demo**  \n   The program prompts the user to type three integers and prints the median.  This can be removed or replaced by a unit\u2011test framework in real projects.\n\nFeel free to copy, adapt, or extend this snippet to suit your specific needs.", "Here\u2019s a simple, clear implementation that returns the median of three numbers.  \nIt\u2019s written in C++11 (or newer) and uses only standard headers.\n\n```cpp\n#include <cassert>\n#include <algorithm>\n\n// Return the median of a, b and c.\n// The result is returned as a floating point value\n// so that the function behaves the same for integer or\n// floating\u2011point inputs.\nstatic inline float median_numbers(long a, long b, long c)\n{\n    // Put the values into an array\n    long arr[3] = {a, b, c};\n\n    // Sort the array \u2013 O(3 log 3) which is constant time\n    std::sort(std::begin(arr), std::end(arr));\n\n    // After sorting, the median is the middle element\n    // Casting to float so callers that expect a float\n    // don\u2019t get an integer result\n    return static_cast<float>(arr[1]);\n}\n\n/* ----------  Example usage  ----------\nint main()\n{\n    assert(median_numbers(3, 1, 2) == 2.0f);\n    assert(median_numbers(10, 20, 30) == 20.0f);\n    assert(median_numbers(-1, -5, -3) == -3.0f);\n\n    std::cout << \"All tests passed\\n\";\n}\n--------------------------------------- */\n```\n\n### Why this version?\n\n| Feature | Why it\u2019s useful |\n|---------|-----------------|\n| **Only the STL\u2019s `sort`** | No manual comparison logic\u2014keeps code concise and correct. |\n| **`constexpr`\u2011like behaviour** | The function is `inline` so the compiler can evaluate it at compile time if all arguments are known constants. |\n| **Returns `float`** | Matches the requirement while still working with `long` inputs. |\n| **Small, self\u2011contained** | Easy to drop into any project without pulling in other dependencies. |\n\nFeel free to drop the function into your codebase and adjust the casts if you prefer `double` or another numeric type.", "Here\u2019s a short, self\u2011contained implementation that works for any three `long` values and returns the median as a `float`:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*  Return the median of three numbers\n *  The median is the middle value when the three numbers are sorted.\n *  We avoid sorting libraries to keep the code minimal and efficient.\n */\nfloat median_numbers(long a, long b, long c)\n{\n    /* The two\u2011by\u2011two comparison trick:\n     *   * If a <= b\n     *      - if b <= c \u2192 median is b\n     *      - else if a <= c \u2192 median is c\n     *      - else \u2192 median is a\n     *   * Else (a > b)\n     *      - if a <= c \u2192 median is a\n     *      - else if b <= c \u2192 median is c\n     *      - else \u2192 median is b\n     */\n    if (a <= b) {\n        if (b <= c) return static_cast<float>(b);      // a <= b <= c\n        if (a <= c) return static_cast<float>(c);      // a <= c < b\n        return static_cast<float>(a);                  // c < a <= b\n    } else { // a > b\n        if (a <= c) return static_cast<float>(a);      // b < a <= c\n        if (b <= c) return static_cast<float>(c);      // b <= c < a\n        return static_cast<float>(b);                  // c < b < a\n    }\n}\n```\n\n### Why this works\n* **No sorting** \u2013 we only perform a constant number of comparisons (`O(1)`), which is the fastest possible for three values.\n* **Accurate type conversion** \u2013 the result is cast to `float` only once at the return statement, preserving the exact integer value before conversion.\n* **Predictable behavior** \u2013 the function works correctly for any `long` values, including negative numbers, zeros, and very large values (within the range of `long`).\n\nYou can test it with:\n\n```cpp\nint main() {\n    cout << median_numbers(5, 2, 9) << endl;   // outputs 5\n    cout << median_numbers(-1, -5, 0) << endl; // outputs -1\n}\n```\n\nFeel free to integrate this into your codebase!"]}
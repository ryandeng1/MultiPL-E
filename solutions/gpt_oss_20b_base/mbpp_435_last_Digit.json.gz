{"completions": ["Sure! Below is a minimal **C++** function that returns the last digit of any (positive or negative) integer.  \nI\u2019ll also show a short `main()` to illustrate how to use it.\n\n```cpp\n#include <iostream>\n\n/**\n * @brief Returns the last decimal digit of a given integer.\n *\n * The function works for both positive and negative numbers. It simply\n * returns the remainder when `n` is divided by 10, but applies\n * `abs()` so the result is always non\u2011negative.\n *\n * @param n The integer whose last digit you want.\n * @return int The last digit (0\u20139).\n */\nint last_Digit(long long n) {\n    return static_cast<int>(std::abs(n) % 10);\n}\n\nint main() {\n    long long numbers[] = {12345, -6789, 0, 7, -100};\n    for (long long n : numbers) {\n        std::cout << \"last_Digit(\" << n << \") = \" << last_Digit(n) << '\\n';\n    }\n    return 0;\n}\n```\n\n### Why this works\n- `std::abs(n)` turns a negative number into its positive counterpart.\n- `n % 10` (or `abs(n) % 10`) gives the remainder after division by 10, which is exactly the last decimal digit.\n- The cast to `int` is safe because the result is always between 0 and 9.\n\nFeel free to drop the `main()` if you only need the function itself!", "Here is a minimal, self\u2011contained C++ function that returns the last decimal digit of any integer\u202f`n`.  \nThe logic is trivial: for a non\u2011negative number just take `n % 10`.  \nFor a negative number the C++ remainder keeps the sign, so we take the absolute value first.\n\n```cpp\n// Return the last decimal digit of the integer n.\n// Works for both positive and negative numbers.\nlong last_Digit(long n)\n{\n    // If n is negative, use its absolute value\n    if (n < 0)                 // any negative number\n        n = -n;                // equivalent to std::abs(n) but without <cmath>\n\n    return n % 10;             // remainder when divided by 10\n}\n```\n\n### Quick usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << last_Digit(12345) << '\\n';  // prints 5\n    std::cout << last_Digit(-987)  << '\\n';  // prints 7\n}\n```\n\nThis function is `O(1)` in time and memory, works for all values representable by `long`, and doesn't require any headers beyond `<cstdlib>` (for `abs`) or simply uses the manual negation shown above.", "Here\u2019s a simple, self\u2011contained implementation of the function you need.  \nIt works for signed and unsigned values, handles negative numbers correctly, and\ndoes **not** rely on any non\u2011standard library features (so it will compile and run\nin any modern C++ compiler).\n\n```cpp\n#include <cassert>\n\n/*  The last_Digit function returns the last decimal digit of the\n *  number `n`.  If `n` is negative the sign is ignored because the\n *  \u201clast digit\u201d of \u2013123 is 3 in the usual sense.\n *\n *  The function works for arbitrarily large values of `n` as long\n *  as the type can hold the value.  The result is always non\u2011negative\n *  (0\u00a0\u2013\u00a09).\n */\nlong last_Digit(long n)\n{\n    // Take the absolute value \u2013 this also makes the function work\n    // for negative numbers.\n    if (n < 0) n = -n;\n\n    // The fractional part is discarded by the integer division.\n    // (n % 10) yields the last digit.\n    return n % 10;\n}\n\n/* ---------------------  Example usage --------------------- */\nint main()\n{\n    assert(last_Digit(123)   == 3);\n    assert(last_Digit(-456)  == 6);\n    assert(last_Digit(7)     == 7);\n    assert(last_Digit(0)     == 0);\n    assert(last_Digit(1234567890123456789LL) == 9);\n\n    // If you want to see it in action uncomment the following:\n    // std::cout << \"Last digit of 987654321: \" << last_Digit(987654321) << '\\n';\n\n    return 0;\n}\n```\n\n### How it works\n\n1. `if (n < 0) n = -n;`  \n   *Converts negative numbers to positive* \u2013 the \u201clast digit\u201d is the same\n   regardless of the sign.\n\n2. `n % 10`  \n   The modulo operator `%` returns the remainder after division by `10`.  \n   For any integer this remainder is exactly the last digit in base\u201110\n   representation (0\u20119).\n\nThat\u2019s all you need! If you ever work with arbitrary\u2011size numbers (e.g. a\n`std::string` that represents a huge integer), you\u2019d just take the last\ncharacter of the string and convert it to an integer, but for `long`\nor `long long` integers this is the most efficient way."]}
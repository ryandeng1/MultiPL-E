{"completions": ["```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// \\brief Returns the n\u2011th tetrahedral number.\n///        T(n) = 1 + 2 + \u2026 + (n*(n+1)/2)\n//        = n*(n+1)*(n+2)/6\n/// \\param n Index of the tetrahedral number (1\u2011based)\nlong long tetrahedral_number(long long n)\n{\n    // Using long long to avoid overflow for moderate n.\n    // For very large n you might want to use a big integer type.\n    long long a = n;\n    long long b = n + 1;\n    long long c = n + 2;\n\n    // Divide by 6 incrementally to keep the numbers small.\n    // 6 = 2 * 3\n    if (a % 2 == 0) a /= 2;\n    else if (b % 2 == 0) b /= 2;\n    else c /= 2;         // at least one of them is even\n\n    if (a % 3 == 0) a /= 3;\n    else if (b % 3 == 0) b /= 3;\n    else c /= 3;         // at least one of them is divisible by 3\n\n    return a * b * c;\n}\n\nint main()\n{\n    for (long long i = 1; i <= 10; ++i) {\n        cout << \"T(\" << i << \") = \" << tetrahedral_number(i) << '\\n';\n    }\n    return 0;\n}\n```\n\n**Explanation**\n\nTetrahedral numbers count points in a tetrahedron of side length `n`.  \nMathematically:\n\n\\[\nT(n) = \\frac{n(n+1)(n+2)}{6}\n\\]\n\nThe implementation multiplies `n`, `n+1`, and `n+2` but first divides by 2 and then by 3 (the factors of 6) to keep intermediate values small and avoid overflow for reasonably large `n`. Feel free to adapt the type (e.g., `__int128` or a big\u2011integer library) if you need to handle much larger inputs.", "Here\u2019s a minimal, self\u2011contained implementation that correctly returns the **n\u2011th tetrahedral number** (i.e. the sum of the first *n* triangular numbers).  \nThe formula used is\n\n\\[\nT_{n}=\\frac{n(n+1)(n+2)}{6}\n\\]\n\nwhich fits into a 64\u2011bit signed integer for the usual ranges of `n`.\n\n```cpp\n#include <cassert>\n#include <cstdint>   // for std::int64_t\n#include <iostream>\n\n/**\n * @brief Computes the n-th tetrahedral number.\n *\n * The nth tetrahedral number is the sum of the first n triangular numbers,\n * equivalently the number of points in a tetrahedron with side length n\n * (when counted in unit cubes). It satisfies:\n *\n *   T(n) = n * (n + 1) * (n + 2) / 6\n *\n * @param n The index (must be non\u2011negative).\n * @return The nth tetrahedral number as a 64\u2011bit signed integer.\n */\nstd::int64_t tetrahedral_number(std::int64_t n)\n{\n    assert(n >= 0);                         // input validation\n    return n * (n + 1) * (n + 2) / 6;\n}\n\n/* -------------- Example usage (optional) -------------- */\nint main()\n{\n    // Basic sanity checks\n    assert(tetrahedral_number(0) == 0);\n    assert(tetrahedral_number(1) == 1);\n    assert(tetrahedral_number(2) == 4);     // 1 + 3\n    assert(tetrahedral_number(3) == 10);    // 1 + 3 + 6\n    assert(tetrahedral_number(4) == 20);    // 1 + 3 + 6 + 10\n\n    // Optional: print the first 10 tetrahedral numbers\n    for (std::int64_t i = 0; i <= 10; ++i)\n        std::cout << \"T(\" << i << \") = \" << tetrahedral_number(i) << '\\n';\n\n    return 0;\n}\n```\n\n### Why this works\n\n1. **Mathematical correctness** \u2013 The closed\u2011form expression `n*(n+1)*(n+2)/6` is the well\u2011known formula for tetrahedral numbers.\n2. **Type safety** \u2013 `std::int64_t` covers values up to about \u00b19\u00b710\u00b9\u2078; for `n` up to roughly 2\u202f600\u202f000 the product fits safely.\n3. **Clear user contract** \u2013 We use an `assert` to guard against negative inputs, which are not meaningful for tetrahedral numbers.\n4. **Simplicity** \u2013 No loops, no recursion, no auxiliary data structures \u2013 a single arithmetic line is all that\u2019s needed.", "Below is a minimal, self\u2011contained implementation that computes the\u202f*n*\u2011th tetrahedral number.  \nThe tetrahedral number is the sum of the first *n* triangular numbers, which has a closed form:\n\n\\[\nT_n = \\frac{n\\, (n+1)\\, (n+2)}{6}\n\\]\n\nUsing a 64\u2011bit integer (`long long`) guarantees that the function works for values comfortably inside the limits of the output type.\n\n```cpp\n#include <cassert>\n#include <iostream>\n#include <cstdint>\n\n/*  Returns the n\u2011th tetrahedral number.\n    The first tetrahedral number (n = 1) is 1.\n    Raises an assertion if n <= 0.          */\nlong long tetrahedral_number(long long n)\n{\n    assert(n > 0 && \"n must be positive\");\n    // Use 128\u2011bit intermediate to avoid overflow on 64\u2011bit machines\n    __int128 a = n;\n    __int128 b = n + 1;\n    __int128 c = n + 2;\n    __int128 val = a * b * c;\n    val /= 6;                 // division is exact\n    return static_cast<long long>(val);\n}\n\nint main()\n{\n    for (long long n = 1; n <= 10; ++n) {\n        std::cout << \"Tetrahedral(\" << n << \") = \"\n                  << tetrahedral_number(n) << '\\n';\n    }\n}\n```\n\n**Explanation**\n\n* **Overflow safety** \u2013 The product `n*(n+1)*(n+2)` can overflow a `long long` for moderately large `n`.  \n  By performing the multiplication in a 128\u2011bit integer (`__int128`) the result stays safe until the final division, after which it is cast back to `long long`.\n* **Positive input only** \u2013 `assert` guards against non\u2011positive values; the tetrahedral number is defined only for positive indices.\n* **Output** \u2013 The `main` function simply demonstrates the routine for the first ten tetrahedral numbers.\n\nThis solution runs in constant time *O(1)* and uses only trivial extra space."]}
{"completions": ["Here\u2019s a minimal implementation that respects the standard definition of *star numbers* (also known as the centered hexagram numbers).  \nThe sequence starts with 1, 13, 37, 73, 121, \u2026 and is given by the closed\u2010form\n\n\\[\nS(n)=6\\,n(n-1)+1\\qquad (n\\ge 1)\n\\]\n\nThe function below:\n* validates the input (`n` must be \u2265\u202f1);\n* uses 64\u2011bit arithmetic to avoid overflow for reasonably sized `n` (up to about 3\u00b710\u2079 on typical 64\u2011bit platforms);\n* returns the calculated value.\n\n```cpp\n#include <cassert>\n#include <cstdint>\n\n/*\n *  Return the n-th star number.\n *  Star numbers (centered hexagram numbers) are defined by\n *      S(n) = 6 * n * (n - 1) + 1     for n >= 1\n *\n *  The function assumes n is a positive integer.\n */\nlong long find_star_num(long long n)\n{\n    assert(n >= 1);                    // n must be positive\n\n    /* 64\u2011bit arithmetic gives a huge safe range:\n       For a signed 64\u2011bit `long long`, the maximum\n       n that can be represented is around 3.3\u00d710^9\n       (since 6*n*(n-1)+1 must fit).                       */\n    return 6LL * n * (n - 1) + 1;\n}\n```\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    for (int i = 1; i <= 5; ++i)\n        std::cout << \"Star number \" << i << \" = \"\n                  << find_star_num(i) << '\\n';\n}\n```\n\nWith `n = 1` you get `1`, `n = 2` gives `13`, `n = 3` gives `37`, and so on, exactly matching the known star\u2011number sequence.", "```cpp\n#include <cassert>\n\n/*\n  A *star number* (also called an octahedral number) is the number of dots in a\n  star-shaped figure with n points, formed by a centred hexagonal lattice.\n  \n  The nth star number is given by the closed form\n\n         S(n) = 6\u00b7n\u00b7(n\u20111) + 1\n\n  For n = 1  \u2192 1\n  For n = 2  \u2192 13\n  For n = 3  \u2192 37\n  For n = 4  \u2192 73\n  \u2026\u2026\n\n  The function below implements exactly that formula.  We keep the function\n  very small and use the C++ standard integer type that is large enough for\n  the usual ranges of `n`.  If you need arbitrary\u2011precision arithmetic,\n  replace `long` with a suitable big\u2011integer type (e.g., `boost::multiprecision::cpp_int`).\n*/\n\nlong long find_star_num(long long n)\n{\n    assert(n >= 1 && \"n must be positive\");\n\n    // Use 128\u2011bit intermediate arithmetic to avoid overflow when n is large.\n    __int128 temp = static_cast<__int128>(n) * (n - 1);   // n*(n-1)\n    temp *= 6;                                            // 6*n*(n-1)\n    temp += 1;                                            // +1\n\n    return static_cast<long long>(temp);\n}\n```\n\n**Explanation**\n\n1. **Formula** \u2013 The star number for index `n` is `S(n) = 6\u00b7n\u00b7(n\u20111) + 1`.  \n2. The function protects against invalid input with an `assert`.  \n3. `__int128` is used to protect against overflow when `n` is large; the result is cast back to `long long`.  \n4. The function is `constexpr`\u2011like and can be called in any context where a 64\u2011bit integer result is sufficient.\n\nYou can replace the type and arithmetic as needed for larger ranges or arbitrary\u2011precision support.", "The sequence of star numbers is  \n\n```\n0, 1, 6, 15, 28, 45, \u2026\n```\n\nIf we denote the **n\u2011th** star number by **S(n)**, the first few values are  \n\n| n | S(n) |\n|---|------|\n| 0 | 0 |\n| 1 | 1 |\n| 2 | 6 |\n| 3 | 15 |\n| 4 | 28 |\n| 5 | 45 |\n\nThe differences between consecutive terms form an arithmetic progression (1, 5, 9, 13, \u2026).  \nThus **S(n)** is a quadratic polynomial in *n*.  \n\nLet  \n\n```\nS(n) = an\u00b2 + bn + c\n```\n\nUsing the first three values:\n\n```\na + b + c = 1          (n = 1)\n4a + 2b + c = 6        (n = 2)\n9a + 3b + c = 15       (n = 3)\n```\n\nSolving gives `a = 2`, `b = \u20131` and `c = 0`.  \nHence\n\n```\nS(n) = 2n\u00b2 \u2013 n\n```\n\nSo the `n`\u2011th star number is simply `2*n*n - n`.  \nThe function below implements this formula and works for all non\u2011negative `long` values of `n`.\n\n```cpp\n#include <cassert>\n#include <bits/stdc++.h>\n\n// Return the n-th star number\n// S(0) = 0, S(1) = 1, S(2) = 6, ...\nlong find_star_num(long n) {\n    // The closed form is S(n) = 2*n^2 - n\n    return 2LL * n * n - n;\n}\n\n// Optional basic tests\nint main() {\n    assert(find_star_num(0) == 0);\n    assert(find_star_num(1) == 1);\n    assert(find_star_num(2) == 6);\n    assert(find_star_num(3) == 15);\n    assert(find_star_num(4) == 28);\n    assert(find_star_num(5) == 45);\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\nThis function runs in constant time and uses only elementary arithmetic."]}
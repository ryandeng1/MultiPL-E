{"completions": ["Here is a complete implementation of the `file_name_check` function according to the specification.  \nThe code is self\u2011contained \u2013 you can include it in any C++ project that uses the C++17 (or newer) standard library.\n\n```cpp\n#include <cctype>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\n/*\n * Checks if a file name is valid.\n *\n * Rules:\n *   1. No more than three digits (0\u20119) in the entire string.\n *   2. Exactly one dot '.'.\n *   3. The part before the dot must be non\u2011empty and start with a Latin letter.\n *   4. The part after the dot must be one of {\"txt\", \"exe\", \"dll\"}.\n *\n * Returns \"Yes\" if all rules are satisfied, otherwise \"No\".\n */\nstd::string file_name_check(std::string file_name) {\n    // ---------- rule 2 : exactly one dot ----------\n    size_t dot_pos = file_name.find('.');\n    if (dot_pos == std::string::npos || dot_pos != file_name.rfind('.'))\n        return \"No\";\n\n    // ---------- rule 1 : at most three digits ----------\n    int digit_count = 0;\n    for (char c : file_name) {\n        if (std::isdigit(static_cast<unsigned char>(c)))\n            ++digit_count;\n        if (digit_count > 3)          // early exit\n            return \"No\";\n    }\n\n    // ---------- rule 3 : part before the dot ----------\n    std::string before_dot = file_name.substr(0, dot_pos);\n    if (before_dot.empty() || !std::isalpha(static_cast<unsigned char>(before_dot[0])))\n        return \"No\";\n\n    // ---------- rule 4 : part after the dot ----------\n    std::string after_dot = file_name.substr(dot_pos + 1);\n    static const std::unordered_set<std::string> valid_exts{\"txt\", \"exe\", \"dll\"};\n    if (valid_exts.find(after_dot) == valid_exts.end())\n        return \"No\";\n\n    return \"Yes\";\n}\n```\n\n### How it works\n\n1. **Dot check** \u2013 `find` and `rfind` ensure that there is exactly one `.` and capture its position.\n2. **Digit count** \u2013 We iterate once over the string, counting digits and aborting if more than three appear.\n3. **Prefix check** \u2013 The part before the dot must be non\u2011empty and the first character must be an alphabet letter.\n4. **Extension check** \u2013 The part after the dot is compared against a small set of allowed extensions (`txt`, `exe`, `dll`).\n\nThe function runs in a single pass over the input string (O(n) time) and uses constant additional space.  \n\nFeel free to copy/paste this code into your project or testing harness.", "Below is a self\u2011contained implementation of `file_name_check` that satisfies all of the stated requirements.  \nFeel free to drop it into your codebase and use it as needed.\n\n```cpp\n#include <string>\n#include <cctype>   // for isalpha, isdigit\n\n// Returns \"Yes\" if the file name is valid, otherwise \"No\".\nstd::string file_name_check(const std::string& file_name)\n{\n    // 1. Count digits \u2013 must be <= 3\n    int digitCount = 0;\n    for (char ch : file_name) {\n        if (std::isdigit(static_cast<unsigned char>(ch)))\n            ++digitCount;\n    }\n    if (digitCount > 3) return \"No\";\n\n    // 2. Find the dot. There must be exactly one.\n    size_t dotPos = file_name.find('.');\n    if (dotPos == std::string::npos)    return \"No\";          // no dot\n    if (file_name.find('.', dotPos + 1) != std::string::npos) return \"No\"; // more than one\n\n    // 3. Validate the part before the dot\n    if (dotPos == 0) return \"No\";                          // empty prefix\n    if (!std::isalpha(static_cast<unsigned char>(file_name[0])))\n        return \"No\";                                      // must start with a letter\n\n    // 4. Validate the part after the dot\n    std::string suffix = file_name.substr(dotPos + 1);\n    if (suffix != \"txt\" && suffix != \"exe\" && suffix != \"dll\")\n        return \"No\";\n\n    // All checks passed\n    return \"Yes\";\n}\n```\n\n### How it works\n\n| Check | Implementation detail | Why it works |\n|-------|-----------------------|--------------|\n| **\u22643 digits** | Loop over all characters and count `isdigit`. | Simple O(n) scan. |\n| **Exactly one dot** | `find('.')` gives first dot; ensure a second dot is not found. | Avoids counting multiple dots. |\n| **Non\u2011empty prefix starting with a letter** | `dotPos` guarantees at least one character before dot; `isalpha` checks the first character. | Matches the requirement. |\n| **Valid suffix** | Substring after dot must be one of `txt`, `exe`, `dll`. | Direct comparison. |\n\nFeel free to add any extra error handling or edge\u2011case tests that your project requires!", "Below is a complete, self\u2011contained implementation that follows the rules described in the prompt.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/**\n * @brief Checks whether a file name is valid according to the given rules.\n *\n * Rules:\n * 1. At most three digits anywhere in the name.\n * 2. Exactly one dot '.'.\n * 3. Part before the dot must be non\u2011empty and start with an ASCII letter.\n * 4. Extension (part after the dot) must be one of {\"txt\", \"exe\", \"dll\"}.\n *\n * @param file_name The name of the file to validate.\n * @return \"Yes\" if the file name is valid, otherwise \"No\".\n */\nstring file_name_check(const string& file_name)\n{\n    /* --- 1. Count dots and locate the only dot --- */\n    int dot_count = 0;\n    size_t dot_pos = string::npos;\n    for (size_t i = 0; i < file_name.size(); ++i) {\n        if (file_name[i] == '.') {\n            ++dot_count;\n            dot_pos = i;\n        }\n    }\n    if (dot_count != 1) return \"No\";\n\n    /* --- 2. Split into name and extension --- */\n    string name_part = file_name.substr(0, dot_pos);\n    string ext_part   = file_name.substr(dot_pos + 1);\n\n    /* --- 3. Name part must be non\u2011empty and start with a letter --- */\n    if (name_part.empty()) return \"No\";\n    char first = name_part[0];\n    if (!isalpha(static_cast<unsigned char>(first))) return \"No\";\n\n    /* --- 4. Extension must be one of the accepted ones --- */\n    const unordered_set<string> allowed_exts = {\"txt\", \"exe\", \"dll\"};\n    if (allowed_exts.find(ext_part) == allowed_exts.end())\n        return \"No\";\n\n    /* --- 5. Count all digits in the whole string (including extension) --- */\n    int digit_cnt = 0;\n    for (char c : file_name) {\n        if (isdigit(static_cast<unsigned char>(c))) ++digit_cnt;\n    }\n    if (digit_cnt > 3) return \"No\";\n\n    /* All checks passed */\n    return \"Yes\";\n}\n\n/* ---------------------  Example usage --------------------- */\n#ifdef LOCAL_TEST\nint main()\n{\n    vector<string> tests = {\"example.txt\", \"1example.dll\", \"abc.exe\", \"ab.c\", \"a1b2c3.txt\", \"file.unknown\"};\n    for (auto &t : tests) {\n        cout << t << \" -> \" << file_name_check(t) << '\\n';\n    }\n    return 0;\n}\n#endif\n```\n\n### How it works\n\n1. **Dot handling** \u2013 We count the dots and keep the position of the only one.  \n   If the count is not exactly one we immediately return `\"No\"`.\n\n2. **Splitting** \u2013 Using `substr` we separate the part before and after the dot.\n\n3. **Name validation** \u2013 The part before the dot must be non\u2011empty and its first character must be a letter (`isalpha`).\n\n4. **Extension validation** \u2013 The part after the dot must be exactly one of the allowed extensions.\n\n5. **Digit count** \u2013 We scan the whole file name and count digits (`isdigit`).  \n   More than three digits \u2192 `\"No\"`.\n\nIf all checks pass, we return `\"Yes\"`.\n\nCompile with `-std=c++17` or newer. The `#ifdef LOCAL_TEST` block gives a quick manual test harness."]}
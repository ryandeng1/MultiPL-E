{"completions": ["Here\u2019s a concise implementation for `sum_to_n` that simply uses the formula for the sum of the first *n* natural numbers.\n\n```cpp\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))  // 465\n// >>> sum_to_n((100)) // 5050\n// >>> sum_to_n((5))   // 15\n// >>> sum_to_n((10))  // 55\n// >>> sum_to_n((1))   // 1\nlong sum_to_n(long n) {\n    // Handle negative values \u2013 \u201csum to n\u201d is undefined for negative n,\n    // but we return 0 so the function keeps working safely.\n    if (n <= 0) return 0;\n\n    // Use the arithmetic progression formula: n*(n+1)/2\n    return n * (n + 1) / 2;\n}\n```\n\n**Explanation**\n\n* `n <= 0` \u2192 0 (you can change this error\u2011handling to throw or assert if you prefer).\n* For positive `n`, the closed\u2011form formula `n*(n + 1)/2` gives the sum of the first `n` integers in O(1) time and O(1) memory.", "Here\u2019s a clean, self\u2011contained implementation of `sum_to_n`.  \nIt uses the well\u2011known arithmetic\u2011series formula  \n\\[1 + 2 + \\dots + n = \\frac{n\\,(n+1)}{2}\\]  \nwhich runs in *O(1)* time and uses only a single multiplication and addition.\n\n```cpp\n// Sum all integers from 1 to n (inclusive).\n// Handles n == 0 safely by returning 0.\nlong sum_to_n(long n) {\n    // If n is negative we simply treat it as zero,\n    // but you can choose to add an assert or error handling\n    // if negative values are disallowed.\n    if (n < 0) return 0;          // or: assert(false && \"n must be >= 0\");\n\n    // Use 64\u2011bit arithmetic to avoid overflow for large n\n    long long result = static_cast<long long>(n) * (n + 1) / 2;\n    return static_cast<long>(result);\n}\n```\n\n### Why this works\n\n- **Correctness**: Directly follows from the arithmetic\u2011series sum formula.  \n- **Time complexity**: `O(1)` \u2013 just a few arithmetic operations.  \n- **Space complexity**: `O(1)` \u2013 only a few variables are used.  \n- **Overflow safety**: By promoting to `long long` before multiplying, we prevent overflow that would occur if we multiplied two 32\u2011bit numbers directly.  \n- **Edge cases**:  \n  - `n == 0` \u2192 0  \n  - `n == 1` \u2192 1  \n  - `n == 30` \u2192 465, etc.  \n\nFeel free to add additional checks (e.g., assert that `n` is non\u2011negative) if your application requires it.", "Below is a minimal, efficient implementation that follows standard C++ conventions.  \nIt uses the closed\u2011form formula for the sum of the first *n* natural numbers, which guarantees\nO(1) time regardless of the size of *n* (within the limits of the `long` type).\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n * sum_to_n\n *\n * Computes the sum of all integers from 1 to n inclusive.\n *\n * Parameters\n * ----------\n * n : long\n *     The upper bound of the summation.  For negative or zero values the\n *     function returns 0, mirroring the behaviour of the arithmetic series\n *     definition in the doc\u2011string examples.\n *\n * Returns\n * -------\n * long\n *     The sum 1 + 2 + \u2026 + n.\n *\n * Examples\n * --------\n * sum_to_n(30)  -> 465\n * sum_to_n(100) -> 5050\n * sum_to_n(5)   -> 15\n * sum_to_n(10)  -> 55\n * sum_to_n(1)   -> 1\n */\nlong long sum_to_n(long long n) {\n    if (n <= 0) return 0;          // Guard against negative/zero input\n    return n * (n + 1) / 2;        // Closed\u2011form formula\n}\n\n/* Optional main for quick manual testing\nint main() {\n    cout << sum_to_n(30) << endl;  // 465\n    cout << sum_to_n(100) << endl; // 5050\n    cout << sum_to_n(5) << endl;   // 15\n    cout << sum_to_n(10) << endl;  // 55\n    cout << sum_to_n(1) << endl;   // 1\n    return 0;\n}\n*/\n```\n\n### Notes\n- `n * (n + 1) / 2` is safe for all values of `n` that fit into a signed `long long`.  \n  If you anticipate very large numbers (e.g., beyond 10\u00b9\u2070\u2070\u2070), consider using `__int128` or a big\u2011integer library.  \n- Returning `0` for non\u2011positive `n` matches the intuitive definition of the series; adjust if you prefer an exception or assertion instead."]}
{"completions": ["Here\u2019s a straightforward implementation that follows the behaviour described in the examples:\n\n```cpp\n#include <vector>\n#include <cassert>\n\n/*  Intersperse a delimiter between every two consecutive elements of\n    `numbers`. The first element of the result is always the first element\n    of `numbers` (if it exists). For a vector with n elements we receive a\n    result of size: 2*n-1  (unless n==0 in which case the result is empty).\n*/\nstd::vector<long> intersperse(const std::vector<long>& numbers, long delimiter)\n{\n    // Fast\u2011path for an empty input.\n    if (numbers.empty())\n        return {};\n\n    std::vector<long> result;\n    result.reserve(2 * numbers.size() - 1);   // reserve capacity for speed.\n\n    // Insert elements with delimiter between them.\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        if (i > 0)          // add delimiter before every element except the first.\n            result.push_back(delimiter);\n        result.push_back(numbers[i]);\n    }\n    return result;\n}\n\n// --------------------------------------------------------------------------\n// Simple tests to verify correctness (you can use a proper unit\u2011test framework)\n// --------------------------------------------------------------------------\n#include <iostream>\nint main() {\n    // Test 1: empty input\n    assert(intersperse({}, 4).empty());\n\n    // Test 2: single element\n    auto r1 = intersperse({1}, 4);\n    assert(r1.size() == 1 && r1[0] == 1);\n\n    // Test 3: three elements\n    auto r2 = intersperse({1, 2, 3}, 4);\n    std::vector<long> expected = {1, 4, 2, 4, 3};\n    assert(r2 == expected);\n\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Fast\u2011path** \u2013 If the input vector is empty we return an empty vector immediately.\n2. **Reserve** \u2013 Pre\u2011allocating the expected size (`2 * n - 1`) avoids reallocations.\n3. **Loop** \u2013 For each element after the first we first push the `delimiter` and then the element itself.  \n   This yields the correct intersperse order.\n4. **Tests** \u2013 A few assertions confirm that the function behaves as expected.\n\nFeel free to adapt the testing approach or integrate this function into your larger codebase.", "Here\u2019s a compact, ready\u2011to\u2011use implementation of `intersperse`.  \nIt walks over the input vector, copies each element to a new result vector and, except after the last element, inserts the specified delimiter.\n\n```cpp\n#include <vector>\n\n// Insert the value `delimiter` between every two consecutive elements of `numbers`.\n// The returned vector contains the same elements as `numbers` with the delimiter\n// interleaved. If `numbers` has 0 or 1 element, it is returned unchanged.\n//\n// Example:\n//   intersperse({}, 4)            => {}\n//   intersperse({1,2,3}, 4)       => {1,4,2,4,3}\nstd::vector<long> intersperse(const std::vector<long>& numbers, long delimiter) {\n    std::vector<long> result;\n    result.reserve(numbers.size() * 2 - 1);   // maximum possible size\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);           // original element\n        // Insert delimiter except after the last element\n        if (i + 1 < numbers.size())\n            result.push_back(delimiter);\n    }\n    return result;\n}\n```\n\n**Key points**\n\n- We use `const std::vector<long>&` for the input to avoid an unnecessary copy.\n- `reserve` preallocates the maximum required storage, making the push\u2011backs fast.\n- The loop arranges the delimiter only between elements, matching the behavior shown in the examples.", "Here\u2019s a clear, simple implementation that follows the example behaviour:\n\n```cpp\n#include <vector>\n\nstd::vector<long> intersperse(std::vector<long> numbers, long delimiter) {\n    // if the input vector is empty or has only one element, just return it\n    if (numbers.size() <= 1)\n        return numbers;\n\n    // Reserve enough space to avoid reallocations:\n    //  n elements + (n-1) delimiters\n    std::vector<long> result;\n    result.reserve(numbers.size() + numbers.size() - 1);\n\n    // Copy the first element\n    result.push_back(numbers[0]);\n\n    // For each remaining element, push the delimiter first, then the element\n    for (std::size_t i = 1; i < numbers.size(); ++i) {\n        result.push_back(delimiter);\n        result.push_back(numbers[i]);\n    }\n\n    return result;\n}\n```\n\n**Explanation**\n\n1. **Handle the trivial cases** \u2013 If the input vector has zero or one element, there\u2019s nothing to intersperse.\n2. **Reserve capacity** \u2013 `result.reserve(numbers.size() + numbers.size() - 1)` ensures we only allocate once.\n3. **Build the result** \u2013 Start with the first number, then for every other number prefix a delimiter before adding the number itself.\n4. **Return the new vector** \u2013 The original `numbers` vector remains unchanged.\n\nThis matches the behavior shown in the examples:\n```cpp\nintersperse({}, 4);                         // \u2192 {}\nintersperse({1,2,3}, 4);                   // \u2192 {1,4,2,4,3}\n```"]}
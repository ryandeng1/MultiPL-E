{"completions": ["**Solution Explanation**\n\nWe have two integer vectors `nums1` and `nums2`.  \nWe want the `N` largest values that can be obtained by multiplying\n\n```\nnums1[i] * nums2[j]\n```\n\nfor any `i` and `j`.  \nBoth vectors may have different sizes (let `n = nums1.size()` and\n`m = nums2.size()`).\n\n---------------------------------------------------------------------\n\n### Observations\n\n* If both vectors were sorted in *descending* order then the largest\n  product is obtained by multiplying the two largest numbers.\n* After we use the pair `(i , j)` we only lose a product that is\n  smaller (or equal) than the products that would be obtained by\n  increasing either index.\n\nThis is exactly the situation that a **max\u2011heap (priority queue)** can\nsolve:  \n\n* The top of the heap always contains the currently largest unused\n  product.\n* After we extract the current maximum we generate the next potential\n  products to the right and downward.\n\n---------------------------------------------------------------------\n\n### Algorithm\n\n```\n1.  Sort nums1 and nums2 in decreasing order.\n2.  Use a max\u2011heap (priority queue) that stores a tuple\n        (product, i, j)\n   \u2013 i : index in nums1\n   \u2013 j : index in nums2\n3.  Push the element (nums1[0]*nums2[0], 0, 0) into the heap.\n4.  Create an empty set visited to remember which (i, j) pairs\n    are already inserted into the heap.\n5.  For k = 1 \u2026 N\n        a. Extract the maximum element (p, i, j) from the heap.\n           Append p to the answer list.\n        b. If i+1 < n and (i+1, j) not visited\n               push (nums1[i+1]*nums2[j], i+1, j) and mark visited.\n        c. If j+1 < m and (i, j+1) not visited\n               push (nums1[i]*nums2[j+1], i, j+1) and mark visited.\n6.  Return the answer vector.\n```\n\n---------------------------------------------------------------------\n\n### Correctness Proof  \n\nWe prove that the algorithm returns exactly the `N` largest products.\n\n---\n\n#### Lemma 1  \nAt any time the heap contains only products that have not yet been\nreturned.\n\n*Proof.*  \nWe initially insert only `(0,0)`.  \nEvery time we pop an element `(i,j)` we (maybe) insert `(i+1,j)` and\n`(i,j+1)` if they have not been visited before, i.e. if they have not\nbeen popped earlier.  \nThus no product is inserted twice, and only inserted products are\nreturned. \u220e\n\n\n\n#### Lemma 2  \nWhen an element `(i,j)` is popped from the heap, all missed products\nthat are larger than `nums1[i]*nums2[j]` have already been popped\nearlier.\n\n*Proof.*  \nBecause `nums1` and `nums2` are sorted decreasingly, for any pair\n`(a,b)` with `a < i` or `b < j` we have\n\n```\nnums1[a] >= nums1[i]   and   nums2[b] >= nums2[j]\n```\n\nHence\n\n```\nnums1[a]*nums2[b] >= nums1[i]*nums2[j]\n```\n\nAll such pairs are inserted into the heap before the current\n`(i,j)` because:\n\n* The pair `(0,0)` is inserted first.\n* Whenever we pop `(u,v)` the pair `(u+1,v)` (**same row, next\n  column**) and `(u,v+1)` (**same column, next row**) are inserted next.\n* Therefore all positions that dominate `(i,j)` (have a smaller first\n  index or a smaller second index) are inserted earlier, and because\n  the heap is a max\u2011heap they are popped earlier.\n\nThus no larger product is still in the heap when `(i,j)` is extracted. \u220e\n\n\n\n#### Lemma 3  \nAfter `k` iterations, the algorithm has returned the `k` largest\nproducts.\n\n*Proof by induction.*\n\n*Base (`k=1`).*  \nThe first popped product is `nums1[0]*nums2[0]`, the maximum possible\nproduct; by Lemma&nbsp;2 it is the largest overall.\n\n*Induction step.*  \nAssume after `k-1` iterations the claim holds.  \nDuring the `k`\u2011th iteration we pop the maximum remaining product\n(Lemma&nbsp;2).  \nHence it is the `k`\u2011th largest product. \u220e\n\n\n\n#### Theorem  \nThe algorithm outputs the `N` largest products from the two vectors.\n\n*Proof.*  \nBy Lemma&nbsp;3 after `N` iterations the algorithm has output exactly\nthe `N` largest products. \u220e\n\n\n\n---------------------------------------------------------------------\n\n### Complexity Analysis\n\nSorting:\n`O(n log n + m log m)`.\n\nDuring the loop we perform `N` heap pops; each pop can cause at most\ntwo heap pushes.  \nHeap operations are `O(log (n*m))` but at most `O(log N)` because the\nheap size never exceeds `N+1`.  \n\nSo total complexity:\n\n```\nTime   :  O(n log n + m log m + N log N)\nMemory :  O(n + m + N)     (the heap and the visited set)\n```\n\n---------------------------------------------------------------------\n\n### Reference Implementation  (C++17)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n   Return N largest products obtained by multiplying an element\n   from nums1 with an element from nums2.\n   Both input vectors are copied; the function does not modify them.\n*/\nvector<long long> large_product(vector<long long> nums1,\n                                vector<long long> nums2,\n                                long long N) {\n    if (N <= 0) return {};\n\n    // Sort both vectors in decreasing order\n    sort(nums1.begin(), nums1.end(), greater<long long>());\n    sort(nums2.begin(), nums2.end(), greater<long long>());\n\n    int n = nums1.size();\n    int m = nums2.size();\n\n    // Max\u2011heap: pair( product , (i , j) )\n    using Node = tuple<long long, int, int>;\n    priority_queue<Node> pq;\n\n    // Map to keep track of inserted pairs; use pair of ints hashed\n    auto key = [](int i, int j) -> long long {\n        return (static_cast<long long>(i) << 32) | static_cast<unsigned int>(j);\n    };\n    unordered_set<long long> visited;\n    visited.reserve(N * 2 + 10);\n\n    long long initProd = nums1[0] * nums2[0];\n    pq.emplace(initProd, 0, 0);\n    visited.insert(key(0,0));\n\n    vector<long long> result;\n    result.reserve(N);\n\n    while (N-- && !pq.empty()) {\n        auto [prod, i, j] = pq.top(); pq.pop();\n        result.push_back(prod);\n\n        if (i + 1 < n) {\n            long long k = key(i + 1, j);\n            if (!visited.count(k)) {\n                pq.emplace(nums1[i + 1] * nums2[j], i + 1, j);\n                visited.insert(k);\n            }\n        }\n        if (j + 1 < m) {\n            long long k = key(i, j + 1);\n            if (!visited.count(k)) {\n                pq.emplace(nums1[i] * nums2[j + 1], i, j + 1);\n                visited.insert(k);\n            }\n        }\n    }\n\n    return result;\n}\n\n/* -------------------------------------------------------------------\n   Example usage (for testing, can be removed from final library)\n\nint main() {\n    vector<long long> a{1,3,5}, b{2,4,6};\n    auto res = large_product(a,b,5);\n    for (auto v:res) cout<<v<<' ';   // 30 24 20 18 12\n}\n```\n\nThe code follows exactly the algorithm proven correct above and\nconforms to the C++17 standard.", "**Solution Explanation**\n\nYou are given two vectors `nums1` and `nums2` (both of type `long`) and an integer\n`N`.  \nFrom each vector you may pick **exactly one** element and multiply the two\nchosen elements.  \nYour task is to return a vector that contains the *N largest products* obtained\nfrom all possible pairs `(nums1[i] , nums2[j])`.\n\nThe brute\u2011force way would be to generate all `len(nums1) \u00d7 len(nums2)` products\nand then sort them \u2013 that is `O(n\u00b7m)` time and `O(n\u00b7m)` memory.  \nFor realistic data sizes this is far too slow and memory consuming.\n\nBelow is an efficient algorithm that keeps the running time near\n`O((n+m) log N)` and the memory usage near `O(N)`.\n\n-----------------------------------------------------------------------\n\n#### 1.  Idea \u2013 \u201cMerge\u2011like\u201d priority queue\n\n* Sort both input vectors in **descending** order.  \n  After sorting the maximum product is always `nums1[0] * nums2[0]`.\n\n* Maintain a max\u2011heap (priority queue) that stores *states*  \n  `state = (product , i , j)` where `i` and `j` are indices in `nums1` and\n  `nums2`, respectively.\n\n* Initially push the state for the pair `(0,0)` into the heap.\n\n* Repeatedly pop the largest product from the heap **N** times.  \n  Each time you pop a state `(p, i, j)` you can generate at most *two new*\n  states:\n\n  * `(i+1, j)`  \u2013 next element from `nums1`, same element from `nums2`\n  * `(i, j+1)`  \u2013 same element from `nums1`, next element from `nums2`\n\n  These two states are pushed into the heap **only if** they have not been\n  generated before.  To prevent duplicates we keep a `set` (or an\n  `unordered_set`) of `(i, j)` pairs that have already been inserted.\n\n* After extracting `N` largest products the collected list is already sorted\n  in descending order (because we always pop the greatest product).\n\nThe algorithm is basically the same as the classic \u201ck\u2011th smallest pair\nin two sorted arrays\u201d problem, except that we want largest products.\n\n\n\n-----------------------------------------------------------------------\n\n#### 2.  Correctness Proof  \n\nWe prove that the algorithm returns exactly the `N` largest products.\n\n---\n\n##### Lemma 1  \nAfter sorting, for every indices `i1 \u2264 i2` and `j1 \u2264 j2`  \n`nums1[i1] * nums2[j1] \u2265 nums1[i2] * nums2[j2]`.\n\n**Proof.**  \nAll numbers in each vector are non\u2011increasing after sorting.\nThus `nums1[i1] \u2265 nums1[i2]` and `nums2[j1] \u2265 nums2[j2]`.  \nMultiplying preserves the inequality because all values are non\u2011negative\n(holds also for negative values because the product of two decreasing\nsequences is decreasing). \u220e\n\n\n\n##### Lemma 2  \nAt any time the heap contains all products of the form\n`nums1[i] * nums2[j]` such that neither `(i, j)` nor any lexicographically\nsmaller pair was extracted before.\n\n**Proof by induction over the steps of the algorithm.**\n\n*Base.*  \nInitially the heap contains only `(0,0)` \u2013 the pair with smallest\nindices. No pair with smaller indices exists.\n\n*Induction step.*  \nAssume the property holds before a step.  \nLet `(p, i, j)` be popped.  \nThe algorithm inserts `(i+1, j)` and `(i, j+1)` **iff** they were never\ninserted before.  \nAny other pair `(i', j')` that is lexicographically smaller than either\n`(i+1,j)` or `(i,j+1)` must already have been extracted in a previous\nstep, because the heap is a max\u2011heap and we always pop the largest product.\nTherefore, after the insertion the property again holds. \u220e\n\n\n\n##### Lemma 3  \nThe *k\u2011th* popped product is the *k\u2011th largest* product among all\npossible pairs.\n\n**Proof.**  \nBy Lemma&nbsp;2 the heap always contains all still-unextracted products that\nare \u201creachable\u201d from the already extracted pairs.  \nThe max\u2011heap property guarantees that the largest of the reachable products\nis popped next.  \nBy Lemma&nbsp;1 the set of still\u2011unextracted products is a superset of the\nset of products whose indices are lexicographically larger; thus any product\noutside the heap is strictly smaller than the current maximum.  \nHence the algorithm pops products in strictly decreasing order. \u220e\n\n\n\n##### Theorem  \nThe vector returned by the algorithm contains exactly the `N`\nlargest products (with multiplicities) that can be formed by taking one\nelement from each input vector.\n\n**Proof.**  \nBy Lemma&nbsp;3 the first `N` popped products are the `N` largest products.\nThe algorithm stores each popped product in the result vector, therefore\nthe output consists exactly of those `N` values. \u220e\n\n\n\n-----------------------------------------------------------------------\n\n#### 3.  Complexity Analysis\n\nLet `n = nums1.size()`, `m = nums2.size()`.\n\n*Sorting* the two vectors: `O(n log n + m log m)` time, `O(n+m)` extra space.  \n*Heap operations* \u2013 each of the `N` pops generates at most two pushes.\nThe number of heap operations is `O(N)`.  \nEach push/pop costs `O(log K)` where `K \u2264 2N`, so the heap part takes\n`O(N log N)` time and `O(N)` memory.\n\nTotal complexities:\n\n| Operation | Time | Extra Space |\n|-----------|------|-------------|\n| Sorting | `O(n log n + m log m)` | `O(n+m)` |\n| Heap + visited set | `O(N log N)` | `O(N)` |\n| Result vector | `O(N)` | `O(N)` |\n\nThe dominant term is the sorting step.  \nIf `n` and `m` are large but `N` is small, the algorithm is heavily\nimproved over the brute\u2011force `O(n\u00b7m)` solution.\n\n-----------------------------------------------------------------------\n\n#### 4.  Reference Implementation (C++17)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<long> large_product(vector<long> nums1,\n                           vector<long> nums2,\n                           long N)\n{\n    if (nums1.empty() || nums2.empty() || N <= 0) return {};\n\n    // 1. sort descending\n    sort(nums1.begin(), nums1.end(), greater<long>());\n    sort(nums2.begin(), nums2.end(), greater<long>());\n\n    typedef long long L;          // to avoid overflow when multiplying\n    struct State {\n        L prod;   // product\n        int i, j; // indices\n        bool operator<(State const& other) const {\n            return prod < other.prod;          // for max-heap\n        }\n    };\n\n    priority_queue<State> pq;                   // max-heap\n    unordered_set<long long> visited;           // encode pair (i,j)\n\n    auto encode = [](int a, int b) -> long long {\n        return (static_cast<long long>(a) << 32) | static_cast<unsigned int>(b);\n    };\n\n    // initial pair (0,0)\n    pq.push({static_cast<L>(nums1[0]) * nums2[0], 0, 0});\n    visited.insert(encode(0, 0));\n\n    vector<long> result;\n    result.reserve(static_cast<size_t>(N));\n\n    while (!pq.empty() && static_cast<long>(result.size()) < N) {\n        State cur = pq.top();\n        pq.pop();\n\n        result.push_back(static_cast<long>(cur.prod)); // product fits in long\n\n        // Neighbor 1: next element in nums1\n        if (cur.i + 1 < static_cast<int>(nums1.size())) {\n            int ni = cur.i + 1, nj = cur.j;\n            long long key = encode(ni, nj);\n            if (visited.insert(key).second) {\n                pq.push({static_cast<L>(nums1[ni]) * nums2[nj], ni, nj});\n            }\n        }\n\n        // Neighbor 2: next element in nums2\n        if (cur.j + 1 < static_cast<int>(nums2.size())) {\n            int ni = cur.i, nj = cur.j + 1;\n            long long key = encode(ni, nj);\n            if (visited.insert(key).second) {\n                pq.push({static_cast<L>(nums1[ni]) * nums2[nj], ni, nj});\n            }\n        }\n    }\n\n    return result; // already sorted in descending order\n}\n```\n\n-----------------------------------------------------------------------\n\n#### 5.  Further Notes\n\n* **Overflow** \u2013 the product of two `long` values may exceed `long`.  \n  The code uses `long long` for internal multiplication; the result is\n  cast back to `long` when the function\u2019s contract requires it.\n* **Tie handling** \u2013 if several pairs produce the same product, the\n  algorithm returns as many copies as there are such pairs (subject to the\n  limit `N`), exactly as the problem statement demands.\n* **Alternative data structures** \u2013 if `N` is guaranteed to be very\n  small the algorithm can be further simplified; if `N` may approach\n  `n\u00b7m` a different approach (e.g., histogram or fast counting for small\n  integer ranges) would be preferable.", "Below is a compact, self\u2011contained implementation that returns the **N** largest products that can be formed by multiplying one element from `nums1` with one element from `nums2`.  \nThe algorithm is a classic \u201ck\u2011maximum pairwise product\u201d problem and runs in  \n`O((|nums1|+|nums2|) log (|nums1| + |nums2|))` time and `O(|nums1| + |nums2|)` space.  \n\n```cpp\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n\n/*\n * Return the N largest products that can be obtained by multiplying one\n * element from nums1 with one element from nums2.\n *\n * It is assumed that N <= nums1.size() * nums2.size().\n * The function does NOT modify the input vectors.\n */\nstd::vector<long> large_product(const std::vector<long>& nums1,\n                                const std::vector<long>& nums2,\n                                long N) {\n    const size_t n1 = nums1.size();\n    const size_t n2 = nums2.size();\n    assert(N <= static_cast<long>(n1) * static_cast<long>(n2) &&\n           \"N is larger than the number of possible products.\");\n\n    /* -------------------------------------------------------------\n       1. Sort the two input arrays in non\u2011increasing order (largest\n          first).  The largest product will always involve the largest\n          element of each array, which justifies the greedy approach.\n    ------------------------------------------------------------- */\n    std::vector<long> a(nums1), b(nums2);\n    std::sort(a.begin(), a.end(), std::greater<long>());\n    std::sort(b.begin(), b.end(), std::greater<long>());\n\n    /* -------------------------------------------------------------\n       2. Priority queue that keeps candidate products in decreasing\n          order.  Every entry stores:  product, index i in a, index j in b.\n    ------------------------------------------------------------- */\n    struct Item {\n        long prod;      // product a[i] * b[j]\n        size_t i, j;    // indices in a and b\n        bool operator<(const Item& other) const {\n            return prod < other.prod;          // max\u2011heap\n        }\n    };\n\n    std::priority_queue<Item> pq;\n    std::vector<std::vector<bool>> seen(n1, std::vector<bool>(n2, false));\n\n    // start with the largest possible product\n    pq.push({a[0] * b[0], 0, 0});\n    seen[0][0] = true;\n\n    std::vector<long> result;\n    result.reserve(static_cast<size_t>(N));\n\n    /* -------------------------------------------------------------\n       3. Extract the largest product N times, pushing the next two\n          neighbours in the grid each time.\n    ------------------------------------------------------------- */\n    while (result.size() < static_cast<size_t>(N) && !pq.empty()) {\n        auto cur = pq.top(); pq.pop();\n        result.push_back(cur.prod);\n\n        // neighbour to the right (i, j+1)\n        if (cur.j + 1 < n2 && !seen[cur.i][cur.j + 1]) {\n            pq.push({a[cur.i] * b[cur.j + 1], cur.i, cur.j + 1});\n            seen[cur.i][cur.j + 1] = true;\n        }\n        // neighbour below   (i+1, j)\n        if (cur.i + 1 < n1 && !seen[cur.i + 1][cur.j]) {\n            pq.push({a[cur.i + 1] * b[cur.j], cur.i + 1, cur.j});\n            seen[cur.i + 1][cur.j] = true;\n        }\n    }\n\n    return result;   // already in non\u2011increasing order\n}\n```\n\n### How it works\n\n1. **Sorting** \u2013 By sorting both vectors in descending order we guarantee that the largest product is `a[0] * b[0]`.  \n2. **Priority queue** \u2013 We maintain a max\u2011heap of candidate products.  \n3. **Visited matrix** \u2013 To avoid pushing the same `(i,j)` pair multiple times we keep a boolean grid `seen`.  \n4. **Neighbour expansion** \u2013 When we pop the current maximum `(i,j)`, we push its two rightward neighbours `(i, j+1)` and `(i+1, j)` (if within bounds and not already visited).  \n5. **Result collection** \u2013 The first `N` popped values are the N largest products, already in descending order.\n\nThe function is safe to use in a production environment: it checks that `N` does not exceed the total number of possible products and guarantees that the resulting vector contains exactly `N` values."]}
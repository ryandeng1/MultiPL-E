{"completions": ["Below is a compact, self\u2011contained implementation that works for all ASCII/UTF\u20118 compatible strings.  \nIt uses the classic dynamic\u2011programming approach:  \n`dp[i][j]` stores the length of the longest palindromic subsequence (LPS) inside `s[i\u2026j]`.  \nThe recurrence is\n\n```\nif s[i] == s[j] :  dp[i][j] = dp[i+1][j-1] + 2\nelse            :  dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n```\n\nThe table is filled for all substring lengths from 1 up to `n`.  \nThe result is `dp[0][n-1]` (or `0` when the string is empty).\n\n```cpp\n#include <string>\n#include <vector>\n#include <algorithm>\n\n// Return the length of the longest palindromic subsequence in `s`.\nlong lps(const std::string& s)\n{\n    const std::size_t n = s.size();\n    if (n == 0) return 0;\n\n    // dp[i][j] \u2013 LPS length in s[i .. j]\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, 0));\n\n    // all substrings of length 1 are palindromes of length 1\n    for (std::size_t i = 0; i < n; ++i)\n        dp[i][i] = 1;\n\n    // fill table for increasing substring lengths\n    for (std::size_t len = 2; len <= n; ++len) {\n        for (std::size_t i = 0; i + len <= n; ++i) {\n            std::size_t j = i + len - 1;\n            if (s[i] == s[j]) {\n                dp[i][j] = (len == 2) ? 2 : dp[i + 1][j - 1] + 2;\n            } else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\n```\n\n**Usage example**\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::string str = \"character\";\n    std::cout << \"Length of LPS: \" << lps(str) << '\\n';\n    return 0;\n}\n```\n\nThe algorithm runs in `O(n\u00b2)` time and `O(n\u00b2)` memory, which is optimal for the classic DP solution. If memory is a concern, a rolling\u2011array optimization can reduce it to `O(n)`.", "Below is a **complete, self\u2011contained C++ program** that implements the classic dynamic\u2011programming solution for the longest palindromic subsequence (LPS) problem.\n\n```cpp\n/*\n    Longest Palindromic Subsequence\n    --------------------------------\n    The function `longestPalindromicSubsequence` returns the length of the\n    longest subsequence that is also a palindrome.\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// ---------------------------------------------------------------\n// Return length of longest palindromic subsequence in `s`.\n// ---------------------------------------------------------------\nint longestPalindromicSubsequence(const string& s) {\n    int n = static_cast<int>(s.size());\n    if (n == 0) return 0;\n\n    // DP table: dp[i][j] = LPS length in substring s[i..j] inclusive\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n\n    // Length 1 substrings \u2013 single character is a palindrome of length 1\n    for (int i = 0; i < n; ++i) dp[i][i] = 1;\n\n    // Build table for increasing substring lengths\n    for (int len = 2; len <= n; ++len) {\n        for (int i = 0; i + len - 1 < n; ++i) {\n            int j = i + len - 1;\n            if (s[i] == s[j]) {\n                dp[i][j] = (len == 2) ? 2 : dp[i + 1][j - 1] + 2;\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\n\n// ---------------------------------------------------------------\n// Driver code \u2013 runs a few examples and can be used for testing\n// ---------------------------------------------------------------\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    vector<string> tests = {\n        \"bbbab\",\n        \"agbdba\",\n        \"character\",\n        \"abcd\",\n        \"\"\n    };\n\n    for (const auto& str : tests) {\n        cout << \"Input: \\\"\" << str << \"\\\"\\n\"\n             << \"Longest Palindromic Subsequence Length = \"\n             << longestPalindromicSubsequence(str) << \"\\n\\n\";\n    }\n\n    return 0;\n}\n```\n\n### How it works\n\n1. **DP Definition**  \n   `dp[i][j]` holds the length of the longest palindromic subsequence in the substring `s[i\u2026j]`.\n\n2. **Base Cases**  \n   - Every single character is a palindrome of length `1`.  \n   - For two identical characters (`len == 2` and `s[i] == s[j]`) the length is `2`.\n\n3. **Transition**  \n   - If the outer characters match (`s[i] == s[j]`), they can be added to the optimal solution of the inner substring: `dp[i+1][j-1] + 2`.  \n   - Otherwise, the result is the maximum of the two possibilities obtained by dropping either the leftmost or the rightmost character: `max(dp[i+1][j], dp[i][j-1])`.\n\n4. **Result**  \n   The answer for the whole string is `dp[0][n-1]`.\n\nThe algorithm runs in `O(n\u00b2)` time and uses `O(n\u00b2)` auxiliary space, which is optimal for this problem.", "Here is a compact, self\u2011contained implementation of **Longest Palindromic Subsequence (LPS)** in C++.  \nThe routine uses a classic DP approach with **O(n\u00b2)** time and **O(n)** auxiliary space.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n * Longest Palindromic Subsequence (LPS)\n *\n * A subsequence that reads the same forward and backward.\n * DP recurrence (len = n-1 - i is the length of the suffix considered):\n *   if s[i] == s[j]          -> dp[i][j] = 2 + dp[i+1][j-1]\n *   else                      -> dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n *\n * In the optimized version below we keep only one row of dp because\n * dp[i][j] depends on the row left to it (i+1) and the current row (i).\n */\n\nint lps(const string& s) {\n    int n = (int)s.size();\n    if (n == 0) return 0;\n\n    // dp[j] will store LPS length for substring s[i..j] when i is current row\n    vector<int> dp(n, 0);\n\n    // Process from the end of the string backwards\n    for (int i = n - 1; i >= 0; --i) {\n        dp[i] = 1;                // single character palindrome\n        int prev = 0;              // dp[i+1][j-1] from previous iteration\n\n        for (int j = i + 1; j < n; ++j) {\n            int temp = dp[j];     // save current dp[i+1][j] before overwriting\n            if (s[i] == s[j]) {\n                dp[j] = 2 + prev;   // characters match\n            } else {\n                dp[j] = max(dp[j], dp[j - 1]); // max of removing s[i] or s[j]\n            }\n            prev = temp;           // update prev for next j\n        }\n    }\n    return dp[n - 1];\n}\n\n/* ---------- Example usage & sanity check ---------- */\nint main() {\n    vector<string> tests = {\n        \"bbbab\",     // expected 4 (\"bbbb\")\n        \"agbdba\",    // expected 5 (\"abdba\")\n        \"abcd\",      // expected 1\n        \"\",          // expected 0\n        \"a\",         // expected 1\n        \"abacdfgdcaba\" // expected 7 (\"abaaba\" or others)\n    };\n\n    for (const auto& s : tests) {\n        cout << \"String: \\\"\" << s << \"\\\"\\tLPS length: \" << lps(s) << endl;\n    }\n    return 0;\n}\n```\n\n### How it works\n\n1. **Base case** \u2013 A single character is always a palindrome of length\u202f1.\n\n2. **DP Row update** \u2013 When iterating `i` from right to left and `j` from left to right:\n   * `prev` holds the value of the subproblem `dp[i+1][j-1]` from the preceding iteration of `j`.\n   * If `s[i] == s[j]`, we can extend the palindrome by 2 characters plus whatever was inside (`prev`).\n   * Otherwise we discard either the left or the right character (`dp[j]` or `dp[j-1]`) and take the best.\n\n3. **Space optimization** \u2013 Only one array `dp` is needed; each element references either the current row or the previous row, so the algorithm runs in `O(n)` space.\n\nFeel free to drop this snippet into your project or adapt it for larger input sizes."]}
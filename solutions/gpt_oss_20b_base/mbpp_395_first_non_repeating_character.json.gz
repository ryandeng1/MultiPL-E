{"completions": ["Below is a **stand\u2011alone, header\u2011only** implementation that can be dropped into any C++ program (C++17\u201120).  \nIt exposes a single function\n\n```cpp\nstd::optional<std::string> first_non_repeating_character(const std::string& str);\n```\n\n* Returns an `std::optional<std::string>` that contains the first non\u2011repeated\ncharacter encoded as a `std::string` (so it works with multibyte UTF\u20118 symbols).\n* Returns an empty `std::optional` when every character is repeated or the\nstring is empty.\n* Uses an `unordered_map` to count occurrences and a `deque` to keep the\norder of first appearances \u2013 O(n) time, O(k) extra space.\n\n```cpp\n// -------- first_non_repeating_character.hpp --------\n#pragma once\n\n#include <string>\n#include <unordered_map>\n#include <deque>\n#include <optional>\n\n/**\n * @brief Find the first *Unicode* character that is not repeated in the\n *        given string.\n *\n * The function treats the input as a UTF\u20118 encoded string.  Each\n * Unicode code\u2011point is considered one character \u2013 this is done by\n * iterating over all UTF\u20118 code\u2011points and decoding them.\n *\n * @param str input string (UTF\u20118)\n * @return std::optional<std::string>\n *          - with the first unique character (as a UTF\u20118 string) if one\n *            exists,\n *          - std::nullopt if the string is empty or all characters repeat.\n *\n * @note  Complexity:  O(n) time,  O(k) extra memory\n *        where n = str.size()  and  k = number of distinct code\u2011points.\n */\nstd::optional<std::string>\nfirst_non_repeating_character(const std::string& str)\n{\n    // Quick exit for empty string\n    if (str.empty())\n        return std::nullopt;\n\n    // Map from code\u2011point to its frequency\n    std::unordered_map<std::uint32_t, std::size_t> freq;\n\n    // deque stores the order in which code\u2011points were first seen\n    std::deque<std::uint32_t> order;\n\n    // Decode UTF\u20118 and count frequencies\n    for (std::size_t i = 0; i < str.size();) {\n        std::uint32_t cp = 0;          // current Unicode code\u2011point\n        unsigned char byte = static_cast<unsigned char>(str[i]);\n\n        if (byte <= 0x7F) {                // 1\u2011byte (ASCII)\n            cp = byte;\n            i += 1;\n        } else if ((byte >> 5) == 0x6) {   // 2\u2011byte\n            if (i + 1 >= str.size()) break;  // truncated\n            cp = ((byte & 0x1F) << 6) |\n                 (static_cast<unsigned char>(str[i+1]) & 0x3F);\n            i += 2;\n        } else if ((byte >> 4) == 0xE) {   // 3\u2011byte\n            if (i + 2 >= str.size()) break;\n            cp = ((byte & 0x0F) << 12) |\n                 ((static_cast<unsigned char>(str[i+1]) & 0x3F) << 6) |\n                 (static_cast<unsigned char>(str[i+2]) & 0x3F);\n            i += 3;\n        } else if ((byte >> 3) == 0x1E) {  // 4\u2011byte\n            if (i + 3 >= str.size()) break;\n            cp = ((byte & 0x07) << 18) |\n                 ((static_cast<unsigned char>(str[i+1]) & 0x3F) << 12) |\n                 ((static_cast<unsigned char>(str[i+2]) & 0x3F) << 6) |\n                 (static_cast<unsigned char>(str[i+3]) & 0x3F);\n            i += 4;\n        } else {\n            // Invalid UTF\u20118 byte, treat it as a distinct char\n            i += 1;\n        }\n\n        // Update frequency map\n        auto &cnt = freq[cp];\n        cnt += 1;\n        if (cnt == 1)                 // first time we see this code\u2011point\n            order.push_back(cp);\n    }\n\n    // Walk the order deque to find the first not repeated\n    for (const auto cp : order) {\n        if (freq[cp] == 1) {\n            // Convert cp back to UTF\u20118\n            std::string result;\n            if (cp <= 0x7F) {\n                result.push_back(static_cast<char>(cp));\n            } else if (cp <= 0x7FF) {\n                result.push_back(static_cast<char>(0xC0 | (cp >> 6)));\n                result.push_back(static_cast<char>(0x80 | (cp & 0x3F)));\n            } else if (cp <= 0xFFFF) {\n                result.push_back(static_cast<char>(0xE0 | (cp >> 12)));\n                result.push_back(static_cast<char>(0x80 | ((cp >> 6) & 0x3F)));\n                result.push_back(static_cast<char>(0x80 | (cp & 0x3F)));\n            } else {\n                result.push_back(static_cast<char>(0xF0 | (cp >> 18)));\n                result.push_back(static_cast<char>(0x80 | ((cp >> 12) & 0x3F)));\n                result.push_back(static_cast<char>(0x80 | ((cp >> 6) & 0x3F)));\n                result.push_back(static_cast<char>(0x80 | (cp & 0x3F)));\n            }\n            return result;\n        }\n    }\n\n    // No unique character found\n    return std::nullopt;\n}\n```\n\n### How to use it\n\n```cpp\n#include \"first_non_repeating_character.hpp\"\n#include <iostream>\n\nint main() {\n    std::string s1 = \"hello world\";\n    auto r1 = first_non_repeating_character(s1);\n    if (r1) std::cout << \"first non\u2011repeating: \" << *r1 << '\\n';\n    else std::cout << \"no unique character\\n\";\n\n    std::string s2 = \"aabbcc\";\n    auto r2 = first_non_repeating_character(s2);\n    if (r2) std::cout << \"first non\u2011repeating: \" << *r2 << '\\n';\n    else std::cout << \"no unique character\\n\";\n}\n```\n\n### Why this implementation?\n\n| Feature | Why it matters |\n|---------|----------------|\n| **UTF\u20118 aware** | Works with any Unicode text, not just ASCII. |\n| **`std::optional`** | Clear, safe interface that indicates \u201cno result\u201d without magic values. |\n| **Single pass counting + order queue** | Guarantees the *first* non\u2011repeated in O(n). |\n| **Header\u2011only** | Easy to drop into projects. |\n\nFeel free to drop the header into your code base, or copy the function into your file if you prefer. Happy coding!", "Here\u2019s a ready\u2011to\u2011paste C++17 implementation that follows the signature you started with.  \nIt returns an `std::optional<std::string>` that contains the first non\u2011repeated character as a *single\u2011character string*.  \nIf every character is repeated, the optional is empty.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*  Returns the first non\u2011repeated character of the\n *  given string.  If no such character exists,\n *  an empty optional is returned.\n */\nstd::optional<std::string> first_non_repeating_character(std::string str1)\n{\n    // Count how many times each character occurs\n    unordered_map<char, int> freq;\n    for (char c : str1) {\n        ++freq[c];\n    }\n\n    // Find the first character whose frequency is 1\n    for (char c : str1) {\n        if (freq[c] == 1) {\n            // Wrap the character in a single\u2011char string\n            return string(1, c);\n        }\n    }\n\n    // No unique character found\n    return std::nullopt;\n}\n\n/*  -----------------  Example usage  ----------------- */\nint main()\n{\n    string s = \"swiss\";\n    auto res = first_non_repeating_character(s);\n    if (res) {\n        cout << \"First non\u2011repeating character: \" << *res << '\\n';\n    } else {\n        cout << \"No non\u2011repeating character found.\\n\";\n    }\n    return 0;\n}\n```\n\n### How it works\n\n1. **Frequency counting** \u2013 A single pass over the string populates `freq` with the number of occurrences of each character.  \n2. **Search for a unique character** \u2013 A second pass checks the original order. The first character that has a frequency of `1` is returned.  \n3. **Result type** \u2013 We wrap the character inside a `std::string` because the function\u2019s return type is `std::optional<std::string>`.  \n4. **Empty optional** \u2013 If no character occurs exactly once, the function returns `std::nullopt`.\n\nFeel free to drop this into your project, modify the return type (e.g., `std::optional<char>`), or adapt it for case\u2011insensitive/non\u2011ASCII strings.", "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Return the first non\u2011repeating character in *str1*.\n// If every character repeats, return an empty optional.\nstd::optional<char> first_non_repeating_character(const std::string &str1)\n{\n    // Count occurrences\n    std::unordered_map<char, int> freq;\n    for (char c : str1) {\n        ++freq[c];\n    }\n\n    // Find first character with frequency 1\n    for (char c : str1) {\n        if (freq[c] == 1) {\n            return c;          // found\n        }\n    }\n\n    // All characters repeat\n    return std::nullopt;\n}\n```\n\n### Examples\n\n```cpp\nauto r1 = first_non_repeating_character(\"swiss\");      // r1.has_value() == true, *r1 == 'w'\nauto r2 = first_non_repeating_character(\"aabbcc\");      // r2.has_value() == false\nauto r3 = first_non_repeating_character(\"abcdabc\");     // *r3 == 'd'\n```\n\nThis implementation runs in\u202fO(n) time and uses O(\u03c3) additional space (\u03c3\u202f=\u202fnumber of distinct characters)."]}
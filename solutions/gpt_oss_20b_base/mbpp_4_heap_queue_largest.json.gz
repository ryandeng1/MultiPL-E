{"completions": ["Here\u2019s a compact, exception\u2011safe implementation that uses a **min\u2011heap** (priority_queue with `std::greater`) to keep track of the current `n` largest elements.  \nIf `n` is larger than the vector size, we simply return the whole vector sorted in descending order.\n\n```cpp\n#include <vector>\n#include <queue>\n#include <algorithm>\n\n// Return the n largest integers from `nums`, in descending order.\nstd::vector<long> heap_queue_largest(std::vector<long> nums, long n)\n{\n    // if the request is more than available elements, just sort everything\n    if (n >= static_cast<long>(nums.size()))\n    {\n        std::sort(nums.begin(), nums.end(), std::greater<long>());\n        return nums;\n    }\n\n    // min\u2011heap that keeps the n largest elements seen so far\n    std::priority_queue<long, std::vector<long>, std::greater<long>> min_heap;\n\n    // initialise heap with first n elements\n    for (long i = 0; i < n; ++i)\n        min_heap.push(nums[i]);\n\n    // iterate over the rest of the vector\n    for (long i = n; i < static_cast<long>(nums.size()); ++i)\n    {\n        if (nums[i] > min_heap.top())\n        {\n            min_heap.pop();          // remove smallest of current n\n            min_heap.push(nums[i]);  // add the new larger element\n        }\n    }\n\n    // extract elements from the heap into a vector (in ascending order)\n    std::vector<long> result;\n    result.reserve(static_cast<size_t>(n));\n    while (!min_heap.empty())\n    {\n        result.push_back(min_heap.top());\n        min_heap.pop();\n    }\n\n    // we need descending order, so reverse the vector\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```\n\n### How it works\n\n1. **Edge case** \u2013 If `n` is larger than the number of elements, sort the entire vector in descending order and return it.\n2. **Min\u2011heap** \u2013 Keeps the `n` largest values seen so far.  \n   * The top of the heap is always the *smallest* among those `n` values.\n3. **Scanning** \u2013 For each element after the first `n`, if it is larger than the heap\u2019s top, we replace the smallest element with it.\n4. **Result extraction** \u2013 Pull all elements from the heap into a vector, reverse it to obtain descending order, and return.\n\nThis algorithm runs in `O(m log n)` time (`m = nums.size()`) and uses `O(n)` auxiliary space.", "Below is a **complete, ready\u2011to\u2011compile** implementation that follows the specification:\n\n* **Parameters** \u2013 `nums` : a vector of integers (can contain negative values),  \n  `n` : how many of the largest values we want to extract.\n* **Return value** \u2013 a vector that contains the `n` largest values **in descending order**.\n* **Behaviour** \u2013 if `n` is larger than the number of elements in `nums`, it simply returns all elements in descending order.\n* **Complexity** \u2013  \n  \u2022 `O(k log n)` where `k = nums.size()`.  \n  \u2022 Memory usage is `O(n)`.\n\n```cpp\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <stdexcept>\n#include <iostream>\n\n// ---------------------------------------------------------------------\n//  Return the n largest integers of |nums| in descending order.\n// ---------------------------------------------------------------------\nstd::vector<long> heap_queue_largest(const std::vector<long>& nums, long n)\n{\n    if (n <= 0) return {};                    // nothing requested\n\n    /* \u4f7f\u7528\u6700\u5c0f\u5806 (priority_queue with greater<>) \u7ef4\u6301\u5f53\u524d\u9009\u51fa\u7684 n \u4e2a\u6700\u5927\u503c\n       a. \u904d\u5386\u6240\u6709\u5143\u7d20\n       b. \u9700\u8981\u4f7f\u7528\u7684\u72b6\u6001: \u5806\u7684\u5927\u5c0f <= n\n    */\n    std::priority_queue<long, std::vector<long>, std::greater<long>> min_heap;\n\n    for (long x : nums) {\n        if (static_cast<long>(min_heap.size()) < n) {\n            min_heap.push(x);                 // \u76f4\u63a5\u5165\u5806\n        } else if (x > min_heap.top()) {\n            min_heap.pop();                   // \u5f39\u51fa\u6700\u5c0f\u5143\u7d20\n            min_heap.push(x);                 // \u5165\u65b0\u7684\u66f4\u5927\u7684\u5143\u7d20\n        }\n        // \u5982\u679c x <= min_heap.top() \u5219\u76f4\u63a5\u5ffd\u7565\n    }\n\n    // \u628a\u5806\u4e2d\u7684\u5143\u7d20\u5168\u90e8\u53d6\u51fa\uff0c\u5f97\u5230\u7684\u987a\u5e8f\u662f\u5347\u5e8f\n    std::vector<long> result;\n    result.reserve(min_heap.size());\n    while (!min_heap.empty()) {\n        result.push_back(min_heap.top());\n        min_heap.pop();\n    }\n\n    // \u9700\u8981\u964d\u5e8f\u8fd4\u56de\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n\n// ---------------------------------------------------\n//  \u4ee5\u4e0b\u4e3a\u6f14\u793a\u7528\u7684 main \u51fd\u6570\uff08\u53ef\u81ea\u884c\u53bb\u6389\uff09\n// ---------------------------------------------------\n#ifdef RUN_SAMPLE_MAIN\nint main() {\n    std::vector<long> data = {5, 1, 9, 3, 7, 2, 9, 4};\n    long n = 4;\n\n    std::vector<long> largest = heap_queue_largest(data, n);\n\n    std::cout << \"The \" << n << \" largest values (descending): \";\n    for (auto v : largest) std::cout << v << ' ';\n    std::cout << '\\n';\n    return 0;\n}\n#endif\n```\n\n### \u8bf4\u660e\n\n1. **\u4e3a\u4ec0\u4e48\u8981\u7528\u6700\u5c0f\u5806?**  \n   \u53ea\u4fdd\u6301\u5f53\u524d\u770b\u5230\u7684\u6700\u5927\u7684 `n` \u4e2a\u5143\u7d20\u3002  \n   \u5806\u9876\u662f\u5f53\u524d `n` \u4e2a\u6570\u91cc\u6700\u5c0f\u7684\uff0c\u5f53\u65b0\u5143\u7d20\u6bd4\u5b83\u5927\u65f6\uff0c\u66ff\u6362\u6389\u5b83\u3002  \n   \u6700\u540e\u5806\u91cc\u5c31\u5269\u4e0b `n` \u4e2a\u6700\u5927\u7684\u5143\u7d20\u3002\n\n2. **\u65f6\u95f4\u590d\u6742\u5ea6**  \n   - \u5bf9\u6bcf\u4e2a\u8f93\u5165\u5143\u7d20\u53ea\u505a `O(log n)` \u7684\u5806\u64cd\u4f5c \u2192 `O(k\u202flog\u202fn)`\u3002  \n   - \u53ea\u4f1a\u904d\u5386\u4e00\u6b21\u8f93\u5165\u6570\u7ec4\u3002\n\n3. **\u7a7a\u95f4\u590d\u6742\u5ea6**  \n   - \u5806\u53ea\u4fdd\u5b58 `n` \u4e2a\u5143\u7d20 \u2192 `O(n)`\u3002\n\n4. **\u8fb9\u754c\u60c5\u51b5**  \n   - `n` \u4e3a\u8d1f\u6216\u96f6 \u2192 \u7a7a\u5411\u91cf\u3002  \n   - `n` \u5927\u4e8e `nums.size()` \u2192 \u76f4\u63a5\u8fd4\u56de\u5168\u90e8\u5143\u7d20\u7684\u964d\u5e8f\u6392\u5e8f\u3002  \n   - \u8d1f\u6570\u3001\u91cd\u590d\u503c\u5747\u88ab\u6b63\u786e\u5904\u7406\u3002\n\n\u82e5\u60f3\u5728\u5176\u5b83\u6587\u4ef6\u4e2d\u4f7f\u7528\uff0c\u53ea\u9700\u53bb\u6389 `#ifdef RUN_SAMPLE_MAIN` \u5757\u5373\u53ef\uff1b\u7f16\u8bd1\u65f6\u53ea\u9700\u4fdd\u8bc1\u5305\u542b `<bits/stdc++.h>` \u6216\u8005\u81ea\u5df1\u52a0\u5165\u5fc5\u8981\u5934\u6587\u4ef6\u3002", "**Solution**\n\nWe want to return the *n* biggest numbers from a vector `nums` in **descending** order.  \nA direct sort would be `O(N log N)` and then we would just slice the first *n* elements.  \nA more efficient way when *n* is much smaller than *N* is to maintain a *min\u2011heap* of size *n*:\n\n* insert the first *n* numbers into the heap\n* for every remaining number `x`\n  * if `x` is larger than the smallest element in the heap (the top), pop the top and push `x`\n* after processing all elements the heap contains the *n* largest numbers\n* finally, pop all elements from the heap into a vector and sort it in reverse.\n\nThis runs in `O(N log n)` time and `O(n)` additional space \u2013 which is better than sorting the whole vector when *n<<N*.\n\n```cpp\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n\n/**\n * @brief Returns the n largest integers from the input vector in descending order.\n *\n * @param nums The input vector of long integers.\n * @param n    Number of largest elements to return. If n <= 0 or n > nums.size() the\n *             function returns all elements sorted in descending order.\n * @return std::vector<long>  A vector containing the n largest elements in descending order.\n */\nstd::vector<long> heap_queue_largest(std::vector<long> nums, long n)\n{\n    if (nums.empty() || n <= 0) return {};\n\n    // If n >= size we can simply sort once.\n    if (n >= static_cast<long>(nums.size())) {\n        std::sort(nums.begin(), nums.end(), std::greater<long>());\n        return nums;\n    }\n\n    // Min\u2011heap that will keep the current n largest elements\n    std::priority_queue<long, std::vector<long>, std::greater<long>> min_heap;\n\n    // Build initial heap of size n\n    for (long i = 0; i < n; ++i)\n        min_heap.push(nums[i]);\n\n    // Process remaining elements\n    for (size_t i = static_cast<size_t>(n); i < nums.size(); ++i) {\n        if (nums[i] > min_heap.top()) {\n            min_heap.pop();\n            min_heap.push(nums[i]);\n        }\n    }\n\n    // Extract elements from the heap into a vector (will be ascending)\n    std::vector<long> result;\n    result.reserve(static_cast<size_t>(n));\n    while (!min_heap.empty()) {\n        result.push_back(min_heap.top());\n        min_heap.pop();\n    }\n\n    // Reverse to convert to descending order\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```\n\n**Test Cases**\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<long> data{4, 1, 7, 3, 10, 9, 2};\n    auto top3 = heap_queue_largest(data, 3);\n    for (auto x : top3) std::cout << x << ' ';   // 10 9 7\n    std::cout << '\\n';\n\n    auto all = heap_queue_largest(data, 10);      // n > size -> all sorted\n    for (auto x : all) std::cout << x << ' ';    // 10 9 7 4 3 2 1\n}\n```\n\nThe function handles edge conditions (empty vector, negative `n`, `n` larger than the vector) and performs the task in an efficient `O(N log n)` time with `O(n)` auxiliary space."]}
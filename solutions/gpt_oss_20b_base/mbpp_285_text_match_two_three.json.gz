{"completions": ["Here is a simple, self\u2011contained implementation of the requested function.\n\n```cpp\n#include <string>\n\n/// \\brief   Checks whether a string contains the pattern\n///          'a' followed by two **or** three consecutive 'b' characters.\n/// \\param   text  Input string to be examined.\n/// \\return  true  if the pattern is present; false otherwise.\n///\n/// The implementation is intentionally straightforward: it walks through the\n/// string one character at a time and, when an `'a'` is seen, it checks whether\n/// the next two or three characters are all `'b'`.  No regular\u2011expression\n/// libraries are used, which makes the code portable to any compiler that\n/// supports C++11 or later.\nbool text_match_two_three(const std::string& text)\n{\n    const std::size_t n = text.size();\n\n    for (std::size_t i = 0; i + 2 < n; ++i) {          // at least 3 chars left\n        if (text[i] != 'a')                           // look for an 'a'\n            continue;\n\n        // We already have an 'a' at position i.\n        // Check for \"abb\"\n        if (text[i + 1] == 'b' && text[i + 2] == 'b')\n            return true;                              // \"a bb\" found\n\n        // Check for \"abbb\" (requires one more character)\n        if (i + 3 < n && text[i + 1] == 'b' &&\n            text[i + 2] == 'b' && text[i + 3] == 'b')\n            return true;                              // \"a bbb\" found\n    }\n\n    return false;                                      // pattern not found\n}\n```\n\n### Why this design?\n\n| Feature | Reason |\n|---------|--------|\n| **No regex** | Avoids pulling in large regex libraries; code remains tiny and fast. |\n| **`const std::string&`** | Passes the string by reference to avoid a copy. |\n| **Early return** | Stops scanning as soon as the pattern is found. |\n| **Single loop** | Only one pass over the string: \\(O(n)\\) time, \\(O(1)\\) extra space. |\n\n### Quick tests\n\n```cpp\n#include <cassert>\n\nint main() {\n    assert(text_match_two_three(\"acbbb\") == false);\n    assert(text_match_two_three(\"ab\")     == false);\n    assert(text_match_two_three(\"abbb\")   == true);   // \"a bbb\"\n    assert(text_match_two_three(\"aabbb\")  == true);   // second 'a' starts the pattern\n    assert(text_match_two_three(\"aaabb\")  == false);  // 'a' followed by only two 'b's\n    assert(text_match_two_three(\"xbbabb\") == true);   // contains \"a bb\" at the end\n    return 0;\n}\n```\n\nThis satisfies the requirement: the function checks for an `'a'` immediately followed by **exactly two** or **exactly three** `'b'` characters anywhere inside the string.", "You can implement the function by scanning the string once.  \nWhenever you encounter an `'a'`, you then look ahead to see if the next two or three characters are all `'b'`.  \nIf you find such a pattern, the function returns `true`. If the end of the string is reached without a match, it returns `false`.\n\n```cpp\n#include <string>\n#include <cassert>\n\n// Return true if the text contains an 'a' followed by two or three 'b' characters.\nbool text_match_two_three(const std::string& text) {\n    // Iterate over the string but don\u2019t go beyond its last two characters\n    // because we need at least \u201ca + 2*b\u201d to consider.\n    for (std::size_t i = 0; i + 2 < text.size(); ++i) {\n        if (text[i] != 'a') continue;          // nothing to do if not an 'a'\n        \n        // Check for two consecutive 'b's\n        if (text[i + 1] == 'b' && text[i + 2] == 'b') {\n            // If there's a third 'b', that's also acceptable\n            if (i + 3 < text.size() && text[i + 3] == 'b')\n                return true;                    // a + 3 b's\n            return true;                        // a + 2 b's\n        }\n    }\n    return false;\n}\n\n// ---------------------------------------------------------------------\n// Simple test harness\n// ---------------------------------------------------------------------\nint main() {\n    assert(text_match_two_three(\"aaabb\") == false);\n    assert(text_match_two_three(\"abbb\")  == true);   // a + 3 b's\n    assert(text_match_two_three(\"abb\")   == true);   // a + 2 b's\n    assert(text_match_two_three(\"ab\")    == false);  // not enough b's\n    assert(text_match_two_three(\"baabb\") == true);   // a + 2 b's embedded\n    assert(text_match_two_three(\"\")      == false);\n    assert(text_match_two_three(\"a\")     == false);\n    assert(text_match_two_three(\"abbbb\") == true);  // a + 3 b's (extra b ignored)\n\n    return 0;\n}\n```\n\n**Explanation**\n\n* We iterate only while `i + 2 < text.size()` because a match needs at least an `\"a\"` and two `\"b\"` characters.\n* When an `'a'` is found, we immediately check the next two positions for `'b'`.\n* If those two are `'b'`, we additionally test for a third `'b'` (makes the check for \u201ctwo or three\u201d).\n* The function returns `true` at the first match; if the loop finishes without finding one, it returns `false`.\n\nThis implementation is *O(n)* time, *O(1)* extra space, and works for any ASCII string.", "Below is a minimal, self\u2011contained implementation that follows the specification.\nIt accepts a `std::string` and returns `true` if the string contains the letter `'a'` immediately followed by **two** or **three** `'b'` characters.  \nAll other characters are allowed, they just cannot appear between that `a` and the definite sequence of `b`s.\n\n```cpp\n#include <string>\n#include <regex>\n\n/*  Return true if the input contains\n *  the pattern \"abb\" or \"abbb\".\n */\nbool text_match_two_three(const std::string& text)\n{\n    /*  Regular expression that looks for:\n     *      a   -> the literal 'a'\n     *      b{2,3} -> either two or three consecutive 'b's\n     *      The expression is unconstrained by start/end anchors, so\n     *      the match may appear anywhere inside the string.          */\n    static const std::regex pattern(\"a b{2,3}\", std::regex::ECMAScript);\n\n    // std::regex_search scans the whole string for any match of the pattern\n    return std::regex_search(text, pattern);\n}\n```\n\n### How it works\n\n1. **Regular expression**  \n   - `a`   \u2013 literal `a`.  \n   - `b{2,3}` \u2013 exactly two or three consecutive `b` characters.  \n   - The pattern is not anchored (`^`/`$`), so a match can be found anywhere in the string.\n\n2. **`std::regex_search`**  \n   The function scans the string and returns `true` as soon as it finds a match.\n\n3. **Performance note**  \n   Because the regex is small and the pattern space is tiny (`a` followed by 2\u20133 `b`s), compile\u2011time and run\u2011time are negligible.  \n   If you plan to call this function many times on huge strings, you might prefer a manual character\u2011by\u2011character scan (just a few lines of code) which would avoid the overhead of the regex engine.\n\n---\n\n#### Manual\u2011scan alternative (no regex)\n\nIf you want to avoid `<regex>` altogether, you can use a simple loop:\n\n```cpp\nbool text_match_two_three(const std::string& text)\n{\n    for (size_t i = 0; i + 2 < text.size(); ++i) {\n        if (text[i] == 'a' &&\n            text[i+1] == 'b' &&\n            text[i+2] == 'b' &&\n            (i + 3 >= text.size() || text[i+3] != 'b' || text[i+4] != 'b')) {\n            return true;   // exactly two 'b's\n        }\n        if (i + 3 < text.size() &&\n            text[i] == 'a' &&\n            text[i+1] == 'b' &&\n            text[i+2] == 'b' &&\n            text[i+3] == 'b') {\n            return true;   // exactly three 'b's\n        }\n    }\n    return false;\n}\n```\n\nEither version satisfies the requirement; choose the one that best fits your context."]}
{"completions": ["Below is a complete, self\u2011contained example that demonstrates how to take **three** aligned vectors\n\n| `l1` | `l2` | `l3` |\n|------|------|------|\n| a    | x    | 1    |\n| a    | y    | 2    |\n| b    | x    | 3    |\n| b    | z    | 4    |\n\n\u2014 and produce a **nested map**\n\n```cpp\n{\n   \"a\" : { \"x\" : 1, \"y\" : 2 },\n   \"b\" : { \"x\" : 3, \"z\" : 4 }\n}\n```\n\nThe function accepts three vectors of the same length (the caller is responsible for that; we simply assert it in our code).  \nIt iterates over the vectors, and for each three\u2011tuple\n\n1. `outerKey = l1[i]`\u2003\u2013 the key of the *outer* map  \n2. `innerKey = l2[i]`\u2003\u2013 the key of the *inner* map  \n3. `value    = l3[i]`\u2003\u2013 the value stored in the inner map\n\nand inserts them into the nested map structure.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <cassert>\n\n// ---------------------------------------------------------------------------\n// Convert three parallel vectors into a nested map\n//\n// l1 : vector of outer keys (std::string)\n// l2 : vector of inner keys (std::string)\n// l3 : vector of values (long)\n// ---------------------------------------------------------------------------\nstd::vector<std::map<std::string,std::map<std::string,long>>>\nconvert_list_dictionary(const std::vector<std::string> &l1,\n                        const std::vector<std::string> &l2,\n                        const std::vector<long>        &l3)\n{\n    // NOTE: This API mirrors the original question \u2013 it returns a *vector*\n    // of nested maps.  In most real\u2011world cases you would return a single\n    // nested map, but keeping the vector form matches the requested type\n    // signature.  Here we simply put one element into the vector.\n    //\n    // Validation\n    assert(l1.size() == l2.size() &&\n           l2.size() == l3.size() &&\n           \"Input vectors must have the same length\");\n\n    std::map<std::string, std::map<std::string, long>> nested;\n\n    for (size_t i = 0; i < l1.size(); ++i)\n    {\n        const std::string &outerKey = l1[i];\n        const std::string &innerKey = l2[i];\n        const long        value     = l3[i];\n\n        // Insert or update the inner map\n        nested[outerKey][innerKey] = value;\n    }\n\n    // Wrap the single nested map into a vector as per the requested\n    // signature.\n    return { nested };\n}\n\n// ---------------------------------------------------------------------------\n// Helper: pretty\u2011print a nested map\n// ---------------------------------------------------------------------------\nvoid printNestedMap(const std::map<std::string,std::map<std::string,long>>& nested)\n{\n    std::cout << \"{\\n\";\n    for (const auto &outer : nested)\n    {\n        std::cout << \"  \\\"\" << outer.first << \"\\\" : { \";\n        for (auto it = outer.second.begin(); it != outer.second.end(); ++it)\n        {\n            std::cout << \"\\\"\" << it->first << \"\\\" : \" << it->second;\n            if (std::next(it) != outer.second.end()) std::cout << \", \";\n        }\n        std::cout << \" }\\n\";\n    }\n    std::cout << \"}\\n\";\n}\n\n// ---------------------------------------------------------------------------\n// Demo\n// ---------------------------------------------------------------------------\nint main()\n{\n    std::vector<std::string> l1 = {\"a\",\"a\",\"b\",\"b\"};\n    std::vector<std::string> l2 = {\"x\",\"y\",\"x\",\"z\"};\n    std::vector<long>        l3 = {1,2,3,4};\n\n    auto result = convert_list_dictionary(l1, l2, l3);\n    assert(result.size() == 1);          // we created one nested map\n\n    printNestedMap(result.front());\n\n    return 0;\n}\n```\n\n### What the program does\n\n1. **Validation** \u2013 `assert` guarantees the vectors all have the same length.\n2. **Construction** \u2013 A `std::map` of maps is built by iterating over the vectors.\n3. **Return** \u2013 The nested map is wrapped in a `std::vector` (as requested in the function signature).\n4. **Printing** \u2013 The helper `printNestedMap` lets you see the result in a JSON\u2011ish format.\n\nRunning the program prints:\n\n```\n{\n  \"a\" : { \"x\" : 1, \"y\" : 2 }\n  \"b\" : { \"x\" : 3, \"z\" : 4 }\n}\n```\n\nFeel free to adapt the function to return a single nested map directly if that matches your application better.", "Below is a self\u2011contained implementation that takes three `std::vector`s\n\n```text\nl1 : vector of first\u2011level keys (std::string)\nl2 : vector of second\u2011level keys (std::string)\nl3 : vector of values (long)\n```\n\nand produces a nested structure\n\n```c++\nstd::vector<\n    std::map<std::string,               // first key\n        std::map<std::string, long>>>; // second key \u2192 value\n```\n\nThe implementation keeps the order of the outer vector (`l1`), while each\n`std::map` keeps the keys sorted (the natural behaviour of `std::map`).\n\n```cpp\n#include <vector>\n#include <string>\n#include <map>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n\n/*\n *  Convert 3 parallel vectors into a nested vector<map<\u2026>>.\n *\n *  l1 \u2013 vector of first\u2011level keys (used as the outer vector elements).\n *  l2 \u2013 vector of second\u2011level keys.\n *  l3 \u2013 vector of corresponding values.\n *\n *  Preconditions:\n *      l1.size() == l2.size() == l3.size()\n *\n *  Returns:\n *      vector where each element is a map firstKey \u2192 (map secondKey \u2192 value).\n *      Each *firstKey* appears only once in the outer vector; the map\n *      aggregates all second\u2011keys for that firstKey.\n */\nstd::vector<std::map<std::string, std::map<std::string, long>>>\nconvert_list_dictionary(const std::vector<std::string>& l1,\n                        const std::vector<std::string>& l2,\n                        const std::vector<long>&       l3)\n{\n    // 1. Check that all input vectors have the same length\n    assert(l1.size() == l2.size() && l2.size() == l3.size());\n\n    // 2. Build a temporary map from first\u2011key to the inner map\n    std::unordered_map<std::string, std::map<std::string, long>> temp;\n\n    for (size_t i = 0; i < l1.size(); ++i)\n    {\n        const std::string& first_key = l1[i];\n        const std::string& second_key = l2[i];\n        long              value     = l3[i];\n\n        temp[first_key][second_key] = value;\n    }\n\n    // 3. Transfer the unordered_map into a vector so the outer order follows the first appearance\n    std::vector<std::map<std::string, std::map<std::string, long>>> result;\n\n    // We want to preserve the order of first keys as they appear in l1.\n    // A simple way is to iterate l1 again and push each unique first_key once.\n    std::unordered_set<std::string> seen;\n    for (const auto& first_key : l1)\n    {\n        if (seen.insert(first_key).second)   // first time we see this key\n        {\n            result.emplace_back();                // make a copy of the inner map\n            result.back() = temp[first_key];\n        }\n    }\n\n    return result;\n}\n\n/* ------------------------------------------------------------------------- */\n/* Utility functions to pretty\u2011print the resulting data structure (for demo) */\n\nvoid print_nested_vector(const std::vector<std::map<std::string, std::map<std::string, long>>>& v)\n{\n    std::cout << \"[\\n\";\n    for (const auto& outer_map : v)\n    {\n        std::cout << \"  {\\n\";\n        for (const auto& [k1, inner_map] : outer_map)\n        {\n            std::cout << \"    \\\"\" << k1 << \"\\\": {\\n\";\n            for (const auto& [k2, val] : inner_map)\n            {\n                std::cout << \"      \\\"\" << k2 << \"\\\": \" << val << \",\\n\";\n            }\n            std::cout << \"    }\\n\";\n        }\n        std::cout << \"  },\\n\";\n    }\n    std::cout << \"]\\n\";\n}\n\n/* ------------------------------------------------------------------------- */\n/* Example usage */\n\nint main()\n{\n    std::vector<std::string> l1 = {\"apple\", \"banana\", \"apple\", \"cherry\"};\n    std::vector<std::string> l2 = {\"red\",    \"yellow\", \"green\", \"red\"};\n    std::vector<long>       l3 = {5,        7,        8,        9};\n\n    auto result = convert_list_dictionary(l1, l2, l3);\n\n    print_nested_vector(result);\n    return 0;\n}\n```\n\n### What the code does\n\n1. **Input validation** \u2013 an `assert` guarantees all vectors have the same size.\n2. **First\u2011level aggregation** \u2013 an `unordered_map` collects all `(second_key \u2192 value)` pairs for each `first_key`.\n3. **Ordering** \u2013 because the outer structure is required to be a `vector` that preserves the order in which first\u2011level keys appear, we walk through `l1` again, adding each distinct `first_key` only once to the result vector.\n4. **Return** \u2013 the final vector contains the nested maps in the requested format.\n\n### Remarks\n\n* The inner map is a `std::map`, so the second\u2011level keys are ordered alphabetically.\n* If you need the outer vector in *exactly* the order of first appearance, the order\u2011preserving loop in step\u202f3 guarantees that.\n* If you prefer the outer vector to be sorted lexicographically by the first key, simply replace the order\u2011preserving loop with a simple copy of the `unordered_map`\u2019s entries after sorting the keys.", "Below is a complete and idiomatic C++ implementation of the function you described.  \nThe function accepts three equally\u2011sized vectors  \n`l1` \u2013\u202fouter key (string)  \n`l2` \u2013\u202finner key (string)  \n`l3` \u2013\u202fvalue (long)  \n\nand produces\n\n```\nvector<map<string , map<string , long>>>\n```\n\nwhich can be thought of as\n```\n[   // outer vector\n    {   // first map in the vector\n        \"USA\" : {  \"New York\" : 100 , \"Boston\" : 200 },\n        \"UK\"   : {  \"London\"   : 300 }\n    },\n    {   // second map in the vector\n        \"Germany\" : { \"Berlin\" : 400 }\n    }\n]\n```\n\nThe implementation is very small, uses only the standard library and respects\nconst\u2011correctness and efficient operations (amortized constant time insert\noperations).  It also contains a small helper for testing.\n\n```cpp\n#include <cassert>\n#include <cstddef>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n\n/**\n * @brief   Convert three parallel vectors into a nested vector\u2011of\u2011maps structure\n * @param   l1  Vector containing the keys of the outer map\n * @param   l2  Vector containing the keys of the inner map\n * @param   l3  Vector containing the values of the inner map\n *\n * @return  std::vector<std::map<std::string,\n *                 std::map<std::string, long>>>   // nested structure\n *\n * @note    All three input vectors must have the same length.\n *          Each index i is interpreted as a tuple:\n *              l1[i] -> l2[i] -> l3[i]\n */\nstatic std::vector<std::map<std::string, std::map<std::string, long>>>\nconvert_list_dictionary(const std::vector<std::string> &l1,\n                        const std::vector<std::string> &l2,\n                        const std::vector<long>        &l3)\n{\n    /* Sanity check \u2013 in release builds this is optional but helps find bugs\n       early. */\n    assert(l1.size() == l2.size() && l2.size() == l3.size());\n\n    /* The result vector and a temporary map that couples an outer key with\n       its corresponding inner map.  Using a helper map allows us\n       to rebuild the vector if we ever need it sorted by the outer key. */\n    std::vector<std::map<std::string, std::map<std::string, long>>> result;\n    std::map<std::string, std::map<std::string, long>> tmp;\n\n    for (std::size_t i = 0; i < l1.size(); ++i) {\n        /* Insert the inner mapping into the corresponding outer map. */\n        tmp[l1[i]][l2[i]] = l3[i];\n    }\n\n    /* Move the temporary map into the result vector. */\n    result.emplace_back(std::move(tmp));\n\n    return result;\n}\n\n/* --------------------------------------------------------------------- */\n/* Example usage / test ------------------------------------------------- */\nint main()\n{\n    std::vector<std::string> l1 = {\"USA\", \"USA\", \"UK\"};\n    std::vector<std::string> l2 = {\"New York\", \"Boston\", \"London\"};\n    std::vector<long>        l3 = {1200, 800, 500};\n\n    auto nested = convert_list_dictionary(l1, l2, l3);\n\n    /* Print the result to verify it looks as expected. */\n    int outerIndex = 0;\n    for (const auto &outerMap : nested) {\n        std::cout << \"Outer map #\" << outerIndex++ << \":\\n\";\n        for (const auto &innerPair : outerMap) {\n            std::cout << \"  \" << innerPair.first << \" : {\";\n            bool first = true;\n            for (const auto &pr : innerPair.second) {\n                if (!first) std::cout << \", \";\n                std::cout << pr.first << \" => \" << pr.second;\n                first = false;\n            }\n            std::cout << \"}\\n\";\n        }\n    }\n\n    return 0;\n}\n```\n\n### What changed / why this is a good solution\n\n| Feature | Description |\n|---------|-------------|\n| **Const\u2011referenced arguments** | Avoid unnecessary copies of the input vectors. |\n| **`assert`** | Quick sanity check for equal vector lengths during development. |\n| **`tmp` map** | Builds all inner maps first, then moves them into the vector. |\n| **`emplace_back` with `std::move(tmp)`** | Avoids an extra copy. |\n| **Return type** | `std::vector< std::map<...> >` exactly matches your specification. |\n| **Full example** | Shows how to use the function and prints a readable output. |\n\nFeel free to adapt this function to return other container types or\nto handle more complex key/value types."]}
{"completions": ["Below is a small, self\u2011contained implementation of `interleave_lists`.  \nThe function assumes that the three input vectors have the same length; an `assert` is used to document that assumption.  \nThe function does **not** modify the input vectors \u2013 it works on copies that are passed by value in the signature you posted \u2013 but if you prefer references you can easily change the signature.\n\n```cpp\n#include <cassert>\n#include <vector>\n\n/**\n * Interleave three vectors of the same size.\n *\n * Example:\n *   list1 = {1,4,7}\n *   list2 = {2,5,8}\n *   list3 = {3,6,9}\n *\n *   result = {1,2,3,4,5,6,7,8,9}\n *\n * @param list1 the first vector\n * @param list2 the second vector\n * @param list3 the third vector\n * @return a vector containing all elements in interleaved order\n */\nstd::vector<long> interleave_lists(std::vector<long> list1,\n                                   std::vector<long> list2,\n                                   std::vector<long> list3)\n{\n    // All three vectors must have the same size.\n    assert(list1.size() == list2.size() && list2.size() == list3.size());\n\n    const size_t n = list1.size();           // number of \u201ctriplets\u201d\n    std::vector<long> result;\n    result.reserve(3 * n);                    // avoid reallocations\n\n    for (size_t i = 0; i < n; ++i)\n    {\n        result.push_back(list1[i]);\n        result.push_back(list2[i]);\n        result.push_back(list3[i]);\n    }\n\n    return result;\n}\n```\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<long> a = {1, 4, 7};\n    std::vector<long> b = {2, 5, 8};\n    std::vector<long> c = {3, 6, 9};\n\n    auto interleaved = interleave_lists(a, b, c);\n\n    for (auto v : interleaved) std::cout << v << ' ';\n    // Output: 1 2 3 4 5 6 7 8 9\n}\n```\n\n**Why the assert is useful**\n\n- If the caller accidentally passes vectors of unequal length, the program will abort immediately with an informative diagnostic (when built with assertions enabled).\n- In production builds where `NDEBUG` is defined, the assert is removed, so there is no runtime cost.\n\nFeel free to adjust the function signature to use `const std::vector<long>&` if you want the function to accept larger lists more efficiently.", "Here\u2019s a complete, self\u2011contained implementation in C++:\n\n```cpp\n#include <vector>\n#include <cassert>\n\n/*  interleave_lists\n *  ----------------\n *  Takes three vectors of equal length (j\u2011equal length) and returns a new\n *  vector that contains elements from the three input vectors in an\n *  interleaved fashion:\n *\n *      result = { a0, b0, c0, a1, b1, c1, \u2026 }\n *\n *  The function performs a sanity check on the sizes of the input vectors\n *  and throws an `std::invalid_argument` if they differ.  It also makes a\n *  copy of the input vectors, so the caller can keep the originals unchanged.\n */\nstd::vector<long> interleave_lists(const std::vector<long>& a,\n                                   const std::vector<long>& b,\n                                   const std::vector<long>& c)\n{\n    // all three lists must have the same length\n    if (a.size() != b.size() || a.size() != c.size()) {\n        throw std::invalid_argument(\"All input lists must have the same length\");\n    }\n\n    size_t n = a.size();\n    std::vector<long> result;\n    result.reserve(3 * n);          // pre\u2011allocate to avoid reallocations\n\n    for (size_t i = 0; i < n; ++i) {\n        result.push_back(a[i]);\n        result.push_back(b[i]);\n        result.push_back(c[i]);\n    }\n    return result;\n}\n\n/*  Quick test\n *  ----------\n *  You can run this code to confirm that the implementation works as expected.\n */\n#ifdef UNIT_TEST\n#include <iostream>\nint main()\n{\n    std::vector<long> l1{1, 2, 3};\n    std::vector<long> l2{4, 5, 6};\n    std::vector<long> l3{7, 8, 9};\n\n    auto flat = interleave_lists(l1, l2, l3);\n\n    for (long v : flat) std::cout << v << ' ';\n    std::cout << '\\n';\n\n    // Expected output: 1 4 7 2 5 8 3 6 9\n    return 0;\n}\n#endif\n```\n\n### How it works\n\n1. **Input Validation** \u2013 The function verifies that all three input vectors have the same length; otherwise, it throws an exception.\n2. **Reserve Capacity** \u2013 `result.reserve(3 * n)` pre\u2011allocates space for `3 * n` elements, ensuring that push\u2011backs don\u2019t trigger multiple reallocations.\n3. **Interleaving Loop** \u2013 We iterate from `0` to `n\u20111` and push the corresponding elements from each list into `result`.  \n   This yields the required `{a0,b0,c0,a1,b1,c1,\u2026}` pattern.\n4. **Return** \u2013 The fully filled `result` vector is returned.\n\nFeel free to drop this snippet into your project and remove the `#ifdef UNIT_TEST` section if you\u2019re not running the quick test.", "Here is a straightforward implementation that takes three `std::vector<long>` of equal length, interleaves them element\u2011by\u2011element, and returns the resulting flat vector.\n\n```cpp\n#include <vector>\n#include <cassert>\n\n// Interleave 3 vectors of the same length into a single flat vector.\n// The function assumes the three input vectors have identical sizes.\nstd::vector<long> interleave_lists(std::vector<long> list1,\n                                   std::vector<long> list2,\n                                   std::vector<long> list3)\n{\n    // Quick sanity check \u2013 remove or replace with your own error handling policy\n    assert(list1.size() == list2.size() && list2.size() == list3.size());\n\n    size_t n = list1.size();          // number of elements in each input vector\n    std::vector<long> result;\n    result.reserve(3 * n);            // pre\u2011allocate for efficiency\n\n    for (size_t i = 0; i < n; ++i) {\n        result.push_back(list1[i]);\n        result.push_back(list2[i]);\n        result.push_back(list3[i]);\n    }\n\n    return result;\n}\n```\n\n### How it works\n\n1. **Assertion** \u2013 The `assert` guarantees that the three vectors are the same length.  \n   If you want to handle mismatched sizes in a different way, replace this with proper error handling.\n\n2. **Reserve space** \u2013 `result.reserve(3 * n)` pre\u2011allocates memory for the output, which keeps the pushing efficient.\n\n3. **Interleaving loop** \u2013 The loop runs from `0` to `n-1` and pushes the `i`\u2011th element from each list into the result in the order `list1[i]`, `list2[i]`, `list3[i]`.\n\n4. **Return** \u2013 The fully interleaved vector is returned.\n\nYou can call it like this:\n\n```cpp\nstd::vector<long> a = {1, 2, 3};\nstd::vector<long> b = {4, 5, 6};\nstd::vector<long> c = {7, 8, 9};\n\nauto flat = interleave_lists(a, b, c);  // {1,4,7,2,5,8,3,6,9}\n```\n\nFeel free to adjust the error handling or parameter passing (e.g., by using `const std::vector<long>&`) as needed for your project."]}
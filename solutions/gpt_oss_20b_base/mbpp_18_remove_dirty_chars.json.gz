{"completions": ["Here\u2019s a straightforward implementation that removes every character from the first string that appears in the second string.  \n```cpp\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\n/*  remove_dirty_chars\n    ----------------\n    Return a new string that is `s` with all characters that appear in `bad`\n    removed.\n\n    Parameters\n        s      \u2013 the original (clean) string  \n        bad    \u2013 any character that should be filtered out\n\n    Complexity\n        O(n)   where n is the length of `s`.  \n        The lookup cost for each character is O(1) on average because we use\n        an unordered_set.\n\n    Example\n        remove_dirty_chars(\"hello world\", \"lod\")   -->  \"he wr\"\n*/\nstd::string remove_dirty_chars(const std::string& s,\n                               const std::string& bad)\n{\n    // 1) Build a hash set of the characters that must be removed\n    std::unordered_set<char> to_remove;\n    to_remove.reserve(bad.size() * 2);          // a little extra space\n    for(char c : bad) to_remove.insert(c);\n\n    // 2) Copy only the characters that are *not* in the set\n    std::string result;\n    result.reserve(s.size());                  // avoid reallocations\n\n    for(char c : s)\n    {\n        if(to_remove.find(c) == to_remove.end())\n            result.push_back(c);\n    }\n\n    return result;\n}\n```\n\n### Why this works\n\n1. **Fast look\u2011up** \u2013 an `unordered_set` gives average\u2011case O(1) lookup time for each character, so deciding whether to keep a character is inexpensive.\n2. **Preserves order** \u2013 the result is built by iterating through `s` once, keeping the relative order of the remaining characters.\n3. **No side\u2011effects** \u2013 the original string `s` is not modified; a new string is returned.\n\nFeel free to adapt the function if you need case\u2011insensitive removal, Unicode support, or in\u2011place modification.", "Here\u2019s a compact, yet fully\u2011featured implementation that removes every character from the first string that occurs in the second string.  \nIt works with `std::string` (i.e., 8\u2011bit characters, including extended UTF\u20118 characters) and is O(*n* + *m*) time, O(\u03c3) additional memory (\u03c3=alphabet size).\n\n```cpp\n#include <algorithm>\n#include <string>\n#include <unordered_set>\n\n/**\n * Remove all characters from `input` that appear in `remove`.\n *\n * @param input   String to be cleaned.\n * @param remove  String containing the set of characters to be removed.\n * @return        New string containing only characters from `input` that are\n *                not present in `remove`.\n */\nstd::string remove_dirty_chars(const std::string& input,\n                               const std::string& remove)\n{\n    // Build a hash set of all characters that must be removed.\n    std::unordered_set<char> to_remove(remove.begin(), remove.end());\n\n    // Reserve space for the output; worst case is the entire input.\n    std::string result;\n    result.reserve(input.size());\n\n    // Copy only characters that are *not* in the hash set.\n    std::copy_if(input.begin(), input.end(),\n                 std::back_inserter(result),\n                 [&](char c) { return to_remove.find(c) == to_remove.end(); });\n\n    return result;\n}\n```\n\n### Why this implementation?\n\n| Feature | Explanation |\n|---------|-------------|\n| **Linear complexity** | We scan each input string once \u2013 `O(n + m)` time. |\n| **Small memory overhead** | Only an `unordered_set` of unique characters from `remove` (\u2264 256 for 8\u2011bit chars) plus the output string. |\n| **Simple API** | Takes `const std::string&` to avoid unnecessary copies and returns a new string. |\n| **Readable** | Uses standard `<algorithm>` (`copy_if`) for clarity. |\n\nIf you ever need to handle Unicode code points instead of single bytes, replace the `char` based set with `std::unordered_set<std::u32string>` or use a proper Unicode library.", "Here is a complete, self\u2011contained implementation of the `remove_dirty_chars` function.  \nIt removes **every** character that appears in `second_string` from `string`.  \nThe implementation uses an `unordered_set` for O(1) look\u2011ups and is written in a\nclear, idiomatic C++17 style.\n\n```cpp\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\n/*  Removes all characters of `second_string` from `string`. */\nstd::string remove_dirty_chars(std::string string, const std::string& second_string)\n{\n    // Build a set of all characters that must be removed.\n    std::unordered_set<char> to_remove;\n    to_remove.reserve(second_string.size() * 2);   // optional performance hint\n    for (char c : second_string)\n        to_remove.emplace(c);\n\n    // Copy only the characters that are not in the set into a new string.\n    std::string result;\n    result.reserve(string.size());   // reserve in advance to avoid reallocations\n\n    for (char c : string)\n        if (to_remove.find(c) == to_remove.end())\n            result.push_back(c);\n\n    return result;\n}\n```\n\n### How it works\n\n1. **Create a lookup set** \u2013 Every character from `second_string` is inserted into an\n   `unordered_set<char>`. This lets us decide in O(1) time whether a character\n   should be discarded.\n\n2. **Filter the first string** \u2013 Iterate over the input string, appending to the\n   result only those characters that do *not* appear in the set.\n\n3. **Return the cleaned string** \u2013 The function returns a new string with all \u201cdirty\u201d\n   characters removed.\n\n### Example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::string a = \"hello, world!\";\n    std::string b = \"lo\";\n\n    std::string cleaned = remove_dirty_chars(a, b);\n    std::cout << cleaned;  // prints \"he, wrd!\"\n}\n```\n\nThis implementation is efficient and works for all character values (including\npotentially non\u2011ASCII ones, as it operates on `char`). Feel free to adjust the\nreserve sizes or replacing `unordered_set` with a `std::array<bool, 256>` if you\nknow the character set is a small fixed range."]}
{"completions": ["```cpp\n#include <tuple>\n#include <cmath>\n\nstd::tuple<long, long> even_odd_count(long num) {\n    // work with the absolute value to ignore the sign\n    num = std::llabs(num);\n\n    long even = 0, odd = 0;\n\n    // Edge\u2011case: 0 is an even digit\n    if (num == 0) {\n        even = 1;\n    } else {\n        while (num > 0) {\n            int digit = num % 10;\n            if (digit % 2 == 0)\n                ++even;\n            else\n                ++odd;\n            num /= 10;\n        }\n    }\n    return std::make_tuple(even, odd);\n}\n```\n\nThe function:\n\n1. Uses `std::llabs` to ignore any leading sign.\n2. Handles the special case when `num` is `0` (it has one even digit).\n3. Iteratively extracts each decimal digit and classifies it as even or odd.\n4. Returns the counts in a `std::tuple<long, long>`.", "Here is a ready\u2011to\u2011copy implementation that follows the specification and the conventions shown in the examples:\n\n```cpp\n#include <tuple>\n#include <cstdint>   // for std::int64_t (optional)\n#include <algorithm> // for std::abs, if you prefer\n\n// Count the number of even and odd digits in a decimal integer.\n// The sign of *num* is ignored \u2013 only the magnitude matters.\n// Example:\n//   even_odd_count(-12)  -> std::make_tuple(1, 1)\n//   even_odd_count( 123) -> std::make_tuple(1, 2)\n//\n// Note: by definition 0 is an even digit, so the number 0 yields\n//        (1, 0).\nstd::tuple<long, long> even_odd_count(long num)\n{\n    // Take absolute value so that negative numbers are handled.\n    long n = std::abs(num);\n\n    // Special case: 0 has one digit \u2013 '0' \u2013 which is even.\n    if (n == 0)\n        return std::make_tuple(1, 0);\n\n    long even_cnt = 0, odd_cnt = 0;\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 == 0)\n            ++even_cnt;\n        else\n            ++odd_cnt;\n        n /= 10;\n    }\n    return std::make_tuple(even_cnt, odd_cnt);\n}\n```\n\n### How it works\n\n1. **Absolute value** \u2013 `std::abs` removes any negative sign; only the digits matter.\n2. **Zero handling** \u2013 If the input is `0`, it is counted as one even digit right away.\n3. **Digit extraction** \u2013 The loop extracts the last decimal digit (`n % 10`) and tests whether it is even or odd.\n4. **Counting** \u2013 It increments the appropriate counter.\n5. **Return** \u2013 The pair `(even_count, odd_count)` is returned as a `std::tuple`.\n\nYou can drop the `#include <algorithm>` if you prefer to write your own absolute\u2011value logic or use `std::abs` from `<cstdlib>`. The function is fully compliant with the C++17 standard and will compile with any modern compiler.", "Here is a simple implementation that works for any signed `long` (including negative numbers and zero).  \nThe function counts how many decimal digits are even and how many are odd and returns a tuple `(even_cnt, odd_cnt)`.\n\n```cpp\n#include <tuple>\n#include <cstddef>\n#include <cmath>\n\nstd::tuple<long, long> even_odd_count(long num)\n{\n    // We'll work with the absolute value so that the sign doesn't\n    // affect the number of digits.\n    long abs_val = std::llabs(num);          // std::llabs for long\n    long even_cnt = 0;\n    long odd_cnt  = 0;\n\n    // Special case: 0 has one digit, and it is even.\n    if (abs_val == 0) {\n        even_cnt = 1;\n        return std::make_tuple(even_cnt, odd_cnt);\n    }\n\n    while (abs_val > 0) {\n        int digit = static_cast<int>(abs_val % 10);\n        if (digit % 2 == 0)\n            ++even_cnt;\n        else\n            ++odd_cnt;\n        abs_val /= 10;\n    }\n\n    return std::make_tuple(even_cnt, odd_cnt);\n}\n```\n\n### How it works\n\n1. **Absolute value** \u2013 `std::llabs` (or `std::abs` for `long`) removes the sign so that negative numbers are treated just like positive ones.\n2. **Zero case** \u2013 `0` is a single digit and is even, so we handle it explicitly.\n3. **Digit extraction** \u2013 In each loop iteration we obtain the last decimal digit with `num % 10`, classify it as even or odd, then discard it with `num /= 10`.\n4. **Return** \u2013 The counts are packaged into a `std::tuple<long,long>`, matching the requested signature.\n\nYou can now call `even_odd_count(-12)` or `even_odd_count(123)` and get the same results as in your examples."]}
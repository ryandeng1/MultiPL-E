{"completions": ["**Solution Explanation**\n\nWe are given a 2\u2011D array `M` (represented as `std::vector<std::vector<long>>`).  \nFor every row we compute the sum of its elements, sort all rows by this sum in **ascending** order and finally return a new matrix that contains the rows in that order.\n\nBecause the input matrix can be modified in place, we could sort the matrix directly, but the problem statement specifically asks for a function that *returns* a sorted matrix, so we create a new one.\n\n--------------------------------------------------------------------\n\n#### Algorithm\n```\nfunction sort_matrix(M):\n    if M is empty: return empty matrix\n\n    n = number of rows   (M.size())\n    m = number of columns (M[0].size())   # matrix is rectangular\n\n    Create vector<RowInfo> rows\n    for i from 0 to n-1:\n        sum = 0\n        for each element x in M[i]:\n            sum += x\n        rows.push_back( {sum, i} )   // keep original index\n\n    sort rows by the sum field (ascending)\n\n    Create answer matrix ans of the same shape as M\n    for k from 0 to n-1:\n        ans[k] = M[ rows[k].index ]\n\n    return ans\n```\n\n`RowInfo` is a small struct used only for sorting.\n\n--------------------------------------------------------------------\n\n#### Correctness Proof\n\nWe prove that the algorithm returns a matrix whose rows are sorted in ascending order of row sums and that no row is lost or duplicated.\n\n*Lemma 1*  \nAfter the first loop, for every `i` (`0 \u2264 i < n`) `rows[i]` stores the sum of row `i` of `M` and the original index `i`.\n\n*Proof.*  \nThe loop iterates over all indices `i`. In each iteration it initializes `sum` to zero and adds every element of `M[i]` to `sum`. Therefore, after the inner loop `sum` equals exactly the sum of that row.  \nThe pair `(sum, i)` is appended to `rows`. Thus the lemma holds. \u220e\n\n*Lemma 2*  \nAfter sorting `rows`, the sequence of `sum` values in `rows` is non\u2011decreasing.\n\n*Proof.*  \n`std::sort` arranges the elements according to the comparison function `operator<` defined for `RowInfo`. This comparison checks only the `sum` field, thus ordering the vector by the sums. Therefore the resulting sequence of sums is sorted in non\u2011decreasing order. \u220e\n\n*Lemma 3*  \nThe resulting matrix `ans` contains each original row of `M` exactly once.\n\n*Proof.*  \nDuring construction of `ans`, we iterate `k` from `0` to `n-1` and copy `M[rows[k].index]` into `ans[k]`.  \nBy Lemma&nbsp;1, every `rows[k].index` is an index of a row of `M`.  \nBecause the indices are unique in `rows` (each original row produces one entry), each original row appears exactly once in the new matrix. Additionally, the number of rows of `ans` equals `n`, which is the number of rows in `M`. \u220e\n\n*Theorem*  \n`ans` returned by `sort_matrix` is a matrix whose rows are sorted in ascending order according to the sum of their elements.\n\n*Proof.*  \nFrom Lemma&nbsp;3, `ans` contains the same set of rows as `M`.  \nFrom Lemma&nbsp;2, the sequence of sums corresponding to these rows (ordered by the indices in `rows`) is non\u2011decreasing.  \nThus `ans` is a permutation of `M` sorted by row sums in ascending order. \u220e\n\n--------------------------------------------------------------------\n\n#### Complexity Analysis\n\nLet `R` be the number of rows and `C` the number of columns.\n\n* Summing all rows: `O(R*C)`\n* Sorting `R` pairs: `O(R log R)`\n* Copying the rows to the answer: `O(R*C)`\n\nTotal time: `O(R*C + R log R)`  \nExtra space: a vector of `R` pairs and the answer matrix \u2192 `O(R*C)` (the answer itself can be considered part of the required output).\n\n--------------------------------------------------------------------\n\n#### Reference Implementation (C++17)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct RowInfo {\n    long long sum;   // use long long for safety\n    size_t index;    // original row index\n\n    bool operator<(const RowInfo& other) const {\n        return sum < other.sum;          // ascending order\n    }\n};\n\n/**\n * Sorts a matrix in ascending order with respect to the sum of each row.\n *\n * @param M The input matrix (vector of vectors).\n * @return  A new matrix with rows sorted by ascending row sum.\n */\nvector<vector<long>> sort_matrix(vector<vector<long>> M) {\n    if (M.empty() || M[0].empty()) return {};\n\n    const size_t R = M.size();\n\n    // Compute sums and store original indices\n    vector<RowInfo> rows;\n    rows.reserve(R);\n    for (size_t r = 0; r < R; ++r) {\n        long long s = 0;\n        for (auto x : M[r]) s += x;\n        rows.push_back({s, r});\n    }\n\n    // Sort by sum\n    sort(rows.begin(), rows.end());\n\n    // Build answer matrix\n    vector<vector<long>> ans(R);\n    for (size_t k = 0; k < R; ++k) {\n        ans[k] = std::move(M[rows[k].index]);   // copy or move if desired\n    }\n\n    return ans;\n}\n```\n\nThe implementation follows exactly the algorithm proven correct above and compiles under a conforming C++17 compiler.", "Sure!  \nBelow is a complete, self\u2011contained implementation that\n\n1. **Computes the sum of each row**.  \n2. **Sorts the matrix rows** in **ascending order** according to those sums.  \n3. Returns the sorted matrix.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n//---------------------------------------------------------------------\n// Function: sort_matrix\n//   Sorts a 2\u2011D vector (matrix) of type long in ascending order based\n//   on the sum of each row.\n//\n// Parameters\n//   M   : The matrix to be sorted.  It can have any number of rows\n//         and columns (including zero rows or columns).\n//\n// Returns\n//   A new matrix containing the same rows as `M`, but reordered such that\n//   row with the smallest sum comes first, next smallest second, etc.\n//---------------------------------------------------------------------\nvector<vector<long>> sort_matrix(vector<vector<long>> M)\n{\n    // Helper lambda to compute the sum of a row\n    auto row_sum = [](const vector<long>& row) -> long\n    {\n        long s = 0;\n        for (long v : row) s += v;\n        return s;\n    };\n\n    // Sort using a custom comparator that compares the sums of the rows\n    sort(M.begin(), M.end(),\n        [&](const vector<long>& a, const vector<long>& b)\n        {\n            return row_sum(a) < row_sum(b);\n        });\n\n    return M;\n}\n\n//---------------------------------------------------------------------\n// Optional: Small test harness\n//---------------------------------------------------------------------\n#ifdef UNIT_TEST\nint main()\n{\n    vector<vector<long>> mat = {\n        {3, 5, 1},\n        {0, 2},\n        {4, 4, 4}\n    };\n\n    auto sorted = sort_matrix(mat);\n\n    for(const auto& r : sorted){\n        for(long v : r) cout << v << ' ';\n        cout << '\\n';\n    }\n}\n#endif\n```\n\n### How it works\n* **`row_sum`**: A quick helper that iterates over a row and returns the total.\n* **`sort`**: We pass a lambda comparator to `std::sort`.  \n  The comparator takes two rows `a` and `b` and returns `true` if the sum of\n  `a` is smaller than the sum of `b`, which makes the sorting ascending.\n* The function returns the sorted matrix; the original matrix passed as an\n  argument is also sorted in\u2011place (because it\u2019s passed by value, making a\n  copy). If you prefer to sort the input matrix directly, just call\n  `std::sort` on the reference instead of returning a copy.\n\nFeel free to remove the `#ifdef UNIT_TEST` block or replace it with your own\ntests. Happy coding!", "Below is a clean\u2011C++ version that does exactly what you asked for:\n\n```cpp\n#include <vector>\n#include <numeric>   // std::__sum\n#include <algorithm> // std::sort\n\n/**\n * Sorts the rows of a matrix in ascending order of the row sum.\n *\n * @param M  The matrix to be sorted (passed by value so the caller\n *          receives an unchanged original matrix).\n * @return   A new matrix containing the same rows but reordered\n *          so that the row sums are non\u2011decreasing.\n *\n * Example\n * -------\n *  input  M =\n *     { { 3, 1, 2 },\n *       { 5, 4, 0 },\n *       { 1, 1, 1 } }\n *\n *  row sums  = { 6, 9, 3 }\n *  sorted rows = { {1,1,1}, {3,1,2}, {5,4,0} }\n */\nstd::vector<std::vector<long>> sort_matrix(std::vector<std::vector<long>> M)\n{\n    // Helper to compute the sum of a row.\n    auto row_sum = [](const std::vector<long>& row) -> long {\n        return std::accumulate(row.begin(), row.end(), 0L);\n    };\n\n    // Sort in place using the row sum as the key.\n    std::sort(M.begin(), M.end(),\n              [&](const std::vector<long>& a,\n                  const std::vector<long>& b) {\n                  return row_sum(a) < row_sum(b);\n              });\n\n    return M;              // return the sorted matrix\n}\n```\n\n### Why this works\n\n* **`std::accumulate`** runs in linear time on the row size, which is all we need to know the sum.\n* **`std::sort`** is a well\u2011tested, efficient routine (Timsort on GCC/Clang, introsort elsewhere) that runs in *O(n log n)* where *n* is the number of rows.\n* The comparator is a lambda that captures nothing but uses the helper `row_sum`, so it\u2019s clean and self\u2011contained.\n\n### Usage\n\n```cpp\nint main()\n{\n    std::vector<std::vector<long>> mat = {\n        {3, 1, 2},\n        {5, 4, 0},\n        {1, 1, 1}\n    };\n\n    auto sorted = sort_matrix(mat);\n\n    for (const auto& row : sorted) {\n        for (long v : row) std::cout << v << ' ';\n        std::cout << '\\n';\n    }\n}\n```\n\nOutput\n\n```\n1 1 1 \n3 1 2 \n5 4 0 \n```\n\nFeel free to tweak the implementation (e.g., make it stable by adding a secondary key, or handle empty matrices) \u2013 the core idea stays the same."]}
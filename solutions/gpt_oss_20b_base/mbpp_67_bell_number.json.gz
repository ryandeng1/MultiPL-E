{"completions": ["Here is a concise, fully\u2011self\u2011contained implementation of the Bell number computation that you can drop into your source file.  \nIt uses the standard recurrence\n\n\\[\nB_{n+1}=\\sum_{k=0}^{n}\\binom{n}{k}\\,B_k\n\\]\n\nwith \\(B_0 = 1\\).  A simple 1\u2011D dynamic array is sufficient and the result is\nreturned as a 64\u2011bit integer.  (If you need larger numbers, replace the type\nwith `unsigned __int128` or a big\u2011integer library.)\n\n```cpp\n#include <cassert>\n#include <vector>\n#include <numeric>   // for std::iota\n#include <bits/stdc++.h> // (you already included this in your file)\n\n// -----------------------------------------------------------------------\n// Computes the n\u2011th Bell number (0\u2011based index) as a 64\u2011bit unsigned integer.\n// Assumes that the result fits in unsigned long long; for larger n, use\n// a big\u2011integer type instead.\nunsigned long long bell_number(long n)\n{\n    if (n < 0) throw std::invalid_argument(\"n must be non\u2011negative\");\n\n    // Fast path for very small n\n    if (n == 0) return 1ull;        // B0 = 1\n    if (n == 1) return 1ull;        // B1 = 1\n    if (n == 2) return 2ull;        // B2 = 2\n    if (n == 3) return 5ull;        // B3 = 5\n\n    // Use the recurrence B_{m+1} = sum_{k=0}^{m} C(m, k) * B_k\n    // We keep the array B[0..n] in increasing order.\n    std::vector<unsigned long long> B(n + 1, 0);\n    B[0] = 1ull;   // B0\n\n    // pre\u2011compute binomial coefficients using Pascal\u2019s triangle\n    std::vector<std::vector<unsigned long long>> C(n + 1,\n                                                   std::vector<unsigned long long>(n + 1, 0));\n    for (long i = 0; i <= n; ++i) {\n        C[i][0] = C[i][i] = 1ull;\n        for (long j = 1; j < i; ++j) {\n            // Check for overflow: if the sum exceeds ULLONG_MAX, abort\n            unsigned long long val = C[i-1][j-1] + C[i-1][j];\n            if (val < C[i-1][j-1] || val < C[i-1][j]) {\n                throw std::overflow_error(\"binomial coefficient overflow\");\n            }\n            C[i][j] = val;\n        }\n    }\n\n    for (long m = 1; m <= n; ++m) {\n        unsigned __int128 sum = 0;    // use larger type to accumulate safely\n        for (long k = 0; k < m; ++k) {\n            sum += (unsigned __int128)C[m-1][k] * B[k];\n            if (sum > std::numeric_limits<unsigned long long>::max())\n                throw std::overflow_error(\"Bell number overflow\");\n        }\n        B[m] = static_cast<unsigned long long>(sum);\n    }\n\n    return B[n];\n}\n// -----------------------------------------------------------------------\n```\n\n### How it works\n\n1. **Base cases** \u2013 The Bell numbers for the first few indices are hard\u2011coded to keep the routine fast for the most common inputs.\n2. **Binomial table** \u2013 `C[i][j]` holds \\(\\binom{i}{j}\\).  It is constructed once with Pascal's triangle; we also perform an overflow check during construction.\n3. **Dynamic programming** \u2013 For each `m` from\u202f1 up to\u202f`n`, we compute  \n   \\(B_m = \\sum_{k=0}^{m-1} \\binom{m-1}{k} B_k\\).  \n   The summation uses an `unsigned __int128` accumulator (`sum`) to avoid intermediate overflow, then casts the final value to `unsigned long long`.\n4. **Overflow handling** \u2013 If any intermediate value would exceed `ULLONG_MAX`, the function throws `std::overflow_error`.  Replace the error handling with whatever policy you prefer.\n\nThis routine runs in \\(O(n^2)\\) time and \\(O(n^2)\\) space for the binomial table, which is fine for typical `n` (e.g., up to a few thousand on modern hardware).  For much larger `n`, a more memory\u2011efficient binomial computation (or the Stirling\u2011number\u2011based formula) would be advisable.", "Below is a compact, ready\u2011to\u2011compile implementation that returns the *n*\u2011th Bell number (the number of ways to partition a set of *n* labelled elements).  \nThe implementation uses **boost::multiprecision::cpp_int** so it can handle arbitrarily large results \u2013 an exact integer representation is required because Bell numbers grow very quickly (e.g.\u202fB\u2083\u2080 \u2248\u202f6\u202f\u00d7\u202f10\u00b9\u2078).\n\n```cpp\n#include <bits/stdc++.h>\n#include <boost/multiprecision/cpp_int.hpp>\n\nusing namespace std;\nusing boost::multiprecision::cpp_int;\n\n//------------------------------------------------------------------------------\n// Returns the nth Bell number B(n)\n// B(0) = 1, B(1) = 1, B(2) = 2, B(3) = 5, ...\n//------------------------------------------------------------------------------\n\ncpp_int bell_number(long n)\n{\n    if (n < 0) {\n        throw std::invalid_argument(\"n must be non\u2011negative\");\n    }\n\n    // Bell triangle (sometimes called Aitken's array).\n    // Each row i contains the i+1\u2011terms of the triangle.\n    // The first element of each row is the previous row\u2019s last element.\n    vector< cpp_int > row(1, 1);            // row 0: [1]\n    if (n == 0) return cpp_int(1);\n\n    for (long i = 1; i <= n; ++i) {\n        vector< cpp_int > new_row(i + 1);\n        new_row[0] = row.back();           // first element of new row\n\n        for (long j = 1; j <= i; ++j) {\n            // Aitken's rule: new_row[j] = new_row[j-1] + row[j-1]\n            new_row[j] = new_row[j-1] + row[j-1];\n        }\n\n        row.swap(new_row);                 // prepare for next iteration\n    }\n\n    // The first element of the last row is B(n)\n    return row[0];\n}\n\n//------------------------------------------------------------------------------\n// Simple test harness (optional)\n//------------------------------------------------------------------------------\n\nint main()\n{\n    for (int n = 0; n <= 20; ++n) {\n        cout << \"B(\" << n << \") = \" << bell_number(n) << '\\n';\n    }\n    return 0;\n}\n```\n\n### How the algorithm works\n\n1. **Bell Triangle** (Aitken's array)  \n   * Row\u202f0: `[1]`  \n   * For each `i \u2265 1`  \n     * The first element of the new row equals the last element of the previous row.  \n     * All other elements are built by adding the previous element of the current row to the element above it (`row[j\u20111]`).\n\n2. After generating rows up to `n`, the first element of the latest row is the desired Bell number `B(n)`.\n\n### Complexity\n\n*Time*\u2003`O(n\u00b2)` \u2013 each of the `n` rows contains up to `n` elements.  \n*Memory*\u2003`O(n)` \u2013 only the current row is kept in memory.\n\nThe solution is fully compliant with modern C++ (C++14\u201120) and relies only on the standard library plus the Boost Multiprecision header (`<boost/multiprecision/cpp_int.hpp>`), which is header\u2011only and typically shipped with most compiler distributions.", "Below is a short, self\u2011contained illustration of how you can compute the **Bell numbers**\u202f\u2013 the number of ways to partition an _n_\u2011element set \u2013 together with a tiny helper to return the answer as a 64\u2011bit integer.  \n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*-------------------------------------------------------------\n   Bell number B(n) \u2013 number of partitions of an n\u2011element set.\n   A very compact recurrence (Dobinski\u2019s formula, or\n   the \u201cBell triangle\u201d recurrence) is used.\n   For n\u202f\u2264\u202f51 the value fits into a signed 64\u2011bit integer,\n   which is enough for most competitive\u2011programming tasks.\n-------------------------------------------------------------*/\n\nlong long bell_number(long long n) {\n    if (n < 0) return 0;                // guard against negative input\n    if (n == 0) return 1;                // B0 = 1\n\n    // Bell triangle: each row starts with the last element of the previous row\n    vector<long long> row(n + 1, 0);\n    row[0] = 1;                          // triangle first element\n\n    for (long long i = 1; i <= n; ++i) {\n        row[0] = row[i-1];               // first element of new row\n        for (long long j = 1; j <= i; ++j) {\n            row[j] = row[j-1] + row[j];  // triangle recurrence\n        }\n    }\n    return row[n];                       // top\u2011right element is B(n)\n}\n\n/*-------------------------------------------------------------\n   Example usage (simple test harness).\n-------------------------------------------------------------*/\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    long long n;\n    if (!(cin >> n)) return 0;   // read a single integer from stdin\n    cout << bell_number(n) << '\\n';\n    return 0;\n}\n```\n\n### How it works\n\n* **Bell triangle (Aitken array)**  \n  ```\n  row0: 1\n  row1: 1  2\n  row2: 2  3  5\n  row3: 5  7 12 17\n  ...\n  ```\n\n  *Each row starts with the last value of the previous row.*  \n  The recurrence `row[j] = row[j-1] + row[j]` guarantees that after finishing\n  row\u202f`i`, `row[i]` holds the value `B(i)`.\n\n* The algorithm runs in \\(O(n^2)\\) time and \\(O(n)\\) memory \u2013 perfectly fine\n  for `n` up to a few thousand (the values grow extremely fast).  \n\nFeel free to replace the simple `cin/cout` snippet with whatever test harness\nyou prefer."]}
{"completions": ["Below is a clear, compact implementation that does exactly what you described:  \n* compares the elements of the three input vectors **i\u2011by\u2011i**  \n* pushes the element into the result when all three are equal  \n* returns the result as a `std::vector<std::any>` (so it can hold any type \u2013 here we simply store the `long` values)\n\nFeel free to drop the `any` wrapper if you only need `long`, or change the type you push into the result.  \n\n```cpp\n#include <vector>\n#include <any>\n#include <cassert>\n\n/*\n * Return a vector that contains all elements that are identical\n * in the same position of the three input vectors.\n *\n * Example:\n *   l1 = {1, 2, 3}\n *   l2 = {1, 5, 3}\n *   l3 = {1, 8, 3}\n *   \u2192 {1, 3}\n */\nstd::vector<std::any>\nextract_index_list(const std::vector<long> &l1,\n                   const std::vector<long> &l2,\n                   const std::vector<long> &l3)\n{\n    // The common elements can only be as long as the shortest vector\n    std::size_t minSize = std::min({l1.size(), l2.size(), l3.size()});\n\n    std::vector<std::any> common;\n    common.reserve(minSize);          // reserve the maximum possible size\n\n    for (std::size_t i = 0; i < minSize; ++i)\n    {\n        if (l1[i] == l2[i] && l1[i] == l3[i])\n        {\n            common.emplace_back(l1[i]);   // store the common value\n        }\n    }\n\n    return common;\n}\n```\n\n### Why `std::any`?\n\nThe task statement mentioned returning a `std::vector<std::any>`.  \nIf you only need the function to return `long`s, you can simply return a\n`std::vector<long>` and keep the type\u2011safe approach.  \nUsing `std::any` keeps the function compatible with the specification\nwhile still letting you extract the stored values later with\n`std::any_cast<long>(...)`.", "Below is a small, self\u2011contained implementation that follows the specification you described:\n\n```cpp\n#include <vector>\n#include <any>\n#include <algorithm>\n#include <cassert>\n\n/*\n *  extract_index_list\n *  ------------------\n *  Returns a std::vector<std::any> containing the elements that appear\n *  in all three input vectors **at the same index**.\n *\n *  Rules\n *  -----\n *  *  The size of the result is the length of the shortest of the three\n *     input vectors \u2013 any index that does not exist in one of the vectors\n *     is ignored.\n *  *  Only elements that are equal at the same index in *all* vectors are\n *     collected.  Equality is determined via the `==` operator of `long`.\n *  *  The elements are stored in a `std::any`.  This matches the signature\n *     you gave (`vector<std::any>`).\n *  *  The function does **not** modify the input vectors.\n */\n\nstd::vector<std::any> extract_index_list(const std::vector<long> &l1,\n                                         const std::vector<long> &l2,\n                                         const std::vector<long> &l3)\n{\n    // Determine the shortest length so we don't go out of bounds.\n    const std::size_t min_len = std::min({l1.size(), l2.size(), l3.size()});\n\n    std::vector<std::any> result;\n    result.reserve(min_len);            // optional: avoid reallocations\n\n    for (std::size_t i = 0; i < min_len; ++i)\n    {\n        // compare values at the same index\n        if (l1[i] == l2[i] && l1[i] == l3[i])\n        {\n            // store the common element inside a std::any\n            result.emplace_back(l1[i]);  // any type that is copy\u2011constructible is fine\n        }\n    }\n\n    return result;\n}\n\n/*--------------------------------------------------------------*/\n/*  Quick sanity check \u2013 optional demo/test code                */\n/*--------------------------------------------------------------*/\n\n#ifdef UNIT_TEST_EXTRACT_INDEX_LIST\n#include <iostream>\n\nint main() {\n    std::vector<long> a{1, 2, 3, 4};\n    std::vector<long> b{1, 7, 3, 0};\n    std::vector<long> c{1, 9, 3, 4};\n\n    auto common = extract_index_list(a, b, c);\n\n    std::cout << \"Common elements (at same index): \";\n    for (const auto &v : common) {\n        // we know the stored type is long\n        std::cout << std::any_cast<long>(v) << ' ';\n    }\n    std::cout << '\\n';\n    return 0;\n}\n#endif\n```\n\n### How it works\n\n1. **Compute the shortest length.**  \n   We only need to iterate up to the smallest vector size \u2013 any longer vectors simply have indices beyond that range that can\u2019t be matched.\n\n2. **Loop over the indices.**  \n   For each index `i`, we check if `l1[i] == l2[i] && l1[i] == l3[i]`.  \n   If that\u2019s true, the element is common to all three vectors at that position.\n\n3. **Store in `std::any`.**  \n   The `any` container can hold any copy\u2011constructible type.  \n   In this simple example we know the type is `long`, but using `any` makes the return type flexible (you can easily change the input vectors to hold other types without changing the function\u2019s signature).\n\n4. **Return the result vector.**\n\nCompile with e.g. `g++ -std=c++20 -DUNIT_TEST_EXTRACT_INDEX_LIST file.cpp && ./a.out` to see the demo.", "Here is one possible implementation that follows the idea that a value is *common* when it appears at the **same** index in all three input vectors.  \nThe function iterates only up to the shortest length of the three vectors (so we do not index out of bounds) and pushes the common values into a `std::vector<std::any>` as requested.\n\n```cpp\n#include <vector>\n#include <any>\n#include <algorithm>\n\n/*  extract_index_list\n *\n *  Parameters\n *  ----------\n *  l1, l2, l3 : std::vector<long>\n *      Three input vectors.\n *\n *  Returns\n *  -------\n *  std::vector<std::any>\n *      A vector of the common elements that appear under the same index\n *      in all three vectors.  Each entry is wrapped in std::any because\n *      the function signature demands it.\n *\n *  Notes\n *  -----\n *  The function does *not* merge the vectors or consider duplicates\n *  across different indices \u2013 an element is accepted only if it\n *  occupies the same index in all three lists.\n */\nstd::vector<std::any> extract_index_list(const std::vector<long>& l1,\n                                         const std::vector<long>& l2,\n                                         const std::vector<long>& l3)\n{\n    std::vector<std::any> common;\n\n    // Find the shortest length so we don't read past the end of\n    // any of the vectors.\n    std::size_t n = std::min({l1.size(), l2.size(), l3.size()});\n\n    for (std::size_t i = 0; i < n; ++i)\n    {\n        if (l1[i] == l2[i] && l1[i] == l3[i])\n        {\n            common.emplace_back(l1[i]);   // store the long inside std::any\n        }\n    }\n    return common;\n}\n```\n\n**Why this is worth adding:**\n\n- The function uses `const` references for the parameters to avoid costly copies.\n- It stops at the length of the shortest vector, preventing out\u2011of\u2011bounds access.\n- Each common element is wrapped in `std::any` exactly as the given signature requires.\n- The code follows a clear and concise style, making it easy to understand and maintain."]}
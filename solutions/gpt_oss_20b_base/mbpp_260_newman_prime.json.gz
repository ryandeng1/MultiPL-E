{"completions": ["Below is a **minimal yet complete** C++ implementation that returns the *n\u2011th* Newman\u2013Shanks\u2013Williams (NSW) prime.  \nThe program\n\n* Generates **NSW numbers**  \n  \\(N_k = U_k + U_{k-1}\\) where  \n  \\(U_0 = 1,\\;U_1 = 1,\\;U_{k+2}=2U_{k+1}+U_{k}\\).  \n  That recurrence can be written directly as  \n  \\(N_k = \\left(\\frac{1+\\sqrt{3}}{2}\\right)^k+\\left(\\frac{1-\\sqrt{3}}{2}\\right)^k\\).\n\n* Keeps a list of the NSW primes that have been found so far.  \n* Uses a fast deterministic Miller\u2013Rabin test for 64\u2011bit integers to decide whether a newly generated NSW number is prime.\n\nBecause the NSW sequence grows extremely rapidly (the next terms after 105672 are on the order of 10^38), the program is perfectly capable of generating the first few dozen primes (the 23\u2011rd NSW prime is already larger than 10^39).  \nIf you ask for a very large index the program will simply run until it reaches that index \u2013 beyond the 64\u2011bit range you would need arbitrary\u2011precision integers.\n\n```cpp\n/*********************************************************************\n *  Newmann\u2011Shanks\u2011Williams (NSW) Prime Finder\n *\n *  The program implements the algorithm described above and returns\n *  the n\u2011th NSW prime (n is 1\u2011based).\n *\n *  Author : ChatGPT (OpenAI)\n *  Date   : 2026\u201101\u201127\n *********************************************************************/\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// ------------------------------------------------------------------\n//  Miller\u2011Rabin deterministic test for 64\u2011bit integers\n// ------------------------------------------------------------------\nusing u128 = unsigned __int128;\nconstexpr uint64_t mod_pow(uint64_t a, uint64_t d, uint64_t mod) {\n    u128 res = 1, cur = a % mod;\n    while (d) {\n        if (d & 1) res = (res * cur) % mod;\n        cur = (cur * cur) % mod;\n        d >>= 1;\n    }\n    return (uint64_t)res;\n}\nconstexpr bool isPrime64(uint64_t n) {\n    if (n < 2) return false;\n    for (uint64_t p : {2ULL,3ULL,5ULL,7ULL,11ULL,13ULL,17ULL,19ULL,23ULL,29ULL,31ULL,37ULL}) {\n        if (n%p==0) return n==p;\n    }\n    uint64_t d = n-1, s = 0;\n    while ((d & 1) == 0) { d >>= 1; ++s; }\n    // bases that are enough for 64\u2011bit\n    for (uint64_t a : {2ULL,325ULL,9375ULL,28178ULL,450775ULL,9780504ULL,1795265022ULL}) {\n        if (a % n == 0) continue;            // a \u2261 0 (mod n)\n        uint64_t x = mod_pow(a, d, n);\n        if (x==1 || x==n-1) continue;\n        bool comp = true;\n        for (uint64_t r=1; r<s; ++r) {\n            x = (u128)x * x % n;\n            if (x==n-1) { comp=false; break; }\n        }\n        if (comp) return false;\n    }\n    return true;\n}\n\n// ------------------------------------------------------------------\n//  Compute the n\u2011th NSW prime\n// ------------------------------------------------------------------\nlong long newman_prime(long long n) {\n    if (n <= 0) return -1;              // invalid request\n    vector<unsigned long long> primes; // list of found NSW primes\n\n    // NSW recurrence: N_k = U_k + U_{k-1}\n    unsigned long long U_prev = 1; // U_0\n    unsigned long long U_cur  = 1; // U_1\n    unsigned long long N_k    = U_cur + U_prev; // N_1\n\n    // Two first NSW numbers are 1 (non\u2011prime) and 3\n    // We start from k=1, i.e. N_1 = 1 (skip), then N_2 = 3\n    // The loop will generate N_k for k >= 2\n    long long k = 1;\n    while ((long long)primes.size() < n) {\n        if (k >= 2) {\n            if (isPrime64(N_k)) primes.push_back(N_k);\n            if ((long long)primes.size() >= n) break;\n        }\n        /* compute next U and N */\n        unsigned long long U_next = 2ULL*U_cur + U_prev;   // U_{k+1}\n        U_prev = U_cur;\n        U_cur  = U_next;\n        N_k = U_cur + U_prev;              // N_{k+1}\n        ++k;\n    }\n    return (long long)primes.back();\n}\n\n// ------------------------------------------------------------------\n//  Demo / test\n// ------------------------------------------------------------------\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    long long idx;\n    cout << \"Enter N (1\u2011based index of NSW prime): \";\n    while (cin >> idx) {\n        unsigned long long p = newman_prime(idx);\n        cout << \"The \" << idx << \"-th NSW prime is: \" << p << \"\\n\";\n        cout << \"Enter another N (or Ctrl\u2011C to quit): \";\n    }\n    return 0;\n}\n```\n\n### How it works\n\n1. **NSW Recurrence**  \n   The recurrence `U_{k+2}=2*U_{k+1}+U_{k}` generates the *U* sequence.  \n   The NSW number of order `k` is `N_k = U_k + U_{k-1}`.  \n   The program produces `N_k` for `k = 2, 3, 4 \u2026` and keeps only the primes.\n\n2. **Prime Test**  \n   The function `isPrime64` is a fully deterministic Miller\u2013Rabin test for any 64\u2011bit integer.  \n   It is fast (O(log n) multiplications) and reliable for our use\u2011case.\n\n3. **Result**  \n   The vector `primes` keeps the primes in order.  \n   When we reach the requested index we return that prime.\n\n### Limits\n\n* The implementation uses 64\u2011bit integers (`unsigned long long`).  \n  The 23\u2011nd NSW prime already exceeds 10\u00b3\u2079, so with this implementation you can comfortably compute the first ~20\u201325 primes.  \n  To go further you would need arbitrary\u2011precision integers (e.g. `__int128`, GMP, or custom BigInt).\n\nFeel free to adapt the big\u2011integer part if you need to generate larger NSW primes. Happy hacking!", "**Solution Explanation**\n\nThe Newman\u2013Shanks\u2013Williams (NSW) numbers are defined by the recurrence\n\n```\nu0 = 1\nu1 = 1\nu_n = u_{n-1} + 10 \u00d7 u_{n-2}          for n \u2265 2\n```\n\n(You can find the derivation in the Wikipedia entry for the NSW sequence.)\n\nFor most values of `n` the number `u_n` is composite, but for a handful of\nindices it is prime.  \nThe task is to return the *n\u2011th* such prime \u2013 for example\n\n```\nindex 0 1 2 3 4 ...\nprime  1 11 4431 111111111771\n```\n\nThe sequence grows extremely fast, so we only need to generate numbers\nuntil we have found `n+1` primes (indices are 0\u2011based).\n\nThe outline of the algorithm is\n\n1. **Generate NSW numbers** using the recurrence above.\n2. **Test primality** of each generated number.  \n   The numbers quickly exceed the range of 64\u2011bit integers, so we use\n   128\u2011bit arithmetic (`__int128`) while generating (the first few primes\n   all fit comfortably in 64 bits).\n3. **Collect primes** until the required count is reached.\n\nThe only heavy part is the primality test.  \nBecause the numbers become huge very fast, a deterministic test for\n64\u2011bit integers (Miller\u2011Rabin with bases `{2,3,5,7,11,13}`) is\nperfectly adequate for all primes that appear in practice.\n\n---\n\n#### Correctness Proof  \n\nWe prove that the algorithm returns the *n\u2011th* NSW prime.\n\n**Lemma 1**\n\nThe sequence produced by the recurrence\n`u0 = 1, u1 = 1, u_n = u_{n-1} + 10*u_{n-2}` is exactly the sequence of\nNSW numbers.\n\n*Proof.*\n\nThe recurrence is part of the definition of the NSW numbers,\nso every number produced is an NSW number and every NSW number\nappears exactly once. \u220e\n\n\n\n**Lemma 2**\n\nDuring the execution the algorithm checks the primality of every NSW\nnumber in increasing order.\n\n*Proof.*\n\nThe algorithm starts with `u0, u1` and then iteratively computes\n`u_{k+1} = u_k + 10*u_{k-1}`.  \nThus `u_0, u_1, u_2, \u2026` are produced in order, and each is tested for primality\nbefore the next one is generated. \u220e\n\n\n\n**Lemma 3**\n\nWhenever the algorithm appends a number to the list of primes,\nthat number is a prime.\n\n*Proof.*\n\nA number is appended only if the primality test reports it prime.\nThe deterministic Miller\u2011Rabin test used here is correct for all 64\u2011bit\nintegers, so the reported result is reliable. \u220e\n\n\n\n**Lemma 4**\n\nThe list of primes produced by the algorithm is a prefix of the\nsequence of all NSW primes.\n\n*Proof.*\n\nBy Lemma&nbsp;2 every NSW number is examined and by Lemma&nbsp;3 each\nprimality determination is correct.  \nHence the list contains exactly the NSW primes seen so far, in order, and\nno composite NSW number is inserted. \u220e\n\n\n\n**Theorem**\n\nAfter the algorithm terminates, the element returned is the\n*n\u2011th* NSW prime (0\u2011based indexing).\n\n*Proof.*\n\nThe algorithm stops as soon as the list contains `n+1` elements,\ni.e. the primes `p\u2080, p\u2081, \u2026, p_n`.  \nBy Lemma&nbsp;4 this list is precisely the first `n+1` NSW primes,\nso the last element in the list is `p_n`, the required *n\u2011th* NSW prime. \u220e\n\n\n\n---\n\n#### Complexity Analysis\n\nLet `P` be the number of candidate NSW numbers examined until the\n`n`\u2011th prime is found.  \nGenerating each candidate takes `O(1)` time.\nThe Miller\u2011Rabin test on a 64\u2011bit integer runs in `O(log\u202fm)` time\n(`m` is the number size, at most 64\u202fbits), i.e. `O(1)` practically.\n\n```\nTime   :  O(P)          (P is very small \u2013 the primes appear quickly)\nMemory :  O(1)          aside from the few integers kept\n```\n\n---\n\n#### Reference Implementation  (GNU\u202fC++17)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nusing int64 = long long;\nusing u128 = __uint128_t;\n\n//--------- deterministic Miller\u2011Rabin for 64\u2011bit integers ----------\nbool isPrime(uint64_t n)\n{\n    if (n < 2) return false;\n    for (uint64_t p : {2,3,5,7,11,13,17,19,23,29,31,37}) {\n        if (n % p == 0) return n == p;\n    }\n    uint64_t d = n-1, s = 0;\n    while ((d & 1) == 0) { d >>= 1; ++s; }\n\n    auto powmod = [](u128 a, u128 e, u128 mod)->u128 {\n        u128 r = 1;\n        while (e) {\n            if (e & 1) r = (r*a) % mod;\n            a = (a*a) % mod;\n            e >>= 1;\n        }\n        return r;\n    };\n\n    // bases that are sufficient for 64\u2011bit integers\n    for (uint64_t a : {2,325,9375,28178,450775,9780504,1795265022}) {\n        if (a % n == 0) continue;\n        u128 x = powmod(a, d, n);\n        if (x==1 || x==n-1) continue;\n        bool composite = true;\n        for (uint64_t r=1; r<s; ++r) {\n            x = (x*x) % n;\n            if (x == n-1) { composite = false; break; }\n        }\n        if (composite) return false;\n    }\n    return true;\n}\n//--------------------------------------------------------------------\n\n/*\n * Return the n\u2011th Newman\u2013Shanks\u2013Williams prime (0\u2011based index).\n */\nlong newman_prime(long n)\n{\n    if (n < 0) throw std::invalid_argument(\"n must be non\u2011negative\");\n    vector<uint64_t> primes;\n    uint64_t u0 = 1, u1 = 1, u2;\n    // handle first two numbers\n    if (isPrime(u0)) primes.push_back(u0);\n    if (primes.size() > (size_t)n) return primes[n];\n    if (isPrime(u1)) primes.push_back(u1);\n    if (primes.size() > (size_t)n) return primes[n];\n\n    // generate successors\n    while (true) {\n        // u_{k+2} = u_{k+1} + 10*u_k  (recurrence)\n        u2 = u1 + 10ULL * u0;\n        if (isPrime(u2)) primes.push_back(u2);\n        if (primes.size() > (size_t)n) return primes[n];\n        u0 = u1;\n        u1 = u2;\n    }\n}\n\nint main()\n{\n    // quick demo\n    for (int i = 0; i < 5; ++i) {\n        cout << \"NSW prime #\" << i << \" = \" << newman_prime(i) << '\\n';\n    }\n    return 0;\n}\n```\n\nThe program follows exactly the algorithm proven correct above and\nconforms to the GNU\u202fC++17 standard.", "**Explanation**\n\nThe Newman\u2013Shanks\u2013Williams (NSW) numbers form a Lucas\u2011type sequence\n\n```\nS0 = 1\nS1 = 1\nSn = 4\u00b7Sn\u20111 + Sn\u20112          ( n \u2265 2 )\n```\n\nAn **NSW prime** is an element of this sequence that is itself a prime\nnumber.  \nThe first few primes of the sequence are\n\n```\nn = 5 , 7 , 12 , 13 , 14 , 15 , 21 , 24 , 29 , \u2026\nS5 =  781\nS7 =  5\u202f267\nS12= 8\u202f600\u202f000\u202f000001\n\u2026            (values grow extremely fast)\n```\n\nThe task is to return the *n*\u2011th NSW prime.\n\nBecause the numbers grow exponentially (about `~(2+\u221a5)^n`) a 64\u2011bit\nint will overflow very soon (`S32 > 10^18`).  \nThus we use `boost::multiprecision::cpp_int` which gives us arbitrary\nprecision integers.\n\n**Algorithm**\n\n1. Generate the NSW sequence iteratively: `a = S0`, `b = S1`, then  \n   `c = 4*b + a`;  shift `a\u2190b`, `b\u2190c`.\n2. At every step test the current term for primality.\n   The `cpp_int` type is not hashable, so we need a Miller\u2013Rabin\n   deterministic test for 64\u2011bit integers that can be extended to larger\n   ranges \u2013 `boost::multiprecision::cpp_int` is not natively supported in\n   `boost::multiprecision::cpp_int`, we implement a simple deterministic\n   Miller\u2013Rabin for large numbers (using the known witness sets for\n   64\u2011bit numbers). For numbers larger than that we fall back to a\n   probabilistic version with say 7 rounds (very unlikely to fail).\n3. Count the primes found; stop when the *n*\u2011th one is reached.\n\nThe function returns the *n*\u2011th NSW prime as a `cpp_int`.  \nFor convenience we provide a small wrapper that converts the result to a\nstring, so it can be printed easily.\n\n**Complexity**\n\nLet *k* be the index of the searched prime.  \nThe sequence grows roughly like `\u03b1^k` with `\u03b1 \u2248 4.236`.  \nSo the size of the numbers is `O(k)`.  \nMiller\u2013Rabin on a `k`\u2011bit number costs `O(k^3)` deterministic\narithmetic operations in the worst case, which is fast enough for the\ntiny values of *k* that we normally ask for (`k \u2264 25` gives\nat most a 200\u2011digit number).\n\n**Code**\n\n```cpp\n#include <bits/stdc++.h>\n#include <boost/multiprecision/cpp_int.hpp>\n\nusing namespace std;\nusing boost::multiprecision::cpp_int;\n\n/* ----------  Miller\u2013Rabin primality test for cpp_int  ---------- */\n\ncpp_int mod_pow(cpp_int a, cpp_int d, const cpp_int &mod) {\n    cpp_int res = 1;\n    a %= mod;\n    while (d > 0) {\n        if (d & 1) res = (res * a) % mod;\n        a = (a * a) % mod;\n        d >>= 1;\n    }\n    return res;\n}\n\n/*  Deterministic test for 64\u2011bit numbers (convenient for the\n    early terms).  For larger numbers we run a few rounds of\n    probabilistic Miller\u2013Rabin \u2013 a 99.999\u2026% safe approximation\n    in practice.  The chosen witnesses provide\n    deterministic correctness for n < 341,550,071,728,321.  */\nbool is_prime(const cpp_int &n) {\n    if (n < 2) return false;\n    for (static_cast<uint64_t>(p) : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {\n        if (n == p) return true;\n        if (n % p == 0) return false;\n    }\n    // write n \u2212 1 as d\u00b72^s\n    cpp_int d = n - 1;\n    unsigned int s = 0;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        ++s;\n    }\n    // witnesses valid for 64\u2011bit integers\n    const vector<uint64_t> witnesses =\n        {2ULL, 325ULL, 9375ULL, 28178ULL, 450775ULL, 9780504ULL, 1795265022ULL};\n\n    for (uint64_t w : witnesses) {\n        if (w % n == 0) continue;                // skip if witness >= n\n        cpp_int a = w;\n        cpp_int x = mod_pow(a, d, n);\n        if (x == 1 || x == n - 1) continue;\n        bool next_witness = false;\n        for (unsigned int r = 1; r < s; ++r) {\n            x = (x * x) % n;\n            if (x == n - 1) {\n                next_witness = true;\n                break;\n            }\n        }\n        if (next_witness) continue;\n        return false;                            // composite\n    }\n    return true;                                 // probably prime\n}\n\n/* ----------  Newman\u2013Shanks\u2013Williams prime generator  ---------- */\n\ncpp_int newman_prime(long n) {\n    if (n <= 0) throw std::invalid_argument(\"n must be positive\");\n\n    // NSW sequence: S0 = 1, S1 = 1\n    cpp_int prev = 1;  // S(n-2)\n    cpp_int cur  = 1;  // S(n-1)\n\n    long prime_cnt = 0;          // how many primes we found\n    long idx       = 1;          // index of 'cur' in the sequence\n\n    while (true) {\n        if (is_prime(cur)) {\n            ++prime_cnt;\n            if (prime_cnt == n) return cur;\n        }\n\n        // next term\n        cpp_int next = 4 * cur + prev;\n        prev = cur;\n        cur  = next;\n        ++idx;\n    }\n    // never reached\n    return cpp_int(-1);\n}\n\n/* ----------  Helper for printing ---------- */\n\nstring newman_prime_str(long n) {\n    return newman_prime(n).convert_to<string>();\n}\n\n/* ----------  Demo and minimal test ---------- */\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    long k;\n    cout << \"Enter the index of NSW prime to compute: \";\n    if (!(cin >> k)) return 0;\n    // bounds safety: if k is too large we may run for a long time\n    try {\n        cpp_int p = newman_prime(k);\n        cout << \"The \" << k << \"-th NSW prime is:\\n\" << p << '\\n';\n    } catch (const exception &e) {\n        cerr << \"Error: \" << e.what() << '\\n';\n    }\n    return 0;\n}\n```\n\n**How to compile**\n\n```\ng++ -std=c++20 -O2 -Wall -Wextra -o newman newman.cpp -lboost_system -lboost_filesystem\n```\n\n(Only the header part of Boost (`boost/multiprecision/cpp_int.hpp`) is\nused, so normally no additional linking is required; the command above\nis safe for most systems.)\n\n**What the program does**\n\n1. Reads an integer `k`.\n2. Generates the NSW sequence until it has found exactly `k` primes.\n3. Prints the `k`\u2011th NSW prime.\n\nThe function `newman_prime` can be reused directly in other programs.\nIt returns the prime as a `cpp_int`, which can be converted to a\n`string`, printed, or used in further arbitrary\u2011precision\ncalculations."]}
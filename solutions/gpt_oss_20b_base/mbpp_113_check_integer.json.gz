{"completions": ["Here is a compact yet robust implementation of `check_integer`.  \nIt uses `std::stoll` to try converting the whole string to a long long.  \nThe conversion succeeds **only when**:\n\n1. the string is not empty,\n2. it consists solely of an optional sign followed by decimal digits,\n3. the parsed value fits into a signed 64\u2011bit integer.\n\nThat matches the common definition of \u201crepresents an integer\u201d.\n\n```cpp\n#include <string>\n#include <cstdlib>\n#include <cctype>\n#include <stdexcept>\n\nbool check_integer(const std::string& text)\n{\n    if (text.empty())                   // empty string \u2192 not an integer\n        return false;\n\n    std::size_t pos = 0;                // position to start parsing\n\n    // Optional initial sign\n    if (text[pos] == '+' || text[pos] == '-')\n        ++pos;\n\n    // Must contain at least one digit\n    if (pos == text.size() || !std::isdigit(static_cast<unsigned char>(text[pos])))\n        return false;\n\n    // Consume all subsequent digits\n    while (pos < text.size() && std::isdigit(static_cast<unsigned char>(text[pos])))\n        ++pos;\n\n    // Anything else left in the string \u2192 not an integer\n    if (pos != text.size())\n        return false;\n\n    // Finally, ensure numeric value is in valid range (optional, but safe)\n    try {\n        std::stoll(text);               // throws if out of range\n    } catch (const std::exception&) {\n        return false;\n    }\n\n    return true;\n}\n```\n\n**Why this works**\n\n* The loop guarantees there are no stray characters (besides an optional sign).  \n* If the string contained just a sign or non\u2011digit characters, the function returns `false`.  \n* The `std::stoll` call catches potential overflows such as `\"12345678901234567890\"`.  \n\nFeel free to tweak the numeric range or replace `std::stoll` with your own overflow check if you need support for arbitrarily large integers.", "Here\u2019s a concise, self\u2011contained C++ function that tells whether a given string represents an integer (in decimal form).  \nIt runs in *O(n)* time, cleans up leading/trailing spaces, deals with optional sign, and rejects any other characters.\n\n```cpp\n#include <string>\n#include <cctype>\n\n/*  Return true if `text` is a valid integer representation\n *  (decimal, optional leading + or -).  Leading/trailing whitespace\n *  is ignored.  No other characters are allowed (e.g. \u201c12.5\u201d, \u201c  40x\u201d).\n */\nbool check_integer(const std::string& text)\n{\n    // Trim leading whitespace\n    std::size_t start = 0;\n    while (start < text.size() && std::isspace(static_cast<unsigned char>(text[start])))\n        ++start;\n\n    // Trim trailing whitespace\n    std::size_t end = text.size();\n    while (end > start && std::isspace(static_cast<unsigned char>(text[end-1])))\n        --end;\n\n    if (start == end)            // empty string or only whitespace\n        return false;\n\n    std::size_t i = start;\n\n    // Optional sign\n    if (text[i] == '+' || text[i] == '-')\n        ++i;\n\n    // At least one digit must follow the sign (or not exist if no sign)\n    if (i == end)                // string was only \"+\" or \"-\"\n        return false;\n\n    // All remaining characters must be digits\n    while (i < end) {\n        if (!std::isdigit(static_cast<unsigned char>(text[i])))\n            return false;\n        ++i;\n    }\n\n    return true;\n}\n```\n\n### Quick test\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::string tests[] = {\n        \"42\", \"-13\", \"+7\", \"   123  \", \"0\", \"+\", \"-\", \"12a\", \"  3.14 \", \"\"\n    };\n\n    for (const auto& s : tests) {\n        std::cout << '\"' << s << \"\\\" -> \"\n                  << (check_integer(s) ? \"int\" : \"not int\") << '\\n';\n    }\n}\n```\n\n**Output**\n\n```\n\"42\" -> int\n\"-13\" -> int\n\"+7\" -> int\n\"   123  \" -> int\n\"0\" -> int\n\"+\" -> not int\n\"-\" -> not int\n\"12a\" -> not int\n\"  3.14 \" -> not int\n\"\" -> not int\n```\n\nThis implementation is portable, does not rely on `<bits/stdc++.h>`, and follows common C++ best practices.", "Here is a complete, self\u2011contained implementation of a helper that tells whether a string represents an **integer** (no whitespace, no decimal point, only an optional sign followed by one or more decimal digits).  \n\n```cpp\n#include <string>\n#include <cctype>\n\n/**\n * @brief   Returns true iff @p text represents an integer.\n *\n * The definition is intentionally simple:\n *  - Leading/trailing spaces are NOT allowed.\n *  - The string may start with '+' or '-' (only one such sign).\n *  - The rest must be a non\u2011empty sequence of decimal digits (0\u20119).\n *\n * Examples of text that evaluate to true:\n *     \"0\", \"123\", \"+456\", \"-789\"\n *\n * Examples of text that evaluate to false:\n *     \"\", \"   12\", \"12 \", \"+\", \"- 5\", \"3.0\", \"abc123\"\n *\n * @param text  The string that should be examined.\n * @return      true if the string matches the integer pattern described above,\n *              otherwise false.\n */\nbool check_integer(const std::string& text)\n{\n    // Empty string cannot be an integer\n    if (text.empty())\n        return false;\n\n    size_t i = 0;\n    // Optional leading sign\n    if (text[i] == '+' || text[i] == '-')\n        ++i;\n\n    // There must be at least one digit\n    if (i == text.size())\n        return false;\n\n    // All remaining characters must be digits\n    for (; i < text.size(); ++i)\n        if (!std::isdigit(static_cast<unsigned char>(text[i])))\n            return false;\n\n    return true;\n}\n```\n\n### Why this implementation?\n\n| Check | Why it matters | What it does |\n|-------|----------------|--------------|\n| `text.empty()` | Prevents `\"\"` from becoming `true` | Immediately returns `false`. |\n| Optional `+/-` | Allows signed numbers | Skips the first character if it\u2019s a sign. |\n| At least one digit | A lone sign isn't a number | Ensures the string isn\u2019t just `+` or `-`. |\n| `std::isdigit` on every remaining char | Guarantees decimal\u2011only digits | Rejects anything like `\"12a\"` or `\"3.0\"`. |\n| `static_cast<unsigned char>` | Avoids UB when negative `char` values are passed | Ensures correct behavior with locales or signed `char`. |\n\nFeel free to integrate this function into your codebase. If you need support for other numeral systems (hex, octal) or additional whitespace handling, the logic can be extended accordingly."]}
{"completions": ["Here\u2019s a quick, clean implementation of `search`.  \nIt counts the frequencies of each integer, then scans the map looking for\nvalues that satisfy `freq >= value`.  \nThe largest such value is returned \u2013 or `-1` when no value meets the\ncriterion.  \n\n```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nlong search(std::vector<long> lst) {\n    // Count frequencies\n    std::unordered_map<long,long> freq;\n    for (long x : lst) ++freq[x];\n\n    long best = -1;                     // default when no candidate exists\n    for (const auto &[val, cnt] : freq) {\n        if (cnt >= val && val > best)   // val > 0 is guaranteed in the problem\n            best = val;\n    }\n    return best;\n}\n```\n\n> **Explanation**  \n> - A hash map gives `O(1)` average\u2011time inserts & lookups.  \n> - We only traverse the list once to build the frequency table.  \n> - We traverse the map once to find the maximum value satisfying the\n>   condition \u2013 overall time complexity\u202f`O(n)` and space complexity\u202f`O(k)` where\n>   `k` is the number of distinct values.", "Here is a straightforward implementation that follows the rules you described.  \nIt counts the frequencies of each value, then looks for the largest value `x` such that  \n`frequency(x) >= x`.  If no such value exists, `-1` is returned.\n\n```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nlong search(std::vector<long> lst) {\n    // Count frequencies\n    std::unordered_map<long, long> freq;\n    for (long v : lst) {\n        ++freq[v];\n    }\n\n    // Find the largest valid candidate\n    long best = -1;\n    for (const auto &p : freq) {\n        long value = p.first;\n        long f = p.second;\n        if (f >= value && value > best) {\n            best = value;\n        }\n    }\n    return best;\n}\n```\n\n```cpp\n// Example usage:\n#include <iostream>\nint main() {\n    std::vector<long> a1 {4,1,2,2,3,1};\n    std::vector<long> a2 {1,2,2,3,3,3,4,4,4};\n    std::vector<long> a3 {5,5,4,4,4};\n\n    std::cout << search(a1) << '\\n'; // 2\n    std::cout << search(a2) << '\\n'; // 3\n    std::cout << search(a3) << '\\n'; // -1\n}\n```\n\nThis solution runs in `O(n)` time and uses `O(k)` additional space, where `k` is the number of distinct integers in the list.", "Here is a concise, self\u2011contained implementation that follows the spec.\n\n```cpp\n#include <unordered_map>\n#include <vector>\n#include <algorithm>\n\n/*\n * Return the greatest integer > 0 that appears in `lst` at least as many times as\n * its value.  If no such integer exists, return -1.\n *\n * Example:\n *   search({4,1,2,2,3,1})  -> 2\n *   search({1,2,2,3,3,3,4,4,4}) -> 3\n *   search({5,5,4,4,4}) -> -1\n */\nlong search(std::vector<long> lst)\n{\n    if (lst.empty()) return -1;               // safety, though input is non empty\n\n    // Compute frequencies\n    std::unordered_map<long,long> freq;\n    for (long x : lst) {\n        if (x > 0) freq[x]++;                 // we only care about positive numbers\n    }\n\n    long best = -1;\n    for (const auto& kv : freq) {\n        long value = kv.first;\n        long count = kv.second;\n        if (count >= value && value > best) {\n            best = value;\n        }\n    }\n\n    return best;                              // will be -1 if no candidate was found\n}\n```\n\nThe function:\n\n1. Counts occurrences of each positive integer using an `unordered_map`.\n2. Iterates over that map to find the greatest value such that its count is at least its value.\n3. Returns that value, or `-1` if none satisfy the condition.\n\nThis satisfies all the provided examples."]}
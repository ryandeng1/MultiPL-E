{"completions": ["Here\u2019s a compact, fast\u2011and\u2011safe implementation of the **nth Jacobsthal number** that follows the definition from the GeeksforGeeks page:\n\n```cpp\n#include <cassert>\n#include <bits/stdc++.h>\n\n/*\n * Jacobsthal numbers satisfy:\n *   J(0) = 0 ,\n *   J(1) = 1 ,\n *   J(n) = J(n-1) + 2 * J(n-2)    for n \u2265 2\n *\n * Sequence: 0, 1, 1, 3, 5, 11, 21, 43, \u2026\n */\nlong jacobsthal_num(long n)\n{\n    assert(n >= 0);               // undefined for negative n\n\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n\n    long prev2 = 0;   // J(n-2)\n    long prev1 = 1;   // J(n-1)\n    long cur   = 0;   // J(n)\n\n    for (long i = 2; i <= n; ++i) {\n        cur = prev1 + 2 * prev2;\n        prev2 = prev1;\n        prev1 = cur;\n    }\n\n    return cur;\n}\n```\n\n### Why this works\n\n1. **Iterative DP** \u2013 No recursion or caching is needed; each term is computed in constant time.\n2. **Overflow notice** \u2013 Using `long` gives you up to 2\u202f^\u202f63\u202f\u2212\u202f1. For larger `n` you may need `long long` or a big\u2011integer type.\n3. **Correctness** \u2013 The recurrence `J(n) = J(n-1) + 2\u00b7J(n-2)` matches the definition in the article.\n\nYou can test it with:\n\n```cpp\nfor (int i = 0; i < 15; ++i)\n    std::cout << i << \": \" << jacobsthal_num(i) << '\\n';\n```\n\nwhich prints the first 15 Jacobsthal numbers as in the reference sequence.", "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n   The n\u2011th Jacobsthal number is defined by the recurrence  \n\n          J(0) = 0\n          J(1) = 1\n          J(n) = J(n\u20111) + 2*J(n\u20112)   , n \u2265 2\n\n   The sequence starts 0, 1, 1, 3, 5, 11, 21, \u2026\n*/\n\n/*  Return the nth Jacobsthal number */\nlong long jacobsthal_num(long long n)\n{\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n\n    long long a = 0;          // J(0)\n    long long b = 1;          // J(1)\n    long long cur = 0;\n\n    for (long long i = 2; i <= n; ++i) {\n        cur = b + 2 * a;      // J(i) = J(i\u20111) + 2*J(i\u20112)\n        a = b;\n        b = cur;\n    }\n    return cur;\n}\n\n/* -----------------  test harness  ----------------- */\n\nint main()\n{\n    vector<long long> expected = {0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341,\n                                 683, 1365, 2731};\n\n    for (size_t i = 0; i < expected.size(); ++i) {\n        long long got = jacobsthal_num(i);\n        assert(got == expected[i]);\n    }\n    cout << \"All tests passed.\\n\";\n    return 0;\n}\n```\n\n**Explanation**\n\n* Use an iterative loop so no recursion or extra memory is needed.  \n* `a` holds `J(n\u20112)` and `b` holds `J(n\u20111)`; `cur` becomes `J(n)`.  \n* The recurrence `J(n) = J(n\u20111) + 2*J(n\u20112)` is applied for every `n \u2265 2`.  \n\nThe program includes a small test harness that verifies the first 14 Jacobsthal numbers.", "### Final C++ Function to Generate the nth Jacobsthal Number\n\nBelow is a clean and well\u2011commented implementation that follows the classic recurrence\n\\[ J(0)=0,\\; J(1)=1,\\; J(n)=J(n-1)+2\\,J(n-2) \\]\nfor \\(n\\ge2\\).  \nThe code computes the number iteratively \u2013 which is O(n) time and O(1) additional space \u2013 and stores the result in a 64\u2011bit integer (`long long`).  \n\n```cpp\n#include <cstdint>   // for std::int64_t (long long)\n#include <cassert>\n\n// -----------------------------------------------------------------------------\n//  Compute the nth Jacobsthal number\n//\n//  The Jacobsthal sequence begins: 0, 1, 1, 3, 5, 11, 21, 43, ...\n//  --------------------------------------------------------------\n//  Right\u2011hand side of Wikipedia: J(n) = J(n-1) + 2 * J(n-2)\n//\n//  Complexity\n//  -----------\n//  * Time:      O(n)  \u2013 simple iteration\n//  * Space:     O(1)  \u2013 only two previous values stored\n//\n//  Parameters\n//  -----------\n//   n : non\u2011negative integer, the index of the desired value\n//\n//  Returns\n//  -------\n//   The integer value of J(n)\n// -----------------------------------------------------------------------------\nint64_t jacobsthal_num(std::int64_t n)\n{\n    assert(n >= 0);                     // index must be non\u2011negative\n    if (n == 0) return 0;               // base case J(0)\n    if (n == 1) return 1;               // base case J(1)\n\n    std::int64_t prev2 = 0;             // J(n-2)\n    std::int64_t prev1 = 1;             // J(n-1)\n    std::int64_t cur   = 0;             // J(n)  \u2013 will hold next value\n\n    for (std::int64_t i = 2; i <= n; ++i) {\n        cur = prev1 + 2 * prev2;       // recurrence\n        prev2 = prev1;                 // shift window\n        prev1 = cur;\n    }\n\n    return cur;\n}\n```\n\n#### How to Use\n\n```cpp\n#include <iostream>\n\nint main() {\n    for (int i = 0; i <= 10; ++i) {\n        std::cout << \"J(\" << i << \") = \" << jacobsthal_num(i) << '\\n';\n    }\n}\n```\n\n#### Why This Implementation?\n\n* **Safety** \u2013 The `assert` protects against negative indices.\n* **Simplicity** \u2013 The iterative loop avoids expensive recursion or matrix\u2011exponentiation.\n* **Speed** \u2013 Only a handful of arithmetic operations per iteration.\n* **Portability** \u2013 Uses standard C++ and the signed 64\u2011bit type `int64_t`.\n\nFeel free to adapt the function to your project, e.g., using `std::uint64_t` if you only need non\u2011negative outputs or adding modulo support for very large `n`."]}
{"completions": ["Below is a **complete, compile\u2011ready** C++ program that implements the requested\nfunction `cal_sum`.  \nThe program also contains a small test harness (`main`) so you can run it\ndirectly and verify the implementation.\n\nThe Perrin sequence is defined as  \n\n```\nP(0) = 3,   P(1) = 0,   P(2) = 2\nP(n) = P(n\u20112) + P(n\u20113)   for n \u2265 3\n```\n\n`cal_sum(n)` returns the sum  \n\n```\nS(n) = P(0) + P(1) + \u2026 + P(n)\n```\n\nAll calculations are performed with the built\u2011in `long` type (64\u2011bit on most\nmodern systems).  If you need more precision you can switch to `long long`\nor even `__int128` \u2013 the algorithm itself is unchanged.\n\n```cpp\n#include <iostream>\n#include <cassert>\n\n/* ----------------------------------------------------\n   Calculate the sum of Perrin numbers from P(0) to P(n)\n   ---------------------------------------------------- */\nlong cal_sum(long n)\n{\n    if (n < 0)\n        return 0;                      // impossible input \u2013 guard\n\n    /* base values of the Perrin sequence */\n    long p0 = 3,   // P(0)\n         p1 = 0,   // P(1)\n         p2 = 2;   // P(2)\n\n    /* handle the first 3 terms explicitly */\n    long sum = 0;\n    if (n >= 0) sum += p0;\n    if (n >= 1) sum += p1;\n    if (n >= 2) sum += p2;\n\n    /* iteratively compute P(3)\u2026P(n) and add to the sum */\n    for (long i = 3; i <= n; ++i)\n    {\n        long pi = p0 + p1;       // P(i) = P(i\u20112) + P(i\u20113)\n        sum += pi;\n\n        /* shift the sliding window:\n           p0 \u2190 P(i\u20112), p1 \u2190 P(i\u20111), p2 \u2190 P(i) */\n        p0 = p1;\n        p1 = p2;\n        p2 = pi;\n    }\n    return sum;\n}\n\n/* --------------------  Demo / Test  -------------------- */\nint main()\n{\n    // Simple manual tests (known Perrin values)\n    assert(cal_sum(0) == 3);\n    assert(cal_sum(1) == 3);         // 3 + 0\n    assert(cal_sum(2) == 5);         // 3 + 0 + 2\n    assert(cal_sum(3) == 8);         // + P(3)=3 \u2192 5+3\n    assert(cal_sum(4) == 13);        // + P(4)=5 \u2192 8+5\n    assert(cal_sum(5) == 23);        // + P(5)=8 \u2192 13+8\n\n    std::cout << \"All test cases passed!\\n\";\n\n    /* Demo: print sum of first 20 Perrin numbers */\n    long n = 20;\n    std::cout << \"Sum of Perrin numbers P(0) .. P(\" << n << \") = \"\n              << cal_sum(n) << '\\n';\n\n    return 0;\n}\n```\n\n### How it works\n\n1. **Base cases** \u2013 we immediately handle the first three terms of the\n   sequence, adding them to the running `sum`.\n2. **Sliding\u2011window (three\u2011element) approach** \u2013 we only ever need the last\n   three values to compute the next term, so we keep them in `p0`, `p1`,\n   and `p2`.  After using them to compute `pi`, we shift the window.\n3. **Linear time, constant space** \u2013 the loop runs exactly `n\u20112` times and\n   uses O(1) additional memory.\n\nFeel free to remove or adapt the `main` section if you only need the\nfunction in a larger codebase.", "Below is a simple, self\u2011contained implementation that\n\n* builds the Perrin sequence up to the requested index `n`\n* accumulates the sum as it goes\n\n```cpp\n#include <cassert>\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Sum of Perrin numbers from P(0) up to P(n) (inclusive)\nlong cal_sum(long n) {\n    // Handle trivial cases\n    if (n < 0) return 0;          // nothing to sum\n    if (n == 0) return 3;         // P(0) = 3\n    if (n == 1) return 3;         // P(0)+P(1) = 3\n    if (n == 2) return 5;         // 3+0+2 = 5\n\n    // We'll keep only the last three values to conserve memory.\n    long p0 = 3, p1 = 0, p2 = 2;   // corresponds to P(0), P(1), P(2)\n    long sum = p0 + p1 + p2;      // sum up to P(2)\n\n    for (long i = 3; i <= n; ++i) {\n        // Perrin recurrence: P(i) = P(i-2) + P(i-3)\n        long pi = p0 + p1;        // p0 == P(i-3), p1 == P(i-2)\n\n        // Shift the window: drop the oldest (p0), move others forward\n        p0 = p1;\n        p1 = p2;\n        p2 = pi;\n\n        sum += pi;\n    }\n\n    return sum;\n}\n```\n\n### Why this works\n\n* The Perrin sequence is defined by  \n  \\(P(0)=3,\\; P(1)=0,\\; P(2)=2\\) and \\(P(n)=P(n-2)+P(n-3)\\) for \\(n\\ge3\\).\n* We keep the last three values (`p0`, `p1`, `p2`) and compute the next one as\n  `p0 + p1`.  \n  After each iteration we shift the window so that the new triple always\n  represents the most recent three consecutive Perrin numbers.\n* Running sum is updated on the fly, giving an O(n) time and O(1) space\n  algorithm.\n\nFeel free to adjust the boundary checks (e.g., if you want the sum up to but\nnot including `n`) by nudging the `if` statements accordingly.", "Here is a compact, self\u2011contained implementation that follows the classic\nPerrin sequence definition\n\n```\nP(0) = 3 ,  P(1) = 0 ,  P(2) = 2\nP(n) = P(n\u20112) + P(n\u20113)            (n \u2265 3)\n```\n\nThe routine `cal_sum(n)` returns the sum  \n```\nS(n) = P(0) + P(1) + \u2026 + P(n)\n```\n\n---\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*  Sum of Perrin numbers up to index n   */\nlong cal_sum(long n)\n{\n    if (n < 0) return 0;          // nothing to sum\n\n    /*  base cases  */\n    long p0 = 3, p1 = 0, p2 = 2;\n    long sum = 0;\n\n    if (n >= 0) sum += p0;\n    if (n >= 1) sum += p1;\n    if (n >= 2) sum += p2;\n\n    /*  iterate from 3 to n  */\n    for (long i = 3; i <= n; ++i)\n    {\n        long pi = p0 + p1;       // P(i) = P(i-2) + P(i-3)\n        sum += pi;\n\n        /* shift the last three values  */\n        p0 = p1;\n        p1 = p2;\n        p2 = pi;\n    }\n\n    return sum;\n}\n```\n\n**Explanation**\n\n1. **Base** \u2013 we keep the three most recent Perrin numbers (`p0`, `p1`, `p2`)\n   which correspond to `P(i\u20113)`, `P(i\u20112)` and `P(i\u20111)` respectively.\n2. **Recurrence** \u2013 `P(i) = P(i\u20112) + P(i\u20113) = p0 + p1`.\n3. **Rolling window** \u2013 after computing `P(i)` we push it to the window by\n   shifting the three variables.\n4. **Sum** \u2013 we accumulate every computed `P(i)` in `sum`.\n\nThe loop works in\u202fO(n) time and uses\u202fO(1) extra space."]}
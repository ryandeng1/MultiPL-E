{"completions": ["```cpp\n#include <bits/stdc++.h>\n\n// ------------------------------------------------------------------\n// Count the number of rotations required to convert an array of\n// strictly increasing integers into a sorted (non\u2011rotated) array.\n// The array is assumed to be a rotated version of a sorted array\n//  (i.e. it was sorted in ascending order and then rotated some\n//  number of times).\n//\n// Approach:\n//   * In a rotated sorted array, the only element that is smaller\n//     than its predecessor is the minimum element \u2013 the point of\n//     rotation.\n//   * The index of that element equals the number of rotations.\n//   * The problem can be solved in O(log n) time using a binary\n//     search variant.\n//\n// Complexity:\n//   \u2022 Time   : O(log n)\n//   \u2022 Space  : O(1)\n// ------------------------------------------------------------------\nlong count_rotation(const std::vector<long>& arr) {\n    if (arr.empty()) return 0;          // no rotation on empty array\n    \n    int low = 0, high = (int)arr.size() - 1;\n    \n    // If array is not rotated at all, the smallest element is at index 0\n    if (arr[low] <= arr[high]) return 0;\n    \n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        int next = (mid + 1) % arr.size();\n        int prev = (mid - 1 + arr.size()) % arr.size();\n        \n        // Check if mid element is the minimum\n        if (arr[mid] <= arr[next] && arr[mid] <= arr[prev]) {\n            return mid;   // index of minimum element = #rotations\n        }\n        \n        // Decide which side to search next\n        // If the element at mid is greater than the element at high,\n        // the min must be in the right half\n        if (arr[mid] > arr[high]) {\n            low = mid + 1;\n        } else {                    // Otherwise it's in the left half\n            high = mid - 1;\n        }\n    }\n    return 0;  // should never reach here for valid input\n}\n```\n\n**How it works**\n\n1. **Handle trivial cases** \u2013 empty array or already sorted array (no rotation).\n2. **Binary search** \u2013 reduce the search space to the side that contains the minimum element.\n3. **Pivot detection** \u2013 when an element is smaller than both its immediate neighbors, it\u2019s the pivot (smallest element).\n4. **Return** \u2013 the pivot index is exactly the number of rotations.", "```cpp\n#include <iostream>\n#include <vector>\n\n/*\n * Count the number of rotations required to get a sorted array.\n *\n * In a rotated sorted array the pivot (the smallest element) is the\n * point where the rotation happened.  \n * For an array of size n, the number of rotations is\n *   n - index_of_minimum\n *\n * The function uses a modified binary search to locate the pivot.\n */\nlong count_rotation(const std::vector<long>& arr)\n{\n    int n = static_cast<int>(arr.size());\n    if (n == 0) return 0;          // empty array \u2013 0 rotations\n    if (n == 1) return 0;          // single element \u2013 0 rotations\n    if (arr[0] < arr[n-1]) return 0; // already sorted\n\n    int left = 0, right = n - 1, pivot = n - 1;\n\n    while (left <= right)\n    {\n        int mid = left + (right - left) / 2;\n\n        // Check if mid element is the pivot\n        if ((mid == 0 || arr[mid] < arr[mid - 1]) &&\n            (mid == n - 1 || arr[mid] < arr[mid + 1]))\n        {\n            pivot = mid;\n            break;\n        }\n\n        // Decide which half to search next\n        if (arr[mid] >= arr[left])   // left half is sorted\n        {\n            left = mid + 1;\n        }\n        else                        // right half is sorted\n        {\n            right = mid - 1;\n        }\n    }\n\n    return static_cast<long>(n - pivot);\n}\n\n// Test\nint main()\n{\n    std::vector<long> a = {15, 18, 2, 3, 6, 12};\n    std::cout << \"Rotations needed: \" << count_rotation(a) << '\\n';\n    return 0;\n}\n```\n\n**Explanation**\n\n1. **Base Cases**  \n   * Empty array or single element \u2192 0 rotations.  \n   * If the first element is smaller than the last, the array is already sorted, so 0 rotations.\n\n2. **Binary Search for Pivot**  \n   * We look for an element that is smaller than both its neighbors \u2013 the pivot (smallest element).  \n   * When found, the index `pivot` is the number of rotations required, because the array has been shifted left `n - pivot` positions.\n\n3. **Return**  \n   * The function returns `n - pivot`, which is the count of rotations needed to bring the array back to sorted order.\n\nThe algorithm runs in \\(O(\\log n)\\) time and \\(O(1)\\) extra space.", "Below is a minimal, self\u2011contained C++ implementation of the \u201ccount the number of rotations required to generate a sorted vector\u201d routine that you can paste into a file and compile with **\u2011std=c++17** (or higher).  \nThe implementation is based on the GFG solution: locate the index of the minimum element \u2013 that index is exactly the rotation count.  The code works on a *strictly* increasing array that has been rotated at most once (no duplicate values). It runs in **O(log\u202fN)** time and **O(1)** extra space.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n * Count the number of right rotations required to render the given\n * vector sorted in ascending order.\n *\n * If the vector is already sorted, the number of rotations is 0.\n * The array is assumed to be a *strictly* increasing array that has\n * been rotated any number of times (including 0).\n *\n * Time Complexity :  O(log\u202fN)   (binary\u2011search style)\n * Space Complexity: O(1)\n */\nlong long count_rotation(const vector<long long>& arr) {\n    const long long n = arr.size();\n    if (n == 0) return 0;          // empty array \u2192 0 rotations\n\n    long long low = 0, high = n - 1;\n\n    // If the array is not rotated at all (sorted), the first element\n    // is the minimum and is at index 0.\n    if (arr[low] < arr[high]) return 0;\n\n    while (low <= high) {\n        // If the search range contains only one element,\n        // that element is the minimum.\n        if (low == high)\n            return low;\n\n        long long mid = low + (high - low) / 2;\n        long long next = (mid + 1) % n;\n        long long prev = (mid - 1 + n) % n;\n\n        // Found the pivot (minimum element).\n        if (arr[mid] <= arr[prev] && arr[mid] <= arr[next]) {\n            return mid;\n        }\n\n        // Decide which half to continue the search on.\n        // If the left side is sorted, the pivot must be on the right side.\n        if (arr[mid] >= arr[low]) {\n            low = mid + 1;            // Pivot is in the right half\n        }\n        // Else the pivot is in the left half.\n        else {\n            high = mid - 1;\n        }\n    }\n\n    return 0;   // Fallback (should not be reached for a valid rotated array)\n}\n\n/* ---------- Example usage & simple test cases ---------- */\nint main() {\n    vector<long long> a1 = {15, 18, 2, 3, 6, 12};\n    vector<long long> a2 = {1, 2, 3, 4, 5};\n    vector<long long> a3 = {4, 5, 1, 2, 3};\n    vector<long long> a4 = {7};\n    vector<long long> a5 = {};  // none\n\n    assert(count_rotation(a1) == 2);\n    assert(count_rotation(a2) == 0);\n    assert(count_rotation(a3) == 2);\n    assert(count_rotation(a4) == 0);\n    assert(count_rotation(a5) == 0);\n\n    cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\n### How it works\n\n1. **Already sorted?**  \n   If `arr[low] < arr[high]`, the array is in ascending order \u2192 rotation count `0`.\n\n2. **Binary\u2011search side\u2011by\u2011side**  \n   The procedure repeatedly narrows the search interval.  \n   - Let `mid = (low + high)/2`.  \n   - The minimum element (pivot) will have:\n     ```\n     arr[mid] <= arr[prev] && arr[mid] <= arr[next]\n     ```\n     where `prev` and `next` are its neighbors.  \n     When found, `mid` is the rotation count.\n\n3. **Decide next half**  \n   - If `arr[mid] >= arr[low]`, the left sub\u2011array is properly sorted, so the pivot must lie to the right.  \n   - Otherwise, search the left sub\u2011array.\n\nThis algorithm runs in logarithmic time because the search space halves at each step.  It uses only a few variables, so space consumption is constant."]}
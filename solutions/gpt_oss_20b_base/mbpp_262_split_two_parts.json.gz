{"completions": ["Here is a straightforward, self\u2011contained implementation that follows the specification.  \nThe function copies the original vector, splits it at position `L` (if `L` is larger than the size of the vector it simply returns the whole vector as the first part and an empty second part), and returns the two new vectors wrapped in a `std::tuple`.\n\n```cpp\n#include <algorithm>   // std::min\n#include <tuple>       // std::tuple\n#include <vector>\n#include <any>\n\n/**\n * Splits a `std::vector<std::any>` into two parts.\n *\n * @param list1 The original vector.\n * @param L     Length of the first part.  If L > list1.size(), the first part\n *              contains all elements and the second part is empty.\n *\n * @return a tuple where\n *     - first element is the first part (vector of size L or list1.size()),\n *     - second element is the remaining elements.\n */\nstd::tuple<std::vector<std::any>, std::vector<std::any>>\nsplit_two_parts(const std::vector<std::any>& list1, long L)\n{\n    // Clamp L to the range [0, list1.size()]\n    const std::size_t len = std::size_t(std::min(L, static_cast<long>(list1.size())));\n\n    // Build the two result vectors\n    std::vector<std::any> first(list1.begin(), list1.begin() + len);\n    std::vector<std::any> second(list1.begin() + len, list1.end());\n\n    return std::make_tuple(first, second);\n}\n```\n\n### Usage example\n\n```cpp\n#include <iostream>\n#include <iomanip>\n\nint main()\n{\n    std::vector<std::any> vec = {1, 2.5, std::string(\"hello\"), 42};\n\n    auto [first, second] = split_two_parts(vec, 2);\n\n    std::cout << \"First part: \";\n    for (const auto& el : first) {\n        if (el.type() == typeid(int))\n            std::cout << std::any_cast<int>(el) << ' ';\n        else if (el.type() == typeid(double))\n            std::cout << std::any_cast<double>(el) << ' ';\n        else if (el.type() == typeid(std::string))\n            std::cout << std::any_cast<std::string>(el) << ' ';\n    }\n\n    std::cout << \"\\nSecond part: \";\n    for (const auto& el : second) { /* Similar handling */ }\n\n    return 0;\n}\n```\n\nThe function returns a `std::tuple<std::vector<std::any>, std::vector<std::any>>` as requested.  If you really want to keep the return type as `std::any`, you can wrap the tuple again:\n\n```cpp\nstd::any split_two_parts_any(std::vector<std::any> list1, long L)\n{\n    return std::tuple<std::vector<std::any>, std::vector<std::any>>{ ... };\n}\n```\n\nBut the version returning a plain `std::tuple` is usually clearer and easier to use.", "Below is a minimal, self\u2011contained implementation that does exactly what the comment describes.  \nThe function:\n\n1. Accepts a `std::vector<std::any>` and a `long L`.  \n2. Splits the vector into two parts:  \n   - The first part contains the first **L** elements (or all of them if `L > size`).  \n   - The second part contains the remaining elements.  \n3. Returns the two parts in an `std::tuple<std::vector<std::any>, std::vector<std::any>>`.  \n\nAll of this is done using only standard C++17/20 facilities (no need for `bits/stdc++.h`). Feel free to drop it straight into your code or tweak it as needed.\n\n```cpp\n#include <vector>\n#include <any>\n#include <tuple>\n#include <algorithm>\n#include <stdexcept>\n\n/**\n * Splits the vector into two parts.\n *\n * @param list1  The input vector of std::any.\n * @param L      The desired size of the first part.\n *\n * @return A tuple containing:\n *         - The first part (size = L or list1.size() if L > list1.size()).\n *         - The second part (remaining elements).\n */\nstd::tuple<std::vector<std::any>, std::vector<std::any>>\nsplit_two_parts(std::vector<std::any> list1, long L)\n{\n    // guard against negative L\n    if (L < 0) {\n        throw std::invalid_argument(\"L must be non\u2011negative\");\n    }\n\n    // Determine split point, not exceeding list1.size()\n    size_t split = static_cast<size_t>(std::min<long>(L, static_cast<long>(list1.size())));\n\n    // Allocate the two result vectors\n    std::vector<std::any> firstPart;\n    std::vector<std::any> secondPart;\n\n    // Reserve capacity to avoid reallocations\n    firstPart.reserve(split);\n    secondPart.reserve(list1.size() - split);\n\n    // Copy elements into the two vectors\n    std::copy_n(list1.begin(), split, std::back_inserter(firstPart));\n    std::copy(list1.begin() + split, list1.end(), std::back_inserter(secondPart));\n\n    return {std::move(firstPart), std::move(secondPart)};\n}\n```\n\n### Usage example\n\n```cpp\nint main() {\n    std::vector<std::any> v = {1, 2.5, std::string(\"hello\"), 42};\n\n    auto [a, b] = split_two_parts(v, 2);\n\n    // a contains {1, 2.5}\n    // b contains {std::string(\"hello\"), 42}\n}\n```\n\nThis implementation is straightforward, follows the spirit of the original requirement, and is portable across standard C++ compilers.", "Here\u2019s a complete, self\u2011contained implementation that satisfies the requirements:\n\n```cpp\n#include <any>\n#include <cassert>\n#include <iostream>\n#include <tuple>\n#include <utility>\n#include <vector>\n\n/**\n * Split a vector into two parts.\n *\n * @param list1 the source vector \u2013 can hold any type (std::any).\n * @param L     desired length of the first part.\n *\n * @return      std::tuple containing two std::vector<std::any>\n *\n *               * 0\u2011th element   : first part (size = L, or the whole vector\n *                                    if L > list1.size())\n *               * 1\u2011st element   : second part (remaining elements)\n *\n * @note        The function performs bounds checking using `assert`\n *               so it should be compiled with asserts enabled when\n *               rigorous safety is required.  If you want it to be\n *               exception\u2011safe in all builds, replace the asserts with\n *               appropriate runtime checks.\n */\nstd::tuple<std::vector<std::any>, std::vector<std::any>>\nsplit_two_parts(const std::vector<std::any> &list1, long L)\n{\n    assert(L >= 0);          // L must be non\u2011negative\n\n    std::size_t n = list1.size();\n    std::size_t first_len = static_cast<std::size_t>(std::min<long>(L, static_cast<long>(n)));\n\n    // Create the first part\n    std::vector<std::any> first_part;\n    first_part.reserve(first_len);\n    for (std::size_t i = 0; i < first_len; ++i)\n        first_part.push_back(list1[i]);\n\n    // Create the second part\n    std::vector<std::any> second_part;\n    second_part.reserve(n - first_len);\n    for (std::size_t i = first_len; i < n; ++i)\n        second_part.push_back(list1[i]);\n\n    return std::make_tuple(std::move(first_part),\n                           std::move(second_part));\n}\n\n/* ----------  Example usage / basic test ---------- */\nint main()\n{\n    std::vector<std::any> v{1, 2.5, std::string(\"hello\"), 42, 3.14};\n\n    std::size_t L = 3;\n    auto [part1, part2] = split_two_parts(v, L);\n\n    std::cout << \"First part (\" << part1.size() << \" elements):\\n\";\n    for (const auto &elem : part1) {\n        if (elem.type() == typeid(int))\n            std::cout << std::any_cast<int>(elem) << '\\n';\n        else if (elem.type() == typeid(double))\n            std::cout << std::any_cast<double>(elem) << '\\n';\n        else if (elem.type() == typeid(std::string))\n            std::cout << std::any_cast<std::string>(elem) << '\\n';\n    }\n\n    std::cout << \"\\nSecond part (\" << part2.size() << \" elements):\\n\";\n    for (const auto &elem : part2) {\n        if (elem.type() == typeid(int))\n            std::cout << std::any_cast<int>(elem) << '\\n';\n        else if (elem.type() == typeid(double))\n            std::cout << std::any_cast<double>(elem) << '\\n';\n        else if (elem.type() == typeid(std::string))\n            std::cout << std::any_cast<std::string>(elem) << '\\n';\n    }\n}\n```\n\n### What the code does\n\n1. **Safety & Flexibility**  \n   * Uses `assert` to ensure `L` is non\u2011negative.  \n   * Handles the case where `L > list1.size()` by limiting the first part to the actual vector size.\n\n2. **Return Type**  \n   * A `std::tuple<std::vector<std::any>, std::vector<std::any>>` is returned, exactly matching the requested interface.\n\n3. **Performance**  \n   * Reserves the correct capacity for each output vector to avoid unnecessary reallocations.  \n   * Moves the vectors into the tuple, eliminating copies.\n\nFeel free to adapt the testing and error\u2011handling style to match the rest of your codebase."]}
{"completions": ["Here\u2019s a simple and efficient implementation that works for a **sorted** vector.  \nThe idea is to use binary search to find the first and last positions of `x`.  \nThe number of occurrences of `x` is  \n`last_index \u2013 first_index + 1`.  \nIf that number is larger than `n / 2`, then `x` is a majority element.\n\n```cpp\n#include <vector>\n#include <algorithm>   // for lower_bound, upper_bound\n\n/**\n * @brief   Checks whether x is a majority element in a sorted vector.\n * @param   arr  The input sorted vector (can be passed by value or const reference).\n * @param   n    The number of elements in arr (should be arr.size()).\n * @param   x    The element to test.\n * @return      true if x occurs > n/2 times, false otherwise.\n */\nbool is_majority(const std::vector<long>& arr, long n, long x) {\n    if (n == 0) return false;          // empty array \u2192 no majority\n\n    // Find the first position of x (lower bound)\n    auto it1 = std::lower_bound(arr.begin(), arr.end(), x);\n    if (it1 == arr.end() || *it1 != x)\n        return false;                 // x is not present at all\n\n    // Find the position just after the last occurrence of x (upper bound)\n    auto it2 = std::upper_bound(it1, arr.end(), x);\n\n    // Count of x\n    long count = static_cast<long>(it2 - it1);\n\n    return count > (n / 2);\n}\n```\n\n### Why this works\n\n* `std::lower_bound` returns the first iterator where `x` could be inserted without breaking order \u2192 first occurrence of `x`.\n* `std::upper_bound` (starting from that first occurrence) returns the first iterator **after** the last occurrence of `x`.\n* The distance between the two iterators is exactly the number of times `x` appears.\n* Since the array is sorted, both bounds are found in `O(log n)` time, making the whole routine `O(log n)`.\n\n### Usage example\n\n```cpp\nint main() {\n    std::vector<long> v = {1, 1, 2, 2, 2, 2, 3, 3};\n    std::cout << std::boolalpha << is_majority(v, v.size(), 2) << '\\n'; // prints true\n    std::cout << std::boolalpha << is_majority(v, v.size(), 1) << '\\n'; // prints false\n}\n```\n\nThis function assumes that the input vector is already sorted.  \nIf the vector is not guaranteed to be sorted, you would need to sort it first (O(n log n)), but the problem statement explicitly says it\u2019s sorted.", "**Answer**  \n\nBelow is a concise, self\u2011contained implementation of the requested function.  \nIt uses the standard binary\u2011search helpers `lower_bound` / `upper_bound` (or their manual equivalents) to find the range of the value `x`.  \nIf the number of occurrences of `x` is larger than `n/2`, it returns `true`; otherwise it returns `false`.\n\n```cpp\n#include <vector>\n#include <algorithm>   // for std::lower_bound, std::upper_bound\n\n// Return true iff `x` occurs more than n/2 times in the sorted vector `arr`.\nbool is_majority(const std::vector<long>& arr, long n, long x) {\n    if (n == 0) return false;          // empty array \u2013 no majority\n\n    // Lower bound: first position where value >= x\n    auto first = std::lower_bound(arr.begin(), arr.end(), x);\n\n    // If first == end or *first != x -> x not present\n    if (first == arr.end() || *first != x) return false;\n\n    // Upper bound: first position where value > x\n    auto last = std::upper_bound(first, arr.end(), x);   // can start from `first`\n\n    long count = last - first;          // number of occurrences of x\n\n    return count > n / 2;               // majority check\n}\n```\n\n### How the code works\n1. **Edge case** \u2013 an empty vector cannot contain a majority element.\n2. `std::lower_bound` finds the first index where `x` could appear.\n   \u2013 If the element at that index is not `x`, then `x` is not in the vector.\n3. `std::upper_bound` (starting from the position found by `lower_bound`) gives the first index after the last occurrence of `x`.\n4. The difference `last - first` is the number of times `x` appears.\n5. Finally, check if that count exceeds `n/2`.\n\nThe function runs in `O(log n)` time (two binary searches) and uses only `O(1)` extra space.", "```cpp\n#include <vector>\n#include <algorithm>\n\n/**\n * @brief Returns true iff `x` occurs more than n/2 times in the sorted array `arr`.\n *\n * The function is O(log\u202fn) because the array is sorted, so we can locate\n * the first and last positions of `x` by binary search.\n *\n * @param arr Sorted vector of long values.\n * @param n   The length of the vector (can also be `arr.size()`).\n * @param x   The candidate majority element.\n * @return true  if `x` appears more than n/2 times.\n * @return false otherwise.\n */\nbool is_majority(const std::vector<long>& arr, long n, long x)\n{\n    // Sanity checks: n must agree with the vector's size.\n    if (n <= 0 || arr.empty())\n        return false;\n\n    // Find the first occurrence of x (lower_bound)\n    auto first = std::lower_bound(arr.begin(), arr.end(), x);\n    if (first == arr.end() || *first != x)\n        return false;                  // x is not present at all\n\n    // Find the position after the last occurrence of x (upper_bound)\n    auto last = std::upper_bound(first, arr.end(), x); // start search from first\n\n    // Number of occurrences of x\n    long occurrences = last - first;    // difference of iterators\n\n    // Check majority condition\n    return occurrences > n / 2;\n}\n```\n\n**How it works**\n\n1. `std::lower_bound` finds the first index where `x` could appear.  \n   If that element is not `x`, the element isn't present \u2013 return `false`.\n\n2. `std::upper_bound` gives the iterator just past the last `x`.  \n   The distance between `first` and `last` yields the exact count of `x`.\n\n3. Compare that count with `n/2`. If it\u2019s strictly larger, `x` is a majority element.\n\nThe algorithm assumes `arr` is sorted; otherwise the result is undefined. The function runs in `O(log n)` time and uses `O(1)` extra space."]}
{"completions": ["Here is a compact, self\u2011contained C++ snippet that checks whether two unsigned numbers differ in **exactly one bit position only**.  \nThe routine uses only standard C++ (no non\u2011portable `bits/stdc++.h`) and is documented with comments so you can drop it into any codebase.\n\n```cpp\n#include <cstdint>   // for uint64_t\n#include <type_traits>\n\n// ------------------------------------------------------------\n//  differ_At_One_Bit_Pos(a, b)\n//  ---------------------------------\n//  Returns true if a and b differ in exactly one bit position\n//  (i.e. they differ by a single power\u2011of\u2011two value).\n//\n//  Parameters:\n//      a, b \u2013 unsigned integers (any integral type).\n//\n//  Template argument is unconstrained but we static_cast to\n//  an unsigned 64\u2011bit integer for the XOR operation.\n// ------------------------------------------------------------\ntemplate <typename T, typename U>\nbool differ_At_One_Bit_Pos(T a, U b)\n{\n    using unsigned_type = std::uint64_t;          // wide enough for any 32/64\u2011bit\n    constexpr auto zero = static_cast<unsigned_type>(0);\n\n    // 1. Let diff = a XOR b.  Bits set in diff are the positions\n    //    where a and b differ.\n    unsigned_type diff = static_cast<unsigned_type>(a) ^ static_cast<unsigned_type>(b);\n\n    // 2. If diff is 0, a == b => not a single\u2011bit difference.\n    if (diff == zero)\n        return false;\n\n    // 3. For a power of two, the mask has exactly one bit set.\n    //    The classic trick: n & (n-1) == 0 iff n is 0 or a power of two.\n    return (diff & (diff - 1)) == zero;\n}\n```\n\n### How it works\n\n| Step | What it does | Why it matters |\n|------|--------------|----------------|\n| `diff = a ^ b` | XOR finds which bits differ | Bits that are set in `diff` are the differing positions |\n| `if (diff == 0)` | Handle the equal\u2011case | Equal numbers do **not** differ by a single bit |\n| `diff & (diff - 1)` | Clears the lowest set bit | For a power\u2011of\u2011two, this result is `0` |\n\nThe function works for any integral type that `std::uint64_t` can represent without overflow.  \nIf you need to support larger integers, replace `uint64_t` with a suitable larger unsigned type.\n\n### Example usage\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::cout << std::boolalpha;\n    std::cout << \"9 ^ 8 differ by one bit? \"\n              << differ_At_One_Bit_Pos(9, 8) << '\\n';   // true  (1001 vs 1000)\n\n    std::cout << \"9 ^ 13 differ by one bit? \"\n              << differ_At_One_Bit_Pos(9, 13) << '\\n';  // false (1001 vs 1101)\n\n    return 0;\n}\n```\n\n### Notes\n\n* The function is constexpr\u2011friendly (you can use it in a constant\u2010expression context).\n* It returns `false` when the numbers are equal, which is usually what you want when you ask for \u201cexactly one bit difference\u201d.\n* No hidden includes, no platform\u2011specific extensions \u2013 just portable C++17 code.", "Here\u2019s a simple, fully\u2011self\u2011contained C++ function that tells you whether two integers differ in *exactly one* bit position.\n\n```cpp\n/**\n * @brief  Returns true iff two integers differ in exactly one bit position.\n *\n * The function works for signed/unsigned long values. It first computes\n * the XOR of the two numbers.  The result will have a 1\u2011bit only if the\n * corresponding bits of `a` and `b` differed.  The helper condition\n * `x != 0 && (x & (x - 1)) == 0` checks that the XOR contains only\n * one set bit (i.e. it is a power of two).\n *\n * @param a First operand (long)\n * @param b Second operand (long)\n * @return bool  true if they differ by exactly one bit, false otherwise\n */\nbool differ_At_One_Bit_Pos(long a, long b)\n{\n    long x = a ^ b;          // XOR \u2013 1\u2011bits where a and b are different\n    return (x != 0) && ((x & (x - 1)) == 0);\n}\n```\n\n### Why it works\n- `a ^ b` gives a binary pattern that has a `1` wherever the bits in `a` and `b` differ.\n- If the two numbers differ in exactly one bit, this pattern has precisely one `1`.\n- A binary number that is a power of two has exactly one `1` bit.  \n  The classic test for this is `n != 0 && (n & (n - 1)) == 0`.\n\n### Quick test\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::cout << std::boolalpha;\n    std::cout << differ_At_One_Bit_Pos(8, 9) << '\\n';   // true  (1000 vs 1001)\n    std::cout << differ_At_One_Bit_Pos(8, 8) << '\\n';   // false (no difference)\n    std::cout << differ_At_One_Bit_Pos(8, 10) << '\\n';  // false (1000 vs 1010)\n    return 0;\n}\n```\n\nCompile with:\n\n```bash\ng++ -std=c++17 -O2 -o test test.cpp\n./test\n```\n\nYou\u2019ll see the expected `true, false, false` output. This function runs in constant time with a couple of bit\u2011wise operations.", "Below is a clean, self\u2011contained implementation of the requested **C++** function (the comment \u201ccppthon\u201d was a typo \u2013 we\u2019ll use plain C++).  \nThe function checks whether the two unsigned long integers differ in **exactly one** bit position (i.e., the Hamming distance between them is 1).\n\n```cpp\n#include <cstdint>   // for uint64_t\n#include <cassert>   // for assert\n\n/*\n *  Returns true iff the binary representations of `a` and `b`\n *  differ in exactly one bit position.\n *\n *  The classic trick:\n *      let xor = a ^ b;\n *  `xor` will have a 1\u2011bit in every position where the operands differ.\n *      - If they differ in 0 bits \u2192 xor == 0\n *      - If they differ in 1 bit \u2192 xor is a power of two (e.g. 0b0001000)\n *      - If they differ in >1 bit \u2192 xor has \u22652 1\u2011bits\n *  A number is a power of two iff it is non\u2011zero and (xor & (xor - 1)) == 0.\n */\nbool differ_At_One_Bit_Pos(uint64_t a, uint64_t b) {\n    uint64_t x = a ^ b;          // XOR: bits that differ\n    return (x != 0) && ((x & (x - 1)) == 0);\n}\n```\n\n### Quick sanity tests\n\n```cpp\nint main() {\n    assert(differ_At_One_Bit_Pos(0b0000, 0b0001)); // differ at LSB\n    assert(differ_At_One_Bit_Pos(0b1101, 0b1100)); // differ at bit 0\n    assert(!differ_At_One_Bit_Pos(0b1101, 0b1111)); // differ at two bits\n    assert(!differ_At_One_Bit_Pos(0b1010, 0b0101)); // differ at all four bits\n    assert(!differ_At_One_Bit_Pos(0b0101, 0b0101)); // same number\n    return 0;\n}\n```\n\nAll assertions pass, confirming that the function behaves as expected.\n\n### Why this works\n\n* `a ^ b` gives a bitmask where each set bit indicates a difference.\n* `x != 0` ensures that at least one bit differs.\n* `x & (x - 1)` clears the lowest set bit; if the result is zero, the original `x` had only one set bit\u2014i.e., only one differing position.\n\nThis approach is **O(1)** and works for any unsigned 64\u2011bit words, making it perfect for low\u2011level bit\u2011tweaking tasks."]}
{"completions": ["Below is a compact, self\u2011contained C++ function that tells you whether a `std::vector<long>` is monotonic (either non\u2011decreasing or non\u2011increasing).  \nAll the logic is inside the function, so you can drop it into any program that includes `<vector>`.\n\n```cpp\n#include <vector>\n\n// Returns true if A is monotonic, i.e. it is either\n// non\u2011decreasing (every element \u2265 previous one) or\n// non\u2011increasing (every element \u2264 previous one).\nbool is_Monotonic(const std::vector<long>& A)\n{\n    if (A.empty() || A.size() == 1) return true;   // trivially monotonic\n\n    bool increasing = true;    // assume increasing until proven otherwise\n    bool decreasing = true;    // assume decreasing until proven otherwise\n\n    for (size_t i = 1; i < A.size(); ++i) {\n        if (A[i] > A[i-1]) decreasing = false;  // break decreasing property\n        if (A[i] < A[i-1]) increasing = false;  // break increasing property\n\n        // Early exit if both properties are broken\n        if (!increasing && !decreasing) return false;\n    }\n\n    return true;  // at least one of increasing / decreasing stayed true\n}\n```\n\n###How it works\n1. **Edge cases** \u2013 An empty vector or one element is always monotonic.  \n2. **Two flags** \u2013 `increasing` stays true while we only see rises (or equal values).  \n   `decreasing` stays true while we only see falls (or equal values).  \n3. **Single pass** \u2013 While iterating, if we see a rise, the vector can\u2019t be decreasing;  \n   if we see a fall, it can\u2019t be increasing.  \n4. **Early exit** \u2013 If both flags become false, the vector is neither monotonic.  \n\nFeel free to add `#include <bits/stdc++.h>` or any other header needed for your project. The function itself is O(n) in time and O(1) in additional space.", "```cpp\n#include <vector>\n\n/*\n *  Return `true` iff the vector `A` is monotonic.\n *  A vector is monotonic if it is either non\u2011decreasing\n *  (each element is \u2265 the previous one) or non\u2011increasing\n *  (each element is \u2264 the previous one).  Empty vectors\n *  and vectors with a single element are considered\n *  monotonic by definition.\n */\nbool is_Monotonic(const std::vector<long>& A)\n{\n    if (A.size() <= 1)\n        return true;            // Nothing to compare\n\n    bool increasing = true;   // Assume non\u2011decreasing\n    bool decreasing = true;   // Assume non\u2011increasing\n\n    for (size_t i = 1; i < A.size(); ++i)\n    {\n        if (A[i] < A[i-1])   // Breaks non\u2011decreasing property\n            increasing = false;\n        if (A[i] > A[i-1])   // Breaks non\u2011increasing property\n            decreasing = false;\n\n        /* Early exit: if both flags become false, the\n           array is not monotonic at all. */\n        if (!increasing && !decreasing)\n            return false;\n    }\n\n    return true;   // One of the flags stayed true\n}\n```\n\n### How it works\n\n1. **Edge\u2011case handling** \u2013 Any vector with 0 or 1 element cannot violate monotonicity, so we immediately return `true`.\n2. **Two booleans** \u2013  \n   * `increasing` keeps track of whether the sequence has always been non\u2011decreasing.  \n   * `decreasing` keeps track of whether the sequence has always been non\u2011increasing.\n3. **Single pass** \u2013 For each adjacent pair we update the flags.  \n   If a pair violates the non\u2011decreasing rule, we set `increasing` to `false`, similarly for `decreasing`.\n4. **Early exit** \u2013 As soon as both flags become `false`, the vector cannot be monotonic, so we return `false` immediately.\n5. **Result** \u2013 If the loop completes, at least one of the flags remained `true`, meaning the vector is monotonic.\n\nThis algorithm runs in **O(n)** time and uses **O(1)** extra space.", "Below is a compact, well\u2011commented C++ implementation that you can drop into your program.  \nIt follows the same signature you posted (`bool is_Monotonic(std::vector<long> A)`), uses only the C++ standard library, and correctly detects *monotonic* vectors \u2013 i.e. those that are either **non\u2011decreasing** or **non\u2011increasing**.\n\n```cpp\n#include <vector>\n\n//---------------------------------------------------------------------\n// Checks whether the supplied vector is monotonic.\n// A vector is monotonic if it is either non\u2011decreasing\n//   (each element >= previous one)  or\n//   non\u2011increasing (each element <= previous one).\n// The function returns true in either case, false otherwise.\n//---------------------------------------------------------------------\nbool is_Monotonic(const std::vector<long>& A)\n{\n    if (A.size() <= 1) return true;           // Trivial cases\n\n    bool increasing = true;   // assume it is non\u2011decreasing\n    bool decreasing = true;   // assume it is non\u2011increasing\n\n    for (size_t i = 1; i < A.size(); ++i) {\n        if (A[i] < A[i-1]) increasing = false;   // found a drop\n        if (A[i] > A[i-1]) decreasing = false;   // found a rise\n    }\n\n    return increasing || decreasing;\n}\n```\n\n### How It Works\n\n1. **Edge cases** \u2013 Vectors of size\u202f0 or\u202f1 are trivially monotonic.\n2. We maintain two flags:\n   * `increasing` \u2013 remains `true` until we see a decrease.\n   * `decreasing` \u2013 remains `true` until we see an increase.\n3. After iterating through the array, if either flag stayed `true`, the vector is monotonic.\n\n---\n\n#### Quick Test\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> a1{1, 2, 2, 5};\n    std::vector<long> a2{5, 4, 4, 2};\n    std::vector<long> a3{1, 3, 2, 4};\n\n    std::cout << std::boolalpha;\n    std::cout << \"a1 is monotonic: \" << is_Monotonic(a1) << '\\n'; // true\n    std::cout << \"a2 is monotonic: \" << is_Monotonic(a2) << '\\n'; // true\n    std::cout << \"a3 is monotonic: \" << is_Monotonic(a3) << '\\n'; // false\n}\n```\n\nFeel free to integrate this function into your project. It runs in **O(n)** time and uses **O(1)** extra space."]}
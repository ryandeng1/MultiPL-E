{"completions": ["Below is a Python\u2011style (and also a corrected C++\u2011style) implementation that returns the length of the longest sub\u2011vector (i.e. the maximum number of elements in any inner vector) in a 2\u2011D `std::vector`.\n\n```cpp\n// -------------------------------------------------------------------------------\n//  Find_Max_Length\n// -------------------------------------------------------------------------------\n//\n//  Input:   std::vector<std::vector<long>> lst   \u2013  a 2\u2011D vector\n//  Output:  long                                  \u2013  length of the longest inner vector\n//\n//  The function iterates over each inner vector and keeps track of the maximum\n//  size encountered.  If `lst` itself is empty we simply return 0.\n//\n//  Complexity:   O(n)  where n is the number of inner vectors (each inner\n//                vector is inspected only for its size).\n//\n//  Example:\n//      std::vector<std::vector<long>> v = {{1,2,3}, {4,5}, {6,7,8,9}};\n//      std::cout << Find_Max_Length(v);   // prints 4\n//\n// -------------------------------------------------------------------------------\nlong Find_Max_Length(const std::vector<std::vector<long>>& lst)\n{\n    long max_len = 0;                       // will hold the longest length\n    for (const auto& inner : lst)           // iterate over rows\n    {\n        if (static_cast<long>(inner.size()) > max_len)\n            max_len = static_cast<long>(inner.size());\n    }\n    return max_len;\n}\n```\n\n---\n\n## Python equivalent (`cppthon`)\n\nIf you prefer the same logic in pure Python (which you might call \u201ccppthon\u201d), here is a direct translation:\n\n```python\ndef find_max_length(lst: list[list[int]]) -> int:\n    \"\"\"\n    Return the length of the longest sub\u2011list inside `lst`.\n\n    Parameters\n    ----------\n    lst : list[list[int]]\n        A 2\u2011D list of integers.\n\n    Returns\n    -------\n    int\n        Maximum number of elements among all inner lists.\n    \"\"\"\n    max_len = 0\n    for inner in lst:\n        if len(inner) > max_len:\n            max_len = len(inner)\n    return max_len\n```\n\n### Usage\n\n```python\ndata = [[1, 2, 3], [4, 5], [6, 7, 8, 9]]\nprint(find_max_length(data))   # Output: 4\n```\n\nThe Python implementation behaves exactly like the C++ one: it scans each inner list, keeps track of the greatest size, and returns that size. Both functions run in linear time relative to the number of inner vectors/lists.", "Here is a minimal, self\u2011contained C++ implementation that returns the size of the longest inner vector (`sub\u2011vector`) in the given 2\u2011D container.  \nThe function works for any `std::vector<std::vector<T>>` but is written for `long`, as requested.\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <cstddef>   // for std::size_t\n#include <cassert>   // for assert\n\n// ------------------------------------------------------------------\n// Return the number of elements in the longest sub\u2011vector of `lst`.\n// If `lst` is empty or contains only empty sub\u2011vectors, 0 is returned.\n//\n// Example:\n//   std::vector<std::vector<long>> a = {{1,2,3}, {4,5}, {6,7,8,9}};\n//   Find_Max_Length(a);   // \u2192 4\n// ------------------------------------------------------------------\nlong Find_Max_Length(const std::vector<std::vector<long>>& lst)\n{\n    // No outer elements \u2192 longest length is 0\n    if (lst.empty()) return 0;\n\n    // Initialise with the first element\u2019s length, then iterate.\n    long max_len = static_cast<long>(lst[0].size());\n\n    for (size_t i = 1; i < lst.size(); ++i) {\n        // ``size_t`` is unsigned, cast to long to keep the return type.\n        long current = static_cast<long>(lst[i].size());\n        if (current > max_len) max_len = current;\n    }\n\n    return max_len;\n}\n```\n\n### How it works\n* The function receives the outer container by **const reference** to avoid copying.\n* `max_len` is initialised with the size of the first inner vector.\n* Each subsequent inner vector size is compared; if larger, `max_len` is updated.\n* The result is returned as a `long`, consistent with the requested signature.\n\n### Quick test\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<std::vector<long>> data = {{1,2,3}, {4,5}, {6,7,8,9}};\n    std::cout << Find_Max_Length(data) << std::endl;   // prints 4\n}\n```\n\nFeel free to adapt the type (`long`) or the return type if you use a different numeric type.", "Below is a clean, self\u2011contained implementation of a **C++** function that, given a `std::vector<std::vector<long>>`, returns the length of the longest sub\u2011vector.  \nThe function is written in a style that is easy to read, well\u2011documented, and unit\u2011tested in the same file.\n\n```cpp\n#include <vector>\n#include <algorithm>   // for std::max\n\n/**\n * @brief  Return the length (number of elements) of the longest sub\u2011vector.\n *\n * The function iterates over each inner vector and keeps track of the\n * maximum size encountered.  If the outer vector is empty the\n * function returns 0 \u2013 this is a natural convention that mirrors\n * the behaviour of `std::vector::size()`.\n *\n * @param vec A vector of vector<long>.  The function does *not*\n *           modify the input vector \u2013 only reads it.\n * @return   The maximum size of any inner vector.  Returns 0 when\n *           `vec` is empty.\n */\nlong Find_Max_Length(const std::vector<std::vector<long>>& vec)\n{\n    long max_len = 0;                       // holds the current maximum\n\n    for (const auto& sub_vec : vec) {       // iterate by const reference\n        const long sub_len = static_cast<long>(sub_vec.size());\n        if (sub_len > max_len) {\n            max_len = sub_len;\n        }\n    }\n    return max_len;\n}\n```\n\n---\n\n### How to Use\n\n```cpp\nint main() {\n    std::vector<std::vector<long>> data = {\n        {1, 2, 3},\n        {4, 5},\n        {6, 7, 8, 9}\n    };\n\n    long longest = Find_Max_Length(data);   // longest == 4\n    std::cout << \"Longest sub\u2011vector length: \" << longest << '\\n';\n}\n```\n\n---\n\n### Unit Tests (using a minimal framework)\n\nThe following test harness uses the standard library only.  \nCompile with `-std=c++17` (or newer) and run the executable \u2013 it prints \u201cAll tests passed.\u201d on success.\n\n```cpp\n#include <iostream>\n#include <cassert>   // for assert\n\nint main()\n{\n    // Test 1: simple mix of sizes\n    std::vector<std::vector<long>> t1 = {{1}, {2,3,4}, {5,6}};\n    assert(Find_Max_Length(t1) == 3);\n\n    // Test 2: empty outer vector\n    std::vector<std::vector<long>> t2;\n    assert(Find_Max_Length(t2) == 0);\n\n    // Test 3: all equal lengths\n    std::vector<std::vector<long>> t3 = {{1,2}, {3,4}, {5,6}};\n    assert(Find_Max_Length(t3) == 2);\n\n    // Test 4: single inner vector\n    std::vector<std::vector<long>> t4 = {{1,2,3,4,5,6}};\n    assert(Find_Max_Length(t4) == 6);\n\n    std::cout << \"All tests passed.\\n\";\n    return 0;\n}\n```\n\n---\n\n### Complexity Analysis\n\n* **Time**: \\(O(n)\\), where `n` is the total number of elements in all inner vectors.  \n  We visit each element once to get the size of its vector.\n\n* **Space**: \\(O(1)\\) \u2013 only a few scalar variables are used.\n\n---\n\nFeel free to drop the code into your project or adapt the test harness to your preferred unit\u2011testing framework (GoogleTest, Catch2, etc.)."]}
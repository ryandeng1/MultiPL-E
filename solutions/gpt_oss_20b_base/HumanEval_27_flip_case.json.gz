{"completions": ["```cpp\n#include <string>\n#include <cctype>\n\nstd::string flip_case(std::string s) {\n    for (char &c : s) {\n        if (std::islower(static_cast<unsigned char>(c))) {\n            c = static_cast<char>(std::toupper(static_cast<unsigned char>(c)));\n        } else if (std::isupper(static_cast<unsigned char>(c))) {\n            c = static_cast<char>(std::tolower(static_cast<unsigned char>(c)));\n        }\n        // non\u2011alphabetic characters are left untouched\n    }\n    return s;\n}\n```\n\nThe function iterates over each character.  \n* If the character is a lowercase letter it is converted to the corresponding uppercase letter using `std::toupper`.  \n* If it is an uppercase letter it is converted to lowercase using `std::tolower`.  \nAll other characters (digits, punctuation, spaces, etc.) are left unchanged.", "Below is a complete, self\u2011contained implementation of `flip_case` in C++.  \nIt uses only standard library headers (no need for `<bits/stdc++.h>` which is non\u2011portable).  \nThe function loops over each character, flips its case using `std::isupper/islower`, and assembles the result in a new string.\n\n```cpp\n#include <string>\n#include <cctype>   // for std::isupper, std::islower\n#include <cassert>  // for assert (used in the test)\n\n/// Flip the case of every alphabetic character in a string.\n/// Lower\u2011case \u2192 Upper\u2011case, Upper\u2011case \u2192 Lower\u2011case.\n/// Non\u2011alphabetic characters are left unchanged.\n///\n/// @param s Input string.\n/// @return A new string with the case of each letter flipped.\nstd::string flip_case(const std::string &s)\n{\n    std::string result;\n    result.reserve(s.size());          // avoid repeated reallocations\n\n    for (char ch : s) {\n        if (std::islower(static_cast<unsigned char>(ch))) {\n            result.push_back(std::toupper(static_cast<unsigned char>(ch)));\n        } else if (std::isupper(static_cast<unsigned char>(ch))) {\n            result.push_back(std::tolower(static_cast<unsigned char>(ch)));\n        } else {\n            result.push_back(ch);      // unchanged\n        }\n    }\n    return result;\n}\n\n// Simple test harness\nint main()\n{\n    assert(flip_case(\"Hello\") == \"hELLO\");\n    assert(flip_case(\"hELLO\") == \"Hello\");\n    assert(flip_case(\"123 abc XYZ!\") == \"123 ABC xyz!\");\n    assert(flip_case(\"\") == \"\");\n    return 0;  // success\n}\n```\n\n### Why this version?\n\n* **Portability** \u2013 uses only `<string>`, `<cctype>`, and `<cassert>`.\n* **Safety** \u2013 casts `char` to `unsigned char` before calling `std::isupper/islower/toupper/tolower` to avoid undefined behaviour on signed characters outside the ASCII range.\n* **Efficiency** \u2013 pre\u2011allocates the result string with `reserve(s.size())`.\n* **Clarity** \u2013 handles non\u2011alphabetic characters explicitly, making the intent obvious.", "Here\u2019s a simple implementation of `flip_case` that uses the standard library\u2019s `std::toupper` and `std::tolower` functions. It iterates over each character in the input string and flips its case.\n\n```cpp\n#include <cctype>\n#include <string>\n#include <algorithm>\n\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case(\"Hello\")   // returns \"hELLO\"\nstd::string flip_case(std::string str) {\n    std::transform(str.begin(), str.end(), str.begin(),\n        [](unsigned char ch) {\n            return std::isupper(ch) ? std::tolower(ch) : std::toupper(ch);\n        });\n    return str;\n}\n```\n\n### How it works\n1. **`std::transform`** \u2013 Applies the provided lambda to every character, modifying the string in place.\n2. **Lambda** \u2013  \n   * If the character is uppercase (`std::isupper`), it is converted to lowercase (`std::tolower`).  \n   * Otherwise (`else`), it is converted to uppercase (`std::toupper`).\n3. **Return** \u2013 The modified string is returned.\n\nThis solution is concise, uses only standard facilities, and handles all printable characters correctly. If you need to preserve non\u2011alphabetic characters unchanged (they will be returned unchanged because the corresponding `tolower`/`toupper` calls simply return the same character), no extra logic is necessary."]}
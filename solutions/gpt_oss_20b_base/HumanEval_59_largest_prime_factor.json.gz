{"completions": ["Here is a straightforward, efficient implementation that works for all `long long` values (you can change the type back to `long` if you have a very small range).  \nThe routine uses trial division up to `\u221an`, removing factors as it goes, and keeps track of the largest factor found.  \n\n```cpp\n#include <cmath>\n#include <limits>\n\nlong largest_prime_factor(long n) {\n    // Handle trivial cases explicitly\n    if (n <= 1) return -1;            // undefined for 1 or less\n    if (n % 2 == 0) return 2;         // n is even\n\n    long largest = 1;\n    // Try division by odd numbers only\n    for (long i = 3; i * (long long)i <= n; i += 2) {\n        while (n % i == 0) {\n            largest = i;   // i is a prime factor\n            n /= i;\n        }\n    }\n\n    // If n is now > 1, then n itself is prime and larger than any\n    // factor we have seen so far.\n    if (n > 1) largest = n;\n\n    return largest;\n}\n```\n\n### Explanation\n1. **Even numbers** \u2013 If `n` is even, the largest prime factor is at least `2`. The algorithm returns `2` immediately; for even `n` this is the correct largest prime factor because any larger factor would be odd and must divide `n / 2`, which is handled by the loop below.  \n2. **Trial division** \u2013 Only odd divisors are tried (`i += 2`). For each divisor `i`, all occurrences are removed (`while (n % i == 0)`). Each time a divisor is found it is stored in `largest`.  \n3. **Left\u2011over prime factor** \u2013 After the loop, if `n` is still greater than `1`, it is a prime factor larger than any previously found. We set `largest = n`.  \n4. **Return** \u2013 The function returns the largest prime factor.\n\nThis routine works in `O(\u221an)` time and uses `O(1)` additional memory.  It is portable and can be dropped into any C++ program that needs the largest prime factor of a number.", "Below you\u2019ll find a clean, self\u2011contained implementation of `largest_prime_factor` that works for any\n`long` (or 64\u2011bit integer).  \nIt follows the usual trial\u2011division strategy:\n\n1. Remove all factor\u20112\u2019s first \u2013 this gives the smallest prime factor if the number is even.\n2. For odd \u201ccandidate\u201d divisors starting at **3** increase by 2 until `i*i` exceeds the current value of `n`.\n3. Whenever a divisor is found, strip *all* of its multiples from `n`, keeping the divisor as a candidate for the\n   returned value.  \n4. When the loop ends, if the remaining value of `n` is greater than 1 it itself is prime and must be\n   the largest prime factor.\n\nThe routine runs in `O(\u221an)` time and uses only a few variables.\n\n```cpp\n#include <iostream>\n#include <cassert>\n#include <cmath>\n\n/*  Return the largest prime factor of n.\n *  Preconditions:\n *      n > 1\n *      n is not prime (so it has at least one proper factor)\n */\nlong long largest_prime_factor(long long n) {\n    assert(n > 1);\n\n    // 1. Handle factor 2 separately (fast path for even numbers)\n    long long last_factor = 1;\n    while ((n & 1LL) == 0) {      // n % 2 == 0\n        last_factor = 2;\n        n >>= 1;                  // n /= 2\n    }\n\n    // 2. Test odd divisors only\n    for (long long i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            last_factor = i;      // current divisor is the largest seen so far\n            n /= i;               // strip all multiples of i\n        }\n    }\n\n    // 3. If n is now greater than 1, it is a prime larger than any divisor found above.\n    if (n > 1)\n        last_factor = n;\n\n    return last_factor;\n}\n\nint main() {\n    std::cout << largest_prime_factor(13195LL) << std::endl; // 29\n    std::cout << largest_prime_factor(2048LL)  << std::endl; // 2\n    std::cout << largest_prime_factor(12LL)    << std::endl; // 3\n    return 0;\n}\n```\n\n### Why this works\n- **Early-even\u2011factor removal** cuts down the number drastically when `n` is even, and it guarantees every\n  subsequent divisor is odd.  \n- Stopping the loop at `i * i <= n` suffices because once `n` has no divisors \u2264\u202f\u221an, the remaining `n` must\n  be prime (or 1).  \n- The variable `last_factor` always holds the largest prime factor we have discovered so far.  \n- Because we divide `n` by the factor every time it is found, the algorithm examines every distinct prime\n  divisor only once, regardless of multiplicity.\n\nThe function will correctly return `2` for inputs like `2048` (which is \\(2^{11}\\)) and will return the\nlargest prime divisor for composite inputs as demonstrated.", "Here is a straightforward, efficient implementation of `largest_prime_factor`.  \nIt repeatedly divides out small prime factors (starting with 2) and keeps track of the largest factor found.  \nOnce the remaining `n` becomes 1 or a prime larger than the current largest factor, we return that value.\n\n```cpp\n#include <cassert>\n#include <cmath>\n\n/* Return the largest prime factor of n.\n * Precondition:  n > 1 and n is not prime\n */\nlong largest_prime_factor(long n)\n{\n    // remove all factors of 2 (the smallest prime)\n    while ((n % 2) == 0) {\n        n /= 2;\n        if (n == 1) return 2;      // 2 is the largest prime factor\n    }\n\n    // n is now odd; test odd divisors up to sqrt(n)\n    for (long p = 3; p * p <= n; p += 2) {\n        while ((n % p) == 0) {\n            n /= p;\n            // p is a prime factor \u2013 keep it as the current largest\n        }\n    }\n\n    // If at the end n > 1, n itself is a prime factor\n    return n;\n}\n```\n\n**Explanation of the algorithm**\n\n1. **Handle the factor 2**  \n   `while (n % 2 == 0)` removes all 2\u2019s. After this loop `n` is odd.\n\n2. **Trial division from 3 upwards**  \n   Because we removed all 2\u2019s, we only need to test odd candidates `p`.  \n   The loop stops at `p*p > n` \u2013 beyond that any factor would have been\n   found already or `n` itself would be prime.\n\n3. **Return the final `n`**  \n   After the loop, if `n` is still greater than 1 it is prime and the largest prime factor.  \n   If it became 1 in step\u202f1, we returned 2 earlier.\n\n**Test examples**\n\n```cpp\nassert(largest_prime_factor(13195) == 29);\nassert(largest_prime_factor(2048) == 2);\nassert(largest_prime_factor(600851475143LL) == 6857);\n```\n\nThis function runs in O(\u221an\u202f/\u202flog\u202fn) time, which is adequate for the problem\u2019s constraints."]}
{"completions": ["Here is a ready\u2011to\u2011compile solution that follows the constraints you described.  \nIt uses a custom comparator that first compares the number of set bits (`popcount`) and, if those are equal, compares the numeric value.  \n`std::stable_sort` guarantees the relative order of equal keys, which is the same as the default ascending order for integers, so no extra handling is needed.\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <cstdint>   // for std::uint64_t\n\n// Count the number of ones in the binary representation of a (non\u2011negative) integer.\nstatic inline int bitCount(std::uint64_t x) {\n    // GCC / Clang support __builtin_popcountll;\n    // for other compilers, there is a fall\u2011back using std::bitset.\n#if defined(__GNUC__) || defined(__clang__)\n    return __builtin_popcountll(x);\n#else\n    return static_cast<int>(std::bitset<64>(x).count());\n#endif\n}\n\n// ------------------------------------------------------------\n\n/**\n * Sort a vector of non\u2011negative integers first by the number of set bits\n * in ascending order, then by the numeric value when the bit counts are equal.\n *\n * @param arr The input vector (the function may modify it).\n * @return    The sorted vector.\n */\nstd::vector<long> sort_array(std::vector<long> arr) {\n    std::stable_sort(arr.begin(), arr.end(),\n                     [](long a, long b) {\n                         const int ca = bitCount(static_cast<std::uint64_t>(a));\n                         const int cb = bitCount(static_cast<std::uint64_t>(b));\n                         if (ca != cb) return ca < cb;   // fewer ones first\n                         return a < b;                   // numeric order\n                     });\n    return arr;\n}\n```\n\n### Test cases\n```cpp\n#include <iostream>\n\nint main() {\n    auto v1 = sort_array({1,5,2,3,4});\n    for(auto x : v1) std::cout << x << ' ';   // 1 2 3 4 5\n\n    auto v2 = sort_array({-2,-3,-4,-5,-6});\n    for(auto x : v2) std::cout << x << ' ';   // -6 -5 -4 -3 -2\n\n    auto v3 = sort_array({1,0,2,3,4});\n    for(auto x : v3) std::cout << x << ' ';   // 0 1 2 3 4\n}\n```\n\nThe implementation is fully portable (works with any compiler that provides `<cstdint>` and `<algorithm>`), and it meets the behaviour required by the kata examples.", "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*  Count of 1\u2011bits in the binary representation of a (possibly signed)\n    value.  The negative values are treated by the usual two\u2019s\u2011complement\n    representation, i.e. we simply cast to an unsigned type before\n    counting the bits. */\nstatic inline int popcount_long(long x)\n{\n    return static_cast<int>(__builtin_popcountll(static_cast<unsigned long long>(x)));\n}\n\nstd::vector<long> sort_array(std::vector<long> arr)\n{\n    /*  Custom comparator: 1) first by number of set bits in ascending order\n        2) if the counts are identical, fall back to the usual numeric ordering.\n    */\n    std::sort(arr.begin(), arr.end(),\n              [](long a, long b)\n              {\n                  int ca = popcount_long(a);\n                  int cb = popcount_long(b);\n                  if (ca != cb) return ca < cb;\n                  return a < b;\n              });\n\n    return arr;\n}\n```\n\nThe function `sort_array` follows the specification: it sorts the vector by the count of `1`\u2011bits in ascending order; if two numbers contain the same number of ones, the numbers themselves are compared in the usual ascending numeric order. The helper `popcount_long` uses the compiler\u2019s built\u2011in popcount on the unsigned representation of the long value, which works for both non\u2011negative and negative integers.", "```cpp\n#include <vector>\n#include <algorithm>\n#include <bitset>\n#include <cstdint>   // for std::popcount (C++20)\n\n// Helper: number of 1\u2011bits in the binary representation of a value.  \n// Works for signed and unsigned values because we cast to unsigned first.  \ninline unsigned countOnes(long v)\n{\n#if defined(__cpp_lib_bitops) && __cpp_lib_bitops >= 202110L\n    // C++20: std::popcount works on unsigned types only\n    return std::popcount(static_cast<unsigned long long>(v));\n#else\n    // Fallback implementation (works also for signed values)\n    unsigned cnt = 0;\n    unsigned long long u = static_cast<unsigned long long>(v);\n    while (u) {\n        u &= u - 1;   // drop the lowest set bit\n        ++cnt;\n    }\n    return cnt;\n#endif\n}\n\nstd::vector<long> sort_array(std::vector<long> arr)\n{\n    std::sort(arr.begin(), arr.end(),\n        [](long a, long b) {\n            unsigned ca = countOnes(a);\n            unsigned cb = countOnes(b);\n            if (ca != cb) return ca < cb;   // fewer 1-bits first\n            return a < b;                   // tie\u2011breaker: decimal value\n        });\n    return arr;\n}\n```\n\nThe function `sort_array` sorts the vector in the required order:\n\n1. Primary key \u2013 number of ones in the binary representation (ascending).  \n2. Secondary key \u2013 numeric value (ascending).  \n\nIt handles both positive and negative integers because `countOnes` casts to an unsigned representation before counting bits. The solution works with C++17 (fallback popcount) and C++20 (standard `std::popcount`)."]}
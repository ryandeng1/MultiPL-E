{"completions": ["```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// @brief  Determines whether there exists a *nested* subsequence of brackets.\n///\n/// A subsequence is a sequence that can be obtained from the string by deleting\n/// some (possibly none) characters while keeping the relative order of the\n/// remaining characters.  \n/// The subsequence must be a *valid* bracket sequence (equal number of \u2018[\u2019 and\n/// \u2018]\u2019, matched in the correct order) **and** it must contain at least one\n/// bracket that is *nested* \u2013 i.e. we have two matching pairs and one pair is\n/// inside the other.\n///\n/// The algorithm is straightforward: we only have to check whether we can\n/// pick four indices\n\n///   i < j < k < l\n///\n/// such that\n\n///   s[i] = '[' , s[j] = '[' , s[k] = ']' , s[l] = ']'\n///\n/// and *j < k*.  Because the subsequence keeps the order, this condition is\n/// equivalent to the existence of a nested pair.  If no such indices exist,\n/// no valid nested subsequence can be formed.\n///\n/// Time   : O(n^2) \u2013 we search for the first two \u2018[\u2019 and the first two \u2018]\u2019 after\n/// the second \u2018[\u2019.  \n/// Space  : O(1).\nbool is_nested(const string& s) {\n    int n = (int)s.size();\n    // pre\u2011compute positions of '['\n    vector<int> openPos;\n    for (int i = 0; i < n; ++i)\n        if (s[i] == '[') openPos.push_back(i);\n    if (openPos.size() < 2) return false;          // need two opens\n\n    // try every pair of '[' as the outer and inner openings\n    for (size_t a = 0; a + 1 < openPos.size(); ++a) {   // a: outer\n        for (size_t b = a + 1; b < openPos.size(); ++b) { // b: inner\n            int innerOpen = openPos[b];\n            // find the first ']' after innerOpen  \u2192 inner close\n            int innerClose = -1;\n            for (int i = innerOpen + 1; i < n; ++i)\n                if (s[i] == ']') { innerClose = i; break; }\n            if (innerClose == -1) continue;\n\n            // find the next ']' after innerClose \u2192 outer close\n            int outerClose = -1;\n            for (int i = innerClose + 1; i < n; ++i)\n                if (s[i] == ']') { outerClose = i; break; }\n            if (outerClose != -1)\n                return true;          // we found a nested pair\n        }\n    }\n    return false;\n}\n```\n\n### How the function works\n\n1. **Collect all opening brackets** \u2013 we store their indices.\n2. **Try every possible pair of openings** (`outerOpen`, `innerOpen` with\n   `outerOpen < innerOpen`).\n3. From the position of the inner opening we look for the first closing\n   bracket (inner close).\n4. After that, we look for one more closing bracket, which would close\n   the outer pair.\n5. If such a chain of indices exists, a nested valid subsequence can be\n   built (e.g. `s[outerOpen] s[innerOpen] s[innerClose] s[outerClose]`),\n   and the function returns `true`.  \n   If no such chain exists after examining all possibilities, return\n   `false`.\n\nThis follows exactly the definition of a nested subsequence of brackets.", "**Explanation**\n\nA *nested* valid subsequence of brackets means we can pick some of the\nbrackets (keeping the original order) that\n\n1. form a correct bracket sequence, and  \n2. contain at least one pair that is *inside* another pair, i.e.  \n   we can find indices  \n\n```\ni < j < k < l          where\ns[i] == '[' , s[j] == '[' , s[k] == ']' , s[l] == ']'\n```\n\nThe bracket at `j` is matched with the bracket at `k`, and the one at\n`i` is matched with the one at `l`.  \nThus the problem reduces to checking whether the string contains a\nsubsequence `[[ ]]`.  \nThe remaining characters between the chosen four need not be\nconsecutive.\n\nThe following algorithm scans the string once:\n\n* For each position `j` where `s[j]=='['`  \n   * `prevOpen` \u2013 number of `'['` before position `j`\n   * `postClose` \u2013 number of `']'` after position `j`\n* If `prevOpen \u2265 1` **and** `postClose \u2265 2` we can choose  \n  (i) the earlier `'['` as `i`,  \n  (ii) `j` itself,  \n  (iii) two `'']'` after `j` as `k` and `l`.  \n  Thus a nested subsequence exists \u2192 return `true`.\n\nIf no such position `j` exists, the function returns `false`.\n\nThe algorithm works in *O(n)* time and *O(1)* additional space.\n\n**Code**\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Returns true iff there exists a valid nested subsequence\nbool is_nested(const string& s)\n{\n    int n = s.size();\n\n    // suffix count of ']' from position i (exclusive to the right)\n    vector<int> suffixClose(n + 1, 0);\n    for (int i = n - 1; i >= 0; --i) {\n        suffixClose[i] = suffixClose[i + 1] + (s[i] == ']');\n    }\n\n    int openSoFar = 0;          // number of '[' seen so far\n    for (int j = 0; j < n; ++j) {\n        if (s[j] == '[') {\n            // we consider this '[' as the *inner* opening bracket (j)\n            int postClose = suffixClose[j + 1];  // ']' after j\n            if (openSoFar >= 1 && postClose >= 2) {\n                return true;  // we can pick an outer '[' before j\n            }\n            ++openSoFar;                       // this '[' becomes available for future outer brackets\n        }\n    }\n    return false;\n}\n\n/* -----------  Optional main to illustrate usage  ------------- */\n/*\nint main() {\n    vector<string> tests = {\"[[]]\", \"[]]]]]]][[[[[]\", \"[][]\", \"[]\", \"[[][]]\", \"[[]][[\"};\n    for (auto& t : tests) {\n        cout << t << \" -> \" << (is_nested(t) ? \"true\" : \"false\") << '\\n';\n    }\n}\n*/\n```\n\nThe function `is_nested` follows exactly the reasoning above and\nconforms to the requested signature.", "**Answer in C++**\n\n```cpp\n#include <string>\n#include <vector>\n#include <stack>\n\n/*\n   Return true iff there exists a *valid* subsequence of brackets in the\n   given string that contains at least one nested pair.\n   The string consists solely of '[' and ']'.\n\n   We first find all \"well\u2011formed\" bracket pairs by simulating a stack.\n   Each time we encounter a ']' we pop the last unmatched '[' from the\n   stack \u2013 that gives us a pair (start, end).  We then simply look\n   for two pairs that are nested: pair A (a,b) and pair B (c,d) such that\n   a < c  and  d < b.  If such a pair exists we return true, otherwise\n   we return false.\n*/\n\nbool is_nested(const std::string& s)\n{\n    std::vector<std::pair<int,int>> pairs;      // all matched pairs\n    std::stack<int> st;                         // stack of indices of '['\n\n    for (int i = 0; i < (int)s.size(); ++i)\n    {\n        if (s[i] == '[')\n            st.push(i);\n        else            // ']'  (the input contains only bracket chars)\n        {\n            if (!st.empty())\n            {\n                int start = st.top(); st.pop();\n                pairs.emplace_back(start, i);\n            }\n        }\n    }\n\n    // Look for two pairs where one is nested inside the other\n    for (size_t i = 0; i < pairs.size(); ++i)\n    {\n        for (size_t j = i + 1; j < pairs.size(); ++j)\n        {\n            if (pairs[i].first < pairs[j].first && pairs[j].second < pairs[i].second)\n                return true;          // i contains j\n            if (pairs[j].first < pairs[i].first && pairs[i].second < pairs[j].second)\n                return true;          // j contains i\n        }\n    }\n\n    return false;   // no nested pair found\n}\n```\n\n### Why this works\n\n* The stack guarantees that every `[` matched with a later `]` forms a *valid* bracket\n  subsequence.\n* Each pair `(start, end)` represents a contiguous valid subsequence \u201c``[\u2026]``\u201d.\n* Two such pairs are nested exactly when one starts inside the other *and* finishes\n  before the outer one ends, i.e. `a < c` and `d < b`.  Checking all pair\n  combinations is `O(n\u00b2)` where `n` is the number of matched pairs \u2013 which is far\n  below the length of the original string (worst case `n = len/2`).\n\nThis implementation follows the requirements and matches the example calls in the\nproblem statement."]}
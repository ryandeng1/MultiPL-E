{"completions": ["Below is a **complete, self\u2011contained implementation** that follows the idea described in the edit\u2011style answer.  \nThe algorithm consists of two parts\n\n1. **Binary search on the answer** \u2013  \n   we binary\u2011search on the maximum average value `mid`.  \n   For each `mid` we ask \u201c*is there a path whose average \u2265 mid?*\u201d\n\n2. **Feasibility check for a fixed `mid`** \u2013  \n   Let `val(i , j) = cost[i][j] \u2013 mid`.  \n   If a path exists from `(0,0)` to `(n\u20111,n\u20111)` with a **positive total\n   sum** of `val`, then its average is at least `mid`.  \n   The maximum total sum for a fixed `mid` is a classical\n   \u201cmax\u2011sum path in a grid moving only right or down\u201d and can be computed\n   with a simple dynamic programming (DP) in **O(n\u00b2)** time.  \n   If the maximum sum is \u2264 0, no path can reach average `mid`.\n\nThe binary search is performed on the interval `[minCost , maxCost]`  \nwhere `minCost` and `maxCost` are the minimum and maximum cell values in\nthe grid.  \nWe iterate a fixed number of times (e.g., 60) \u2013 that is enough for the\nrequired double precision.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// returns true if there exists a path whose average >= mid\nstatic bool feasible(const vector<vector<long>>& cost, double mid, int n) {\n    // DP: dp[j] is the maximum sum of (cost - mid) up to cell (i,j)\n    vector<double> dp(n, -1e100);\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            double val = (double)cost[i][j] - mid;\n            if (i == 0 && j == 0) {\n                dp[j] = val;\n            } else {\n                double best = -1e100;\n                if (i > 0) best = max(best, dp[j]);          // from top\n                if (j > 0) best = max(best, dp[j-1]);        // from left\n                dp[j] = best + val;\n            }\n        }\n    }\n    return dp[n-1] > 0.0;        // positive sum \u21d2 average \u2265 mid\n}\n\nfloat maxAverageOfPath(vector<vector<long>> cost) {\n    if (cost.empty() || cost[0].empty()) return 0.0f;\n    int n = (int)cost.size();\n\n    long mn = LLONG_MAX, mx = LLONG_MIN;\n    for (auto& row : cost) {\n        for (long v : row) {\n            mn = min(mn, v);\n            mx = max(mx, v);\n        }\n    }\n\n    double lo = mn, hi = mx;\n    const int ITER = 60;          // enough for double precision\n    for (int it = 0; it < ITER; ++it) {\n        double mid = (lo + hi) / 2.0;\n        if (feasible(cost, mid, n))\n            lo = mid;             // we can reach at least mid\n        else\n            hi = mid;             // not possible\n    }\n    return static_cast<float>(lo);\n}\n\n#ifdef LOCAL\nint main() {\n    vector<vector<long>> a = {{5,1,7},{4,8,6},{2,3,9}};\n    cout << fixed << setprecision(6) << maxAverageOfPath(a) << '\\n';\n}\n#endif\n```\n\n### How the code works\n\n| Step | Description |\n|------|-------------|\n| **`feasible()`** | For each cell `(i,j)` compute `val = cost[i][j] - mid`.  \nUsing a single 1\u2011D array we keep the maximum accumulated sum that can\nreaches that cell from the start following only right or down moves.  \nAt the end, if this sum at the destination is positive, a path with\naverage at least `mid` exists. |\n| **Binary search** | Start with the interval `[mn, mx]`.  \nIf `feasible(mid)` is true, the answer is at least `mid`, set `lo = mid`.  \nOtherwise set `hi = mid`.  \nAfter ~60 iterations the interval width is far below `1e-12`. |\n| **Return** | The lower bound `lo` is the maximum achievable average; cast to `float`. |\n\nThe algorithm runs in **O(n\u00b2)** time per feasibility test and\nneeds only a handful of iterations, so the total complexity is\n`O(n\u00b2 \u00b7 log(range))`, easily fast enough for matrices up to several\nthousand by thousand cells.", "Below is a **complete, compilable** implementation for the problem.  \nThe idea is:\n\n1. We are looking for a path that maximises  \n   `average = (sum of costs on the path) / (number of cells on the path)`  \n   where a path starts at `(0,0)` and ends at `(n\u20111,n\u20111)` using only moves `right` or `down`.\n\n2. The classical way to solve such *max\u2011average* problems is to employ **binary search on the answer**.  \n   *   For a candidate average `mid`, transform each cell value `cost[i][j]` into `cost[i][j] - mid`.  \n   *   If there exists a path whose transformed sum is \u2265\u202f0, then a genuine path whose average is \u2265\u202fmid exists.  \n   *   Hence we can decide \u201ckeep searching to the right\u201d or \u201csearch to the left\u201d.\n\n3. The feasibility test (`canAchieve(mid)`) is just a standard dynamic\u2011programming for \u201cmaximum\u2011sum path\u201d on the transformed grid \u2013 O(N\u00b2) time.\n\n4. Binary search on an interval that is guaranteed to contain the answer.  \n    *   Lower bound = the global minimum cost (an average can\u2019t be lower).  \n    *   Upper bound = the global maximum cost (an average can\u2019t be higher).  \n    *   60 iterations gives way more than enough precision for `float`.\n\n5. Finally we return the best average found.  \n   The function returns a `float` (you could also use `double` if more precision is needed).\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// ------------------------------------------------------------\n// Helper: check whether a path of average >= mid exists\nstatic bool canAchieve(const vector<vector<long>>& cost, double mid) {\n    int n = (int)cost.size();\n    if (n == 0) return false;\n    int m = (int)cost[0].size();\n    // dp[i][j] = maximum transformed sum for a path ending at (i,j)\n    vector<vector<double>> dp(n, vector<double>(m, -1e100));\n    dp[0][0] = cost[0][0] - mid;\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (i == 0 && j == 0) continue;\n            double best = -1e100;\n            if (i > 0) best = max(best, dp[i-1][j]);\n            if (j > 0) best = max(best, dp[i][j-1]);\n            dp[i][j] = best + cost[i][j] - mid;\n        }\n    }\n    return dp[n-1][m-1] >= 0.0;\n}\n// ------------------------------------------------------------\n\nfloat maxAverageOfPath(std::vector<std::vector<long>> cost) {\n    if (cost.empty() || cost[0].empty()) return 0.0f;\n    int n = (int)cost.size();\n    int m = (int)cost[0].size();\n\n    // find bounds\n    long mn = LLONG_MAX, mx = LLONG_MIN;\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < m; ++j) {\n            mn = min(mn, cost[i][j]);\n            mx = max(mx, cost[i][j]);\n        }\n\n    double lo = mn, hi = mx;\n    for (int iter = 0; iter < 60; ++iter) {          // enough for 1e\u201118 relative precision\n        double mid = (lo + hi) / 2.0;\n        if (canAchieve(cost, mid))\n            lo = mid;   // we can do at least mid, go higher\n        else\n            hi = mid;   // cannot, go lower\n    }\n    return static_cast<float>(lo);   // lo is the best achievable average\n}\n// ------------------------------------------------------------\n\n#ifdef LOCAL_TEST\nint main() {\n    vector<vector<long>> a = {\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 9}\n    };\n    cout << maxAverageOfPath(a) << endl;   // should be 6.0 (path 1-4-7-8-9)\n    return 0;\n}\n#endif\n```\n\n### Complexity\n*Time*: `O(N\u00b2 \u00b7 log\u202fPrecision)` \u2013 60 iterations of DP \u2192  \n`O(60 \u00b7 N\u00b2)` \u2248 `O(N\u00b2)`.  \n*Space*: `O(N\u00b2)` for the DP array.\n\nFeel free to replace the `#ifdef LOCAL_TEST` block with your own tests or to compile this file in a larger project.", "Below is a complete, self\u2011contained implementation of the requested function.  \nThe idea is to use **binary search on the answer** (the maximum average).  \nFor a candidate average `mid` we transform every cell value `v` into `v \u2013 mid`.  \nIf there exists a path whose **sum of transformed values is non\u2011negative**, then a path\nwith average \u2265\u202f`mid` exists.  \nWe can check this condition with a standard DP that keeps the maximum sum reachable\nat each cell (moving only right or down).  \nBecause the matrix size is `N\u202f\u00d7\u202fN`, the DP runs in `O(N\u00b2)` time.  \nBinary searching over the range of possible averages (from `min(cost)` to `max(cost)`)\ngives an overall complexity of `O(N\u00b2\u202f\u00b7\u202flog\u202fR)` where `R` is the precision range.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Return true if there exists a path whose average is at least 'mid'\nbool canAchieve(const vector<vector<long>>& cost, double mid) {\n    int n = cost.size();\n    vector<vector<double>> dp(n, vector<double>(n, -1e100)); // use the largest negative value\n    dp[0][0] = cost[0][0] - mid;                // start at top\u2011left\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (i == 0 && j == 0) continue;\n            double best = -1e100;\n            if (i > 0) best = max(best, dp[i-1][j]);\n            if (j > 0) best = max(best, dp[i][j-1]);\n            dp[i][j] = best + (cost[i][j] - mid);\n        }\n    }\n    return dp[n-1][n-1] >= 0.0; // a non\u2011negative sum means average \u2265 mid\n}\n\nfloat maxAverageOfPath(const vector<vector<long>>& cost) {\n    if (cost.empty() || cost[0].empty()) return 0.0f;\n\n    int n = cost.size();\n    long mn = LLONG_MAX, mx = LLONG_MIN;\n    for (const auto& row : cost)\n        for (long v : row) {\n            mn = min(mn, v);\n            mx = max(mx, v);\n        }\n\n    double lo = mn, hi = mx;\n    const int ITER = 60;                   // enough for double precision\n    for (int it = 0; it < ITER; ++it) {\n        double mid = (lo + hi) / 2.0;\n        if (canAchieve(cost, mid))\n            lo = mid;                      // we can do better\n        else\n            hi = mid;\n    }\n    return static_cast<float>(lo);\n}\n```\n\n### How it works\n\n1. **Bounds** \u2013 The answer must lie between the smallest and largest cell value  \n   (`mn` and `mx`).\n2. **Binary search** \u2013 On each step we test whether a path with average \u2265\u202f`mid`\n   is possible via `canAchieve`.\n3. **Checking a candidate** \u2013 `canAchieve` builds a DP table where each entry keeps\n   the maximum possible transformed sum (value\u202f\u2013\u202f`mid`) achievable up to that cell.\n   The recurrence is the same as the classic \u201cmaximum\u2011sum path\u201d problem, except we\n   use the transformed values.\n4. **Result** \u2013 After iterating a sufficient number of times, `lo` holds the\n   maximum achievable average within numerical precision.\n\nThe function returns the result as `float`, as requested."]}
{"completions": ["Below is a compact, self\u2011contained snippet that implements the requested predicate, a short `main()` that exercises it, and a set of remarks on how it works and why it is safe.\n\n```cpp\n// -----------------------------------------------------------------------------\n//  check_element\n// -----------------------------------------------------------------------------\n//  Returns true iff *all* elements in `vec` are equal (in value AND type) to\n//  `element`.  The function is completely type\u2011generic \u2013 it works with any\n//  concrete type that can be stored inside an std::any.\n//\n//  Comparison of std::any values is not provided by the standard, so we have\n//  to come up with a small helper that:\n//\n//    1) compares the contained types;\n//    2) casts both anys to the same concrete type and compares the result\n//       via operator==.\n//\n//  For types that do not have operator== (e.g. std::string with a custom\n//  comparator) the program will simply fail to compile.  That is fine for the\n//  purposes of this toy example.\n//\n//  The function receives `vec` and `element` by *value*; copying a vector of\n//  std::any is cheap compared to copying arbitrary PODs that might be stored\n//  in the anys (which are only copied when the user code actually creates a\n//  copy of the any itself).  The function is marked `noexcept` because we\n//  never throw \u2013 `std::any_cast` throws only if the type does not match the\n//  one being cast, but we guard against that by checking `type()`.  The\n//  only way `any_cast` can throw would be if the contained value is not\n//  constructible from the target type \u2013 that is also detected by the type\n//  comparison above, so no throw can occur.\n//\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Helper that compares two std::any values for equality.\nbool any_equal(const std::any& a, const std::any& b) noexcept {\n    // 1. Same type?\n    if (a.type() != b.type())\n        return false;\n\n    // 2. If the type is known at compile time, cast & compare.\n    //    We use a little template trick to cover all possible types.\n    struct Visitor {\n        const std::any& a;\n        const std::any& b;\n\n        template <typename T>\n        bool operator()(const T&) const noexcept {\n            // The cast will succeed because the types match.\n            return std::any_cast<T>(a) == std::any_cast<T>(b);\n        }\n    };\n\n    // Use std::visit by first turning the type into a type list.\n    // Since std::any does not give us a type list, we use a simple\n    // switch\u2011case like construction via if-else.  For demonstration\n    // we handle a handful of common types \u2013 the rest fall through to\n    // \"not equal\" (or could be extended).\n    if (a.type() == typeid(int))\n        return Visitor{a,b}(int{});\n    if (a.type() == typeid(double))\n        return Visitor{a,b}(double{});\n    if (a.type() == typeid(std::string))\n        return Visitor{a,b}(std::string{});\n    if (a.type() == typeid(char))\n        return Visitor{a,b}(char{});\n    // \u2026 add more types as needed \u2026\n\n    // Unknown or unsupported type: we conservatively say \"not equal\".\n    return false;\n}\n\n// -----------------------------------------------------------------------------\n//  check_element\n// -----------------------------------------------------------------------------\nbool check_element(const std::vector<std::any>& vec,\n                   const std::any& element) noexcept\n{\n    for (const auto& v : vec)\n        if (!any_equal(v, element))     // as soon as one differs \u2192 false\n            return false;\n    return true;\n}\n\n// -----------------------------------------------------------------------------\n//  Test harness\n// -----------------------------------------------------------------------------\nint main()\n{\n    // Example vector containing ints\n    std::vector<std::any> v1 = { 42, 42, 42 };\n    assert(check_element(v1, 42));            // true\n\n    // Same vector but different element\n    assert(!check_element(v1, 24));           // false\n\n    // Mixed types \u2013 not all equal\n    std::vector<std::any> v2 = { 42, std::string(\"42\") };\n    assert(!check_element(v2, 42));\n\n    // All strings\n    std::vector<std::any> v3 = { std::string(\"foo\"), std::string(\"foo\") };\n    assert(check_element(v3, std::string(\"foo\")));\n\n    std::cout << \"All tests passed.\\n\";\n    return 0;\n}\n```\n\n### How it works\n\n1. **`any_equal`**  \n   * Checks that the two `std::any` objects hold the *same* type.  \n   * If they do, it casts them to that type and compares the values\n     using `operator==`.  \n   * A small `Visitor`-like lambda is used so that the compiler\n     generates the correct `any_cast<T>` for each known type.\n2. **`check_element`**  \n   * Iterates over the vector.  \n   * Calls `any_equal` for each item against the given element.  \n   * If any comparison fails, it returns `false`; otherwise it returns\n     `true` after the loop.\n3. **Test harness**  \n   Validates several scenarios: all integers, mismatched element,\n   mixed types, all strings.\n\nFeel free to expand the type checks in `any_equal` to cover any other\nstandard or custom types you plan to store inside the `std::any`\nvector.", "Below is a self\u2011contained, \u201cC++\u201117 ready\u201d implementation of `check_element`.  \nIt demonstrates how to compare the contents of an `std::any` with another `std::any` when **both hold types that are\n`==`\u2011comparable**.  \n\n```cpp\n#include <vector>\n#include <any>\n#include <typeinfo>\n#include <stdexcept>\n#include <iostream>\n\n/* ---------------------------------------------------------------\n   Helper that compares two std::any objects\n\n   - If the two objects hold exactly the same type, we try to\n     compare their underlying values via `operator==`.\n   - If the types differ we consider them unequal \u2013 this is the\n     most sensible behaviour for a \u201ccheck that all items are\n     equal to X\u201d.\n   --------------------------------------------------------------- */\nbool any_equal(const std::any& lhs, const std::any& rhs)\n{\n    // If the types differ \u2192 not equal\n    if (lhs.type() != rhs.type())\n        return false;\n\n    // Now we know the types are identical.\n    // Shield the comparison inside a try \u2013\u2011 if the type is not\n    // comparable we throw a run\u2011time error. In a production\n    // system you could decide to silently return false\n    // instead of throwing.\n\n    // C++20 introduced `std::any::is` and `any_cast<T>` helpers.\n    // Here we use a switch\u2011like approach via helper struct templates.\n\n    struct Visitor {\n        const std::any& a, &b;\n        template<class T>\n        bool operator()(const T&) const {\n            // perform the test only if T supports operator==\n            return std::any_cast<T>(a) == std::any_cast<T>(b);\n        }\n    };\n\n    // Visiting on T using typeid\n    return std::visit(\n        Visitor{lhs, rhs},\n        std::function<void(const void*)>(nullptr) // dummy placeholder\n    );\n}\n```\n\nHowever, the above code uses `std::visit` incorrectly \u2013 we cannot visit an `std::any` that way.  \nInstead, a more straightforward and fully standard approach is:\n\n```cpp\nbool any_equal(const std::any& lhs, const std::any& rhs)\n{\n    if (lhs.type() != rhs.type())\n        return false;\n\n    // The following lambda is instantiated with the concrete type\n    // if the type is one of the supported ones.\n    // By default, we return *false* for unhandled types.\n    struct AnyComparer {\n        const std::any& lhs; const std::any& rhs;\n        template<class T>\n        bool operator()(T dummy) const {\n            // Throw if == not defined \u2013 we catch below\n            try {\n                return std::any_cast<T>(lhs) == std::any_cast<T>(rhs);\n            } catch (const std::bad_any_cast&) {\n                return false;        // cannot compare \u2013 treat as not equal\n            }\n        }\n    };\n\n    AnyComparer comp{lhs, rhs};\n\n    // Use a helper that forwards the actual stored value\n    // to the lambda \u2013 this dispatches on the real type.\n    // We do it with `std::apply` on an `std::tuple` of the\n    // stored type.  The lambda will be called with that type.\n\n    if (lhs.type() == typeid(int))\n        return comp(int{});\n    else if (lhs.type() == typeid(double))\n        return comp(double{});\n    else if (lhs.type() == typeid(std::string))\n        return comp(std::string{});\n    // \u2026 add more supported types as required \u2026\n\n    // For any other type we simply report mismatch\n    return false;\n}\n```\n\nThe version above is a bit verbose but completely portable and shows explicitly which types you want to support.  \nIf you prefer a generic solution that works for **any** type that is `operator==`\u2011able, you can use a C++20 `apply_cvref_t` trick or rely on `std::any::type() == rhs.type()` and then `any_cast<T>(lhs) == any_cast<T>(rhs)` inside a try\u2011except.\n\n---\n\n### Full working example\n\nBelow is a ready\u2011to\u2011paste, compact example that compiles with any modern compiler (C++17 or newer). Feel free to drop it into a file and run `make` or `g++ -std=c++17`.\n\n```cpp\n#include <vector>\n#include <any>\n#include <string>\n#include <iostream>\n#include <cassert>\n\n/* ---------------------------------------------------------------\n   Compare two std::any objects that hold the *same* type and\n   return true iff their stored values are equal.\n   --------------------------------------------------------------- */\nbool any_equal(const std::any& a, const std::any& b)\n{\n    if (a.type() != b.type())        // different types \u2192 not equal\n        return false;\n\n    // Small helper that is instantiated only for the concrete type.\n    struct Comparator {\n        const std::any&a, &b;\n        template<class T>\n        bool operator()() const {\n            return std::any_cast<T>(a) == std::any_cast<T>(b);\n        }\n    };\n\n    Comparator cmp{a, b};\n\n    // Dispatch on the concrete type.  The list below can be\n    // extended with all types you need to support.\n    if      (a.type() == typeid(int))        return cmp.template operator<int>()();\n    else if (a.type() == typeid(double))     return cmp.template operator<double>()();\n    else if (a.type() == typeid(std::string))return cmp.template operator<std::string>()();\n    // \u2026 more types \u2026\n\n    // If we reach this point, the type is not on the list \u2192 treat as not equal\n    return false;\n}\n\n/* ---------------------------------------------------------------\n   check_element:  true \u21d4 every element in `list` equals `element`\n   --------------------------------------------------------------- */\nbool check_element(const std::vector<std::any>& list, const std::any& element)\n{\n    for (const auto& v : list)\n        if (!any_equal(v, element))\n            return false;\n    return true;\n}\n\n/* =============================================================== */\nint main()\n{\n    std::vector<std::any> v1{1, 1, 1};\n    assert(check_element(v1, 1));\n\n    std::vector<std::any> v2{1, 1, 2};\n    assert(!check_element(v2, 1));\n\n    std::vector<std::any> v3{\"abc\", std::string(\"abc\"), std::string(\"abc\")};\n    assert(check_element(v3, std::string(\"abc\")));\n\n    std::vector<std::any> v4{1.0, 1.0, 1.0};\n    assert(check_element(v4, 1.0));\n\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\n**Explanation of the key points**\n\n| Line | What it does | Why it matters |\n|------|--------------|----------------|\n| `if (a.type() != b.type()) return false;` | Ensures both `any`s hold the same type. | Different types can never be \u201cequal\u201d for the purpose of \u201call items equal to X\u201d. |\n| `Comparator` & `cmp.template operator<T>()()` | Instantiates the comparison only for the concrete type. | Avoids trying to compare arbitrary, potentially non\u2011comparable types. |\n| The list of `if`/`else if` statements | Dispatches based on the actual type. | Keeps the code C++17\u2011compatible and lets you list exactly which types you support. |\n| `check_element` loops | Calls `any_equal` for every element. | Returns `false` on the first mismatch \u2013 efficient short\u2011circuiting. |\n\nFeel free to drop the comparison helper into your own utilities or to convert it into a templated version if you know the underlying types ahead of time.", "Below is a simple (yet still *generic*) implementation that checks whether **every**\nitem in the `std::vector<std::any>` is the *same exact value* as\nthe supplied `element`.  \nBecause `std::any` can hold any copy\u2011constructible type, the only\nmechanism we have for comparison is to determine the stored *type* first\nand then cast both operands to that type.  \nThe implementation below supports the builtin scalar types that are\nmost common (`int`, `long`, `double`, `char`, `bool`) plus\n`std::string`.  \nIf you need more types, just add another branch.\n\n```cpp\n#include <any>\n#include <vector>\n#include <string>\n#include <typeinfo>\n#include <type_traits>\n#include <stdexcept>\n\n// \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n// Comparing two heterogeneous values that are known to have the same type.\n//\n// Generic helper that casts the value to its type and returns it as\n// a reference. The function is only instantiated for the types that we\n// support. Unsupported types cause a compile\u2011time error, which is fine\n// because std::any ensures the underlying type is one of the\n// explicitly listed ones or you must add a new branch.\n// \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\ntemplate <typename T>\ninline T const& any_cast_value(const std::any& a)\n{\n    using Decay = std::decay_t<T>;\n    // The static_assert is only there to provide a clearer error message\n    // if you try to use a type that is not explicitly supported.\n    static_assert(std::is_same_v<Decay, int> ||\n                  std::is_same_v<Decay, long> ||\n                  std::is_same_v<Decay, double> ||\n                  std::is_same_v<Decay, char> ||\n                  std::is_same_v<Decay, bool> ||\n                  std::is_same_v<Decay, std::string> ,\n                  \"any_cast_value only supports int, long, double, char, bool, and std::string\");\n    return std::any_cast<Decay>(a);\n}\n\n// \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n// Public API\n// \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nbool check_element(const std::vector<std::any>& list, const std::any& element)\n{\n    // An empty list contains *zero* elements \u2013 by definition all (zero)\n    // elements match the target.\n    if (list.empty()) return true;\n\n    // The type of the reference value must match the type stored in\n    // each element of the vector; otherwise they cannot be equal.\n    const std::type_info& target_type = element.type();\n\n    for (const auto& val : list)\n    {\n        // If the types differ, we can immediately return `false`.\n        if (val.type() != target_type) {\n            return false;\n        }\n\n        // The types match \u2013 perform the actual value comparison.\n        // We do it via a switch on the type name (aka `type_info::name()`).\n        // The comparison for every supported type is straightforward.\n        if (target_type == typeid(int)) {\n            if (any_cast_value<int>(val) != any_cast_value<int>(element))\n                return false;\n        }\n        else if (target_type == typeid(long)) {\n            if (any_cast_value<long>(val) != any_cast_value<long>(element))\n                return false;\n        }\n        else if (target_type == typeid(double)) {\n            if (any_cast_value<double>(val) != any_cast_value<double>(element))\n                return false;\n        }\n        else if (target_type == typeid(char)) {\n            if (any_cast_value<char>(val) != any_cast_value<char>(element))\n                return false;\n        }\n        else if (target_type == typeid(bool)) {\n            if (any_cast_value<bool>(val) != any_cast_value<bool>(element))\n                return false;\n        }\n        else if (target_type == typeid(std::string)) {\n            if (any_cast_value<std::string>(val) != any_cast_value<std::string>(element))\n                return false;\n        }\n        else {\n            // Unsupported type \u2013 you can decide what to do.\n            // For this demo we simply throw an exception.\n            throw std::logic_error(\n                \"check_element: unsupported std::any type encountered\");\n        }\n    }\n\n    // All loop iterations succeeded \u2013 every element equals the reference.\n    return true;\n}\n\n// \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n// Example usage & quick sanity check\n// \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n#include <iostream>\n\nint main()\n{\n    std::vector<std::any> v = { int{42}, int{42}, int{42} };\n    std::any target = int{42};\n\n    std::cout << std::boolalpha\n              << \"All equal? \" << check_element(v, target) << '\\n'; // true\n\n    v.push_back(int{7});\n    std::cout << \"All equal? \" << check_element(v, target) << '\\n'; // false\n\n    return 0;\n}\n```\n\n### Why this works\n\n1. **Type Safety** \u2013 We first compare the `type_info` stored in each\n   `std::any`. If the types differ the function immediately returns\n   `false`.  \n2. **Value Comparison** \u2013 If the types match, the concrete value is\n   extracted via `any_cast_value<T>`.  \n   The `if\u2011else` ladder resolves the correct type at compile time.\n3. **Extensibility** \u2013 Adding a new supported type only requires one\n   more `else if` branch.  \n   The helper `any_cast_value` contains a `static_assert` that will\n   produce a clear compile\u2011time error if an unsupported type sneaks in.\n\nFeel free to adapt the list of supported types or the behaviour for\nunknown types to fit your exact needs."]}
{"completions": ["Below is a compact and self\u2011contained implementation that fulfills the requirement:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Return the maximum difference (#0 - #1) that can be obtained\n// from any contiguous substring of 'binary'.\nint maxZeroMinusOneDiff(const string& binary)\n{\n    int best = 0, cur = 0;\n\n    for (char ch : binary)\n    {\n        // treat 0 as +1, 1 as \u20131\n        int val = (ch == '0') ? 1 : -1;\n\n        cur = max(val, cur + val);   // Kadane\u2019s algorithm\n        best = max(best, cur);\n    }\n    return best;   // best is the maximum difference (#0 - #1)\n}\n\n/* ---------- Optional helper to get the length of the\n   substring that achieves the above maximum difference ---------- */\nint longestSubstringWithMaxDiff(const string& binary)\n{\n    int max_diff = maxZeroMinusOneDiff(binary);\n\n    // identical mapping: 0 \u2192 1, 1 \u2192 \u20131\n    vector<long long> pref(binary.size() + 1, 0);\n    for (size_t i = 0; i < binary.size(); ++i)\n        pref[i + 1] = pref[i] + (binary[i] == '0' ? 1 : -1);\n\n    // we need the longest interval with sum = max_diff\n    // map prefix sums to their earliest index\n    unordered_map<long long, size_t> first;\n    for (size_t i = 0; i <= binary.size(); ++i)\n        if (!first.count(pref[i]))\n            first[pref[i]] = i;\n\n    int bestLen = 0;\n    for (size_t r = 0; r <= binary.size(); ++r)\n    {\n        long long target = pref[r] - max_diff;\n        auto it = first.find(target);\n        if (it != first.end())\n            bestLen = max<int>(bestLen, r - it->second);\n    }\n    return bestLen;\n}\n\n/* ------------------------------------------------------------ */\n\nint main()\n{\n    string s;\n    while (cin >> s)\n    {\n        int diff = maxZeroMinusOneDiff(s);\n        cout << \"Maximum difference (#0 \u2013 #1) = \" << diff << '\\n';\n        cout << \"Longest substring that achieves it has length = \"\n             << longestSubstringWithMaxDiff(s) << \"\\n\\n\";\n    }\n    return 0;\n}\n```\n\n### How it works\n1. **Mapping**  \n   Convert the binary string into a numeric array where `0 \u2192 +1` and `1 \u2192 \u20131`.  \n   Then the sum over any interval equals  \n   `(#0 in that interval) \u2013 (#1 in that interval)`.\n\n2. **Kadane\u2019s algorithm**  \n   Scan once, keeping a running sum `cur`.  \n   `cur = max(val, cur + val);`  \n   Updates the best value `best` at each step.  \n   The final `best` is the maximum difference.\n\n3. **(Optional) Longest substring**  \n   If you also need the length of the longest substring that achieves the maximum difference, the code builds a prefix\u2011sum array and uses a hash map to remember the earliest occurrence of each prefix value.  \n   For each right boundary `r`, the earliest index `l` such that\n   `pref[r] - pref[l] == max_diff` gives a candidate length `r - l`.\n\n4. **Complexity**  \n   Both tasks run in **O(n)** time and use **O(n)** additional memory (the map for the optional part).  \n   Pure Kadane\u2019s version uses **O(1)** extra memory.\n\nFeel free to drop the optional part if you only need the maximum difference.", "Below is a self\u2011contained implementation of the requested helper.  \nIt runs in **O(n)** time and uses only a few integer variables \u2013 so it scales to\nvery long strings without any extra memory overhead beyond the input.\n\n```cpp\n#include <string>\n#include <cassert>\n\n/*\n *  Given a binary string (consisting only of \u20180\u2019 and \u20181\u2019),\n *  returns the maximum difference  \n *  (#0s \u2013 #1s) that can be achieved in *any* contiguous substring.\n *\n *  Example:\n *      \"010110\"  ->  max diff = 3   (substring \"00\")\n *\n *  The idea is to view \u20180\u2019 as +1 and \u20181\u2019 as \u20131, and then the problem\n *  becomes: \u201cmaximum sub\u2011array sum\u201d over that transformed array.\n *  Kadane\u2019s algorithm gives that result in linear time.\n */\nlong find_length(const std::string& s) {\n    long max_diff = 0;          // best value seen so far\n    long current = 0;           // sum of current window\n\n    for (char c : s) {\n        // Convert \u20180\u2019 \u2192 +1,  \u20181\u2019 \u2192 \u20131\n        if (c == '0')\n            current += 1;\n        else\n            current -= 1;\n\n        // Kadane: either extend the current window or start a new one\n        if (current > max_diff)\n            max_diff = current;\n        if (current < 0)\n            current = 0;\n    }\n    return max_diff;\n}\n\n/* ----------  Simple test harness ---------- */\n#include <iostream>\nint main() {\n    assert(find_length(\"010110\") == 3);\n    assert(find_length(\"1111\")    == 0);\n    assert(find_length(\"0000\")    == 4);\n    assert(find_length(\"101010\")  == 1);\n    std::cout << \"All tests passed.\\n\";\n    return 0;\n}\n```\n\n### How it works\n* Treat each \u20180\u2019 as `+1` and each \u20181\u2019 as `\u20111`.  \n  The running sum after reading the i\u2011th character represents  \n  `#0s \u2013 #1s` in the current window.\n* Kadane\u2019s algorithm keeps the best window ending at each position\n  and updates the overall best (`max_diff`).\n* Whenever the running sum becomes negative the best window ending\n  there cannot be extended further, so we reset it to zero.\n\nThe algorithm visits each character only once, so its time complexity\nis `O(n)` and its space usage is `O(1)` (apart from the input string\nitself).", "Below is a minimal, self\u2011contained implementation that:\n1. converts a binary string into a numeric \u201carray\u201d where a **0** contributes **+1** and a **1** contributes **\u20131**,\n2. runs Kadane\u2019s algorithm to find the maximum sub\u2011array sum \u2013 which is exactly the maximum \\(\\#0 - \\#1\\) difference any substring can have,\n3. returns that maximum difference (the \u201clength\u201d in the sense of the problem statement).\n\n```cpp\n#include <bits/stdc++.h>\n\n// -----------------------------------------------------------------\n// Maximum difference between the number of 0s and 1s in *any* sub\u2011string\n// of a binary string.  The returned value is that maximum difference.\n// -----------------------------------------------------------------\nlong find_length(const std::string& s)\n{\n    // If the string is empty, the maximum difference is 0.\n    if (s.empty()) return 0;\n\n    long max_diff = 0;          // Max sub\u2011array sum seen so far\n    long cur_sum = 0;           // Sum of current sub\u2011array\n\n    for (char ch : s) {\n        // treat 0 as +1, 1 as -1\n        long val = (ch == '0') ? 1 : -1;\n\n        // Kadane's step: either extend current sub\u2011array or start new\n        cur_sum = std::max(val, cur_sum + val);\n        max_diff = std::max(max_diff, cur_sum);\n    }\n\n    return max_diff;\n}\n\n// -----------------------------------------------------------------\n// Example usage & simple test harness\n// -----------------------------------------------------------------\nint main()\n{\n    std::string tests[] = {\n        \"\",              // empty\n        \"0\",             // single zero\n        \"1\",             // single one\n        \"010101\",        // equal zeros and ones\n        \"000111\",        // 3 zeros then 3 ones\n        \"001110\",        // mixed\n        \"110001100\",     // random\n    };\n\n    for (const auto& t : tests) {\n        std::cout << \"s = \\\"\" << t << \"\\\"\\t\"\n                  << \"max diff = \" << find_length(t) << '\\n';\n    }\n    return 0;\n}\n```\n\n**Explanation of the algorithm**\n\n* **Mapping**  \n  * Each `'0'` \u2192 `+1`  \n  * Each `'1'` \u2192 `\u20131`  \n\n  For any substring, the sum of the mapped values is exactly  \n  `(#0s \u2013 #1s)` of that substring.\n\n* **Kadane\u2019s algorithm**  \n  * Keeps a running sum `cur_sum`.  \n  * At each character, either continue the current sub\u2011array (`cur_sum + val`) or start a new sub\u2011array at this character (`val`).  \n  * `max_diff` is updated to the maximum value of `cur_sum` seen.\n\nThe algorithm runs in **O(n)** time and uses **O(1)** additional memory, where *n* is the length of the input string."]}
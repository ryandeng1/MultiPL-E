{"completions": ["```cpp\n#include <regex>\n#include <tuple>\n#include <string>\n\n/// Search a string for a regex pattern.\n/// @param text    The text to be searched.\n/// @param pattern The regular expression pattern.\n/// @return A tuple containing\n///         1. The matched substring (empty if no match),\n///         2. The start index of the match (text::size_type::max() if no match),\n///         3. The end index of the match (text::size_type::max() if no match).\nstd::tuple<std::string, long, long>\nfind_literals(const std::string& text, const std::string& pattern)\n{\n    try\n    {\n        std::regex re(pattern);\n        std::smatch m;\n\n        if (std::regex_search(text, m, re))\n        {\n            // m.position() gives the distance from the beginning of the text to the\n            // first character of the match.\n            long start = static_cast<long>(m.position());   // start index\n            long end   = static_cast<long>(m.position() + m.length()); // end index\n            return { m.str(), start, end };\n        }\n    }\n    catch (const std::regex_error& e)\n    {\n        // The pattern was ill\u2011formed; return an empty result.\n        // (Alternatively, one could rethrow or log the error.)\n    }\n\n    // No match (or error) was found.\n    return { \"\", static_cast<long>(-1), static_cast<long>(-1) };\n}\n```\n\n### How it works\n\n1. **Compile the pattern**  \n   `std::regex re(pattern);` \u2013 this throws a `std::regex_error` if the pattern is not a valid regular\u2011expression.\n\n2. **Search**  \n   `std::regex_search(text, m, re)` \u2013 it fills a `std::smatch` object.  \n   If the search succeeds:\n   * `m.str()` \u2013 the entire matched substring.\n   * `m.position()` \u2013 zero\u2011based index of the first character of the match.\n   * `m.position() + m.length()` \u2013 index *after* the last matched character (the typical \u201cend\u2011index\u201d representation).\n\n3. **Return route**  \n   The function returns a `std::tuple<std::string, long, long>` containing the matched string, start, and end indices.  \n   If there is no match or the regex is invalid, it returns an empty string and `-1` for both indices.\n\nFeel free to change the sentinel `-1` to something else (e.g., `std::string::npos` or a `bool` flag) depending on your downstream requirements.", "Here is a completely self\u2011contained implementation that uses the C++11 `<regex>` facilities.  \nThe function returns the first match that satisfies the supplied regular\u2011expression pattern and\nsupplies the start and end positions (in *characters*) of that match inside `text`.  \nIf nothing matches we return an empty string together with `-1` indices to signal \u201cno match\u201d.\n\n```cpp\n#include <string>\n#include <regex>\n#include <tuple>\n\n/**\n * Search `text` for the first substring matching the regular expression `pattern`.\n *\n * @param text    The string to search.\n * @param pattern The regular\u2011expression pattern (exactly the same syntax that\n *                `std::regex` understands).\n *\n * @return A tuple consisting of\n *         - the matching substring (empty string if nothing matched),\n *         - the starting index of the match in `text`  (\u20111 if nothing matched),\n *         - the ending index of the match in `text`  (exclusive, \u20111 if nothing matched).\n */\nstd::tuple<std::string, long, long> find_literals(const std::string& text,\n                                                  const std::string& pattern)\n{\n    try\n    {\n        std::regex re(pattern);\n        std::smatch m;\n\n        // Find the first match\n        if (std::regex_search(text, m, re))\n        {\n            // Note: m.position() gives the offset of the whole match\n            // m.length() gives the length of the whole match\n            long start = static_cast<long>(m.position());\n            long end   = static_cast<long>(m.position() + m.length());\n\n            return std::make_tuple(m.str(), start, end);\n        }\n    }\n    catch (const std::regex_error& e)\n    {\n        // If the pattern is invalid we simply fall through to the \"no match\" case.\n        // In production code you might want to propagate or log the error.\n    }\n\n    // No match (or pattern was invalid)\n    return std::make_tuple(std::string{}, -1, -1);\n}\n```\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::string text    = \"The quick brown fox jumps over the lazy dog.\";\n    std::string pattern = R\"(\\b\\w{5}\\b)\";  // first word that has 5 letters\n\n    auto [match, start, end] = find_literals(text, pattern);\n\n    if (!match.empty())\n        std::cout << \"Match: \\\"\" << match << \"\\\" at [\" << start << \", \" << end << \")\\n\";\n    else\n        std::cout << \"No match found.\\n\";\n}\n```\n\nOutput:\n\n```\nMatch: \"quick\" at [4, 9)\n```\n\nFeel free to adjust the function to return all matches, use `std::regex` flags, or convert the indices to byte positions if you are working with UTF\u20118 encoded strings.", "Below is a concise, self\u2011contained implementation that does exactly what you asked for:\n\n1. **`find_literals`** \u2013 takes a `text` and a `pattern` (as a regular\u2011expression string).  \n2. It uses `std::regex` to locate the *first* match.  \n3. The tuple contains the matched substring, the *zero\u2011based* start index, and the *zero\u2011based* end index (the index of the character after the match, i.e. the usual C\u2011style `end()` iterator position).\n\n```cpp\n#include <string>\n#include <tuple>\n#include <regex>\n#include <stdexcept>\n\n/**\n * @brief Search a string for a regex pattern.\n *\n * @param text    The text in which to search.\n * @param pattern The regular\u2011expression pattern.\n *\n * @return A tuple containing:\n *   - the matched substring (empty if no match),\n *   - the start index of the match (\u22121 if no match),\n *   - the end index of the match (\u22121 if no match).\n *\n * @note   Uses std::regex (ECMAScript syntax) and standard string/tuple.\n */\nstd::tuple<std::string, long, long>\nfind_literals(const std::string &text, const std::string &pattern)\n{\n    try {\n        std::regex   re(pattern);\n        std::smatch  m;\n\n        if (std::regex_search(text, m, re)) {\n            // m[0] is the whole match\n            const std::string matched(m[0].first, m[0].second);\n            const long start = static_cast<long>(m[0].first - text.c_str());\n            const long end   = static_cast<long>(m[0].second - text.c_str());\n            return {matched, start, end};\n        }\n    } catch (const std::regex_error &e) {\n        // If the pattern is invalid we simply return \u201cno match\u201d.\n        // In a real system you might want to log e.what() or propagate the fault.\n    }\n\n    // No match (or bad pattern)\n    return {\"\", -1, -1};\n}\n```\n\n### How to use it\n\n```cpp\nint main() {\n    std::string subject = \"The quick brown fox jumps over the lazy dog.\";\n    auto [match, start, end] = find_literals(subject, \"quick (brown)\");\n\n    if (start != -1) {\n        std::cout << \"Found \\\"\" << match << \"\\\" at [\" << start << \", \" << end << \")\"\n                  << std::endl;\n    } else {\n        std::cout << \"No match found.\\n\";\n    }\n}\n```\n\n### Why this implementation works\n\n| Feature | Reason |\n|---------|--------|\n| **ECMAScript syntax** | The default for `std::regex` is ECMAScript, which is most common for simple patterns. |\n| **`std::smatch`** | Provides span pointers (`first`, `second`) so we can compute start/end indices quickly. |\n| **Error handling** | Catches `std::regex_error` so an invalid pattern does not crash the program. |\n| **Return type** | `tuple<string,long,long>` matches the requested signature and is easy to destructure. |\n\nFeel free to tweak the error handling or to expose an overload that returns a boolean instead of a tuple if you only care about the presence of a match."]}
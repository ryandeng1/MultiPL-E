{"completions": ["Here\u2019s a complete implementation of the function `max_sub_array_sum`.  \nIt takes a vector of signed long integers (`a`) and returns the sum of the largest contiguous sub\u2011vector (i.e. the maximum sub\u2011array sum).  \nThe routine uses the classic *Kadane\u2019s algorithm* \u2013 an O(n) linear\u2011time, O(1)\u2011space solution.\n\n```cpp\n#include <vector>\n#include <limits>\n\n/*\n * Finds the sum of the largest contiguous sub\u2011vector in the given vector.\n * Parameters:\n *   a    \u2013 vector of long integers\n *   size \u2013 number of elements to consider in `a`\n *\n * Returns:\n *   The maximum sub\u2011array sum. If all numbers are negative, the\n *   algorithm correctly returns the largest (least negative) element.\n */\nlong max_sub_array_sum(const std::vector<long> &a, long size)\n{\n    if (size <= 0)                    // guard for empty input\n        return 0;\n\n    long best = std::numeric_limits<long>::min();   // maximum sum seen so far\n    long cur  = 0;                                     // current sum\n\n    for (long i = 0; i < size; ++i) {\n        cur = std::max(a[i], cur + a[i]);  // extend or start new\n        best = std::max(best, cur);        // update best if needed\n    }\n\n    return best;\n}\n```\n\n### How it works\n\n1. **`cur`** keeps the sum of the best sub\u2011array that ends at the current element.  \n2. For each element `a[i]` you decide whether it\u2019s better to  \n   * start a new sub\u2011array at `i` (`a[i]`), or  \n   * extend the previous one (`cur + a[i]`).  \n3. `best` retains the largest value of `cur` seen during the scan.\n\n### Edge Cases\n\n* **All negative numbers:** `cur` will never grow beyond the largest single element, so `best` ends up being that element.  \n* **Empty vector (size\u202f\u2264\u202f0):** returns `0` (you can change this to throw an exception if you prefer).  \n\nFeel free to drop this into your codebase; it is header\u2011only and requires only the standard library.", "Below is a complete, idiomatic implementation of the classic **Kadane\u2019s algorithm** that finds the maximum\u2011sum contiguous sub\u2011vector (sub\u2011array) in linear time.  \nWe support `unsigned long long` for safety in case the input contains large positive values, but you can easily switch back to `long` if that\u2019s what you need.\n\n```cpp\n#include <vector>\n#include <algorithm>   // for std::max\n#include <limits>      // for std::numeric_limits\n\n// -----------------------------------------------------------------------------\n//   Returns the sum of the largest contiguous sub\u2011vector in `a`.\n// -----------------------------------------------------------------------------\nlong long max_sub_array_sum(const std::vector<long long>& a)\n{\n    // Handles empty input \u2013 no sub\u2011array exists.\n    if (a.empty())\n        return 0;               // or throw std::invalid_argument\n\n    long long max_ending_here = a[0];   // Max sum subarray ending at current index\n    long long max_so_far      = a[0];   // Global max\n\n    for (std::size_t i = 1; i < a.size(); ++i) {\n        // Extend or restart the sub\u2011array at i.\n        max_ending_here = std::max(a[i], max_ending_here + a[i]);\n\n        // Update the global maximum if needed.\n        max_so_far = std::max(max_so_far, max_ending_here);\n    }\n\n    return max_so_far;\n}\n```\n\n### How it works\n1. **Initialisation** \u2013 Start with the first element, because any sub\u2011array must contain at least one element.\n2. **Iteration** \u2013 For each subsequent element `a[i]`:\n   * `max_ending_here`: the larger of  \n     * starting a new sub\u2011array at `i` (`a[i]`),  \n     * or extending the previous best sub\u2011array (`max_ending_here + a[i]`).\n   * `max_so_far`: keep the maximum of every `max_ending_here` seen.\n3. **Result** \u2013 `max_so_far` is the maximum sub\u2011array sum.\n\n### Complexity\n- **Time:** `O(n)` \u2013 one pass through the vector.  \n- **Space:** `O(1)` \u2013 only a few scalar variables.\n\n### Usage example\n```cpp\nint main()\n{\n    std::vector<long long> v = { -2, 3, 5, -1, 4, -3, 2, 1 };\n    long long best = max_sub_array_sum(v);\n    std::cout << \"Maximum sub\u2011array sum = \" << best << '\\n'; // 12\n    return 0;\n}\n```\n\nFeel free to drop this function into your codebase; it handles negative numbers, all\u2011negative input, and even a single\u2011element vector correctly.", "```cpp\n#include <vector>\n#include <algorithm>\n#include <limits>\n\n// -----------------------------------------------------------------\n//  Find the maximum sum of any contiguous sub\u2011vector (sub\u2011array)\n//  O(n) time, O(1) extra space.\n//\n//  The algorithm is Kadane\u2019s: keep a running sum of the current\n//  sub\u2011array and reset it to zero when it becomes negative.\n// -----------------------------------------------------------------\nlong max_sub_array_sum(const std::vector<long>& a)\n{\n    if (a.empty()) return 0;          // no elements -> sum 0\n\n    long max_so_far = a[0];\n    long current_sum = a[0];\n\n    for (size_t i = 1; i < a.size(); ++i)\n    {\n        // Either extend the current sub\u2011array or start a new one\n        current_sum = std::max(a[i], current_sum + a[i]);\n\n        // Update global maximum\n        max_so_far = std::max(max_so_far, current_sum);\n    }\n\n    return max_so_far;\n}\n```\n\n**Usage**\n\n```cpp\nint main() {\n    std::vector<long> v = { -2, 1, -3, 4, -1, 2, 1, -5, 4 };\n    std::cout << max_sub_array_sum(v);  // prints 6 (sub\u2011array {4,-1,2,1})\n}\n```\n\nThis implementation handles all\u2011negative vectors correctly (returns the largest element) and runs in linear time with constant additional memory."]}
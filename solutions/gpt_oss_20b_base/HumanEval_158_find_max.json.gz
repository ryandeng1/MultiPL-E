{"completions": ["**Solution Explanation**\n\nFor each word we need to know\n\n1. how many **different** characters it contains,\n2. if two words have the same number of unique characters, which one is\n   lexicographically smaller.\n\nThe easiest way to count distinct characters in a word is to put them in a\n`std::set<char>`.  \nThe size of the set is the number of unique characters.\n\nWe iterate over all words, keep track of the current best candidate\n(`best_word`) and its unique\u2011character count (`best_unique`).  \nWhen we encounter a new word\n\n* if it has **more** unique characters than `best_unique` \u2013 it becomes the\n  new best.\n* if it has the same number \u2013 we keep the smaller one in lexicographical\n  order (i.e. the one that compares smaller with `std::string::operator<`).\n\nAt the end `best_word` is the answer.\n\nThe algorithm runs in  \n`O(total number of characters)` time and uses `O(1)` extra memory per word\n(because the set can contain at most 26 characters for lowercase\nalphabetic words \u2013 in general up to the alphabet size).\n\n---\n\n**Robustness**\n\n* Empty input \u2192 return empty string (the function\u2019s contract is not\n  defined for this case, but returning an empty string is safe).\n* Works for any printable character set \u2013 nothing assumes only letters.\n\n---\n\n**C++ implementation**\n\n```cpp\n#include <string>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <cctype>   // for std::isalpha\n#include <cassert>  // for tests\n\n// Find the word with the maximum number of unique characters.\n// In case of a tie, the lexicographically smallest word is returned.\nstd::string find_max(const std::vector<std::string>& words)\n{\n    std::string best_word;   // empty string means \"nothing yet\"\n    size_t best_unique = 0;\n\n    for (const auto& w : words)\n    {\n        // Count unique characters of this word\n        std::set<char> unique_chars;\n        for (char c : w)\n        {\n            unique_chars.insert(c);\n        }\n        size_t uniq_cnt = unique_chars.size();\n\n        if (uniq_cnt > best_unique ||\n            (uniq_cnt == best_unique && (best_word.empty() || w < best_word)))\n        {\n            best_unique = uniq_cnt;\n            best_word   = w;\n        }\n    }\n    return best_word;\n}\n\n/***************************  Test harness  *****************************/\n\nvoid run_tests()\n{\n    assert(find_max({\"name\",\"of\",\"string\"})     == \"string\");\n    assert(find_max({\"name\",\"enam\",\"game\"})     == \"enam\");\n    assert(find_max({\"aaaaaaa\",\"bb\",\"cc\"})      == \"aaaaaaa\");\n    assert(find_max({\"abc\",\"ab\",\"abcde\"})       == \"abcde\");\n    assert(find_max({\"!@#\",\"abc\",\"!@#\",\"cba\"})  == \"!@#\"); // same uniq count, lexicographically first\n    assert(find_max({\"xyz\",\"yzx\",\"zxy\"})        == \"xyz\"); // all same uniq count, first in order\n    assert(find_max({\"tiny\",\"tiny\",\"tiny\"})    == \"tiny\"); // same word repeated\n    assert(find_max({})                       == \"\");     // empty input -> empty string\n}\n\nint main()\n{\n    run_tests();\n    std::cout << \"All tests passed.\\n\";\n    return 0;\n}\n```\n\nThe program defines `find_max`, runs a small set of unit tests, and prints\na confirmation message on success.  \nAdjust the test cases as needed to cover edge\u2011conditions for your\nspecific environment.", "You can solve the problem by iterating over the vector once, keeping track of\n\n1. the current maximum number of **unique** letters,\n2. the word that achieves it  \n   (if several words have the same count, keep the lexicographically smallest one).\n\nHere's a clean implementation that works on the examples you provided:\n\n```cpp\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\n// Return the word with the most distinct characters.\n// If several words tie, return the lexicographically first one.\nstd::string find_max(const std::vector<std::string>& words)\n{\n    int best_unique = -1;           // maximum number of unique chars seen so far\n    std::string best_word;          // word that achieved that number\n\n    for (const auto& w : words) {\n        // Count unique characters in the current word\n        std::unordered_set<char> uniq(w.begin(), w.end());\n        int cnt = static_cast<int>(uniq.size());\n\n        // Decide whether to replace the current best\n        if (cnt > best_unique ||\n            (cnt == best_unique && w < best_word))\n        {\n            best_unique = cnt;\n            best_word   = w;\n        }\n    }\n    return best_word;\n}\n```\n\n### How it works\n\n1. `std::unordered_set<char>` stores each character of a word exactly once, so its size is the number of unique characters.\n2. `cnt > best_unique` picks a word with a higher number of unique letters.\n3. `cnt == best_unique && w < best_word` ensures that when there is a tie in the count, the lexicographically smallest word wins (because `std::string` defines `operator<` as lexicographic comparison).\n4. The function returns the best word found.\n\n### Test cases\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << find_max({\"name\", \"of\", \"string\"}) << '\\n'; // string\n    std::cout << find_max({\"name\", \"enam\", \"game\"}) << '\\n';  // enam\n    std::cout << find_max({\"aaaaaaa\", \"bb\", \"cc\"}) << '\\n';   // aaaaaaa\n}\n```\n\nAll the example calls produce the expected results.", "Here is a straightforward implementation of the `find_max` function.  \nIt iterates over every word, counts the number of distinct characters for that word, and keeps track of the best word seen so far.  \nIf two words have the same number of distinct characters, the lexicographically smaller one is kept.\n\n```cpp\n#include <string>\n#include <vector>\n#include <unordered_set>\n\nstd::string find_max(const std::vector<std::string>& words) {\n    std::string best_word;\n    size_t best_unique = 0;\n\n    for (const auto& word : words) {\n        // Count unique characters in the current word\n        std::unordered_set<char> uniq(word.begin(), word.end());\n        size_t unique_count = uniq.size();\n\n        // Update best_word if we found a better candidate\n        if (unique_count > best_unique) {\n            best_unique = unique_count;\n            best_word = word;\n        } else if (unique_count == best_unique) {\n            // For a tie, take the lexicographically smaller word\n            if (!best_word.empty() && word < best_word) {\n                best_word = word;\n            }\n        }\n    }\n    return best_word;\n}\n```\n\n### How it works\n\n1. **Iterate over all words**: For each word we create an `unordered_set<char>` from its characters; the set automatically removes duplicates, so its size is the number of unique characters.\n\n2. **Keep the best word**:  \n   - If the current word has more unique characters than the best found so far, it becomes the new best.  \n   - If the count is equal, we compare the words lexicographically and keep the smaller one.\n\n3. **Return the best word**.\n\nThe function works for the examples you provided:\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<std::string> v1 = {\"name\", \"of\", \"string\"};\n    std::cout << find_max(v1) << '\\n';          // outputs: string\n\n    std::vector<std::string> v2 = {\"name\", \"enam\", \"game\"};\n    std::cout << find_max(v2) << '\\n';          // outputs: enam\n\n    std::vector<std::string> v3 = {\"aaaaaaa\", \"bb\", \"cc\"};\n    std::cout << find_max(v3) << '\\n';          // outputs: aaaaaaa\n}\n```\nThis implementation runs in `O(total_characters)` time and uses `O(max_word_length)` auxiliary space."]}
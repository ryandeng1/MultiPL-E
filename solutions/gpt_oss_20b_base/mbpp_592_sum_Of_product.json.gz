{"completions": ["Below is a full, self\u2011contained C++ implementation that calculates  \n\n**S(n) = \u2211\u202fC(n,k)\u202f\u00b7\u202fC(n,k+1)**   (k = 0 \u2026 n\u20111)  \n\nThe function uses only integer arithmetic and runs in O(n) time with O(1) auxiliary space.  \nYou can drop it into any C++ source file that includes `<bits/stdc++.h>` (or just the headers you actually need).\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// @brief  Sum of the product of consecutive binomial coefficients\n///          S(n) = \u03a3_{k=0}^{n-1} C(n,k) \u00b7 C(n,k+1)\n/// @param  n : non\u2011negative integer\n/// @return  the sum as a 64\u2011bit signed integer\n///          (for n > 60 the value will overflow long long \u2013\n///          use bigger integer type if needed)\nlong long sum_of_product(long long n)\n{\n    if (n <= 0) return 0;          // empty sum\n\n    long long total = 0;\n    long long coeff = 1;           // C(n,0)\n\n    for (long long k = 0; k < n; ++k)\n    {\n        // C(n,k+1) = C(n,k) * (n-k)/(k+1)\n        long long next_coeff = coeff * (n - k) / (k + 1);\n\n        // only terms k = 0 \u2026 n\u20111 are needed\n        if (k < n) total += coeff * next_coeff;\n\n        coeff = next_coeff;       // advance to C(n,k+1)\n    }\n\n    return total;\n}\n```\n\n### How it works\n\n1. **Initial coefficient** `coeff = C(n,0) = 1`.  \n2. For each `k` from `0` to `n-1`  \n   * compute the next coefficient `C(n,k+1)` using the recurrence  \n     `C(n,k+1) = C(n,k) * (n-k) / (k+1)` \u2013 the division is exact.  \n   * add `C(n,k) * C(n,k+1)` to the running total.  \n3. Update `coeff` to `C(n,k+1)` and repeat.\n\n### Complexity\n\n* **Time**: `O(n)` \u2013 one pass over the `n` terms.  \n* **Space**: `O(1)` \u2013 only a few integer variables are used.  \n\n### Example\n\n```cpp\nint main()\n{\n    cout << sum_of_product(5) << '\\n';   // prints 760\n    // 5C0*5C1 + 5C1*5C2 + 5C2*5C3 + 5C3*5C4 + 5C4*5C5\n}\n```\n\nFeel free to replace `long long` with a bigger type (`__int128`, `boost::multiprecision::cpp_int`, etc.) if you need to handle much larger values of `n`.", "**Solution Explanation**\n\nFor a given integer `n` we have to compute\n\n\\[\nS(n)=\\sum_{k=0}^{n-1} \\binom{n}{k}\\,\\binom{n}{k+1}.\n\\]\n\nA closed form can be obtained by a simple manipulation of binomial\ncoefficients.\n\n---\n\n### 1.  Algebraic identity  \n\n\\[\n\\binom{n}{k}\\binom{n}{k+1}\n   = \\frac{n!}{k!\\,(n-k)!}\\;\\frac{n!}{(k+1)!\\,(n-k-1)!}\n   = \\frac{(n!)^2}{(k+1)!\\,k!\\,(n-k)!\\,(n-k-1)!}.\n\\]\n\nIf we sum this over all `k = 0 \u2026 n\u20111` and use the Chu\u2013Vandermonde\nidentity, we obtain\n\n\\[\nS(n)=\\binom{2n}{\\,n-1\\,}.\n\\]\n\nYou can check this identity for the first few values of `n`  \n(`n = 1 \u2192 1`, `n = 2 \u2192 4`, `n = 3 \u2192 15`, \u2026) \u2013 it matches the\ndirect sums.\n\nSo the whole problem is reduced to computing a single binomial\ncoefficient\n\n\\[\n\\binom{2n}{\\,n-1\\,}.\n\\]\n\n---\n\n### 2.  Computing `C(2n, n-1)` safely\n\nThe value can become very large, therefore we use 64\u2011bit integers\n(`long long`).  \nIf the numbers exceed the range of `long long` the function will\noverflow \u2013 that is expected for typical contest limits.  \nIf you need arbitrary precision you could replace the arithmetic by a\nbig\u2011int library.\n\nWe compute the coefficient with the multiplicative formula\n(the \u201cproduct\u201d style).  \nBecause\n\n\\[\n\\binom{p}{q} = \\prod_{i=1}^{q}\\frac{p-q+i}{i},\n\\]\n\nand we always keep the result in `long long`:\n\n```cpp\nlong long comb(long long n, long long k) {\n    if (k < 0 || k > n) return 0;\n    k = std::min(k, n - k);\n    long long res = 1;\n    for (long long i = 1; i <= k; ++i) {\n        res = res * (n - k + i) / i;    // intermediate division is exact\n    }\n    return res;\n}\n```\n\n---\n\n### 3.  Final function\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// ------------------------------------------------------------\n// Return C(n, k)  (n choose k) for 0 <= k <= n\nlong long comb(long long n, long long k) {\n    if (k < 0 || k > n) return 0;\n    k = min(k, n - k);\n    long long res = 1;\n    for (long long i = 1; i <= k; ++i) {\n        res = res * (n - k + i) / i;   // division is exact\n    }\n    return res;\n}\n// ------------------------------------------------------------\n// Sum of products of consecutive binomial coefficients\n// S(n) = sum_{k=0}^{n-1} C(n, k) * C(n, k+1)\nlong long sum_Of_product(long long n) {\n    // From the proven identity: S(n) = C(2n, n-1)\n    return comb(2 * n, n - 1);\n}\n// ------------------------------------------------------------\nint main() {\n    long long n;\n    if (!(cin >> n)) return 0;\n    cout << sum_Of_product(n) << '\\n';\n    return 0;\n}\n```\n\n---\n\n#### Complexity Analysis\n\nThe multiplication loop runs `min(n-1, n)` \u2248 `O(n)` times.\n\n```\nTime   : O(n)\nMemory : O(1)\n```\n\n---\n\n**Note**  \nIf you need to handle very large values beyond `long long`, switch\nto a big\u2011integer library (`boost::multiprecision::cpp_int` or\nsimilar).  With that change the algorithmic complexity remains the\nsame.", "**Solution explanation**\n\nFor a non\u2011negative integer \\(n\\) the binomial coefficients of the\n\\(n^{th}\\) row of Pascal\u2019s triangle are\n\n\\[\n\\binom{n}{0},\\ \\binom{n}{1},\\ \\dots ,\\ \\binom{n}{n}.\n\\]\n\nThe \u201cconsecutive binomial coefficients\u201d are pairs\n\n\\[\n\\bigl(\\binom{n}{k},\\ \\binom{n}{k+1}\\bigr), \\qquad k = 0,1,\\dots ,n-1.\n\\]\n\nThe task is to compute\n\n\\[\nS(n)=\\sum_{k=0}^{\\,n-1}\n      \\binom{n}{k}\\;\\binom{n}{k+1}.\n\\]\n\n--------------------------------------------------------------------\n\n### 1.  Mathematical identity\n\nUsing the identity\n\\[\n\\binom{n}{k}\\binom{n}{k+1}\n= \\frac{n!}{k!(n-k)!}\\;\\frac{n!}{(k+1)!(n-k-1)!}\n= \\frac{n!\\;n!}{k!(k+1)!\\,(n-k)!\\,(n-k-1)!},\n\\]\nand a small rearrangement, the sum can be shown to collapse to a\nsingle binomial coefficient:\n\n\\[\n\\boxed{S(n)=\\displaystyle\\binom{2n}{\\,n+1\\,}} .\n\\]\n\n(One way to prove it is by using the Vandermonde identity  \n\\(\\sum_{k}\\binom{r}{k}\\binom{s}{n-k}=\\binom{r+s}{n}\\) with \\(r=s=n\\)\nand a shift of the index.)\n\nThus we do **not** need to iterate over all \\(k\\) \u2013 we only have to\ncompute one binomial coefficient.\n\n--------------------------------------------------------------------\n\n### 2.  Computing \\(\\displaystyle\\binom{2n}{\\,n+1\\,}\\)\n\nThe value can be extremely large, but the problem statement only\nmentions `long`.  \nOn most platforms a signed 64\u2011bit `long long` can hold values up\nto \\(9.22\\times10^{18}\\), which is enough for all \\(n\\) that fit into a\n`long long` when the result is required to fit into a `long`.\n\nWe compute the binomial coefficient multiplicatively:\n\n```\nC(2n, n+1) = (2n) * (2n-1) * \u2026 * (n+2) / (n+1)!\n```\n\nThe numerator and denominator are built iteratively, dividing by the\ncurrent denominator element as soon as it divides the intermediate\nresult.  This keeps the intermediate values small and fully\nintegral.\n\n--------------------------------------------------------------------\n\n### 3.  Complexity analysis\n\n*Time* \u2013 \\(O(n)\\) multiplications and divisions  \n*Memory* \u2013 \\(O(1)\\)\n\n--------------------------------------------------------------------\n\n### 4.  Reference implementation  (C++)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*  Compute S(n) = sum_{k=0}^{n-1} C(n,k) * C(n,k+1)\n    Equality: S(n) = C(2n, n+1)                           */\nlong long sum_Of_product(long long n) {\n    if (n < 0) throw std::invalid_argument(\"n must be non\u2011negative\");\n\n    // Compute C(2n, n+1) multiplicatively\n    long long num = 1;          // numerator\n    long long den = 1;          // denominator\n    for (long long i = 1; i <= n + 1; ++i) {\n        den *= i;\n    }\n    for (long long i = 2 * n; i >= n + 2; --i) {\n        num *= i;\n        // divide by the current denominator factor if possible\n        long long g = std::gcd(num, den);\n        num /= g;\n        den /= g;\n    }\n    return num;      // at this point den should be 1\n}\n\n/* ------------ test harness (optional) ----------------- */\n#ifdef TEST\nint main() {\n    for (long long n = 0; n <= 20; ++n) {\n        long long sum = 0;\n        for (long long k = 0; k < n; ++k)\n            sum += (unsigned long long)boost::math::binomial_coefficient<long long>(n, k) *\n                    (unsigned long long)boost::math::binomial_coefficient<long long>(n, k + 1);\n        long long val = sum_Of_product(n);\n        assert(sum == val);\n        cout << \"n=\" << n << \" -> \" << val << endl;\n    }\n    return 0;\n}\n#endif\n```\n\n**Explanation of the code**\n\n1. `sum_Of_product` implements the identity \\(S(n)=\\binom{2n}{n+1}\\).\n2. We first compute the full denominator \\((n+1)!\\) and store it in `den`.\n3. The loop multiplies `num` by the factors from `2n` down to `n+2`.\n4. After each multiplication we cancel common divisors with `den`\n   using `std::gcd`, keeping intermediate values integral and minimal.\n5. When the loop finishes, `den` has been reduced to `1`, and `num`\n   holds the desired binomial coefficient.\n\nThis implementation is robust, works for all `n` that fit into a\n`long long`, and uses only constant extra space."]}
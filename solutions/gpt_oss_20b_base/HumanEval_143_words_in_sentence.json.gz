{"completions": ["Here\u2019s a clean implementation that does exactly what you described:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// helper: check if n is prime\nbool isPrime(int n){\n    if (n < 2) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int d = 3; d * d <= n; d += 2)\n        if (n % d == 0) return false;\n    return true;\n}\n\n// main function\nstring words_in_sentence(string sentence){\n    vector<string> result;\n    string word;\n    stringstream ss(sentence);\n    while (ss >> word) {          // read words separated by whitespace\n        if (isPrime((int)word.size()))\n            result.push_back(word);\n    }\n    // join all selected words with a single space\n    string res;\n    for (size_t i = 0; i < result.size(); ++i){\n        if (i) res += ' ';\n        res += result[i];\n    }\n    return res;\n}\n```\n\n### How it works\n1. **Prime checker** \u2013 `isPrime` handles all numbers \u2265\u202f2 (the smallest prime).  \n2. **Splitting the sentence** \u2013 `stringstream` eats whitespace automatically, giving us each word in `word`.  \n3. **Collecting qualified words** \u2013 If a word\u2019s length is prime, we store it.  \n4. **Re\u2011joining** \u2013 We build the final string from the collected words, keeping the original order and separating them by a single space.\n\nIf no word has a prime length, the function will return an empty string. This satisfies the constraints (`len(sentence) <= 100` and only letters).", "Here\u2019s a complete, self\u2011contained implementation of the required function.  \nThe code parses the input sentence, checks each word\u2019s length against a pre\u2011computed list of prime numbers up to 100, and builds the resulting string while preserving the original order of the words.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* Helper: generate all primes <= n using Sieve of Eratosthenes */\nstatic vector<bool> getPrimeFlags(int n = 100) {\n    vector<int> primes;\n    vector<bool> isPrime(n + 1, true);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i * i <= n; ++i)\n        if (isPrime[i])\n            for (int j = i * i; j <= n; j += i)\n                isPrime[j] = false;\n    return isPrime;\n}\n\nstring words_in_sentence(string sentence) {\n    // Pre\u2011compute prime flags only once (static guarantees this)\n    static const vector<bool> isPrime = getPrimeFlags(100);\n\n    // Split the sentence into words\n    vector<string> words;\n    string word;\n    stringstream ss(sentence);\n    while (ss >> word)\n        words.push_back(word);\n\n    // Collect words whose lengths are prime\n    vector<string> result;\n    for (const auto& w : words) {\n        if (isPrime[w.size()])\n            result.push_back(w);\n    }\n\n    // Join the selected words back into a single string\n    string out;\n    for (size_t i = 0; i < result.size(); ++i) {\n        if (i) out += ' ';\n        out += result[i];\n    }\n    return out;\n}\n```\n\n### How it works\n\n1. **Prime table** \u2013 `getPrimeFlags` builds a boolean vector where `isPrime[i]` is `true` if `i` is a prime number.  \n   The table is computed only once thanks to the `static` keyword.\n\n2. **Splitting** \u2013 `stringstream` tokenises the input sentence on whitespace.\n\n3. **Filtering** \u2013 For each word, its length is checked against the prime table; if it\u2019s prime, the word is stored.\n\n4. **Joining** \u2013 The filtered words are concatenated with single spaces between them.\n\n### Example\n\n```cpp\nint main() {\n    cout << '\"' << words_in_sentence(\"This is a test\") << '\"' << '\\n';   // outputs \"is\"\n    cout << '\"' << words_in_sentence(\"lets go for swimming\") << '\"' << '\\n'; // outputs \"go for\"\n}\n```\n\nBoth examples match the required behaviour. The function runs in \\(O(n)\\) time, where \\(n\\) is the length of the input sentence (\u2264\u202f100), and uses \\(O(n)\\) additional space for splitting and reconstruction.", "**Solution Explanation**\n\nFor a sentence we need all words whose character count is a prime number.\nThe order has to stay the same and the result must be a single string\nin which those words are joined by spaces.\n\nConstraints are small (`sentence.length \u2264 100`), so an `O(n)` scan with\nsimple helper functions is completely sufficient.\n\n---\n\n### Algorithm\n1. **Prime checker** \u2013  \n   For a non\u2011negative integer `x`  \n   ```\n   if x < 2 \u2192 false\n   for i = 2 \u2026 sqrt(x)\n       if x % i == 0 \u2192 false\n   return true\n   ```\n\n2. **Split the sentence** \u2013  \n   Use a string stream or manual scan to split by single spaces\n   (the problem guarantees words are separated by a single space).\n\n3. **Filter words** \u2013  \n   For every word, if `isPrime(word.size())` is true, append it to a\n   vector `res`.\n\n4. **Join the result** \u2013  \n   If `res` is empty return `\"\"`.  \n   Otherwise join the words with a single space.\n\n---\n\n### Correctness Proof  \n\nWe prove that the algorithm returns exactly the required string.\n\n*Let* `S` be the input sentence and  \n`W = [w\u2081, w\u2082, \u2026, w_k]` the list of its words in the original order.\n\n1. **Splitting step**  \n   The split by spaces constructs precisely the list `W`.  \n   Therefore for each word processed later the algorithm examines the\n   correct word.\n\n2. **Prime test**  \n   For any word `w_i` its length `|w_i|` is a positive integer.\n   The helper `isPrime` returns `true` iff `|w_i|` is a prime number\n   (definition of primality).  \n   Thus `w_i` is appended to `res` **iff** its length is prime.\n\n3. **Result construction**  \n   `res` contains all and only the prime\u2011length words from `W`, in the\n   same order they were added (since we processed `W` from left to right).\n   Joining them with a single space preserves that order and produces a\n   string that contains precisely those words.\n\nHence the returned string satisfies the specification.\n\n---\n\n### Complexity Analysis\n\n* Let `n = |S|`.  \n* Splitting the string: `O(n)`  \n* Checking each word: sum of word lengths \u2264 `n`; each prime test takes\n  `O(\u221alen) \u2264 O(\u221an)`.  \n  Total `O(n\u221an)` \u2192 with `n \u2264 100` this is negligible.  \n* Memory usage: `O(n)` for the result.\n\n---\n\n### Reference Implementation (C++17)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// ---------- helper: prime check ----------\nbool isPrime(int x) {\n    if (x < 2) return false;\n    for (int d = 2; d * d <= x; ++d) {\n        if (x % d == 0) return false;\n    }\n    return true;\n}\n\n// ---------- main function ----------\nstd::string words_in_sentence(std::string sentence) {\n    vector<string> result;\n    string word;\n\n    // split by space (no empty tokens because input guarantees single space)\n    stringstream ss(sentence);\n    while (ss >> word) {\n        if (isPrime((int)word.size()))\n            result.push_back(word);\n    }\n\n    // join with spaces\n    string out;\n    for (size_t i = 0; i < result.size(); ++i) {\n        if (i) out += ' ';\n        out += result[i];\n    }\n    return out;               // empty if result.empty()\n}\n```\n\nThe code follows the algorithm proven correct above and compiles under\nC++17."]}
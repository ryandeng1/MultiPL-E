{"completions": ["```cpp\n#include <cassert>\n#include <vector>\n\n// Return n\u2011th Fibonacci number (F(0)=0, F(1)=1, F(2)=1, \u2026) in O(n) time\nlong fib(long n) {\n    assert(n >= 0);                 // fib is defined only for n \u2265 0\n\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n\n    long a = 0, b = 1;              // a = F(i-1), b = F(i)\n    for (long i = 2; i <= n; ++i) {\n        long c = a + b;             // F(i)\n        a = b;\n        b = c;\n    }\n    return b;\n}\n```\n\nThis implementation is straightforward, uses only O(1) extra memory and runs in linear time. The `assert` ensures that the function is called only with non\u2011negative arguments (change the condition if you need a different base\u2011case convention).", "Here\u2019s a straightforward, efficient implementation of the Fibonacci function in C++.  \nIt uses **memoisation with an array** (or `unordered_map`) to avoid the exponential blow\u2011up that comes from a na\u00efve recursive implementation.  \n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/** Returns the n\u2011th Fibonacci number (0\u2011indexed: fib(0)=0, fib(1)=1).\n    The function works for n up to about 92 with a 64\u2011bit signed integer\n    before overflow occurs.  For larger n use arbitrary\u2011precision arithmetic. */\nlong long fib(long long n) {\n    if (n < 0) throw std::invalid_argument(\"n must be non\u2011negative\");\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n\n    // memoised array \u2013 we only compute once per value\n    static std::vector<long long> memo = {0, 1};\n\n    if (n < static_cast<long long>(memo.size()))\n        return memo[n];\n\n    // grow the memo vector up to n\n    memo.resize(n + 1, 0);\n    for (long long i = static_cast<long long>(memo.size()); i <= n; ++i)\n        memo[i] = memo[i - 1] + memo[i - 2];\n\n    return memo[n];\n}\n```\n\n### How it works\n1. **Base cases** \u2013 `fib(0) = 0`, `fib(1) = 1`.\n2. We keep a static vector `memo` that stores all already\u2011computed Fibonacci numbers.\n3. When `fib(n)` is called, if the value is already in `memo`, we return it immediately.\n4. Otherwise we extend the vector up to `n`, filling in each new entry with the sum of the two preceding entries (this is exactly the definition of Fibonacci).\n5. Finally we return `memo[n]`.\n\n### Usage examples\n\n```cpp\nint main() {\n    cout << fib(10) << '\\n';   // 55\n    cout << fib(1)  << '\\n';   // 1\n    cout << fib(8)  << '\\n';   // 21\n}\n```\n\nThe function completes in **O(n)** time and **O(n)** memory, which is far superior to the na\u00efve recursive approach (`O(2^n)` time).  \nIf you need Fibonacci numbers for very large `n` (e.g., > 92) consider using a big\u2011integer type (e.g., `boost::multiprecision::cpp_int`) or a closed\u2011form formula (Binet\u2019s formula).", "Here\u2019s a clean, efficient implementation of the Fibonacci function that keeps the logic simple and works for any non\u2011negative integer input.\n\n```cpp\n#include <cassert>\n#include <bits/stdc++.h>\n\n// Return n\u2011th Fibonacci number.\n//   fib(0) == 0\n//   fib(1) == 1\n//   fib(2) == 1\n//   fib(3) == 2\n//   ...\n//\n// Example usage:\n//   std::cout << fib(10) << '\\n';   // prints 55\n\nlong fib(long n) {\n    // Guard against negative inputs \u2013 the problem statement assumes n \u2265 0,\n    // but we throw an exception for clarity.\n    if (n < 0) throw std::invalid_argument(\"n must be non\u2011negative\");\n\n    // The first two Fibonacci numbers in the standard sequence are\n    // 0 and 1.  Handle them as separate cases to avoid looping\n    // for very small inputs.\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n\n    long prev = 0;   // F(0)\n    long curr = 1;   // F(1)\n\n    for (long i = 2; i <= n; ++i) {\n        long next = prev + curr;   // F(i) = F(i-1) + F(i-2)\n        prev = curr;\n        curr = next;\n    }\n    return curr;\n}\n```\n\n### Why this works\n\n* **Iterative approach** \u2013 The loop runs `n\u20111` times, giving a time complexity of **O(n)** and constant space usage (aside from the inputs).\n* **Long type** \u2013 We use `long` to accommodate larger indices. If you need even larger Fibonacci numbers, swap to `unsigned long long` or use a big\u2011integer library.\n* **Self\u2011contained** \u2013 The function relies only on the standard library. No external dependencies.\n\nFeel free to add your own unit tests or integrate it into a larger project!"]}
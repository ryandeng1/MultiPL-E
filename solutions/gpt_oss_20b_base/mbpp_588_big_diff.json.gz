{"completions": ["Below is a tiny, self\u2011contained *C++* function that returns the difference between the largest and the smallest element of a `std::vector<long>`.  \nIt performs a single pass through the vector (O(n) time, O(1) extra space) and uses `assert` to guard against an empty container.\n\n```cpp\n#include <vector>\n#include <cassert>\n#include <limits>\n\n/**\n * @brief  Returns the difference between the largest and smallest element\n *         in a vector of long integers.\n *\n * @param nums  Vector that holds the values.\n * @return      (max_element - min_element)\n *\n * @throws std::invalid_argument if the vector is empty.\n */\nlong big_diff(const std::vector<long>& nums)\n{\n    // Guard against an empty container.\n    assert(!nums.empty());\n    if (nums.empty())   // extra safety \u2013 fall\u2011back to exception\n        throw std::invalid_argument(\"big_diff requires a non\u2011empty vector\");\n\n    long min_v = std::numeric_limits<long>::max();\n    long max_v = std::numeric_limits<long>::min();\n\n    for (long x : nums) {\n        if (x < min_v) min_v = x;\n        if (x > max_v) max_v = x;\n    }\n\n    return max_v - min_v;\n}\n```\n\n### How to use it\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> data = {5, 12, -3, 42, 0};\n\n    try {\n        long diff = big_diff(data);\n        std::cout << \"Largest \u2013 smallest = \" << diff << '\\n';\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << '\\n';\n    }\n    return 0;\n}\n```\n\n**Output**\n\n```\nLargest \u2013 smallest = 45\n```\n\nThe function is intentionally lightweight and avoids any dependency other than the standard library. Feel free to adapt the error handling (e.g., throw a custom exception or return an `optional<long>`) to fit the rest of your project.", "Sure! Below is a self\u2011contained C++17 implementation that does exactly what you asked for \u2013 find the difference between the largest and the smallest value that appears in a given `std::vector<long>`.\n\n```cpp\n#include <vector>\n#include <algorithm>   // std::min_element, std::max_element\n#include <stdexcept>   // std::invalid_argument\n\n/**\n * @brief  Returns the difference between the largest and smallest value\n *         present in the supplied vector.\n *\n * @param  nums  A vector of long integers.  The function does **not**\n *               modify the vector.\n *\n * @return  The largest element in `nums` minus the smallest element.\n *\n * @throws  std::invalid_argument  If the vector is empty.\n */\nlong big_diff(const std::vector<long>& nums)\n{\n    if (nums.empty())\n        throw std::invalid_argument(\"Input vector must contain at least one element\");\n\n    // Find the minimum and maximum in a single pass\n    auto min_max = std::minmax_element(nums.begin(), nums.end());\n\n    // min_max.first  -> iterator to the smallest element\n    // min_max.second -> iterator to the largest  element\n    return *min_max.second - *min_max.first;\n}\n```\n\n### Why this implementation?\n\n| Feature | Why it matters |\n|---------|----------------|\n| **Const reference** to the input vector | Avoids copying and guarantees the function doesn't modify the caller\u2019s data. |\n| **Single pass** (`std::minmax_element`) | Efficient \u2013 only one scan over the data. |\n| **Exception safety** | Throws `std::invalid_argument` if the vector is empty, which is a clear contract for the caller. |\n| **Clear error handling** | The caller can catch the exception and decide how to proceed. |\n\n---\n\n#### Quick usage example\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<long> v{ 3, 7, -2, 12, 5 };\n\n    try {\n        long diff = big_diff(v);\n        std::cout << \"Largest - smallest = \" << diff << '\\n'; // prints 14\n    }\n    catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << '\\n';\n    }\n\n    return 0;\n}\n```\n\nFeel free to drop this function into your project \u2013 it\u2019s fully self\u2011contained and follows the common C++ idioms. Happy coding!", "Sure! Below is a clean, self\u2011contained implementation that returns the difference between the largest and the smallest value in a `std::vector<long>`.  \nI\u2019ve added a few comments and an example of how to call it.\n\n```cpp\n#include <algorithm>   // for std::max_element / min_element\n#include <vector>\n#include <stdexcept>   // for std::invalid_argument\n#include <cstdlib>    // for std::abs\n\n/**\n * @brief Computes the difference between the largest and smallest element\n *        in a vector of long integers.\n *\n * @param nums A vector of long integers.\n * @return long The difference (largest - smallest).\n * @throws std::invalid_argument if the vector is empty.\n */\nlong big_diff(const std::vector<long>& nums)\n{\n    if (nums.empty())\n        throw std::invalid_argument(\"Vector must contain at least one element.\");\n\n    // Using STL algorithms gives us a clear O(n) solution\n    auto [min_it, max_it] = std::minmax_element(nums.begin(), nums.end());\n\n    return *max_it - *min_it;\n}\n\n/* ---------- Example usage ---------- */\n#ifdef DEMO\n#include <iostream>\n\nint main()\n{\n    std::vector<long> v{7, -3, 12, 0, 5};\n\n    try {\n        long diff = big_diff(v);\n        std::cout << \"Largest - smallest = \" << diff << '\\n';   // prints 15\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << '\\n';\n    }\n\n    return 0;\n}\n#endif\n```\n\n### Why this implementation is good\n\n1. **Robustness** \u2013 An empty input throws an exception instead of returning an undefined value.  \n2. **Performance** \u2013 `std::minmax_element` scans the vector only once, giving an O(n) time complexity and O(1) extra space.  \n3. **Readability** \u2013 The code expresses the intent (\u201cfind minimum & maximum\u201d) without manual loops.  \n\nFeel free to compile with any C++17/20 compiler, replacing `DEMO` guard if you want to test it directly."]}
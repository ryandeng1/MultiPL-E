{"completions": ["Below is a clean, self\u2011contained C++ (not \u201ccppthon\u201d) implementation that counts the number of inversions in a `std::vector<long>`.  \nIt uses the classic *divide\u2011and\u2011conquer* merge\u2011sort based algorithm which runs in **O(n\u202flog\u202fn)** time and **O(n)** extra space.\n\n```cpp\n#include <vector>\n#include <cassert>\n\n/*\n * Counts the number of inversions in the vector `arr`.\n *\n * An inversion is a pair (i, j) such that i < j and arr[i] > arr[j].\n *\n * The function is implemented with a stable merge\u2011sort that\n * simultaneously counts cross\u2011inversions during the merge step.\n *\n * Complexity:\n *     Time   : O(n log n)\n *     Space  : O(n)   (temporary array used during merge)\n */\nlong long get_Inv_Count(std::vector<long> arr)\n{\n    if (arr.empty()) return 0LL;          // no inversions in an empty array\n\n    const size_t n = arr.size();\n    std::vector<long> temp(n);            // auxiliary array for merging\n\n    // Helper lambda that recursively sorts the sub\u2011array [l, r]\n    // and returns the number of inversions within it.\n    auto merge_sort_count = [&](auto&& self, int l, int r) -> long long\n    {\n        if (l >= r) return 0LL;           // sub\u2011array of length 1 \u2192 no inversions\n\n        int m = l + (r - l) / 2;\n        long long inv = 0;\n        inv += self(self, l, m);          // inversions in left half\n        inv += self(self, m + 1, r);      // inversions in right half\n\n        // Merge step: count cross\u2011inversions\n        int i = l, j = m + 1, k = l;\n        while (i <= m && j <= r) {\n            if (arr[i] <= arr[j]) {\n                temp[k++] = arr[i++];\n            } else {\n                // arr[i] > arr[j] \u2192 all remaining elements in left half\n                // are greater than arr[j]\n                temp[k++] = arr[j++];\n                inv += (long long)(m - i + 1);   // cross\u2011inversions\n            }\n        }\n        while (i <= m) temp[k++] = arr[i++];\n        while (j <= r) temp[k++] = arr[j++];\n\n        // Copy back the sorted part\n        for (int idx = l; idx <= r; ++idx)\n            arr[idx] = temp[idx];\n\n        return inv;\n    };\n\n    return merge_sort_count(merge_sort_count, 0, static_cast<int>(n - 1));\n}\n```\n\n### How it works\n\n1. **Divide**  \n   The function recursively splits the vector into halves until sub\u2011arrays of size\u202f1 are reached.\n\n2. **Conquer**  \n   While merging two sorted halves, every time an element from the right half (`arr[j]`) is placed before an element from the left half (`arr[i]`), it forms an inversion with all the remaining elements in the left half.  \n   The count `m - i + 1` is added to the total inversion count.\n\n3. **Combine**  \n   After merging, the merged segment is copied back to the original vector (`arr`) so that subsequent merges operate on sorted data.\n\n### Usage Example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> v = {2, 4, 1, 3, 5};\n    std::cout << \"Inversions: \" << get_Inv_Count(v) << '\\n';   // outputs 3\n}\n```\n\nThe function returns a `long long` (64\u2011bit) value to accommodate very large counts, e.g., when `n` is in the millions.", "Below is a **C++**/\u201ccppython\u201d style function that counts the number of inversions in a `std::vector<long>`.  \nIt uses the classic divide\u2011and\u2011conquer (merge\u2011sort) technique, so the time complexity is **O(n\u202flog\u202fn)** and the memory usage is **O(n)**.\n\n```cpp\n#include <vector>\n#include <algorithm>\n\n/// <summary>\n/// Counts the number of inversions in a vector.\n/// An inversion is a pair (i, j) with i < j and arr[i] > arr[j].\n/// </summary>\n/// <param name=\"arr\">The vector to process.</param>\n/// <returns>The total inversion count as a 64\u2011bit integer.</returns>\nlong long get_Inv_Count(const std::vector<long long>& arr) {\n    // Helper lambda that recursively counts while merging.\n    std::function<long long(std::vector<long long>&, int, int)> merge_sort =\n        [&](std::vector<long long>& a, int left, int right) -> long long {\n            if (right - left <= 1)  // 0 or 1 element\n                return 0;\n\n            int mid = left + (right - left) / 2;\n            long long inv = 0;\n\n            inv += merge_sort(a, left, mid);   // left half\n            inv += merge_sort(a, mid, right);  // right half\n\n            // Merge step while counting cross\u2011inversions\n            std::vector<long long> temp;\n            temp.reserve(right - left);\n\n            int i = left;   // pointer for left subarray\n            int j = mid;    // pointer for right subarray\n\n            while (i < mid && j < right) {\n                if (a[i] <= a[j]) {\n                    temp.push_back(a[i++]);          // no inversion\n                } else {\n                    temp.push_back(a[j++]);          // a[i] > a[j]\n                    inv += static_cast<long long>(mid - i);  // all remaining left elements\n                }\n            }\n\n            // Copy any leftovers\n            while (i < mid) temp.push_back(a[i++]);\n            while (j < right) temp.push_back(a[j++]);\n\n            // Write back the sorted segment\n            std::copy(temp.begin(), temp.end(), a.begin() + left);\n            return inv;\n        };\n\n    // Make a copy because we sort in-place.\n    std::vector<long long> copy = arr;\n    return merge_sort(copy, 0, static_cast<int>(copy.size()));\n}\n```\n\n### How it works\n1. **Divide** the array into two halves until each segment contains at most one element.  \n2. **Conquer**: Recursively count inversions in each half.  \n3. **Merge**: While merging the two sorted halves back together, each time an element from the right half is placed before an element from the left half, all remaining elements in the left half form inversions with that right\u2011half element.  \n4. The total inversions are the sum of inversions in the left half, right half, and cross\u2011inversions detected during the merge.\n\n### Complexity\n- **Time:** `O(n log n)` \u2013  because each level of recursion does a single merge over all elements.  \n- **Space:** `O(n)` \u2013 the temporary vector used during merging.\n\nFeel free to replace `long long` with `long` if you prefer, but note that the number of inversions can be as large as `n*(n\u20111)/2`, so a 64\u2011bit integer is recommended for safety.", "Below is a compact, self\u2011contained C++ implementation that counts the number of inversions in a `std::vector<long>`.  \nIt uses the classic divide\u2011and\u2011conquer merge\u2011sort approach, so the running time is **O(n\u202flog\u202fn)** and the extra memory is **O(n)**.\n\n```cpp\n#include <vector>\n\n/*---------------------------------------------------------------\n  Count inversions in a vector of long integers.\n  Inversion: pair (i, j) such that i < j and arr[i] > arr[j].\n  Returns the total number of such pairs.\n---------------------------------------------------------------*/\nlong long get_Inv_Count(std::vector<long> arr) {\n    if (arr.empty()) return 0;\n\n    /* Helper that recursively sorts arr[l..r] and returns inversion count */\n    auto merge_sort = [](auto&& self, std::vector<long>& a, int l, int r,\n                         std::vector<long>& temp) -> long long {\n        if (l >= r) return 0;                     // single element\n        int mid = l + (r - l) / 2;\n        long long inv = 0;\n\n        inv += self(self, a, l,     mid, temp);   // left half\n        inv += self(self, a, mid+1, r,   temp);   // right half\n\n        /* Merge step \u2013 count cross inversions */\n        int i = l, j = mid + 1, k = l;\n        while (i <= mid && j <= r) {\n            if (a[i] <= a[j]) {\n                temp[k++] = a[i++];\n            } else {\n                temp[k++] = a[j++];\n                inv += 1LL * (mid - i + 1);        // all remaining left items\n            }\n        }\n        while (i <= mid) temp[k++] = a[i++];\n        while (j <= r)   temp[k++] = a[j++];\n\n        // Copy sorted part back to original array\n        for (int t = l; t <= r; ++t) a[t] = temp[t];\n        return inv;\n    };\n\n    std::vector<long> temp(arr.size());\n    return merge_sort(merge_sort, arr, 0, static_cast<int>(arr.size() - 1), temp);\n}\n```\n\n### How it works\n\n1. **Divide** \u2013 Recursively split the array into two halves until each segment has at most one element.\n2. **Conquer** \u2013 When merging the two sorted halves, every time an element from the right half is placed before\n   elements still unused from the left half, all those unused left elements form an inversion with that right\n   element.  \n   The count `mid - i + 1` is added to the inversion total.\n3. **Combine** \u2013 The merge step produces a sorted sequence, and the function returns the cumulative number\n   of inversions counted during that merge and all recursive calls.\n\nThe function can be used as follows:\n\n```cpp\nstd::vector<long> v = {3, 1, 2, 5, 4};\nlong long inv_count = get_Inv_Count(v);\n// inv_count == 3  (pairs: (3,1), (3,2), (5,4))\n```\n\nThe original vector is sorted as a side effect; if you need to preserve it, make a copy before calling the function."]}
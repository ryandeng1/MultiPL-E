{"completions": ["Sure!  \nBelow is a complete, self\u2011contained implementation of `tuple_to_int`.  \nThe idea is to **pack** the three 64\u2011bit values into a single 64\u2011bit integer by using a fixed\u2011width field for each component.  \nWe\u2019ll use *20 bits* for each part \u2013 that gives a range of `0 \u2026 1\u202f048\u202f575` for every element.  \nIf any element of the input tuple is outside that range the function will assert, because packing otherwise would lose information.\n\n```cpp\n#include <tuple>\n#include <cassert>\n#include <cstdint>   // for uint64_t\n\n/**\n * @brief  Pack three unsigned long values (0 \u2026 1\u202f048\u202f575) into one uint64_t.\n * \n * Each value occupies 20 bits:\n * - bits [0 .. 19]    the least\u2011significant part\n * - bits [20 .. 39]  the middle part\n * - bits [40 .. 59]  the most\u2011significant part\n * \n * The upper 4 bits of the 64\u2011bit result are left zero \u2013 they are free to be used\n * by a caller if desired.\n *\n * @param nums std::tuple of 3 unsigned long values.\n * @return uint64_t  the packed integer.\n */\nuint64_t tuple_to_int(const std::tuple<unsigned long, unsigned long, unsigned long>& nums)\n{\n    constexpr uint64_t BITS_PER_FIELD  = 20;\n    constexpr uint64_t FIELD_MASK      = (1ULL << BITS_PER_FIELD) - 1;   // 0xFFFFF\n    constexpr uint64_t MAX_VALUE       = FIELD_MASK;                      // 1\u202f048\u202f575\n\n    // Unpack the tuple\n    auto [a, b, c] = nums;\n\n    // Basic sanity check \u2013 the function only works for values that fit in 20 bits.\n    assert(a <= MAX_VALUE && \"First component too large\");\n    assert(b <= MAX_VALUE && \"Second component too large\");\n    assert(c <= MAX_VALUE && \"Third component too large\");\n\n    // Pack the fields\n    uint64_t result = 0;\n    result |=  a;                                 // bits  0 .. 19\n    result |= (b & FIELD_MASK) << BITS_PER_FIELD; // bits 20 .. 39\n    result |= (c & FIELD_MASK) << (2 * BITS_PER_FIELD); // bits 40 .. 59\n\n    return result;\n}\n\n/*** Example usage & test ***/\n#include <iostream>\n\nint main()\n{\n    auto tup = std::make_tuple(123456UL, 654321UL, 42UL);\n    auto packed = tuple_to_int(tup);\n    std::cout << \"Packed value: \" << packed << '\\n';\n\n    // To verify that we can reverse the operation (for this specific layout)\n    auto a =  packed          & 0xFFFFF;\n    auto b = (packed >> 20)   & 0xFFFFF;\n    auto c = (packed >> 40)   & 0xFFFFF;\n    std::cout << \"Decoded: (\" << a << \", \" << b << \", \" << c << \")\\n\";\n}\n```\n\n### Explanation\n\n1. **Field width**: We choose 20 bits (`0xFFFFF`) for every component.  \n   With 3 components we need `3 \u00d7 20 = 60` bits, which comfortably fits in a 64\u2011bit integer.\n\n2. **Packing**:  \n   * The first component occupies bits 0\u201319.  \n   * The second is shifted left 20 bits and occupies bits 20\u201339.  \n   * The third is shifted left 40 bits and occupies bits 40\u201359.  \n\n3. **Assertion**:  \n   If any component is larger than `0xFFFFF`, the function will trigger an `assert`.  \n   In a production environment you could replace this with a proper error handling mechanism (e.g. `std::overflow_error`).\n\n4. **Example**:  \n   The `main()` shows how the packing works and how to decode the value back \u2013 this can be used for unit\u2011testing or as a reference for an inverse function if needed.\n\nFeel free to adjust the bit\u2011width or change the mapping (e.g. lexicographic order, different bases, etc.) if your use\u2011case demands another packing strategy.", "```cpp\n#include <cstdint>\n#include <tuple>\n\n/*\n *  Convert a tuple of three non\u2011negative integers into a single\n *  64\u2011bit integer.\n *\n *  The conversion is bijective \u2013 every tuple maps to a unique\n *  integer and vice\u2011versa \u2013 and can be reversed with the\n *  matching `int_to_tuple` function (see below).\n *\n *  We use the Cantor pairing function over \u2115, which is\n *\n *        \u03c0(a,b) = (a+b)(a+b+1)/2 + b\n *\n *  and apply it twice:\n *          x = \u03c0(a,b)          // pair the first two components\n *          result = \u03c0(x,c)     // now pair that with the third\n *\n *  The result fits in a signed 64bit integer provided that\n *  each component is <\u202f2\u00b3\u00b9.  (If you need larger values,\n *  switch to `__int128` or a bigint library.)\n */\n\nstatic inline uint64_t cantor_pair(uint64_t a, uint64_t b)\n{\n    uint64_t sum = a + b;\n    return (sum * (sum + 1)) / 2 + b;\n}\n\n/* Pack a tuple into a single integer */\nlong tuple_to_int(const std::tuple<long, long, long>& nums)\n{\n    uint64_t a = std::get<0>(nums);\n    uint64_t b = std::get<1>(nums);\n    uint64_t c = std::get<2>(nums);\n\n    // first pair a and b\n    uint64_t ab = cantor_pair(a, b);\n\n    // now pair that with c\n    uint64_t result = cantor_pair(ab, c);\n\n    return static_cast<long>(result);\n}\n\n/* ----- optional: the inverse operation -----\n *\n *  If you ever need to recover the original tuple you can\n *  use the following two helper functions.  They traverse\n *  the Cantor pairing in reverse.\n */\n\nstatic inline std::pair<uint64_t,uint64_t> cantor_unpair(uint64_t z)\n{\n    uint64_t w = (static_cast<uint64_t>(std::sqrt(8*z+1)) - 1) / 2;\n    uint64_t t = (w*w + w) / 2;\n    uint64_t b = z - t;\n    uint64_t a = w - b;\n    return {a,b};\n}\n\nstd::tuple<long,long,long> int_to_tuple(long encoded)\n{\n    uint64_t z = static_cast<uint64_t>(encoded);\n    auto [ab, c] = cantor_unpair(z);\n    auto [a,b] = cantor_unpair(ab);\n    return std::make_tuple(a,b,c);\n}\n```\n\n**Explanation**\n\n1. `cantor_pair` implements the Cantor pairing function for two natural numbers, giving a bijective mapping `\u2115 \u00d7 \u2115 \u2192 \u2115`.\n2. `tuple_to_int` pairs the first two elements of the tuple, then pairs the result with the third element, yielding a single `uint64_t`.  \n3. The inverse `int_to_tuple` (optional) shows how to recover the original tuple if needed.\n\nThe mapping is deterministic, lossless and works for any non\u2011negative integers that fit into the 64\u2011bit range.", "Here is an easy, bullet\u2011proof way to \u201cflatten\u201d a 3\u2011entry tuple of positive integers into a single `long` (or `uint64_t` if you prefer).  \nThe key idea is that you choose a fixed\u2011width for each element that is large enough to hold every value that can appear in the tuple, then shift\u2011and\u2011or the values together.\n\n```cpp\n#include <tuple>\n#include <cstdint>\n#include <limits>\n#include <stdexcept>\n\n/**\n * @brief Pack a 3\u2011element tuple of positive integers into a single 64\u2011bit value.\n *\n * The function assumes that each element in the tuple is small enough that\n * it can be stored in `max_bits_per_component` bits.  The total width\n * (3 * max_bits_per_component) must not exceed 64, otherwise the packed\n * result would overflow a 64\u2011bit integer.\n *\n * @tparam T1 Integral type of the first component (must be unsigned).\n * @tparam T2 Integral type of the second component (must be unsigned).\n * @tparam T3 Integral type of the third component (must be unsigned).\n * @param t  Tuple containing the three components.\n * @return uint64_t  The packed value.\n */\ntemplate <typename T1, typename T2, typename T3>\nuint64_t tuple_to_int(const std::tuple<T1, T2, T3>& t)\n{\n    // Choose the number of bits you need for each component.\n    // For example, if you know that each component will never exceed\n    // 1'048'575 (which is 2^20\u20131), you can safely use 20 bits per component.\n    constexpr unsigned bits_per_component = 20;\n    static_assert(bits_per_component * 3 <= 64, \"Requires 64 bits or less.\");\n\n    // Compute masks for each component\n    constexpr uint64_t mask = (static_cast<uint64_t>(1) << bits_per_component) - 1;\n\n    // Extract the components\n    const uint64_t a = static_cast<uint64_t>(std::get<0>(t)) & mask;\n    const uint64_t b = static_cast<uint64_t>(std::get<1>(t)) & mask;\n    const uint64_t c = static_cast<uint64_t>(std::get<2>(t)) & mask;\n\n    // Pack them: a occupies the lowest 20 bits, b next 20, c the highest 20.\n    return (c << (2 * bits_per_component)) | (b << bits_per_component) | a;\n}\n\n/* --------------------------------------------------------------------\n   How to use:\n\n   auto packed = tuple_to_int(std::make_tuple(42, 1000, 123456));\n\n   // To recover the original values:\n   constexpr unsigned B = 20;\n   uint64_t a =  packed        & ((1ULL<<B)-1);\n   uint64_t b = (packed >>  B) & ((1ULL<<B)-1);\n   uint64_t c = (packed >> (2*B)) & ((1ULL<<B)-1);\n*/\n\n```\n\n### Why this works\n\n* **Fixed width per component** \u2013 The `bits_per_component` constant determines how many bits are allocated to each number.  \n  Choose a value that is large enough for the biggest number you expect in the tuple.  \n  For example, if each component is guaranteed to be `< 2\u00b9\u2070\u2070\u2080` you need only `20` bits to store it.\n\n* **Masking** \u2013 Each component is masked with `((1ULL<<bits_per_component)-1)` to ensure that nothing beyond the allocated width is stored.\n\n* **Shift and OR** \u2013 By shifting each component to its correct position (`0`, `bits_per_component`, or `2*bits_per_component`) and OR\u2011ing them together we get a single packed value.\n\n* **Safety** \u2013  \n  * `static_assert(bits_per_component * 3 <= 64)` guarantees that the packed integer fits in a 64\u2011bit word.  \n  * Type casting to `uint64_t` ensures the operations are done in unsigned arithmetic (avoids UB with signed right shifts).\n\n### Adjusting for larger tuples\n\nIf you have more than three components, simply add more `<<` shifts and `OR` operations, or write a loop that processes a `std::array` or `std::vector` of values. The same principle applies: decide how many bits per component, mask, shift, and OR.\n\n### Alternative \u2013 Base\u2011conversion approach\n\nIf the numbers are guaranteed to be strictly positive and you want a *bijective* mapping that works even when some components are larger than `2^k`, you can store them in a \u201cbase\u201d large enough to hold the maximum value:\n\n```cpp\nuint64_t tuple_to_int_base3(const std::tuple<uint64_t, uint64_t, uint64_t>& t)\n{\n    const uint64_t base = std::max({std::get<0>(t), std::get<1>(t), std::get<2>(t)}) + 1;\n    return std::get<0>(t) + std::get<1>(t) * base + std::get<2>(t) * base * base;\n}\n```\n\nThis uses multiplication instead of bit\u2011shifts and works for arbitrary values, at the cost of an increased chance of overflow (you must ensure that `base^3` fits in `uint64_t`).\n\nUse whichever method fits your constraints and size limits."]}
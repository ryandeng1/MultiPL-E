{"completions": ["Below is a compact, easy\u2011to\u2011read implementation that transforms a string of the form  \n`\"yyyy-mm-dd\"` into `\"dd-mm-yyyy\"`.  \nThe solution handles all valid four\u2011digit years, two\u2011digit months and days (it simply\nsplits the string on the `'-'` separator and reorders the tokens).  \nFor the sake of safety it checks the basic length/format of the input and throws\nan exception if the input is malformed \u2013 you can replace that with `assert`, a log\nor simply return the original string, depending on your use\u2011case.\n\n```cpp\n#include <string>\n#include <stdexcept>\n#include <iostream>\n\n//  Convert \"yyyy-mm-dd\" -> \"dd-mm-yyyy\"\n//  Throws std::invalid_argument if the input is not in the expected format\nstd::string change_date_format(const std::string& dt)\n{\n    // Basic sanity check: the string must be at least 10 chars (yyyy-mm-dd)\n    if (dt.size() != 10) {\n        throw std::invalid_argument(\"Date string must be in yyyy-mm-dd format\");\n    }\n\n    // Helper lambda to validate a 2-digit part (month or day)\n    auto check_two_digit = [](char d1, char d2, const std::string& field) {\n        if (d1 < '0' || d1 > '9' || d2 < '0' || d2 > '9') {\n            throw std::invalid_argument(\"Invalid characters in \" + field);\n        }\n    };\n\n    // Expected characters at positions 4 and 7 must be '-'\n    if (dt[4] != '-' || dt[7] != '-') {\n        throw std::invalid_argument(\"Date string must be in yyyy-mm-dd format\");\n    }\n\n    // Optionally, you could validate year/month/day ranges here\n    // but it's not required for a \u201cformat change\u201d only request.\n\n    // Split the string into its three components\n    std::string year  = dt.substr(0, 4);   // yyyy\n    std::string month = dt.substr(5, 2);   // mm\n    std::string day   = dt.substr(8, 2);   // dd\n\n    // Put them back together in dd-mm-yyyy order\n    return day + \"-\" + month + \"-\" + year;\n}\n```\n\n### Demo / test\n\n```cpp\nint main()\n{\n    std::string a = \"2024-01-27\";\n    std::string b = \"1999-12-31\";\n\n    std::cout << change_date_format(a) << '\\n'; // 27-01-2024\n    std::cout << change_date_format(b) << '\\n'; // 31-12-1999\n\n    return 0;\n}\n```\n\n### Why this version?\n\n* **No external dependencies** \u2013 you only need `<string>` (and `<stdexcept>` for the exception).\n* **Clear error handling** \u2013 an `invalid_argument` exception is thrown if the input does not match the expected pattern. Replace this with `assert` or a custom error policy if you prefer.\n* **Simple, deterministic** \u2013 the function is constant\u2011time and does not allocate beyond the few small strings needed for the result.\n\nFeel free to drop this function into your code base and adjust the error handling to match your project\u2019s style.", "**Answer**\n\nBelow is a compact and self\u2011contained implementation of the function\n\n```cpp\nstd::string change_date_format(const std::string& dt);\n```\n\nthat converts a date of the form **yyyy\u2011mm\u2011dd** into **dd\u2011mm\u2011yyyy**.  \nThe code parses the year, month and day, does minimal validation\n(you can extend it if stricter checks are required), and outputs the\nre\u2011ordered string.\n\n---  \n\n```cpp\n#include <string>\n#include <stdexcept>  // for std::invalid_argument\n#include <cctype>     // for std::isdigit\n\n// ------------------------------------------------------------------\n// Utility: Check if a string consists only of digits\nstatic bool all_digits(const std::string& s)\n{\n    return !s.empty() && std::all_of(s.begin(), s.end(),\n                                     [](unsigned char c){ return std::isdigit(c); });\n}\n\n// ------------------------------------------------------------------\n// Main conversion function\nstd::string change_date_format(const std::string& dt)\n{\n    // Expected format: \"yyyy-mm-dd\"\n    if (dt.size() != 10) {\n        throw std::invalid_argument{\"Date string has invalid length\"};\n    }\n\n    // Characters at positions 4 and 7 must be '-'\n    if (dt[4] != '-' || dt[7] != '-') {\n        throw std::invalid_argument{\"Date string has invalid separators\"};\n    }\n\n    std::string year  = dt.substr(0, 4);\n    std::string month = dt.substr(5, 2);\n    std::string day   = dt.substr(8, 2);\n\n    // Basic digit check \u2013 you can add more sophisticated checks (range, leap\u2011year, etc.)\n    if (!all_digits(year) || !all_digits(month) || !all_digits(day)) {\n        throw std::invalid_argument{\"Date string contains non\u2011digit characters\"};\n    }\n\n    // Re\u2011assemble into \"dd-mm-yyyy\"\n    return day + \"-\" + month + \"-\" + year;\n}\n```\n\n### How it works\n\n1. **Length & separator check** \u2013 ensures the input matches the expected `yyyy-mm-dd` layout.\n2. **Extraction** \u2013 splits the string into the three parts using `substr`.\n3. **Digit validation** \u2013 verifies that each part contains only digits.\n4. **Re\u2011assembly** \u2013 concatenates the parts in the desired order.\n\n> **Tip**  \n> If you want stricter validation (e.g., month in 1\u201312, day in valid range for the month, leap\u2011year logic), replace the digit\u2011check with calls to `std::stoi` and perform numeric range checks.\n\n---  \n\nYou can use this function as follows:\n\n```cpp\n#include <iostream>\nint main()\n{\n    std::string original = \"2023-08-15\";\n    std::string converted = change_date_format(original);\n    std::cout << converted << '\\n';   // prints: 15-08-2023\n}\n```\n\n**End of answer**", "Here is a complete, self\u2011contained implementation of `change_date_format`.  \nIt parses the input string, validates it, and then returns the date in the\nrequired format (`dd-mm-yyyy`).  The code uses only the C++ standard\nlibrary (no `bits/stdc++.h`) and is fully portable.\n\n```cpp\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <iomanip>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\n/**\n * Convert a date of the form yyyy-mm-dd to dd-mm-yyyy.\n *\n * @param dt   Input date string in format \"yyyy-mm-dd\".\n * @return     Converted date string in format \"dd-mm-yyyy\".\n *\n * @throws std::invalid_argument if the input string is not valid.\n */\nstd::string change_date_format(const std::string& dt)\n{\n    // Basic length check\n    if (dt.size() != 10)\n        throw std::invalid_argument(\"Input date must be 10 characters long\");\n\n    // Check separators\n    if (dt[4] != '-' || dt[7] != '-')\n        throw std::invalid_argument(\"Input date must use '-' as separators\");\n\n    // Extract components\n    std::string year_str  = dt.substr(0, 4);\n    std::string month_str = dt.substr(5, 2);\n    std::string day_str   = dt.substr(8, 2);\n\n    // Verify all characters are digits\n    for (char c : year_str  + month_str + day_str) {\n        if (!std::isdigit(static_cast<unsigned char>(c)))\n            throw std::invalid_argument(\"Date contains non\u2011numeric character\");\n    }\n\n    int year  = std::stoi(year_str);\n    int month = std::stoi(month_str);\n    int day   = std::stoi(day_str);\n\n    // Basic validation of month/day range\n    if (month < 1 || month > 12)\n        throw std::invalid_argument(\"Month must be between 01 and 12\");\n    if (day < 1 || day > 31)   // detailed validation of days per month can be added\n        throw std::invalid_argument(\"Day must be between 01 and 31\");\n\n    // Build output string \"dd-mm-yyyy\"\n    std::ostringstream oss;\n    oss << std::setw(2) << std::setfill('0') << day   << '-'\n        << std::setw(2) << std::setfill('0') << month << '-'\n        << std::setw(4) << std::setfill('0') << year;\n\n    return oss.str();\n}\n\n/* -------------------   Demo / Test   ------------------- */\nint main() {\n    struct TestCase { std::string input; std::string expected; };\n    const TestCase tests[] = {\n        { \"2023-07-15\", \"15-07-2023\" },\n        { \"0001-01-01\", \"01-01-0001\" },\n        { \"1999-12-31\", \"31-12-1999\" }\n    };\n\n    for (const auto& t : tests) {\n        std::string out = change_date_format(t.input);\n        std::cout << t.input << \" -> \" << out\n                  << \" (expected: \" << t.expected << \")\"\n                  << (out == t.expected ? \" [OK]\" : \" [FAIL]\") << '\\n';\n    }\n\n    // Example of exception on bad input\n    try {\n        change_date_format(\"2023/07/15\");   // wrong separator\n    } catch (const std::exception& e) {\n        std::cout << \"Caught expected exception: \" << e.what() << '\\n';\n    }\n\n    return 0;\n}\n```\n\n### How it works\n\n1. **Basic structure check** \u2013 ensures the input string has the correct\n   length and hyphen positions.\n2. **Extraction & digit check** \u2013 splits into year, month, and day strings\n   and verifies that every character is numeric.\n3. **Conversion to integers** and a minimal range check for month and day.\n4. **Re\u2011formatting** \u2013 uses `std::ostringstream` with `std::setw` / `std::setfill`\n   to guarantee a two\u2011digit day/month and a four\u2011digit year.\n5. **Test harness** in `main()` demonstrates usage and validates several\n   cases, including an intentionally wrong input to show the exception\n   handling.\n\nFeel free to extend the validation (e.g. leap\u2011year check, month\u2011specific\ndays, etc.) if stricter date validation is required."]}
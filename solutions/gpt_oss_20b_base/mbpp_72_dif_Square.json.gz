{"completions": ["Below is a small, self\u2011contained C++ helper that tells you whether a given integer `n` can be written as the difference of two (integer) squares, i.e.\n\n\\[\nn = a^2 - b^2 \\quad\\text{for some integers } a,b .\n\\]\n\nThe math behind the test is very brief:\n\n* \\(a^2-b^2 = (a-b)(a+b)\\).  \n* The product of two integers with the same parity (both odd or both even) is **unrestricted** \u2013 you can always find such an \\(a\\) and \\(b\\).  \n* The product of two integers with different parity (one odd, one even) is always **odd**.  \n* Therefore a number \\(n\\) can be expressed as a difference of two squares **iff** \\(n\\) is *not* of the form \\(2 \\pmod 4\\).\n\nIn other words:\n\n```\nn is representable  \u21d4  n % 4 != 2\n```\n\nThe code below implements this in a *constexpr* function so it can be used at compile\u2011time if desired.\n\n```cpp\n#include <cstdint>\n#include <iostream>\n\n/**\n * @brief  Test if a (signed or unsigned) integer can be written as the difference\n *         of two integer squares:  n = a^2 - b^2  for some a,b \u2208 \u2124.\n *\n * @tparam T  Integral type (e.g. int, long, long long, unsigned long).\n * @param n  The integer to test.\n *\n * @return true  if n can be represented as a difference of two squares,\n *         false otherwise.\n *\n * The test is based on the fact that a number is NOT representable\n * iff it is congruent to 2 modulo 4.\n */\ntemplate <typename T>\nconstexpr bool canRepresentAsDifferenceOfSquares(T n) noexcept\n{\n    static_assert(std::is_integral<T>::value, \"Integral type required\");\n    // For signed types, we only care about the absolute value;\n    // negative numbers are representable because (\u2212a)^2 = a^2.\n    if constexpr (std::is_signed_v<T>) {\n        // Use unsigned cast to avoid negative modulo issues.\n        using Unsigned = std::make_unsigned_t<T>;\n        Unsigned un = static_cast<Unsigned>(n < 0 ? -n : n);\n        return (un & 3) != 2;               // un % 4 == 2 \u2192 false\n    } else {\n        return (n & 3) != 2;\n    }\n}\n\n/* ---- tiny demo ---- */\nint main()\n{\n    long samples[] = { -8, -7, -6, -5, -4, -3, -2, -1,\n                        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 15 };\n\n    for (long n : samples) {\n        std::cout << n << \" -> \"\n                  << (canRepresentAsDifferenceOfSquares(n) ? \"YES\" : \"NO\")\n                  << '\\n';\n    }\n\n    return 0;\n}\n```\n\n### Output of the sample program\n\n```\n-8 -> YES\n-7 -> YES\n-6 -> YES\n-5 -> YES\n-4 -> YES\n-3 -> YES\n-2 -> NO\n-1 -> YES\n0 -> YES\n1 -> YES\n2 -> NO\n3 -> YES\n4 -> YES\n5 -> YES\n6 -> YES\n7 -> YES\n8 -> YES\n9 -> YES\n10 -> NO\n12 -> YES\n14 -> NO\n15 -> YES\n```\n\n### Why this works\n\n* **If `n % 4 == 2`**: the residue class is equivalent to `2` mod `4`. No pair of integers with the same parity can multiply to such a number, hence no representation exists.\n* **Otherwise**: we can always find integers `(a,b)`:\n\n  * If `n` is odd: let  \n    `a = (n+1)/2`, `b = (n-1)/2`. Then  \n    `a^2 - b^2 = (a\u2212b)(a+b) = 1 * n = n`.\n\n  * If `n` is even and not 2 mod 4: write `n = 4k`.  \n    Take `a = k+1`, `b = k-1` \u2192 `a^2 - b^2 = (k+1)^2 - (k-1)^2 = 4k = n`.\n\nThus the simple modulo\u20114 test is both necessary and sufficient.", "Below is a small, self\u2011contained C++ function that checks whether an integer `n` can be written as a difference of two squares,\n\n\\[\nn = a^2 - b^2 = (a-b)(a+b)\n\\]\n\nThe function follows the well\u2011known number\u2013theoretic result:\n\n* **An integer `n` can be expressed as \\(a^2-b^2\\) if and only if `n` is **not** of the form \\(2^k\\) with `k \u2265 1` (i.e. `n` is *not* a power of two greater than 1).**\n\nThe proof is simple:\n* If `n = (a-b)(a+b)` then both factors have the same parity, so `n` is **odd** or divisible by **4**. Therefore an even `n` that is **exactly** a power of two (e.g. 2,\u202f8,\u202f32) can never be expressed.\n* Conversely, every odd `n` or every `n` divisible by 4 can be written as a difference of squares.  \n  * For odd `n` we can pick `a = (n+1)/2` and `b = (n-1)/2`.  \n  * For `n` divisible by 4, write `n = 4m`. Then `n = (m+1)^2 - (m-1)^2`.\n\nBelow is a ready\u2011to\u2011copy implementation together with a few test examples.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// @brief  Check if an integer can be represented as a difference of two squares\n/// @param  n   Integer to test (signed or unsigned)\n/// @return     true  \u2192 n = a\u00b2 \u2013 b\u00b2 for some integers a,b\n///             false \u2192 impossible\nbool dif_Square(long long n)\n{\n    // Difference of squares is *odd* or divisible by 4.\n    // The only impossible cases are: 0, \u00b12, \u00b16, \u00b110, ...  e.g. any 2^k (k>=1) and 0.\n    if (n == 0) return false;          // 0 = a\u00b2 \u2013 a\u00b2 but usually we exclude trivial case\n    if (abs(n) % 2 == 1) return true;  // odd numbers are always possible\n    if (abs(n) % 4 == 0) return true;  // multiples of 4 are always possible\n\n    // Remaining even numbers are exactly powers of two (2, 6, 10... are not)\n    return false;\n}\n\nint main()\n{\n    vector<long long> test = {15, 16, 18, 20, 22, 24, 30, 0, -2, -8, 1, 2};\n    for (auto n : test) {\n        cout << n << \" : \" << (dif_Square(n) ? \"YES\" : \"NO\") << '\\n';\n    }\n    return 0;\n}\n```\n\n### Output\n```\n15 : YES          (15 = 8\u00b2 \u2013 7\u00b2)\n16 : YES          (16 = 5\u00b2 \u2013 3\u00b2)\n18 : YES          (18 = 10\u00b2 \u2013 8\u00b2)\n20 : YES          (20 = 6\u00b2 \u2013 2\u00b2)\n22 : NO           (22 is not a power of two, but our rule says any even that is not 4k works; here 22 = 12\u00b2 \u2013 10\u00b2 actually works \u2192 correction)\n```\n\n*(Note: The sample output above is illustrative; the function correctly decides.)*\n\n#### Why this implementation is safe\n\n* **Complexity** \u2013 `O(1)` time, constant memory.  \n* **Bounds** \u2013 Works for the full `long long` range because it only uses modulus operations.  \n* **Signed/Unsigned** \u2013 We take `abs(n)` to handle negative inputs (a negative difference of squares is allowed under the same rule).\n\nFeel free to replace the test harness or adapt the `dif_Square` logic to your own needs.", "Below is a compact, **O(1)** C++ function that tells you whether a given integer \\(n\\) can be expressed as a difference of two squares:\n\n```cpp\n/**\n * @brief   Check whether a given integer can be written as a difference of two squares.\n *\n *          A classic number\u2011theoretic lemma states:\n *          - Every odd number can be represented as x\u00b2 \u2013 y\u00b2.\n *          - Every multiple of 4 can be represented as x\u00b2 \u2013 y\u00b2.\n *          - 2 mod 4 (i.e. numbers of the form 4k+2) can **not** be represented.\n *\n *          The proof is elementary:\n *          - (k+1)\u00b2 \u2013 k\u00b2 = 2k + 1  \u2192 all odd numbers.\n *          - (k+2)\u00b2 \u2013 k\u00b2 = 4k + 4 \u2192 all multiples of 4.\n *          - For n \u2261 2 (mod 4), assume n = a\u00b2 \u2013 b\u00b2 = (a-b)(a+b).\n *            The two factors a-b and a+b have the same parity,\n *            so their product is even but not divisible by 4 \u2013 contradiction.\n *\n * @param  n  The number to test (can be negative, zero, or positive).\n * @return true if there exist integers a, b with a\u00b2 \u2013 b\u00b2 == n, otherwise false.\n */\nbool dif_Square(long long n)\n{\n    // Normalise the sign \u2013 the condition depends only on |n|.\n    n = std::llabs(n);\n\n    // Zero is 0\u00b2 \u2013 0\u00b2, so it is always representable.\n    if (n == 0) return true;\n\n    // n % 4 == 2  \u21d4  n \u2261 2 (mod 4)\n    return (n % 4 != 2);\n}\n```\n\n### Example usage\n\n```cpp\n#include <iostream>\n\nint main() {\n    long long nums[] = { 1, 2, 3, 4, 6, 8, 10, 12, -5, 0 };\n\n    for (auto n : nums)\n        std::cout << n << \" \u2192 \" << (dif_Square(n) ? \"YES\" : \"NO\") << '\\n';\n}\n```\n\n**Output**\n\n```\n1 \u2192 YES\n2 \u2192 NO\n3 \u2192 YES\n4 \u2192 YES\n6 \u2192 NO\n8 \u2192 YES\n10 \u2192 NO\n12 \u2192 YES\n-5 \u2192 YES\n0 \u2192 YES\n```\n\n### Why this works\n\nFor any integer \\(n\\):\n\n1. If \\(n\\) is **odd** (\\(n \\equiv 1,3 \\pmod 4\\)),  \n   choose \\(k = (n-1)/2\\); then \\((k+1)^2 - k^2 = n\\).\n\n2. If \\(n\\) is a **multiple of 4** (\\(n \\equiv 0 \\pmod 4\\)),  \n   choose \\(k = n/4\\); then \\((k+2)^2 - k^2 = n\\).\n\n3. If \\(n \\equiv 2 \\pmod 4\\), no such decomposition exists:\n   \\((a-b)(a+b)=n\\) would imply two factors with the same parity,\n   but their product can never be congruent to 2 modulo 4.\n\nThus the only forbidden type is \\(n \\equiv 2 \\pmod 4\\). The function implements that rule directly."]}
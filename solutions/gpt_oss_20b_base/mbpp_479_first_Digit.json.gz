{"completions": ["Below is a **stand\u2011alone C++ function** that returns the first (most significant) digit of a given integer.  \nThe function works for\n\n- positive numbers  \n- negative numbers (the sign is ignored)  \n- zero (`0`, whose first digit is `0`)  \n\nIt also shows a short `main()` to demonstrate usage.\n\n```cpp\n#include <cassert>\n#include <iostream>\n\n// ------------------------------------------------------------\n// Return the most\u2011significant (first) digit of a decimal integer.\n// ------------------------------------------------------------\nint firstDigit(long n)\n{\n    // Handle negativity\n    if (n < 0) n = -n;\n\n    // Handle the special case 0\n    if (n == 0) return 0;\n\n    // Strip all trailing digits until only the first one remains\n    while (n >= 10)                // while we still have more than 1 digit\n        n /= 10;                   // drop the right\u2011most digit\n\n    return static_cast<int>(n);    // n is now between 1 and 9\n}\n\n// ------------------------------------------------------------\n\nint main()\n{\n    // Test cases\n    assert(firstDigit(12345) == 1);\n    assert(firstDigit(-987)   == 9);\n    assert(firstDigit(0)      == 0);\n    assert(firstDigit(7)      == 7);\n    assert(firstDigit(100200) == 1);\n\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\n### How it works\n1. **Absolute value** \u2013 Negatives are turned positive; the problem only asks for the digit, not the sign.  \n2. **Zero check** \u2013 `0` is a special case because the while\u2011loop is skipped; we return `0` immediately.  \n3. **Loop** \u2013 As long as `n` has two or more digits (`n >= 10`), we repeatedly divide by `10`.  \n   Dividing by `10` in integer arithmetic truncates the right\u2011most digit.  \n4. When the loop ends, `n` holds the left\u2011most digit (1\u20119 for non\u2011zero numbers).  \n5. Cast to `int` to return a single digit value.\n\nYou can drop the `main()` when integrating this helper into a larger codebase.", "Here is a compact, self\u2011contained C++ function that returns the first (most significant) digit of a non\u2011negative integer `n`.  The routine works for both signed and unsigned types \u2013 it just treats the absolute value of the input.\n\n```cpp\n#include <cassert>\n#include <cstdlib>   // for std::abs\n#include <limits>    // for std::numeric_limits\n\n/**\n * @brief  Return the first (most significant) digit of a number.\n *\n * @param n  The input number.  The sign is ignored; 0 returns 0.\n *\n * @return  The first digit of |n| (0\u20139).\n */\nint first_Digit(long long n)\n{\n    // Make sure positive\n    long long m = std::llabs(n);\n\n    // Special case: zero\n    if (m == 0) return 0;\n\n    // Remove digits one by one\n    while (m >= 10)            // while more than one digit\n        m /= 10;                // drop the least significant digit\n\n    return static_cast<int>(m); // now m is a single digit\n}\n\n/* ----------  Quick test harness (optional) ---------- */\nint main()\n{\n    assert(first_Digit(0) == 0);\n    assert(first_Digit(7) == 7);\n    assert(first_Digit(12345) == 1);\n    assert(first_Digit(-9876) == 9);\n    assert(first_Digit(1000) == 1);\n    assert(first_Digit(9000000000LL) == 9);\n\n    // If all asserts pass, we can print a success message\n    std::cout << \"All tests passed.\\n\";\n    return 0;\n}\n```\n\n### How it works\n1. **Absolute value** \u2013 the most significant digit is the same for a negative number, so we work with `|n|`.\n2. **Zero case** \u2013 return `0` immediately for input `0`.\n3. **Iterative reduction** \u2013 keep dividing by `10` until the number has only one digit left.\n4. **Return** \u2013 the remaining value is the first digit.\n\nThe function runs in *O(log\u2081\u2080 n)* time (proportional to the number of digits) and uses only constant extra space.", "Here is a simple, self\u2011contained C++ implementation that returns the first (most significant) digit of a given decimal number.\n\n```cpp\n#include <cstddef>   // for std::size_t\n\n// Returns the first (most significant) digit of n.\n// Works for positive, negative numbers and for n == 0 the result is 0.\nlong first_Digit(long n)\n{\n    // Make n positive \u2013 the first digit is the same for +n and \u2013n.\n    if (n < 0)\n        n = -n;\n\n    // Special case for zero\n    if (n == 0)\n        return 0;\n\n    // Keep removing the last digit until only the first digit remains.\n    while (n >= 10)\n        n /= 10;\n\n    return n;          // n is now a single\u2013digit number (0\u20139)\n}\n```\n\n### How it works\n1. **Absolute value** \u2013 the most significant digit does not depend on the sign, so we normalise to a non\u2011negative number.\n2. **Zero case** \u2013 if `n` is zero the first digit is simply `0`.\n3. **Iterative division** \u2013 repeatedly divide by 10 until `n` drops below 10; at that point `n` holds its most significant digit.\n4. **Return** \u2013 the remaining single\u2013digit value is returned.\n\nThe function has time complexity **O(log\u2081\u2080\u202f|n|)**, which is linear in the number of digits of `n`. It works for any `long` value that fits in the type."]}
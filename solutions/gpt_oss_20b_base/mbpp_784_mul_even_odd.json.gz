{"completions": ["```cpp\n#include <vector>\n#include <stdexcept>\n\n/**\n * @brief Computes the product of the first even number and the first odd number in a vector.\n *\n * The function scans the vector from left to right, keeping track of the first\n * even number it encounters and the first odd number it encounters.  \n * If either an even or an odd number is missing, an exception is thrown.\n *\n * @param list1 The input vector of long integers.\n * @return long The product of the first even and the first odd number.\n *\n * @throws std::runtime_error if no even or no odd number exists in the vector.\n */\nlong mul_even_odd(const std::vector<long> &list1) {\n    long first_even = 0;\n    long first_odd  = 0;\n    bool even_found = false;\n    bool odd_found  = false;\n\n    for (long val : list1) {\n        if (!even_found && val % 2 == 0) {\n            first_even = val;\n            even_found = true;\n        }\n        if (!odd_found && val % 2 != 0) {\n            first_odd = val;\n            odd_found = true;\n        }\n        if (even_found && odd_found) break;      // both found, no need to continue\n    }\n\n    if (!even_found || !odd_found) {\n        throw std::runtime_error(\n            \"Vector must contain at least one even and one odd number.\");\n    }\n\n    return first_even * first_odd;\n}\n```\n\n**Explanation**\n\n1. Iterate through the vector once.  \n2. Keep the first even (`first_even`) and the first odd (`first_odd`) values.  \n3. As soon as both are found, break out of the loop to keep it O(n).  \n4. If either number is missing, throw an exception \u2013 otherwise return their product.  \n\nThis implementation uses only standard library components and compiles with a C++ compiler (C++11 or newer).", "```cpp\n#include <vector>\n#include <limits>\n\n/*\n * Find the product of the first even number and the first odd number\n * that appear in `list1`.  \n *\n * * If either an even or an odd number is missing, the function\n *   returns 0.  (You may also choose to throw an exception or return\n *   a special value \u2013 here 0 is used for simplicity.)\n *\n * * The search is performed in the order of appearance in the vector,\n *   so the \u201cfirst\u201d even (or odd) is the one that occurs earliest.\n *\n * \u2192 Complexity: O(n) \u2013 a single scan of the vector.\n */\nlong mul_even_odd(const std::vector<long>& list1)\n{\n    long first_even = std::numeric_limits<long>::min();   // sentinel\n    long first_odd  = std::numeric_limits<long>::min();   // sentinel\n\n    for (const long &v : list1)\n    {\n        if (v % 2 == 0 && first_even == std::numeric_limits<long>::min())\n            first_even = v;\n        else if (v % 2 != 0 && first_odd == std::numeric_limits<long>::min())\n            first_odd = v;\n\n        /* stop early once both have been found */\n        if (first_even != std::numeric_limits<long>::min() &&\n            first_odd  != std::numeric_limits<long>::min())\n            break;\n    }\n\n    if (first_even == std::numeric_limits<long>::min() ||\n        first_odd  == std::numeric_limits<long>::min())\n        return 0;                // one (or both) of the numbers missing\n\n    return first_even * first_odd;\n}\n```\n\n### How to use it\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> v{3, 4, 7, 10, 5};\n    std::cout << mul_even_odd(v) << '\\n';   // 4 * 3 = 12\n    return 0;\n}\n```\n\nThe function scans the vector once, stores the first even and the first odd it encounters, and then multiplies them. If the vector contains only even numbers or only odd numbers (or is empty), it returns `0`. Adjust the sentinel logic or return value to fit your particular error\u2011handling needs.", "Here is a clean, self\u2011contained implementation that follows the requirements:\n\n```cpp\n#include <vector>\n#include <cstddef>   // for std::size_t\n\n/**\n * @brief  Return the product of the first even element and the first odd element\n *         in the given vector.\n *\n * @param  list1  The vector of long integers.\n *\n * @return The product of the first even and the first odd element found.\n *         If either an even or an odd element is not present the function\n *         returns 0.\n *\n * @note  The function does **not** modify the input vector.\n *\n * @example\n *      std::vector<long> v{3, 2, 5, 8};\n *      // first odd = 3, first even = 2  \u2192  product = 6\n *      long result = mul_even_odd(v);   // result == 6\n */\nlong mul_even_odd(const std::vector<long>& list1)\n{\n    long first_even = 0; // 0 will be replaced when an even value is found\n    long first_odd  = 0; // same for odd\n\n    bool even_found = false;\n    bool odd_found  = false;\n\n    for (const long& val : list1)\n    {\n        if (!even_found && (val % 2 == 0))\n        {\n            first_even = val;\n            even_found = true;\n        }\n\n        if (!odd_found && (val % 2 != 0))\n        {\n            first_odd = val;\n            odd_found = true;\n        }\n\n        // If we already found both, we can stop early\n        if (even_found && odd_found)\n            break;\n    }\n\n    // If either type was never found, return 0 as defined\n    if (!even_found || !odd_found)\n        return 0;\n\n    return first_even * first_odd;\n}\n```\n\n### Why this implementation works\n\n1. **Single pass** \u2013 We scan the vector only once and stop as soon as both a first even and a first odd number have been located.  \n2. **Constant extra space** \u2013 Only a few scalar variables are used.  \n3. **Robustness** \u2013 If the vector has no even element *or* no odd element, the function returns `0`, which is a clear \u201cno\u2011product\u2011found\u201d indication.  \n4. **Non\u2011mutating** \u2013 The input vector is passed as a `const` reference, so the original data isn\u2019t altered.\n\nFeel free to adjust the return policy (`0` vs. `-1` vs. throwing an exception) if your application requires a different error\u2011handling strategy."]}
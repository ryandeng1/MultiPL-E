{"completions": ["Below is a simple, self\u2011contained C++ function that returns the number of positive divisors of a given integer\u202f`n`.  \nThe function works for both positive and negative numbers \u2013 for negative arguments it simply counts the divisors of the absolute value (since the set of divisors of `\u2212n` is the same as for `n`).  \nThe algorithm runs in `O(\u221an)` time, which is fast enough for any integer that fits in a 64\u2011bit signed type.\n\n```cpp\n#include <bits.h>          // common inclusion if you already use <bits/stdc++.h>\n#include <cmath>           // for std::sqrt\n#include <cstdint>        // for int64_t\n\n/*  Return the number of positive divisors of n.\n    n can be any 64\u2011bit signed integer; 0 or \u00b11 return 1.\n*/\nlong long divisor(long long n)\n{\n    if (n == 0) return 0;          // convention: 0 has infinitely many divisors \u2013 0 for \"undefined\"\n    n = std::llabs(n);             // work with the absolute value\n\n    long long cnt = 0;\n    long long r = std::sqrt(static_cast<double>(n));\n\n    for (long long i = 1; i <= r; ++i) {\n        if (n % i == 0) {\n            cnt += 2;              // i and n / i\n        }\n    }\n    // If n is a perfect square, we counted the middle divisor twice\n    if (r * r == n) cnt--;\n\n    return cnt;\n}\n```\n\n### Quick usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << divisor(24) << '\\n';   // 24 has 8 divisors: 1,2,3,4,6,8,12,24\n    std::cout << divisor(-36) << '\\n';  // same as 36 \u2192 9 divisors\n    std::cout << divisor(1) << '\\n';    // 1 has exactly 1 divisor\n    std::cout << divisor(0) << '\\n';    // 0 case \u2013 returns 0 (you can modify if needed)\n}\n```\n\nFeel free to adapt the function signature to your project's needs (e.g., change the return type or parameter type).", "Below is a **stand\u2011alone C++ implementation** that counts the number of positive divisors of a given integer `n`.  \nIt uses the prime\u2011factorisation trick:  \nIf  \n\n\\[\nn=\\prod_{i=1}^{k}\\!p_i^{e_i} ,\n\\]\n\nthen the number of divisors is  \n\n\\[\n\\tau(n)=\\prod_{i=1}^{k}(e_i+1).\n\\]\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// @brief  Count the number of positive divisors of a (possibly large) integer.\n///\n/// @param n  The integer whose divisors we want to count.\n/// @return   The number of positive divisors of n.\n///\n/// @note\n///   \u2022 Works for 1 \u2264 n \u2264 10^12 on a 64\u2011bit machine.\n///   \u2022 For n == 0 we return 0 (undefined number of divisors).\ninline long long divisor(long long n)\n{\n    if (n <= 0) return 0;          // 0 has infinitely many divisors \u2013 not counted\n\n    long long count = 1;           // result accumulator\n\n    // count factors of 2 first\n    int exp = 0;\n    while (n % 2 == 0) {\n        n    /= 2;\n        exp++;\n    }\n    if (exp > 0) count *= (exp + 1);\n\n    // check odd divisors up to sqrt(n)\n    for (long long d = 3; d * d <= n; d += 2) {\n        if (n % d == 0) {\n            exp = 0;\n            while (n % d == 0) {\n                n /= d;\n                exp++;\n            }\n            count *= (exp + 1);\n        }\n    }\n\n    // if n is prime > 1 at this point\n    if (n > 1) count *= 2;   // exponent 1 \u2192 (1+1)\n\n    return count;\n}\n```\n\n### How it works\n\n| Step | What happens | Why |\n|------|--------------|-----|\n| **1** | Handle edge cases (`n <= 0`). | Divisors are defined only for positive ints. |\n| **2** | Count factor `2` (even numbers). | Even numbers are frequent; handling them separately loosens the loop\u2019s stride. |\n| **3** | Loop over odd candidates `d = 3,5,7,\u2026` up to `sqrt(n)`. | All remaining prime factors must be odd. |\n| **4** | For each divisor found, divide out all its powers, keep exponent `exp`. | The exponent determines how many divisors come from this prime. |\n| **5** | If a prime factor larger than `sqrt(original n)` remains, it must have exponent 1. | Multiply final count by `2` (`1+1`). |\n\n### Complexity\n\n- **Time**: \\(O(\\sqrt n)\\) in the worst case (for a prime `n`).\n- **Memory**: \\(O(1)\\).\n\nThis function runs easily under a millisecond for values up to \\(10^{12}\\) on modern CPUs. If you need to handle numbers larger than that, you may switch to a faster prime\u2011factorisation technique (e.g. Pollard\u2011Rho).", "Here\u2019s a minimal, self\u2011contained implementation of the `divisor` function that counts the number of divisors of a given integer.  \nIt works for positive and negative inputs (the sign is ignored, because negative numbers have the same number of positive divisors as their absolute value).  \n\n```cpp\n#include <cmath>\n\n/// Returns the number of (positive) divisors of n.\n/// The function works for n == 0 (returns 0) and for negative n\n/// by simply taking the absolute value.\nlong divisor(long n)\n{\n    if (n == 0) return 0;          // 0 has infinitely many divisors \u2013 here we return 0\n    n = std::llabs(n);             // work with absolute value\n\n    long cnt = 0;\n    long root = static_cast<long>(std::sqrt(static_cast<long double>(n)));\n\n    for (long i = 1; i <= root; ++i) {\n        if (n % i == 0) {\n            if (i == n / i)          // perfect square \u2013 count only once\n                ++cnt;\n            else                     // pair of distinct divisors\n                cnt += 2;\n        }\n    }\n    return cnt;\n}\n```\n\n### Why this implementation?\n| Feature | Reason |\n|---------|--------|\n| Uses `std::llabs` | Works with negative numbers safely. |\n| Handles **0** | Defined as 0 \u2013 you can change this if you need a different convention. |\n| Runs in **O(\u221an)** | Efficient for numbers up to about `10^12` on modern hardware. |\n\n### Quick usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << divisor(28) << '\\n'; // 6  (1,2,4,7,14,28)\n    std::cout << divisor(-12) << '\\n'; // 6  (1,2,3,4,6,12)\n    return 0;\n}\n```\n\nFeel free to adapt the return value for `n == 0` or to adjust the precision if you work with `long long` values larger than the range of `long`."]}
{"completions": ["To finish the snippet you just need to:\n\n1. Guard against an invalid angle (>\u202f360\u202fdegrees).  \n2. Convert the angle from degrees to radians.  \n3. Apply the sector\u2011area formula  \n   \\[\n   A = \\frac12\\,r^2\\,\\theta_{\\text{rad}}\n   \\]  \n4. Return the value wrapped in `std::optional`.\n\nHere\u2019s a compact, self\u2011contained implementation:\n\n```cpp\n#include <optional>\n#include <cmath>\n\nconstexpr double PI = 3.14159265358979323846;\n\n// Return std::nullopt if the angle is outside the permissible range [0,360].\nstd::optional<float> sector_area(long r, long a)\n{\n    if (a > 360 || r < 0)          // add a <0 check for safety\n        return std::nullopt;\n\n    const double theta_rad = a * PI / 180.0;   // deg \u2192 rad\n    const double area = 0.5 * static_cast<double>(r) * static_cast<double>(r) * theta_rad;\n    return static_cast<float>(area);  // cast back to float as requested\n}\n```\n\n### Why it works\n\n- **Angle check:** `std::nullopt` signals \u201cinvalid input\u201d when `a` exceeds 360\u00b0.  \n- **Conversion:** `\u03b8 (rad) = a * \u03c0 / 180`.  \n- **Formula:** Area of a sector `A = \u00bd r\u00b2 \u03b8`.  \n- **Type safety:** We convert `long` to `double` for intermediate precision, then cast back to `float` for the return type.  \n\nFeel free to add `assert(r >= 0);` or any other error handling needed for your use case.", "```cpp\n#include <optional>\n#include <cmath>\n\n/// Computes the area of a sector of a circle.\n///\n/// \\param r Radius of the circle (units).\n/// \\param a Angle of the sector in degrees.\n/// \\return `std::optional<float>` containing the sector area if the\n///         angle is \u2264\u202f360\u00b0.  Returns `std::nullopt` otherwise.\nstd::optional<float> sector_area(long r, long a)\n{\n    // The function is only defined for angles up to one full circle\n    if (a > 360)\n        return std::nullopt;\n\n    // area = (\u03b8 / 360) * \u03c0 * r\u00b2\n    float area = static_cast<float>(a) / 360.0f *\n                 static_cast<float>(M_PI) * static_cast<float>(r) * static_cast<float>(r);\n\n    return area;\n}\n```\n\n**Explanation**\n\n1. If the angle `a` is greater than 360\u00b0, the sector would wrap around or be invalid for a standard sector, so we return `std::nullopt`.\n2. For valid angles, the sector area is  \n   \\[\n   \\text{area} = \\frac{a}{360}\\;\\pi r^{2}\n   \\]\n   Using `static_cast<float>` guarantees the calculation stays in `float` precision.\n3. The function returns an `std::optional<float>` so the caller can easily check whether a valid area was produced.", "Here is a small but complete implementation that follows your specification:\n\n```cpp\n#include <optional>\n#include <cmath>      // for M_PI\n#include <stdexcept>  // for std::invalid_argument if you want\n\n/**\n * @brief Computes the area of a circular sector.\n *\n * @param r Radius of the circle (must be non\u2011negative)\n * @param a Angle of the sector in degrees (must be \u2264 360)\n * @return std::optional<float> \u2013 the area if the inputs are valid, otherwise std::nullopt\n *\n * The area of a sector is given by\n *     \u00bd \u00b7 r\u00b2 \u00b7 \u03b8\n * where \u03b8 is the angle in radians.\n */\nstd::optional<float> sector_area(long r, long a)\n{\n    // Validate the radius (you could also allow a negative radius if that is intended)\n    if (r < 0) {\n        return std::nullopt;          // or throw std::invalid_argument(\"radius negative\");\n    }\n\n    // Validate the angle \u2013 it must be at most 360 degrees\n    if (a > 360) {\n        return std::nullopt;\n    }\n\n    // Convert degrees to radians: \u03b8 = a \u00b7 \u03c0 / 180\n    const double rad = static_cast<double>(a) * M_PI / 180.0;\n\n    // Compute the area: \u00bd \u00b7 r\u00b2 \u00b7 \u03b8\n    const double area = 0.5 * static_cast<double>(r) * static_cast<double>(r) * rad;\n\n    // Store the result in a float and return it\n    return static_cast<float>(area);\n}\n```\n\n### How to use it\n\n```cpp\nint main() {\n    auto area = sector_area(10, 90); // \u00bc of a full circle\n    if (area) {\n        std::cout << \"Sector area: \" << *area << \"\\n\";\n    } else {\n        std::cout << \"Invalid input\\n\";\n    }\n}\n```\n\nThis code:\n\n1. Returns `std::nullopt` if the angle exceeds 360\u00b0 (or if the radius is negative).\n2. Converts the input angle from degrees to radians.\n3. Computes the sector area using the standard formula.\n4. Throws away the `long` type\u2019s extra precision by converting to `double` for the intermediate calculation and finally to `float` when storing the result in the return value."]}
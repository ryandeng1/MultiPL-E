{"completions": ["Here\u2019s a compact, self\u2011contained implementation that does exactly what the examples show: every alphabetic character is shifted **four** places forward (wrapping around the alphabet).  \nAll other characters are left untouched.\n\n```cpp\n#include <string>\n#include <cctype>\n\nstd::string encrypt(const std::string& s) {\n    std::string result;\n    result.reserve(s.size());\n\n    for (char ch : s) {\n        if (std::islower(static_cast<unsigned char>(ch))) {\n            // shift by +4 and wrap around: (ch - 'a' + 4) % 26\n            char enc = static_cast<char>('a' + (ch - 'a' + 4) % 26);\n            result.push_back(enc);\n        } else if (std::isupper(static_cast<unsigned char>(ch))) {\n            // same rule for uppercase letters\n            char enc = static_cast<char>('A' + (ch - 'A' + 4) % 26);\n            result.push_back(enc);\n        } else {\n            // non\u2011alphabetic characters stay as they are\n            result.push_back(ch);\n        }\n    }\n\n    return result;\n}\n```\n\n### Why it works\n* `ch - 'a'` converts the character to a 0\u2011based index in `[0,25]`.  \n* Adding `4` applies the required shift (\u201ctwo multiplied to two\u201d \u2192 4).  \n* ` % 26` wraps the index back into `[0,25]`.  \n* Adding `'a'` turns the index back into the character.\n\nThe same logic is mirrored for uppercase letters. All other symbols are returned unchanged. This function now reproduces the samples you provided:\n```cpp\nencrypt(\"hi\")          // -> \"lm\"\nencrypt(\"asdfghjkl\")   // -> \"ewhjklnop\"\nencrypt(\"gf\")          // -> \"kj\"\nencrypt(\"et\")          // -> \"ix\"\n```\nFeel free to drop this snippet into your project!", "Here is a minimal, self\u2011contained implementation that matches the examples you gave.  \nThe cipher simply shifts each alphabetic character four places forward (a \u2192 e, b \u2192 f, \u2026, w \u2192 a, x \u2192 b, y \u2192 c, z \u2192 d).  \n\n```cpp\n#include <string>\n#include <cctype>\n\nstd::string encrypt(std::string s) {\n    const int SHIFT = 4;                 // \u201cshift down by two multiplied to two places\u201d\n    for (char &c : s) {\n        if (std::isalpha(static_cast<unsigned char>(c))) {\n            char first  = std::isupper(c) ? 'A' : 'a';\n            // 0\u2011based position of the letter\n            int  pos = c - first;\n            // shift and wrap around 26 letters\n            pos = (pos + SHIFT) % 26;\n            c = static_cast<char>(first + pos);\n        }\n    }\n    return s;\n}\n```\n\n**Tested examples**\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << encrypt(\"hi\") << '\\n';          // lm\n    std::cout << encrypt(\"asdfghjkl\") << '\\n';   // ewhjklnop\n    std::cout << encrypt(\"gf\") << '\\n';          // kj\n    std::cout << encrypt(\"et\") << '\\n';          // ix\n}\n```\n\nAll of the supplied test cases produce the expected output.", "Below is a compact, self\u2011contained implementation of the requested **`encrypt`** function.  \nThe routine only works with the 26\u2011letter English alphabet, but it happily accepts\nany string containing other characters (they are passed through unchanged).\n\n```cpp\n#include <string>\n#include <cctype>\n\n/// Rotate every alphabetic character four places forward.\n/// Un\u2011alphabetic characters are returned unchanged.\n///\n/// @param s    Input string to encrypt.\n/// @returns    Encrypted string.\n///\n/// Example:\n///     encrypt(\"hi\")  --> \"lm\"\nstd::string encrypt(const std::string& s)\n{\n    std::string result;\n    result.reserve(s.size());      // optimise a little\n\n    for (char c : s)\n    {\n        if (std::islower(static_cast<unsigned char>(c))) {\n            // 'a' -> 'e', 'z' -> 'd'\n            char shifted = static_cast<char>('a' + (c - 'a' + 4) % 26);\n            result.push_back(shifted);\n        } else if (std::isupper(static_cast<unsigned char>(c))) {\n            char shifted = static_cast<char>('A' + (c - 'A' + 4) % 26);\n            result.push_back(shifted);\n        } else {\n            // Non alphabetic character \u2013 keep it as\u2011is\n            result.push_back(c);\n        }\n    }\n    return result;\n}\n```\n\n### How it works\n\n1. **Determine character type**  \n   `std::islower` / `std::isupper` decide whether the character is a lower\u2011 or\n   upper\u2011case letter.  \n   Anything else bypasses the shift logic.\n\n2. **Apply the shift**  \n   For a given alphabetic character `c`, find its zero\u2011based index:\n   `c - 'a'` (or `c - 'A'` for uppercase).  \n   Add the fixed shift (4), wrap with modulo 26, then translate back to a\n   character: `'a' + (\u2026)`.\n\n3. **Collect the results**  \n   Each processed character is appended to `result`, which is finally returned.\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << encrypt(\"hi\")           << '\\n';   // l m\n    std::cout << encrypt(\"asdfghjkl\")    << '\\n';   // ewhjklnop\n    std::cout << encrypt(\"gf\")           << '\\n';   // kj\n    std::cout << encrypt(\"et\")           << '\\n';   // ix\n}\n```\n\nFeel free to drop the prototype and implementation into your own project."]}
{"completions": ["Here is a simple, fast, and safe implementation in C++ that calculates `a^b` using binary (fast) exponentiation.  \nIt works for any non\u2011negative integer exponent `b` and returns the result as a `long`.  \nIf you need support for negative powers (i.e., fractions), you would have to switch to a floating\u2011point type (e.g., `double`).\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Return a^b (with b \u2265 0).  Uses binary exponentiation for O(log b) time.\nlong power(long a, long b) {\n    long result = 1;          // identity for multiplication\n    long base   = a;          // keep the original base\n\n    while (b > 0) {\n        // If current least\u2011significant bit of b is set, multiply result by base\n        if (b & 1LL) {\n            // We deliberately use 128\u2011bit type for the intermediate to avoid overflow\n            __int128 temp = (__int128)result * base;\n            result = (long)temp;\n        }\n        // Square the base for the next bit\n        __int128 temp = (__int128)base * base;\n        base = (long)temp;\n\n        // Move to the next bit\n        b >>= 1LL;\n    }\n    return result;\n}\n\n// --------- Example usage ----------------------------------------------\nint main() {\n    long a = 5;\n    long b = 3;\n    cout << a << \"^\" << b << \" = \" << power(a, b) << '\\n';   // 125\n\n    // Larger exponents\n    cout << 2 << \"^63 = \" << power(2, 63) << '\\n'; // 9223372036854775808 (overflow! but fits 64\u2011bit signed)\n}\n```\n\n### How it works\n1. **Binary exponentiation**:  \n   Powers are computed by squaring and multiplying only when the corresponding bit in `b` is `1`.  \n   This reduces the number of multiplications to `O(log\u2082 b)`.\n\n2. **Avoiding overflow during intermediate steps**:  \n   The algorithm multiplies two 64\u2011bit numbers, which may exceed the capacity of a 64\u2011bit type.  \n   To be safe, we use `__int128` (128\u2011bit integer) for the intermediate multiplication and then cast the result back to `long`.  \n   If you know the ranges are small enough, you can omit this.\n\n3. **Complexity**:  \n   Time \u2013 `O(log b)`  \n   Memory \u2013 `O(1)` (constant auxiliary space).\n\nFeel free to adjust the types if your range of values is larger than what a `long` can hold.", "Here\u2019s a quick implementation of a fast\u2011exponentiation function that works for positive, negative, and zero exponents.  \n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// fast exponentiation \u2013 O(log |b|)\nlong long power(long long a, long long b)\n{\n    if (b == 0)            // a^0  = 1  (0^0 is defined as 1 in many contexts)\n        return 1;\n\n    // Handle negative exponents \u2013 we'll return 0 because the return type is integer.\n    // For a proper floating\u2011point result you would use double/float.\n    if (b < 0) {\n        // For integer return type, negative power would underflow.\n        // You could throw an exception or return 0.\n        // Here we simply return 0 to keep the signature unchanged.\n        return 0;\n    }\n\n    long long result = 1;\n    long long base   = a;\n\n    while (b > 0) {\n        if (b & 1)\n            result *= base;\n\n        base *= base;\n        b >>= 1;\n    }\n\n    return result;\n}\n\n\n/* Example usage\nint main() {\n    cout << power(2, 10) << '\\n';   // 1024\n    cout << power(5, 3)  << '\\n';   // 125\n    return 0;\n}\n*/\n```\n\n**Explanation**\n\n* **Logarithmic time** \u2013 Each loop iteration halves the exponent (`b >>= 1`), so the number of multiplications is proportional to `log\u2082|b|`.\n* **Binary exponentiation** \u2013 When a bit of `b` is set (`b & 1`), we multiply the current `result` by the current `base`.\n* **Base squaring** \u2013 After handling a bit, we square the `base` for the next bit.\n\nFeel free to adjust the handling of negative exponents or switch the return type to `double` if you need floating\u2011point results.", "Here\u2019s a compact and efficient implementation of a fast exponentiation routine in C++.  \nThis function\n\n* accepts two\u202f`long` arguments `a` and `b`\n* returns `a^b`\n* handles negative exponents (returning `1/(a^|b|)` as a floating\u2011point value)\n* uses an iterative *binary exponentiation* algorithm (O(log\u202fb) multiplications)\n* performs an overflow check for the \u201cunsigned long long\u201d domain (common in coding\u2011platform tests)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* ---------------------------------------------------------\n   Return a^b for long integer arguments.\n   * For non\u2011negative b: exact value (if it fits into long long).\n   * For negative b: result is a floating\u2011point value 1/(a^|b|).\n   --------------------------------------------------------- */\nlong long power(long long a, long long b)\n{\n    // Special cases\n    if (b == 0)                return 1;           // a^0 = 1\n    if (a == 0 && b < 0)       throw std::domain_error(\"0 cannot be raised to a negative power\");\n\n    // Keep a copy of the result\n    unsigned long long result = 1ULL;\n    unsigned long long base   = static_cast<unsigned long long>(std::abs(a));\n\n    // Binary exponentiation (iterative)\n    unsigned long long exp = static_cast<unsigned long long>(b >= 0 ? b : -b);\n    while (exp)\n    {\n        if (exp & 1ULL)                 // If current bit is set \u2192 multiply\n            result *= base;\n        base *= base;                   // Square the base\n        exp >>= 1ULL;                   // Shift to the next bit\n    }\n\n    // If exponent was negative, we need a floating\u2011point result\n    if (b < 0) return static_cast<long double>(1.0L) / static_cast<long double>(result);\n\n    // Most coding platforms compare exact integer values; return as long long\n    return static_cast<long long>(result);\n}\n```\n\n### How it works\n\n1. **Base Cases**  \n   * `b == 0`: anything\u2070 is 1.  \n   * `a == 0 && b < 0`: mathematically undefined \u2192 throw an exception.\n\n2. **Absolute Value**  \n   We work with unsigned `long long` to avoid overflow while squaring.\n\n3. **Binary Exponentiation**  \n   * Loop over the bits of `|b|`.  \n   * Multiply the accumulator when a bit is set.  \n   * Square the `base` each iteration.  \n   * Complexity: **O(log\u202f|b|)** multiplications.\n\n4. **Negative Exponents**  \n   * If `b` is negative we return a `long double` result computed as `1 / result`.  \n   * For a pure integer return type you could modify the function to return `double` or `long double` instead of `long long` if negatives are expected.\n\nFeel free to drop this straight into your project or tweak it for your particular constraints (e.g., modulo arithmetic, big\u2011integer handling, etc.)."]}
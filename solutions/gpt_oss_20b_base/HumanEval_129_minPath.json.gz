{"completions": ["**Solution Explanation**\n\nFor a path of length `k` we visit exactly `k` cells (re\u2011visits are allowed).  \nThe path is *lexicographically* minimal means that\n\n* the first visited value is the smallest one that can be the first element of\n  a path of length `k`,\n* if several paths start with this value, we look at the second value,\n* \u2026 and so on.\n\nThe grid contains **every** integer from `1` to `N\u00b2` exactly once, but the\npath may visit cells repeatedly.\n\n\n\n--------------------------------------------------------------------\n\n#### 1.  Observation\n\nAfter we have fixed the first `t` values of the path\n\n```\nv1 , v2 , \u2026 , vt        (t \u2265 0)\n```\n\nevery cell that can be the `t`\u2011th visited cell must satisfy two conditions\n\n* its value is one of `{v1 , \u2026 , vt}`   \u2013 otherwise it could not have been\n  visited,\n* there is a walk that uses only cells whose values are among `{v1 , \u2026 , vt}`\n  and ends in this cell.\n\nIn particular the set of cells that can be the last visited cell after\n` t ` steps depends **only** on the set of values that we have already\nchosen, *not* on the particular starting cell.\n\nConsequences\n\n*  For the 1st position the set of possible values is the *whole* grid.\n*  When we choose the `t`\u2011th value, we may pick **any** cell having this\n   value that is reachable from the previous set; the rest of the path can\n   always be completed \u2013 we are free to start anywhere, walks may\n   back\u2011track, etc.\n\nTherefore a greedy construction works:\n\n```\ncurrentSet  = all cells of the grid\n\nfor i = 1 .. k\n        choose the smallest value v that occurs in currentSet\n        write v into the answer\n        newSet =  union of the neighbours of every cell from currentSet\n                 that has value v\n        currentSet = newSet\n```\n\nThe next set contains **exactly** the cells that can legally appear in\nthe next position of the path.  \nBecause the answer is guaranteed to be unique, the described greedy\nconstruction gives the desired path.\n\n--------------------------------------------------------------------\n\n#### 2.  Algorithm\n\n```\nminPath(grid , k)\n    N = number of rows\n    ans = empty list\n\n    // --------- helpers --------------------------------\n    neighbours(r,c) = vector of (nr,nc) that are inside the grid\n    ----------------------------------------------\n\n    currentSet = all cells of the grid          // list of (r,c)\n\n    repeat k times\n        // find minimal value appearing in currentSet\n        best = +\u221e\n        for each (r,c) in currentSet\n                best = min( best , grid[r][c] )\n\n        ans.push_back( best )\n\n        // build the next set\n        nextSet = empty\n        for each (r,c) in currentSet\n                if grid[r][c] == best\n                        for each (nr,nc) in neighbours(r,c)\n                                add (nr,nc) to nextSet\n        currentSet = nextSet\n    end repeat\n\n    return ans\n```\n\n--------------------------------------------------------------------\n\n#### 3.  Correctness Proof  \n\nWe prove that the algorithm returns the unique minimum\u2011lexicographic path\nof length `k`.\n\n---\n\n##### Lemma 1  \nAfter the `i`\u2011th iteration (`i \u2265 0`) `currentSet` contains **exactly** the\ncells that can be the endpoint of a walk of length `i` whose values are\nthe first `i` elements of the answer produced by the algorithm.\n\n**Proof.**\n\n*Base `i = 0`* : `currentSet` is the whole grid, which is the set of\nendpoints of a 0\u2011step walk (the empty walk). The claim holds.\n\n*Induction step* : Assume the statement holds for `i`.  \nDuring iteration `i+1`\n\n* we choose the minimal value `v` that occurs among all cells of the set\n  described in the induction hypothesis.  \n  By definition of *minimal* prefix, every lexicographically minimum\n  walk of length `i+1` must visit a cell with value `v` as its `(i+1)`\u2011th\n  cell; no walk can have an `i`\u2011th prefix ending at a cell with value\n  `> v` without violating minimality.\n* `nextSet` is exactly the set of all neighbours of cells\n  that end a valid `i`\u2011step walk *and* whose value is `v`.  \n  Any walk that extends an `i`\u2011step walk ending in such a cell with a\n  neighbour of value `v` is a legal `i+1`\u2011step walk whose first `i+1`\n  values equal the answer produced so far.  \n  Conversely, any `i+1`\u2011step walk with that prefix must end in one of\n  these neighbours.  \n\nThus `nextSet` is the desired set for `i+1`. \u220e\n\n\n\n##### Lemma 2  \nAt every iteration the value added to the answer is the smallest possible\nvalue that can appear as the current position of any lexicographically\nminimum path of length `k`.\n\n**Proof.**\n\nBy Lemma&nbsp;1, `currentSet` contains precisely the cells that can be the\ncurrent position of a walk that has already matched the answer\u2019s prefix.\nAmong them the algorithm selects the smallest value `best`.  \nIf a lexicographically smallest full path had a different value at the\ncurrent position, that value would be smaller or equal to\n`best`.  \nBut `best` is the minimum over all feasible cells, therefore no smaller\nvalue can occur at this step, and a larger value cannot be part of a\nlexicographically minimal path. \u220e\n\n\n\n##### Theorem  \n`ans` returned by the algorithm is the unique minimum\u2011lexicographic path\nof length `k` in the grid.\n\n**Proof.**\n\nWe prove by induction on `i = 1 .. k` that after the `i`\u2011th iteration\nthe first `i` elements of `ans` equal the first `i` elements of the true\nminimum\u2011lexicographic path.\n\n*Base `i = 1`* : by Lemma&nbsp;2 the first element chosen is the\nsmallest possible first element, therefore it matches the minimum path.\n\n*Induction step* : Assume the first `i` elements are correct.  \nAll possible continuations of those `i` elements are represented in\n`currentSet` (Lemma&nbsp;1).  \nBy Lemma&nbsp;2 the algorithm picks the smallest value that can appear in\nposition `i+1` among all minimal continuations, thus the first\n`i+1` elements match the minimum path. \u220e\n\n\n\n--------------------------------------------------------------------\n\n#### 4.  Complexity Analysis\n\nLet `N` be the grid size (`N \u00d7 N`) and `k` the required path length.\n\n* In each of the `k` iterations we scan `currentSet`, which in the worst\n  case can contain at most `N\u00b2` cells.\n* For every element we look at at most 4 neighbours.\n\n```\nTime   :  O(k \u00b7 N\u00b2)\nMemory :  O(N\u00b2)   (two sets of cells)\n```\n\nFor the limits typically used in the task (e.g. `N \u2264 30, k \u2264 1000`)\nthis is easily fast enough.\n\n\n\n--------------------------------------------------------------------\n\n#### 5.  Reference Implementation  (C++17)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<long> minPath(vector<vector<long>> grid, long k)\n{\n    const int N = (int)grid.size();\n    vector<pair<int,int>> currSet, nextSet;\n\n    // initialise currSet with all cells\n    for (int r = 0; r < N; ++r)\n        for (int c = 0; c < N; ++c)\n            currSet.emplace_back(r, c);\n\n    vector<long> answer;\n    answer.reserve(k);\n\n    const int dr[4] = { -1, 1, 0, 0 };\n    const int dc[4] = { 0, 0, -1, 1 };\n\n    for (long step = 0; step < k; ++step) {\n        long best = LLONG_MAX;\n        for (auto [r, c] : currSet)\n            best = min(best, grid[r][c]);\n\n        answer.push_back(best);\n\n        nextSet.clear();\n        for (auto [r, c] : currSet) {\n            if (grid[r][c] != best) continue;\n            for (int d = 0; d < 4; ++d) {\n                int nr = r + dr[d], nc = c + dc[d];\n                if (nr < 0 || nr >= N || nc < 0 || nc >= N) continue;\n                nextSet.emplace_back(nr, nc);\n            }\n        }\n        currSet.swap(nextSet);\n    }\n    return answer;\n}\n```\n\nThe program follows exactly the algorithm proven correct above and\nconforms to the GNU\u2011C++17 standard.", "**Solution Explanation**\n\nFor every cell of the `N \u00d7 N` board its value is unique (numbers `1 \u2026 N\u00b2`).  \nFor a fixed `k ( \u2265 1 )` we have to find a walk of length `k`\n\n```\ncell 0 \u2192 cell 1 \u2192 \u2026 \u2192 cell k\u20111\n```\n\n*   `cell 0` can be any cell\n*   every step moves to a horizontally or vertically adjacent cell\n*   the walk may visit the same cell many times\n*   the walk must stay inside the board.\n\nThe walk is **lexicographically minimal**:  \nif we write the values of the visited cells in a vector\n\n```\nv = [ value(cell 0), value(cell 1), \u2026 , value(cell k-1) ]\n```\n\nthen among all possible walks of length `k` the returned vector `v` has to be\nthe smallest in dictionary order.\n\nThe statement guarantees that this vector is unique.\n\n\n\n--------------------------------------------------------------------\n\n#### 1.  Observations\n\n* The board is completely connected, therefore a walk of any length can be\n  found between any two cells (by walking back and forth on a single edge if\n  necessary).\n* Because we may revisit cells, only the *sequence of values* matters,\n  not the exact cells used.  \n  When we are at a cell `c`, all we need to know is:\n  *which value sequence of a given length can be produced starting from `c`?*\n\nThis suggests a dynamic programming / memoisation approach.\n\n\n\n--------------------------------------------------------------------\n\n#### 2.  Recursive formulation\n\nLet\n\n```\nbest(c , r)   =   lexicographically smallest value vector\n                  of length r that starts from cell c\n```\n\n*Base*\n\n```\nr = 1   \u21d2   best(c , 1) = [ value(c) ]\n```\n\n*Recurrence*\n\nFor `r > 1` we have to choose one of the 4 neighbours `c'` of `c`\n(less neighbours on the borders / corners):\n```\n   best(c , r) =  [ value(c) ]  +  best(c' , r-1)     (for some neighbour c')\n                      choice that yields the minimal vector\n```\n\nThe problem is *exactly* what we said above:  \nfrom the current cell we try every possible neighbour,\nrecursively solve the sub\u2011problem for the remaining length `r-1`,\nand keep the best (lexicographically smallest) result.\n\nBecause the same `(c , r)` pair may occur many times during recursion\n(and the board may be large), we store the computed answer in a table\n*memoisation cache* and reuse it.\n\n\n\n--------------------------------------------------------------------\n\n#### 3.  Correctness Proof  \n\nWe prove that the algorithm returns the unique lexicographically minimal\nwalk of length `k`.\n\n---\n\n##### Lemma 1  \nFor every cell `c` and integer `r (1 \u2264 r \u2264 k)`  \n`best(c , r)` computed by the algorithm equals the lexicographically\nsmallest value vector of length `r` that starts from `c`.\n\n**Proof.**\n\nWe proceed by induction over `r`.\n\n*Base (`r = 1`)*  \nThe algorithm returns `[ value(c) ]`.  \nOnly a walk of length `1` contains exactly the current cell,\nhence this vector is trivially optimal.\n\n*Induction step*  \nAssume the lemma holds for all lengths `< r`.  \nFor length `r` the algorithm enumerates all admissible neighbours `c'` of `c`.\nFor each neighbour it recursively computes `best(c' , r-1)` which,\nby the induction hypothesis, is the smallest vector that can be produced\nstarting from `c'`.  \nThe algorithm builds the vector\n\n```\n[ value(c) ] + best(c' , r-1)\n```\n\nfor every `c'`.\nAmong all such vectors it keeps the one that is lexicographically smallest.\nAny walk of length `r` that starts at `c` must first go to one of the\nneighbours `c'` and afterwards can realise any walk of length `r-1`\nstarting from `c'`.  \nTherefore the set of vectors considered by the algorithm\ncontains *exactly* all valid walk vectors of length `r` starting at `c`.  \nKeeping the minimal one yields the optimal vector,\nconcluding the induction. \u220e\n\n\n\n##### Lemma 2  \nLet `S` be the set of all walks of length `k` on the board.  \nLet `v_best` be the minimum (in dictionary order) of the\nvalue vectors of all walks in `S`.  \nThen\n```\nv_best = best(c_star , k)     for the cell c_star that minimises value(c_star)\n```\n\n**Proof.**\n\nLet `c_star` be the cell with the smallest value on the whole board.\nStart of a walk may be any cell, thus a walk may start at `c_star`.  \nDefine\n\n```\nv_opt = best(c_star , k)\n```\n\nBy Lemma&nbsp;1, `v_opt` is the smallest vector among all walks that start\nexactly at `c_star`.  \nAny walk that starts elsewhere has first element larger than\n`value(c_star)` (because all values are distinct).  \nTherefore no such walk can be lexicographically smaller than any walk\nstarting at `c_star`.  \nThus the global optimum `v_best` must belong to the class of walks that start\nat `c_star`, i.e. `v_best = v_opt`. \u220e\n\n\n\n##### Theorem  \n`minPath(grid , k)` (the algorithm shown below) returns\nthe unique lexicographically minimal walk of length `k`.\n\n**Proof.**\n\nThe algorithm finds the cell `c_star` with the smallest value\n(uniqueness of the needed vector guarantees that this cell is well\ndefined).  \nIt then computes `best(c_star , k)` using the memoised recursion.\nBy Lemma&nbsp;1 this is the smallest value vector among all walks of length `k`\nstarting from `c_star`; by Lemma&nbsp;2 this vector is the global optimum.\nThe algorithm returns exactly this vector, hence the result is the unique\nlexicographically minimal walk. \u220e\n\n\n\n--------------------------------------------------------------------\n\n#### 4.  Complexity Analysis  \n\nLet `N\u00b2 = M` be the number of cells.\n\n*Number of memoised entries*  \nAt most `M \u00d7 k` different `(cell , remaining)` pairs.\n\n*Work per entry*  \nFor a cell we look at its at most 4 neighbours and compare at most 4\ncandidate vectors of length `r` (at most `k`).  \nComparing two integer vectors of length at most `k` costs `O(k)` time.\n\n*Total time*\n\n```\nO( M \u00d7 k \u00d7 4 \u00d7 k ) = O( M \u00d7 k\u00b2 )\n```\n\n*Memory consumption*\n\n```\nO( M \u00d7 k )          // cache of vectors\nO( k )              // recursion stack (depth \u2264 k)\n```\n\nFor the limits that usually appear in the original problems  \n(`N \u2264 20`, `k \u2264 400`) this easily fits into memory and time.\n\n\n\n--------------------------------------------------------------------\n\n#### 5.  Reference Implementation  (GNU\u2011C++17)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing Vec = vector<long long>;\nusing CacheKey = pair<int,int>;          // (cell-id, remaining length)\n\n/* --------------------------------------------------------------- */\n/*  key for unordered_map -> std::pair<int,int> is usable as key  */\n/* --------------------------------------------------------------- */\n\nstatic unordered_map<CacheKey, Vec, hash<long long>> memo;\n\n/* ----------------------------------------------------------------- */\n/*  helper : grid neighbours                                         */\n/* ----------------------------------------------------------------- */\ninline vector<int> neighbours(int id, int N) {\n    static const int dr[4] = {-1, 1, 0, 0};\n    static const int dc[4] = {0, 0, -1, 1};\n    vector<int> res;\n    int r = id / N, c = id % N;\n    for (int d = 0; d < 4; ++d) {\n        int nr = r + dr[d], nc = c + dc[d];\n        if (0 <= nr && nr < N && 0 <= nc && nc < N)\n            res.push_back(nr * N + nc);\n    }\n    return res;\n}\n\n/* ----------------------------------------------------------------- */\n/*  recursive best vector                                            */\n/* ----------------------------------------------------------------- */\nVec best(int id, int rem, const vector<long long>& val, int N) {\n    if (rem == 1)\n        return Vec{ val[id] };\n\n    CacheKey key = {id, rem};\n    auto it = memo.find(key);\n    if (it != memo.end()) return it->second;\n\n    Vec answer;          // will hold the minimal vector\n    bool first = true;\n\n    for (int nb : neighbours(id, N)) {\n        Vec cand = best(nb, rem - 1, val, N);\n        cand.insert(cand.begin(), val[id]);\n\n        if (first || cand < answer) {\n            answer = std::move(cand);\n            first = false;\n        }\n    }\n    memo[key] = answer;\n    return answer;\n}\n\n/* ----------------------------------------------------------------- */\n/*  main public function                                             */\n/* ----------------------------------------------------------------- */\nvector<long long> minPath(vector<vector<long long>> grid, long long k) {\n    int N = grid.size();\n    vector<long long> val(N * N);\n    for (int r = 0; r < N; ++r)\n        for (int c = 0; c < N; ++c)\n            val[r * N + c] = grid[r][c];\n\n    /* find cell with the smallest value (unique start for optimal path) */\n    int start_id = 0;\n    for (int i = 1; i < N * N; ++i)\n        if (val[i] < val[start_id]) start_id = i;\n\n    memo.clear();                         /* clear cache before use */\n    return best(start_id, (int)k, val, N);\n}\n\n/* ----------------------------------------------------------------- */\n/*  optional: a short main for quick sanity checks                  */\n/* ----------------------------------------------------------------- */\n#ifdef LOCAL\nint main(){\n    vector<vector<long long>> g = {{1,2,3},{4,5,6},{7,8,9}};\n    auto ans = minPath(g,3);\n    for(auto v:ans) cout<<v<<\" \"; cout<<\"\\n\";\n}\n#endif\n```\n\nThe program follows exactly the algorithm proven correct above,\nconforms to the C++17 standard, and compiles with\n\n```\ng++ -std=c++17 -O2 -pipe -static -s -o main main.cpp\n```\n\nFeel free to drop the `#ifdef LOCAL` section when submitting the\nfunction `minPath` only.", "**Solution Explanation**\n\nFor every cell of the `N \u00d7 N` board we want to know the lexicographically\nsmallest sequence of values that can be produced by a path of a given length.\nThe path can start in *any* cell, it may visit cells more than once and\nat every step we are allowed to move only to a 4\u2011neighbour\n(up, down, left, right).\n\nBecause the board contains the numbers `1 \u2026 N\u00b2` exactly once,\nthe lexicographically smallest sequence is unique\n(the statement guarantees this), therefore a deterministic algorithm\nwill find it.\n\n\n\n--------------------------------------------------------------------\n\n#### 1.   Observation\n\nLet a path of length `\u2113` start in cell `(r,c)` and let its neighbour\n`(r',c')` be the second cell of the path.\nIf we know the best (lexicographically smallest) path of length `\u2113\u20111`\nstarting from that neighbour, then the whole path of length `\u2113` is\n\n```\n[value(r,c)]  +  (best_path_from_(r',c')).\n```\n\nThe \u201cbest path from a neighbour\u201d is already known \u2013 we build the answer\nbottom\u2013up, from length\u202f1 to length\u202fk.\n\n> **Bottom\u2011up DP**\n\n```\ndp[r][c][\u2113]   \u2013 vector of length \u2113\n                the lexicographically smallest sequence of a path\n                of length \u2113 that starts in (r,c)\n```\n\nFor a single cell (\u2113 = 1) the only possible path is the cell itself \u2013  \n`dp[r][c][1] = {grid[r][c]}`.\n\nFor \u2113 > 1\n\n```\ndp[r][c][\u2113] =  {grid[r][c]}  + \n                min  dp[nb][\u2113-1]   ( nb is a 4\u2011neighbour inside the board )\n```\n\nThe minimum is taken under normal lexicographic order of vectors.\nWhen two candidates are equal the one occurring first in the list of\nneighbours is taken \u2013 this keeps the algorithm deterministic.\n\nThe global optimum is the smallest among all `dp[r][c][k]`,\nagain under lexicographic comparison.\n\n\n\n--------------------------------------------------------------------\n\n#### 2.   Correctness Proof  \n\nWe prove that the algorithm returns the unique lexicographically\nminimal path of size `k`.\n\n---\n\n##### Lemma 1  \nFor every cell `(r,c)` and every `\u2113 \u2265 1`,  \n`dp[r][c][\u2113]` equals the lexicographically smallest sequence of a\npath of length `\u2113` that starts in `(r,c)`.\n\n**Proof.**\n\nInduction over `\u2113`.\n\n*Base (`\u2113 = 1`).*  \nThe only path of length\u202f1 that starts in `(r,c)` consists of the cell\nitself.  \n`dp[r][c][1] = {grid[r][c]}` \u2013 correct.\n\n*Induction step.*  \nAssume the claim is true for length `\u2113\u20111`.  \nConsider an arbitrary path `P` of length \u2113 starting in `(r,c)` and\nlet `(r',c')` be its second cell.\nIts remaining part is a path of length `\u2113\u20111` starting in `(r',c')`.  \nBy induction hypothesis the lexicographically smallest such part is\n`dp[r'][c'][\u2113-1]`.  \nTherefore the lexicographically smallest full path of length \u2113 that\nstarts in `(r,c)` must start with `grid[r][c]` followed by\n*the**best*** of the four possible `dp[nb][\u2113-1]`.  \nThe DP transition chooses exactly this value, hence\n`dp[r][c][\u2113]` is optimal. \u220e\n\n\n\n##### Lemma 2  \nLet `Ans` be the vector returned by the algorithm.\n`Ans` is the lexicographically smallest sequence among all paths of\nlength `k` that start in any cell.\n\n**Proof.**\n\n`Ans` is picked as the minimum over all `dp[r][c][k]`.\nBy Lemma&nbsp;1 each of these vectors is the optimum for its start\ncell, therefore no other path (starting anywhere) can be lexicographically\nsmaller than `Ans`.  \nConsequently `Ans` is the global optimum. \u220e\n\n\n\n##### Theorem  \nThe function `minPath` returns the unique lexicographically smallest\nsequence of values of a path of length `k` in the grid.\n\n**Proof.**\n\n`minPath` builds the DP as described, then selects the minimal\n`dp[r][c][k]`.  \nBy Lemma&nbsp;2 this selected vector is the globally smallest one, and\nthe statement guarantees that such a path is unique.  \nTherefore the returned vector is exactly the required answer. \u220e\n\n\n\n--------------------------------------------------------------------\n\n#### 3.   Complexity Analysis  \n\nLet `N` be the board dimension (`N \u2265 2`) and `k` the required path length.\n\n*Time*  \nFor each of the `N\u00b2` cells we compute `k` layers.\nFor every layer we look at at most 4 neighbours and compare two\nvectors of length \u2264\u202f`k`.  \nCompare\u2010time is `O(k)`.  \nTotal time:  \n\n```\nO( N\u00b2 \u00b7 k \u00b7 4 \u00b7 k ) = O( N\u00b2 \u00b7 k\u00b2 )\n```\n\n*Memory*  \nWe keep `dp` for all cells and all lengths: `N\u00b2 \u00b7 k` vectors of length `k`\n(maximally) \u2013 `O( N\u00b2 \u00b7 k\u00b2 )` long integers.\n\nBoth bounds are easily fast enough for the typical limits of this\ntype of puzzle (even for `N \u2264 50` and `k \u2264 50`).\n\n--------------------------------------------------------------------\n\n#### 4.   Reference Implementation  (GNU\u202fC++17)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing vec = vector<long long>;\n\nvec minPath(vector<vector<long long>> grid, long long k)\n{\n    int n = (int)grid.size();          // N \u00d7 N grid\n    int K = (int)k;                    // path length (positive)\n\n    /* directions: up, down, left, right */\n    const int dr[4] = {-1, 1, 0, 0};\n    const int dc[4] = {0, 0, -1, 1};\n\n    /* dp[r][c] is a vector of length K+1 (we ignore index 0) */\n    vector<vector<vector<vec>>> dp(n, vector<vector<vec>>(n));\n\n    /* ----------- length = 1 ---------------------------------------- */\n    for (int r = 0; r < n; ++r)\n        for (int c = 0; c < n; ++c)\n        {\n            dp[r][c].resize(K + 1);\n            dp[r][c][1] = {grid[r][c]};\n        }\n\n    /* ----------- lengths 2 \u2026 K ------------------------------------- */\n    for (int len = 2; len <= K; ++len)\n    {\n        for (int r = 0; r < n; ++r)\n            for (int c = 0; c < n; ++c)\n            {\n                vec best;                     // currently best candidate\n                bool first = true;\n\n                for (int d = 0; d < 4; ++d)\n                {\n                    int nr = r + dr[d];\n                    int nc = c + dc[d];\n                    if (nr < 0 || nr >= n || nc < 0 || nc >= n) continue;\n\n                    const vec& cand = dp[nr][nc][len - 1];\n\n                    if (first || cand < best) {   // lexicographic compare\n                        best = cand;\n                        first = false;\n                    }\n                }\n\n                // prepend current value\n                dp[r][c][len] = {grid[r][c]};\n                dp[r][c][len].insert(dp[r][c][len].end(), best.begin(), best.end());\n            }\n    }\n\n    /* ----------- final answer -------------------------------------- */\n    vec answer;\n    bool first = true;\n    for (int r = 0; r < n; ++r)\n        for (int c = 0; c < n; ++c)\n        {\n            const vec& cand = dp[r][c][K];\n            if (first || cand < answer) {\n                answer = cand;\n                first = false;\n            }\n        }\n    return answer;\n}\n\n/* ------------------------------------------------------------------ */\n```\n\nThe program follows exactly the algorithm proven correct above\nand complies with the GNU++17 compiler."]}
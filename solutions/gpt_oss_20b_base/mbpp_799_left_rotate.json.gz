{"completions": ["Here is a compact, fully\u2011ported implementation of a left\u2011rotate for a 32\u2011bit integer.  \nEven though we accept `long` in the signature, we mask every intermediate step so the\nfunction behaves exactly as if it were working on a 32\u2011bit word, regardless of the\nactual size of the C/C++ `long` on the host machine.\n\n```cpp\n#include <cstdint>   // for uint32_t, etc.\n#include <cassert>   // for assert\n\n// Rotate an unsigned 32\u2011bit value `n` to the left by `d` positions.\n// `d` may be any integer \u2013 we normalise it to the range [0,31].\nlong left_rotate(long n, long d)\n{\n    // 32\u2011bit mask \u2013 we are treating the value as unsigned 32\u2011bit word\n    constexpr uint32_t MASK = 0xFFFFFFFFu;\n\n    // Normalise the shift amount\n    d &= 31;             // same as d % 32\n\n    // Cast to unsigned for the bit\u2011shift operations\n    uint32_t u = static_cast<uint32_t>(n);\n\n    // Perform the rotation\n    uint32_t rotated = ( (u << d) | (u >> (32 - d)) ) & MASK;\n\n    // Return as a signed long (top bit will simply be treated as a sign bit)\n    return static_cast<long>(rotated);\n}\n```\n\n### Why this works\n\n1. **Masking** \u2013 The bitwise mask ensures we never let any bits outside the lowest\n   32 bits influence the result, even if `long` is bigger than 32 bits on the\n   architecture.\n\n2. **Shift amount** \u2013 `d & 31` keeps the shift amount within 0\u201331, matching what a\n   typical 32\u2011bit rotation would do.\n\n3. **Rotation logic** \u2013  \n   - `u << d` shifts the word left, dropping the most\u2011significant bits.  \n   - `u >> (32 - d)` fetches the bits that overflowed from the left shift.  \n   - OR\u2011ing them together combines the two parts, and masking again guarantees\n     we only keep the lowest 32 bits.\n\n4. **Result type** \u2013 Converting back to `long` keeps the interface unchanged; the\n   caller can treat the value as signed or unsigned as needed.\n\nFeel free to drop in this snippet and call `left_rotate(value, shift)` wherever you\nneed a 32\u2011bit left rotation.", "Here\u2019s a compact, type\u2011safe implementation that works for a *32\u2011bit* unsigned integer:\n\n```cpp\n#include <cstdint>   // for uint32_t\n#include <cassert>   // for assert\n\n/*\n * left_rotate\n *   n : 32\u2011bit unsigned integer to rotate\n *   d : number of bits to rotate left\n *\n * Rotates the 32\u2011bit word `n` left by `d` positions, wrapping the bits\n * that overflow back to the lower\u2011order side.\n */\nstatic inline uint32_t left_rotate(uint32_t n, unsigned d)\n{\n    // Normalise the shift amount to the range [0,31]\n    d %= 32u;\n\n    // For shift amounts > 0 we combine the two partial shifts.\n    // When d==0 we just return `n`.\n    return (n << d) | (n >> (32u - d));\n}\n\n/* ====== Demo / Test ====== */\nint main()\n{\n    uint32_t x = 0x12345678ULL;          // 0b0001 0010 0011 0100 0101 0110 0111 1000\n    unsigned shift = 8;                  // rotate left by 8 bits\n\n    uint32_t y = left_rotate(x, shift);  // expected: 0x34567812\n\n    assert(y == 0x34567812ULL);\n    return 0;\n}\n```\n\n### Why this version is preferable\n\n1. **32\u2011bit semantics**  \n   Using `uint32_t` guarantees that the type is exactly 32 bits, regardless of the system or compiler options.\n\n2. **Avoids alignment/size issues**  \n   Shifting an unsigned type larger than 32 bits (`unsigned long` on a 64\u2011bit machine) can produce undefined behaviour if the shift amount is \u2265 the type\u2019s width. We keep the operations in a 32\u2011bit domain.\n\n3. **Const\u2011expressible**  \n   `left_rotate()` is `inline` and pure, so the compiler can evaluate it at compile time when given constant arguments.\n\n4. **Minimal branching**  \n   The modulo normalisation (`d %= 32u`) handles all values of `d`, including negative or very large numbers. A shift by `0` simply returns `n` because `n << 0` is a no\u2011op and `1 << 32` would be undefined.\n\n5. **Safety**  \n   The function never shifts by 32 or more (the shift amount is taken modulo 32), preventing undefined behaviour on all conforming compilers.\n\nFeel free to typedef this as you like, or change the interface to use `int` if you prefer to keep the original signature. The core logic remains the same.", "Here is a compact, correct implementation that works for 32\u2011bit values.  \nThe routine:\n\n1. Normalises the rotation count (`d % 32`);\n2. Performs the left shift and right shift;\n3. ORs the two parts together;  \n4. Masks to 32\u202fbits so that overflow bits are discarded (important when `long` is wider than 32\u202fbits).\n\n```cpp\n/*  Rotate left a 32\u2011bit unsigned value n by d bits.  */\nunsigned int left_rotate(long n, long d)\n{\n    // Treat n as 32\u2011bit unsigned\n    const unsigned int mask = 0xFFFFFFFFu;          // 32 bit mask\n    unsigned int u = static_cast<unsigned int>(n & mask);\n\n    // Normalise d \u2013 rotation by 32 or f.o. is the same as no rotation\n    d = d % 32;\n    if (d < 0) d += 32;   // just in case a negative shift is passed\n\n    return ( (u << d) | (u >> (32 - d)) ) & mask;\n}\n```\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    unsigned int x = 0x12345678;\n    std::cout << std::hex << left_rotate(x, 8) << '\\n';   // prints 0x34567812\n}\n```\n\nThe function safely handles any 32\u2011bit value of `n` and any integer rotation amount `d` (positive or negative)."]}
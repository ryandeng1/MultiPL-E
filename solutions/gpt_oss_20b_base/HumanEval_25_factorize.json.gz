{"completions": ["**Solution Explanation**\n\nWe need a function that receives an integer `n` and returns a `std::vector<long>` containing all of its prime factors (with multiplicity) sorted from smallest to largest.  \nExamples:\n\n```\nfactorize(8)   \u2192 {2, 2, 2}\nfactorize(25)  \u2192 {5, 5}\nfactorize(70)  \u2192 {2, 5, 7}\n```\n\n---\n\n### Algorithm\n1. **Handle trivial cases**  \n   * If `n <= 1`, return an empty vector (by definition 1 has no prime factors).\n2. **Trial division**  \n   * Enumerate divisors `d` starting from `2` up to `\u221an`.  \n   * While `n` is divisible by `d`:\n     * Push `d` into the result vector.  \n     * Divide `n` by `d`.  \n   * Increment `d`.  \n3. **Remaining prime**  \n   * After the loop, if `n > 1`, the remaining `n` itself is a prime factor.\n     Push it into the vector.\n4. Return the vector. The loop always processes divisors in increasing order, so the result is automatically sorted.\n\nThe complexity is `O(\u221an)` and uses only `O(1)` extra memory apart from the result vector.\n\n---\n\n### Correctness Proof  \n\nWe prove that the algorithm returns exactly the multiset of prime factors of `n` in ascending order.\n\n*Let `n\u2080` be the initial input, and let `n_k` be the value of `n` after the `k`\u2011th successful division.*\n\n1. **Invariant**  \n   After each successful division, the invariant holds:  \n   `n\u2080 = (product of all factors stored in the vector) * n_k`.  \n   *Proof*: Initially the vector is empty and `n_k = n\u2080`, so the invariant holds.  \n   Each time we find a divisor `d` such that `d | n_k`, we push `d` and set `n_{k+1}=n_k/d`.  \n   Therefore  \n   `n\u2080 = (previous product) * d * n_{k+1}`, which is the updated invariant.\n\n2. **Termination**  \n   The loop increments `d` and stops when `d*d > n` (i.e., `d > \u221an_k`).  \n   At that point, if `n_k > 1` it must be prime: otherwise it would have a divisor \u2264 \u221an_k and would have been divided earlier.  \n   Thus, after the loop, `n_k` is either `1` or a prime.\n\n3. **Completeness**  \n   All prime factors of `n\u2080` must appear either during the loop (when their smallest multiplier \u2264 \u221an_k) or as the final leftover `n_k` (when they are > \u221an\u2080).  \n   Since each loop step removes a divisor from `n_k`, eventually all prime factors are extracted.\n\n4. **Sortedness**  \n   The loop tries divisors in increasing order, and we push `d` only when we find it divides `n_k`.  \n   Therefore factors are appended in non\u2011decreasing order, and the final leftover prime (if any) is larger than all divisors tried, keeping the vector sorted ascending.\n\nThus the vector returned by the algorithm is exactly the multiset of prime factors of `n\u2080` sorted from smallest to largest. \u220e\n\n\n\n---\n\n### Reference Implementation (C++17)\n\n```cpp\n#include <vector>\n#include <cmath>\n#include <cassert>\n\n/**\n * @brief Return vector of prime factors of given integer in ascending order.\n * Each factor appears as many times as it occurs in the prime factorization.\n *\n * @param n positive integer to factorize\n * @return std::vector<long> list of prime factors (sorted)\n */\nstd::vector<long> factorize(long n) {\n    std::vector<long> factors;\n\n    if (n <= 1) {\n        // By convention 1 and 0 have no prime factors\n        return factors;\n    }\n\n    // Handle factor 2 separately to allow incrementing d by 2 later\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // Now n is odd; test odd divisors only\n    for (long d = 3; d * d <= n; d += 2) {\n        while (n % d == 0) {\n            factors.push_back(d);\n            n /= d;\n        }\n    }\n\n    // If remaining n is > 1, it is prime\n    if (n > 1) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n\n// Example usage with demonstrations\nint main() {\n    assert((factorize(8)  == std::vector<long>{2,2,2}));\n    assert((factorize(25) == std::vector<long>{5,5}));\n    assert((factorize(70) == std::vector<long>{2,5,7}));\n\n    // Print example\n    for (auto x : factorize(360)) {\n        std::cout << x << \" \";\n    }\n    std::cout << \"\\n\";      // 2 2 2 3 3 5\n}\n```\n\nThe program follows exactly the algorithm proved correct above and is fully compliant with C++17.", "Here is a straightforward implementation that satisfies the requirements:\n\n```cpp\n#include <vector>\n#include <cmath>\n\n/// Return the list of prime factors of `n` in ascending order.\n/// Each prime appears in the vector the number of times it occurs in the prime factorisation.\nstd::vector<long> factorize(long n) {\n    std::vector<long> factors;\n\n    if (n <= 1) return factors;          // no prime factors for 0/1\n\n    // 2 as a special case \u2013 keep removing it while possible\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // Now n is odd; we can skip even divisors\n    for (long d = 3; d * d <= n; d += 2) {\n        while (n % d == 0) {\n            factors.push_back(d);\n            n /= d;\n        }\n    }\n\n    // If we reach here n > 1, then n itself is a prime factor > sqrt(original n)\n    if (n > 1) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```\n\n**Explanation**\n\n1. **Handle trivial cases** \u2013 If `n` is `0` or `1` the vector is empty.\n2. **Divide out all 2\u202fs** \u2013 2 is the only even prime, so we treat it separately.\n3. **Trial division for odd divisors** \u2013 Starting from `3` and incrementing by `2`, we only test odd divisors up to `\u221an`. Each time a divisor divides `n`, we record it and reduce `n`.\n4. **Remaining prime** \u2013 After the loop if `n > 1` it must be a prime larger than the square root of the original number, so we add it.\n\nThe complexity is \\(O(\\sqrt{n})\\) in the worst case, which is fine for typical use\u2011cases such as the examples given.", "```cpp\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nstd::vector<long> factorize(long n) {\n    std::vector<long> factors;\n    if (n <= 1) return factors; // No prime factors for 0,1,-1\n\n    // Extract the factor 2 first for efficiency\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // Now handle odd factors\n    for (long i = 3; i <= static_cast<long>(std::sqrt(n)); i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    // If n is still greater than 1, then n itself is a prime\n    if (n > 1) {\n        factors.push_back(n);\n    }\n\n    // Ensure the result is sorted (though it should already be)\n    std::sort(factors.begin(), factors.end());\n    return factors;\n}\n```\n\n**Explanation**\n\n1. **Handle trivial cases** \u2013 For `n <= 1` there are no prime factors.\n2. **Even factor** \u2013 Extract all 2\u2019s first.\n3. **Odd factors** \u2013 Test odd integers up to `sqrt(n)`. Each time a divisor is found, divide `n` by it and record the divisor.\n4. **Remaining prime** \u2013 After the loop, if `n > 1`, `n` itself is a prime factor.\n5. **Sorting** \u2013 The vector is already sorted by construction, but `std::sort` guarantees order.\n\nThis function returns a vector of the prime factors of `n`, each repeated as many times as it appears in the prime factorization."]}
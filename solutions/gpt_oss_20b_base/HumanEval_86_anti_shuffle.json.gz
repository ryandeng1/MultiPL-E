{"completions": ["**Solution Explanation**\n\nWe need to reorder each *word* in the string, where a word is a maximal\nsequence of non\u2011space characters.  \nThe order of words and the (possibly multiple) spaces between them\nmust stay unchanged.  \nFor every word we simply sort its characters in ascending ASCII order.\n\n**Algorithm**\n\n```\nanti_shuffle(string s):\n    result = empty string\n    word   = empty string\n\n    for each character c in s:\n        if c is a space:\n            // end of current word\n            if word is not empty:\n                sort word\n                append word to result\n                clear word\n            append the space 'c' to result\n        else:\n            append c to word\n\n    // last word (if string does not end with space)\n    if word is not empty:\n        sort word\n        append word to result\n\n    return result\n```\n\n**Correctness Proof**\n\nWe prove that the algorithm returns the required string.\n\n*Lemma 1*  \nFor every maximal contiguous block of non\u2011space characters in `s`\n(the words of the sentence), the algorithm adds to `result`\nexactly this block after sorting its characters.\n\n*Proof.*  \nDuring the scan of `s` the algorithm collects characters into\n`word` until the next character is a space or the end of the string.\n\n* If a space is encountered, the block of characters stored in `word`\n  is exactly the preceding word.\n  The algorithm sorts them, appends the sorted word to `result`,\n  and then appends the space itself.  \n  Thus the word is correctly processed and the space is preserved.\n\n* If the end of string is reached, the same reasoning applies to the\n  final word. \u220e\n\n*Lemma 2*  \nThe order of the words and spaces in `s` appears unchanged in `result`.\n\n*Proof.*  \nThe algorithm scans `s` from left to right.\nEach space is appended immediately when it is read,\nand each word is appended only after the preceding space (or start of\nstring).  \nHence the relative order of words and spaces is preserved. \u220e\n\n*Theorem*  \n`result` returned by the algorithm is the ordered version of `s`\naccording to the problem statement.\n\n*Proof.*  \nBy Lemma&nbsp;1 every word is sorted, and by Lemma&nbsp;2 the sequence\nof words and spaces remains the same as in the original string.\nThus `result` satisfies all required properties. \u220e\n\n**Complexity Analysis**\n\nLet `n` be the length of `s` and let `L` be the sum of lengths of\nall words (i.e. `L \u2264 n`).  \nEach character is processed once, and each word of length `k`\nis sorted in `O(k log k)` time.  \nTherefore the total running time is  \n`O( \u03a3 k log k ) \u2264 O( L log L ) \u2264 O( n log n )`.  \nThe algorithm uses `O(n)` additional memory for the result string\nand the temporary `word` buffer.\n\n**Reference Implementation (C++17)**\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*  anti_shuffle\n *  Rearranges each word independently while keeping the original\n *  word and space order.\n */\nstring anti_shuffle(const string& s) {\n    string result;\n    string word;\n\n    for (char c : s) {\n        if (c == ' ') {               // word boundary\n            if (!word.empty()) {\n                sort(word.begin(), word.end());\n                result += word;\n                word.clear();\n            }\n            result += c;              // keep the space\n        } else {                      // part of a word\n            word += c;\n        }\n    }\n\n    // process the last word if string ends with a word\n    if (!word.empty()) {\n        sort(word.begin(), word.end());\n        result += word;\n    }\n\n    return result;\n}\n\n/* ---- Example usage ----\nint main() {\n    cout << anti_shuffle(\"Hello World!!!\") << endl;   // Hello !!!Wdlor\n    cout << anti_shuffle(\"Hi\") << endl;               // Hi\n    cout << anti_shuffle(\"hello\") << endl;            // ehllo\n    return 0;\n}\n*/\n```\n\nThe implementation follows exactly the algorithm proven correct above\nand is fully compliant with the GNU++17 compiler.", "Here is a clean and straightforward implementation of the `anti_shuffle` function in C++ that meets the requirements:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <algorithm>\n\n/// \\brief  Reorders each word of a sentence so that its\n///         characters appear in ascending ASCII order.\n///\n/// \\param  s  The input string.  Words are sequences of non\u2011space\n///            characters separated by one or more spaces.\n/// \\return The transformed string where every word is sorted\n///         individually, but the order of words and the exact\n///         spacing between them is preserved.\n///\n/// \\note   The function keeps every character that is not a space\n///         (punctuation, digits, etc.) inside the word and\n///         sorts it according to normal `char` ordering.\n///\n/// Example\n/// -------\n/// ```\n/// anti_shuffle(\"Hello World!!!\")  // returns \"Hello !!!Wdlor\"\n/// ```\nstd::string anti_shuffle(const std::string& s)\n{\n    std::string result;\n    std::string current_word;\n\n    for (char c : s) {\n        if (c == ' ') {\n            // We hit a space \u2013 output the (possibly sorted) word\n            // and then the actual space.\n            if (!current_word.empty()) {\n                std::sort(current_word.begin(), current_word.end());\n                result += current_word;\n                current_word.clear();\n            }\n            result += c;                     // keep the original space\n        } else {\n            // Accumulate characters belonging to the current word.\n            current_word += c;\n        }\n    }\n\n    // Handle the last word (if the string doesn't end with a space).\n    if (!current_word.empty()) {\n        std::sort(current_word.begin(), current_word.end());\n        result += current_word;\n    }\n\n    return result;\n}\n\n// ---- Simple test harness ----------------------------------------------------\nint main()\n{\n    std::cout << \"\\\"\" << anti_shuffle(\"Hi\") << \"\\\"\\n\";                // Hi\n    std::cout << \"\\\"\" << anti_shuffle(\"hello\") << \"\\\"\\n\";             // ehllo\n    std::cout << \"\\\"\" << anti_shuffle(\"Hello World!!!\") << \"\\\"\\n\";    // Hello !!!Wdlor\n    return 0;\n}\n```\n\n### How it works\n\n1. **Scan the string once**  \n   We iterate over every character, building up `current_word` until we hit a space.\n\n2. **Sort and write out each word**  \n   When a space is encountered (or at the end of the string), we sort the accumulated word using `std::sort` and append it to the result.\n\n3. **Preserve spacing**  \n   The actual space character from the input is added directly to the result, so the number and position of spaces remain unchanged.\n\n4. **Return the final string**  \n   After the loop, any remaining word (the last one) is sorted and appended.\n\nThis implementation has a time complexity of **O(n\u202flog\u202fm)**, where *n* is the length of the input string and *m* is the average length of the words, which is optimal for the problem.", "**Solution Explanation**\n\nThe task is to sort the characters of every \u201cword\u201d in the input string independently, while leaving all spaces in exactly the same positions.  \nA *word* is a maximal sequence of consecutive non\u2011space characters.  \nEverything that is not a space belongs to a word and participates in the sorting \u2013 punctuation, digits, upper\u2011case letters, etc.\n\n--------------------------------------------------------------------\n\n### Algorithm\n```\nanti_shuffle(s):\n    result  = empty string\n    i       = 0                            // current position in s\n\n    while i < len(s):\n        if s[i] == ' ':                    // copy space unchanged\n            result += ' '\n            i += 1\n        else:                              // start of a word\n            start = i\n            while i < len(s) and s[i] != ' ':\n                i += 1\n            word = s[start : i]          // substring of the word\n            sort(word.begin(), word.end()) // ascending ASCII order\n            result += word\n\n    return result\n```\n\n--------------------------------------------------------------------\n\n### Correctness Proof  \n\nWe prove that the algorithm returns the required \"ordered version\" of the input string.\n\n*Lemma 1*  \nDuring the traversal, every character of the input string is appended to the output exactly once.\n\n*Proof.*  \nThe outer loop runs until `i == len(s)`.  \n- If `s[i]` is a space, the algorithm appends that space to `result` and increments `i` by 1.  \n- If `s[i]` is not a space, the inner loop moves `i` to the index of the first following space (or the end of the string). All characters from `start` to this new `i` belong to the same word and are appended together to `result`. No character is skipped or appended twice. \u220e\n\n*Lemma 2*  \nLet `w` be a word of the input string. The algorithm appends to the output string the characters of `w` sorted in ascending ASCII order.\n\n*Proof.*  \nWhen the algorithm encounters the first character of `w`, the inner loop records the whole word `w` in the variable `word`.  \nThe line `sort(word.begin(), word.end())` rearranges `word` in non\u2011decreasing ASCII order.  \nFinally `word` is appended to `result`. By Lemma&nbsp;1 no character from `w` is lost or added elsewhere. \u220e\n\n*Theorem*  \nThe output string produced by `anti_shuffle` contains exactly the same characters as the input with the following property:  \n\u2013 each sequence of non\u2011space characters (each word) is replaced by the same characters sorted in ascending ASCII order;  \n\u2013 all spaces remain at their original positions.\n\n*Proof.*  \nBy Lemma&nbsp;1 the set of characters in the output equals the set in the input, and no character changes its position relative to the spaces.  \nBy Lemma&nbsp;2 every word is sorted correctly.  \nTherefore the output satisfies the specification. \u220e\n\n--------------------------------------------------------------------\n\n### Complexity Analysis\n\nLet `n` be the length of the input string and `m` the number of words.  \n- Scanning the string is `O(n)` time.  \n- Sorting each word of length `k` costs `O(k log k)`.  \n  Summed over all words, the total sorting time is `O(n log k_max)` where `k_max` is the maximum word length (worst\u2011case `k_max = n`).  \n- The algorithm uses `O(n)` additional space for the result string and for the temporary word buffer.\n\n--------------------------------------------------------------------\n\n### Reference Implementation (C++17)\n\n```cpp\n#include <string>\n#include <algorithm>\n\nstd::string anti_shuffle(const std::string& s) {\n    std::string result;\n    result.reserve(s.size());      // avoid reallocations\n\n    std::size_t i = 0;\n    while (i < s.size()) {\n        if (s[i] == ' ') {         // keep space unchanged\n            result += ' ';\n            ++i;\n        } else {                   // word begins here\n            std::size_t start = i;\n            while (i < s.size() && s[i] != ' ')\n                ++i;\n            std::string word = s.substr(start, i - start);\n            std::sort(word.begin(), word.end()); // ASCII ascending\n            result += word;\n        }\n    }\n    return result;\n}\n```\n\nThe function follows exactly the algorithm proven correct above and compiles with any C++17 compiler."]}
{"completions": ["```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// @brief Return the largest proper divisor of `n` (i.e. the greatest number\n///         that divides `n` evenly and is strictly smaller than `n`).\n///\n/// The function works for all positive integers `n`.  For `n == 1` or for\n/// negative numbers the behaviour is undefined (assert fails).\n/// \n/// @param n Input integer. Must be > 1.\n/// @return The largest divisor of `n` that is < n.\n///\n/// @note The algorithm runs in O(\u221an) time.  For each candidate divisor `i`\n///       starting from 2 we check if `n % i == 0`.  The first such divisor\n///       is the smallest prime factor `p`, and the largest proper divisor\n///       is `n / p`.  If no divisor is found, `n` is prime and the answer\n///       is `1` (since `n / n` would be itself, so we return `1` instead).\nlong largest_divisor(long n) {\n    assert(n > 1);                // we only handle positive integers > 1\n    if (n == 2) return 1;         // smallest special case\n\n    // Find the smallest divisor greater than 1\n    for (long i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            // i is a divisor, so n / i is \u2265 i\n            // n / i is the largest proper divisor\n            return n / i;\n        }\n    }\n\n    // If no divisor found above, n is prime\n    return 1; // largest proper divisor of a prime is 1\n}\n```", "Below is a minimal yet robust implementation of **`largest_divisor`**.  \nThe routine works for any positive integer `n` and returns the greatest integer `< n` that divides `n` without remainder. For `n == 1` it returns `1` (by convention, because 1 has no proper divisor).  \n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// Find the largest proper divisor of n.\n/// \\param n   positive integer (n >= 1)\n/// \\return   greatest d < n such that n % d == 0\n///            (if n == 1, returns 1 by convention)\nlong long largest_divisor(long long n) {\n    assert(n >= 1);               // safeguard\n    if (n == 1) return 1;         // 1 has no proper divisor\n\n    // Search from sqrt(n) downwards \u2013 the first divisor found\n    // will be the largest proper divisor.\n    for (long long d = static_cast<long long>(sqrt(n)); d >= 1; --d) {\n        if (n % d == 0) {\n            long long other = n / d;\n            // `other` is the counterpart divisor.\n            // Since we look from sqrt(n) downwards, either\n            // `other` (>= sqrt(n)) or `d` (<= sqrt(n)) will be the\n            // largest proper divisor \u2013 just pick the larger\n            // one that is strictly smaller than n.\n            if (other < n) return other;\n            if (d < n)   return d;\n        }\n    }\n    // For prime numbers n, the loop never hits, but that\n    // never occurs because 1 is always a divisor \u2013 handled above.\n    return 1;                       // unreachable\n}\n```\n\n### How it works\n\n1. **Edge case** \u2013 For `n == 1` we return `1`.\n2. We only need to check divisors up to `sqrt(n)`.  \n   If `d` divides `n`, then `n/d` is the complementary divisor.\n3. Starting from `sqrt(n)` and moving downward guarantees that\n   the first divisor we encounter will give the largest proper divisor.\n4. We return the larger of the two complementary divisors\n   that is strictly smaller than `n`.\n\nThis algorithm runs in `O(\u221an)` time and uses `O(1)` auxiliary space.", "**Solution Overview**\n\nFor a given integer `n > 1` we want the largest proper divisor (i.e. a divisor strictly smaller than `n`).  \nThe most efficient way is:\n\n1. Find the **smallest** divisor of `n` that is larger than `1`.  \n2. The largest proper divisor will always be the quotient `n / smallest_divisor`.  \n\nIf `n` is prime, the smallest divisor is `n` itself, so the largest proper divisor is `1`.  \nFor `n \u2264 1` we can either return `0` or throw an error \u2013 the implementation below returns `0`.\n\nThe smallest divisor can be found by iterating from `2` up to `\u221an`.  \nIf no divisor is found in that range, the number is prime.\n\n---\n\n```cpp\n#include <cassert>\n#include <cmath>\n\n// Returns the largest proper divisor of n (divisor < n).\n// For n <= 1, the function returns 0.\nlong largest_divisor(long n)\n{\n    if (n <= 1) return 0;                     // no proper divisor\n\n    // Find smallest divisor > 1\n    for (long d = 2; d <= static_cast<long>(std::sqrt(n)); ++d) {\n        if (n % d == 0) {\n            // d is the smallest divisor, so n/d is the largest proper divisor\n            return n / d;\n        }\n    }\n    // n is prime: largest proper divisor is 1\n    return 1;\n}\n\n/*** Test cases ***/\nint main()\n{\n    assert(largest_divisor(15) == 5);   // 15 = 3 \u00d7 5\n    assert(largest_divisor(16) == 8);   // 16 = 2 \u00d7 8\n    assert(largest_divisor(13) == 1);   // 13 is prime\n    assert(largest_divisor(6)  == 3);   // 6 = 2 \u00d7 3\n    assert(largest_divisor(1)  == 0);\n    return 0;\n}\n```\n\n**Explanation of the algorithm**\n\n- The loop runs at most `\u230a\u221an\u230b` times.\n- The first time a divisor `d` is found, it must be the smallest possible divisor (>1).\n  Therefore the complementary divisor `n/d` is the largest proper divisor.\n- If no divisor is found, `n` is prime and its only proper divisor is `1`.\n\nThe function runs in `O(\u221an)` time and uses `O(1)` additional memory."]}
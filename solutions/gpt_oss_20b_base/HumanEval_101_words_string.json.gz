{"completions": ["Here is a concise and portable implementation that works for any string in which words are separated by **spaces** or **commas** (or a mixture of both).  \nIt does **not** depend on any non\u2011standard library features, so you can use it in any C++\u00a011\u2011(or newer) environment.\n\n```cpp\n#include <string>\n#include <vector>\n#include <cctype>   // for std::isspace\n#include <sstream>  // for std::istringstream\n\n// Split a string into words separated by spaces or commas.\n// Consecutive separators, leading/trailing separators, and empty words\n// are automatically ignored.\nstd::vector<std::string> words_string(const std::string& s)\n{\n    std::vector<std::string> words;\n    std::string current;\n\n    for (char c : s)\n    {\n        if (c == ',' || std::isspace(static_cast<unsigned char>(c)))\n        {\n            // end of a word\n            if (!current.empty())\n            {\n                words.push_back(current);\n                current.clear();\n            }\n        }\n        else\n        {\n            current.push_back(c);\n        }\n    }\n\n    // last word (if string doesn't end with a separator)\n    if (!current.empty())\n    {\n        words.push_back(current);\n    }\n\n    return words;\n}\n```\n\n### How it works\n\n1. **Iterate over each character** of the input string.  \n2. When a comma `,` or any whitespace (`std::isspace`) is encountered, the current word (if any) is stored in the result vector and cleared.  \n3. All other characters are appended to the current word.  \n4. After the loop, if a word remains, it is also added to the vector.  \n\n### Testing\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    auto v1 = words_string(\"Hi, my name is John\");\n    auto v2 = words_string(\"One, two, three, four, five, six\");\n    for (auto&& w : v1) std::cout << w << ' ';\n    std::cout << \"\\n\";\n    for (auto&& w : v2) std::cout << w << ' ';\n    std::cout << \"\\n\";\n}\n```\n\nOutput:\n\n```\nHi my name is John \nOne two three four five six \n```\n\nThis implementation handles corner cases such as consecutive commas, leading/trailing separators, and empty input strings gracefully.", "Below is a simple, self\u2011contained implementation that\n\n1. iterates over the input string,\n2. keeps a buffer for the current word,\n3. whenever a comma or a space (or any other delimiter we might want to add later) is encountered, the buffer is flushed into the result vector,\n4. after the loop the last word (if any) is also flushed.\n\n```cpp\n#include <string>\n#include <vector>\n\nstd::vector<std::string> words_string(std::string s)\n{\n    std::vector<std::string> words;   // result\n    std::string cur;                  // current word being built\n\n    for (char ch : s)\n    {\n        // treat comma and space as separators\n        if (ch == ',' || ch == ' ')\n        {\n            if (!cur.empty())\n            {\n                words.push_back(cur);\n                cur.clear();\n            }\n        }\n        else\n        {\n            cur.push_back(ch);\n        }\n    }\n\n    // last word (if the string does not end with a delimiter)\n    if (!cur.empty())\n        words.push_back(cur);\n\n    return words;\n}\n```\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    auto v = words_string(\"Hi, my name is John\");\n    for (auto&& w : v)\n        std::cout << w << '\\n';\n}\n```\n\nThis prints\n\n```\nHi\nmy\nname\nis\nJohn\n```\n\nFeel free to extend the set of delimiters by adding more conditions in the `if` statement.", "Here is a concise and robust implementation of `words_string`.  \nIt removes any leading/trailing spaces, splits the input on either commas or spaces (treating consecutive delimiters as a single separator), and returns the words in a `std::vector<std::string>`.\n\n```cpp\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iterator>\n#include <regex>\n\nstd::vector<std::string> words_string(std::string s) {\n    // Remove surrounding white\u2011spaces\n    s.erase(s.begin(),\n            std::find_if(s.begin(), s.end(),\n                         [](unsigned char ch) { return !std::isspace(ch); }));\n    s.erase(std::find_if(s.rbegin(), s.rend(),\n                         [](unsigned char ch) { return !std::isspace(ch); })\n                .base(),\n            s.end());\n\n    // Empty string \u2192 empty vector\n    if (s.empty()) return {};\n\n    // Split on commas or spaces.  Using regex to handle consecutive delimiters.\n    std::regex re(\"[,\\\\s]+\");\n    std::sregex_token_iterator it(s.begin(), s.end(), re, -1);\n    std::sregex_token_iterator end;\n\n    std::vector<std::string> words;\n    for (; it != end; ++it) {\n        // ignore empty tokens that might appear if the string starts/ends with delimiters\n        if (!it->matched.empty())\n            words.emplace_back(*it);\n    }\n    return words;\n}\n```\n\n### How it works\n\n1. **Trimming** \u2013 The first two `erase` statements strip any leading or trailing whitespace.  \n2. **Regex Split** \u2013 The regular expression `[,\\\\s]+` matches one or more commas or whitespace characters.  \n   `sregex_token_iterator` with the replacement token `-1` returns all substrings that are *not* matched by the regex, i.e., the words.  \n3. **Collecting** \u2013 We iterate over the tokens, discarding any empty ones (just in case) and push the rest into a vector.\n\nThis function will correctly handle inputs such as:\n\n```cpp\nwords_string(\"Hi, my name is John\");\n// {\"Hi\", \"my\", \"name\", \"is\", \"John\"}\n\nwords_string(\"One, two, three, four, five, six\");\n// {\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"}\n\nwords_string(\"   leading and trailing   \");\n// {\"leading\",\"and\",\"trailing\"}\n\nwords_string(\",, ,  hello,,world,,\");\n// {\"hello\",\"world\"}\n```\n\nFeel free to adjust the trimming logic if you want to keep delimiters at the ends."]}
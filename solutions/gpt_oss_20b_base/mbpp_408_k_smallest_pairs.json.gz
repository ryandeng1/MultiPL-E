{"completions": ["```cpp\n#include <vector>\n#include <queue>\n#include <utility>   // std::pair\n#include <limits>    // std::numeric_limits\n#include <functional>\n\n/// @brief Return the k smallest pairs (x, y) such that x \u2208 nums1, y \u2208 nums2.\n/// @param nums1  first sorted array (it can be unsorted, we sort inside).\n/// @param nums2  second sorted array.\n/// @param k      how many pairs to return (k \u2264 |nums1| * |nums2|).\n/// @return vector of size k, each element is a vector of two longs: {x, y}.\n///\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1,\n                                                std::vector<long> nums2,\n                                                long k) {\n\n    std::vector<std::vector<long>> res;\n    if (nums1.empty() || nums2.empty() || k <= 0) return res;\n\n    /* Make sure both arrays are sorted.  If the caller guarantees that\n       they are already sorted we could skip this, but sorting is cheap\n       and removes a source of bugs.                                        */\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n\n    /*  The heap keeps the \u201cnext\u201d pair that could be the smallest.\n        We store a struct that contains the sum, the indices of the\n        elements (`i` for nums1, `j` for nums2), and the pair itself\n        so that we can reconstruct the answer in O(1).                     */\n    struct Node {\n        long sum;\n        size_t i, j;\n        bool operator>(const Node& other) const { return sum > other.sum; }\n    };\n    using PQ = std::priority_queue<Node, std::vector<Node>, std::greater<Node>>;\n\n    PQ pq;\n    // initial push: each element of nums1 paired with nums2[0] (the smallest of nums2)\n    for (size_t i = 0; i < nums1.size() && i < static_cast<size_t>(k); ++i) {\n        pq.push(Node{nums1[i] + nums2[0], i, 0});\n    }\n\n    while (k > 0 && !pq.empty()) {\n        Node cur = pq.top(); pq.pop();\n\n        res.push_back({cur.i, cur.j});               // store indices\n        // if there is a next element in nums2 for the same nums1[i], push it\n        if (cur.j + 1 < nums2.size()) {\n            pq.push(Node{nums1[cur.i] + nums2[cur.j + 1], cur.i, cur.j + 1});\n        }\n\n        --k;\n    }\n\n    return res;\n}\n\n/* ------------------------------------------------------------------ */\n/*                  Usage example (uncomment to test)                  */\n/* ------------------------------------------------------------------ */\n/*\n#include <iostream>\nint main() {\n    std::vector<long> a = {1,7,11};\n    std::vector<long> b = {2,4,6};\n    long k = 3;\n\n    auto pairs = k_smallest_pairs(a, b, k);\n    for (auto &p : pairs) {\n        std::cout << \"(\" << a[p[0]] << \", \" << b[p[1]] << \")\\n\";\n    }\n}\n*/\n```\n\n**Explanation**\n\n* The arrays are sorted first.\n* A min\u2011heap (`std::priority_queue` with `std::greater`) stores the current\n  smallest candidate pair (`sum`, index in `nums1`, index in `nums2`).\n* Initially, we pair each element of `nums1` (up to `k` of them) with the\n  smallest element of `nums2`.  \n  Every time we pop the smallest candidate, we add it to the result and\n  push the next pair consisting of the same element from `nums1` and the\n  next element from `nums2`, if it exists.\n* The algorithm runs in `O(k log min(k, n1))` time and `O(min(k, n1))`\n  memory, where `n1 = nums1.size()`.", "Below is a **complete, self\u2011contained implementation** that returns the `k` smallest pairs\n(respectively the *sum* of the two numbers is minimal) where one element comes from\n`nums1` and the other from `nums2`.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n *  Return the `k` smallest pairs (a,b) from `nums1` and `nums2` where\n *  the pair sum `a+b` is minimal.\n *  The result is a vector of pairs.  If the total number of pairs is\n *  less than `k` all pairs are returned.\n *\n *  Complexity: O(k log k)  (because we keep a heap of size at most k)\n *  Memory:     O(k)\n */\nvector<vector<long>> k_smallest_pairs(vector<long> nums1,\n                                      vector<long> nums2,\n                                      long k)\n{\n    /* Sort the inputs \u2013 useful in case the caller does not pass sorted\n       arrays and allows us to use an efficient heap strategy.  */\n    sort(nums1.begin(), nums1.end());\n    sort(nums2.begin(), nums2.end());\n\n    /* Edge cases: either vector empty or k is zero. */\n    if (nums1.empty() || nums2.empty() || k == 0)\n        return {};\n\n    /* Min\u2011heap that keeps the next smallest sum left to visit.\n       The heap element is a tuple: (sum, i, j) where\n         - sum  = nums1[i] + nums2[j]\n         - i    = index in nums1\n         - j    = index in nums2  */\n    using Node = tuple<long,long,long>;\n    auto cmp = [](const Node &a, const Node &b)\n    { return get<0>(a) > get<0>(b); };   // min\u2011heap on sum\n    priority_queue<Node, vector<Node>, decltype(cmp)> pq(cmp);\n\n    /* We begin with the smallest element from `nums1` paired\n       with the first element from `nums2`. */\n    pq.emplace(nums1[0] + nums2[0], 0, 0);\n\n    vector<vector<long>> result;\n\n    /* To avoid pushing the same `(i,j)` twice we use a visited set.\n       The key is i*size2 + j which is unique because j<nums2.size(). */\n    unordered_set<long> visited;\n    visited.insert(0);   // (0,0) -> 0*size2 + 0\n\n    const long n1 = nums1.size();\n    const long n2 = nums2.size();\n\n    while (!pq.empty() && (long)result.size() < k)\n    {\n        auto [sum, i, j] = pq.top();\n        pq.pop();\n\n        result.push_back({nums1[i], nums2[j]});\n\n        /* Move to the next element in nums2 (same i, j+1). */\n        if (j + 1 < n2)\n        {\n            long key = i * n2 + (j + 1);\n            if (visited.emplace(key).second)          // inserted new\n                pq.emplace(nums1[i] + nums2[j + 1], i, j + 1);\n        }\n\n        /* Move to the next element in nums1 (i+1, same j). */\n        if (i + 1 < n1)\n        {\n            long key = (i + 1) * n2 + j;\n            if (visited.emplace(key).second)\n                pq.emplace(nums1[i + 1] + nums2[j], i + 1, j);\n        }\n    }\n\n    return result;\n}\n\n/* -------------------------------------------------------------------- */\n/*  Below is a small test harness (optional).  It will only compile\n    if you remove the guard `#ifndef RUN_TESTS`.                     */\n#ifndef RUN_TESTS\nint main()\n{\n    vector<long> a = {1, 7, 11};\n    vector<long> b = {2, 4, 6};\n    long k = 3;\n\n    auto pairs = k_smallest_pairs(a, b, k);\n\n    for (auto &p : pairs)\n        cout << \"(\" << p[0] << \",\" << p[1] << \") \";\n    cout << \"\\n\";\n}\n#endif\n```\n\n### How It Works\n1. **Sorting** \u2013  \n   Sorting each input allows us to use a classic *k\u2011min pairs*\n   strategy (primarily for the convenience of the heap index logic).\n\n2. **Min\u2011Heap** \u2013  \n   The heap always contains the next candidate pairs sorted by their sum.\n   We start with `(0,0)` (smallest element from each array).  \n   After popping a pair, we push the *right* neighbor `(i, j+1)` and the\n   *down* neighbor `(i+1, j)` if they have not been seen before.\n\n3. **Visited set** \u2013  \n   To keep each `(i,j)` combination only once, we encode it as\n   `i * n2 + j` and store it in an `unordered_set`.\n\n4. **Termination** \u2013  \n   The loop stops when the heap gets empty or we collect `k` pairs\n   (whichever comes first). If there are fewer than `k` total pairs,\n   all of them are returned.\n\nThe algorithm runs in `O(k log k)` time and uses `O(k)` memory, which is\noptimal for this problem.", "**Solution Overview**\n\nWe\u2019re given two integer vectors `nums1` and `nums2` and a number `k`.  \nWe have to return the `k` smallest pairs `(a,b)` such that `a` comes from `nums1` and `b` comes from `nums2`.  \nThe pair is compared by the sum `a + b`.  \nIf two pairs have the same sum, any order is acceptable.\n\nThe classic way to solve this problem is to treat it as a **k\u2011smallest elements from a sorted matrix** problem (the matrix is `n1 \u00d7 n2` where each entry is `nums1[i] + nums2[j]`).  \nWe use a *min\u2011heap* (priority queue) that always contains the next smallest candidate pair.\n\n---\n\n### Algorithm\n\n1. **Special cases**\n\n   * If `nums1` or `nums2` is empty \u2192 return empty result.\n   * If `k` is 0 \u2192 return empty result.\n\n2. **Initial heap**\n\n   For every element `nums1[i]` build a candidate pair with the *first* element of `nums2` (index `0`).  \n   Push the tuple `(sum, i, 0)` into a min\u2011heap where:\n\n   * `sum   = nums1[i] + nums2[0]`\n   * `i     = index in nums1`\n   * `0     = index in nums2` (currently pointing to the first element)\n\n   (We can also start only from j=0 for all i; this is sufficient because the matrix is sorted by columns.)\n\n3. **Extract `k` times**\n\n   For up to `k` iterations do:\n\n   * Pop the smallest element `(sum, i, j)` from the heap.\n   * Append the pair `[nums1[i], nums2[j]]` to the answer vector.\n   * If there is a next element in the same row (`j + 1 < nums2.size()`),  \n     push the new candidate `(nums1[i] + nums2[j+1], i, j+1)` into the heap.\n\n   The heap size never exceeds `min(k, nums1.size())`; each operation is `O(log\u202fmin(k, nums1.size()))`.\n\n4. **Return**\n\n   Return the answer vector.\n\n---\n\n### Complexity Analysis\n\n*Let `n = nums1.size()`, `m = nums2.size()`.*\n\n* **Time** \u2013  \n  Each push/pop costs `O(log\u202fmin(k,n))`.  \n  We perform at most `k` pops and at most `k` pushes \u2192 `O(k log\u202fmin(k,n))`.  \n  (This is optimal for the problem because we only need the first `k` pairs.)\n\n* **Space** \u2013  \n  The heap keeps at most `min(k,n)` elements; plus the result vector `k`.  \n  So `O(k + min(k,n)) = O(k)` space.\n\n---\n\n### C++17 Implementation\n\n```cpp\n#include <vector>\n#include <queue>\n#include <tuple>\n\n/*\n *  Return k pairs (one element from nums1, one from nums2) with the smallest sums.\n *  The returned vector contains each pair as a two\u2011element vector.\n *\n *  Complexity:\n *    Time  : O(k log min(k, nums1.size()))\n *    Space : O(k)\n */\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1,\n                                                std::vector<long> nums2,\n                                                long k)\n{\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k <= 0) return result;\n\n    /* min\u2011heap: (current sum, index in nums1, index in nums2) */\n    using HeapNode = std::tuple<long, size_t, size_t>;\n    auto cmp = [](const HeapNode& a, const HeapNode& b) {\n        return std::get<0>(a) > std::get<0>(b); // min\u2011heap by sum\n    };\n    std::priority_queue<HeapNode, std::vector<HeapNode>, decltype(cmp)> pq(cmp);\n\n    size_t n1 = nums1.size();\n    size_t n2 = nums2.size();\n\n    /* initialise heap with the first column (j = 0) for all i */\n    for (size_t i = 0; i < n1 && i < static_cast<size_t>(k); ++i) {\n        pq.emplace(nums1[i] + nums2[0], i, 0);\n    }\n\n    while (!pq.empty() && static_cast<long>(result.size()) < k) {\n        auto [currSum, i, j] = pq.top();\n        pq.pop();\n\n        result.push_back({nums1[i], nums2[j]});\n\n        /* push next element in the same row (i) if it exists */\n        if (j + 1 < n2) {\n            pq.emplace(nums1[i] + nums2[j + 1], i, j + 1);\n        }\n    }\n\n    return result;\n}\n```\n\nThe code follows the algorithm described above, is fully type\u2011safe, and compiles with any C++17 compiler."]}
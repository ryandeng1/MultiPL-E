{"completions": ["Here\u2019s a complete, self\u2011contained solution that implements the classic 3\u2011D dynamic\u2011programming algorithm for the longest common subsequence of **three** strings.  \nThe function signature you started with is kept, and a short example driver is supplied so you can test it yourself.\n\n```cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n/*\n *  Longest Common Subsequence (LCS) of three strings.\n *\n *  Time Complexity :  O(n * m * p)\n *  Space Complexity:  O(n * m * p)   (can be reduced to 2\u2011D or 1\u2011D if memory is tight)\n *\n *  Parameters\n *      X, Y, Z \u2013 the three input strings\n *\n *  Returns\n *      Length of the longest common subsequence of X, Y and Z\n */\nlong lcs_of_three(const std::string& X,\n                  const std::string& Y,\n                  const std::string& Z)\n{\n    const int n = (int)X.size();\n    const int m = (int)Y.size();\n    const int p = (int)Z.size();\n\n    // 3\u2011D DP array: dp[i][j][k] = LCS length of X[0..i-1], Y[0..j-1], Z[0..k-1]\n    std::vector<std::vector<std::vector<long>>> dp(\n        n + 1, std::vector<std::vector<long>>(m + 1, std::vector<long>(p + 1, 0)));\n\n    for (int i = 1; i <= n; ++i)\n    {\n        for (int j = 1; j <= m; ++j)\n        {\n            for (int k = 1; k <= p; ++k)\n            {\n                if (X[i - 1] == Y[j - 1] && X[i - 1] == Z[k - 1])\n                {\n                    // Current character is part of the LCS\n                    dp[i][j][k] = 1 + dp[i - 1][j - 1][k - 1];\n                }\n                else\n                {\n                    // Take the maximum of the three possibilities\n                    dp[i][j][k] = std::max({\n                        dp[i - 1][j][k],\n                        dp[i][j - 1][k],\n                        dp[i][j][k - 1]\n                    });\n                }\n            }\n        }\n    }\n    return dp[n][m][p];\n}\n\n/*------------------ Driver / Test harness ------------------*/\nint main()\n{\n    // Example from GeeksforGeeks\n    std::string X = \"AGGT12\";\n    std::string Y = \"12TXAYB\";\n    std::string Z = \"12XBA\";\n\n    long result = lcs_of_three(X, Y, Z);\n    std::cout << \"LCS length: \" << result << '\\n';   // Output should be 2\n\n    // Quick sanity checks\n    assert(lcs_of_three(\"abc\", \"abc\", \"abc\") == 3);\n    assert(lcs_of_three(\"abc\", \"def\", \"ghi\") == 0);\n    assert(lcs_of_three(\"\", \"xyz\", \"xyz\") == 0);\n\n    return 0;\n}\n```\n\n### How it works\n\n1. **DP state**  \n   `dp[i][j][k]` stores the length of the LCS of the prefixes  \n   `X[0 \u2026 i\u20111]`, `Y[0 \u2026 j\u20111]`, `Z[0 \u2026 k\u20111]`.\n\n2. **Transition**  \n   * If the three current characters are equal \u2013 they must belong to the LCS.  \n     `dp[i][j][k] = 1 + dp[i-1][j-1][k-1]`.\n   * Otherwise the LCS can be obtained by dropping one of the three characters:  \n     `dp[i][j][k] = max(dp[i-1][j][k], dp[i][j-1][k], dp[i][j][k-1])`.\n\n3. **Initialization**  \n   All entries with any index equal to\u202f0 are 0 because an empty string shares no common subsequence with any other string.\n\n4. **Answer**  \n   The desired length is `dp[n][m][p]`.\n\nFeel free to adapt the memory layout (e.g., 2\u2011D or 1\u2011D rolling arrays) if you need to handle very long strings. The implementation above is clear, straightforward, and matches the classic GeeksforGeeks solution.", "Below is a **complete** implementation of the `lcs_of_three` function.  \nIt uses a 3\u2011dimensional DP table (`dp[i][j][k]` \u2013 LCS length for the first `i` chars of `X`, first `j` chars of `Y` and first `k` chars of `Z`) and runs in `O(n*m*p)` time and `O(n*m*p)` auxiliary memory (where `n = X.size()`, `m = Y.size()`, `p = Z.size()`).  \nThe function returns the length of the longest common subsequence of the three strings.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// -----------------------------------------------------------------\n// Returns the length of the Longest Common Subsequence (LCS)\n// of three input strings X, Y and Z.\n// -----------------------------------------------------------------\nlong lcs_of_three(const string &X, const string &Y, const string &Z)\n{\n    const size_t n = X.size(), m = Y.size(), p = Z.size();\n\n    // 3\u2011D DP table: we only need one row at a time in k\u2011direction,\n    // but for clarity we keep the whole table.\n    vector<vector<vector<long>>> dp(n + 1,\n                                    vector<vector<long>>(m + 1,\n                                                          vector<long>(p + 1, 0)));\n\n    // Fill DP table\n    for (size_t i = 1; i <= n; ++i) {\n        for (size_t j = 1; j <= m; ++j) {\n            for (size_t k = 1; k <= p; ++k) {\n                if (X[i - 1] == Y[j - 1] && X[i - 1] == Z[k - 1]) {\n                    dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1;\n                } else {\n                    dp[i][j][k] = max({dp[i - 1][j][k],\n                                       dp[i][j - 1][k],\n                                       dp[i][j][k - 1]});\n                }\n            }\n        }\n    }\n\n    return dp[n][m][p];\n}\n\n// -----------------------------------------------------------------\n// Example usage / simple test harness\n// -----------------------------------------------------------------\nint main()\n{\n    string X = \"abcfbc\";\n    string Y = \"abafcdc\";\n    string Z = \"cbafc\";\n\n    cout << \"Length of LCS of three strings = \"\n         << lcs_of_three(X, Y, Z) << '\\n';   // expected 3 (\"abc\" or \"cbc\")\n    return 0;\n}\n```\n\n### How it works\n\n1. **DP state definition**  \n   `dp[i][j][k]` = length of the LCS of:\n   - first `i` characters of `X`\n   - first `j` characters of `Y`\n   - first `k` characters of `Z`\n\n2. **Transitions**  \n   * If the three current characters are equal, we can extend the LCS found for the prefixes that omit these characters:  \n     `dp[i][j][k] = dp[i-1][j-1][k-1] + 1`.\n   * Otherwise, at least one string must omit its current character.  \n     Take the maximum of the three possibilities:  \n     `max(dp[i-1][j][k], dp[i][j-1][k], dp[i][j][k-1])`.\n\n3. **Initialization**  \n   All entries where any index is `0` are `0` because an empty string has no common subsequence with any other string.\n\n4. **Result**  \n   The answer is `dp[n][m][p]`, where `n = X.length()`, `m = Y.length()`, `p = Z.length()`.\n\nFeel free to integrate this function into your project or adapt the memory usage (e.g., by using only two \u201cslices\u201d of the 3\u2011D array if memory is tight).", "Here\u2019s a compact, self\u2011contained C++ implementation that follows the standard 3\u2011string LCS dynamic programming algorithm.  \nIt runs in \\(O(|X|\\cdot|Y|\\cdot|Z|)\\) time and uses a 3\u2011D DP table to keep the lengths of the longest common subsequence for every prefix triple \\((i,j,k)\\).\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n///  Find length of longest common subsequence for three strings.\n///\n///  \u201cLCS for three strings\u201d is a classic DP problem.\n///  dp[i][j][k] = length of LCS of:\n///          X[0 \u2026 i\u20111],  Y[0 \u2026 j\u20111],  Z[0 \u2026 k\u20111]\n///\n///  Transition:\n///  * if X[i\u20111] == Y[j\u20111] == Z[k\u20111]   -> 1 + dp[i\u20111][j\u20111][k\u20111]\n///  * otherwise                       -> max( dp[i\u20111][j][k],\n///                                            dp[i][j\u20111][k],\n///                                            dp[i][j][k\u20111] )\n///\nlong long lcs_of_three(const string& X,\n                       const string& Y,\n                       const string& Z)\n{\n    size_t n = X.size(), m = Y.size(), p = Z.size();\n\n    /*  One\u2011based indices: dp[0][*][*] = dp[*][0][*] = dp[*][*][0] = 0.  */\n    vector<vector<vector<long long>>> dp(\n        n + 1, vector<vector<long long>>(m + 1, vector<long long>(p + 1, 0)));\n\n    for (size_t i = 1; i <= n; ++i)\n        for (size_t j = 1; j <= m; ++j)\n            for (size_t k = 1; k <= p; ++k) {\n                if (X[i - 1] == Y[j - 1] && X[i - 1] == Z[k - 1]) {\n                    dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1;\n                } else {\n                    dp[i][j][k] = max({ dp[i - 1][j][k],\n                                        dp[i][j - 1][k],\n                                        dp[i][j][k - 1] });\n                }\n            }\n\n    return dp[n][m][p];\n}\n\n/* ----------  Example / test harness  ---------- */\n#ifdef LOCAL\nint main() {\n    string a = \"abpqi\";\n    string b = \"bqpax\";\n    string c = \"aphqi\";\n    cerr << \"LCS length = \" << lcs_of_three(a,b,c) << '\\n';   // expected 3 (\"aq\"??)\n    return 0;\n}\n#endif\n```\n\n### How it works\n\n* We allocate a 3\u2011dimensional vector `dp` with dimensions `(n+1) \u00d7 (m+1) \u00d7 (p+1)`.  \n  The extra row/column/depth for index `0` stores the base cases (empty prefixes).\n\n* We iterate through all prefix lengths `i`, `j`, `k`.  \n  When the last characters of those prefixes match, we extend the LCS by one; otherwise we take the best of the three ways of dropping a character from one of the strings.\n\n* The result is `dp[n][m][p]`, i.e., the LCS length of the whole three strings.\n\nThe algorithm is straightforward, works for any sized strings (within memory limits), and adheres to the problem statement on GeeksforGeeks."]}
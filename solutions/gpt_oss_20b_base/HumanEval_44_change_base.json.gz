{"completions": ["Here is a complete, self\u2011contained implementation of `change_base`.  \nIt converts a non\u2011negative integer `x` into a string in a base less than\u202f10.  \nThe implementation uses an iterative approach (you can also use recursions), and it\nhandles the special case `x == 0` correctly.\n\n```cpp\n#include <string>\n#include <stdexcept>\n\n// Change numerical base of input number x to `base`.\n// Returns string representation after the conversion.\n// Supporting bases: 2 \u2026 9.\n// The function throws std::invalid_argument if the base is not in that range.\n// Example:\n//   change_base(8, 3) -> \"22\"\n//   change_base(8, 2) -> \"1000\"\n//   change_base(7, 2) -> \"111\"\nstd::string change_base(long x, long base) {\n    if (base < 2 || base > 9) {\n        throw std::invalid_argument(\"base must be in the range [2,9]\");\n    }\n\n    if (x == 0) {\n        return \"0\";\n    }\n\n    std::string result;\n    long value = x;\n\n    while (value > 0) {\n        long digit = value % base;\n        result.push_back('0' + static_cast<int>(digit)); // digit is <10\n        value /= base;\n    }\n\n    // The computed string is reversed (least\u2011significant digit first)\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```\n\n### How it works\n1. **Input validation** \u2013 The base must lie in the range 2\u20139 (`<10`).  \n   If it doesn\u2019t, the function throws an exception (you can change this to an\n   `assert` if you prefer the original style).\n\n2. **Zero is special** \u2013 The conversion of `0` is simply `\"0\"`.\n\n3. **Conversion loop** \u2013  \n   * While `value` is non\u2011zero, obtain the remainder (`digit = value % base`),  \n     push the character representation of the digit onto `result`, and divide\n     `value` by `base`.  \n   * This builds the number from least\u2011significant to most\u2011significant digit,\n     so the string is reversed at the end.\n\n4. **Return** \u2013 The correctly ordered string is returned.\n\n### Usage Example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << change_base(8, 3) << '\\n';  // prints 22\n    std::cout << change_base(8, 2) << '\\n';  // prints 1000\n    std::cout << change_base(7, 2) << '\\n';  // prints 111\n}\n```\n\nFeel free to drop this implementation into your code base.", "Here is a straightforward implementation of the requested `change_base` function.  \nIt validates the inputs, rejects invalid bases (0, 1, or >\u202f9), and converts the number into the target base by repeatedly taking remainders. The function is also robust against negative inputs (it keeps the minus sign in front of the result).\n\n```cpp\n#include <string>\n#include <stdexcept>\n#include <limits>\n#include <cassert>\n\n// -----------------------------------------------------------------------------\n// convert a long integer x to a string representation in the given base\n// -----------------------------------------------------------------------------\n//  base must be an integer in the range 2 \u2026 9\n//  if x is negative the sign is preserved\n// -----------------------------------------------------------------------------\n// Examples:\n//  change_base(8,  3)  -> \"22\"\n//  change_base(8,  2)  -> \"1000\"\n//  change_base(7,  2)  -> \"111\"\n//\nstd::string change_base(long x, long base)\n{\n    // --------- sanity checks -----------------------------------------------\n    if (base < 2 || base > 9) {\n        throw std::invalid_argument(\n            \"base must be an integer between 2 and 9 (inclusive)\");\n    }\n\n    // --------- special case zero ------------------------------------------\n    if (x == 0) {\n        return \"0\";\n    }\n\n    // --------- remember sign -----------------------------------------------\n    bool negative = false;\n    if (x < 0) {\n        negative = true;\n        // careful with LLONG_MIN \u2013 absolute value would overflow\n        // therefore we use unsigned arithmetic\n    }\n\n    // --------- convert -----------------------------------------------\n    std::string result;\n    unsigned long long abs_val;\n    if (negative) {\n        abs_val = static_cast<unsigned long long>(-(x + 1)) + 1; // avoid overflow\n    } else {\n        abs_val = static_cast<unsigned long long>(x);\n    }\n\n    while (abs_val > 0) {\n        unsigned long long rem = abs_val % base;\n        result.push_back(static_cast<char>('0' + rem));   // because base < 10\n        abs_val /= base;\n    }\n\n    if (negative) {\n        result.push_back('-');\n    }\n\n    // reverse to get the most\u2011significant digit first\n    std::reverse(result.begin(), result.end());\n\n    return result;\n}\n\n// -----------------------------------------------------------------------------\n// Basic test harness \u2013 could be removed in production\n// -----------------------------------------------------------------------------\nint main() {\n    assert(change_base(8, 3) == \"22\");\n    assert(change_base(8, 2) == \"1000\");\n    assert(change_base(7, 2) == \"111\");\n    assert(change_base(0, 2) == \"0\");\n    assert(change_base(-8, 2) == \"-1000\");\n    std::cout << \"All tests passed.\\n\";\n}\n```\n\n### Explanation\n\n1. **Input validation** \u2013 Ensures `base` is between 2 and 9 (inclusive).  \n2. **Zero handling** \u2013 Directly returns `\"0\"` for `x==0`.  \n3. **Sign** \u2013 Keeps track of negativity; for negative values, conversion is done using the absolute value, then a `'-'` is prepended after conversion.  \n4. **Conversion loop** \u2013 Uses `abs_val % base` to get each digit from least\u2011significant to most\u2011significant.  \n5. **Character mapping** \u2013 Since all digits are <\u202f10, we can safely cast the remainder to a character by adding `'0'`.  \n6. **Reversal** \u2013 The digits are produced in reverse order, so we reverse the string at the end.  \n\nFeel free to integrate the function into your project or adapt it to other numeric types if needed.", "Here is a complete, self\u2011contained implementation of `change_base`.  \nThe function simply repeatedly divides the number by the target base, collecting the remainders in reverse order, and finally returns the string.  \nI also added a small `main` with the examples you provided so you can test it right away.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n//\n// Examples:\n//   change_base( 8, 3) -> \"22\"\n//   change_base( 8, 2) -> \"1000\"\n//   change_base( 7, 2) -> \"111\"\n//\nstring change_base(long x, long base) {\n    // handle zero explicitly\n    if (x == 0) return \"0\";\n\n    string res;\n    while (x > 0) {\n        long rem = x % base;               // remainder < base (<10)\n        res.push_back(char('0' + rem));     // convert digit to char\n        x /= base;\n    }\n    reverse(res.begin(), res.end());       // build the number in correct order\n    return res;\n}\n\n// ---------- optional test harness ----------\nint main() {\n    assert(change_base(8, 3) == \"22\");\n    assert(change_base(8, 2) == \"1000\");\n    assert(change_base(7, 2) == \"111\");\n    assert(change_base(0, 5) == \"0\");\n\n    cout << \"All tests passed.\\n\";\n    return 0;\n}\n```\n\n**Explanation**\n\n1. **Edge case** \u2013 If `x` is zero, simply return `\"0\"`.  \n2. **Loop** \u2013 While `x` is positive:  \n   * Compute `rem = x % base` (the least significant digit).  \n   * Append the character `'0' + rem` to the result.  \n   * Divide `x` by `base`.  \n3. **Reverse** \u2013 The digits were collected from least to most significant, so reverse the string before returning.\n\nThe algorithm works for any positive `x` and any base `2 <= base < 10`, as required."]}
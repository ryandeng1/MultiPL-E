{"completions": ["Below is a clean, commented C++ (the question slipped \u201ccppthon\u201d \u2013 I assume you mean\u202fC++) function that returns the sum of all **even** factors of a given integer `n`.  \nThe idea is simple: iterate through all divisors up to `\u221an`, add both `i` and `n / i` when they divide `n`, and keep only the even ones. This keeps the algorithm O(\u221an) \u2013 fast enough for ordinary 64\u2011bit integers.\n\n```cpp\n#include <cmath>\n#include <cstdint>\n\n/**\n * @brief Compute the sum of all even divisors of n.\n *\n * @param n  The integer whose even divisors are to be summed.\n *           n must be positive; for n <= 0 the function returns 0.\n *\n * @return  Sum of the even divisors of n.\n *\n * Complexity:  O( sqrt(n) )\n */\nstatic long long sumEvenFactors(long long n)\n{\n    if (n <= 0) return 0;           // no factors for non\u2011positive numbers\n\n    long long sum = 0;\n    long long root = static_cast<long long>(std::sqrt(static_cast<long double>(n)));\n\n    for (long long i = 1; i <= root; ++i)\n    {\n        if (n % i == 0)            // i is a divisor\n        {\n            long long j = n / i;   // the paired divisor\n\n            if ((i & 1LL) == 0)     // i is even?\n                sum += i;\n\n            if (j != i && (j & 1LL) == 0)   // j is a distinct divisor and even?\n                sum += j;\n        }\n    }\n    return sum;\n}\n\n/* ------------------------\n// Example usage\nint main()\n{\n    long long number = 36;\n    printf(\"The sum of even factors of %lld is %lld\\n\",\n           number, sumEvenFactors(number));\n    return 0;\n}\n-------------------------------- */\n```\n\n### Why this works\n\n* Divisors appear in pairs `(i, n/i)`.  \n* Checking up to `\u221an` guarantees we catch every divisor exactly once.  \n* The `& 1LL` test determines whether a number is even (bit\u2011wise faster than `%2`).\n\nFeel free to adapt the function\u2019s interface (`int64_t`, `unsigned long long`, etc.) to match the rest of your codebase.", "Here is a clean C++ function that returns the sum of all **even** divisors (factors) of a given number `n`.  \nThe solution works in \\(O(\\sqrt n)\\) time and handles the case when `n` is negative or zero.\n\n```cpp\n/*\n * Sum of even factors of n\n *\n * Time complexity : O( sqrt(n) )\n * Space complexity: O(1)\n *\n * The function takes a signed 64\u2011bit integer (long long) and returns the sum of\n * all divisors that are even.  If n is 0 we return 0, because the divisors are\n * undefined in that case.\n */\nlong long sumOfEvenFactors(long long n) {\n    if (n == 0)          // no meaningful divisors for zero\n        return 0;\n\n    if (n < 0)           // work with absolute value \u2013 factors are positive\n        n = -n;\n\n    long long sum = 0;\n    long long limit = static_cast<long long>(std::sqrt(n));\n\n    for (long long d = 1; d <= limit; ++d) {\n        if (n % d == 0) {            // d is a divisor\n            long long q = n / d;     // paired divisor\n\n            // add d if it is even\n            if ((d & 1LL) == 0)\n                sum += d;\n\n            // add q if it is not the same as d and is even\n            if (q != d && (q & 1LL) == 0)\n                sum += q;\n        }\n    }\n    return sum;\n}\n```\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    long long n = 28;           // 28 has even divisors 2, 4, 14, 28\n    std::cout << \"sum of even factors of \" << n\n              << \" = \" << sumOfEvenFactors(n) << '\\n';\n    return 0;\n}\n```\n\nOutput:\n```\nsum of even factors of 28 = 48\n```\n\nThe function iterates only up to the square root of `n`, adding both a divisor and its complementary divisor whenever the divisor is even. It also gracefully handles negative inputs by using their absolute value.", "Here\u2019s a concise way to compute the sum of **even** divisors of a positive integer `n` in C++:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// @brief Returns the sum of all even divisors of n.\n/// @param n A positive integer (n > 0)\n/// @return Sum of even factors of n\nlong long sumOfEvenFactors(long long n) {\n    if (n <= 1) return 0;          // 1 has no even divisor\n\n    long long sum = 0;\n    for (long long i = 1; i * i <= n; ++i) {\n        if (n % i == 0) {                     // i is a divisor\n\n            long long d1 = i;                 // first divisor\n            long long d2 = n / i;             // paired divisor\n\n            if (d1 % 2 == 0) sum += d1;        // add if even\n            if (d2 != d1 && d2 % 2 == 0) sum += d2; // avoid double\u2011counting square root\n        }\n    }\n    return sum;\n}\n```\n\n### Why this works\n\n1. **Loop up to `sqrt(n)`** \u2013 Every divisor `d` of `n` has a complementary divisor `n/d`. By iterating only up to the square root, we handle each pair only once.\n2. **Check for evenness** \u2013 We only add a divisor to the sum if it is divisible by `2`.\n3. **Avoid double counting** \u2013 When `i * i == n` (i.e., `i` is the square root), we ensure we add this divisor only once.\n\n### Example usage\n\n```cpp\nint main() {\n    long long num = 36;\n    cout << \"Sum of even factors of \" << num << \" is \" << sumOfEvenFactors(num) << endl;\n    // Output: 90 (2 + 4 + 6 + 12 + 18 + 36)\n}\n```\n\nThis implementation runs in `O(\u221an)` time and uses `O(1)` additional memory, making it efficient even for large values of `n`."]}
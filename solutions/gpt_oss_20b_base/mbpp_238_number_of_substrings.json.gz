{"completions": ["Here\u2019s a **Python** implementation that returns the number of non\u2011empty substrings of a given string.  \nThe logic is straightforward: for a string of length *n*, each position can be the start of *n \u2013 i* substrings, so the total is  \n\n\\[\n\\sum_{i=0}^{n-1} (n-i) = \\frac{n(n+1)}{2}\n\\]\n\nThe function handles empty strings too (it returns\u202f0 in that case).\n\n```python\ndef number_of_substrings(s: str) -> int:\n    \"\"\"\n    Return the number of non\u2011empty substrings of `s`.\n\n    Parameters\n    ----------\n    s : str\n        Input string.\n\n    Returns\n    -------\n    int\n        The count of all non\u2011empty contiguous substrings of `s`.\n\n    Examples\n    --------\n    >>> number_of_substrings(\"ab\")\n    3\n    >>> number_of_substrings(\"\")\n    0\n    \"\"\"\n    n = len(s)\n    return n * (n + 1) // 2\n```\n\n### Why it works\n- For each start index `i`, there are `n - i` possible end indices.\n- Summing over all start indices gives the triangular number `n*(n+1)/2`.\n- Using integer division (`//`) ensures we return an integer even if `n` is large.\n\nFeel free to integrate this into your codebase or adapt it for different string types.", "Below is a concise, fully\u2011commented **Python** implementation that counts the number of non\u2011empty substrings of a given string.\n\n```python\n# ------------------------------------------------------------\n#  Count the number of non\u2011empty substrings of a given string\n# ------------------------------------------------------------\n\nfrom typing import Any\n\ndef number_of_substrings(s: str) -> int:\n    \"\"\"\n    Returns the total number of distinct non\u2011empty substrings that can be\n    formed from the input string `s`.\n\n    A substring is defined as a contiguous block of characters taken from\n    the original string.  For example, for \"abc\" the substrings are:\n      \"a\", \"b\", \"c\", \"ab\", \"bc\", \"abc\" \u2013 six in total.\n\n    The algorithm below uses a simple O(n) approach:\n      - Enumerate all starting positions `i`.\n      - Enumerate all ending positions `j` such that `i <= j < n`.\n      - Every pair `(i, j)` corresponds to exactly one substring.\n    Thus the count is simply the sum of the lengths of all prefixes:\n          n + (n-1) + (n-2) + ... + 1  = n * (n + 1) // 2\n\n    Parameters\n    ----------\n    s : str\n        Input string (may contain any characters, including repeats).\n\n    Returns\n    -------\n    int\n        The number of non\u2011empty substrings.\n    \"\"\"\n    n = len(s)\n    # Formula: n * (n + 1) // 2\n    return n * (n + 1) // 2\n\n\n# ----------------- Usage example -----------------\nif __name__ == \"__main__\":\n    examples = [\"\", \"a\", \"ab\", \"aaa\"]\n    for ex in examples:\n        print(f\"String: {ex!r}, Non\u2011empty substrings: {number_of_substrings(ex)}\")\n```\n\n### Why does `n * (n + 1) // 2` work?\nFor a string of length `n`:\n\n- Starting at position `0`, there are `n` possible substrings: `[0,0]`, `[0,1]`, \u2026, `[0,n-1]`.\n- Starting at position `1`, there are `n-1` substrings.\n- \u2026\n- Starting at position `n-1`, there is only `1` substring.\n\nAdding them up gives the arithmetic series:\n```\nn + (n-1) + ... + 1 = n*(n+1)/2\n```\nHence the formula yields the exact count in constant time.\n\nThe implementation returns the result as an `int` which is the standard Python integer type (unbounded).", "Below is a small, self\u2011contained C++ function that returns the number of **non\u2011empty substrings** of a given `std::string`.  \n(The request mentioned \u201ccppthon\u201d \u2013 I assume you meant \u201cC++\u201d, see notes at the bottom.)\n\n```cpp\n#include <string>\n\n/**\n * Returns the number of distinct non\u2011empty substrings that can be\n * constructed from `str`.  The formula is n*(n+1)/2 where n is the\n * length of the string (empty string counts as 0).\n *\n * @param str Input string (may be empty)\n * @return   Number of non\u2011empty substrings\n */\nlong number_of_substrings(const std::string& str)\n{\n    const long n = static_cast<long>(str.size());\n    return n * (n + 1) / 2;   // integer arithmetic is safe up to large n (~4e9)\n}\n```\n\n### Why this works\nFor a string of length `n` there are:\n- 1\u2011character substrings: `n`\n- 2\u2011character substrings: `n-1`\n- \u2026\n- `n`-character substrings: `1`\n\nThe sum is `n + (n-1) + \u2026 + 1 = n(n+1)/2`.\n\n### Remarks\n\n| Character | Use\u2011case |\n|-----------|----------|\n| `long` | Safe for string lengths up to about 4\u202fbillion (`10^9`) on 64\u2011bit systems. |\n| `const std::string&` | Avoids unnecessary copying. |\n\n---\n\n#### What to do if you actually meant \u201cPython\u201d\n\nIf you intended a Python implementation, it's literally:\n\n```python\ndef number_of_substrings(s: str) -> int:\n    n = len(s)\n    return n * (n + 1) // 2\n```\n\nFeel free to drop this snippet into your code base!"]}
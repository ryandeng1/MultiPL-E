{"completions": ["```cpp\n#include <vector>\n#include <algorithm>\n\n// Return the minimum sum of any non\u2011empty sub\u2011array of *nums*.\n//   \u2022  A single element sub\u2011array is allowed.\n//   \u2022  *nums* will contain at least one element.\n//\n// The algorithm runs in O(n) time and O(1) additional space\n// (Kadane\u2019s algorithm adapted for the minimum sum).\nlong minSubArraySum(const std::vector<long>& nums)\n{\n    // Guard against an empty input \u2013 we expect at least one element,\n    // but in case the function is called incorrectly we can throw\n    // an exception or return 0. Here we just return 0.\n    if (nums.empty())\n        return 0;\n\n    long current_min = nums[0];\n    long global_min = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        // Extend previous sub\u2011array or start a new one at i\n        current_min = std::min(nums[i], current_min + nums[i]);\n\n        // Update global minimum\n        global_min = std::min(global_min, current_min);\n    }\n\n    return global_min;\n}\n```\n\n**Explanation**\n\n* `current_min` holds the minimum sum of a sub\u2011array that ends at the current position.\n* For each element `nums[i]`, the best sub\u2011array ending at `i` is either:\n  * a sub\u2011array that ends at `i\u20111` and we extend it (`current_min + nums[i]`), or\n  * a new sub\u2011array that starts at `i` itself (`nums[i]`).\n  We pick the smaller of these two options.\n* `global_min` keeps the smallest value seen so far.\n\nThe algorithm works for positive, negative, and mixed values and matches the examples:\n\n```cpp\nminSubArraySum({2, 3, 4, 1, 2, 4}) // -> 1\nminSubArraySum({-1, -2, -3})      // -> -6\n```", "Below is a small, self\u2011contained implementation of the \u201cminimum sub\u2011array sum\u201d problem.  \nThe routine follows the classic *Kadane* pattern but inverted \u2013 we keep track of the smallest possible sum ending at each position and propagate it forward.  \nThe algorithm runs in **O(n)** time and **O(1)** extra space.\n\n```cpp\n#include <vector>\n#include <limits>\n#include <algorithm>\n\n/**\n * @brief   Return the minimum sum of any non\u2011empty sub\u2011vector of `nums`.\n *\n *          The function implements the \u201cmin\u2011Kadane\u201d algorithm: for each new\n *          element we decide whether extending the previous sub\u2011array\n *          results in a smaller sum or starting a new sub\u2011array is better.\n *\n * @param   nums   Vector of integers (may be empty \u2013 in that case the function\n *                 throws std::invalid_argument).\n *\n * @return  The smallest possible sum of a contiguous sub\u2011vector of `nums`.\n *\n * @throws  std::invalid_argument  if `nums` is empty.\n */\nlong minSubArraySum(const std::vector<long>& nums)\n{\n    if (nums.empty()) {\n        throw std::invalid_argument(\"Input vector must contain at least one element.\");\n    }\n\n    long best = std::numeric_limits<long>::max(); // best (i.e., minimum) sum seen so far\n    long cur  = 0;                                // sum of the current sub\u2011array\n\n    for (long x : nums) {\n        // In the classic Kadane for maximum sum we would do\n        // cur = max(x, cur + x);\n        // Here we want the minimum, so we use min instead.\n        cur = std::min(x, cur + x);\n\n        // Update the global best\n        best = std::min(best, cur);\n    }\n    return best;\n}\n```\n\n### How it works\n1. **`cur`** keeps the smallest sum of a sub\u2011array that ends at the current element.\n2. For each element `x` we decide:\n   * either start a new sub\u2011array at `x` (`x` alone),\n   * or extend the previous sub\u2011array (`cur + x`).\n   Whichever is smaller becomes the new `cur`.\n3. **`best`** records the minimum value that `cur` has ever taken \u2013 that is the answer.\n\n### Example runs\n```cpp\nstd::vector<long> v1 = {2, 3, 4, 1, 2, 4};\nstd::cout << minSubArraySum(v1) << '\\n';   // prints 1\n\nstd::vector<long> v2 = {-1, -2, -3};\nstd::cout << minSubArraySum(v2) << '\\n';   // prints -6\n```\n\nThe implementation is fully portable, uses only standard C++ headers, and handles all corner cases (including all-positive or all-negative arrays).", "Here is a complete implementation of `minSubArraySum` that returns the minimum possible sum of any non\u2011empty sub\u2011vector of `nums`.  \nThe algorithm is the classic \u201cminimum subarray sum\u201d version of Kadane\u2019s algorithm \u2013 it runs in O(n) time and uses O(1) extra memory.\n\n```cpp\n#include <vector>\n#include <algorithm>   // for std::min\n#include <limits>      // for std::numeric_limits\n\n// -----------------------------------------------------------------\n// Returns the minimum sum of any non\u2011empty contiguous sub\u2011vector\n// of `nums`.  If all numbers are positive the answer is the\n// smallest element; if there are negative numbers it may be\n// the sum of several of them.\n//\n// Complexity:  O(n) time, O(1) additional memory\n// -----------------------------------------------------------------\nlong minSubArraySum(const std::vector<long>& nums) {\n    // Guard against empty input (should never happen per problem statement)\n    if (nums.empty())\n        throw std::invalid_argument(\"input vector must be non\u2011empty\");\n\n    long min_ending_here = nums[0];   // min sum of subarray ending at current index\n    long min_so_far      = nums[0];   // best (i.e. smallest) sum seen so far\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        // Extend the previous subarray or start a new one at i.\n        min_ending_here = std::min(nums[i], min_ending_here + nums[i]);\n\n        // Update global best\n        min_so_far = std::min(min_so_far, min_ending_here);\n    }\n\n    return min_so_far;\n}\n```\n\n### How it works\n\n* `min_ending_here` keeps track of the minimum sum of a sub\u2011array that **ends** at the current position `i`.  \n  At each step we decide whether it is better to extend the previous sub\u2011array (`min_ending_here + nums[i]`) or start a new sub\u2011array at `i` (`nums[i]` itself).\n\n* `min_so_far` remembers the minimal sum encountered so far. It is updated each iteration with the current `min_ending_here`.\n\n### Example runs\n\n```cpp\nstd::vector<long> v1 = {2, 3, 4, 1, 2, 4};\nstd::cout << minSubArraySum(v1) << '\\n';   // prints 1\n\nstd::vector<long> v2 = {-1, -2, -3};\nstd::cout << minSubArraySum(v2) << '\\n';   // prints -6\n```\n\nThis matches the examples given in your prompt."]}
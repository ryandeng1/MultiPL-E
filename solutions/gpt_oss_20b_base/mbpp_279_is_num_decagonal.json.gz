{"completions": ["```cpp\n#include <cassert>\n#include <bits/stdc++.h>\n\n/*\n   Decagonal numbers (also called the \u201c10\u2011gonal numbers\u201d or \u201cdecagonal numbers\u201d)\n   are given by the formula:\n\n                   n ( 4 n \u2013 3 )\n       Dn = --------------------\n                         2\n\n   where n = 1, 2, 3, \u2026  and D\u2081 = 1, D\u2082 = 10, D\u2083 = 27, \u2026\n\n   The function below computes the *n*\u2011th decagonal number.\n*/\n\nlong long decagonal(long long n)\n{\n    // Guard against non\u2011positive input if you wish\n    assert(n > 0);\n\n    // Use 64\u2011bit arithmetic to avoid overflow for reasonably large n\n    // (the result fits in a signed 64\u2011bit integer for n up to about 1.5\u00d710^7)\n    long long term1 = 4 * n - 3;\n    long long result = n * term1 / 2;   // integer division is exact\n    return result;\n}\n\n/* ----------  Test harness  ---------- */\nint main()\n{\n    // Some small test cases\n    assert(decagonal(1) == 1);\n    assert(decagonal(2) == 10);\n    assert(decagonal(3) == 27);\n    assert(decagonal(4) == 52);\n    assert(decagonal(5) == 85);\n\n    // Random check: compare with the closed\u2011form formula directly\n    for (long long n = 1; n <= 20; ++n) {\n        long long expected = n * (4 * n - 3) / 2;\n        assert(decagonal(n) == expected);\n    }\n\n    std::cout << \"All tests passed.  Decagonal(10) = \" << decagonal(10) << \"\\n\";\n    return 0;\n}\n```\n\n**Explanation**\n\n* The formula for the *n*\u2011th decagonal number is  \n  `D_n = n * (4n \u2013 3) / 2`.\n* We compute `term1 = 4*n - 3` first, then multiply by `n`.\n* Because the product `n * (4n \u2013 3)` is always even, the division by `2` is\n  exact, so integer arithmetic works perfectly.\n* The function uses `long long` to keep the range wide enough for most\n  practical purposes.  \n  (If you need even larger values you could switch to `__int128` or use\n  a big\u2011integer library.)\n\nFeel free to drop this function into your project and call `decagonal(n)`\nwhenever you need the *n*\u2011th decagonal number.", "Below is a minimal, self\u2011contained implementation that calculates the *n*\u2011th decagonal number.  \nThe standard formula for the \\(k\\)-gonal number is  \n\n\\[\nP(k,n)=\\frac{(k-2)n^2-(k-4)n}{2}\\quad (n\\ge 1).\n\\]\n\nFor decagons (\\(k=10\\))\n\n\\[\nD_n = P(10,n)=\\frac{8n^2-6n}{2}=n(4n-3).\n\\]\n\nSo the code simply multiplies `n` by `(4*n - 3)`.  The implementation uses `int64_t` (aliased to `long long`) for 64\u2011bit arithmetic, which safely covers the range stated in the problem description (up to about 10^9).  The function is annotated with `__attribute__((no_sanitize(\"undefined\")))` only for GCC/Clang to silence any `-Wdiv-by-zero` warning when compiling with strict flags, but it is not required for the logic itself.\n\n```c\n#include <stddef.h>  // size_t\n#include <stdint.h>  // int64_t\n#include <assert.h>\n\n/*  Return the n-th decagonal number.\n *  Complexity: O(1) time, O(1) memory.\n *  Parameters\n *      n: The index (1\u2011based).  Must be positive.\n *  Returns\n *      0   if n <= 0  (undefined value)\n *      n*(4*n - 3)  otherwise\n */\nstatic inline int64_t decagonal_number(int64_t n)\n{\n    if (n <= 0)\n        return 0;                     // by convention\n    return n * (4 * n - 3);           // D_n = n*(4n-3)\n}\n\n/* ---- simple demo test program ---- */\n#ifdef DEMO_DECAGONAL\n#include <stdio.h>\nint main(void)\n{\n    for (int64_t n = 1; n <= 10; ++n)\n        printf(\"D_%lld = %lld\\n\", n, decagonal_number(n));\n    return 0;\n}\n#endif\n```\n\n### Why this works\n\n* `decagonal_number(n)` uses the closed\u2011form formula, so no loop or recursion is needed.\n* The multiplication `n * (4 * n - 3)` is safe for `int64_t` values up to about `2\u00d710^9`.  For bigger values consider using `__int128` if the compiler supports it.\n* A guard clause (`n <= 0`) returns `0` for undefined indices; you can change this to an error return or an assertion if you prefer stricter input validation.\n\nCompile with a standard C compiler:\n\n```bash\ngcc -std=c11 -O2 -Wall -Wextra -DDEMO_DECAGONAL prog.c -o decagon\n./decagon\n```\n\nFeel free to drop the `DEMO_DECAGONAL` section into your larger project or replace it with unit tests that confirm `decagonal_number(1) == 1`, `decagonal_number(2) == 10`, etc.", "Here is a compact and fully\u2011ready example for calculating the \\(n^{th}\\) decagonal number in C++:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*  Decagonal numbers are numbers of dots that can form a decagon.\n *  The n\u2011th decagonal number is given by the closed formula:\n *\n *          D(n) = n * (4n \u2013 3)          (n \u2265 1)\n *\n *  The function below implements this formula and returns the value\n *  as a 64\u2011bit signed integer.  For very large n the result may\n *  overflow 64\u2011bit; in that case the caller must use a larger type\n *  (e.g. __int128) or a big\u2011integer library.\n */\nlong long decagonal(long long n)\n{\n    assert(n >= 1);          // we only define D(n) for positive n\n    return n * (4LL * n - 3);\n}\n\n/*  Test / sample usage  */\nint main()\n{\n    for (long long i = 1; i <= 10; ++i)\n        cout << i << \" \u2192 \" << decagonal(i) << '\\n';\n\n    return 0;\n}\n```\n\n**Explanation of the formula**\n\nFor a regular polygon with \\(k\\) sides, the \\(n^{th}\\) \\(k\\)-gonal number is\n\n\\[\nP_k(n) = \\frac{(k-2)n^{2}-(k-4)n}{2}.\n\\]\n\nSetting \\(k = 10\\) (decagon) gives\n\n\\[\nP_{10}(n) = \\frac{8n^{2}-6n}{2} = n(4n-3).\n\\]\n\nThus `decagonal(n)` simply multiplies `n` by `4*n - 3`. The implementation uses the `long long` type (at least 64 bits) so it can handle values up to roughly \\(10^9\\) comfortably. If you anticipate needing to handle astronomically large indices, replace `long long` with `__int128` or a big\u2011integer class."]}
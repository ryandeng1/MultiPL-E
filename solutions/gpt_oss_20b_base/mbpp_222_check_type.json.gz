{"completions": ["**Solution explanation**\n\n`std::tuple` can hold values of different types \u2013 that is one of the reasons it exists.  \nIf we want to confirm that *every* element inside a given tuple has the\nexact same type, we have to\n\n1. Step through the tuple\u2019s elements (this must be done at compile\u2011time,\n   because the tuple\u2019s element count and types are known at compile time).\n2. Extract each element\u2019s type (`std::tuple_element_t<I,T>`).\n3. Compare that type to the first element\u2019s type.\n\nAll of this can be achieved with a small bit of template metaprogramming.\nWe\u2019ll write a helper that recursively checks the tuple elements, and the\n`check_type` function simply forwards the call to that helper.\n\nBelow is the self\u2011contained code, followed by a few tests.\n\n\n\n```cpp\n#include <tuple>\n#include <type_traits>\n#include <any>\n#include <iostream>\n#include <cassert>\n\n/* ------------------------------------------------------------------ */\n/*  Helper: recursively walk a tuple from index I to I+1                */\n/* ------------------------------------------------------------------ */\ntemplate<std::size_t I, std::size_t N, typename Tuple>\nconstexpr bool tuple_all_same_impl(const Tuple& /*tup*/)\n{\n    if constexpr (I == N - 1)   // last element \u2013 only one element left\n        return true;            // nothing to compare with\n    else\n    {\n        using FirstType  = std::tuple_element_t<I,  Tuple>;\n        using NextType   = std::tuple_element_t<I+1, Tuple>;\n        // compare the current element type with the next one\n        if constexpr (!std::is_same_v<FirstType, NextType>)\n            return false;\n        else\n            return tuple_all_same_impl<I+1, N, Tuple>();\n    }\n}\n\n/* ------------------------------------------------------------------ */\n/*  Public helper that deduces the tuple size and calls the impl.     */\n/* ------------------------------------------------------------------ */\ntemplate<typename Tuple>\nconstexpr bool tuple_all_same(const Tuple&)\n{\n    constexpr std::size_t N = std::tuple_size_v<std::remove_cvref_t<Tuple>>;\n    if constexpr (N <= 1)    // empty or single element tuple \u2013 trivially same\n        return true;\n    else\n        return tuple_all_same_impl<0, N>(Tuple{});\n}\n\n/* ------------------------------------------------------------------ */\n/*  Public API as requested \u2013 takes the tuple as std::any            */\n/* ------------------------------------------------------------------ */\nbool check_type(std::any test_tuple)\n{\n    if (!test_tuple.has_value()) return false;          // empty std::any\n    // We shall only allow a std::tuple inside \u2013 otherwise return false\n    if (!test_tuple.type().name())                      // sanity check\n        return false;\n\n    // Try to cast to a tuple of unknown type via a helper\n    struct Helper\n    {\n        template<typename T>\n        static constexpr bool call(T const& t)\n        {\n            return tuple_all_same(t);\n        }\n    };\n\n    // Attempt to cast to any tuple type that could be stored in the any\n    // Since std::any can hold *any* type, we use type erasure to detect whether\n    // the stored type is a std::tuple.\n    bool result = false;\n    // We cannot generic cast std::any to an arbitrary tuple type,\n    // but we can leverage the fact that `std::any_cast` with a\n    // container type will throw std::bad_any_cast if the types differ.\n    // So we iterate over a set of possible tuple types \u2013 but\n    // that would be infinite. Instead we use a trick: \n    // `std::any_cast` can be used to get a pointer to the stored value\n    // and then we can use `std::apply` for a constexpr generic function.\n    // This is a bit involved \u2013 the simplest robust approach is:\n    // attempt to deduce the stored type via a templated lambda.\n    result = std::any_cast_helper(test_tuple, Helper{});\n\n    return result;\n}\n\n/* ------------------------------------------------------------------ */\n/*  any_cast_helper \u2013 deduces the stored type inside std::any and calls\n    the helper if it is a tuple.                                          */\n/* ------------------------------------------------------------------ */\ntemplate <typename Any, typename F>\nbool any_cast_helper(const Any& a, F&& f)\n{\n    // Try if the stored type is a tuple \u2013 we can attempt an any_cast<tuple<...>>\n    // but we don't know the arity or types. So we first try to obtain a\n    // pointer to the stored value via any_cast<>::type<>&.\n    // But C++17 std::any does not provide a direct means to introspect\n    // arbitrary types. Therefore, we rely on the fact that we only care\n    // about tuples that compile with our helper. We can attempt a try-catch:\n    try {\n        // Base pointer to the any value\n        const void* ptr = a.data();\n        if (!ptr) return false;\n\n        // Use a templated function that attempts to cast to *any* type\n        // and, if successful, uses the helper. Since we cannot know the type,\n        // we make use of a helper that uses SFINAE on the template parameter:\n        struct Tester {\n            template<typename T>\n            static constexpr bool test(const T& t)\n            {\n                return tuple_all_same(t);\n            }\n\n            template<typename T>\n            static constexpr bool test(...) { return false; }\n        };\n        // If the stored type is some T, `test<T>(T)` will be chosen,\n        // otherwise the fallback will be chosen.\n        // We can attempt a dynamic cast? No. Instead we use a trick:\n        // we cannot invoke the type erasure here. So for simplicity,\n        // our `check_type` will only handle a tuple stored via a\n        // specific known type.  In real code you would overload or\n        // provide a wrapper that guarantees the type.\n        return false; // placeholder\n    } catch (...) { return false; }\n}\n\n```\n\n### A simpler approach\n\nBecause the \u201c`std::any` is opaque\u201d problem is a bit messy, a cleaner design\nis:\n\n```cpp\ntemplate<typename T> requires std::is_same_v<T, std::tuple<std::decay_t<T>>>\nbool check_type(T const& tup) {\n    return tuple_all_same(tup);\n}\n```\n\nNow the caller must pass a tuple directly, not an opaque `std::any`.\n\n### Testing\n\n```cpp\nint main()\n{\n    std::tuple<int,int,int> t1{1,2,3};\n    std::tuple<int,double,int> t2{1,2.0,3};\n    std::tuple<> t3;\n    std::tuple<int> t4{5};\n\n    static_assert(tuple_all_same(t1), \"t1 should be all same\");\n    static_assert(!tuple_all_same(t2), \"t2 should differ\");\n    static_assert(tuple_all_same(t3), \"empty tuple trivially same\");\n    static_assert(tuple_all_same(t4), \"single element same\");\n\n    std::cout << (tuple_all_same(t1) ? \"t1 all same\\n\" : \"t1 differs\\n\");\n    std::cout << (tuple_all_same(t2) ? \"t2 all same\\n\" : \"t2 differs\\n\");\n}\n```\n\nThe output will be:\n\n```\nt1 all same\nt2 differs\n```\n\nThis demonstrates how to determine whether every element in a tuple\nshares the same data type.", "Below is a **complete, self\u2011contained example** that demonstrates how to write a function template `all_same_type` that accepts an arbitrary `std::tuple` and tells you whether **every element inside the tuple has the same type**.  \nIt uses only the C++ standard library (no `bits/stdc++.h`) and works with any tuple size.\n\n```cpp\n#include <tuple>\n#include <type_traits>\n#include <iostream>\n#include <cassert>\n\n/* --------------------------------------------------------------\n   Helper: compile\u2011time folding expression that checks that all\n   types in a parameter pack are identical to T.\n   -------------------------------------------------------------- */\ntemplate<typename T, typename... Rest>\nconstexpr bool all_same_impl()\n{\n    if constexpr (sizeof...(Rest) == 0) {\n        return true;                     // only one element \u2192 trivially equal\n    } else {\n        return ((std::is_same_v<T, Rest>) && ...) ;   // fold expression\n    }\n}\n\n/* --------------------------------------------------------------\n   Main function template to test a std::tuple.\n   -------------------------------------------------------------- */\ntemplate <typename... Ts>\nconstexpr bool all_same_type(const std::tuple<Ts...>&)\n{\n    // Special case: empty tuple \u2013 we consider it *true* (nothing to compare)\n    if constexpr (sizeof...(Ts) == 0) {\n        return true;\n    } else {\n        // first element type\n        using FirstType = std::tuple_element_t<0, std::tuple<Ts...>>;\n        // check that every other element is the same as FirstType\n        return all_same_impl<FirstType, Ts...>();\n    }\n}\n\n/* --------------------------------------------------------------\n   Simple runtime tester\n   -------------------------------------------------------------- */\nint main()\n{\n    // Same type \u2013 true\n    std::tuple<int, int, int> t1{1, 2, 3};\n    static_assert(all_same_type(t1));\n    std::cout << std::boolalpha << all_same_type(t1) << '\\n';\n\n    // Mixed types \u2013 false\n    std::tuple<int, double, int> t2{1, 2.5, 3};\n    static_assert(!all_same_type(t2));\n    std::cout << std::boolalpha << all_same_type(t2) << '\\n';\n\n    // Empty tuple \u2013 true\n    std::tuple<> t3{};\n    static_assert(all_same_type(t3));\n    std::cout << std::boolalpha << all_same_type(t3) << '\\n';\n\n    return 0;\n}\n```\n\n### How it works\n\n1. **`all_same_impl`**  \n   *A tiny helper that, given a leading type `T` and the rest of the types (`Rest...`), returns `true` if every type in `Rest...` is the same as `T`.  \n   The `fold expression` *(\u2026) &** is evaluated at compile\u2011time.*\n\n2. **`all_same_type`**  \n   *Accepts any `std::tuple`.  \n   *If the tuple is empty, it trivially returns `true`.  \n   *Otherwise, it extracts the first element type (`FirstType`) and delegates to `all_same_impl` to compare the rest.*\n\n3. **Testing**  \n   *The `static_assert`s perform a compile\u2011time check, and the `std::cout` prints the same result at runtime.*\n\nFeel free to drop this snippet into your project; it is header\u2011only, requires only C++17 (fold expressions), and is entirely type\u2011safe. Happy coding!", "Below is a self\u2011contained, header\u2011only implementation that works for **any** `std::tuple` (or `std::pair`, `std::array`, \u2026).  \nThe core idea is to *unpack* the tuple at compile time and compare the\n`std::type_index` of every element with the first one.  \nIf all of them match the function returns `true`, otherwise `false`.\n\n```cpp\n#include <iostream>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n\n/* ------------------------------------------------------------------ */\n/*  predicate that checks if all types in a tuple are identical        */\n/* ------------------------------------------------------------------ */\n\ntemplate <typename Tuple, std::size_t... I>\nconstexpr bool all_same_impl(const std::type_index& first,\n                             std::index_sequence<I...>) noexcept\n{\n    // the comma operator is evaluated left\u2011to\u2011right.  The result of the first\n    // expression is discarded; we only care about the logical AND chain.\n    // Because the compiler knows I is sequence 0,1,\u2026, we can be sure that\n    // (I == 0) ? true : (first == typeid(std::tuple_element_t<I, Tuple>))\n    return (... && (   I == 0\n                    ? true\n                    : first\n                        == typeid(std::tuple_element_t<I, Tuple>)));\n}\n\ntemplate <typename Tuple>\nconstexpr bool all_same() noexcept\n{\n    // empty tuple \u2013 by convention we consider it \u201call same\u201d\n    if constexpr (std::tuple_size_v<Tuple> == 0)\n        return true;\n\n    constexpr std::size_t N = std::tuple_size_v<Tuple>;\n    // Build the type_index of the first element.\n    // This is a compile\u2011time constant expression because typeid() of a\n    // type (not of a value) is constexpr from C++17 onward.\n    constexpr std::type_index first{typeid(std::tuple_element_t<0, Tuple>)};\n\n    return all_same_impl<Tuple>(first,\n                                std::make_index_sequence<N>{});\n}\n\n/* ------------------------------------------------------------------ */\n/*  helper to print the result \u2013 only for demonstration                */\n/* ------------------------------------------------------------------ */\n\ntemplate <typename... Ts>\nvoid demo(const std::tuple<Ts...>& t)\n{\n    std::cout << \"tuple is \" << (all_same<std::tuple<Ts...>>() ? \"homogeneous\"\n                                                          : \"heterogeneous\")\n              << '\\n';\n}\n\n/* ------------------------------------------------------------------ */\n/*  Test cases                                                     */\n/* ------------------------------------------------------------------ */\nint main()\n{\n    demo(std::make_tuple(1, 2, 3));                       // homogeneous\n    demo(std::make_tuple(1.0, 2, 3));                     // heterogeneous\n    demo(std::make_tuple());                              // empty \u2013 homogeneous\n    demo(std::make_tuple(std::string(\"Hi\"), std::string(\"Bye\"))); // homogeneous\n    demo(std::make_tuple(1, std::string(\"Hi\")));         // heterogeneous\n}\n```\n\n### How it works\n\n| Step | Explanation |\n|------|-------------|\n| **`template <typename Tuple>`** | The function is a *function template* so it can be instantiated for *any* tuple type. |\n| **`constexpr std::size_t N = std::tuple_size_v<Tuple>`** | Determines how many elements are in the tuple (zero\u2011based). |\n| **`constexpr std::type_index first{typeid(std::tuple_element_t<0, Tuple>)}`** | Captures the RTTI of the *first* element\u2019s type. |\n| **`... && (I == 0 ? true : first == typeid(...))`** | For every index `I` in `0 \u2026 N\u20111` we compare its type to the first one.  \n`I == 0` is special\u2011cased because the first element is obviously the same as itself. |\n| **Compile\u2011time evaluation** | All `typeid` on types (not objects) are `constexpr` since C++17, so the whole result is known at compile time. |\n\n### Why `std::any` was not suitable\n\n`std::any` holds a value *and* its runtime type information.  \nWhen you write a function like `bool check_type(std::any test_tuple)` you\nlose all information about the element types that the tuple contained \u2013  \nyou only see the `std::any` objects themselves.  \nTherefore the only reliable way to check the homogeneity of a tuple is\nto examine its *compile\u2011time* type list, exactly what the code above does."]}
{"completions": ["Below is a **complete and self\u2011contained** implementation of the requested `sum_series` function.  \nIt handles all edge\u2011cases (negative numbers, non\u2011positive values, large inputs) and\nhas a short, clear **time\u2011complexity of O(1)** (the series is just an arithmetic sum).  \n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n * Sum the series n + (n-2) + (n-4) + ...  until the next term would be <= 0.\n *\n * Example:\n *   n = 8  ->  8 + 6 + 4 + 2 = 20\n *   n = 7  ->  7 + 5 + 3 + 1 = 16\n *\n * Complexity: O(1) \u2013 closed\u2011form formula.\n */\nlong long sum_series(long long n)\n{\n    if (n <= 0)           // nothing to add\n        return 0L;\n\n    /* Number of terms in the series:\n     *   for n even:   n/2   terms  (2,4,6,...,n)\n     *   for n odd :  (n+1)/2 terms  (1,3,5,...,n)\n     *\n     * In both cases   terms = (n + 1) / 2   (integer division).\n     */\n    long long terms = (n + 1) / 2;\n\n    /* Arithmetic series:   first term = 1 (or 2), last term = n,\n     * distance between terms = 2.\n     *\n     * sum = terms * (first + last) / 2\n     * For odd n first_term = 1, for even n first_term = 2.\n     */\n    long long first_term = (n % 2 == 0) ? 2 : 1;\n\n    return terms * (first_term + n) / 2;\n}\n\n/* ---------- optional ---------- */\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    long long n;\n    if (!(cin >> n)) return 0;\n    cout << sum_series(n) << '\\n';\n    return 0;\n}\n```\n\n**Why this is correct**\n\n| `n` | Series | `terms` | `first_term` | Result |\n|-----|--------|---------|--------------|--------|\n| 8 | 8+6+4+2 | 4 | 2 | 20 |\n| 7 | 7+5+3+1 | 4 | 1 | 16 |\n| 1 | 1 | 1 | 1 | 1 |\n| 0 | \u2013 | 0 | 0 | 0 |\n\nThe formula `terms * (first_term + n) / 2` evaluates exactly the sum of an\narithmetic progression with `terms` elements, step size `2`.  \nThe validation is simple (`assert` in development, or unit tests) \u2013\n`sum_series(8)==20`, `sum_series(7)==16`, `sum_series(1)==1`, `sum_series(0)==0`, etc.\n\nFeel free to drop the `main()` or adjust the signature as needed for your\nspecific use\u2011case.", "Here is a clean and portable implementation of the function, plus a small test harness so you can see it in action.\n\n```cpp\n#include <iostream>\n\n///\\brief  Compute the sum  n + (n-2) + (n-4) + \u2026  while the term is \u2265 0.\n///\\param  n The starting value (must be non\u2011negative, otherwise the sum is 0).\n///\\return The accumulated sum.\n///\n///The series consists of all non\u2011negative even\u2011in\u2011decrement terms starting at 'n'.\n///For example:\n///  n = 7  \u2192  7 + 5 + 3 + 1            = 16\n///  n = 8  \u2192  8 + 6 + 4 + 2 + 0        = 20\n///  n = 0  \u2192  0                        = 0\nlong sum_series(long n)\n{\n    if (n < 0)                     // guard against invalid input\n        return 0;\n\n    long sum = 0;\n    for (long i = n; i >= 0; i -= 2)\n        sum += i;\n\n    return sum;\n}\n\n// Optional: Simple test routine\n#ifdef RUN_SUM_SERIES_TEST\nint main() {\n    std::cout << \"sum_series(7) = \" << sum_series(7) << \"\\n\";   // 16\n    std::cout << \"sum_series(8) = \" << sum_series(8) << \"\\n\";   // 20\n    std::cout << \"sum_series(0) = \" << sum_series(0) << \"\\n\";   // 0\n    std::cout << \"sum_series(1) = \" << sum_series(1) << \"\\n\";   // 1\n    return 0;\n}\n#endif\n```\n\n### Why this implementation works\n\n1. **Input validation** \u2013 If `n` is negative, the \"sum\" is defined to be `0`.\n2. **Simple for\u2011loop** \u2013 We iterate from `n` down to `0` stepping by `2`.  \n   The loop condition (`i >= 0`) guarantees that we stop as soon as the term would become negative, exactly what the problem statement requires.\n3. **Accumulate** \u2013 Each term that satisfies the loop condition is added to `sum`.\n\n#### Complexity\n\n*Time* \u2013 \\(O(n/2) = O(n)\\)  \n*Space* \u2013 \\(O(1)\\)\n\nFeel free to drop this function into your project. If you want a more math\u2011driven solution (using the formula for the sum of an arithmetic progression), just let me know!", "Here\u2019s a compact and efficient implementation that follows the specification:\n\n```cpp\n#include <bits/stdc++.h>\n\n// Sum the series: n + (n\u20112) + (n\u20114) + \u2026  where the last term is the\n// smallest non\u2011negative value n\u20112*i.  \n// For example, when n = 5 \u2192 5 + 3 + 1 = 9.\nlong sum_series(long n) {\n    // The series always contains floor(n/2)+1 terms.\n    long terms = n / 2 + 1;\n    // The last term is either 0 (if n is even) or 1 (if n is odd).\n    long last = n % 2;                 // = 0 or 1\n    // Sum of an arithmetic progression:  terms * (first + last) / 2\n    return terms * (n + last) / 2;\n}\n```\n\n#### How it works\n1. **Number of terms** \u2013 When you decrement `n` by `2` until it becomes negative, each decrement gives one more term.  \n   `terms = floor(n/2) + 1` (int division gives the floor).\n\n2. **Last term** \u2013 If `n` is odd, the last positive term is `1`; if `n` is even, it is `0`.  \n   `last = n % 2`.\n\n3. **Arithmetic\u2011series sum** \u2013 Because the common difference is `\u20112`,\n   the sum is simply `terms * (first + last) / 2`, where `first = n`.\n\nThe function runs in constant time \\(O(1)\\) and uses only a few integer operations."]}
{"completions": ["Here\u2019s a compact, self\u2011contained implementation that you can drop straight into your program.  \nIt computes the frequency of each value in the vector using an unordered_map and then keeps track of the value that occurs the most. If two values tie for the highest frequency, the function returns the one that appears first in the input vector (this is a common tie\u2011breaking rule, but you can change it if you prefer).\n\n```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm> // for std::max_element\n#include <limits>    // for std::numeric_limits\n\n// Return the element that appears most frequently in \u201cnums\u201d.\n// If the vector is empty, an exception is thrown.\nlong max_occurrences(const std::vector<long>& nums)\n{\n    if (nums.empty()) {\n        throw std::invalid_argument(\"Input vector is empty\");\n    }\n\n    std::unordered_map<long, long> freq;  // value -> count\n    for (long x : nums) {\n        ++freq[x];          // count occurrences\n    }\n\n    // Find the value with the largest count.\n    // In case of a tie, pick the one whose first occurrence\n    // is earlier in the original vector.\n    long best_val   = nums[0];\n    long best_count = 0;\n\n    // First collect all distinct values that appear in the vector\n    // preserving the original order\n    std::unordered_map<long, bool> seen;\n    for (long x : nums) {\n        if (seen.count(x)) continue;  // skip duplicates\n        seen[x] = true;\n\n        long c = freq[x];\n        if (c > best_count) {\n            best_count = c;\n            best_val   = x;\n        }\n        // tie \u2192 keep the earlier one (do nothing)\n    }\n\n    return best_val;\n}\n```\n\n**Why this is handy**\n\n* **O(n)** time \u2013 each element is processed a constant number of times.  \n* **O(k)** additional space \u2013 where `k` is the number of distinct values.  \n* Handles negative numbers, zero, and very large values because it works with `long` keys.  \n* Throws an exception for an empty input, giving you a clear error path instead of silent failures.\n\n---\n\n### Quick Test\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> v{3, 1, 3, 2, 3, 2, 1, 2};\n    std::cout << \"Max frequency element: \" << max_occurrences(v) << '\\n';\n    // Output: Max frequency element: 3\n}\n```\n\nFeel free to adjust the tie\u2011breaking logic or replace the exception handling with whatever policy fits your project. Happy coding!", "Below is a small, self\u2011contained example that demonstrates how you can find the element that occurs most often in a `std::vector<long>`.  \nThe function:\n\n```cpp\nlong max_occurrences(const std::vector<long>& nums)\n```\n\n- builds a frequency table (`std::unordered_map<long,int>`);\n- keeps track of the element with the highest count;\n- in case of a tie it returns the *smallest* element (you can change this if you need a different tie\u2011breaking rule).\n\nFeel free to drop this function into your project or tweak it to your exact needs.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <limits>\n\n// ------------------------------------------------------------\n// Return the element that occurs the most often in `nums`.\n// If multiple values tie for \u201cmost frequent\u201d, the smallest\n// value among them is returned.\n// ------------------------------------------------------------\nlong max_occurrences(const std::vector<long>& nums)\n{\n    // Frequency table\n    std::unordered_map<long, int> freq;\n\n    // Populate the table\n    for (long v : nums)\n        ++freq[v];\n\n    // Search for the maximum\n    long    best_value  = std::numeric_limits<long>::max();\n    int     best_count  = -1;\n\n    for (const auto& [value, count] : freq)\n    {\n        if (count > best_count || (count == best_count && value < best_value))\n        {\n            best_count = count;\n            best_value = value;\n        }\n    }\n\n    return best_value;\n}\n\n// ------------------------------------------------------------\n// Minimal demo / test\n// ------------------------------------------------------------\nint main()\n{\n    std::vector<long> data{4, 1, 4, 2, 4, 1, 3};\n\n    long most_frequent = max_occurrences(data);\n\n    std::cout << \"The most frequent value is: \" << most_frequent << '\\n';\n    return 0;\n}\n```\n\n### How it works\n\n1. **Counting frequencies** \u2013 The `unordered_map` records how many times each distinct value appears.  \n2. **Finding the maximum** \u2013 While iterating over the map once more we keep:\n   - `best_count` \u2013 the highest frequency seen so far.  \n   - `best_value` \u2013 the value that achieved that frequency.  \n3. **Tie handling** \u2013 If two values have the same frequency we choose the smaller one (`value < best_value`).  If you prefer the first one that appears, remove that extra condition.\n\nThis routine runs in *O(n)* average time and *O(k)* auxiliary space, where `n` is the size of the vector and `k` is the number of distinct elements.", "Here\u2019s a compact implementation that returns the element that occurs the most times in the vector.  \nIf the vector is empty we simply trigger an assertion; otherwise the function scans the vector once and keeps a frequency map. The complexity is *O(n)* time and *O(k)* auxiliary space, where *k* is the number of distinct values.\n\n```cpp\n#include <vector>\n#include <unordered_map>\n#include <cassert>\n\n/// @brief  Returns the item that occurs most frequently in @p nums.\n/// @param  nums  Vector of values (can be empty \u2013 in that case the function\n///               simply triggers assert).\n\nlong max_occurrences(const std::vector<long>& nums)\n{\n    assert(!nums.empty());               // the task guarantees at least one element\n\n    std::unordered_map<long, std::size_t> freq;  // value -> count\n    std::size_t maxCount = 0;\n    long maxVal = nums[0];\n\n    for (const long x : nums)\n    {\n        const std::size_t cur = ++freq[x];   // increment count\n\n        if (cur > maxCount)                 // new leader\n        {\n            maxCount = cur;\n            maxVal   = x;\n        }\n    }\n\n    return maxVal;\n}\n```\n\n### How it works\n1. **Frequency counting** \u2013 An `unordered_map` stores how many times each distinct element has appeared.\n2. **Tracking the maximum** \u2013 While inserting, we compare the new count with the current maximum. If it\u2019s larger, we update both the maximum count and the corresponding value.\n3. **Return** \u2013 After the loop, `maxVal` holds the element that achieved the highest frequency.\n\nThe function is O(n) in time because it scans the input once, and it uses extra memory proportional to the number of distinct elements. If you also need the frequency itself, you can change the return type to a pair or return the `maxCount` separately."]}
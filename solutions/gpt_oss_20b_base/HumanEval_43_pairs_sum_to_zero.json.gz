{"completions": ["Here\u2019s a clean implementation that follows the specification and passes all the doctests you gave:\n\n```cpp\n#include <vector>\n#include <unordered_set>\n\n/// @brief Return true if there exists a pair of distinct indices i \u2260 j\n///        such that l[i] + l[j] == 0.\n///\n/// The algorithm runs in O(n) time and uses O(n) extra space.\n///\nbool pairs_sum_to_zero(const std::vector<long>& l) {\n    std::unordered_set<long> seen;\n    for (const auto& num : l) {\n        if (seen.find(-num) != seen.end())\n            return true;\n        seen.insert(num);\n    }\n    return false;\n}\n```\n\n### Why this works\n- We iterate over each element `num` in the vector.\n- For every `num` we check whether its negation `-num` has already appeared in the vector (stored in the hash set `seen`).\n  - If it has, then the two numbers sum to zero, so we return `true`.\n  - Otherwise we simply add `num` to `seen`.\n- If we finish the loop without finding a counterpart, no pair sums to zero and we return `false`.\n\n### Complexity\n- **Time:** Each lookup and insertion in an unordered set is on average `O(1)`.  \n  With `n` elements the total is `O(n)`.\n- **Space:** The set may hold up to `n` distinct numbers, so `O(n)`.\n\n### Integration\nReplace the stub in your original file with the function body above.  \nIf you want to keep the exact calling signature (`std::vector<long> l`) you can simply take the parameter by const reference as shown. Otherwise drop the `const` if you prefer the original signature.\n\nNow all the doctests in your comment block will evaluate to the expected boolean values.", "Here is a concise and idiomatic implementation of `pairs_sum_to_zero` in C++.  \nIt uses an unordered set to store the values that we have already seen while scanning the vector.  \nFor each element `x` we check whether `-x` is already present in the set; if so, a pair that sums to zero exists.  \nThe use of an unordered set gives an average\u2011time complexity of **O(n)** and the space complexity is **O(n)**.\n\n```cpp\n#include <vector>\n#include <unordered_set>\n#include <cstddef>   // for std::size_t\n\n// Return true if there exist two distinct elements in `l` whose sum is zero.\nbool pairs_sum_to_zero(const std::vector<long> &l) {\n    // Empty vector or a single element can never produce a pair.\n    if (l.size() < 2) return false;\n\n    std::unordered_set<long> seen;\n    for (long x : l) {\n        if (seen.count(-x)) {          // -x already seen -> pair found\n            return true;\n        }\n        seen.insert(x);                // store current element for future checks\n    }\n    return false;                     // no pair found\n}\n```\n\n### How it works\n1. **Edge cases** \u2013 If the vector has fewer than two elements, return `false` immediately.\n2. **Loop** \u2013 Iterate through each element `x` in the vector.\n3. **Check** \u2013 If `-x` is already in the set `seen`, the pair `(x, -x)` sums to zero \u2192 return `true`.\n4. **Store** \u2013 Insert `x` into the set so it can be matched later.\n5. **Finish** \u2013 If the loop ends without finding a pair, return `false`.\n\n### Complexity\n- **Time:** `O(n)` on average (each hash table operation is O(1) on average).\n- **Space:** `O(n)` for the hash set.\n\nThis implementation satisfies all the examples provided in the prompt.", "Here\u2019s a concise and efficient implementation that follows the specification:\n\n```cpp\n#include <unordered_set>\n#include <vector>\n\nbool pairs_sum_to_zero(std::vector<long> l) {\n    std::unordered_set<long> seen;\n    for (const auto& x : l) {\n        if (seen.count(-x)) {          // we already saw the opposite\n            return true;               // a pair (x, -x) exists\n        }\n        // Insert the current number if it hasn't been visited yet\n        // (this also takes care of zero \u2013 we only need one zero)\n        seen.insert(x);\n    }\n    return false;                      // no pair found\n}\n```\n\n### Why this works\n\n1. **Linear time** \u2013 We walk through the vector once (`O(n)`).\n2. **Constant\u2011time lookup** \u2013 `unordered_set` gives `O(1)` average lookup and insert.\n3. **Distinct elements** \u2013  \n   * We check for the presence of `-x` *before* inserting `x`.  \n   * For zero, the first `0` is inserted; when a second `0` is encountered `seen.count(0)` is true, and we return `true`.  \n   * For other numbers, the pair has to consist of two different indices.\n4. **Correctness for all edge cases** \u2013  \n   * Empty vector \u2192 `false` (loop never runs).  \n   * Single element \u2192 `false` (no pair).  \n   * Duplicate values are handled correctly because an earlier occurrence is kept in `seen`.\n\n### Example run\n\n```cpp\nstd::vector<long> a{2, 4, -5, 3, 5, 7};\nbool result = pairs_sum_to_zero(a);  // returns true (2 + -5 = -3? actually 2 and -5 sum to -3; but 5 and -5 sum to 0)\n```\n\nFeel free to integrate this snippet into your project."]}
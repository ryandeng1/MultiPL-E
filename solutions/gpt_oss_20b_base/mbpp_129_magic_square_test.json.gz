{"completions": ["**Solution**\n\nA *magic square* is an `n x n` matrix that satisfies:\n\n1. All entries are distinct integers from `1` to `n\u00b2`.\n2. The sum of each row, each column, and of the two main diagonals are all equal.\n\nThe function below implements these rules and returns `true` only if all of them are satisfied.\n\n```cpp\n/*  Author : ChatGPT\n    Lunchbox-Dev at PTSM\n    ---------------------------------------------------\n    A quick function that checks whether a given square\n    is a magic square.  The function is completely\n    self\u2011contained and uses only the standard library. */\n```\n\n```cpp\n#include <bits/stdc++.h>\n\nbool magic_square_test(const std::vector<std::vector<long>>& my_matrix) {\n    const size_t n = my_matrix.size();\n    if (n == 0) return false;                 // empty matrix\n    for (const auto& row : my_matrix)\n        if (row.size() != n) return false;    // not a square\n\n    /* ----------------------------------------------------------------\n       1) Build the set of all numbers that should appear in the matrix\n          (1,2,\u2026,n*n).                                           ------ */\n    std::unordered_set<long> required;\n    required.reserve(n * n);\n    for (long v = 1; v <= static_cast<long>(n * n); ++v)\n        required.insert(v);\n\n    /* ----------------------------------------------------------------\n       2) Check that the matrix contains exactly these numbers and that\n          the set is distinct while we go through the matrix.        ------ */\n    for (const auto& row : my_matrix) {\n        for (long val : row) {\n            if (!required.count(val))\n                return false;      // number out of range or duplicate\n            required.erase(val);   // remove to detect duplicates later\n        }\n    }\n    if (!required.empty()) return false;   // missing numbers\n\n    /* ----------------------------------------------------------------\n       3) Compute the \u201cmagic constant\u201d \u2013 the target sum for rows,\n          columns and diagonals.   We use the first row to obtain it.\n          We assume n>0 because the above check already handled n==0.   ------ */\n    long target = 0;\n    for (long v : my_matrix[0]) target += v;\n\n    /* ----------------------------------------------------------------\n       4) Verify the sums of all rows.                                     ------ */\n    for (size_t i = 1; i < n; ++i) {\n        long sum = 0;\n        for (long v : my_matrix[i]) sum += v;\n        if (sum != target) return false;\n    }\n\n    /* ----------------------------------------------------------------\n       5) Verify the sums of all columns.                                 ------ */\n    for (size_t col = 0; col < n; ++col) {\n        long sum = 0;\n        for (size_t row = 0; row < n; ++row) sum += my_matrix[row][col];\n        if (sum != target) return false;\n    }\n\n    /* ----------------------------------------------------------------\n       6) Verify the sums of the two main diagonals.                     ------ */\n    long diag1 = 0, diag2 = 0;\n    for (size_t i = 0; i < n; ++i) {\n        diag1 += my_matrix[i][i];\n        diag2 += my_matrix[i][n - 1 - i];\n    }\n    if (diag1 != target || diag2 != target) return false;\n\n    /* ----------------------------------------------------------------\n       All checks passed \u2013 it\u2019s a magic square.                          ------ */\n    return true;\n}\n```\n\n### How the function works\n\n| Step | Purpose | Key Operation |\n|------|---------|---------------|\n| 1 | Check that the matrix is square | `size_t n = my_matrix.size();` & row\u2011length check |\n| 2 | Validate that every integer 1\u2026n\u00b2 appears exactly once | Remove from an `unordered_set` while scanning |\n| 3 | Determine the magic constant | Sum of first row |\n| 4 | Ensure each row sums to the target | Simple accumulation |\n| 5 | Ensure each column sums to the target | Column accumulation |\n| 6 | Ensure both main diagonals sum to the target | Diagonal accumulation |\n\nIf any check fails, `false` is returned immediately; otherwise `true` is returned at the end.\n\nFeel free to drop this function into your code base. It is fully self\u2011contained, O(n\u00b2) time, and uses only standard library containers.", "Here\u2019s a complete, self\u2011contained implementation of `magic_square_test`.  \nIt checks that:\n\n1. The matrix is square (same number of rows and columns).  \n2. All entries are distinct positive integers.  \n3. The sums of every row, every column and the two main diagonals are the same.  \n\nFeel free to drop it into your project and tweak the return/value/parameter types as you like.\n\n```cpp\n#include <vector>\n#include <unordered_set>\n#include <numeric>\n\n/**\n * @brief  Checks whether a given square matrix forms a magic square.\n *\n * A *magic square* is a square arrangement of the numbers 1 \u2026 n\u00b2\n * such that each row, column and the two main diagonals all sum to the same value.\n *\n * @param my_matrix  n\u00d7n matrix of long integers\n * @return true if the matrix is a magic square, false otherwise\n */\nbool magic_square_test(const std::vector<std::vector<long>>& my_matrix)\n{\n    // ------------------------------------------------------------------\n    // 1. basic size checks\n    // ------------------------------------------------------------------\n    const std::size_t n = my_matrix.size();\n    if (n == 0) {\n        return false;                            // an empty matrix cannot be magic\n    }\n    for (const auto& row : my_matrix) {\n        if (row.size() != n) {\n            return false;                        // not square\n        }\n    }\n\n    // ------------------------------------------------------------------\n    // 2. collect all values \u2013 must be exactly 1..n\u00b2, all distinct\n    // ------------------------------------------------------------------\n    std::unordered_set<long> seen;\n    seen.reserve(n * n);\n    for (const auto& row : my_matrix) {\n        for (long val : row) {\n            if (val <= 0) {\n                return false;                    // magic squares use positive integers\n            }\n            if (!seen.emplace(val).second) {\n                return false;                    // duplicate value\n            }\n        }\n    }\n    const long expected_sum = 1L * n * (n * n + 1) / 2;   // classical magic constant\n    if (seen.size() != n * n || *seen.begin() != 1 || *seen.rbegin() != n * n) {\n        /*  In a *standard* magic square the numbers are 1\u2026n\u00b2.\n            If you only need the \u201csame sum\u201d property, you can drop this\n            check.  The following line is a quick way to ensure we actually\n            have the set {1,\u2026,n\u00b2}. */\n        return false;\n    }\n\n    // ------------------------------------------------------------------\n    // 3. compute the target row/column/diagonal sum\n    // ------------------------------------------------------------------\n    long target = 0;\n    for (long val : my_matrix[0]) {\n        target += val;                 // sum of the first row will be the target\n    }\n\n    // ------------------------------------------------------------------\n    // 4. check every row\n    // ------------------------------------------------------------------\n    for (const auto& row : my_matrix) {\n        long sum = std::accumulate(row.begin(), row.end(), 0L);\n        if (sum != target) {\n            return false;\n        }\n    }\n\n    // ------------------------------------------------------------------\n    // 5. check every column\n    // ------------------------------------------------------------------\n    for (std::size_t col = 0; col < n; ++col) {\n        long sum = 0;\n        for (std::size_t row = 0; row < n; ++row) {\n            sum += my_matrix[row][col];\n        }\n        if (sum != target) {\n            return false;\n        }\n    }\n\n    // ------------------------------------------------------------------\n    // 6. check the two main diagonals\n    // ------------------------------------------------------------------\n    long diag1 = 0, diag2 = 0;\n    for (std::size_t i = 0; i < n; ++i) {\n        diag1 += my_matrix[i][i];\n        diag2 += my_matrix[i][n - 1 - i];\n    }\n    if (diag1 != target || diag2 != target) {\n        return false;\n    }\n\n    return true; // all tests passed\n}\n```\n\n### What this code does\n\n- **Size checks** \u2013 ensures the input is a square matrix.  \n- **Distinct positive integers 1\u2026n\u00b2** \u2013 the classical definition of a magic square.  \n  If you only care about the equal\u2011sum property, comment out the `seen` block.  \n- **Row, column and diagonal sums** \u2013 all compared to the expected value.\n\n### Usage example\n\n```cpp\nint main() {\n    std::vector<std::vector<long>> magic = {\n        {8, 1, 6},\n        {3, 5, 7},\n        {4, 9, 2}\n    };\n\n    if (magic_square_test(magic)) {\n        std::cout << \"It is a magic square!\\n\";\n    } else {\n        std::cout << \"Not a magic square.\\n\";\n    }\n    return 0;\n}\n```\n\nFeel free to adapt the function for different numeric types or for sums that need to be computed in `long long` if overflow is a concern.", "**Solution Overview**\n\nA **magic square** is an \\(n \\times n\\) matrix that satisfies the following conditions  \n\n1. The matrix is square.  \n2. The sums of all rows, all columns, the main diagonal and the anti\u2011diagonal are the same.  \n3. (Optional \u2013 depends on the definition) The matrix contains exactly the integers \\(1,\\dots,n^2\\) *without*\n   repetition.\n\nThe implementation below follows these rules.  \nIf you only care about the \u201cequal\u2011sum\u201d property (the most common definition for an\n*arithmetic* magic square), comment out the check for numbers `1..n^2`.  \n\n```cpp\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <numeric>          // std::accumulate\n\n// ------------------------------------------------------------\n// Return true iff my_matrix is a magic square.\n// ------------------------------------------------------------\nbool magic_square_test(const std::vector<std::vector<long>>& my_matrix)\n{\n    // 1. The matrix must be non\u2011empty and square\n    if (my_matrix.empty()) return false;\n\n    const size_t n = my_matrix.size();\n    for (const auto& row : my_matrix)\n        if (row.size() != n) return false;\n\n    // --------------------------------------------------------\n    // 2. Exactly the numbers 1 .. n*n must appear once\n    // --------------------------------------------------------\n    std::unordered_set<long> values;\n    values.reserve(n * n);\n    for (const auto& row : my_matrix) {\n        for (long v : row)\n            values.insert(v);\n    }\n    if (values.size() != n * n) return false;\n    for (long v = 1; v <= static_cast<long>(n * n); ++v)\n        if (values.find(v) == values.end()) return false;\n\n    // --------------------------------------------------------\n    // 3. Compute magic sum (sum of first row)\n    // --------------------------------------------------------\n    const long magic_sum = std::accumulate(my_matrix[0].begin(),\n                                           my_matrix[0].end(), 0L);\n\n    // --------------------------------------------------------\n    // 4. Check all rows\n    // --------------------------------------------------------\n    for (size_t i = 0; i < n; ++i) {\n        long row_sum = std::accumulate(my_matrix[i].begin(),\n                                       my_matrix[i].end(), 0L);\n        if (row_sum != magic_sum) return false;\n    }\n\n    // --------------------------------------------------------\n    // 5. Check all columns\n    // --------------------------------------------------------\n    for (size_t col = 0; col < n; ++col) {\n        long col_sum = 0;\n        for (size_t row = 0; row < n; ++row) col_sum += my_matrix[row][col];\n        if (col_sum != magic_sum) return false;\n    }\n\n    // --------------------------------------------------------\n    // 6. Check main diagonal\n    // --------------------------------------------------------\n    long diag_sum = 0;\n    for (size_t i = 0; i < n; ++i) diag_sum += my_matrix[i][i];\n    if (diag_sum != magic_sum) return false;\n\n    // --------------------------------------------------------\n    // 7. Check anti\u2011diagonal\n    // --------------------------------------------------------\n    long anti_diag_sum = 0;\n    for (size_t i = 0; i < n; ++i)\n        anti_diag_sum += my_matrix[i][n - 1 - i];\n    if (anti_diag_sum != magic_sum) return false;\n\n    // All tests passed!\n    return true;\n}\n\n// ------------------------------------------------------------\n// Simple test routine \u2013 not part of the function itself\n// ------------------------------------------------------------\nint main()\n{\n    std::vector<std::vector<long>> ms = {\n        {16, 3,  2, 13},\n        {5, 10, 11, 8},\n        {9, 6,  7, 12},\n        {4, 15, 14, 1}\n    };\n\n    std::cout << std::boolalpha\n              << \"Is magic square? \" << magic_square_test(ms) << '\\n';\n}\n```\n\n### What the code does\n\n1. **Matrix validity** \u2013 Checks for non\u2011empty and square shape.  \n2. **Value uniqueness** \u2013 Ensures every integer from `1` to `n*n` appears exactly once.  \n3. **Magic sum** \u2013 Uses the first row as the reference sum.  \n4. **Row, column, diagonal checks** \u2013 Compares every row, column and the two diagonals with the magic sum.\n\nThe function is `O(n\u00b2)` in time and `O(n\u00b2)` in space because of the set used for\nchecking distinct values.  If you only need the sum\u2011consistency test, and can\nskip the distinct\u2011value requirement, remove the block that fills the set and\nthe subsequent checks."]}
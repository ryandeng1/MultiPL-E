{"completions": ["Sure! Below is a complete, minimal C++ implementation that checks whether any value in one integer sequence appears in another.  \nYou can drop the whole file into a `.cpp` file, compile it with any C++17\u2011conforming compiler, and run it.  \n\n```cpp\n#include <vector>\n#include <unordered_set>\n#include <iostream>\n\n/*\n * @brief   Returns true if there is at least one element that belongs to\n *          both `list1` and `list2`.\n *\n * @param list1 A vector of integers (or `long` if you prefer).\n * @param list2 Another vector of integers.\n *\n * @return  true  \u2013 at least one common element exists\n *          false \u2013 the two sequences are disjoint\n */\nbool overlapping(const std::vector<long>& list1, const std::vector<long>& list2)\n{\n    // Build a hash\u2013set with the elements of the *shorter* vector.\n    // This keeps memory usage low and speeds up the lookup.\n    const std::vector<long> *small = &list1;\n    const std::vector<long> *large = &list2;\n    if (list1.size() > list2.size()) {\n        small = &list2;\n        large = &list1;\n    }\n\n    std::unordered_set<long> table(small->cbegin(), small->cend());\n\n    // If any element of the large vector is found in the set, the two\n    // sequences overlap.\n    for (const long &v : *large) {\n        if (table.find(v) != table.end())\n            return true;\n    }\n    return false;\n}\n\n/* --------------------  Demo / unit\u2011test block  -------------------- */\n#ifdef DEMO_OVERLAPPING\nint main()\n{\n    std::vector<long> a = {1, 3, 5, 7};\n    std::vector<long> b = {2, 4, 6};\n    std::vector<long> c = {8, 9, 5};\n\n    std::cout << std::boolalpha;\n    std::cout << \"a overlaps b? \" << overlapping(a, b) << '\\n'; // false\n    std::cout << \"a overlaps c? \" << overlapping(a, c) << '\\n'; // true\n\n    return 0;\n}\n#endif\n```\n\n### Why this implementation?\n\n| Requirement | What we did |\n| ----------- | ----------- |\n| **Fast** | We build a `unordered_set` from the smaller vector, giving *O(1)* average lookup. |\n| **Memory efficient** | Only the smaller vector is stored in the hash\u2011set \u2013 we never duplicate the larger one. |\n| **Deterministic** | Order of arguments doesn\u2019t matter; the function works for any two vectors. |\n| **Safe** | Parameters are passed by `const&`, so no unnecessary copies. |\n\n### How to compile & run\n\n```bash\n# Compile with C++17\ng++ -std=c++17 -DDEMO_OVERLAPPING overlapping.cpp -o overlapping\n./overlapping\n```\n\nYou\u2019ll see:\n\n```\na overlaps b? false\na overlaps c? true\n```\n\nFeel free to drop the `DEMO_OVERLAPPING` macro guard out when integrating the function into your own code base. Happy coding!", "Below is a compact and idiomatic C++ implementation that checks whether **any** value in a first integer sequence (`list1`) also occurs in a second sequence (`list2`).  \nThe function returns `true` as soon as a common element is found; otherwise it returns `false`.\n\n```cpp\n#include <vector>\n#include <unordered_set>\n\n/**\n * @brief Returns true iff there exists at least one element that is present in both lists.\n *\n * @param list1 First sequence of integers.\n * @param list2 Second sequence of integers.\n * @return bool True if the intersection of the two sequences is non\u2011empty; otherwise false.\n */\nbool overlapping(const std::vector<long>& list1, const std::vector<long>& list2)\n{\n    // Use an unordered_set for O(1) average\u2011time look\u2011ups\n    std::unordered_set<long> elems;\n\n    // First pass: put all elements of list1 into the set\n    for (const auto& x : list1)\n        elems.insert(x);\n\n    // Second pass: check each element of list2 against the set\n    for (const auto& y : list2)\n        if (elems.find(y) != elems.end())\n            return true;      // common element found\n\n    return false;            // no overlap\n}\n```\n\n### Why this implementation?\n\n| Requirement | Choice |\n|---|---|\n| **Time\u2011efficiency** | Building an `unordered_set` from `list1` gives \\(O(n)\\) expected time. The second traversal of `list2` is also \\(O(m)\\). Overall \\(O(n+m)\\). |\n| **Space\u2011efficiency** | The maximum additional space is the number of distinct elements in `list1`, i.e. \\(O(n)\\). |\n| **Early exit** | The function returns immediately once a common element is discovered \u2013 useful for large input sequences. |\n| **Thread\u2011safety** | The function only reads the input vectors and does not modify them; it can be used safely in parallel contexts. |\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> a{1, 2, 3, 5};\n    std::vector<long> b{7, 0, 3};\n\n    if (overlapping(a, b))\n        std::cout << \"Sequences overlap.\\n\";\n    else\n        std::cout << \"No common elements.\\n\";\n\n    return 0;\n}\n```\n\n### Edge cases handled\n\n* Empty vectors: returns `false`.\n* Duplicate values inside a list: handled correctly (duplicates do not break the logic).\n* Very large values: `long` is used consistently, and `unordered_set<long>` handles them.\n\nFeel free to adapt the function signature or the container types (e.g., `std::unordered_set<int>`) if your project uses different integer widths or needs a different hash function.", "Here\u2019s a minimal, idiomatic C++ implementation that answers the question:  \n*\u201cDoes any value that appears in `list1` also appear in `list2`?\u201d*\n\n```cpp\n#include <vector>\n#include <unordered_set>\n\n/**\n * @brief Returns true iff there is at least one element shared by both\n *        sequences. The function works in O(n + m) time and O(min(n,m))\n *        auxiliary space.  It uses an unordered_set for constant\u2011time\n *        look\u2011ups.\n *\n * @param list1 The first sequence of values.\n * @param list2 The second sequence of values.\n * @return true if there is a common element, false otherwise.\n */\nbool overlapping(const std::vector<long>& list1,\n                 const std::vector<long>& list2)\n{\n    // Early exit \u2013 if one list is empty there can't be an overlap.\n    if (list1.empty() || list2.empty()) return false;\n\n    // Build a hash\u2011set from the shorter list to keep memory usage low.\n    const std::vector<long> *small, *large;\n    if (list1.size() < list2.size()) {\n        small = &list1; large = &list2;\n    } else {\n        small = &list2; large = &list1;\n    }\n\n    std::unordered_set<long> pool;\n    pool.reserve(small->size() * 2);                // avoid rehashing\n    for (long v : *small) pool.insert(v);\n\n    // Scan the larger sequence; the first hit means we have an overlap.\n    for (long v : *large) {\n        if (pool.find(v) != pool.end()) return true;\n    }\n    return false;\n}\n```\n\n### Why this works\n\n1. **Linear time** \u2013 We iterate once over each vector; every lookup in the hash\u2011set is `O(1)` on average.  \n2. **Low memory** \u2013 We only store the elements of the smaller vector in the hash\u2011set.  \n3. **Robustness** \u2013 The function accepts empty vectors, works for any `long` values, and uses `const` refs to avoid copying.\n\n### Usage example\n\n```cpp\nint main() {\n    std::vector<long> a{1, 3, 5, 7};\n    std::vector<long> b{2, 4, 6, 8};\n    std::cout << std::boolalpha << overlapping(a, b) << '\\n'; // prints false\n\n    std::vector<long> c{2, 4, 7, 9};\n    std::cout << std::boolalpha << overlapping(a, c) << '\\n'; // prints true\n}\n```\n\nThis function can be dropped into any C++11\u2011compatible codebase. If you prefer a \u201chard\u2011coded\u201d approach (no unordered_set), just use nested loops \u2013 but that would be \\(O(n \\times m)\\) and far slower for large inputs."]}
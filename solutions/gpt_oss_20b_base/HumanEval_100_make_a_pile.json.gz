{"completions": ["Here\u2019s a compact implementation that follows the specification:\n\n```cpp\n#include <vector>\n\nstd::vector<long> make_a_pile(long n) {\n    // The vector will contain exactly n elements.\n    std::vector<long> pile;\n    pile.reserve(n);            // Optional: avoid reallocations.\n\n    // Start with the first level having `n` stones.\n    for (long i = 0; i < n; ++i) {\n        // Each subsequent level differs by 2 (odd\u2192odd or even\u2192even).\n        pile.push_back(n + 2 * i);\n    }\n\n    return pile;\n}\n```\n\n### How it works\n1. **Initialization** \u2013 The first level has `n` stones.\n2. **Increment** \u2013 For each following level we add **2** to the previous level.  \n   - If the starting `n` is odd, the sequence remains odd: `n, n+2, n+4, \u2026`.  \n   - If the starting `n` is even, the sequence remains even: `n, n+2, n+4, \u2026`.\n3. **Result** \u2013 A `std::vector<long>` of size `n` containing the number of stones per level.\n\nFeel free to adapt or extend this function to fit into your project\u2019s style or naming conventions.", "Below is a **complete, compilable** implementation for the requested function.  \nIt follows the rules described in the problem statement:\n\n- We start with `n` stones in the first level.\n- If `n` is odd \u2192 next stone count is the *next odd* number (i.e. `next = current + 2`).\n- If `n` is even \u2192 next stone count is the *next even* number (`next = current + 2` as well, because the difference between two consecutive even numbers is also 2, and the same for odds).\n\nThe function simply generates `n` levels and returns them in a `std::vector<long>`.\n\n```cpp\n#include <vector>\n#include <cstdint>   // for std::int64_t if you want a fixed width type\n\n// Return a vector containing the number of stones on each level.\nstd::vector<long> make_a_pile(long n) {\n    // Guard against invalid input: n must be positive.\n    assert(n > 0);\n\n    std::vector<long> pile;\n    pile.reserve(static_cast<std::size_t>(n));\n\n    long current = n;               // Stones in the first level.\n    for (long level = 0; level < n; ++level) {\n        pile.push_back(current);\n\n        // Prepare the stone count for the next level (if any).\n        // Since the difference between consecutive odd numbers is 2,\n        // and the same holds for consecutive even numbers, we can\n        // simply add 2.\n        current += 2;\n    }\n\n    return pile;\n}\n```\n\n### Quick test\n\n```cpp\n#include <iostream>\n\nint main() {\n    auto v = make_a_pile(3);\n    for (auto x : v) std::cout << x << ' ';\n    // Output: 3 5 7\n}\n```\n\nThis implementation is O(n) in time and uses O(n) additional space for the resulting vector, exactly as required.", "```cpp\n#include <vector>\n\n/*  Make a pile of `n` levels.\n    Level 1 contains `n` stones, each subsequent level contains the\n    next odd number if the previous one was odd, or the next even number\n    if the previous one was even.\n    \n    Since moving from an odd to the next odd number, or from an even to\n    the next even number, always increases the count by 2, the sequence\n    is simply:\n         n, n+2, n+4, \u2026 (n terms in total)\n*/\nstd::vector<long> make_a_pile(long n) {\n    std::vector<long> pile;\n    pile.reserve(static_cast<std::size_t>(n));\n\n    for (long i = 0; i < n; ++i) {\n        pile.push_back(n + 2 * i);\n    }\n    return pile;\n}\n```\n\n**Explanation**\n\n* The first level contains `n` stones.\n* Whether `n` is odd or even, the \"next odd/even number\" is always\n  `current + 2`.  \n  (odd \u2192 odd + 2, even \u2192 even + 2)\n* Therefore each level increases by 2 stones.\n* Build a vector of length `n` with elements `n + 2*i` for `i = 0 \u2026 n-1`.\n\nThe function returns a `std::vector<long>` containing all levels."]}
{"completions": ["Here\u2019s a compact, idiomatic C++17 implementation that returns **true** if the two signed integers (`long` in this case) have opposite signs, and **false** otherwise:\n\n```cpp\n// Returns true iff x and y have opposite signs.\n// Works for any signed integral type (long, int, long long, etc.).\nbool opposite_Signs(long x, long y) {\n    // 1. XOR the two values \u2013 if the sign bits differ the result will be negative.\n    // 2. Check whether the result is negative.\n    return ((x ^ y) < 0);\n}\n```\n\n### Why this works\n\n* The bit\u2011wise XOR `x ^ y` flips a bit whenever the two operands differ.  \n* For two signed numbers, the most significant bit is the sign bit.  \n  * If the signs are identical (both positive or both negative) the sign bit of the XOR will be `0`.\n  * If the signs differ, the sign bit of the XOR will be `1`, making the result negative in two\u2019s\u2013complement representation.\n* Comparing the XOR result to `0` therefore yields `true` exactly when the sign bits differ.\n\n### Extended version with template (optional)\n\nIf you want the function to work with any signed integral type, just make it a template:\n\n```cpp\ntemplate <typename SignedInteger>\nbool opposite_signs(SignedInteger x, SignedInteger y) {\n    static_assert(std::is_signed_v<SignedInteger>, \"Template argument must be signed\");\n    return ((x ^ y) < 0);\n}\n```\n\nThis keeps the same O(1) time complexity and uses only a single machine instruction.", "Sure! Below is a simple C++ implementation of a function that checks whether two integers have opposite signs.  \nWe also provide a quick `main` to illustrate its use.\n\n```cpp\n#include <iostream>\n#include <cassert>\n\n/*\n * Returns true if x and y have opposite signs,\n * false otherwise.\n *\n * Edge cases:\n *   - 0 has no sign, so any comparison involving 0\n *     returns false.\n */\nbool opposite_Signs(long x, long y)\n{\n    // If either number is zero, they can't be of opposite sign\n    if (x == 0 || y == 0)\n        return false;\n\n    // x and y have opposite signs iff their product is negative\n    return (x > 0) != (y > 0);\n    // Alternatively: return x*y < 0;  // but beware of overflow\n}\n\nint main()\n{\n    // Test cases\n    assert(opposite_Signs(5, -3) == true);\n    assert(opposite_Signs(-10, 20) == true);\n    assert(opposite_Signs(0, -1) == false);\n    assert(opposite_Signs(-7, -4) == false);\n    assert(opposite_Signs(9, 9) == false);\n\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\n### How it works\n1. **Zero check** \u2013 0 is considered neutral, so we immediately return `false` if either argument is zero.\n2. **Sign comparison** \u2013 We simply check whether the sign of `x` (`>0`) differs from the sign of `y`.  \n   Using `!=` on the boolean results gives `true` only when the signs differ.\n3. **Alternative** \u2013 `x*y < 0` also works, but multiplying may overflow for very large values. The boolean trick avoids that.\n\nFeel free to drop it into your project or tweak the tests to match your own use\u2011case!", "Below is a concise, self\u2011contained C++ implementation that determines whether two signed integer values have opposite signs.  \nThe function works for any signed integer type (`int`, `long`, `long long`, \u2026) because it relies only on the two\u2019s\u2011complement representation that C++ guarantees for signed integers.\n\n```cpp\n#include <cstdint>   // for int64_t, etc.\n#include <limits>    // for std::numeric_limits\n\n/*\n *  oppositeSigns\n *\n *  Returns true if `x` and `y` have opposite signs, i.e. one is\n *  strictly positive and the other strictly negative.\n *\n *  The implementation is independent of the numeric limits of the\n *  type and does not invoke undefined behaviour for the extreme\n *  negative value (INT_MIN).  It works for all integral types\n *  that can be expressed as a 64\u2011bit signed integer (you can change\n *  the template parameter if you need another width).\n */\ntemplate <typename T>\nbool oppositeSigns(T x, T y)\n{\n    // Convert to signed 64\u2011bit to avoid overflow/paradoxical behaviour\n    // of the built\u2011in ! (logical NOT) operator on the most\u2011negative\n    // value (e.g. INT_MIN).\n    using int64 = std::int64_t;\n    int64 ix = static_cast<int64>(x);\n    int64 iy = static_cast<int64>(y);\n\n    // Two numbers have opposite signs iff one is negative and the other\n    // is strictly positive.  Zero is considered *neither*, so any\n    // comparison involving zero returns false.\n    return (ix < 0 && iy > 0) || (ix > 0 && iy < 0);\n}\n```\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::cout << std::boolalpha;\n    std::cout << \"oppositeSigns( 5, -3) = \" << oppositeSigns(5, -3) << '\\n';\n    std::cout << \"oppositeSigns(-8, 8)  = \" << oppositeSigns(-8, 8) << '\\n';\n    std::cout << \"oppositeSigns(0, 7)   = \" << oppositeSigns(0, 7) << '\\n';\n    std::cout << \"oppositeSigns(-1, -1) = \" << oppositeSigns(-1, -1) << '\\n';\n}\n```\n\n**Output**\n\n```\noppositeSigns( 5, -3) = true\noppositeSigns(-8, 8)  = true\noppositeSigns(0, 7)   = false\noppositeSigns(-1, -1) = false\n```\n\nFeel free to include the function in any module that needs this check."]}
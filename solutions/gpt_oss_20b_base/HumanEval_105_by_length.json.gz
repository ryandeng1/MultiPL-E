{"completions": ["Below is a concise, self\u2011contained implementation that follows the specification:\n\n```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <unordered_map>\n\nstd::vector<std::string> by_length(std::vector<long> arr)\n{\n    // 1. Keep only numbers in the allowed range [1,9]\n    std::vector<int> digits;\n    digits.reserve(arr.size());\n    for (long v : arr)\n        if (1 <= v && v <= 9) digits.push_back(static_cast<int>(v));\n\n    // 2. Sort the remaining digits\n    std::sort(digits.begin(), digits.end());\n\n    // 3. Reverse the sorted list\n    std::reverse(digits.begin(), digits.end());\n\n    // 4. Map each digit to its word representation\n    static const std::unordered_map<int,std::string> names = {\n        {1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},\n        {5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}\n    };\n\n    std::vector<std::string> result;\n    result.reserve(digits.size());\n    for (int d : digits)\n        result.push_back(names.at(d));\n\n    return result;\n}\n```\n\n### How it works\n\n1. **Filtering** \u2013 Only the integers `1` through `9` are kept; everything else is silently discarded.\n2. **Sorting** \u2013 The remaining numbers are sorted in ascending order.\n3. **Reversing** \u2013 The sorted vector is reversed so that the largest number becomes first.\n4. **Mapping** \u2013 Each integer is replaced by the corresponding English word.\n\n### Example\n\n```cpp\nstd::vector<long> v{2,1,1,4,5,8,2,3};\nauto r = by_length(v);\n// r == {\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"}\n```\n\nThe function also handles an empty input vector, simply returning an empty vector, as required.", "Below is a self\u2011contained implementation of the requested function in modern C++ (C++17/20).  \nIt follows exactly the rules you described:\n\n1. Keep only the numbers `1 \u2026 9`.  \n2. Sort the remaining numbers.  \n3. Reverse the sorted list.  \n4. Map each digit to its English word.\n\n```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <unordered_map>\n\n// ---------------------------------------------------------------------------\n// Convert a vector of integers to the required \"digit\u2011name\" vector.\n// ---------------------------------------------------------------------------\nstd::vector<std::string>\nby_length(std::vector<long> arr)\n{\n    // 1.  Keep only the digits 1\u20139 (inclusive).\n    std::vector<long> digits;\n    digits.reserve(arr.size());\n    for (long n : arr) {\n        if (1 <= n && n <= 9) {\n            digits.push_back(n);\n        }\n    }\n\n    // 2.  If nothing left, return empty vector immediately.\n    if (digits.empty()) {\n        return {};\n    }\n\n    // 3.  Sort ascending.\n    std::sort(digits.begin(), digits.end());\n\n    // 4.  Reverse so we obtain descending order.\n    std::reverse(digits.begin(), digits.end());\n\n    // 5.  Map each digit to its English name.\n    static const std::unordered_map<int, std::string> name = {\n        {1, \"One\"},   {2, \"Two\"},   {3, \"Three\"}, {4, \"Four\"},\n        {5, \"Five\"},  {6, \"Six\"},   {7, \"Seven\"}, {8, \"Eight\"},\n        {9, \"Nine\"}\n    };\n\n    std::vector<std::string> result;\n    result.reserve(digits.size());\n    for (int d : digits) {\n        result.emplace_back(name.at(d));\n    }\n\n    return result;\n}\n```\n\n### How it works\n\n| Step | Code | Description |\n|------|------|-------------|\n| 1 | `if (1 <= n && n <= 9)` | Filter out numbers not in the range 1\u20269. |\n| 2 | `if (digits.empty()) return {};` | Handle the empty\u2011vector corner case. |\n| 3 | `std::sort` | Sort the remaining numbers in ascending order. |\n| 4 | `std::reverse` | Reverse the sorted vector so that the largest digits come first. |\n| 5 | `unordered_map` & `emplace_back` | Convert each integer to its corresponding string (\u201cOne\u201d, \u2026). |\n\n### Example usage\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    auto v = by_length({2,1,1,4,5,8,2,3});\n    for (const auto& s : v) std::cout << s << ' ';\n    // Output: Eight Five Four Three Two Two One One\n}\n```\n\nThis implementation complies with the behaviour shown in your examples and is ready to be dropped into any C++ project.", "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// Convert the given vector of integers into a vector of spelled\u2011out numbers\n/// according to the following rules:\n///   1. Keep only numbers in the closed interval [1, 9].\n///   2. Sort those numbers in ascending order.\n///   3. Reverse the sorted order.\n///   4. Replace each integer by its English name\n///      (\"One\", \"Two\", \u2026, \"Nine\").\n/// If the input vector is empty or contains no valid numbers, an empty vector\n/// is returned.\nstd::vector<std::string> by_length(std::vector<long> arr) {\n    // Mapping from number to its name\n    static const std::vector<std::string> names{\n        \"One\", \"Two\", \"Three\", \"Four\", \"Five\",\n        \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    };\n\n    // 1. Keep only numbers between 1 and 9 inclusive\n    vector<int> filtered;\n    for (long x : arr) {\n        if (1 <= x && x <= 9)\n            filtered.push_back(static_cast<int>(x));\n    }\n\n    // 2. Sort ascending\n    sort(filtered.begin(), filtered.end());\n\n    // 3. Reverse the order\n    reverse(filtered.begin(), filtered.end());\n\n    // 4. Build the resulting vector using the names\n    vector<std::string> result;\n    result.reserve(filtered.size());\n    for (int n : filtered)\n        result.push_back(names[n - 1]);   // `n` is 1\u2011based\n\n    return result;\n}\n```\n\nThe function follows exactly the specification:\n\n- Invalid values (outside `1\u20269`, negative numbers, larger numbers, etc.) are ignored.\n- If after filtering the vector is empty, an empty vector is returned.\n- The helper `names` array maps numbers `1`\u2011`9` to their English words."]}
{"completions": ["```cpp\n#include <regex>\n\nbool text_starta_endb(const std::string& text)\n{\n    // Regular expression: start with 'a', then any characters (including none),\n    // and finish with 'b'.\n    static const std::regex pattern(\"^a.*b$\", std::regex::ECMAScript);\n    return std::regex_match(text, pattern);\n}\n```\n\n**Explanation**\n\n- `^a`\u2003\u2003\u2013 must start with the character `a`.  \n- `.*`\u2003\u2003\u2013 any number of any characters (including zero).  \n- `b$`\u2003\u2003\u2013 must end with the character `b`.  \n\n`std::regex_match` is used to test the whole string against the pattern.  \nThe pattern is defined `static const` so it is compiled only once.", "Here\u2019s a compact, self\u2011contained implementation of the requested predicate.  \nIt simply checks that the first character is `'a'` (or the string starts with `\"a\"`), that the last character is `'b'`, and that the string is long enough to contain both.  \nNo heavy regex machinery is required, but a regular\u2011expression version is added as a commented\u2011out alternative.\n\n```cpp\n#include <string>\n#include <cctype>      // for std::isalpha if you want a stricter check\n#include <iostream>    // (only for demo; remove in production)\n\n/* -------------------------------------------------\n   Returns true iff:\n         \u2022 the string starts with the literal\n           character 'a' (lower\u2011case a), and\n         \u2022 the string ends with the literal\n           character 'b'\n   ------------------------------------------------- */\nbool text_starta_endb(const std::string &text)\n{\n    /* Quick length check \u2013 we need at least two characters */\n    if (text.size() < 2)          // \"a\" or \"\" cannot satisfy both\n        return false;\n\n    /* Core logic: first is 'a', last is 'b' */\n    return text.front() == 'a' && text.back() == 'b';\n}\n\n/* -------------------------------------------------\n   Optional regex implementation (uncomment to use).\n   This version is a bit slower and pulls in <regex>.\n   ------------------------------------------------- */\n// #include <regex>\n// bool text_starta_endb(const std::string &text)\n// {\n//     static const std::regex pattern(\"^a.*b$\");   // only ASCII a,b\n//     return std::regex_match(text, pattern);\n// }\n\n/* -------------------------------------------------\n   Demo / quick unit\u2011test\n   ------------------------------------------------- */\n#ifdef UNIT_TEST\nint main()\n{\n    struct Test { std::string s; bool expected; };\n    Test tests[] = {\n        {\"ab\",          true},\n        {\"abc\",         true},\n        {\"aXb\",         true},\n        {\"ba\",          false},\n        {\"a\",           false},\n        {\"b\",           false},\n        {\"\",            false},\n        {\"abbb\",        true},\n        {\"aaab\",        true},\n        {\"bbc\",         false}\n    };\n\n    for (auto &t : tests) {\n        bool res = text_starta_endb(t.s);\n        std::cout << (res==t.expected?\"PASS\":\"FAIL\") << \" : \"\n                  << '\"' << t.s << \"\\\" \u2192 \" << res << '\\n';\n    }\n}\n#endif\n```\n\n### How it works\n\n1. **Length check** \u2013 a string that is shorter than two characters can\u2019t have both an `'a'` at the start and a `'b'` at the end.\n2. **First and last characters** \u2013 `std::string::front()` and `back()` (or `text[0]` and `text.back()`) provide the required characters.\n3. **Result** \u2013 true only when both characters match the literals `'a'` and `'b'`.\n\nFeel free to graft the function into your codebase. If you truly need a pattern\u2011matching solution for a more complex grammar, the regex branch (commented out) can be enabled with a single `#include <regex>` and `#undef`.", "Here\u2019s a compact, self\u2011contained implementation that does exactly what you asked for: it returns `true` when the given string starts with an `'a'` and ends with a `'b'`, regardless of what (if anything) appears in between.\n\n```cpp\n#include <string>\n#include <regex>\n\n/// Checks if the supplied text starts with 'a' and ends with 'b'.\n/// Anything (including nothing) may appear between those two characters.\n/// Returns true on a match, false otherwise.\n///\n/// Examples:\n///   \"ab\"          \u2192 true\n///   \"acb\"         \u2192 true\n///   \"abc\"         \u2192 false\n///   \"a\"           \u2192 false\n///   \"ba\"          \u2192 false\nbool text_starta_endb(const std::string& text)\n{\n    // A simple regular expression that captures the requirement:\n    //   - ^ a      : the string must start with 'a'\n    //   - .*       : any number (0+) of any characters\n    //   - b $      : it must end with 'b'\n    static const std::regex pattern(R\"(^a.*b$)\", std::regex::ECMAScript);\n    return std::regex_match(text, pattern);\n}\n```\n\n### Why this works\n\n* `^` and `$` anchor the match to the start and end of the *whole* string, guaranteeing there are no extra characters before or after the desired parts.\n* `a.*b` simply says: an `'a'`, followed by *any* characters (including none), followed by a `'b'`.\n* The use of a `static const` regex means the pattern is compiled only once, making subsequent calls fast.\n\n### Usage\n\n```cpp\nint main()\n{\n    assert(text_starta_endb(\"ab\")   == true);\n    assert(text_starta_endb(\"acb\")  == true);\n    assert(text_starta_endb(\"a\")    == false);\n    assert(text_starta_endb(\"ba\")   == false);\n}\n```\n\nFeel free to drop this function into your project; it requires only `<string>` and `<regex>`."]}
{"name": "HumanEval_88_sort_array", "language": "rs", "prompt": "/// Given a vector of non-negative integers, return a cors of the given vector after sorting,\n/// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n/// or sort it in descending order if the sum( first index value, last index value) is even.\n/// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n/// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2, 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3, 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_88_sort_array.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve this problem, we need to sort a given vector of non-negative integers based on the sum of its first and last elements. The sorting direction depends on whether this sum is odd or even. If the sum is odd, we sort the vector in ascending order; if even, we sort it in descending order. Importantly, we must not modify the original vector.\n\n### Approach\n1. **Check for Empty Vector**: If the input vector is empty, return an empty vector immediately.\n2. **Compute Sum of First and Last Elements**: For non-empty vectors, compute the sum of the first and last elements.\n3. **Determine Sorting Direction**:\n   - If the sum is **odd**, sort the vector in **ascending order**.\n   - If the sum is **even**, sort the vector in **descending order**.\n4. **Return New Sorted Vector**: Create a clone of the original vector, sort it according to the determined direction, and return the sorted vector without modifying the original.\n\n### Solution Code\n```rust\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.is_empty() {\n        return Vec::new();\n    }\n\n    let first = array[0];\n    let last = array.last().unwrap();\n    let sum = first + last;\n\n    if sum % 2 == 1 {\n        let mut sorted = array.clone();\n        sorted.sort();\n        sorted\n    } else {\n        let mut sorted = array.clone();\n        sorted.sort_by(|a, b| b.cmp(a));\n        sorted\n    }\n}\n```\n\n### Explanation\n1. **Empty Vector Handling**: The function first checks if the input vector is empty. If so, it returns an empty vector.\n2. **Sum Calculation**: For non-empty vectors, it retrieves the first and last elements and computes their sum.\n3. **Sorting Direction**:\n   - **Odd Sum**: If the sum is odd, the vector is cloned and sorted in ascending order using `sort()`, which sorts elements in natural order (ascending).\n   - **Even Sum**: If the sum is even, the vector is cloned and sorted in descending order using `sort_by(|a, b| b.cmp(a))`. This comparator ensures that each element `b` is compared against `a` to place `b` before `a` if `b` is greater, resulting in a descending order.\n4. **Result**: The sorted vector is returned without altering the original input vector, adhering to the problem constraints.\n\nThis approach efficiently handles all edge cases, including empty vectors and single-element vectors, while ensuring the sorting direction is correctly determined based on the sum of the first and last elements. The solution is both clear and optimal for the given problem constraints.", "\n\nTo solve this problem, we need to sort a given vector of non-negative integers based on the sum of its first and last elements. The sorting direction depends on whether this sum is odd or even. If the sum is odd, the vector should be sorted in ascending order; if even, it should be sorted in descending order. Importantly, the original vector must not be modified.\n\n### Approach\n1. **Check for Empty Vector**: If the input vector is empty, return an empty vector immediately.\n2. **Compute Sum of First and Last Elements**: For non-empty vectors, compute the sum of the first and last elements.\n3. **Determine Sorting Direction**:\n   - If the sum is odd, sort the vector in ascending order.\n   - If the sum is even, sort the vector in descending order.\n4. **Clone and Sort**: Create a clone of the original vector to avoid modifying it, then sort the clone according to the determined direction.\n\n### Solution Code\n```rust\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.is_empty() {\n        return Vec::new();\n    }\n    let first = array[0];\n    let last = array[array.len() - 1];\n    let sum = first + last;\n\n    if sum % 2 == 1 {\n        let mut sorted = array.clone();\n        sorted.sort();\n        sorted\n    } else {\n        let mut sorted = array.clone();\n        sorted.sort_by(|a, b| b.cmp(a));\n        sorted\n    }\n}\n```\n\n### Explanation\n1. **Empty Vector Check**: The function first checks if the input vector is empty. If so, it returns an empty vector.\n2. **Sum Calculation**: The sum of the first and last elements of the vector is calculated. This sum determines the sorting direction.\n3. **Sorting Direction**:\n   - **Odd Sum**: If the sum is odd, the vector is sorted in ascending order using `sort()`, which sorts the vector in place in ascending order.\n   - **Even Sum**: If the sum is even, the vector is sorted in descending order using `sort_by(|a, b| b.cmp(a))`, which customizes the comparison to place larger elements before smaller ones.\n4. **Cloning**: The original vector is cloned to ensure no modifications are made to it, and the sorted clone is returned as the result.\n\nThis approach efficiently handles all edge cases, including empty vectors and single-element vectors, while adhering to the requirement of not modifying the original vector. The solution leverages Rust's built-in sorting capabilities to achieve the desired result with clarity and correctness.", "\n\nTo solve this problem, we need to sort a given vector of non-negative integers based on the parity of the sum of its first and last elements. The sorting direction depends on whether this sum is odd or even. If the sum is odd, the vector is sorted in ascending order; if even, it is sorted in descending order. Importantly, the original vector must not be modified.\n\n### Approach\n1. **Edge Case Handling**: \n   - If the input vector is empty, return an empty vector.\n   - If the vector contains only one element, return it as is (since sorting a single element vector in any order leaves it unchanged).\n\n2. **Sum Calculation**:\n   - Compute the sum of the first and last elements of the vector.\n\n3. **Sorting Decision**:\n   - If the sum is odd, sort the vector in ascending order.\n   - If the sum is even, sort the vector in descending order.\n\n4. **Cloning the Vector**:\n   - To avoid modifying the original vector, we clone the input vector before sorting.\n\n### Solution Code\n```rust\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.is_empty() {\n        return Vec::new();\n    }\n    let mut sorted = array.clone();\n    let first = array[0];\n    let last = array[array.len() - 1];\n    let sum = first + last;\n    if sum % 2 == 1 {\n        sorted.sort();\n    } else {\n        sorted.sort_by(|a, b| b.cmp(a));\n    }\n    sorted\n}\n```\n\n### Explanation\n1. **Edge Case Handling**: \n   - The function first checks if the input vector is empty. If so, it returns an empty vector immediately.\n   - For vectors with a single element, the function proceeds to sort (though the result remains unchanged).\n\n2. **Sum Calculation**:\n   - The first and last elements of the vector are accessed to compute their sum. This sum determines the sorting direction.\n\n3. **Sorting Decision**:\n   - If the sum is odd (`sum % 2 == 1`), the vector is sorted in ascending order using Rust's default `sort` method.\n   - If the sum is even, the vector is sorted in descending order using `sort_by` with a custom comparator that orders elements in reverse (i.e., `b.cmp(a)`).\n\n4. **Cloning**:\n   - The input vector is cloned to ensure the original vector remains unmodified. The sorted result is then returned.\n\nThis approach efficiently handles all specified cases, including edge cases like empty vectors and single-element vectors, while adhering to the requirement of not modifying the original input vector. The solution leverages Rust's built-in sorting capabilities to achieve the desired result with minimal overhead."]}
{"name": "HumanEval_145_order_by_points", "language": "rs", "prompt": "/// Write a function which sorts the given vector of integers\n/// in ascending order according to the sum of their digits.\n/// Note: if there are several items with similar sum of their digits,\n/// order them based on their index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n/// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_145_order_by_points.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve this problem, we need to sort a vector of integers based on the sum of their digits in ascending order. If two integers have the same digit sum, they should be ordered according to their original indices in the input vector.\n\n### Approach\n1. **Problem Analysis**: The task involves sorting integers based on the sum of their digits. Negative numbers are handled by taking their absolute value for digit sum calculation (since digits are non-negative). For example, the digit sum of `-1` is `1`, and the digit sum of `-12` is `3`.\n2. **Key Insight**: The sorting must be done in two steps:\n   - **Primary Key**: The sum of the digits of each number (in ascending order).\n   - **Secondary Key**: The original index of the number in the input vector (in ascending order).\n3. **Algorithm Selection**: \n   - Convert each number in the input vector into a tuple `(index, number)`.\n   - Sort these tuples using a custom comparator that first compares the digit sums and then the original indices.\n   - Extract the numbers from the sorted tuples to form the result vector.\n\n### Solution Code\n```rust\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut indexed_nums = nums.into_iter().enumerate().collect::<Vec<_>>();\n    indexed_nums.sort_by(|(i, &num1), (j, &num2)| {\n        let sum1 = {\n            let n = num1.abs();\n            if n == 0 {\n                0\n            } else {\n                let mut sum = 0;\n                let mut num = n;\n                while num > 0 {\n                    sum += num % 10;\n                    num /= 10;\n                }\n                sum\n            }\n        };\n        let sum2 = {\n            let n = num2.abs();\n            if n == 0 {\n                0\n            } else {\n                let mut sum = 0;\n                let mut num = n;\n                while num > 0 {\n                    sum += num % 10;\n                    num /= 10;\n                }\n                sum\n            }\n        };\n        sum1.cmp(&sum2).then(i.cmp(&j))\n    });\n    indexed_nums.into_iter().map(|(_, num)| num).collect()\n}\n```\n\n### Explanation\n1. **Indexing**: The input vector is converted into a list of tuples where each tuple contains the original index and the number.\n2. **Digit Sum Calculation**: For each number, its absolute value is taken to handle negative numbers. The digit sum is computed by repeatedly extracting the last digit (using modulo 10) and dividing the number by 10 (integer division).\n3. **Sorting**: The tuples are sorted using a custom comparator:\n   - **Primary Comparison**: The digit sums of the numbers are compared. Numbers with smaller digit sums come first.\n   - **Secondary Comparison**: If digit sums are equal, the original indices are compared to maintain the order from the input vector.\n4. **Result Construction**: After sorting, the numbers are extracted from the sorted tuples to form the final result vector.\n\nThis approach efficiently sorts the numbers according to the specified criteria while handling edge cases like negative numbers and empty vectors correctly. The solution ensures optimal performance with a time complexity of O(n * d), where `n` is the number of elements and `d` is the average number of digits per element.", "\n\nTo solve this problem, we need to sort a vector of integers based on the sum of their digits in ascending order. If two integers have the same digit sum, they should be ordered according to their original indices in the input vector, with the element that appeared later in the original vector coming first.\n\n### Approach\n1. **Digit Sum Calculation**: For each integer in the input vector, compute the sum of its digits. This involves taking the absolute value of the integer to handle negative numbers uniformly, then summing each digit.\n2. **Tracking Original Indices**: As we process each integer, we keep track of its original index to handle tie-breaking when digit sums are equal.\n3. **Custom Sorting**: We sort the integers primarily by their digit sums in ascending order. For integers with the same digit sum, we sort them by their original indices in descending order (i.e., the integer that appeared later in the original vector comes first).\n4. **Edge Handling**: If the input vector is empty, we return an empty vector immediately.\n\n### Solution Code\n```rust\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    fn digit_sum(n: isize) -> usize {\n        if n == 0 {\n            return 0;\n        }\n        let mut num = n.abs();\n        let mut sum = 0;\n        while num > 0 {\n            sum += num % 10;\n            num /= 10;\n        }\n        sum\n    }\n\n    if nums.is_empty() {\n        return Vec::new();\n    }\n\n    let mut indexed_nums: Vec<(isize, usize)> = nums.into_iter().enumerate().map(|(i, n)| (n, i)).collect();\n    indexed_nums.sort_by(|&(a, i), &(b, j)| {\n        let sum_a = digit_sum(a);\n        let sum_b = digit_sum(b);\n        match sum_a.cmp(&sum_b) {\n            Ordering::Less => Ordering::Less,\n            Ordering::Greater => Ordering::Greater,\n            Ordering::Equal => i.cmp(&j).reverse(),\n        }\n    });\n\n    indexed_nums.into_iter().map(|(n, _)| n).collect()\n}\n```\n\n### Explanation\n1. **Digit Sum Calculation**: The helper function `digit_sum` computes the sum of digits for an integer by first taking its absolute value (to handle negative numbers) and then summing each digit from right to left.\n2. **Tracking Indices**: The `indexed_nums` vector stores tuples of `(number, original_index)` for each element in the input vector.\n3. **Custom Sorting**: The `sort_by` method sorts `indexed_nums` based on:\n   - **Primary Key**: The digit sum of each number (ascending).\n   - **Secondary Key**: The original index of each number (descending), ensuring that numbers with the same digit sum are ordered by their original positions in the input vector (later elements come first).\n4. **Result Construction**: After sorting, we extract just the numbers from the sorted `indexed_nums` vector to form the final result.\n\nThis approach efficiently handles the sorting requirements, including tie-breaking based on original indices, and correctly processes both positive and negative integers by focusing on their digit sums. The solution is optimal with a time complexity of O(n * d), where `n` is the number of elements and `d` is the average number of digits per element.", "\n\nTo solve this problem, we need to sort a vector of integers based on the sum of their digits in ascending order. If two integers have the same digit sum, their relative order in the sorted vector should match their original order in the input vector (i.e., a stable sort).\n\n### Approach\n1. **Digit Sum Calculation**: For each integer in the vector, compute the sum of its digits. Since negative numbers can be handled by taking the absolute value, we convert each number to its absolute value before processing its digits.\n2. **Stable Sorting**: Use Rust's stable sort to sort the vector based on the computed digit sums. This ensures that elements with the same digit sum retain their original order.\n\nThe key insight here is that Rust's `sort_by` function is stable, meaning elements with equal keys (in this case, digit sums) will appear in the same order as they did in the original vector.\n\n### Solution Code\n```rust\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut sorted = nums;\n    sorted.sort_by(|a, b| {\n        let sum_a = a.abs().to_string().chars().map(|c| c.to_digit(10).unwrap() as isize).sum();\n        let sum_b = b.abs().to_string().chars().map(|c| c.to_digit(10).unwrap() as isize).sum();\n        sum_a.cmp(&sum_b)\n    });\n    sorted\n}\n```\n\n### Explanation\n1. **Digit Sum Calculation**: The helper expression `a.abs().to_string().chars().map(|c| c.to_digit(10).unwrap() as isize).sum()` computes the sum of the digits of the absolute value of the integer `a`. \n   - `a.abs()` converts the integer to its absolute value.\n   - `.to_string()` converts the absolute value to a string.\n   - `.chars()` splits the string into individual characters.\n   - `.map(|c| c.to_digit(10).unwrap() as isize)` converts each character to its corresponding digit (as an `isize`).\n   - `.sum()` accumulates the sum of these digits.\n2. **Stable Sorting**: The `sort_by` method sorts the vector using the computed digit sums. The comparison `sum_a.cmp(&sum_b)` ensures that the sorting is done in ascending order of digit sums. Because Rust's sort is stable, elements with the same digit sum will maintain their original relative order.\n\nThis approach efficiently handles both positive and negative integers by focusing on their absolute values for digit sum calculation, ensuring correct and stable sorting as required. The solution is concise and leverages Rust's built-in stable sorting capabilities to meet the problem's specifications."]}
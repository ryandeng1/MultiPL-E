{"name": "mbpp_733_find_first_occurrence", "language": "rs", "prompt": "/// Write a function to find the index of the first occurrence of a given number in a sorted vector.\nfn find_first_occurrence(A: Vec<isize>, x: isize) -> isize {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_733_find_first_occurrence.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = find_first_occurrence;\n    assert_eq!(candidate(vec![2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 5), 1);\n    assert_eq!(candidate(vec![2, 3, 5, 5, 6, 6, 8, 9, 9, 9], 5), 2);\n    assert_eq!(candidate(vec![2, 4, 1, 5, 6, 6, 8, 9, 9, 9], 6), 4);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve this problem, we need to find the index of the first occurrence of a given number in a sorted vector. Since the vector is sorted, we can efficiently use binary search to locate the first occurrence of the target number.\n\n### Approach\n1. **Binary Search Adaptation**: The standard binary search algorithm is modified to find the leftmost (first) occurrence of the target value. This involves:\n   - Initializing `low` to 0 and `high` to the last index of the vector.\n   - Calculating the middle index `mid` as `(low + high) / 2`.\n   - If the element at `mid` is less than the target, we adjust `low` to `mid + 1`.\n   - If the element at `mid` is greater than the target, we adjust `high` to `mid - 1`.\n   - If the element at `mid` equals the target, we adjust `high` to `mid - 1` to continue searching for a potential earlier occurrence.\n2. **Termination Condition**: The loop terminates when `low` exceeds `high`. At this point, `low` will be the index of the first occurrence of the target value in the sorted vector.\n\n### Solution Code\n```rust\nfn find_first_occurrence(A: Vec<isize>, x: isize) -> isize {\n    let mut low = 0;\n    let mut high = A.len() as isize - 1;\n    while low <= high {\n        let mid = (low + high) / 2;\n        if A[mid as usize] < x {\n            low = mid + 1;\n        } else if A[mid as usize] > x {\n            high = mid - 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    low\n}\n```\n\n### Explanation\n1. **Initialization**: We start with `low` set to 0 (the first index) and `high` set to the last index of the vector (`A.len() - 1`).\n2. **Binary Search Loop**:\n   - **Mid Calculation**: The middle index `mid` is calculated as the average of `low` and `high`.\n   - **Comparison**:\n     - If the element at `mid` is less than the target `x`, we move `low` to `mid + 1` to search the right half.\n     - If the element at `mid` is greater than `x`, we move `high` to `mid - 1` to search the left half.\n     - If the element at `mid` equals `x`, we move `high` to `mid - 1` to check for any earlier occurrences.\n3. **Termination**: The loop exits when `low` exceeds `high`. At this point, `low` holds the index of the first occurrence of `x` in the vector. If `x` is not present, `low` will be the position where `x` would be inserted to maintain the sorted order (though the problem assumes `x` is present).\n\nThis approach efficiently finds the first occurrence in O(log n) time, leveraging the sorted nature of the vector and binary search principles. The solution handles all edge cases, including empty vectors and the absence of the target value (though the problem assumes the target is present).", "\n\nTo solve this problem, we need to find the index of the first occurrence of a given number `x` in a sorted vector `A`. The solution leverages binary search to efficiently locate the first occurrence by adjusting the search range appropriately when the target is found.\n\n### Approach\n1. **Binary Search Setup**: Initialize `low` to 0 and `high` to the last index of the vector (i.e., `A.len() - 1`).\n2. **Binary Search Execution**:\n   - Calculate the middle index `mid` as `(low + high) / 2`.\n   - If the element at `mid` is less than `x`, adjust `low` to `mid + 1` to search the right half.\n   - If the element at `mid` is greater than `x`, adjust `high` to `mid - 1` to search the left half.\n   - If the element at `mid` equals `x`, adjust `high` to `mid - 1` to continue searching for a potential earlier occurrence.\n3. **Result Determination**: After the loop, check if `low` is within bounds and if the element at `low` equals `x`. If so, return `low`; otherwise, return `-1`.\n\nThis approach ensures that we efficiently narrow down the search space to find the first occurrence of `x` in logarithmic time, O(log n), where n is the number of elements in the vector.\n\n### Solution Code\n```rust\nfn find_first_occurrence(A: Vec<isize>, x: isize) -> isize {\n    let mut low = 0;\n    let mut high = (A.len() as isize) - 1;\n    while low <= high {\n        let mid = (low + high) / 2;\n        if A[mid as usize] < x {\n            low = mid + 1;\n        } else if A[mid as usize] > x {\n            high = mid - 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    if low < (A.len() as isize) && A[low as usize] == x {\n        low\n    } else {\n        -1\n    }\n}\n```\n\n### Explanation\n1. **Initialization**: The variables `low` and `high` are initialized to the start and end of the vector, respectively.\n2. **Binary Search Loop**:\n   - The loop continues as long as `low` is less than or equal to `high`.\n   - The middle index `mid` is calculated. If the value at `mid` is less than `x`, the search continues in the right half (`low = mid + 1`). If it's greater than `x`, the search continues in the left half (`high = mid - 1`). If it equals `x`, the search continues in the left half (`high = mid - 1`) to find any earlier occurrences.\n3. **Result Check**: After the loop, if `low` is within the vector bounds and the value at `low` equals `x`, `low` is returned as the first occurrence index. Otherwise, `-1` is returned indicating `x` was not found.\n\nThis method efficiently locates the first occurrence of `x` in a sorted vector using binary search, ensuring optimal performance with O(log n) time complexity.", "\n\nTo solve the problem of finding the index of the first occurrence of a given number in a sorted vector, we can efficiently use a modified binary search algorithm. This approach leverages the fact that the vector is sorted, allowing us to narrow down the search space in logarithmic time.\n\n### Approach\n1. **Binary Search Setup**: Initialize two pointers, `low` starting at 0 and `high` starting at the last index of the vector.\n2. **Binary Search Execution**: While `low` is less than or equal to `high`:\n   - Calculate the middle index `mid` as `low + (high - low) / 2`.\n   - If the element at `mid` is less than the target `x`, move the `low` pointer to `mid + 1`.\n   - If the element at `mid` is greater than `x`, move the `high` pointer to `mid - 1`.\n   - If the element at `mid` equals `x`, record this index as a potential result and continue searching the left half (`high = mid - 1`) to find any earlier occurrences.\n3. **Result Handling**: After the loop terminates, if a valid index was found during the search, return it; otherwise, return -1 indicating the target is not present.\n\nThis approach ensures that we efficiently find the first occurrence of `x` in the sorted vector with a time complexity of O(log n), where n is the number of elements in the vector.\n\n### Solution Code\n```rust\nfn find_first_occurrence(A: Vec<isize>, x: isize) -> isize {\n    let mut low = 0;\n    let mut high = A.len() - 1;\n    let mut result = -1;\n\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if A[mid] < x {\n            low = mid + 1;\n        } else if A[mid] > x {\n            high = mid - 1;\n        } else {\n            result = mid;\n            high = mid - 1;\n        }\n    }\n\n    result as isize\n}\n```\n\n### Explanation\n- **Initialization**: The `low` pointer starts at the beginning of the vector (index 0), and the `high` pointer starts at the end of the vector (index `A.len() - 1`). The `result` variable is initialized to -1 to handle cases where the target `x` is not found.\n- **Binary Search Loop**: The loop continues as long as `low` is less than or equal to `high`:\n  - **Mid Calculation**: The middle index `mid` is calculated to avoid potential overflow in large vectors.\n  - **Comparison with Target**:\n    - If `A[mid]` is less than `x`, the target must be in the right half, so `low` is moved to `mid + 1`.\n    - If `A[mid]` is greater than `x`, the target must be in the left half, so `high` is moved to `mid - 1`.\n    - If `A[mid]` equals `x`, the current index `mid` is recorded as a potential result, and the search continues in the left half (`high = mid - 1`) to check for any earlier occurrences.\n- **Result Handling**: After the loop, if a valid index was recorded during the search, it is returned as `isize`; otherwise, -1 is returned indicating the target was not found.\n\nThis approach efficiently narrows down the search space using binary search, ensuring optimal performance for large input sizes. The solution handles edge cases such as empty vectors and targets not present in the vector correctly."]}
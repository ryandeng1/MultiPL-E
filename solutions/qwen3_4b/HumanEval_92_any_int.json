{"name": "HumanEval_92_any_int", "language": "rs", "prompt": "/// Create a function that takes 3 numbers.\n/// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n/// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n/// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n/// true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z: f64) -> bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_92_any_int.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve this problem, we need to create a function that checks if one of three numbers is equal to the sum of the other two, and all three numbers are integers. The function should return `true` only if both conditions are satisfied; otherwise, it should return `false`.\n\n### Approach\n1. **Check for Integer Values**: For each number, verify that it is an integer. This is done by checking if the fractional part of the number is less than a small tolerance (1e-10) to account for floating-point precision issues.\n2. **Check Sum Condition**: If all three numbers are integers, then check if any one of them equals the sum of the other two. This involves three comparisons:\n   - `x == y + z`\n   - `y == x + z`\n   - `z == x + y`\n3. **Return Result**: The function returns `true` if all numbers are integers and one of the sum conditions is met; otherwise, it returns `false`.\n\n### Solution Code\n```rust\nfn any_int(x: f64, y: f64, z: f64) -> bool {\n    const TOLERANCE: f64 = 1e-10;\n    (x.fract() < TOLERANCE) && (y.fract() < TOLERANCE) && (z.fract() < TOLERANCE) && \n    (x == y + z || y == x + z || z == x + y)\n}\n```\n\n### Explanation\n1. **Integer Check**: The function uses the `fract()` method to get the fractional part of each number. If the fractional part is less than `1e-10`, the number is considered an integer (within floating-point precision limits).\n2. **Sum Condition Check**: After confirming all numbers are integers, the function checks if any number equals the sum of the other two. This is done through three straightforward comparisons.\n3. **Result Compilation**: The function returns `true` only if all numbers are integers (as verified by the fractional part check) and at least one of the sum conditions is satisfied. If either condition fails, the function returns `false`.\n\nThis approach efficiently combines the integer verification and sum condition checks to solve the problem while handling potential floating-point precision issues with a small tolerance threshold. The solution is both concise and robust for the given problem constraints.", "\n\nTo solve this problem, we need to determine if one of the three given numbers is equal to the sum of the other two, and all three numbers are integers. The solution involves checking two main conditions: \n1. All three numbers must be integers (i.e., they have no fractional part).\n2. One of the numbers must be exactly equal to the sum of the other two.\n\n### Approach\n1. **Check for Integers**: For each of the three numbers, verify if they are integers using the `is_integer()` method. This method returns `true` if the number is an integer (i.e., its fractional part is zero).\n2. **Check Sum Condition**: If all numbers are integers, check if any one of them equals the sum of the other two. This involves three comparisons:\n   - `x == y + z`\n   - `y == x + z`\n   - `z == x + y`\n   \nIf both conditions are satisfied (all numbers are integers and one number equals the sum of the other two), return `true`; otherwise, return `false`.\n\n### Solution Code\n```rust\nfn any_int(x: f64, y: f64, z: f64) -> bool {\n    x.is_integer() && y.is_integer() && z.is_integer() && \n    (x == y + z || y == x + z || z == x + y)\n}\n```\n\n### Explanation\n1. **Integer Check**: The expression `x.is_integer() && y.is_integer() && z.is_integer()` ensures that all three input numbers are integers. If any number is not an integer (e.g., `3.6` or `-2.2`), the entire condition evaluates to `false`.\n2. **Sum Condition**: The expression `(x == y + z || y == x + z || z == x + y)` checks if any one number is the sum of the other two. For example:\n   - If `x = 5.0`, `y = 2.0`, and `z = 7.0`, then `7.0 == 5.0 + 2.0` evaluates to `true`.\n   - If `x = 3.0`, `y = -2.0`, and `z = 1.0`, then `1.0 == 3.0 + (-2.0)` evaluates to `true`.\n3. **Combined Condition**: The function returns `true` only if both conditions are met (all numbers are integers and one number equals the sum of the other two). Otherwise, it returns `false`.\n\nThis approach efficiently checks the required conditions using Rust's floating-point operations and integer checks, ensuring correctness for all valid input scenarios as specified in the problem.", "\n\nTo solve this problem, we need to determine if one of the three given numbers is equal to the sum of the other two, and all three numbers are integers. The solution involves checking two main conditions: \n1. All three numbers must be integers (i.e., their fractional parts are exactly zero).\n2. One of the numbers must be equal to the sum of the other two.\n\n### Approach\n1. **Check for Integers**: For each number, verify if its fractional part is exactly zero. This ensures that all three numbers are integers.\n2. **Check Sum Condition**: If all numbers are integers, check if any one of them equals the sum of the other two. This involves three possible conditions:\n   - `x == y + z`\n   - `y == x + z`\n   - `z == x + y`\n\nIf both conditions are satisfied (all numbers are integers and one number equals the sum of the other two), return `true`; otherwise, return `false`.\n\n### Solution Code\n```rust\nfn any_int(x: f64, y: f64, z: f64) -> bool {\n    if x.fract() == 0.0 && y.fract() == 0.0 && z.fract() == 0.0 {\n        (x == y + z) || (y == x + z) || (z == x + y)\n    } else {\n        false\n    }\n}\n```\n\n### Explanation\n1. **Integer Check**: The function first checks if all three numbers (`x`, `y`, `z`) have a fractional part of exactly zero using `x.fract() == 0.0`. The `fract()` method returns the fractional part of a floating-point number. For integers, this value is `0.0`.\n2. **Sum Condition Check**: If all numbers are integers, the function then checks if any one number is equal to the sum of the other two. This is done by evaluating three conditions:\n   - Whether `x` equals `y + z`\n   - Whether `y` equals `x + z`\n   - Whether `z` equals `x + y`\n3. **Result Determination**: If both the integer check and the sum condition are satisfied, the function returns `true`; otherwise, it returns `false`.\n\nThis approach efficiently combines the checks for integer values and the sum condition to solve the problem as specified. The solution handles all edge cases, including negative numbers and zero, by leveraging Rust's floating-point operations and precise fractional part checks."]}
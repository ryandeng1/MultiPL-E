{"name": "mbpp_630_get_coordinates", "language": "rs", "prompt": "/// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfn get_coordinates(test_tup: (isize, isize)) -> Vec<Vec<isize>> {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_630_get_coordinates.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = get_coordinates;\n    assert_eq!(candidate((3, 4)), vec![vec![2, 3], vec![2, 4], vec![2, 5], vec![3, 3], vec![3, 4], vec![3, 5], vec![4, 3], vec![4, 4], vec![4, 5]]);\n    assert_eq!(candidate((4, 5)), vec![vec![3, 4], vec![3, 5], vec![3, 6], vec![4, 4], vec![4, 5], vec![4, 6], vec![5, 4], vec![5, 5], vec![5, 6]]);\n    assert_eq!(candidate((5, 6)), vec![vec![4, 5], vec![4, 6], vec![4, 7], vec![5, 5], vec![5, 6], vec![5, 7], vec![6, 5], vec![6, 6], vec![6, 7]]);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve this problem, we need to extract all the adjacent coordinates of a given coordinate tuple. In grid-based contexts, adjacent coordinates typically refer to the four orthogonal directions: up, down, left, and right. \n\n### Approach\n1. **Problem Analysis**: The function takes a tuple `(x, y)` representing a coordinate and returns a vector of vectors where each inner vector represents one of the four adjacent coordinates.\n2. **Key Insight**: For any given coordinate `(x, y)`, the adjacent coordinates are:\n   - `(x - 1, y)` (left)\n   - `(x + 1, y)` (right)\n   - `(x, y - 1)` (down)\n   - `(x, y + 1)` (up)\n3. **Algorithm Selection**: The solution involves deconstructing the input tuple into `x` and `y`, then generating the four adjacent coordinates as vectors of two elements each.\n4. **Complexity Analysis**: The solution runs in constant time O(1) since it generates exactly four coordinates regardless of the input size.\n\n### Solution Code\n```rust\nfn get_coordinates(test_tup: (isize, isize)) -> Vec<Vec<isize>> {\n    let (x, y) = test_tup;\n    vec![\n        vec![x - 1, y],\n        vec![x + 1, y],\n        vec![x, y - 1],\n        vec![x, y + 1],\n    ]\n}\n```\n\n### Explanation\n1. **Input Handling**: The function takes a tuple `test_tup` of two `isize` values representing the x and y coordinates.\n2. **Deconstruction**: The tuple is deconstructed into individual variables `x` and `y`.\n3. **Adjacent Coordinates Generation**: The function generates four vectors:\n   - `vec![x - 1, y]` for the left adjacent coordinate.\n   - `vec![x + 1, y]` for the right adjacent coordinate.\n   - `vec![x, y - 1]` for the down adjacent coordinate.\n   - `vec![x, y + 1]` for the up adjacent coordinate.\n4. **Result Compilation**: These four vectors are collected into a single `Vec<Vec<isize>>` which is returned as the result.\n\nThis approach efficiently computes all four adjacent coordinates in constant time, adhering to the problem requirements and constraints. The solution is concise, clear, and handles all valid input values for `isize` types.", "\n\nTo solve this problem, we need to extract all adjacent coordinates of a given 2D coordinate tuple. In a standard 2D grid, adjacent coordinates refer to the four neighboring positions: up, down, left, and right. \n\n### Approach\n1. **Unpack the Input Tuple**: The input is a tuple `(x, y)` representing a 2D coordinate.\n2. **Generate Adjacent Coordinates**: For each coordinate `(x, y)`, compute the four adjacent coordinates:\n   - `(x - 1, y)` (left)\n   - `(x + 1, y)` (right)\n   - `(x, y - 1)` (down)\n   - `(x, y + 1)` (up)\n3. **Return as Vector of Vectors**: Each adjacent coordinate is represented as a vector of two `isize` values, and all such vectors are collected into a single vector.\n\n### Solution Code\n```rust\nfn get_coordinates(test_tup: (isize, isize)) -> Vec<Vec<isize>> {\n    let (x, y) = test_tup;\n    vec![\n        vec![x - 1, y],\n        vec![x + 1, y],\n        vec![x, y - 1],\n        vec![x, y + 1],\n    ]\n}\n```\n\n### Explanation\n1. **Unpacking the Tuple**: The input tuple `(x, y)` is unpacked into two separate variables `x` and `y`.\n2. **Generating Adjacent Coordinates**: Using the unpacked values, we generate four new vectors:\n   - `vec![x - 1, y]` represents the coordinate to the left of `(x, y)`.\n   - `vec![x + 1, y]` represents the coordinate to the right of `(x, y)`.\n   - `vec![x, y - 1]` represents the coordinate below `(x, y)`.\n   - `vec![x, y + 1]` represents the coordinate above `(x, y)`.\n3. **Returning the Result**: These four vectors are collected into a single vector of vectors, which is returned as the result.\n\nThis approach efficiently computes all four adjacent coordinates for any given 2D coordinate in constant time, making it optimal for the problem constraints. The solution is concise and leverages Rust's strong type system and vector operations to ensure correctness and clarity.", "\n\nTo solve this problem, we need to extract all adjacent coordinates of a given 2D coordinate tuple. In a grid-based context, adjacent coordinates typically refer to the four cardinal directions: up, down, left, and right. For a given coordinate `(x, y)`, the adjacent coordinates are `(x-1, y)`, `(x+1, y)`, `(x, y-1)`, and `(x, y+1)`.\n\n### Approach\n1. **Destructure the Input Tuple**: The input is a tuple `(isize, isize)`, which we destructure into individual `x` and `y` values.\n2. **Generate Adjacent Coordinates**: For each of the four possible adjacent directions, compute the new coordinates.\n3. **Convert Coordinates to Vectors**: Each computed coordinate pair is converted into a vector of two `isize` values.\n4. **Return the Result**: Collect all four adjacent coordinate vectors into a single vector of vectors.\n\n### Solution Code\n```rust\nfn get_coordinates(test_tup: (isize, isize)) -> Vec<Vec<isize>> {\n    let (x, y) = test_tup;\n    vec![\n        vec![x - 1, y],\n        vec![x + 1, y],\n        vec![x, y - 1],\n        vec![x, y + 1]\n    ]\n}\n```\n\n### Explanation\n1. **Destructuring the Tuple**: The input tuple `test_tup` is deconstructed into two variables `x` and `y` to access the individual coordinate values.\n2. **Generating Adjacent Coordinates**: \n   - `(x - 1, y)` represents the coordinate to the left.\n   - `(x + 1, y)` represents the coordinate to the right.\n   - `(x, y - 1)` represents the coordinate above.\n   - `(x, y + 1)` represents the coordinate below.\n3. **Vector Conversion**: Each of these coordinate pairs is converted into a vector of two `isize` values. For example, `(x - 1, y)` becomes `vec![x - 1, y]`.\n4. **Result Compilation**: The four generated vectors are collected into a single vector using Rust's `vec!` macro, which efficiently initializes the vector with the specified elements.\n\nThis approach ensures that all four adjacent coordinates are generated and returned in a structured format as required by the problem statement. The solution handles all edge cases, including negative coordinates, by directly computing the adjacent positions without any bounds checks."]}
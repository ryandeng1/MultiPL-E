{"name": "mbpp_806_max_run_uppercase", "language": "rs", "prompt": "/// Write a function to find maximum run of uppercase characters in the given string.\nfn max_run_uppercase(test_str: String) -> isize {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_806_max_run_uppercase.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = max_run_uppercase;\n    assert_eq!(candidate(String::from(\"GeMKSForGERksISBESt\")), 5);\n    assert_eq!(candidate(String::from(\"PrECIOusMOVemENTSYT\")), 6);\n    assert_eq!(candidate(String::from(\"GooGLEFluTTER\")), 4);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve the problem of finding the maximum run of uppercase characters in a given string, we can iterate through each character in the string while tracking the current and maximum runs of uppercase characters. Here's the step-by-step breakdown of the solution:\n\n1. **Initialization**: Start with `current_run` and `max_run` set to 0 to keep track of the current and maximum runs of uppercase characters.\n2. **Iteration**: For each character in the string:\n   - If the character is uppercase, increment `current_run`.\n   - If the character is not uppercase, compare `current_run` with `max_run` and update `max_run` if necessary, then reset `current_run` to 0.\n3. **Final Check**: After processing all characters, perform a final check to ensure the last run (if it ends with uppercase characters) is considered for `max_run`.\n\nThis approach efficiently processes the string in a single pass, making it optimal with a time complexity of O(n), where n is the length of the string.\n\nHere's the implementation:\n\n```rust\nfn max_run_uppercase(test_str: String) -> isize {\n    let mut current_run = 0;\n    let mut max_run = 0;\n\n    for c in test_str.chars() {\n        if c.is_uppercase() {\n            current_run += 1;\n        } else {\n            if current_run > max_run {\n                max_run = current_run;\n            }\n            current_run = 0;\n        }\n    }\n\n    if current_run > max_run {\n        max_run = current_run;\n    }\n\n    max_run\n}\n```\n\n**Explanation**:\n- **`current_run`**: Tracks the length of the current consecutive run of uppercase characters.\n- **`max_run`**: Stores the maximum length of uppercase runs encountered during the iteration.\n- **`c.is_uppercase()`**: Checks if a character is uppercase (using Rust's standard library method).\n- **Loop Handling**: The loop processes each character. When a non-uppercase character is found, it resets `current_run` and updates `max_run` if needed.\n- **Final Check**: Ensures the last run (if it ends with uppercase characters) is accounted for.\n\nThis solution efficiently handles all edge cases, including empty strings and strings with no uppercase characters, returning the correct maximum run length.", "\n\nTo solve this problem, we need to find the maximum run of consecutive uppercase characters in a given string. The solution involves traversing the string character by character, counting the current run of uppercase characters, and updating the maximum run encountered so far.\n\n### Approach\n1. **Initialization**: Start with `current_run` and `max_run` set to 0. These variables will track the length of the current run of uppercase characters and the maximum run found, respectively.\n2. **Traverse the String**: For each character in the string:\n   - **Uppercase Character**: If the character is uppercase, increment `current_run`.\n   - **Non-Uppercase Character**: If the character is not uppercase, compare `current_run` with `max_run`. If `current_run` is greater, update `max_run`. Reset `current_run` to 0.\n3. **Final Check**: After processing all characters, check if the last run of uppercase characters (if any) is longer than the current `max_run` and update `max_run` if necessary.\n4. **Return Result**: Convert `max_run` to `isize` and return it.\n\nThis approach efficiently processes the string in a single pass, making it optimal with a time complexity of O(n), where n is the length of the string.\n\n### Solution Code\n```rust\nfn max_run_uppercase(test_str: String) -> isize {\n    let mut current_run = 0;\n    let mut max_run = 0;\n\n    for c in test_str.chars() {\n        if c.is_uppercase() {\n            current_run += 1;\n        } else {\n            if current_run > max_run {\n                max_run = current_run;\n            }\n            current_run = 0;\n        }\n    }\n\n    if current_run > max_run {\n        max_run = current_run;\n    }\n\n    max_run as isize\n}\n```\n\n### Explanation\n- **Initialization**: `current_run` and `max_run` start at 0 to handle cases where there are no uppercase characters.\n- **Character Processing**: For each character in the string:\n  - If the character is uppercase (checked using `is_uppercase()`), `current_run` is incremented.\n  - If the character is not uppercase, `current_run` is compared with `max_run` to see if it's the new maximum. `current_run` is then reset to 0.\n- **Final Check**: After the loop, a final check ensures that any trailing run of uppercase characters (if the string ends with them) is considered for the maximum run.\n- **Result Conversion**: The integer `max_run` is converted to `isize` as required by the function signature and returned.\n\nThis solution efficiently tracks the longest sequence of consecutive uppercase characters in linear time, making it both optimal and straightforward to implement.", "\n\nTo solve this problem, we need to find the maximum run of consecutive uppercase characters in a given string. The solution involves traversing the string while keeping track of the current run of uppercase characters and updating the maximum run encountered so far.\n\n### Approach\n1. **Initialization**: Start with `max_run` and `current_run` set to 0. These variables will keep track of the longest run of uppercase characters found and the current run of uppercase characters being processed, respectively.\n2. **Traversal**: Iterate over each character in the string:\n   - If the character is uppercase, increment `current_run`.\n   - If the character is not uppercase, compare `current_run` with `max_run` and update `max_run` if `current_run` is larger. Reset `current_run` to 0.\n3. **Final Check**: After processing all characters, perform a final check to update `max_run` if the last run of uppercase characters is the longest.\n4. **Return Result**: Convert `max_run` to `isize` and return it.\n\nThis approach efficiently processes the string in linear time, O(n), where n is the length of the string, making it optimal for large inputs.\n\n### Solution Code\n```rust\nfn max_run_uppercase(test_str: String) -> isize {\n    let mut max_run = 0;\n    let mut current_run = 0;\n\n    for c in test_str.chars() {\n        if c.is_uppercase() {\n            current_run += 1;\n        } else {\n            if current_run > max_run {\n                max_run = current_run;\n            }\n            current_run = 0;\n        }\n    }\n\n    if current_run > max_run {\n        max_run = current_run;\n    }\n\n    max_run as isize\n}\n```\n\n### Explanation\n- **Initialization**: `max_run` and `current_run` are initialized to 0 to start counting runs.\n- **Character Processing**: For each character in the string:\n  - If the character is uppercase (checked using `is_uppercase()`), `current_run` is incremented.\n  - If the character is not uppercase, `current_run` is compared with `max_run` to update the maximum run length found so far, and `current_run` is reset to 0.\n- **Final Check**: After processing all characters, a final check ensures that any trailing run of uppercase characters (if the string ends with them) is considered for the maximum run.\n- **Result Conversion**: The result `max_run` is converted from `u32` (or similar) to `isize` as required by the function signature and returned.\n\nThis solution efficiently handles all edge cases, including empty strings and strings with no uppercase characters, ensuring correctness across all inputs. The algorithm processes each character exactly once, making it optimal for performance."]}
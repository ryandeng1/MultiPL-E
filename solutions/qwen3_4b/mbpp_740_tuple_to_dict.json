{"name": "mbpp_740_tuple_to_dict", "language": "rs", "prompt": "use std::collections::HashMap;\n\n/// Write a function to convert the given tuple to a key-value HashMap using adjacent elements. https://www.geeksforgeeks.org/rsthon-convert-tuple-to-adjacent-pair-HashMap/\nfn tuple_to_dict(test_tup: (isize, isize, isize, isize, isize, isize)) -> HashMap<isize, isize> {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_740_tuple_to_dict.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = tuple_to_dict;\n    assert_eq!(candidate((1, 5, 7, 10, 13, 5)), HashMap::from([(1, 5), (7, 10), (13, 5)]));\n    assert_eq!(candidate((1, 2, 3, 4, 5, 6)), HashMap::from([(1, 2), (3, 4), (5, 6)]));\n    assert_eq!(candidate((7, 8, 9, 10, 11, 12)), HashMap::from([(7, 8), (9, 10), (11, 12)]));\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve this problem, we need to convert a given tuple of six `isize` elements into a `HashMap` where each key-value pair consists of non-overlapping adjacent elements from the tuple. Specifically, the first element pairs with the second, the third with the fourth, and the fifth with the sixth.\n\n### Approach\n1. **Tuple Destructuring**: We start by deconstructing the input tuple into individual variables. This allows us to access each element of the tuple directly.\n2. **HashMap Initialization**: We initialize an empty `HashMap` to store the key-value pairs.\n3. **Inserting Key-Value Pairs**: We insert three key-value pairs into the `HashMap`:\n   - The first element of the tuple as the key and the second element as the value.\n   - The third element as the key and the fourth element as the value.\n   - The fifth element as the key and the sixth element as the value.\n4. **Return the HashMap**: Finally, we return the populated `HashMap`.\n\nThis approach efficiently processes the tuple by leveraging Rust's tuple destructuring feature to directly map adjacent elements into the hash map without any additional complexity.\n\n### Solution Code\n```rust\nuse std::collections::HashMap;\n\nfn tuple_to_dict(test_tup: (isize, isize, isize, isize, isize, isize)) -> HashMap<isize, isize> {\n    let (a, b, c, d, e, f) = test_tup;\n    let mut map = HashMap::new();\n    map.insert(a, b);\n    map.insert(c, d);\n    map.insert(e, f);\n    map\n}\n```\n\n### Explanation\n1. **Tuple Destructuring**: The input tuple `(isize, isize, isize, isize, isize, isize)` is deconstructed into six individual variables `a`, `b`, `c`, `d`, `e`, and `f`. This step allows us to access each element of the tuple by its name.\n2. **HashMap Initialization**: A new `HashMap` is created to store the key-value pairs. The `HashMap` is initialized as empty at the beginning.\n3. **Inserting Pairs**: \n   - The first key-value pair is `a` (key) and `b` (value).\n   - The second key-value pair is `c` (key) and `d` (value).\n   - The third key-value pair is `e` (key) and `f` (value).\n4. **Return Statement**: The populated `HashMap` is returned, containing the three key-value pairs formed from non-overlapping adjacent elements of the input tuple.\n\nThis solution efficiently converts the tuple into the desired `HashMap` by directly mapping adjacent elements in a straightforward and readable manner, leveraging Rust's strong type system and tuple handling capabilities.", "\n\nTo convert a 6-element tuple into a `HashMap` where each key is an element from the tuple and its corresponding adjacent element serves as the value, we can leverage Rust's iterator capabilities. The solution iterates over the tuple's elements and pairs each element with its next element using `zip` and `skip(1)`.\n\nHere's the implementation:\n\n```rust\nuse std::collections::HashMap;\n\nfn tuple_to_dict(test_tup: (isize, isize, isize, isize, isize, isize)) -> HashMap<isize, isize> {\n    let mut map = HashMap::new();\n    let mut iter = test_tup.into_iter();\n    for (key, value) in iter.zip(iter.skip(1)) {\n        map.insert(key, value);\n    }\n    map\n}\n```\n\n**Explanation:**\n1. **`test_tup.into_iter()`**: Converts the tuple into an iterator that yields each element in order.\n2. **`iter.skip(1)`**: Creates a new iterator that starts from the second element of the original tuple.\n3. **`iter.zip(iter.skip(1))`**: Pairs each element from the original iterator with the corresponding element from the skipped iterator (i.e., `(a, b)`, `(b, c)`, etc.).\n4. **`map.insert(key, value)`**: Adds each key-value pair to the `HashMap`.\n\nThis approach efficiently processes the tuple to generate the required `HashMap` with adjacent elements as key-value pairs.\n\n**Example:**\nFor input tuple `(1, 2, 3, 4, 5, 6)`, the output `HashMap` will be:\n```rust\n{\n    1 => 2,\n    2 => 3,\n    3 => 4,\n    4 => 5,\n    5 => 6\n}\n```", "\n\nTo convert a tuple of six `isize` elements into a `HashMap` where each key-value pair consists of non-overlapping adjacent elements (i.e., the first element with the second, the third with the fourth, and the fifth with the sixth), we can destructure the tuple into individual variables and then insert the pairs into the `HashMap`.\n\n### Approach\n1. **Destructure the Tuple**: The input tuple `(isize, isize, isize, isize, isize, isize)` is destructured into six variables (`a`, `b`, `c`, `d`, `e`, `f`).\n2. **Initialize HashMap**: Create a new `HashMap` to store the key-value pairs.\n3. **Insert Pairs**: Insert three key-value pairs into the `HashMap`:\n   - `a` as the key and `b` as the value\n   - `c` as the key and `d` as the value\n   - `e` as the key and `f` as the value\n\nThis approach efficiently converts the tuple into a `HashMap` with non-overlapping adjacent pairs, which is a common pattern for such problems.\n\n### Solution Code\n```rust\nuse std::collections::HashMap;\n\nfn tuple_to_dict(test_tup: (isize, isize, isize, isize, isize, isize)) -> HashMap<isize, isize> {\n    let (a, b, c, d, e, f) = test_tup;\n    let mut map = HashMap::new();\n    map.insert(a, b);\n    map.insert(c, d);\n    map.insert(e, f);\n    map\n}\n```\n\n### Explanation\n- **Destructuring**: The tuple `test_tup` is destructured into six variables (`a`, `b`, `c`, `d`, `e`, `f`). This allows us to access each element individually.\n- **HashMap Initialization**: A new `HashMap` is created to store the key-value pairs.\n- **Inserting Pairs**: \n  - The first element (`a`) is paired with the second element (`b`).\n  - The third element (`c`) is paired with the fourth element (`d`).\n  - The fifth element (`e`) is paired with the sixth element (`f`).\n- **Return**: The `HashMap` containing the three key-value pairs is returned.\n\nThis solution efficiently converts the input tuple into a `HashMap` with non-overlapping adjacent pairs, adhering to the problem's requirements. The approach is straightforward and leverages Rust's pattern matching and collections for clarity and correctness."]}
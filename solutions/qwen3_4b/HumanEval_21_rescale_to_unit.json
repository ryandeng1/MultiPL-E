{"name": "HumanEval_21_rescale_to_unit", "language": "rs", "prompt": "/// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0, 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_21_rescale_to_unit.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve this problem, we need to apply a linear transformation to a vector of numbers such that the smallest number becomes 0 and the largest becomes 1. This transformation is known as normalizing the vector to the unit interval [0, 1].\n\n### Approach\n1. **Find Minimum and Maximum Values**: First, we determine the smallest (`min`) and largest (`max`) values in the input vector. Since the problem specifies that the vector has at least two elements, we can safely assume that both `min` and `max` exist.\n2. **Handle Uniform Values**: If all elements in the vector are the same (i.e., `min == max`), we return a vector of zeros because there's no meaningful scaling to perform.\n3. **Apply Linear Transformation**: For each element `x` in the vector, compute the transformed value using the formula:  \n   $$\n   \\text{transformed\\_value} = \\frac{x - \\text{min}}{\\text{max} - \\text{min}}\n   $$\n   This ensures that the smallest value maps to 0 and the largest maps to 1.\n\n### Solution Code\n```rust\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let min = *numbers.iter().min().unwrap();\n    let max = *numbers.iter().max().unwrap();\n    \n    if min == max {\n        vec![0.0; numbers.len()]\n    } else {\n        numbers.iter().map(|&x| (x - min) / (max - min)).collect()\n    }\n}\n```\n\n### Explanation\n1. **Finding Min and Max**: The code uses `numbers.iter().min().unwrap()` and `numbers.iter().max().unwrap()` to find the smallest and largest values in the vector. The `unwrap()` is safe because the problem guarantees the vector has at least two elements.\n2. **Uniform Values Check**: If `min` equals `max`, it means all elements are the same. In this case, the function returns a vector of zeros since there's no variation to scale.\n3. **Transformation Calculation**: For each element `x` in the vector, the transformation `(x - min) / (max - min)` scales the value to the range [0, 1]. This formula ensures that the smallest value becomes 0 and the largest becomes 1, while all intermediate values are proportionally scaled between them.\n\nThis approach efficiently handles the normalization process with clear and concise logic, ensuring correctness for all valid input vectors as specified by the problem constraints.", "\n\nTo solve this problem, we need to transform a given vector of numbers such that the smallest number becomes 0 and the largest becomes 1. This transformation is a linear scaling operation that maps the range of the input vector to the range [0, 1].\n\n### Approach\n1. **Identify Minimum and Maximum Values**: First, we find the smallest (`min`) and largest (`max`) values in the input vector. Since the problem specifies that the vector has at least two elements, we can safely assume that `min` and `max` exist.\n2. **Compute Scaling Factor**: The scaling factor is derived from the difference between the maximum and minimum values (`max - min`). This factor determines how much each value in the vector is scaled.\n3. **Apply Transformation**: For each number in the vector, we compute the transformed value using the formula: `(x - min) / (max - min)`. This ensures that the smallest value maps to 0 and the largest value maps to 1.\n\n### Solution Code\n```rust\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n    \n    numbers.iter()\n        .map(|x| (x - *min) / (*max - *min))\n        .collect()\n}\n```\n\n### Explanation\n1. **Finding Min and Max**: The `min()` and `max()` methods are used on the iterator created from the vector to find the smallest and largest values. These methods return `Option<&T>`, so we use `unwrap()` to get the actual values since the vector has at least two elements.\n2. **Transformation Calculation**: For each element `x` in the vector, the transformed value is calculated as `(x - min) / (max - min)`. This formula scales each value such that the minimum value becomes 0 and the maximum value becomes 1.\n3. **Collecting Results**: The transformed values are collected into a new vector using `collect()`, which efficiently builds the result from the iterator.\n\nThis approach efficiently scales the input vector to the desired range [0, 1] while maintaining the relative order of the values. The solution handles the constraints and requirements specified in the problem statement correctly.", "\n\nTo solve this problem, we need to transform a vector of numbers such that the smallest number becomes 0 and the largest becomes 1. This is a common normalization technique used in data processing and machine learning. The key insight is that we can apply a linear transformation to each element in the vector based on its relative position within the range defined by the minimum and maximum values in the vector.\n\n### Approach\n1. **Find Minimum and Maximum**: First, we determine the smallest (`min`) and largest (`max`) values in the input vector. Since the problem specifies that the vector has at least two elements, we can safely assume that both `min` and `max` exist.\n2. **Apply Linear Transformation**: For each element `x` in the vector, compute the normalized value using the formula:\n   \\[\n   \\text{normalized\\_value} = \\frac{x - \\text{min}}{\\text{max} - \\text{min}}\n   \\]\n   This formula scales each element so that the smallest element becomes 0 and the largest becomes 1.\n\n### Solution Code\n```rust\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let min = *numbers.iter().min().unwrap();\n    let max = *numbers.iter().max().unwrap();\n    numbers.iter().map(|x| (x - min) / (max - min)).collect()\n}\n```\n\n### Explanation\n1. **Finding Min and Max**: The `numbers.iter().min().unwrap()` and `numbers.iter().max().unwrap()` lines efficiently find the smallest and largest values in the vector. The `unwrap()` is safe here because the problem guarantees at least two elements, ensuring that `min` and `max` are not `None`.\n2. **Transformation**: Each element `x` in the vector is transformed by subtracting the minimum value and then dividing by the difference between the maximum and minimum values. This ensures that:\n   - The smallest value (`min`) becomes `(min - min) / (max - min) = 0.0`.\n   - The largest value (`max`) becomes `(max - min) / (max - min) = 1.0`.\n3. **Result Construction**: The transformed values are collected into a new vector using `collect()`, which efficiently builds the result from the iterator.\n\nThis approach efficiently normalizes the input vector to the range [0, 1] using a straightforward linear transformation, ensuring correctness for all valid inputs as specified by the problem constraints."]}
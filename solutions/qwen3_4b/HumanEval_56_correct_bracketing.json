{"name": "HumanEval_56_correct_bracketing", "language": "rs", "prompt": "/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"<\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_56_correct_bracketing.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo determine if a string of brackets is correctly bracketed, we can use a counter-based approach. The key idea is to track the balance of opening and closing brackets as we iterate through the string. \n\n### Approach\n1. **Initialization**: Start with a counter set to zero.\n2. **Iterate through each character** in the string:\n   - For each `<`, increment the counter.\n   - For each `>`, decrement the counter.\n   - If at any point the counter becomes negative, return `false` immediately (indicating a closing bracket without a corresponding opening bracket).\n3. **Final Check**: After processing all characters, if the counter is zero, return `true` (all opening brackets have corresponding closing brackets); otherwise, return `false`.\n\nThis approach efficiently checks for balanced brackets in linear time with constant space complexity.\n\n### Solution Code\n```rust\nfn correct_bracketing(brackets: String) -> bool {\n    let mut count = 0;\n    for c in brackets.chars() {\n        if c == '<' {\n            count += 1;\n        } else {\n            count -= 1;\n        }\n        if count < 0 {\n            return false;\n        }\n    }\n    count == 0\n}\n```\n\n### Explanation\n- **Initialization**: The counter `count` starts at 0 to track the balance of brackets.\n- **Character Processing**:\n  - When encountering `<`, the counter is incremented (indicating an opening bracket).\n  - When encountering `>`, the counter is decremented (indicating a closing bracket).\n  - If the counter becomes negative during processing, it means there's a closing bracket without a matching opening bracket, so the function returns `false` immediately.\n- **Final Check**: After processing all characters, if the counter is zero, all opening brackets have been properly closed, and the function returns `true`; otherwise, it returns `false`.\n\nThis method efficiently ensures that every opening bracket has a corresponding closing bracket in the correct order, meeting the problem's requirements. The solution handles all edge cases, including empty strings and strings with mismatched brackets, correctly.", "\n\nTo solve this problem, we need to determine if a given string of brackets (composed only of '<' and '>') is correctly bracketed. A string is correctly bracketed if every opening bracket '<' has a corresponding closing bracket '>', and the brackets are properly nested.\n\n### Approach\n1. **Problem Analysis**: The problem requires checking if all opening brackets have matching closing brackets in the correct order. The key insight is that at any point in the string, the number of closing brackets should not exceed the number of opening brackets. If at any point the number of closing brackets exceeds the number of opening brackets, the string is invalid.\n2. **Intuition**: We can traverse the string while maintaining a counter:\n   - For each '<' encountered, increment the counter.\n   - For each '>' encountered, decrement the counter.\n   - If the counter becomes negative at any point, it means there's a closing bracket without a corresponding opening bracket, so the string is invalid.\n   - After processing all characters, if the counter is zero, all brackets are properly matched; otherwise, there are unmatched opening brackets.\n3. **Algorithm Selection**: The algorithm involves a single pass through the string with a counter to track the balance of brackets. This approach is efficient with O(n) time complexity, where n is the length of the string, and O(1) space complexity since we only use a single counter variable.\n\n### Solution Code\n```rust\nfn correct_bracketing(brackets: String) -> bool {\n    let mut count = 0;\n    for c in brackets.chars() {\n        if c == '<' {\n            count += 1;\n        } else {\n            count -= 1;\n            if count < 0 {\n                return false;\n            }\n        }\n    }\n    count == 0\n}\n```\n\n### Explanation\n1. **Initialization**: We start with a counter `count` set to zero.\n2. **Traversal**: For each character in the input string:\n   - If the character is '<', we increment `count` (indicating an opening bracket).\n   - If the character is '>', we decrement `count` (indicating a closing bracket). If `count` becomes negative at any point, it means there's a closing bracket without a matching opening bracket, so we immediately return `false`.\n3. **Final Check**: After processing all characters, if `count` is zero, all opening brackets have been matched with closing brackets in the correct order, so we return `true`. Otherwise, there are unmatched opening brackets, and we return `false`.\n\nThis approach efficiently checks for correct bracketing by ensuring that the balance of brackets never goes negative and ends at zero, providing an optimal solution.", "\n\nTo determine if a string of brackets (comprising only `<` and `>`) is correctly bracketed, we can use a **counter-based approach**. This method efficiently checks for balanced brackets by tracking the number of unmatched opening brackets as we iterate through the string.\n\n---\n\n### \u2705 Key Insight\n\n- Every `<` increases the counter by 1 (an opening bracket).\n- Every `>` decreases the counter by 1 (a closing bracket).\n- If at any point the counter becomes **negative**, it means there's a closing bracket without a matching opening bracket \u2192 **invalid**.\n- At the end of the string, if the counter is **zero**, all brackets are matched \u2192 **valid**.\n\nThis approach avoids the need for a stack and runs in **O(n)** time with **O(1)** space complexity.\n\n---\n\n### \ud83e\udde0 Implementation in Rust\n\nHere's the implementation of the function:\n\n```rust\nfn correct_bracketing(brackets: String) -> bool {\n    let mut count = 0;\n    for c in brackets.chars() {\n        if c == '<' {\n            count += 1;\n        } else {\n            count -= 1;\n        }\n        if count < 0 {\n            return false;\n        }\n    }\n    count == 0\n}\n```\n\n---\n\n### \ud83e\uddea Example Walkthrough\n\n| Input String | Counter Steps | Result |\n|---------------|----------------|--------|\n| `\"<\"`          | `0 \u2192 1`        | `false` |\n| `\"<>\"`         | `0 \u2192 1 \u2192 0`    | `true`  |\n| `\"<<><>>\"`     | `0 \u2192 1 \u2192 2 \u2192 1 \u2192 2 \u2192 1 \u2192 0` | `true` |\n| `\"><<>\"`       | `0 \u2192 -1`       | `false` |\n\n---\n\n### \u2705 Why This Works\n\n- The counter ensures that every closing bracket has a corresponding opening bracket before it.\n- Negative counter indicates an invalid sequence (e.g., `\">\"`).\n- Final counter of zero confirms all brackets are properly matched.\n\nThis solution is both **efficient** and **easy to understand**, making it ideal for this problem.\n\n---\n\n### \ud83c\udfaf Final Answer\n\n```rust\nfn correct_bracketing(brackets: String) -> bool {\n    let mut count = 0;\n    for c in brackets.chars() {\n        if c == '<' {\n            count += 1;\n        } else {\n            count -= 1;\n        }\n        if count < 0 {\n            return false;\n        }\n    }\n    count == 0\n}\n```"]}
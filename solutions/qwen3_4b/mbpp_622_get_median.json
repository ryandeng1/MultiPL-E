{"name": "mbpp_622_get_median", "language": "rs", "prompt": "/// Write a function to find the median of two sorted vectors of same size.\nfn get_median(arr1: Vec<isize>, arr2: Vec<isize>, n: isize) -> f64 {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_622_get_median.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = get_median;\n    assert_eq!(candidate(vec![1, 12, 15, 26, 38], vec![2, 13, 17, 30, 45], 5), 16.0);\n    assert_eq!(candidate(vec![2, 4, 8, 9], vec![7, 13, 19, 28], 4), 8.5);\n    assert_eq!(candidate(vec![3, 6, 14, 23, 36, 42], vec![2, 18, 27, 39, 49, 55], 6), 25.0);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve the problem of finding the median of two sorted vectors of the same size, we can leverage a binary search approach to efficiently determine the two middle elements (the $n$-th and $(n+1)$-th smallest elements) in the merged sorted array without explicitly merging the arrays. This approach ensures an optimal time complexity of $O(\\log n)$.\n\n### Approach\n1. **Problem Analysis**: Given two sorted vectors `arr1` and `arr2` of size `n`, the median of the combined sorted array (of size $2n$) is the average of the $n$-th and $(n+1)$-th smallest elements.\n2. **Binary Search**: We perform a binary search on one of the arrays (the smaller one, though both are of equal size here) to find a partition point such that:\n   - The left partition of `arr1` and `arr2` together contain exactly $n$ elements.\n   - The largest elements in the left partitions are less than or equal to the smallest elements in the right partitions.\n3. **Edge Handling**: Special care is taken to handle edge cases where the partition might be at the start or end of an array.\n4. **Median Calculation**: Once the partition is found, the $n$-th and $(n+1)$-th elements are derived from the left and right partitions, and their average is returned as the median.\n\n### Solution Code\n```rust\nfn get_median(arr1: Vec<isize>, arr2: Vec<isize>, n: isize) -> f64 {\n    let n = n as usize;\n    if n == 0 {\n        return 0.0;\n    }\n\n    if arr1.len() > arr2.len() {\n        return get_median(arr2, arr1, n);\n    }\n\n    let m = arr1.len();\n    let mut low = 0;\n    let mut high = m;\n\n    while low <= high {\n        let i = (low + high) / 2;\n        let j = n - i;\n\n        if i > 0 && j > 0 && arr1[i - 1] > arr2[j - 1] {\n            high = i - 1;\n        } else if i < m && j < n && arr1[i] < arr2[j] {\n            low = i + 1;\n        } else {\n            break;\n        }\n    }\n\n    let i = low;\n    let j = n - i;\n\n    let left1 = if i > 0 { arr1[i - 1] } else { isize::MIN };\n    let left2 = if j > 0 { arr2[j - 1] } else { isize::MIN };\n    let nth = left1.max(left2);\n\n    let right1 = if i < m { arr1[i] } else { isize::MAX };\n    let right2 = if j < n { arr2[j] } else { isize::MAX };\n    let nplus1th = right1.min(right2);\n\n    (nth as f64 + nplus1th as f64) / 2.0\n}\n```\n\n### Explanation\n1. **Initial Checks**: The function first checks if `n` is zero (though the problem states vectors of same size, this handles edge cases). It ensures `arr1` is the smaller array by swapping if necessary.\n2. **Binary Search Setup**: The binary search is initialized with `low` set to 0 and `high` set to the size of `arr1`.\n3. **Binary Search Execution**: For each midpoint `i` in `arr1`, the corresponding partition in `arr2` is `j = n - i`. The algorithm checks if the current partition meets the condition where the largest elements in the left partitions are less than or equal to the smallest elements in the right partitions. Adjusts `low` or `high` based on this check.\n4. **Partition Handling**: After the loop, the valid partition indices `i` (in `arr1`) and `j` (in `arr2`) are used to determine the $n$-th and $(n+1)$-th elements.\n5. **Median Calculation**: The $n$-th element is the maximum of the last elements in the left partitions of both arrays. The $(n+1)$-th element is the minimum of the first elements in the right partitions of both arrays. Their average is returned as the median.\n\nThis approach efficiently narrows down the search space using binary search, ensuring optimal performance even for large input sizes. The solution handles all edge cases and correctly computes the median for two sorted arrays of the same size.", "\n\nTo solve the problem of finding the median of two sorted vectors of the same size efficiently, we leverage binary search to determine the correct partition points between the two arrays. This approach ensures that we avoid merging the arrays (which would take O(n) time) and instead find the median in O(log n) time.\n\n### Approach\n1. **Problem Analysis**: Given two sorted vectors of size `n`, the combined sorted array has `2n` elements. The median is the average of the `n-th` and `(n+1)-th` elements in this combined sorted array.\n2. **Binary Search for Partition**: We perform a binary search on the first array to find a partition index `mid1` such that:\n   - The left part of the first array (up to `mid1 - 1`) and the left part of the second array (up to `mid2 - 1`, where `mid2 = n - mid1`) together contain exactly `n` elements.\n   - The maximum element in the left parts is less than or equal to the minimum element in the right parts.\n3. **Edge Handling**: Special cases are handled where the partition might be at the start or end of either array.\n4. **Median Calculation**: Once the correct partition is found, the median is computed as the average of the maximum element in the left parts and the minimum element in the right parts.\n\n### Solution Code\n```rust\nuse std::cmp;\n\nfn get_median(arr1: Vec<isize>, arr2: Vec<isize>, n: isize) -> f64 {\n    let mut low = 0;\n    let mut high = n;\n\n    while low <= high {\n        let mid1 = (low + high) / 2;\n        let mid2 = n - mid1;\n\n        if mid1 > 0 && mid2 < n && arr1[mid1 - 1] > arr2[mid2] {\n            high = mid1 - 1;\n        } else if mid1 < n && mid2 >= 0 && arr2[mid2 - 1] > arr1[mid1] {\n            low = mid1 + 1;\n        } else {\n            let max_left = if mid1 == 0 {\n                arr2[mid2 - 1]\n            } else if mid2 == 0 {\n                arr1[mid1 - 1]\n            } else {\n                cmp::max(arr1[mid1 - 1], arr2[mid2 - 1])\n            };\n\n            let min_right = if mid1 < n && mid2 < n {\n                cmp::min(arr1[mid1], arr2[mid2])\n            } else if mid1 < n {\n                arr1[mid1]\n            } else {\n                arr2[mid2]\n            };\n\n            return (max_left as f64 + min_right as f64) / 2.0;\n        }\n    }\n\n    0.0\n}\n```\n\n### Explanation\n1. **Binary Search Setup**: The binary search is initialized with `low` set to 0 and `high` set to `n` (the size of each array).\n2. **Partition Check**: For each midpoint `mid1` in the first array:\n   - If the element before `mid1` in `arr1` is greater than the element at `mid2` in `arr2`, we adjust `high` to reduce the partition size.\n   - If the element before `mid2` in `arr2` is greater than the element at `mid1` in `arr1`, we adjust `low` to increase the partition size.\n3. **Correct Partition Found**: When the conditions for a valid partition are met, the maximum element in the left parts (`max_left`) and the minimum element in the right parts (`min_right`) are computed.\n4. **Median Calculation**: The median is the average of `max_left` and `min_right`, converted to a floating-point number for the result.\n\nThis approach efficiently narrows down the search space using binary search, ensuring optimal performance with O(log n) time complexity, which is significantly better than the O(n) time required for a naive merge approach. The solution handles all edge cases, including when the partition is at the boundaries of the arrays.", "\n\nTo find the median of two sorted vectors of the same size efficiently, we can leverage a binary search approach that avoids merging the entire arrays. This method ensures an optimal time complexity of $ O(\\log n) $, where $ n $ is the size of each vector.\n\n### Approach\n1. **Binary Search for Partition**: We perform a binary search on one of the sorted arrays to determine a partition point such that the combined left parts (from both arrays) contain exactly $ n $ elements (since the total size of both arrays is $ 2n $).\n2. **Check Partition Validity**: For each candidate partition index $ i $ in the first array, we check if the largest element in the left part of the first array is less than or equal to the smallest element in the right part of the second array, and vice versa.\n3. **Compute Median**: Once the correct partition is found, the median is the average of the largest element in the left part and the smallest element in the right part.\n\n### Solution Code\n```rust\nuse std::cmp;\n\nfn get_median(arr1: Vec<isize>, arr2: Vec<isize>, n: isize) -> f64 {\n    let n_usize = n as usize;\n    let mut low = 0;\n    let mut high = n_usize;\n\n    while low <= high {\n        let mid = (low + high) / 2;\n        let i = mid;\n        let j = n_usize - i;\n\n        if i > 0 && j < n_usize && arr1[i - 1] > arr2[j] {\n            high = mid - 1;\n        } else if j > 0 && i < n_usize && arr2[j - 1] > arr1[i] {\n            low = mid + 1;\n        } else {\n            break;\n        }\n    }\n\n    let i = low;\n    let j = n_usize - i;\n\n    let max_left = if i > 0 && j > 0 {\n        cmp::max(arr1[i - 1], arr2[j - 1])\n    } else if i > 0 {\n        arr1[i - 1]\n    } else {\n        arr2[j - 1]\n    };\n\n    let min_right = if i < n_usize && j < n_usize {\n        cmp::min(arr1[i], arr2[j])\n    } else if i < n_usize {\n        arr1[i]\n    } else {\n        arr2[j]\n    };\n\n    (max_left as f64 + min_right as f64) / 2.0\n}\n```\n\n### Explanation\n1. **Binary Search Setup**: We initialize `low` and `high` to 0 and `n` respectively, representing the possible range for the partition index in the first array.\n2. **Partition Check**: For each midpoint `mid` in the binary search, we calculate the corresponding partition index `j` in the second array such that `i + j = n`.\n3. **Adjusting Search Range**: If the largest element in the left part of the first array exceeds the smallest element in the right part of the second array, we adjust `high` to reduce the search space. Conversely, if the largest element in the left part of the second array exceeds the smallest element in the right part of the first array, we adjust `low` to expand the search space.\n4. **Median Calculation**: After finding the correct partition, we compute the maximum element in the left part (from both arrays) and the minimum element in the right part. The median is then the average of these two values.\n\nThis approach efficiently narrows down the partition using binary search, ensuring optimal performance without explicitly merging the arrays. The solution handles edge cases such as when the partition index is at the boundaries of the arrays, ensuring correctness across all scenarios."]}
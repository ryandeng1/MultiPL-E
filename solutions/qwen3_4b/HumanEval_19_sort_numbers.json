{"name": "HumanEval_19_sort_numbers", "language": "rs", "prompt": "/// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n/// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n/// Return the string with numbers sorted from smallest to largest\n/// >>> sort_numbers(String::from(\"three one five\"))\n/// String::from(\"one three five\")\nfn sort_numbers(numbers: String) -> String {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_19_sort_numbers.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = sort_numbers;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"three\")), String::from(\"three\"));\n    assert_eq!(candidate(String::from(\"three five nine\")), String::from(\"three five nine\"));\n    assert_eq!(candidate(String::from(\"five zero four seven nine eight\")), String::from(\"zero four five seven eight nine\"));\n    assert_eq!(candidate(String::from(\"six five four three two one zero\")), String::from(\"zero one two three four five six\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve this problem, we need to sort a space-delimited string of number words (from 'zero' to 'nine') in ascending numerical order. The solution involves converting each word into its corresponding numerical value, sorting the words based on these values, and then returning the sorted string.\n\n### Approach\n1. **Define the Order of Words**: We start by defining a list of the valid number words in their correct numerical order (from 'zero' to 'nine').\n2. **Split and Convert Input**: Split the input string into individual words and convert each word into a `String` for easier manipulation.\n3. **Sort Words by Position**: For each word in the input, find its position in the predefined list of words. This position directly corresponds to its numerical value (e.g., 'one' is at position 1, which corresponds to the number 1).\n4. **Join Sorted Words**: After sorting the words based on their positions, join them back into a single space-delimited string.\n\nThis approach efficiently leverages the known order of words to avoid complex mappings or hash tables, making the solution both concise and efficient.\n\n### Solution Code\n```rust\nfn sort_numbers(numbers: String) -> String {\n    let order = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"];\n    let mut words: Vec<String> = numbers.split_whitespace().map(|s| s.to_string()).collect();\n    words.sort_by(|a, b| {\n        let pos_a = order.iter().position(|&w| w == a.as_str()).unwrap();\n        let pos_b = order.iter().position(|&w| w == b.as_str()).unwrap();\n        pos_a.cmp(&pos_b)\n    });\n    words.join(\" \")\n}\n```\n\n### Explanation\n1. **Order List**: The `order` array contains the valid number words in their natural numerical order (from 'zero' to 'nine').\n2. **Splitting Input**: The input string is split into individual words using `split_whitespace()`, and each word is converted to a `String` to facilitate sorting.\n3. **Sorting by Position**: Each word is compared by finding its position in the `order` array. Since the input is guaranteed to be valid, we can safely unwrap the position. The words are then sorted based on these positions, which correspond to their numerical values.\n4. **Joining Words**: The sorted words are joined back into a single string with spaces separating each word, which is then returned as the result.\n\nThis solution efficiently sorts the words by leveraging their predefined order, ensuring correctness and simplicity without the need for complex data structures or additional lookups. The approach is optimal for the given constraints and problem requirements.", "\n\nTo solve this problem, we need to sort a space-delimited string of number words (from 'zero' to 'nine') in ascending numerical order. The solution involves parsing the input string, converting each word to its corresponding numerical value, sorting the words based on these values, and then returning the sorted words as a space-delimited string.\n\n### Approach\n1. **Split the Input String**: The input string is split into a vector of individual words using the `split_whitespace` method.\n2. **Convert Words to Strings**: Each word from the split vector is converted into a `String` to facilitate sorting.\n3. **Sort Words by Numerical Value**: The words are sorted using a custom comparison function. This function maps each word to its corresponding numerical value (0 for \"zero\", 1 for \"one\", etc.) using a `match` expression. The words are compared based on these numerical values.\n4. **Join Sorted Words**: The sorted vector of words is joined back into a single space-delimited string and returned.\n\nThe key insight here is that each word has a fixed numerical value, and we can leverage a `match` expression to map each word to its value efficiently. Since the problem guarantees valid input (only words from 'zero' to 'nine'), we can use `unreachable!()` for any unmatched cases to avoid unnecessary error handling.\n\n### Solution Code\n```rust\nfn sort_numbers(numbers: String) -> String {\n    let words: Vec<&str> = numbers.split_whitespace().collect();\n    let mut sorted_words: Vec<String> = words.iter().map(|w| w.to_string()).collect();\n    sorted_words.sort_by(|a, b| {\n        let num_a = match a {\n            \"zero\" => 0,\n            \"one\" => 1,\n            \"two\" => 2,\n            \"three\" => 3,\n            \"four\" => 4,\n            \"five\" => 5,\n            \"six\" => 6,\n            \"seven\" => 7,\n            \"eight\" => 8,\n            \"nine\" => 9,\n            _ => unreachable!(),\n        };\n        let num_b = match b {\n            \"zero\" => 0,\n            \"one\" => 1,\n            \"two\" => 2,\n            \"three\" => 3,\n            \"four\" => 4,\n            \"five\" => 5,\n            \"six\" => 6,\n            \"seven\" => 7,\n            \"eight\" => 8,\n            \"nine\" => 9,\n            _ => unreachable!(),\n        };\n        num_a.cmp(&num_b)\n    });\n    sorted_words.join(\" \")\n}\n```\n\n### Explanation\n1. **Splitting the Input**: The input string is split into a vector of strings (`Vec<&str>`) using `split_whitespace()`, which handles any whitespace delimiters.\n2. **Converting to Strings**: Each word from the split vector is converted into a `String` to ensure the sorting operation works on `String` values.\n3. **Sorting with Custom Comparison**: The sorting is done using `sort_by` with a closure that compares two words by their numerical values. The `match` expression inside the closure maps each word to its corresponding integer (e.g., \"one\" maps to 1, \"three\" maps to 3). The `unreachable!()` macro is used because the problem guarantees valid input (only the specified words), so any unmatched case is treated as an unreachable state.\n4. **Joining Sorted Words**: The sorted vector of `String` values is joined into a single string with spaces separating the words using `join(\" \")`.\n\nThis approach efficiently sorts the words by their numerical values without additional dependencies or complex data structures, leveraging Rust's strong type system and pattern matching for clarity and correctness. The solution handles the problem constraints directly and efficiently.", "\n\nTo solve this problem, we need to sort a space-delimited string of number words (from 'zero' to 'nine') in ascending numerical order. The solution involves mapping each word to its corresponding numerical value, sorting the words based on these values, and then returning the sorted words as a space-delimited string.\n\n### Approach\n1. **Split the Input String**: The input string is split into a vector of individual words using `split_whitespace()`.\n2. **Create a Mapping**: A `HashMap` is used to map each number word (e.g., \"one\") to its corresponding numerical value (e.g., 1).\n3. **Sort the Words**: The vector of words is sorted based on their numerical values using a custom comparator that retrieves the numerical values from the `HashMap`.\n4. **Join the Sorted Words**: The sorted words are joined back into a single space-delimited string and returned.\n\n### Solution Code\n```rust\nuse std::collections::HashMap;\n\nfn sort_numbers(numbers: String) -> String {\n    let words: Vec<&str> = numbers.split_whitespace().collect();\n    let mut word_to_num = HashMap::new();\n    word_to_num.insert(\"zero\", 0);\n    word_to_num.insert(\"one\", 1);\n    word_to_num.insert(\"two\", 2);\n    word_to_num.insert(\"three\", 3);\n    word_to_num.insert(\"four\", 4);\n    word_to_num.insert(\"five\", 5);\n    word_to_num.insert(\"six\", 6);\n    word_to_num.insert(\"seven\", 7);\n    word_to_num.insert(\"eight\", 8);\n    word_to_num.insert(\"nine\", 9);\n\n    words.sort_by(|a, b| word_to_num[a].cmp(&word_to_num[b]));\n    words.join(\" \")\n}\n```\n\n### Explanation\n1. **Splitting the Input**: The input string is split into a vector of `&str` (references to strings) using `split_whitespace()`, which handles whitespace separation.\n2. **Mapping Words to Numbers**: A `HashMap` is initialized to map each valid number word (e.g., \"one\") to its corresponding integer (e.g., 1). This allows efficient lookup of the numerical value for each word during sorting.\n3. **Sorting Words**: The vector of words is sorted using `sort_by`, which compares each pair of words by their numerical values obtained from the `HashMap`. This ensures the words are ordered from smallest to largest numerical value.\n4. **Joining Sorted Words**: The sorted vector of words is joined into a single string with spaces between each word using `join(\" \")`, which is then returned as the result.\n\nThis approach efficiently leverages Rust's standard library features (like `HashMap` and `split_whitespace`) to solve the problem in a clear and concise manner. The solution handles all valid inputs as specified and ensures the output is correctly sorted."]}
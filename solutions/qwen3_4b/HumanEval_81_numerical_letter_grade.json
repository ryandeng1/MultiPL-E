{"name": "HumanEval_81_numerical_letter_grade", "language": "rs", "prompt": "/// It is the last week of the semester and the teacher has to give the grades\n/// to students. The teacher has been making her own algorithm for grading.\n/// The only problem is, she has lost the code she used for grading.\n/// She has given you a vector of GPAs for some students and you have to write \n/// a function that can output a vector of letter grades using the following table:\n/// GPA       |    Letter grade\n/// 4.0                A+\n/// > 3.7                A \n/// > 3.3                A- \n/// > 3.0                B+\n/// > 2.7                B \n/// > 2.3                B-\n/// > 2.0                C+\n/// > 1.7                C\n/// > 1.3                C-\n/// > 1.0                D+ \n/// > 0.7                D \n/// > 0.0                D-\n/// 0.0                E\n/// Example:\n/// >>> grade_equation(vec![4.0, 3, 1.7, 2, 3.5])\n/// vec![String::from(\"A+\"), String::from(\"B\"), String::from(\"C-\"), String::from(\"C\"), String::from(\"A-\")]\nfn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_81_numerical_letter_grade.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = numerical_letter_grade;\n    assert_eq!(candidate(vec![4.0, 3.0, 1.7, 2.0, 3.5]), vec![String::from(\"A+\"), String::from(\"B\"), String::from(\"C-\"), String::from(\"C\"), String::from(\"A-\")]);\n    assert_eq!(candidate(vec![1.2]), vec![String::from(\"D+\")]);\n    assert_eq!(candidate(vec![0.5]), vec![String::from(\"D-\")]);\n    assert_eq!(candidate(vec![0.0]), vec![String::from(\"E\")]);\n    assert_eq!(candidate(vec![1.0, 0.3, 1.5, 2.8, 3.3]), vec![String::from(\"D\"), String::from(\"D-\"), String::from(\"C-\"), String::from(\"B\"), String::from(\"B+\")]);\n    assert_eq!(candidate(vec![0.0, 0.7]), vec![String::from(\"E\"), String::from(\"D-\")]);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve this problem, we need to convert a vector of numerical GPAs into a corresponding vector of letter grades based on a specific grading scale. The grading scale is defined such that each GPA range maps to a specific letter grade. The solution involves checking each GPA against the thresholds in descending order to determine the correct letter grade.\n\n### Approach\n1. **Problem Analysis**: The problem requires converting each GPA in the input vector to a letter grade according to a predefined table. The table specifies ranges for each letter grade, starting from the highest GPA (4.0) down to the lowest (0.0).\n2. **Key Insight**: The letter grades must be assigned based on the highest threshold that the GPA satisfies. For example, a GPA of 3.5 would fall into the \"A-\" category because it is greater than 3.3 but not greater than 3.7.\n3. **Algorithm Selection**: We iterate through each GPA in the input vector and use a series of conditional checks (in descending order of GPA thresholds) to determine the corresponding letter grade. This ensures that each GPA is correctly mapped to the appropriate grade.\n4. **Complexity Analysis**: The algorithm processes each GPA exactly once, resulting in a time complexity of O(n), where n is the number of GPAs in the input vector. This is optimal for the problem.\n\n### Solution Code\n```rust\nfn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {\n    grades.iter().map(|&grade| {\n        if grade == 4.0 {\n            \"A+\".to_string()\n        } else if grade > 3.7 {\n            \"A\".to_string()\n        } else if grade > 3.3 {\n            \"A-\".to_string()\n        } else if grade > 3.0 {\n            \"B+\".to_string()\n        } else if grade > 2.7 {\n            \"B\".to_string()\n        } else if grade > 2.3 {\n            \"B-\".to_string()\n        } else if grade > 2.0 {\n            \"C+\".to_string()\n        } else if grade > 1.7 {\n            \"C\".to_string()\n        } else if grade > 1.3 {\n            \"C-\".to_string()\n        } else if grade > 1.0 {\n            \"D+\".to_string()\n        } else if grade > 0.7 {\n            \"D\".to_string()\n        } else if grade > 0.0 {\n            \"D-\".to_string()\n        } else {\n            \"E\".to_string()\n        }\n    }).collect()\n}\n```\n\n### Explanation\n1. **Input Handling**: The function takes a vector of `f64` values representing GPAs.\n2. **Iterate and Map**: For each GPA in the input vector, the function checks against a series of conditions in descending order (from highest to lowest GPA thresholds).\n3. **Condition Checks**: The conditions are checked sequentially. The first condition that matches determines the letter grade. For example:\n   - A GPA of `4.0` maps to `\"A+\"`.\n   - A GPA of `3.5` (greater than `3.3` but not greater than `3.7`) maps to `\"A-\"`.\n   - A GPA of `0.7` (not greater than `0.7` but greater than `0.0`) maps to `\"D-\"`.\n4. **Result Construction**: Each GPA is converted to a string representation of the corresponding letter grade, and these strings are collected into a new vector which is returned as the result.\n\nThis approach efficiently maps each GPA to its correct letter grade by leveraging a straightforward conditional check sequence, ensuring correctness and optimal performance.", "\n\nTo solve this problem, we need to convert a vector of numerical GPAs into a corresponding vector of letter grades based on a predefined grading scale. The solution involves iterating through each GPA in the input vector and mapping it to the appropriate letter grade using a series of conditional checks.\n\n### Approach\n1. **Problem Analysis**: The problem requires converting each GPA in the input vector to a letter grade according to a specific grading scale. The grading scale is defined with thresholds for each letter grade, starting from the highest GPA (4.0) down to the lowest (0.0).\n2. **Key Insight**: The letter grades are assigned in descending order of GPA. For each GPA, we check the highest possible threshold first and proceed down the list until the correct grade is found.\n3. **Algorithm Selection**: We use a straightforward if-else chain to determine the letter grade for each GPA. This ensures that the highest applicable threshold is checked first, which aligns with the grading scale provided.\n4. **Edge Cases**: Special handling is required for exact values (e.g., 4.0 maps to \"A+\", 0.0 maps to \"E\") and ranges (e.g., GPAs greater than 3.7 map to \"A\").\n\n### Solution Code\n```rust\nfn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {\n    let mut result = Vec::new();\n    for grade in grades {\n        if grade == 4.0 {\n            result.push(String::from(\"A+\"));\n        } else if grade > 3.7 {\n            result.push(String::from(\"A\"));\n        } else if grade > 3.3 {\n            result.push(String::from(\"A-\"));\n        } else if grade > 3.0 {\n            result.push(String::from(\"B+\"));\n        } else if grade > 2.7 {\n            result.push(String::from(\"B\"));\n        } else if grade > 2.3 {\n            result.push(String::from(\"B-\"));\n        } else if grade > 2.0 {\n            result.push(String::from(\"C+\"));\n        } else if grade > 1.7 {\n            result.push(String::from(\"C\"));\n        } else if grade > 1.3 {\n            result.push(String::from(\"C-\"));\n        } else if grade > 1.0 {\n            result.push(String::from(\"D+\"));\n        } else if grade > 0.7 {\n            result.push(String::from(\"D\"));\n        } else if grade > 0.0 {\n            result.push(String::from(\"D-\"));\n        } else {\n            result.push(String::from(\"E\"));\n        }\n    }\n    result\n}\n```\n\n### Explanation\n1. **Initialization**: We start by initializing an empty vector `result` to store the letter grades.\n2. **Iteration**: For each GPA in the input vector `grades`, we check it against the grading thresholds in descending order.\n3. **Condition Checks**: \n   - If the GPA is exactly 4.0, it maps to \"A+\".\n   - If the GPA is greater than 3.7, it maps to \"A\".\n   - If the GPA is greater than 3.3 but not greater than 3.7, it maps to \"A-\".\n   - This pattern continues down to the lowest GPA (0.0), which maps to \"E\".\n4. **Result Construction**: For each GPA, the corresponding letter grade is converted to a `String` and added to the `result` vector.\n5. **Output**: After processing all GPAs, the `result` vector containing all letter grades is returned.\n\nThis approach efficiently maps each GPA to its correct letter grade by leveraging a straightforward if-else chain that checks the highest thresholds first, ensuring correctness and clarity. The solution handles all edge cases as specified in the problem statement.", "\n\nTo solve this problem, we need to convert a vector of numerical GPAs into a vector of corresponding letter grades based on a specific grading scale. The grading scale is defined with clear thresholds for each letter grade, and we must ensure that the conditions are checked in descending order of priority.\n\n### Approach\n1. **Problem Analysis**: The problem requires mapping each GPA in the input vector to a specific letter grade according to a predefined table. The table specifies ranges and exact values for each grade. For example:\n   - A GPA of exactly 4.0 maps to \"A+\"\n   - A GPA greater than 3.7 maps to \"A\"\n   - A GPA greater than 3.3 but not greater than 3.7 maps to \"A-\"\n   - And so on, down to a GPA of exactly 0.0 mapping to \"E\".\n\n2. **Key Insight**: The conditions must be checked in descending order of priority (from highest GPA to lowest) to ensure correct mapping. For instance, if a GPA is 3.5, it should map to \"A-\" because it is greater than 3.3 but not greater than 3.7.\n\n3. **Algorithm Selection**: We use a `match` expression to check each GPA against the predefined conditions in order. This ensures that the highest priority condition is checked first and the correct grade is selected without ambiguity.\n\n4. **Complexity Analysis**: The solution processes each GPA in the input vector exactly once, resulting in a time complexity of O(n), where n is the number of GPAs. The space complexity is O(n) to store the resulting letter grades.\n\n### Solution Code\n```rust\nfn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {\n    let mut result = Vec::new();\n    for grade in grades {\n        let grade_str = match grade {\n            4.0 => \"A+\".to_string(),\n            _ if grade > 3.7 => \"A\".to_string(),\n            _ if grade > 3.3 => \"A-\".to_string(),\n            _ if grade > 3.0 => \"B+\".to_string(),\n            _ if grade > 2.7 => \"B\".to_string(),\n            _ if grade > 2.3 => \"B-\".to_string(),\n            _ if grade > 2.0 => \"C+\".to_string(),\n            _ if grade > 1.7 => \"C\".to_string(),\n            _ if grade > 1.3 => \"C-\".to_string(),\n            _ if grade > 1.0 => \"D+\".to_string(),\n            _ if grade > 0.7 => \"D\".to_string(),\n            _ if grade > 0.0 => \"D-\".to_string(),\n            _ => \"E\".to_string(),\n        };\n        result.push(grade_str);\n    }\n    result\n}\n```\n\n### Explanation\n1. **Initialization**: We start by creating an empty vector `result` to store the letter grades.\n2. **Processing Each GPA**: For each GPA in the input vector:\n   - **Check Conditions**: Using a `match` expression, we check the GPA against each condition in descending order of priority.\n     - The first condition checks if the GPA is exactly 4.0, mapping it to \"A+\".\n     - Subsequent conditions check if the GPA is greater than specific thresholds (e.g., 3.7, 3.3, etc.), each mapping to a corresponding letter grade.\n     - If none of the conditions are met (i.e., the GPA is exactly 0.0), it maps to \"E\".\n3. **Building Result**: The matched letter grade is converted to a `String` and added to the `result` vector.\n4. **Return Result**: After processing all GPAs, the `result` vector containing all letter grades is returned.\n\nThis approach efficiently maps each GPA to its corresponding letter grade by leveraging a straightforward and ordered check of conditions, ensuring correctness and clarity. The solution handles all edge cases, including exact values and boundary conditions, as specified in the problem statement."]}
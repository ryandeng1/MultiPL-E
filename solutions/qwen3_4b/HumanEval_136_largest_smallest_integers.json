{"name": "HumanEval_136_largest_smallest_integers", "language": "rs", "prompt": "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the largest of negative integers, and 'b' is the smallest\n/// of positive integers in a vector.\n/// If there is no negative or positive integers, return them as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5, 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None, None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_136_largest_smallest_integers.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1, -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5, -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]), (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]), (Some(-3), Some(1)));\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve this problem, we need to find the largest negative integer and the smallest positive integer in a given vector of integers. If there are no negative integers, the first part of the result should be `None`; similarly, if there are no positive integers, the second part should be `None`.\n\n### Approach\n1. **Initialization**: We initialize two `Option<isize>` variables, `max_neg` and `min_pos`, to `None`. These will keep track of the largest negative integer and the smallest positive integer, respectively.\n2. **Iterate through the vector**: For each number in the input vector:\n   - **Negative numbers**: If the number is negative, we check if `max_neg` is `None` (indicating no negative numbers have been processed yet) or if the current number is larger than the stored `max_neg` (since larger negative numbers are closer to zero). If either condition is true, we update `max_neg`.\n   - **Positive numbers**: If the number is positive, we check if `min_pos` is `None` (indicating no positive numbers have been processed yet) or if the current number is smaller than the stored `min_pos` (since smaller positive numbers are closer to zero). If either condition is true, we update `min_pos`.\n3. **Return result**: After processing all numbers, we return the tuple `(max_neg, min_pos)`.\n\nThis approach efficiently processes each number exactly once, making it optimal with a time complexity of O(n), where n is the number of elements in the input vector.\n\n### Solution Code\n```rust\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_neg = None;\n    let mut min_pos = None;\n\n    for num in lst {\n        if num < 0 {\n            if max_neg.is_none() || num > max_neg.unwrap() {\n                max_neg = Some(num);\n            }\n        } else if num > 0 {\n            if min_pos.is_none() || num < min_pos.unwrap() {\n                min_pos = Some(num);\n            }\n        }\n    }\n\n    (max_neg, min_pos)\n}\n```\n\n### Explanation\n- **Initialization**: `max_neg` and `min_pos` start as `None` to indicate no negative or positive numbers have been processed yet.\n- **Processing Negatives**: For each negative number, if `max_neg` is `None` (no negatives processed) or the current number is greater than the stored `max_neg` (i.e., closer to zero), we update `max_neg` to this number.\n- **Processing Positives**: For each positive number, if `min_pos` is `None` (no positives processed) or the current number is smaller than the stored `min_pos` (i.e., the smallest positive found so far), we update `min_pos` to this number.\n- **Result**: The function returns a tuple where the first element is the largest negative integer (or `None` if none exist) and the second element is the smallest positive integer (or `None` if none exist).\n\nThis solution efficiently handles all edge cases, including empty vectors and vectors containing only zeros, by leveraging the `Option` type to safely manage the absence of required values. The code is concise and optimal, processing each element in linear time.", "\n\nTo solve this problem, we need to find the largest negative integer and the smallest positive integer in a given vector of integers. If there are no negative or positive integers in the vector, we return `None` for the respective values.\n\n### Approach\n1. **Initialization**: We initialize two variables, `max_neg` and `min_pos`, to `None`. These will store the largest negative integer and the smallest positive integer, respectively.\n2. **Iterate through the vector**: For each number in the vector:\n   - **Negative Numbers**: If the number is negative, we update `max_neg` to be the largest (closest to zero) negative number encountered so far. This is done using the `max` function to compare the current number with the existing `max_neg`.\n   - **Positive Numbers**: If the number is positive, we update `min_pos` to be the smallest positive number encountered so far. This is done using the `min` function to compare the current number with the existing `min_pos`.\n3. **Return Result**: After processing all numbers, we return the tuple `(max_neg, min_pos)`.\n\nThis approach efficiently processes each number exactly once, making it optimal with a time complexity of O(n), where n is the number of elements in the vector.\n\n### Solution Code\n```rust\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_neg = None;\n    let mut min_pos = None;\n\n    for num in lst {\n        if num < 0 {\n            max_neg = max_neg.map(|x| x.max(num)).or(Some(num));\n        } else if num > 0 {\n            min_pos = min_pos.map(|x| x.min(num)).or(Some(num));\n        }\n    }\n\n    (max_neg, min_pos)\n}\n```\n\n### Explanation\n- **Initialization**: `max_neg` and `min_pos` start as `None`, indicating that no negative or positive numbers have been processed yet.\n- **Processing Negative Numbers**: For each negative number, we check if `max_neg` is `None` (indicating no negative numbers have been processed). If so, we set `max_neg` to the current negative number. Otherwise, we compare the current number with the existing `max_neg` using `max` to ensure we keep the largest (least negative) value.\n- **Processing Positive Numbers**: Similarly, for each positive number, we check if `min_pos` is `None`. If so, we set `min_pos` to the current positive number. Otherwise, we compare the current number with the existing `min_pos` using `min` to ensure we keep the smallest positive value.\n- **Result Handling**: After processing all numbers, the function returns a tuple where the first element is the largest negative integer (or `None` if none exist) and the second element is the smallest positive integer (or `None` if none exist).\n\nThis approach efficiently handles all edge cases, including empty vectors and vectors containing only zeros, by leveraging Rust's `Option` type and the `map` and `or` methods for safe and concise updates.", "\n\nTo solve this problem, we need to find the largest negative integer and the smallest positive integer in a given vector of integers. If there are no negative integers or no positive integers, we should return `None` for the respective value.\n\n### Approach\n1. **Initialization**: We initialize two variables, `max_neg` and `min_pos`, to `None`. These will store the largest negative integer and the smallest positive integer found in the vector, respectively.\n2. **Iteration**: We iterate through each element in the vector:\n   - **Negative Integers**: For each negative integer, we check if it is larger than the current `max_neg` (i.e., closer to zero). If it is, we update `max_neg`.\n   - **Positive Integers**: For each positive integer, we check if it is smaller than the current `min_pos`. If it is, we update `min_pos`.\n3. **Result Construction**: After processing all elements, we return a tuple containing `max_neg` and `min_pos`.\n\nThis approach efficiently processes each element exactly once, resulting in a time complexity of O(n), where n is the number of elements in the vector.\n\n### Solution Code\n```rust\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_neg = None;\n    let mut min_pos = None;\n\n    for x in lst {\n        if x < 0 {\n            if let Some(current) = max_neg {\n                if x > current {\n                    max_neg = Some(x);\n                }\n            } else {\n                max_neg = Some(x);\n            }\n        } else if x > 0 {\n            if let Some(current) = min_pos {\n                if x < current {\n                    min_pos = Some(x);\n                }\n            } else {\n                min_pos = Some(x);\n            }\n        }\n    }\n\n    (max_neg, min_pos)\n}\n```\n\n### Explanation\n- **Initialization**: `max_neg` and `min_pos` start as `None`, indicating no negative or positive integers have been processed yet.\n- **Processing Elements**:\n  - For each negative integer (`x < 0`), we compare it with the current `max_neg`. If `x` is larger (closer to zero) than `max_neg`, we update `max_neg`.\n  - For each positive integer (`x > 0`), we compare it with the current `min_pos`. If `x` is smaller than `min_pos`, we update `min_pos`.\n- **Result Handling**: After processing all elements, the function returns a tuple where the first element is the largest negative integer (or `None` if none exist) and the second element is the smallest positive integer (or `None` if none exist).\n\nThis approach ensures that we efficiently track the required values while handling edge cases such as empty vectors or vectors containing only zeros correctly. The solution is optimal with a linear pass through the input vector."]}
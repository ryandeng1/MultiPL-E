{"name": "mbpp_632_move_zero", "language": "rs", "prompt": "/// Write a rsthon function to move all zeroes to the end of the given vector.\nfn move_zero(num_list: Vec<isize>) -> Vec<isize> {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_632_move_zero.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = move_zero;\n    assert_eq!(candidate(vec![1, 0, 2, 0, 3, 4]), vec![1, 2, 3, 4, 0, 0]);\n    assert_eq!(candidate(vec![2, 3, 2, 0, 0, 4, 0, 5, 0]), vec![2, 3, 2, 4, 5, 0, 0, 0, 0]);\n    assert_eq!(candidate(vec![0, 1, 0, 1, 1]), vec![1, 1, 1, 0, 0]);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nThe problem asks to write a Rust function that moves all zeros to the end of a given vector while preserving the relative order of non-zero elements. \n\nHere's the solution:\n\n```rust\nfn move_zero(num_list: Vec<isize>) -> Vec<isize> {\n    let mut non_zeros = Vec::new();\n    let mut zeros_count = 0;\n    for num in num_list {\n        if num == 0 {\n            zeros_count += 1;\n        } else {\n            non_zeros.push(num);\n        }\n    }\n    non_zeros.into_iter()\n        .chain(std::iter::repeat(0).take(zeros_count))\n        .collect()\n}\n```\n\n**Explanation:**\n1. **Initialization:** We create an empty vector `non_zeros` to store non-zero elements and a counter `zeros_count` to track the number of zeros.\n2. **Iteration:** We iterate through each element in the input vector:\n   - If the element is zero, we increment `zeros_count`.\n   - If the element is non-zero, we add it to `non_zeros`.\n3. **Result Construction:** \n   - We convert `non_zeros` into an iterator.\n   - We create a repeated zero iterator (using `std::iter::repeat(0)`) and take exactly `zeros_count` zeros.\n   - We chain these two iterators and collect the result into a new vector.\n\nThis solution efficiently moves all zeros to the end in a single pass through the input vector, maintaining the relative order of non-zero elements. The time complexity is O(n) where n is the length of the input vector, and the space complexity is O(n) for the output vector.\n\n**Note:** The term \"rsthon\" appears to be a typo for \"Rust\" (a programming language), so the solution is written in Rust as requested.", "\n\nTo solve this problem, we need to move all zeros in a given vector to the end while maintaining the relative order of the non-zero elements. The solution involves creating a new vector that first contains all non-zero elements in their original order, followed by the required number of zeros.\n\n### Approach\n1. **Filter Non-Zero Elements**: Iterate through the input vector and collect all non-zero elements into a new vector. This preserves the original order of non-zero elements.\n2. **Calculate Zero Count**: Determine how many zeros are in the original vector by subtracting the count of non-zero elements from the total elements in the vector.\n3. **Append Zeros**: Create a new vector that starts with the collected non-zero elements and appends the calculated number of zeros.\n\nThis approach efficiently separates non-zero elements from zeros and ensures the solution meets the problem requirements with a time complexity of O(n), where n is the number of elements in the input vector.\n\n### Solution Code\n```rust\nfn move_zero(num_list: Vec<isize>) -> Vec<isize> {\n    let non_zeros: Vec<isize> = num_list.into_iter()\n        .filter(|x| *x != 0)\n        .collect();\n    \n    let zeros_count = num_list.len() - non_zeros.len();\n    let mut result = non_zeros;\n    result.extend(std::iter::repeat(0).take(zeros_count));\n    result\n}\n```\n\n### Explanation\n1. **Filtering Non-Zero Elements**: The `into_iter()` method converts the input vector into an iterator. The `filter` method is used to retain only elements that are not zero (`*x != 0`). The collected elements form a new vector `non_zeros`.\n2. **Calculating Zero Count**: The number of zeros in the original vector is found by subtracting the length of `non_zeros` from the total length of the input vector (`num_list.len()`).\n3. **Constructing Result**: The result vector is initialized as a copy of `non_zeros`. The `extend` method appends the required number of zeros (calculated as `zeros_count`) using `std::iter::repeat(0).take(zeros_count)`.\n\nThis solution efficiently moves all zeros to the end of the vector while maintaining the relative order of non-zero elements, as required. The approach ensures optimal performance with minimal overhead.", "\n\nThe function `move_zero` is implemented to move all zeros to the end of the given vector while maintaining the relative order of non-zero elements. It uses a single pass through the input vector to collect non-zero elements into a new vector and counts the zeros. Finally, it appends the counted zeros to the result vector.\n\n```rust\nfn move_zero(num_list: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut zeros_count = 0;\n    for num in num_list {\n        if num != 0 {\n            result.push(num);\n        } else {\n            zeros_count += 1;\n        }\n    }\n    result.extend(vec![0; zeros_count]);\n    result\n}\n```\n\n**Explanation:**\n1. **Initialization:** A new vector `result` is created to store non-zero elements, and `zeros_count` is initialized to 0 to count zeros.\n2. **Iteration:** For each number in `num_list`:\n   - If the number is non-zero, it is added to `result`.\n   - If the number is zero, `zeros_count` is incremented.\n3. **Appending Zeros:** After processing all elements, `zeros_count` zeros are appended to `result` using `extend`.\n4. **Return:** The final `result` vector, with all zeros moved to the end, is returned.\n\nThis approach efficiently processes the input in a single pass with O(n) time complexity and O(n) space complexity (where n is the length of the input vector), maintaining the relative order of non-zero elements as required.\n\n**Example:**\n- Input: `[1, 0, 2, 0, 3]`\n- Output: `[1, 2, 3, 0, 0]`"]}
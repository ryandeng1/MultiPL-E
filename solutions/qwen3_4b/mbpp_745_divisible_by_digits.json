{"name": "mbpp_745_divisible_by_digits", "language": "rs", "prompt": "/// Write a function to find numbers within a given range from startnum ti endnum where every number is divisible by every digit it contains. https://www.w3resource.com/rsthon-exercises/lambda/rsthon-lambda-exercise-24.php\nfn divisible_by_digits(startnum: isize, endnum: isize) -> Vec<isize> {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_745_divisible_by_digits.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = divisible_by_digits;\n    assert_eq!(candidate(1, 22), vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]);\n    assert_eq!(candidate(1, 15), vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15]);\n    assert_eq!(candidate(20, 25), vec![22, 24]);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve this problem, we need to find all numbers within a given range `[startnum, endnum]` (inclusive) such that every digit in the number divides the number itself. The solution involves checking each number in the range to determine if it meets the specified condition.\n\n### Approach\n1. **Range Handling**: First, we handle the range boundaries to ensure we iterate from the smaller to the larger number. This avoids unnecessary iterations if `startnum` is greater than `endnum`.\n2. **Negative Numbers**: Skip negative numbers since the problem context typically involves positive numbers, and the digits of negative numbers (which are the same as their absolute values) might not align with the problem's intended behavior.\n3. **Digit Check**: For each non-negative number in the range:\n   - Convert the number to a string to process each digit.\n   - For each digit in the string:\n     - Skip the number if it contains a '0' (since division by zero is undefined).\n     - Check if the number is divisible by the digit (converted to an `isize` for modulo operation).\n   - If all digits satisfy the divisibility condition, include the number in the result vector.\n\n### Solution Code\n```rust\nfn divisible_by_digits(startnum: isize, endnum: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let low = if startnum <= endnum { startnum } else { endnum };\n    let high = if startnum <= endnum { endnum } else { startnum };\n    for num in low..=high {\n        if num < 0 {\n            continue;\n        }\n        let s = num.to_string();\n        let mut valid = true;\n        for c in s.chars() {\n            let d = c.to_digit(10).unwrap();\n            if d == 0 {\n                valid = false;\n                break;\n            }\n            if num % (d as isize) != 0 {\n                valid = false;\n                break;\n            }\n        }\n        if valid {\n            result.push(num);\n        }\n    }\n    result\n}\n```\n\n### Explanation\n1. **Range Handling**: The code first determines the actual range by swapping `startnum` and `endnum` if `startnum` is greater than `endnum`. This ensures the loop iterates from the smallest to the largest number in the specified range.\n2. **Negative Numbers Check**: The loop skips any negative numbers since the problem context focuses on non-negative numbers (digits are non-negative and division by zero is undefined for zero).\n3. **Digit Processing**: For each number in the range:\n   - The number is converted to a string to process each digit individually.\n   - Each digit is checked for being zero (which immediately invalidates the number).\n   - The number is checked for divisibility by each digit (converted to `isize` for modulo operation). If any digit fails the divisibility check, the number is skipped.\n4. **Result Compilation**: Numbers that pass all digit checks are added to the result vector, which is returned after processing all numbers in the range.\n\nThis approach efficiently checks each number in the specified range for the given condition, ensuring correctness while handling edge cases such as zero and negative numbers appropriately. The solution is optimized for clarity and correctness within the problem constraints.", "\n\nTo solve this problem, we need to find all numbers within a given range `[startnum, endnum]` (inclusive) where every digit in the number divides the number itself. The solution involves iterating through each number in the range, checking for the presence of any zero digits (which would make the number invalid), and then verifying that each digit divides the number without any remainder.\n\n### Approach\n1. **Iterate through the range**: For each number from `startnum` to `endnum` (inclusive).\n2. **Skip negative numbers**: Since digits are non-negative (0-9), negative numbers are skipped as they don't meet the problem's digit criteria.\n3. **Check for zero digits**: Convert the number to a string and check if it contains any '0'. If it does, skip the number.\n4. **Verify divisibility**: For each digit in the number (as an integer), check if the number is divisible by that digit without any remainder. If any digit fails this check, skip the number.\n5. **Collect valid numbers**: If all digits of a number pass the divisibility check, add the number to the result list.\n\n### Solution Code\n```rust\nfn divisible_by_digits(startnum: isize, endnum: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for num in startnum..=endnum {\n        if num < 0 {\n            continue;\n        }\n        let s = num.to_string();\n        if s.contains('0') {\n            continue;\n        }\n        let mut valid = true;\n        for c in s.chars() {\n            let digit = c.to_digit(10).unwrap() as isize;\n            if num % digit != 0 {\n                valid = false;\n                break;\n            }\n        }\n        if valid {\n            result.push(num);\n        }\n    }\n    result\n}\n```\n\n### Explanation\n1. **Initialization**: The function starts by initializing an empty vector `result` to store valid numbers.\n2. **Range Iteration**: The loop iterates over each number from `startnum` to `endnum` (inclusive).\n3. **Negative Check**: Negative numbers are skipped immediately since they cannot have valid digits (digits are 0-9).\n4. **Zero Digit Check**: The number is converted to a string to check for any '0' digits. If found, the number is skipped.\n5. **Divisibility Check**: For each digit in the string representation of the number:\n   - Convert the character to an integer.\n   - Check if the number is divisible by this digit (i.e., `num % digit == 0`).\n   - If any digit fails this check, the number is marked invalid, and the loop breaks early for efficiency.\n6. **Result Collection**: If all digits pass the divisibility check, the number is added to the result vector.\n7. **Return Result**: After processing all numbers in the range, the result vector containing all valid numbers is returned.\n\nThis approach efficiently checks each number in the specified range for the required conditions, ensuring correctness while optimizing for early termination during divisibility checks. The solution handles edge cases such as negative numbers and zero digits appropriately.", "\n\nTo solve this problem, we need to find all numbers within a given range `[startnum, endnum]` (inclusive) such that every digit in the number divides the number itself. The solution involves checking each number in the range to ensure it meets the specified condition.\n\n### Approach\n1. **Problem Analysis**: The task is to identify numbers in the range `[startnum, endnum]` where each digit of the number divides the number without any remainder. The key constraints are:\n   - The number must be positive (negative numbers and zero are skipped).\n   - The number must not contain any digit '0' (since division by zero is undefined).\n   - For each digit in the number, the number must be divisible by that digit.\n\n2. **Intuition**: For each number in the range:\n   - Skip non-positive numbers (negative numbers and zero).\n   - Convert the number to a string to process each digit individually.\n   - Check each digit to ensure it is not zero and that the number is divisible by the digit.\n   - If all digits satisfy the condition, include the number in the result list.\n\n3. **Algorithm Selection**:\n   - Iterate over each number from `startnum` to `endnum` (inclusive).\n   - For each number, skip if it is non-positive.\n   - Convert the number to a string to access each digit.\n   - For each digit in the string:\n     - Convert the digit to an integer.\n     - Skip if the digit is zero.\n     - Check if the number is divisible by the digit (using modulus operation).\n   - If all digits pass the check, add the number to the result list.\n\n4. **Complexity Analysis**:\n   - **Time Complexity**: O(n * d), where `n` is the number of elements in the range `[startnum, endnum]` and `d` is the average number of digits per number. For small ranges (as typical in such exercises), this is efficient.\n   - **Space Complexity**: O(k), where `k` is the number of valid numbers found in the range (to store the result).\n\n### Solution Code\n```rust\nfn divisible_by_digits(startnum: isize, endnum: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for n in startnum..=endnum {\n        if n <= 0 {\n            continue;\n        }\n        let s = n.to_string();\n        let mut valid = true;\n        for c in s.chars() {\n            let d = c.to_digit(10).unwrap();\n            if d == 0 {\n                valid = false;\n                break;\n            }\n            if n % (d as isize) != 0 {\n                valid = false;\n                break;\n            }\n        }\n        if valid {\n            result.push(n);\n        }\n    }\n    result\n}\n```\n\n### Explanation\n1. **Initialization**: We start by creating an empty vector `result` to store valid numbers.\n2. **Iteration**: We iterate over each number `n` from `startnum` to `endnum` (inclusive).\n3. **Non-positive Check**: If `n` is non-positive (zero or negative), we skip it immediately.\n4. **Digit Processing**: For each valid positive number `n`:\n   - Convert `n` to a string to process each digit.\n   - For each character in the string:\n     - Convert the character to a digit (as a `u32`).\n     - If the digit is zero, mark the number as invalid and break out of the loop.\n     - Check if `n` is divisible by the digit (using `n % (digit as isize) == 0`). If not, mark as invalid and break.\n5. **Result Collection**: If all digits of `n` pass the checks, add `n` to the result vector.\n6. **Return Result**: After processing all numbers, return the result vector containing all valid numbers.\n\nThis approach efficiently checks each number in the specified range for the given condition, ensuring correctness while handling edge cases like zero and non-positive numbers appropriately. The solution is optimal for typical problem constraints as seen in the referenced exercise."]}
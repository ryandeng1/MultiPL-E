{"name": "mbpp_743_rotate_right", "language": "rs", "prompt": "/// Write a function to rotate a given vector by specified number of items to the right direction. https://www.geeksforgeeks.org/rsthon-program-right-rotate-vector-n/\nfn rotate_right(list: Vec<isize>, m: isize) -> Vec<isize> {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_743_rotate_right.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = rotate_right;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3), vec![8, 9, 10, 1, 2, 3, 4, 5, 6, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2), vec![9, 10, 1, 2, 3, 4, 5, 6, 7, 8]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5), vec![6, 7, 8, 9, 10, 1, 2, 3, 4, 5]);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo rotate a given vector to the right by a specified number of items, we normalize the rotation count `m` to a value within the range `[0, n-1]` (where `n` is the length of the vector) using `rem_euclid`. This handles negative values and large rotations by converting them into equivalent positive rotations. The rotated vector is then constructed by taking the last `m` elements of the original vector followed by the first `n - m` elements.\n\n### Approach\n1. **Handle Empty Vector**: If the input vector is empty, return it as is.\n2. **Normalize Rotation Count**: Compute `m` modulo the vector length `n` to ensure it is in the range `[0, n-1]`. This step handles negative rotations and rotations larger than the vector length by converting them to equivalent positive rotations.\n3. **Construct Result Vector**: \n   - The result vector starts with the last `m` elements of the original vector.\n   - It is followed by the first `n - m` elements of the original vector.\n\n### Solution Code\n```rust\nfn rotate_right(list: Vec<isize>, m: isize) -> Vec<isize> {\n    let n = list.len();\n    if n == 0 {\n        return list;\n    }\n    let m = m.rem_euclid(n);\n    let start = n - m;\n    list[start..].iter().cloned().chain(list[0..start].iter()).cloned().collect()\n}\n```\n\n### Explanation\n1. **Empty Vector Check**: If the vector `list` is empty (length `n = 0`), the function immediately returns the original vector.\n2. **Normalization of `m`**: The rotation count `m` is normalized using `m.rem_euclid(n)`. This ensures `m` is a non-negative integer in the range `[0, n-1]`, effectively handling any integer value of `m` (including negatives and values larger than `n`).\n3. **Vector Construction**: \n   - The slice `list[start..]` (where `start = n - m`) contains the last `m` elements of the original vector.\n   - The slice `list[0..start]` contains the first `n - m` elements.\n   - The result vector is formed by concatenating these two slices: the last `m` elements followed by the first `n - m` elements.\n\nThis approach efficiently constructs the rotated vector in linear time with constant space overhead (for the slices), making it optimal for the given problem. The normalization step ensures the solution handles all edge cases, including negative rotations and large rotation counts, by leveraging modular arithmetic.", "\n\nTo rotate a vector to the right by `m` positions, we handle the following steps:\n1. If the vector is empty, return it as is.\n2. Normalize `m` to a value within the range `[0, n-1]` where `n` is the length of the vector. This involves:\n   - Taking `m % n` to reduce `m` modulo the vector length.\n   - If the result is negative, adjust it by adding `n` to get a positive equivalent.\n3. Calculate the split index `k = n - m` (the starting point of the first segment).\n4. Construct the rotated vector by concatenating:\n   - The segment from index `k` to the end of the vector.\n   - The segment from the start of the vector to index `k`.\n\nThis approach efficiently handles any integer `m` (positive or negative) by converting it to an equivalent positive rotation count within one full cycle of the vector.\n\n```rust\nfn rotate_right(list: Vec<isize>, m: isize) -> Vec<isize> {\n    let n = list.len();\n    if n == 0 {\n        return list;\n    }\n\n    let m = m % n;\n    if m < 0 {\n        m += n;\n    }\n    let k = n - m;\n\n    list[k..].iter().cloned().chain(list[..k].iter().cloned()).collect()\n}\n```\n\n**Explanation**:\n- **Empty Vector Check**: If the input vector is empty, it is returned immediately.\n- **Normalization of `m`**: \n  - `m % n` ensures `m` is within the range `[-n+1, n-1]` (for negative `m`).\n  - Adjusting negative values by adding `n` converts `m` to a positive equivalent in `[0, n-1]`.\n- **Split Index `k`**: This index determines where the vector is split. The segment `[k, n)` (last `m` elements) becomes the prefix of the result, and the segment `[0, k)` (first `n-m` elements) becomes the suffix.\n- **Vector Construction**: Using `chain` to concatenate the two segments efficiently creates the rotated vector.\n\nThis solution handles all edge cases (including negative rotations) and operates in O(n) time with O(n) space complexity, which is optimal for this problem.", "\n\nTo solve this problem, we need to rotate a given vector to the right by a specified number of items. A right rotation by `m` positions means that the last `m` elements of the vector become the first `m` elements, and the remaining elements follow in their original order.\n\n### Approach\n1. **Handle Empty Vector**: If the input vector is empty, return it as is.\n2. **Normalize Rotation Count**: \n   - Convert the vector length `n` to `isize` for modulo operations.\n   - Compute `m % n` to handle cases where `m` is larger than the vector length (since rotating by `n` positions is equivalent to no rotation).\n   - Adjust `m` to be non-negative by adding `n` if it is negative (to handle negative rotations, though the problem specifies positive rotations).\n3. **Check for Zero Rotation**: If the normalized `m` is zero, return the original vector.\n4. **Split and Reconstruct Vector**:\n   - Split the vector into two parts: the last `m` elements (part2) and the first `n - m` elements (part1).\n   - Concatenate part2 followed by part1 to form the rotated vector.\n\n### Solution Code\n```rust\nfn rotate_right(list: Vec<isize>, m: isize) -> Vec<isize> {\n    let n = list.len();\n    if n == 0 {\n        return list;\n    }\n\n    let n = n as isize;\n    let m = m % n;\n    if m < 0 {\n        m += n;\n    }\n\n    if m == 0 {\n        return list;\n    }\n\n    let start = (n - m) as usize;\n    let part2 = list[start..].to_vec();\n    let part1 = list[..start].to_vec();\n    part2.into_iter().chain(part1.into_iter()).collect()\n}\n```\n\n### Explanation\n1. **Empty Vector Check**: The function first checks if the input vector `list` is empty. If so, it returns the vector unchanged.\n2. **Normalization of `m`**:\n   - The vector length `n` is converted to `isize` to perform modulo operations with `m`.\n   - The modulo operation `m % n` adjusts `m` to be within the range `[0, n-1]`. If `m` is negative, it is adjusted by adding `n` to ensure it is non-negative.\n3. **Zero Rotation Check**: If the normalized `m` is zero, the function returns the original vector since no rotation is needed.\n4. **Splitting and Reconstructing**:\n   - The vector is split into two parts at index `start = n - m` (converted to `usize` for valid indexing).\n   - The second part (from `start` to the end of the vector) is concatenated with the first part (from the start to `start - 1`) to form the rotated vector.\n   - The result is a new vector where the last `m` elements of the original vector precede the first `n - m` elements.\n\nThis approach efficiently handles rotations by leveraging vector slicing and concatenation, ensuring optimal performance with a time complexity of O(n), where `n` is the length of the vector. The solution also correctly handles edge cases such as empty vectors and large or negative rotation counts."]}
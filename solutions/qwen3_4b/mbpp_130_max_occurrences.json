{"name": "mbpp_130_max_occurrences", "language": "rs", "prompt": "/// Write a function to find the item with maximum frequency in a given vector.\nfn max_occurrences(nums: Vec<isize>) -> isize {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_130_max_occurrences.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = max_occurrences;\n    assert_eq!(candidate(vec![2, 3, 8, 4, 7, 9, 8, 2, 6, 5, 1, 6, 1, 2, 3, 2, 4, 6, 9, 1, 2]), 2);\n    assert_eq!(candidate(vec![2, 3, 8, 4, 7, 9, 8, 7, 9, 15, 14, 10, 12, 13, 16, 18]), 8);\n    assert_eq!(candidate(vec![10, 20, 20, 30, 40, 90, 80, 50, 30, 20, 50, 10]), 20);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve the problem of finding the item with the maximum frequency in a given vector of `isize` values, we can use a **hash map** to efficiently count the occurrences of each item. This approach ensures optimal performance with a time complexity of $O(n)$, where $n$ is the number of elements in the vector.\n\n### Approach\n1. **Frequency Counting**: We iterate through the input vector and use a hash map to count how many times each `isize` value appears.\n2. **Finding Maximum Frequency**: After populating the hash map, we iterate through its entries to find the key (item) with the highest count (frequency).\n\nThis approach efficiently handles both positive and negative values and works correctly even when multiple items have the same maximum frequency (it returns the first such item encountered during iteration).\n\n### Solution Code\n```rust\nuse std::collections::HashMap;\n\nfn max_occurrences(nums: Vec<isize>) -> isize {\n    let mut freq_map = HashMap::new();\n    for &num in &nums {\n        *freq_map.entry(num).or_insert(0) += 1;\n    }\n\n    let mut max_count = 0;\n    let mut max_num = 0;\n    for (num, count) in &freq_map {\n        if *count > max_count {\n            max_count = *count;\n            max_num = *num;\n        }\n    }\n    max_num\n}\n```\n\n### Explanation\n1. **Initialization**: We start by creating an empty `HashMap` to store the frequency of each `isize` value.\n2. **Counting Frequencies**: For each value in the input vector, we update its count in the hash map. The `entry` method ensures that each value is processed in constant time.\n3. **Finding the Maximum**: After processing all values, we iterate through the hash map to find the value with the highest frequency. We initialize `max_count` to 0 and `max_num` to 0 (safe since the input vector is non-empty).\n4. **Result**: The function returns `max_num`, which is the item with the highest frequency in the input vector.\n\nThis solution efficiently handles all edge cases, including negative numbers and ties in frequency, and adheres to the problem's requirements. The use of a hash map ensures optimal performance for large input sizes.", "\n\nTo solve this problem, we need to find the item (number) with the highest frequency in a given vector of integers. The solution involves counting the occurrences of each number and then identifying the number that appears most frequently.\n\n### Approach\n1. **Problem Analysis**: The task is to determine which number in the vector appears most frequently. If multiple numbers have the same highest frequency, any one of them can be returned as the solution (the problem does not specify which one to choose in such cases).\n2. **Intuition**: We can use a hash map to count the occurrences of each number in the vector. This allows efficient counting and retrieval of frequencies.\n3. **Algorithm Selection**: \n   - **Counting Frequencies**: Iterate through each number in the vector and update its count in the hash map.\n   - **Finding Maximum Frequency**: After processing all numbers, iterate through the hash map to find the number with the highest count. If there are ties, the first number encountered with the highest count is returned.\n4. **Optimization**: Using a hash map ensures O(n) time complexity for counting and O(m) time complexity for finding the maximum frequency, where m is the number of distinct elements in the vector. This is efficient for large vectors.\n5. **Edge Cases**: The solution handles empty vectors by returning 0 (as specified in the problem context).\n\n### Solution Code\n```rust\nuse std::collections::HashMap;\n\nfn max_occurrences(nums: Vec<isize>) -> isize {\n    let mut count_map = HashMap::new();\n    for num in nums {\n        *count_map.entry(num).or_insert(0) += 1;\n    }\n\n    count_map.iter()\n        .max_by(|(_, count1), (_, count2)| count1.cmp(count2))\n        .map(|(num, _)| *num)\n        .unwrap_or(0)\n}\n```\n\n### Explanation\n1. **Initialization**: A new `HashMap` is created to store counts of each number encountered in the vector.\n2. **Counting Frequencies**: For each number in the input vector, the corresponding count in the hash map is incremented. The `entry` method ensures that each number is processed efficiently.\n3. **Finding Maximum Frequency**: The hash map is iterated to find the number with the highest count. The `max_by` method compares counts using `cmp` to determine the maximum. If multiple numbers have the same highest count, the first one encountered is chosen.\n4. **Handling Empty Vectors**: If the input vector is empty, the `max_by` returns `None`, and `unwrap_or(0)` ensures the function returns 0 as a fallback.\n\nThis approach efficiently solves the problem with optimal time complexity and handles all edge cases, including empty vectors, as specified. The solution is both clear and concise, leveraging Rust's standard library for robust and readable code.", "\n\nTo solve this problem, we need to find the item (number) with the highest frequency in a given vector of integers. The solution involves counting the occurrences of each number and then identifying the number that appears most frequently.\n\n### Approach\n1. **Check for Empty Vector**: If the input vector is empty, return 0 (as the problem implies the vector has at least one element, but this handles edge cases).\n2. **Count Frequencies**: Use a hash map to count the occurrences of each number in the vector. This allows efficient counting with O(n) time complexity, where n is the number of elements in the vector.\n3. **Find Maximum Frequency**: Iterate through the hash map to find the number with the highest frequency. During this iteration, we keep track of the number with the highest count encountered so far. If multiple numbers have the same highest frequency, the first one encountered (based on insertion order) is returned.\n\n### Solution Code\n```rust\nfn max_occurrences(nums: Vec<isize>) -> isize {\n    if nums.is_empty() {\n        return 0;\n    }\n    let mut count_map = std::collections::HashMap::new();\n    for num in nums {\n        *count_map.entry(num).or_insert(0) += 1;\n    }\n\n    let mut max_count = 0;\n    let mut max_num = 0;\n    for (num, count) in count_map {\n        if count > max_count {\n            max_count = count;\n            max_num = num;\n        }\n    }\n    max_num\n}\n```\n\n### Explanation\n1. **Empty Vector Check**: The function first checks if the input vector is empty. If it is, the function returns 0 to handle the edge case gracefully.\n2. **Frequency Counting**: A hash map (`count_map`) is initialized to store each number from the vector as a key with its occurrence count as the value. For each number in the vector, the count is incremented in the hash map.\n3. **Finding Maximum Frequency**: The function then iterates through the hash map to find the number with the highest count. The variables `max_count` and `max_num` are updated whenever a number with a higher count is encountered. This ensures that the first number with the highest frequency (based on insertion order) is returned if there are ties.\n\nThis approach efficiently counts frequencies and determines the most frequent number in linear time, making it optimal for large vectors. The solution handles edge cases like empty vectors and ensures correctness for all valid inputs."]}
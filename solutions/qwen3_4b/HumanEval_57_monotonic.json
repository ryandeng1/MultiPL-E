{"name": "HumanEval_57_monotonic", "language": "rs", "prompt": "/// Return true is vector elements are monotonically increasing or decreasing.\n/// >>> monotonic(vec![1, 2, 4, 20])\n/// true\n/// >>> monotonic(vec![1, 20, 4, 10])\n/// false\n/// >>> monotonic(vec![4, 1, 0, -10])\n/// true\nfn monotonic(l: Vec<isize>) -> bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_57_monotonic.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = monotonic;\n    assert_eq!(candidate(vec![1, 2, 4, 10]), true);\n    assert_eq!(candidate(vec![1, 2, 4, 20]), true);\n    assert_eq!(candidate(vec![1, 20, 4, 10]), false);\n    assert_eq!(candidate(vec![4, 1, 0, -10]), true);\n    assert_eq!(candidate(vec![4, 1, 1, 0]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 5, 60]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 60]), true);\n    assert_eq!(candidate(vec![9, 9, 9, 9]), true);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo determine if a vector of integers is **monotonically increasing** or **monotonically decreasing**, we need to check that each element is strictly less than the next (for increasing) or strictly greater than the next (for decreasing). The solution involves a single pass through the vector to verify this condition.\n\n### Approach\n1. **Edge Case Handling**: Vectors with 0 or 1 elements are trivially monotonic.\n2. **Initial Check**: Compare the first two elements to determine the direction:\n   - If they are equal, return `false` (not strictly monotonic).\n   - If the first element is less than the second, the sequence is potentially increasing.\n   - If the first element is greater than the second, the sequence is potentially decreasing.\n3. **Consistency Check**: For all subsequent pairs of elements, ensure they continue in the determined direction (either strictly increasing or strictly decreasing). If any pair violates this, return `false`.\n\nThis approach efficiently checks for strict monotonicity in a single pass through the vector, ensuring optimal performance with O(n) time complexity.\n\n### Solution Code\n```rust\nfn monotonic(l: Vec<isize>) -> bool {\n    let n = l.len();\n    if n <= 1 {\n        return true;\n    }\n\n    if l[0] < l[1] {\n        for i in 1..n-1 {\n            if l[i] >= l[i+1] {\n                return false;\n            }\n        }\n        return true;\n    } else if l[0] > l[1] {\n        for i in 1..n-1 {\n            if l[i] <= l[i+1] {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        return false;\n    }\n}\n```\n\n### Explanation\n1. **Edge Handling**: The function first checks if the vector has 0 or 1 elements, returning `true` immediately since such vectors are trivially monotonic.\n2. **Direction Determination**: The first two elements determine the direction:\n   - If `l[0] < l[1]`, the sequence is checked for strict increasing order.\n   - If `l[0] > l[1]`, the sequence is checked for strict decreasing order.\n   - If `l[0] == l[1]`, the function returns `false` since equal elements break strict monotonicity.\n3. **Consistency Check**: For each subsequent pair of elements, the function verifies they maintain the direction established by the first pair. If any pair violates this direction, the function returns `false`.\n\nThis approach ensures that the solution is both efficient and correct for all valid inputs, adhering to the problem's requirement of strict monotonicity (neither non-strict nor allowing equal elements). \n\n**Final Answer**:\n```rust\nfn monotonic(l: Vec<isize>) -> bool {\n    let n = l.len();\n    if n <= 1 {\n        return true;\n    }\n\n    if l[0] < l[1] {\n        for i in 1..n-1 {\n            if l[i] >= l[i+1] {\n                return false;\n            }\n        }\n        return true;\n    } else if l[0] > l[1] {\n        for i in 1..n-1 {\n            if l[i] <= l[i+1] {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        return false;\n    }\n}\n```", "\n\nTo determine if a vector of integers is monotonically increasing or decreasing (allowing non-strict comparisons), we check two conditions:\n1. **Non-decreasing**: Each element is less than or equal to the next element (`l[i] <= l[i+1]`).\n2. **Non-increasing**: Each element is greater than or equal to the next element (`l[i] >= l[i+1]`).\n\nThe solution handles edge cases (vectors with 0 or 1 element) by returning `true` immediately. For longer vectors, it iterates through the vector once, tracking whether the vector satisfies either condition. If both conditions fail at any point, it breaks early for efficiency.\n\n```rust\nfn monotonic(l: Vec<isize>) -> bool {\n    if l.len() <= 1 {\n        return true;\n    }\n\n    let mut non_decreasing = true;\n    let mut non_increasing = true;\n\n    for i in 0..l.len() - 1 {\n        if l[i] > l[i+1] {\n            non_decreasing = false;\n        }\n        if l[i] < l[i+1] {\n            non_increasing = false;\n        }\n        if !non_decreasing && !non_increasing {\n            break;\n        }\n    }\n\n    non_decreasing || non_increasing\n}\n```\n\n**Explanation**:\n- **Edge Case Handling**: Vectors with 0 or 1 element are trivially monotonic (return `true`).\n- **Tracking Conditions**: \n  - `non_decreasing` is `true` initially and set to `false` if any element is greater than the next.\n  - `non_increasing` is `true` initially and set to `false` if any element is less than the next.\n- **Early Termination**: If both conditions become `false` during iteration, the loop breaks early to avoid unnecessary checks.\n- **Result**: Returns `true` if either condition (`non_decreasing` or `non_increasing`) is still `true` after checking all elements.\n\nThis approach efficiently checks for monotonic behavior with optimal performance (O(n) time, O(1) space). The solution handles all cases, including constant vectors (which are both non-decreasing and non-increasing) and vectors with duplicates. \n\n**Example Usage**:\n```rust\nassert_eq!(monotonic(vec![1, 2, 4, 20]), true);\nassert_eq!(monotonic(vec![1, 20, 4, 10]), false);\nassert_eq!(monotonic(vec![4, 1, 0, -10]), true);\nassert_eq!(monotonic(vec![5, 5, 5]), true);\nassert_eq!(monotonic(vec![1, 1, 2]), true);\nassert_eq!(monotonic(vec![2, 1, 1]), true);\nassert_eq!(monotonic(vec![1, 2, 1]), false);\n```", "\n\nTo determine if a vector of integers is **monotonically increasing** or **monotonically decreasing**, we need to check if the sequence is either **non-decreasing** (each element is less than or equal to the next) or **non-increasing** (each element is greater than or equal to the next).\n\n---\n\n### \u2705 Key Observations:\n- A vector with **0 or 1 elements** is trivially monotonic.\n- For vectors with **more than one element**, we check:\n  - If the sequence is **non-decreasing**: for all `i`, `l[i] <= l[i+1]`\n  - If the sequence is **non-increasing**: for all `i`, `l[i] >= l[i+1]`\n- The function returns `true` if **either** condition holds.\n\n---\n\n### \ud83e\udde0 Approach:\n1. Handle edge cases: return `true` for empty or single-element vectors.\n2. Initialize two flags:\n   - `is_increasing`: `true` if the vector is non-decreasing\n   - `is_decreasing`: `true` if the vector is non-increasing\n3. Iterate through the vector and update the flags:\n   - If any element is **greater than** the next \u2192 `is_increasing = false`\n   - If any element is **less than** the next \u2192 `is_decreasing = false`\n4. Return `is_increasing || is_decreasing`\n\nThis ensures that the function correctly identifies sequences that are **non-decreasing** or **non-increasing**.\n\n---\n\n### \u2705 Final Implementation:\n\n```rust\nfn monotonic(l: Vec<isize>) -> bool {\n    if l.len() <= 1 {\n        return true;\n    }\n\n    let mut is_increasing = true;\n    let mut is_decreasing = true;\n\n    for i in 0..l.len() - 1 {\n        if l[i] > l[i+1] {\n            is_increasing = false;\n        }\n        if l[i] < l[i+1] {\n            is_decreasing = false;\n        }\n    }\n\n    is_increasing || is_decreasing\n}\n```\n\n---\n\n### \ud83e\uddea Example Test Cases:\n\n| Input                  | Output | Explanation                                  |\n|------------------------|--------|-----------------------------------------------|\n| `[1, 2, 4, 20]`        | `true` | Strictly increasing (non-decreasing)         |\n| `[1, 20, 4, 10]`       | `false`| Not non-decreasing or non-increasing         |\n| `[4, 1, 0, -10]`       | `true` | Strictly decreasing (non-increasing)         |\n| `[5, 5, 5]`            | `true` | All elements equal (both non-decreasing and non-increasing) |\n| `[3, 2, 1, 2]`         | `false`| Not non-decreasing or non-increasing         |\n\n---\n\n### \ud83d\udca1 Why This Works:\n- The loop efficiently checks the direction of the sequence.\n- The flags are updated as soon as a violation of monotonicity is found.\n- Handles all edge cases including single-element and empty vectors (though the problem examples assume non-empty inputs).\n\nThis solution is both **efficient** (O(n) time) and **correct** for the given problem statement.\n\n---\n\n### \u2705 Final Answer:\n```rust\nfn monotonic(l: Vec<isize>) -> bool {\n    if l.len() <= 1 {\n        return true;\n    }\n\n    let mut is_increasing = true;\n    let mut is_decreasing = true;\n\n    for i in 0..l.len() - 1 {\n        if l[i] > l[i+1] {\n            is_increasing = false;\n        }\n        if l[i] < l[i+1] {\n            is_decreasing = false;\n        }\n    }\n\n    is_increasing || is_decreasing\n}\n```"]}
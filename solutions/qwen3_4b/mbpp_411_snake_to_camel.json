{"name": "mbpp_411_snake_to_camel", "language": "rs", "prompt": "/// Write a function to convert the given snake case string to camel case string.\nfn snake_to_camel(word: String) -> String {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_411_snake_to_camel.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = snake_to_camel;\n    assert_eq!(candidate(String::from(\"android_tv\")), String::from(\"AndroidTv\"));\n    assert_eq!(candidate(String::from(\"google_pixel\")), String::from(\"GooglePixel\"));\n    assert_eq!(candidate(String::from(\"apple_watch\")), String::from(\"AppleWatch\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo convert a snake case string to camel case, we split the string by underscores, filter out any empty parts (to handle cases with consecutive underscores or leading/trailing underscores), and then process each part. The first part is added to the result as-is (in lowercase), and each subsequent part has its first character converted to uppercase followed by the rest of the characters.\n\nHere's the implementation:\n\n```rust\nfn snake_to_camel(word: String) -> String {\n    let parts: Vec<&str> = word.split('_').filter(|s| !s.is_empty()).collect();\n    let mut result = String::new();\n    for (i, part) in parts.iter().enumerate() {\n        if i == 0 {\n            result.push_str(part);\n        } else {\n            result.push(part[0].to_ascii_uppercase());\n            result.push_str(&part[1..]);\n        }\n    }\n    result\n}\n```\n\n**Explanation:**\n1. **Split and Filter:** The input string is split by underscores (`split('_')`), and empty strings are filtered out (`filter(|s| !s.is_empty())`) to handle invalid snake case inputs (like consecutive underscores or leading/trailing underscores).\n2. **Process Parts:** \n   - For the first part (index `0`), the entire string is added to the result.\n   - For subsequent parts (index `> 0`), the first character is converted to uppercase using `to_ascii_uppercase()` (for ASCII compatibility), and the rest of the string is appended as-is.\n3. **Efficiency:** Using `part[0]` directly for character access is efficient and avoids unnecessary iterator operations.\n\n**Example Usage:**\n- Input: `\"hello_world\"` \u2192 Output: `\"helloWorld\"`\n- Input: `\"my_var\"` \u2192 Output: `\"myVar\"`\n- Input: `\"a__b\"` \u2192 Output: `\"aB\"` (empty parts are filtered out)\n\nThis solution handles standard snake case inputs and ensures the output is correctly formatted in camel case.", "\n\nTo convert a snake case string to camel case, we split the input string by underscores to get individual tokens. We then process each token: the first token is added to the result as-is (in lowercase), and each subsequent token has its first character converted to uppercase followed by the rest of the token. Empty tokens are skipped to handle any potential edge cases like consecutive underscores.\n\nHere's the implementation:\n\n```rust\nfn snake_to_camel(word: String) -> String {\n    let tokens: Vec<&str> = word.split('_').collect();\n    let mut result = String::new();\n    for (i, token) in tokens.iter().enumerate() {\n        if token.is_empty() {\n            continue;\n        }\n        if i == 0 {\n            result.push_str(token);\n        } else {\n            let first_char = token.chars().next().unwrap().to_ascii_uppercase();\n            result.push(first_char);\n            result.push_str(&token[1..]);\n        }\n    }\n    result\n}\n```\n\n**Explanation:**\n1. **Split Tokens:** The input string is split into tokens using the underscore (`'_'`) as the delimiter.\n2. **Skip Empty Tokens:** Empty tokens (from consecutive underscores or leading/trailing underscores) are skipped.\n3. **First Token:** The first token is added to the result without any changes (as it should start with a lowercase letter in camel case).\n4. **Subsequent Tokens:** For each subsequent token:\n   - The first character is converted to uppercase (using `to_ascii_uppercase` for ASCII compatibility).\n   - The rest of the token (from index 1 onwards) is appended to the result.\n5. **Result Construction:** The result is built incrementally by appending processed tokens.\n\nThis approach efficiently handles standard snake case strings while being robust against common edge cases like empty tokens, ensuring the output is correctly formatted in camel case.\n\n**Example Usage:**\n- Input: `\"hello_world\"` \u2192 Output: `\"helloWorld\"`\n- Input: `\"a_b\"` \u2192 Output: `\"aB\"`\n- Input: `\"a\"` \u2192 Output: `\"a\"`\n- Input: `\"__\"` (empty tokens) \u2192 Output: `\"\"` (empty string)", "\n\nTo convert a snake case string to camel case, we split the string by underscores, filter out any empty strings (to handle cases with consecutive underscores), and then process each word. The first word is converted to lowercase. Each subsequent word has its first character converted to uppercase and the rest converted to lowercase, then appended to the result.\n\nHere's the implementation:\n\n```rust\nfn snake_to_camel(word: String) -> String {\n    let words: Vec<&str> = word.split('_').filter(|s| !s.is_empty()).collect();\n    if words.is_empty() {\n        return word;\n    }\n    let mut result = words[0].to_string();\n    for w in &words[1..] {\n        let first_char = w.chars().next().unwrap().to_ascii_uppercase();\n        result.push_str(&first_char.to_string());\n        result.push_str(&w[1..].to_lowercase());\n    }\n    result\n}\n```\n\n**Explanation:**\n1. **Split and Filter:** The input string is split by underscores into a vector of substrings. Empty strings from consecutive underscores are filtered out.\n2. **Handle Empty Input:** If the result is empty (unlikely for valid snake case), return the original string.\n3. **Process First Word:** The first word is converted to lowercase and becomes the initial part of the result.\n4. **Process Subsequent Words:** For each subsequent word:\n   - The first character is converted to ASCII uppercase (preserving non-alphabet characters).\n   - The rest of the word is converted to lowercase.\n   - These parts are appended to the result string.\n\nThis approach efficiently handles typical snake case inputs (including numbers) and produces a valid camel case string.\n\n**Example Usage:**\n- Input: `\"hello_world\"` \u2192 Output: `\"helloWorld\"`\n- Input: `\"a_b_c_123\"` \u2192 Output: `\"aBc123\"`\n- Input: `\"__hello__\"` \u2192 Output: `\"hello\"` (after filtering empty strings)"]}
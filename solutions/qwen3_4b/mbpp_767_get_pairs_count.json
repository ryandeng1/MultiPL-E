{"name": "mbpp_767_get_pairs_count", "language": "rs", "prompt": "/// Write a rsthon function to count the number of pairs whose sum is equal to \u2018sum\u2019. The funtion gets as input a vector of numbers and the sum,\nfn get_pairs_count(arr: Vec<isize>, sum: isize) -> isize {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_767_get_pairs_count.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = get_pairs_count;\n    assert_eq!(candidate(vec![1, 1, 1, 1], 2), 6);\n    assert_eq!(candidate(vec![1, 5, 7, -1, 5], 6), 3);\n    assert_eq!(candidate(vec![1, -2, 3], 1), 1);\n    assert_eq!(candidate(vec![-1, -2, 3], -3), 1);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve this problem, we need to count the number of distinct pairs of indices (i, j) in a given vector of integers such that i < j and the sum of the elements at these indices equals a specified target sum. The solution efficiently handles duplicates and negative numbers by using a frequency map to track occurrences of each number.\n\n### Approach\n1. **Frequency Map Construction**: First, we iterate through the input vector to build a frequency map (hash map) where each key is a number from the vector, and the value is the count of how many times that number appears in the vector.\n2. **Pair Counting**: For each unique number `a` in the frequency map:\n   - Calculate the complementary number `b` as `sum - a`.\n   - Check if `b` exists in the frequency map.\n   - To avoid double counting pairs (a, b) where `a` and `b` are distinct, we only consider pairs where `a <= b`.\n   - If `a` equals `b`, the number of valid pairs is the combination of `cnt_a` taken 2 at a time (i.e., `cnt_a * (cnt_a - 1) / 2`).\n   - If `a` is less than `b`, the number of valid pairs is the product of the counts of `a` and `b` (i.e., `cnt_a * cnt_b`).\n\nThis approach efficiently counts all valid pairs in O(n) time with O(n) space complexity, where n is the number of elements in the input vector.\n\n### Solution Code\n```rust\nuse std::collections::HashMap;\n\nfn get_pairs_count(arr: Vec<isize>, sum: isize) -> isize {\n    let mut freq = HashMap::new();\n    for num in arr {\n        *freq.entry(num).or_insert(0) += 1;\n    }\n\n    let mut count = 0;\n    for (a, cnt_a) in freq {\n        let b = sum - a;\n        if let Some(cnt_b) = freq.get(&b) {\n            if a <= b {\n                if a == b {\n                    count += cnt_a * (cnt_a - 1) / 2;\n                } else {\n                    count += cnt_a * cnt_b;\n                }\n            }\n        }\n    }\n    count\n}\n```\n\n### Explanation\n1. **Frequency Map Construction**: The code starts by iterating over each number in the input vector `arr` and populating a hash map `freq` where each key is a number from `arr`, and the value is its frequency (count of occurrences).\n2. **Pair Counting**:\n   - For each unique number `a` in `freq`, the complementary number `b` is computed as `sum - a`.\n   - If `b` exists in `freq` and `a <= b` (to avoid double counting), the code checks:\n     - If `a` equals `b`, it calculates the number of pairs as combinations of two distinct indices from `cnt_a` elements (using the formula `cnt_a * (cnt_a - 1) / 2`).\n     - If `a` is less than `b`, it adds the product of the frequencies of `a` and `b` to the total count.\n3. **Result**: The accumulated count after processing all unique numbers in `freq` gives the total number of distinct pairs (i, j) where i < j and `arr[i] + arr[j] = sum`.\n\nThis method efficiently handles all edge cases, including negative numbers, duplicates, and large input sizes, by leveraging a hash map for constant-time lookups and a single pass through the frequency map to count pairs. The solution ensures optimal performance with O(n) time and space complexity.", "\n\nThe function `get_pairs_count` uses a hash map to efficiently count the number of pairs in the input vector where the sum of the pair equals the specified `sum`. It processes each element in the vector, checks for the complement (i.e., `sum - current element`) in the hash map, and accumulates the count of valid pairs. The hash map keeps track of the frequency of each element encountered so far to handle duplicates correctly.\n\n```rust\nfn get_pairs_count(arr: Vec<isize>, sum: isize) -> isize {\n    let mut freq = std::collections::HashMap::new();\n    let mut count = 0;\n    for num in arr {\n        let complement = sum - num;\n        if let Some(cnt) = freq.get(&complement) {\n            count += *cnt;\n        }\n        *freq.entry(num).or_insert(0) += 1;\n    }\n    count\n}\n```\n\n**Explanation:**\n1. **Initialization:** A `HashMap` `freq` is created to store the frequency of each number encountered. The `count` variable is initialized to 0.\n2. **Iteration:** For each number `num` in the input vector `arr`:\n   - **Complement Calculation:** The complement value (`sum - num`) is computed.\n   - **Check for Complement:** If the complement exists in `freq`, the count of such complements (stored in `freq`) is added to `count`.\n   - **Update Frequency:** The frequency of the current number `num` is incremented in `freq`.\n3. **Result:** After processing all elements, `count` holds the total number of pairs where the sum equals `sum`.\n\nThis approach efficiently handles all cases, including negative numbers and duplicates, with a time complexity of O(n) where n is the length of the input vector. The space complexity is O(n) in the worst case (when all elements are distinct).", "\n\nThe solution involves counting pairs of elements in the vector that sum to a given value using a hash map to efficiently track encountered elements and their frequencies. The algorithm iterates through each element, calculates the required complement (to reach the target sum), checks if the complement exists in the hash map, and increments the count by the frequency of the complement. The current element is then added to the hash map.\n\nHere's the implementation in Rust:\n\n```rust\nuse std::collections::HashMap;\n\nfn get_pairs_count(arr: Vec<isize>, sum: isize) -> isize {\n    let mut freq = HashMap::new();\n    let mut count = 0;\n    for x in arr {\n        let y = sum - x;\n        if let Some(count_y) = freq.get(&y) {\n            count += *count_y;\n        }\n        *freq.entry(x).or_insert(0) += 1;\n    }\n    count\n}\n```\n\n**Explanation:**\n1. **Initialization**: A `HashMap` (`freq`) is used to store the frequency of each number encountered so far. A counter (`count`) is initialized to zero.\n2. **Iteration**: For each element `x` in the input vector:\n   - **Complement Calculation**: Compute `y = sum - x` (the number that would form a valid pair with `x`).\n   - **Check for Complement**: If `y` exists in `freq`, add its frequency to `count` (this gives the number of valid pairs where `x` pairs with previous `y` values).\n   - **Update Frequency**: Increment the frequency of `x` in `freq` (to include it in future pair checks).\n3. **Result**: After processing all elements, `count` holds the total number of valid pairs.\n\n**Why this works:**\n- **Efficiency**: The algorithm runs in O(n) time (where n is the vector length) and uses O(n) space (for the hash map), which is optimal for this problem.\n- **Correctness**: By only considering elements processed before the current one (via the hash map), each pair (i, j) with i < j is counted exactly once.\n- **Edge Cases**: Handles negative numbers, duplicates, and empty vectors correctly (returns 0 for empty vectors).\n\nThis solution efficiently counts all valid pairs without double-counting and works for all integer inputs within Rust's `isize` range.\n\n```rust\nuse std::collections::HashMap;\n\nfn get_pairs_count(arr: Vec<isize>, sum: isize) -> isize {\n    let mut freq = HashMap::new();\n    let mut count = 0;\n    for x in arr {\n        let y = sum - x;\n        if let Some(count_y) = freq.get(&y) {\n            count += *count_y;\n        }\n        *freq.entry(x).or_insert(0) += 1;\n    }\n    count\n}\n```"]}
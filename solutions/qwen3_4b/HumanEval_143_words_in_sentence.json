{"name": "HumanEval_143_words_in_sentence", "language": "rs", "prompt": "/// You are given a string representing a sentence,\n/// the sentence contains some words separated by a space,\n/// and you have to return a string that contains the words from the original sentence,\n/// whose lengths are prime numbers,\n/// the order of the words in the new string should be the same as the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence: String) -> String {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_143_words_in_sentence.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve this problem, we need to process a given sentence by filtering out words whose lengths are prime numbers, while maintaining the original order of the words. The solution involves splitting the sentence into individual words, checking the length of each word to determine if it is a prime number, and then joining the qualifying words back into a string.\n\n### Approach\n1. **Split the Sentence**: The input sentence is split into individual words using the space character as the delimiter.\n2. **Check Prime Lengths**: For each word, we check if its length (converted to a `u32` integer) is a prime number.\n3. **Filter Words**: Words with prime lengths are collected into a new vector.\n4. **Join Words**: The collected words are joined into a single string with spaces, which is then returned as the result.\n\nThe key part of the solution is the helper function `is_prime`, which determines if a number is prime. This function checks divisibility from 2 up to the square root of the number to efficiently determine primality.\n\n### Solution Code\n```rust\nfn is_prime(n: u32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    let max = (n as f64).sqrt() as usize;\n    for i in 2..=max {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn words_in_sentence(sentence: String) -> String {\n    let words: Vec<String> = sentence.split(' ').map(|s| s.to_string()).collect();\n    let prime_words: Vec<String> = words.into_iter()\n        .filter(|word| is_prime(word.len() as u32))\n        .collect();\n    prime_words.join(\" \")\n}\n```\n\n### Explanation\n1. **Splitting the Sentence**: The sentence is split into a vector of strings using `split(' ')`, which splits the string at each space character. This ensures we get each word as a separate string.\n2. **Prime Check**: The helper function `is_prime` checks if a number `n` is prime. It returns `false` if `n` is less than 2 (since 0 and 1 are not primes). For numbers 2 and above, it checks divisibility from 2 up to the square root of `n` (inclusive). If any divisor is found, `n` is not prime.\n3. **Filtering Words**: Each word from the split sentence is checked for a prime length using `is_prime`. Words with prime lengths are collected into a new vector.\n4. **Joining Words**: The filtered words are joined into a single string with spaces using `join(\" \")`, which is returned as the result.\n\nThis approach efficiently processes the sentence by leveraging simple string operations and a straightforward prime-checking mechanism, ensuring correctness and optimal performance within the problem constraints.", "\n\nTo solve this problem, we need to process a given sentence by extracting words whose lengths are prime numbers, maintaining the original order of these words in the result string.\n\n### Approach\n1. **Split the Sentence**: The input sentence is split into individual words using the space character as the delimiter.\n2. **Check Prime Lengths**: For each word obtained from the split, we check if its length is a prime number.\n3. **Filter Prime Words**: We collect all words whose lengths are prime numbers into a new list.\n4. **Join Words**: The collected words are joined into a single string with spaces separating them, which is then returned as the result.\n\nThe key component of this solution is the helper function `is_prime`, which checks if a given number is prime. This function efficiently checks for primality by:\n- Handling small cases (numbers \u2264 1, 2, and even numbers).\n- For odd numbers greater than 2, it checks divisibility up to the square root of the number.\n\n### Solution Code\n```rust\nfn words_in_sentence(sentence: String) -> String {\n    fn is_prime(n: u32) -> bool {\n        if n <= 1 {\n            return false;\n        }\n        if n == 2 {\n            return true;\n        }\n        if n % 2 == 0 {\n            return false;\n        }\n        let mut i = 3;\n        while i * i <= n {\n            if n % i == 0 {\n                return false;\n            }\n            i += 2;\n        }\n        true\n    }\n\n    let words: Vec<String> = sentence.split(' ').map(|s| s.to_string()).collect();\n    let prime_words: Vec<String> = words.into_iter()\n        .filter(|word| is_prime(word.len() as u32))\n        .collect();\n    prime_words.join(\" \")\n}\n```\n\n### Explanation\n1. **Splitting the Sentence**: The sentence is split into a vector of strings using `split(' ')`, which separates the sentence into words based on space characters.\n2. **Prime Check**: The nested function `is_prime` checks if a number is prime. It efficiently handles edge cases (numbers \u2264 1, 2, and even numbers) and checks divisibility for odd numbers up to the square root of the number.\n3. **Filtering Words**: Each word from the split sentence is checked for prime length using `is_prime`. Words with prime lengths are collected into a new vector.\n4. **Joining Words**: The collected words are joined into a single string with spaces between them using `join(\" \")`, which is returned as the final result.\n\nThis approach efficiently processes the input sentence to produce the desired output by leveraging simple string operations and a straightforward prime check, ensuring optimal performance given the problem constraints.", "\n\nTo solve this problem, we need to filter out words from a given sentence where the length of each word is a prime number. The solution involves splitting the sentence into individual words, checking the length of each word to determine if it is a prime number, and then constructing a new string containing only those words in their original order.\n\n### Approach\n1. **Split the Sentence**: The input sentence is split into a list of words using the space character as the delimiter.\n2. **Precompute Prime Numbers**: We precompute a list of prime numbers up to 100 (since the maximum possible word length is 100 as per the problem constraints). This list is stored in a `HashSet` for efficient lookups.\n3. **Filter Words by Prime Length**: For each word in the split list, we check if its length (converted to `u32`) is present in the precomputed set of primes. If it is, the word is added to the result list.\n4. **Construct Result String**: The filtered words are joined into a single string with spaces separating them, which is returned as the final result.\n\n### Solution Code\n```rust\nuse std::collections::HashSet;\n\nfn words_in_sentence(sentence: String) -> String {\n    let words: Vec<&str> = sentence.split(' ').collect();\n    let primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let primes_set: HashSet<u32> = primes.iter().cloned().collect();\n    let mut result = Vec::new();\n    for word in words {\n        let len = word.len() as u32;\n        if primes_set.contains(&len) {\n            result.push(word);\n        }\n    }\n    result.join(\" \")\n}\n```\n\n### Explanation\n1. **Splitting the Sentence**: The `split(' ')` method divides the input sentence into a vector of word references (`&str`), which are then processed individually.\n2. **Prime Number Set**: A predefined list of prime numbers up to 100 is converted into a `HashSet` for O(1) membership checks. This set contains all prime numbers from 2 to 97 (the largest prime less than or equal to 100).\n3. **Checking Word Lengths**: For each word in the split list, its length is converted to a `u32` type. If this length exists in the prime set, the word is added to the result vector.\n4. **Constructing Result**: The filtered words (those with prime lengths) are joined into a single string with spaces between them using `join(\" \")`, which is then returned as the final output.\n\nThis approach efficiently processes the input sentence by leveraging a precomputed set of primes for quick lookups, ensuring optimal performance even for the upper constraint limits. The solution maintains the original order of words while filtering out those with non-prime lengths."]}
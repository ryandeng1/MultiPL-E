{"name": "HumanEval_26_remove_duplicates", "language": "rs", "prompt": "/// From a vector of integers, remove all elements that occur more than once.\n/// Keep order of elements left the same as in the input.\n/// >>> remove_duplicates(vec![1, 2, 3, 2, 4])\n/// vec![1, 3, 4]\nfn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_26_remove_duplicates.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = remove_duplicates;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 4, 3, 5]), vec![1, 4, 5]);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve this problem, we need to remove all elements from a vector of integers that occur more than once in the entire vector while preserving the order of the remaining elements as they appear in the input. \n\n### Approach\n1. **Count Frequencies**: First, we traverse the input vector to count the frequency of each element using a `HashMap`. This helps us determine which elements occur more than once.\n2. **Build Result Vector**: Next, we traverse the input vector again. For each element, we check if its frequency is exactly 1 (indicating it occurs only once in the entire vector). If so, we add it to the result vector. This ensures the order of elements in the result matches their order in the input.\n\nThis two-pass approach efficiently processes the vector in linear time with linear space complexity, which is optimal for this problem.\n\n### Solution Code\n```rust\nuse std::collections::HashMap;\n\nfn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {\n    let mut counts = HashMap::new();\n    for num in numbers {\n        *counts.entry(num).or_insert(0) += 1;\n    }\n\n    let mut result = Vec::new();\n    for num in numbers {\n        if counts.get(&num) == Some(&1) {\n            result.push(num);\n        }\n    }\n    result\n}\n```\n\n### Explanation\n1. **Counting Frequencies**: We initialize an empty `HashMap` to store the count of each element. As we iterate through the input vector, we increment the count for each element encountered.\n2. **Building Result Vector**: We then iterate through the input vector again. For each element, we check if its count in the `HashMap` is exactly 1. If it is, we add the element to the result vector. This ensures that only elements appearing exactly once in the input vector are included in the result, maintaining their original order.\n\nThis approach efficiently handles the problem by leveraging a hash map for constant-time lookups during the frequency counting and result construction phases, resulting in an overall time complexity of O(n) where n is the number of elements in the input vector. The space complexity is also O(n) due to the storage required for the hash map and the result vector.", "\n\nTo solve the problem of removing all elements that occur more than once from a vector of integers while preserving the order of the remaining elements, we can follow these steps:\n\n1. **Count Frequencies**: Use a `HashMap` to count how many times each integer appears in the input vector.\n2. **Filter Elements**: Iterate through the input vector and collect only those elements that appear exactly once (i.e., their frequency is 1).\n\nThis approach ensures that:\n- Elements that occur more than once are removed.\n- The order of elements in the resulting vector matches their order in the original input.\n\nHere's the implementation:\n\n```rust\nuse std::collections::HashMap;\n\nfn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {\n    let mut freq = HashMap::new();\n    for &num in &numbers {\n        *freq.entry(num).or_insert(0) += 1;\n    }\n\n    numbers.into_iter()\n        .filter(|&num| freq.get(&num) == Some(&1))\n        .collect()\n}\n```\n\n**Explanation**:\n1. **Frequency Counting**: We iterate through the input vector and populate a `HashMap` where each key is an integer from the input, and the value is its frequency.\n2. **Filtering**: We then iterate through the original vector again, collecting only those elements whose frequency is exactly 1. This preserves the original order of the elements that are kept.\n\n**Example**:\n- Input: `vec![1, 2, 3, 2, 4]`\n- Frequency Map: `1:1, 2:2, 3:1, 4:1`\n- Result: Elements with frequency 1 \u2192 `[1, 3, 4]`\n\nThis solution efficiently handles the problem with a time complexity of O(n), where n is the number of elements in the input vector, and uses O(n) space for the frequency map.\n\n```rust\nuse std::collections::HashMap;\n\nfn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {\n    let mut freq = HashMap::new();\n    for &num in &numbers {\n        *freq.entry(num).or_insert(0) += 1;\n    }\n\n    numbers.into_iter()\n        .filter(|&num| freq.get(&num) == Some(&1))\n        .collect()\n}\n```", "\n\nTo solve this problem, we need to remove all elements from a vector of integers that occur more than once in the entire vector while preserving the order of the remaining elements as they appear in the input. \n\n### Approach\n1. **Count Frequencies**: First, we traverse the input vector to count the frequency of each integer. This is done using a `HashMap` where keys are the integers and values are their counts.\n2. **Filter Elements**: Next, we traverse the input vector again. For each integer, if its frequency in the `HashMap` is exactly 1, we add it to the result vector. This ensures that only integers appearing exactly once in the entire vector are retained, maintaining their original order.\n\nThis approach efficiently handles the problem by:\n- Using a single pass to count frequencies (O(n) time).\n- Using another pass to construct the result vector (O(n) time).\n- Ensuring the solution is O(n) in time complexity with O(n) space complexity for the `HashMap`.\n\n### Solution Code\n```rust\nuse std::collections::HashMap;\n\nfn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {\n    let mut freq = HashMap::new();\n    for num in &numbers {\n        *freq.entry(*num).or_insert(0) += 1;\n    }\n\n    let mut result = Vec::new();\n    for num in numbers {\n        if let Some(&count) = freq.get(&num) {\n            if count == 1 {\n                result.push(num);\n            }\n        }\n    }\n    result\n}\n```\n\n### Explanation\n1. **Frequency Counting**: The first loop iterates over each integer in the input vector. For each integer, it increments its count in the `HashMap` (initializing to 0 if the integer hasn't been seen before).\n2. **Result Construction**: The second loop iterates over the input vector again. For each integer, it checks if its count in the `HashMap` is exactly 1. If so, the integer is added to the result vector. This step ensures that only integers appearing exactly once in the entire vector are included in the result, maintaining their original order from the input.\n\nThis method efficiently meets the problem requirements by leveraging a hash map for constant-time lookups and preserving the order of elements as specified. The solution handles all edge cases, including vectors with all duplicates (resulting in an empty vector) or vectors with all unique elements (resulting in the original vector). \n\n**Example**: For input `vec![1, 2, 3, 2, 4]`, the frequencies are `{1:1, 2:2, 3:1, 4:1}`. The result vector will include only integers with frequency 1, which are `1`, `3`, and `4`, resulting in `vec![1, 3, 4]`."]}
{"name": "HumanEval_94_skjkasdkd", "language": "rs", "prompt": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_94_skjkasdkd.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve this problem, we need to find the largest prime number in a given vector of integers and then return the sum of its digits. The solution involves two main steps: identifying the largest prime number in the vector and computing the sum of its digits.\n\n### Approach\n1. **Prime Check**: For each number in the vector, we check if it is a prime number. A prime number is defined as a natural number greater than 1 that has no positive divisors other than 1 and itself.\n2. **Tracking Largest Prime**: As we iterate through the vector, we keep track of the largest prime number encountered.\n3. **Sum of Digits**: Once the largest prime is identified, we convert it into a string, process each character (digit), and sum these digits to get the final result.\n\n### Solution Code\n```rust\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n    fn is_prime(n: isize) -> bool {\n        if n < 2 {\n            return false;\n        }\n        if n == 2 {\n            return true;\n        }\n        if n % 2 == 0 {\n            return false;\n        }\n        let mut i = 3;\n        while i * i <= n {\n            if n % i == 0 {\n                return false;\n            }\n            i += 2;\n        }\n        true\n    }\n\n    fn sum_digits(n: isize) -> isize {\n        n.to_string()\n            .chars()\n            .map(|c| c.to_digit(10).unwrap() as isize)\n            .sum()\n    }\n\n    let mut max_prime = 0;\n    for x in lst {\n        if x > max_prime && is_prime(x) {\n            max_prime = x;\n        }\n    }\n    sum_digits(max_prime)\n}\n```\n\n### Explanation\n1. **Prime Check (`is_prime` function)**:\n   - The function first checks if the number is less than 2 (not prime).\n   - It then checks if the number is 2 (the smallest prime).\n   - For even numbers greater than 2, it immediately returns false.\n   - For odd numbers, it checks divisibility from 3 up to the square root of the number in steps of 2 (to skip even divisors).\n\n2. **Sum of Digits (`sum_digits` function)**:\n   - Converts the number to a string to process each digit individually.\n   - Maps each character to its corresponding digit value and sums them.\n\n3. **Finding Largest Prime**:\n   - Iterates through each number in the input vector.\n   - For each number, checks if it is prime and larger than the current largest prime found.\n   - Updates the largest prime whenever a larger prime is encountered.\n\n4. **Result Calculation**:\n   - After processing all numbers, the largest prime is converted to a string, and the sum of its digits is computed and returned.\n\nThis approach efficiently identifies the largest prime in the vector and computes the required digit sum, handling all edge cases such as non-prime numbers and single-digit primes correctly. The solution is optimized to check for primality efficiently and process digits in linear time relative to the number of digits.", "\n\nTo solve this problem, we need to find the largest prime number in a given vector of integers and return the sum of its digits. The solution involves checking each number in the vector to determine if it is a prime, identifying the largest such prime, and then computing the sum of its digits.\n\n### Approach\n1. **Prime Check**: For each number in the vector, check if it is a prime number. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\n2. **Track Largest Prime**: Iterate through the vector to keep track of the largest prime number encountered.\n3. **Sum Digits**: Once the largest prime is identified, compute the sum of its digits by converting the number to a string, processing each character (digit), and summing the integer values of these digits.\n\n### Solution Code\n```rust\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n    fn is_prime(n: isize) -> bool {\n        if n <= 1 {\n            return false;\n        }\n        if n == 2 {\n            return true;\n        }\n        if n % 2 == 0 {\n            return false;\n        }\n        let mut i = 3;\n        while i * i <= n {\n            if n % i == 0 {\n                return false;\n            }\n            i += 2;\n        }\n        true\n    }\n\n    let mut max_prime = None;\n    for num in lst {\n        if is_prime(num) {\n            if max_prime.is_none() || num > max_prime.unwrap() {\n                max_prime = Some(num);\n            }\n        }\n    }\n\n    let prime = max_prime.unwrap();\n    let s = prime.to_string();\n    s.chars().map(|c| c.to_digit(10).unwrap() as isize).sum()\n}\n```\n\n### Explanation\n1. **Prime Check (`is_prime` function)**:\n   - The function first checks if the number is less than or equal to 1 (not prime).\n   - It then checks if the number is 2 (the only even prime).\n   - For numbers greater than 2, it checks divisibility by 2 (even numbers are not prime).\n   - The loop checks divisibility by odd numbers starting from 3 up to the square root of the number. If any divisor is found, the number is not prime.\n\n2. **Finding Largest Prime**:\n   - The main function iterates through each number in the input vector.\n   - For each number that is prime, it compares the number with the current largest prime (initially `None`).\n   - If the number is larger than the current largest prime, it updates the largest prime.\n\n3. **Summing Digits**:\n   - The largest prime is converted to a string to process each digit individually.\n   - Each character in the string is converted back to an integer, and these integers are summed to get the final result.\n\nThis approach efficiently checks for primes, tracks the largest one, and computes the digit sum, ensuring correctness for all provided examples and edge cases within the problem constraints.", "\n\nTo solve this problem, we need to find the largest prime number in a given vector of integers and return the sum of its digits. The solution involves two main steps: identifying the largest prime number in the vector and then calculating the sum of its digits.\n\n### Approach\n1. **Prime Check**: For each number in the vector, we check if it is a prime number. A prime number is defined as a natural number greater than 1 that has no positive divisors other than 1 and itself.\n2. **Track Largest Prime**: While iterating through the vector, we keep track of the largest prime number encountered.\n3. **Sum Digits**: Once the largest prime is identified, we convert it into a string, process each character (digit), convert it back to an integer, and sum these integers to get the final result.\n\n### Solution Code\n```rust\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n    fn is_prime(n: isize) -> bool {\n        if n < 2 {\n            return false;\n        }\n        if n == 2 {\n            return true;\n        }\n        if n % 2 == 0 {\n            return false;\n        }\n        let mut i = 3;\n        while i * i <= n {\n            if n % i == 0 {\n                return false;\n            }\n            i += 2;\n        }\n        true\n    }\n\n    let mut max_prime = 0;\n    for num in lst {\n        if is_prime(num) {\n            if num > max_prime {\n                max_prime = num;\n            }\n        }\n    }\n\n    max_prime.abs().to_string()\n        .chars()\n        .map(|c| c.to_digit(10).unwrap() as isize)\n        .sum()\n}\n```\n\n### Explanation\n1. **Prime Check Function (`is_prime`)**:\n   - This helper function checks if a number `n` is prime.\n   - It first handles base cases: numbers less than 2 are not prime, 2 is prime, and even numbers greater than 2 are not prime.\n   - For odd numbers greater than 2, it checks divisibility from 3 up to the square root of `n` (in steps of 2 to skip even divisors).\n\n2. **Finding Largest Prime**:\n   - We initialize `max_prime` to 0.\n   - For each number in the input vector, we check if it is prime using `is_prime`.\n   - If it is prime and larger than the current `max_prime`, we update `max_prime`.\n\n3. **Summing Digits**:\n   - Convert the largest prime (`max_prime`) to a string.\n   - Iterate over each character in the string, convert it to a digit, and sum these digits.\n   - The result is returned as an `isize`.\n\nThis approach efficiently identifies the largest prime in the vector and computes the sum of its digits, adhering to the problem requirements and constraints. The solution handles edge cases such as negative numbers (by ignoring them since primes are positive) and ensures correctness through systematic checks."]}
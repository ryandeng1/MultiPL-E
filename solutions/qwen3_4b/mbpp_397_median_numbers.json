{"name": "mbpp_397_median_numbers", "language": "rs", "prompt": "/// Write a function to find the median of three numbers.\nfn median_numbers(a: isize, b: isize, c: isize) -> f64 {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_397_median_numbers.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = median_numbers;\n    assert_eq!(candidate(25, 55, 65), 55.0);\n    assert_eq!(candidate(20, 10, 30), 20.0);\n    assert_eq!(candidate(15, 45, 75), 45.0);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo find the median of three numbers in Rust, we can leverage a mathematical property: the median of three numbers $ a $, $ b $, and $ c $ is equal to the sum of the three numbers minus the minimum and maximum values. This avoids the need for sorting and provides a concise and efficient solution.\n\nHere's the implementation:\n\n```rust\nfn median_numbers(a: isize, b: isize, c: isize) -> f64 {\n    let sum = a + b + c;\n    let min = a.min(b).min(c);\n    let max = a.max(b).max(c);\n    (sum - min - max) as f64\n}\n```\n\n### Explanation:\n1. **Sum Calculation**: Compute the total sum of the three numbers.\n2. **Find Minimum**: Use `min` to determine the smallest value among the three.\n3. **Find Maximum**: Use `max` to determine the largest value among the three.\n4. **Median Calculation**: Subtract the minimum and maximum from the total sum to isolate the median value.\n5. **Type Conversion**: Convert the result to a `f64` for the required return type.\n\nThis approach efficiently computes the median without sorting and handles all edge cases (e.g., duplicate values) correctly.\n\n### Example Usage:\n```rust\nprintln!(\"{}\", median_numbers(1, 2, 3)); // Output: 2.0\nprintln!(\"{}\", median_numbers(3, 1, 2)); // Output: 2.0\nprintln!(\"{}\", median_numbers(5, 5, 5)); // Output: 5.0\n```\n\nThis solution is both concise and optimal for the given problem constraints.", "\n\nTo find the median of three numbers in Rust, we can leverage the built-in sorting functionality of vectors. The median is the middle value when the three numbers are sorted in ascending order. By creating a vector with the three input values, sorting it, and then returning the second element (index 1), we efficiently determine the median.\n\nHere's the implementation:\n\n```rust\nfn median_numbers(a: isize, b: isize, c: isize) -> f64 {\n    let mut nums = vec![a, b, c];\n    nums.sort();\n    nums[1] as f64\n}\n```\n\n**Explanation:**\n1. **Vector Initialization:** We create a mutable vector `nums` containing the three input integers.\n2. **Sorting:** The vector is sorted in ascending order using `sort()`, which arranges the numbers from smallest to largest.\n3. **Median Extraction:** The middle element (at index 1) of the sorted vector is converted to a `f64` and returned as the median.\n\nThis approach is concise, efficient, and handles all edge cases (including duplicates) correctly. The time complexity is $O(1)$ since sorting a fixed-size vector of three elements is constant time.\n\n**Example Usage:**\n```rust\nprintln!(\"{}\", median_numbers(3, 1, 2)); // Output: 2.0\nprintln!(\"{}\", median_numbers(5, 5, 5)); // Output: 5.0\nprintln!(\"{}\", median_numbers(-1, 0, 1)); // Output: 0.0\n```\n\n**Answer:**\n```rust\nfn median_numbers(a: isize, b: isize, c: isize) -> f64 {\n    let mut nums = vec![a, b, c];\n    nums.sort();\n    nums[1] as f64\n}\n```", "\n\nTo find the median of three numbers efficiently and safely from integer overflow issues, we can sort the numbers and return the middle value. This approach avoids arithmetic operations that might overflow and is straightforward for exactly three numbers.\n\n```rust\nfn median_numbers(a: isize, b: isize, c: isize) -> f64 {\n    let mut nums = vec![a, b, c];\n    nums.sort();\n    nums[1] as f64\n}\n```\n\n**Explanation:**\n1. **Vector Initialization:** We create a vector containing the three input numbers.\n2. **Sorting:** The vector is sorted in ascending order using `sort()`, which arranges the numbers from smallest to largest.\n3. **Median Extraction:** The median is the middle element (at index 1 in a zero-based 3-element vector), converted to a `f64` for the return type.\n\nThis method is safe from integer overflow because sorting only involves comparisons (not arithmetic operations) and is efficient for exactly three numbers. The solution handles all cases, including negative numbers and duplicates, correctly.\n\n**Example Usage:**\n```rust\nassert_eq!(median_numbers(1, 2, 3), 2.0);\nassert_eq!(median_numbers(1, 1, 2), 1.0);\nassert_eq!(median_numbers(-3, -2, -1), -2.0);\n```"]}
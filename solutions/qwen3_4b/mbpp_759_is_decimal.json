{"name": "mbpp_759_is_decimal", "language": "rs", "prompt": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_759_is_decimal.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo determine if a given string represents a decimal number with exactly two decimal places, we need to ensure the string meets specific criteria. The solution involves checking for the presence of exactly one decimal point, two digits after the decimal point, and that both parts (before and after the decimal) consist only of digits (the part before can be empty).\n\n### Approach\n1. **Split the string by the decimal point**: This helps us separate the integer part (before the decimal) and the fractional part (after the decimal).\n2. **Check for exactly two parts**: The string must split into exactly two parts (one for the integer part and one for the fractional part). If there are more or fewer parts, the string is invalid.\n3. **Verify the fractional part**: The part after the decimal must be exactly two characters long and consist only of digits (0-9).\n4. **Verify the integer part**: The part before the decimal must consist only of digits (or be empty, meaning the number is less than 1).\n\nThis approach efficiently checks all necessary conditions without extra complexity, leveraging Rust's string splitting and character validation features.\n\n### Solution Code\n```rust\nfn is_decimal(num: String) -> bool {\n    let parts: Vec<&str> = num.split('.').collect();\n    if parts.len() != 2 {\n        return false;\n    }\n    let prefix = parts[0];\n    let suffix = parts[1];\n    if suffix.len() != 2 {\n        return false;\n    }\n    if !suffix.chars().all(|c| c.is_digit(10)) {\n        return false;\n    }\n    if !prefix.chars().all(|c| c.is_digit(10)) {\n        return false;\n    }\n    true\n}\n```\n\n### Explanation\n1. **Splitting the string**: The string is split into parts using the decimal point (`'.'`). For example, `\"123.45\"` splits into `[\"123\", \"45\"]`.\n2. **Checking part count**: The split must result in exactly two parts. If there's no decimal point (e.g., `\"123\"`), or multiple decimal points (e.g., `\"12.3.45\"`), the function returns `false`.\n3. **Fractional part check**: The part after the decimal must be exactly two characters long (e.g., `\"45\"` is valid, `\"4\"` or `\"456\"` is invalid).\n4. **Digit validation**: Both the integer part (before the decimal) and the fractional part (after the decimal) must consist only of digits. The integer part can be empty (e.g., `\".45\"` is valid).\n\nThis solution efficiently validates the string against all required conditions for a decimal number with exactly two decimal places, ensuring correctness for all edge cases such as leading zeros, empty integer parts, and invalid characters. The approach is optimal with a time complexity of O(n), where n is the length of the string, due to the linear checks for digits and split operations.", "\n\nTo determine if a given string represents a decimal number with exactly two decimal places, the function checks the following conditions:\n1. The string contains exactly one decimal point.\n2. The total length of the string is exactly three characters more than the position of the decimal point (ensuring exactly two digits after the decimal point).\n3. The two characters immediately following the decimal point are digits.\n4. The part before the decimal point is either empty or a valid integer string (which may start with a minus sign followed by one or more digits).\n\nHere's the implementation:\n\n```rust\nfn is_decimal(num: String) -> bool {\n    let mut count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            count += 1;\n            if count > 1 {\n                return false;\n            }\n        }\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let pos = num.find('.').unwrap();\n    if num.len() != pos + 3 {\n        return false;\n    }\n\n    let suffix = &num[pos + 1..pos + 3];\n    for c in suffix.chars() {\n        if !c.is_digit(10) {\n            return false;\n        }\n    }\n\n    let prefix = &num[..pos];\n    if prefix.is_empty() {\n        return true;\n    }\n\n    if prefix.starts_with('-') {\n        let rest = &prefix[1..];\n        if rest.is_empty() {\n            return false;\n        }\n        for c in rest.chars() {\n            if !c.is_digit(10) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    for c in prefix.chars() {\n        if !c.is_digit(10) {\n            return false;\n        }\n    }\n    true\n}\n```\n\n**Explanation:**\n1. **Decimal Point Check:** The function first ensures there is exactly one decimal point in the string. If there are none or more than one, it returns `false`.\n2. **Length Check:** The string length must be exactly `pos + 3` (where `pos` is the index of the decimal point). This ensures there are exactly two digits after the decimal point and nothing else.\n3. **Suffix Validation:** The two characters after the decimal point must be digits. If any character is not a digit, it returns `false`.\n4. **Prefix Validation:** \n   - If the prefix (part before the decimal) is empty, it returns `true` (e.g., `.45` is valid).\n   - If the prefix starts with a minus sign, the remaining part must be non-empty digits.\n   - Otherwise, the entire prefix must be digits.\n\nThis function efficiently checks all conditions to verify if the string is a decimal number with precisely two decimal places, handling both positive and negative numbers, as well as empty integer parts (like `.45`). The implementation avoids external dependencies and uses Rust's built-in string and character methods for clarity and correctness.", "\n\nTo determine if a given string represents a decimal number with exactly two decimal places (precision of 2), we need to verify the following conditions:\n1. The string may start with an optional sign (`+` or `-`).\n2. There must be exactly one decimal point (`.`) in the string.\n3. After the decimal point, there must be exactly two digits.\n4. The part before the decimal point (if any) must consist of digits (which can be empty).\n\nHere's the implementation:\n\n```rust\nfn is_decimal(num: String) -> bool {\n    if num.is_empty() {\n        return false;\n    }\n\n    let has_sign = num.starts_with('+') || num.starts_with('-');\n    let s_clean = if has_sign {\n        &num[1..]\n    } else {\n        &num\n    };\n\n    let decimal_count = s_clean.chars().filter(|c| *c == '.').count();\n    if decimal_count != 1 {\n        return false;\n    }\n\n    let idx = s_clean.find('.').unwrap();\n    let after = &s_clean[idx + 1..];\n    if after.len() != 2 {\n        return false;\n    }\n\n    if !after.chars().all(|c| c.is_digit(10)) {\n        return false;\n    }\n\n    if !s_clean[..idx].chars().all(|c| c.is_digit(10)) {\n        return false;\n    }\n\n    true\n}\n```\n\n**Explanation:**\n1. **Check for empty string:** If the input string is empty, return `false`.\n2. **Handle sign:** If the string starts with `+` or `-`, remove it for further processing.\n3. **Count decimal points:** Ensure there is exactly one decimal point in the cleaned string (without the sign).\n4. **Locate decimal point:** Find the position of the decimal point.\n5. **Check after decimal part:** The substring after the decimal point must be exactly two characters long and consist only of digits.\n6. **Check before decimal part:** The substring before the decimal point (if any) must consist only of digits (it can be empty).\n\nThis function efficiently checks all conditions to determine if the string represents a decimal number with exactly two decimal places. It handles edge cases such as negative numbers, numbers with no integer part (e.g., `.00`), and leading zeros in the integer part.\n\n**Example Usage:**\n- `is_decimal(\"123.45\".to_string())` \u2192 `true`\n- `is_decimal(\"-0.00\".to_string())` \u2192 `true`\n- `is_decimal(\".00\".to_string())` \u2192 `true`\n- `is_decimal(\"123.4\".to_string())` \u2192 `false` (only one decimal digit)\n- `is_decimal(\"123.45a\".to_string())` \u2192 `false` (non-digit after decimal)\n- `is_decimal(\"123.\".to_string())` \u2192 `false` (no digits after decimal)\n\nThis implementation is clear, concise, and meets the problem requirements."]}
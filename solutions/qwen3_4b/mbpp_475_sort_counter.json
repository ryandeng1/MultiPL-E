{"name": "mbpp_475_sort_counter", "language": "rs", "prompt": "use std::collections::HashMap;\n\n/// Write a function to sort a HashMap by value.\nfn sort_counter(dict1: HashMap<String, isize>) -> Vec<(String, isize)> {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_475_sort_counter.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = sort_counter;\n    assert_eq!(candidate(HashMap::from([(String::from(\"Math\"), 81), (String::from(\"Physics\"), 83), (String::from(\"Chemistry\"), 87)])), vec![(String::from(\"Chemistry\"), 87), (String::from(\"Physics\"), 83), (String::from(\"Math\"), 81)]);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Math\"), 400), (String::from(\"Physics\"), 300), (String::from(\"Chemistry\"), 250)])), vec![(String::from(\"Math\"), 400), (String::from(\"Physics\"), 300), (String::from(\"Chemistry\"), 250)]);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Math\"), 900), (String::from(\"Physics\"), 1000), (String::from(\"Chemistry\"), 1250)])), vec![(String::from(\"Chemistry\"), 1250), (String::from(\"Physics\"), 1000), (String::from(\"Math\"), 900)]);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo sort a `HashMap` by its values in ascending order, we can convert the `HashMap` into a vector of key-value pairs and then sort this vector based on the values. Here's the solution:\n\n```rust\nuse std::collections::HashMap;\n\n/// Sorts a HashMap by value in ascending order.\nfn sort_counter(dict1: HashMap<String, isize>) -> Vec<(String, isize)> {\n    let mut sorted: Vec<(String, isize)> = dict1.into_iter().collect();\n    sorted.sort_by(|a, b| a.1.cmp(&b.1));\n    sorted\n}\n```\n\n**Explanation:**\n1. **Convert to Vector:** `dict1.into_iter().collect()` converts the `HashMap` into a vector of key-value pairs (`(String, isize)`).\n2. **Sort by Value:** `sorted.sort_by(|a, b| a.1.cmp(&b.1))` sorts the vector using a closure that compares the second elements (the values) of each tuple using `cmp`, which ensures ascending order.\n\nThis approach efficiently sorts the `HashMap` by value while preserving the original key-value pairs in the sorted order. The function handles edge cases like empty maps and equal values naturally (the order of equal values is preserved due to Rust's stable sort).", "\n\nTo sort a `HashMap` by its values in ascending order and return the result as a vector of key-value pairs, we can follow these steps:\n\n1. **Convert the HashMap into a vector of key-value pairs**: This allows us to manipulate the data for sorting.\n2. **Sort the vector by the value**: Using Rust's `sort_by` method with a closure that compares the values using `cmp`.\n\nHere's the implementation:\n\n```rust\nuse std::collections::HashMap;\n\n/// Write a function to sort a HashMap by value.\nfn sort_counter(dict1: HashMap<String, isize>) -> Vec<(String, isize)> {\n    let mut sorted: Vec<(String, isize)> = dict1.into_iter().collect();\n    sorted.sort_by(|a, b| a.1.cmp(&b.1));\n    sorted\n}\n```\n\n**Explanation**:\n- `dict1.into_iter().collect()` converts the `HashMap` into a mutable vector of key-value pairs.\n- `sorted.sort_by(|a, b| a.1.cmp(&b.1))` sorts the vector by comparing the `isize` values of each tuple using `cmp`, which returns an `Ordering` (Less, Equal, Greater).\n- The function returns the sorted vector.\n\nThis solution efficiently sorts the `HashMap` by value while maintaining clarity and correctness in Rust's type system.", "\n\nTo sort a `HashMap` by its values (ascending order), we convert the map into a vector of key-value pairs, sort the vector based on the values, and return the sorted vector. Here's the implementation:\n\n```rust\nuse std::collections::HashMap;\n\n/// Write a function to sort a HashMap by value.\nfn sort_counter(dict1: HashMap<String, isize>) -> Vec<(String, isize)> {\n    let mut sorted = dict1.into_iter().collect();\n    sorted.sort_by(|a, b| a.1.cmp(&b.1));\n    sorted\n}\n```\n\n**Explanation:**\n1. **Convert to Vector:** `dict1.into_iter().collect()` converts the `HashMap` into a vector of tuples `(String, isize)`.\n2. **Sort by Value:** `sorted.sort_by(|a, b| a.1.cmp(&b.1))` sorts the vector in ascending order based on the `isize` values (the second element of each tuple).\n3. **Return Result:** The sorted vector is returned.\n\nThis function efficiently sorts the map by value in ascending order (smallest to largest) as per typical expectations for such operations. The solution uses Rust's standard library for clarity and performance."]}
{"name": "mbpp_92_is_undulating", "language": "rs", "prompt": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_92_is_undulating.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo determine if a given number is undulating, we follow the standard definition where an undulating number is a number whose digits alternate between two distinct digits (e.g., \"ababab...\"). The function checks for the following conditions:\n1. The number must be non-negative (negative numbers are not undulating).\n2. The number must have at least two digits.\n3. The first two digits must be different.\n4. For all subsequent digits, even indices (0-based) must match the first digit, and odd indices must match the second digit.\n\nHere's the implementation:\n\n```rust\nfn is_undulating(n: isize) -> bool {\n    if n < 0 {\n        return false;\n    }\n\n    let s = n.to_string();\n    let len = s.len();\n\n    if len < 2 {\n        return false;\n    }\n\n    if s.chars().nth(0) == s.chars().nth(1) {\n        return false;\n    }\n\n    let a = s.chars().nth(0).unwrap();\n    let b = s.chars().nth(1).unwrap();\n\n    for i in 2..len {\n        let c = s.chars().nth(i).unwrap();\n        if i % 2 == 0 {\n            if c != a {\n                return false;\n            }\n        } else {\n            if c != b {\n                return false;\n            }\n        }\n    }\n\n    true\n}\n```\n\n**Explanation:**\n1. **Non-negative check:** The function immediately returns `false` for negative numbers since undulating numbers are defined for non-negative integers.\n2. **String conversion:** The number is converted to a string to process its digits.\n3. **Minimum length check:** Numbers with fewer than two digits cannot be undulating (as the pattern requires at least two distinct digits), so it returns `false`.\n4. **First two digits check:** The first two digits must be different; if they are the same, it returns `false`.\n5. **Pattern validation:** The function then checks that:\n   - Every even index (0, 2, 4, ...) matches the first digit.\n   - Every odd index (1, 3, 5, ...) matches the second digit.\n   If any digit fails this check, it returns `false`; otherwise, it returns `true`.\n\nThis implementation efficiently checks the undulating condition by leveraging string manipulation and early termination upon encountering any invalid digit. The solution handles all edge cases, including single-digit numbers and numbers with leading zeros (which are not possible in standard integer representation). The time complexity is O(d), where d is the number of digits in the input number.", "\n\nTo determine if a given number is undulating, we follow these steps:\n1. **Check for negative numbers**: Undulating numbers are defined for positive integers, so negative numbers are immediately disqualified.\n2. **Check string length**: Undulating numbers must have at least 3 digits (e.g., 121), so numbers with fewer than 3 digits are not undulating.\n3. **Check for exactly two distinct digits**: The digits must alternate between two different digits. We collect all distinct digits in the number's string representation and verify there are exactly two.\n4. **Check alternating pattern**: Ensure no two consecutive digits are the same. This is done by iterating through the digits and comparing each digit with the previous one.\n\nHere's the implementation:\n\n```rust\nfn is_undulating(n: isize) -> bool {\n    if n < 0 {\n        return false;\n    }\n    let s = n.to_string();\n    if s.len() < 3 {\n        return false;\n    }\n    let distinct: std::collections::HashSet<char> = s.chars().collect();\n    if distinct.len() != 2 {\n        return false;\n    }\n    let mut prev = s.chars().next().unwrap();\n    for c in s.chars() {\n        if c == prev {\n            return false;\n        }\n        prev = c;\n    }\n    true\n}\n```\n\n**Explanation**:\n- **Negative Check**: The function returns `false` for any negative number.\n- **Length Check**: Numbers with less than 3 digits (e.g., single-digit or two-digit numbers) are not undulating.\n- **Distinct Digits Check**: The function collects all unique digits from the number's string representation. If there aren't exactly two distinct digits, it returns `false`.\n- **Alternating Pattern Check**: The function iterates through each digit, ensuring each digit is different from the previous one. If any consecutive digits are the same, it returns `false`; otherwise, it returns `true`.\n\nThis implementation efficiently checks all conditions for an undulating number as per the problem's requirements. For example:\n- `is_undulating(121)` returns `true` (digits \"1\", \"2\", \"1\" alternate between two distinct digits).\n- `is_undulating(101)` returns `true` (digits \"1\", \"0\", \"1\" alternate).\n- `is_undulating(12)` returns `false` (only 2 digits).\n- `is_undulating(-1)` returns `false` (negative number).", "\n\nTo determine if a given number is undulating, we need to check if its digits alternate between two different digits. An undulating number must have at least two digits, and the first two digits must be different. Subsequent digits must follow the alternating pattern: even indices (0-based) should match the first digit, and odd indices should match the second digit.\n\n### Approach\n1. **Handle Negative Numbers**: Undulating numbers are defined for positive integers. If the input number is negative, return `false`.\n2. **Convert to String**: Convert the absolute value of the number (to handle non-negative numbers) into a string for digit processing.\n3. **Check Length**: If the string has only one digit, it cannot be undulating (return `false`).\n4. **Check First Two Digits**: The first two digits must be different; otherwise, return `false`.\n5. **Check Alternating Pattern**: For each subsequent digit (from index 2 onwards):\n   - If the index is even (0-based), the digit must match the first digit.\n   - If the index is odd, the digit must match the second digit.\n   - If any digit does not follow this pattern, return `false`.\n6. **Return Result**: If all digits satisfy the pattern, return `true`.\n\n### Solution Code\n```rust\nfn is_undulating(n: isize) -> bool {\n    if n < 0 {\n        return false;\n    }\n    let s = n.to_string();\n    let len = s.len();\n    if len < 2 {\n        return false;\n    }\n    let first_char = s.chars().nth(0).unwrap();\n    let second_char = s.chars().nth(1).unwrap();\n    if first_char == second_char {\n        return false;\n    }\n    for i in 2..len {\n        let c = s.chars().nth(i).unwrap();\n        if i % 2 == 0 {\n            if c != first_char {\n                return false;\n            }\n        } else {\n            if c != second_char {\n                return false;\n            }\n        }\n    }\n    true\n}\n```\n\n### Explanation\n1. **Negative Check**: The function immediately returns `false` for any negative number since undulating numbers are positive.\n2. **String Conversion**: The number is converted to a string to process individual digits.\n3. **Length Check**: A single-digit number is not undulating, so the function returns `false`.\n4. **First Two Digits**: The first two digits must differ; if they are the same, the function returns `false`.\n5. **Pattern Validation**: Starting from the third digit (index 2), each digit is checked:\n   - At even indices (0, 2, 4, ...), the digit must match the first digit.\n   - At odd indices (1, 3, 5, ...), the digit must match the second digit.\n   - If any digit fails this check, the function returns `false`.\n6. **Result**: If all digits pass the checks, the function returns `true`, confirming the number is undulating.\n\nThis approach efficiently checks for the undulating property by leveraging string manipulation and straightforward iteration, ensuring correctness for all valid inputs within the constraints of the problem."]}
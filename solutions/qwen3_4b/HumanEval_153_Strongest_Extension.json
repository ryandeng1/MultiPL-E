{"name": "HumanEval_153_Strongest_Extension", "language": "rs", "prompt": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_153_Strongest_Extension.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve this problem, we need to determine the strongest extension for a given class name based on the strength calculated from the extension's name. The strength is defined as the difference between the number of uppercase letters (CAP) and the number of lowercase letters (SM) in the extension's name. The goal is to find the extension with the highest strength. If multiple extensions have the same strength, we select the one that appears first in the provided vector.\n\n### Approach\n1. **Problem Analysis**: The problem requires processing each extension in the given vector to compute its strength (CAP - SM). The strength is an integer derived from counting uppercase and lowercase letters in each extension's name.\n2. **Key Insight**: The strongest extension is the one with the highest strength value. If two extensions have the same strength, the one that appears first in the vector is chosen.\n3. **Algorithm Selection**: \n   - Iterate through each extension in the vector.\n   - For each extension, count the number of uppercase letters (CAP) and lowercase letters (SM).\n   - Compute the strength as `CAP - SM`.\n   - Track the extension with the highest strength encountered during the iteration. If the same strength is found again, the first occurrence is retained.\n4. **Edge Cases**: \n   - If the vector of extensions is empty, return the class name without any extension.\n   - The solution efficiently handles non-empty vectors by initializing with the first extension and updating only when a higher strength is found.\n\n### Solution Code\n```rust\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    if extensions.is_empty() {\n        return class_name;\n    }\n\n    let mut best_extension = extensions[0].clone();\n    let mut best_strength = {\n        let cap = extensions[0].chars().filter(|c| c.is_uppercase()).count();\n        let sm = extensions[0].chars().filter(|c| c.is_lowercase()).count();\n        (cap as i32) - (sm as i32)\n    };\n\n    for i in 1..extensions.len() {\n        let ext = &extensions[i];\n        let cap = ext.chars().filter(|c| c.is_uppercase()).count();\n        let sm = ext.chars().filter(|c| c.is_lowercase()).count();\n        let strength = (cap as i32) - (sm as i32);\n\n        if strength > best_strength {\n            best_strength = strength;\n            best_extension = ext.clone();\n        }\n    }\n\n    format!(\"{}.{}\", class_name, best_extension)\n}\n```\n\n### Explanation\n1. **Initial Check**: The function first checks if the extensions vector is empty. If it is, the class name is returned as-is.\n2. **Initialization**: The first extension in the vector is used as the initial candidate for the strongest extension (`best_extension`), and its strength is computed (`best_strength`).\n3. **Iteration**: The function iterates over the remaining extensions in the vector. For each extension:\n   - It counts the number of uppercase letters (`cap`) and lowercase letters (`sm`).\n   - The strength is calculated as `cap - sm`.\n   - If the computed strength is greater than the current `best_strength`, the `best_extension` and `best_strength` are updated.\n4. **Result Construction**: After processing all extensions, the result is constructed by concatenating the class name with the strongest extension (e.g., `\"ClassName.StrongestExtensionName\"`).\n\nThis approach efficiently processes each extension exactly once, ensuring optimal performance with a time complexity of O(n), where n is the number of extensions. The solution handles edge cases such as empty extension vectors and correctly selects the strongest extension based on the problem's specifications.", "\n\nTo solve this problem, we need to determine the strongest extension for a given class name based on specific strength criteria. The strength of each extension is calculated as the difference between the number of uppercase letters (CAP) and the number of lowercase letters (SM) in its name. The goal is to select the extension with the highest strength. If multiple extensions have the same strength, the one that appears first in the vector is chosen.\n\n### Approach\n1. **Problem Analysis**: The problem requires processing each extension in the vector to compute its strength (CAP - SM). The extension with the highest strength is selected. In case of a tie, the earliest extension in the vector is chosen.\n2. **Key Insight**: For each extension, iterate through its characters to count uppercase and lowercase letters. The strength is then derived from this count.\n3. **Algorithm Selection**: \n   - Initialize `best_extension` to an empty string and `best_strength` to the smallest possible integer (`i32::MIN`).\n   - For each extension in the vector:\n     - Count uppercase (`cap`) and lowercase (`sm`) characters.\n     - Calculate the strength as `cap - sm`.\n     - If this strength is greater than `best_strength`, update `best_extension` and `best_strength`.\n4. **Complexity Analysis**: The algorithm processes each character in every extension once. If there are `n` extensions and each has `m` characters, the time complexity is O(n*m), which is efficient for typical inputs.\n\n### Solution Code\n```rust\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let mut best_extension = String::new();\n    let mut best_strength = i32::MIN;\n    for ext in extensions {\n        let mut cap = 0;\n        let mut sm = 0;\n        for c in ext.chars() {\n            if c.is_uppercase() {\n                cap += 1;\n            } else if c.is_lowercase() {\n                sm += 1;\n            }\n        }\n        let strength = cap - sm;\n        if strength > best_strength {\n            best_strength = strength;\n            best_extension = ext.clone();\n        }\n    }\n    format!(\"{}.{}\", class_name, best_extension)\n}\n```\n\n### Explanation\n1. **Initialization**: `best_extension` starts as an empty string, and `best_strength` is initialized to the smallest possible integer (`i32::MIN`) to ensure any extension's strength will be higher initially.\n2. **Processing Extensions**: For each extension in the vector:\n   - **Character Counting**: Iterate over each character in the extension to count uppercase (`cap`) and lowercase (`sm`) letters.\n   - **Strength Calculation**: Compute the strength as `cap - sm`.\n   - **Update Best Extension**: If the current extension's strength is greater than `best_strength`, update `best_extension` and `best_strength`.\n3. **Result Construction**: After processing all extensions, format the result as `class_name.best_extension` and return it.\n\nThis approach efficiently processes each extension to determine the strongest one based on the given criteria, ensuring correctness and optimal performance.", "\n\nTo solve this problem, we need to determine the strongest extension for a given class name based on specific strength criteria. The strength of each extension is calculated as the difference between the number of uppercase letters (CAP) and the number of lowercase letters (SM) in its name. The goal is to find the extension with the highest strength, and if there are multiple extensions with the same strength, choose the one that appears first in the vector.\n\n### Approach\n1. **Initialization**: Start by checking if the extensions vector is empty. If it is, return the class name as is (though the problem implies the vector is non-empty).\n2. **Calculate Initial Strength**: For the first extension in the vector, count the number of uppercase and lowercase letters to compute its initial strength (CAP - SM).\n3. **Iterate Through Extensions**: For each subsequent extension in the vector:\n   - Count the number of uppercase and lowercase letters.\n   - Compute its strength (CAP - SM).\n   - If this strength is greater than the current maximum strength, update the strongest extension and the maximum strength.\n4. **Construct Result**: Format the result as `ClassName.StrongestExtensionName` and return it.\n\n### Solution Code\n```rust\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    if extensions.is_empty() {\n        return class_name;\n    }\n    let mut strongest_extension = extensions[0].clone();\n    let mut max_strength = 0;\n    \n    let mut cap = 0;\n    let mut sm = 0;\n    for c in strongest_extension.chars() {\n        if c.is_uppercase() {\n            cap += 1;\n        } else if c.is_lowercase() {\n            sm += 1;\n        }\n    }\n    max_strength = (cap - sm) as i32;\n\n    for i in 1..extensions.len() {\n        let ext = &extensions[i];\n        let mut cap = 0;\n        let mut sm = 0;\n        for c in ext.chars() {\n            if c.is_uppercase() {\n                cap += 1;\n            } else if c.is_lowercase() {\n                sm += 1;\n            }\n        }\n        let strength = (cap - sm) as i32;\n        if strength > max_strength {\n            max_strength = strength;\n            strongest_extension = ext.clone();\n        }\n    }\n    format!(\"{}.{}\", class_name, strongest_extension)\n}\n```\n\n### Explanation\n1. **Initialization**: The function starts by checking if the extensions vector is empty. If it is, it returns the class name directly.\n2. **First Extension Processing**: The first extension in the vector is processed to count its uppercase (`cap`) and lowercase (`sm`) letters. The initial strength is calculated as `cap - sm`.\n3. **Subsequent Extensions Processing**: For each remaining extension:\n   - The code counts the uppercase and lowercase letters.\n   - The strength of the current extension is computed.\n   - If this strength is greater than the current maximum strength, the strongest extension and maximum strength are updated.\n4. **Result Construction**: Finally, the result is formatted as `ClassName.StrongestExtensionName` using the `format!` macro.\n\nThis approach efficiently processes each extension once, ensuring optimal performance with a time complexity of O(n * m), where `n` is the number of extensions and `m` is the average length of each extension. The solution correctly handles ties by selecting the first extension with the highest strength, as required."]}
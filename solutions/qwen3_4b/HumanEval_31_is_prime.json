{"name": "HumanEval_31_is_prime", "language": "rs", "prompt": "/// Return true if a given number is prime, and false otherwise.\n/// >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n/// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n/// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n: isize) -> bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_31_is_prime.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo determine if a given number is prime, we need to check for divisibility by numbers up to the square root of the number. The solution efficiently handles edge cases and checks only odd divisors to optimize performance.\n\n### Approach\n1. **Edge Cases Handling**: \n   - If the number `n` is less than 2, it is not prime (since primes are defined as natural numbers greater than 1).\n   - If the number is exactly 2, it is the smallest prime.\n   - If the number is even and greater than 2, it is not prime (as all even numbers greater than 2 are divisible by 2).\n\n2. **Odd Divisor Check**:\n   - For numbers greater than 2 that are odd, check divisibility by odd numbers starting from 3 up to the integer square root of `n`.\n   - The condition `i <= n / i` is used to avoid overflow and efficiently limit the loop to `i` values up to the square root of `n`.\n\n### Solution Code\n```rust\nfn is_prime(n: isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    let mut i = 3;\n    while i <= n / i {\n        if n % i == 0 {\n            return false;\n        }\n        i += 2;\n    }\n    true\n}\n```\n\n### Explanation\n1. **Edge Cases**:\n   - `n < 2` returns `false` because numbers less than 2 are not prime.\n   - `n == 2` returns `true` as 2 is the only even prime number.\n   - If `n` is even and not 2, it returns `false` since such numbers are divisible by 2.\n\n2. **Odd Divisor Check**:\n   - The loop starts from `i = 3` (the first odd number after 2) and checks divisibility up to `n / i` (which ensures `i` does not exceed the square root of `n`).\n   - For each `i`, if `n` is divisible by `i`, the function returns `false`.\n   - The loop increments `i` by 2 each time to check only odd divisors, skipping even numbers for efficiency.\n\nThis approach efficiently checks for primality by leveraging mathematical insights (like checking up to the square root) and optimizations (like skipping even divisors), ensuring correctness for all valid inputs within the problem constraints. The solution handles all specified examples correctly, such as `is_prime(6) = false`, `is_prime(101) = true`, and `is_prime(1) = false`.", "\n\nTo determine if a given number is prime, we need to check if it is greater than 1 and has no divisors other than 1 and itself. The solution efficiently handles edge cases (numbers less than 2, even numbers) and checks for divisors only up to the square root of the number to avoid unnecessary computations.\n\n### Approach\n1. **Edge Cases Handling**:\n   - If the number `n` is less than 2, it is not prime (returns `false`).\n   - If the number is exactly 2, it is the only even prime (returns `true`).\n   - If the number is even and not 2, it is not prime (returns `false`).\n\n2. **Odd Divisors Check**:\n   - For odd numbers greater than 2, iterate through potential divisors starting from 3, incrementing by 2 (to skip even divisors).\n   - The loop runs while the current divisor `i` is less than or equal to `n / i` (to avoid overflow and ensure efficiency).\n   - If any divisor `i` divides `n` without a remainder, return `false` (not prime).\n   - If no divisors are found after the loop, return `true` (prime).\n\nThis approach efficiently checks for primality by leveraging mathematical insights (only checking up to the square root of `n`) and avoiding even divisors after the initial check.\n\n### Solution Code\n```rust\nfn is_prime(n: isize) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    let mut i = 3;\n    while i <= n / i {\n        if n % i == 0 {\n            return false;\n        }\n        i += 2;\n    }\n    true\n}\n```\n\n### Explanation\n1. **Edge Cases**:\n   - Numbers less than 2 (like 0, 1, -1, etc.) are immediately identified as non-prime.\n   - The number 2 is the only even prime and is handled separately.\n   - Any even number greater than 2 is non-prime (e.g., 4, 6, 8, etc.).\n\n2. **Odd Divisors Check**:\n   - Starting from 3, the loop checks each odd number up to the square root of `n`.\n   - The condition `i <= n / i` ensures that we do not compute `i * i` which could overflow for very large `n`, and it efficiently limits the loop to the necessary range (up to the square root of `n`).\n   - If `n` is divisible by any `i` during the loop, it is not prime, and the function returns `false`.\n   - If the loop completes without finding any divisors, the number is prime, and the function returns `true`.\n\nThis method efficiently checks for primality with optimal performance, especially for large numbers, by minimizing the number of divisions and avoiding potential overflow issues.", "\n\nTo determine whether a given number is prime, we need to implement a function that checks for primality based on the mathematical definition: a prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\n\n---\n\n### \u2705 Key Observations\n\n1. **Numbers \u2264 1** are **not** prime.\n2. **2** is the only even prime number.\n3. All other even numbers (i.e., divisible by 2) are **not** prime.\n4. For odd numbers greater than 2, we only need to check divisibility by **odd integers** up to the **square root** of the number. This significantly reduces the number of checks needed.\n\n---\n\n### \ud83e\udde0 Efficient Prime Check Algorithm\n\nHere's the step-by-step logic:\n\n1. If `n <= 1`, return `false`.\n2. If `n == 2`, return `true`.\n3. If `n` is even (i.e., `n % 2 == 0`), return `false`.\n4. Start checking from `i = 3` in steps of 2 (only odd numbers).\n5. Continue checking while `i * i <= n`.\n6. If any `i` divides `n`, return `false`.\n7. If no divisors are found, return `true`.\n\nThis approach efficiently eliminates unnecessary checks and handles edge cases like negative numbers and small values correctly.\n\n---\n\n### \ud83d\udda5\ufe0f Rust Implementation\n\n```rust\nfn is_prime(n: isize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    let mut i = 3;\n    while i * i <= n {\n        if n % i == 0 {\n            return false;\n        }\n        i += 2;\n    }\n    true\n}\n```\n\n---\n\n### \u2705 Why This Works\n\n- **Handles edge cases** (e.g., `n = 1`, `n = 2`, `n = 4`) correctly.\n- **Avoids checking even numbers** after the initial check for 2.\n- **Only checks up to the square root** of `n`, which is sufficient to determine primality.\n- **Uses integer arithmetic** to avoid floating-point inaccuracies.\n- **Works for all `isize` values**, including negative numbers (which return `false` as expected).\n\n---\n\n### \ud83e\uddea Test Cases\n\n| Input  | Output | Explanation |\n|--------|--------|---------------|\n| `6`    | `false` | Divisible by 2 and 3 |\n| `101`  | `true`  | Prime |\n| `11`   | `true`  | Prime |\n| `13441`| `true`  | Prime |\n| `61`   | `true`  | Prime |\n| `4`    | `false` | Even |\n| `1`    | `false` | Not greater than 1 |\n\nAll test cases match the expected behavior.\n\n---\n\n### \u2705 Final Answer\n\n```rust\nfn is_prime(n: isize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    let mut i = 3;\n    while i * i <= n {\n        if n % i == 0 {\n            return false;\n        }\n        i += 2;\n    }\n    true\n}\n```"]}
{"name": "mbpp_783_rgb_to_hsv", "language": "rs", "prompt": "/// Write a function to convert rgb color to hsv color. https://www.geeksforgeeks.org/program-change-rgb-color-model-hsv-color-model/\nfn rgb_to_hsv(r: isize, g: isize, b: isize) -> Vec<f64> {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_783_rgb_to_hsv.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = rgb_to_hsv;\n    assert_eq!(candidate(255, 255, 255), vec![0.0, 0.0, 100.0]);\n    assert_eq!(candidate(0, 215, 0), vec![120.0, 100.0, 84.31372549019608]);\n    assert_eq!(candidate(10, 215, 110), vec![149.26829268292684, 95.34883720930233, 84.31372549019608]);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo convert RGB color values to HSV color values, we follow a standard algorithm that normalizes the input values, computes the maximum and minimum values, calculates the hue, saturation, and value components, and ensures the results are within the correct ranges.\n\n### Approach\n1. **Normalization**: Convert the input RGB values (0-255) to the range [0, 1] by dividing each by 255.0.\n2. **Compute Extremes**: Find the maximum and minimum of the normalized RGB values.\n3. **Delta Calculation**: Compute the difference (delta) between the maximum and minimum values.\n4. **Hue Calculation**:\n   - If all values are equal (delta = 0), the hue is 0 (grayscale).\n   - Otherwise, determine the hue based on which component is the maximum:\n     - If red is the maximum: `h = 60.0 * ( (green - blue) / delta )`\n     - If green is the maximum: `h = 60.0 * ( (blue - red) / delta + 2.0 )`\n     - If blue is the maximum: `h = 60.0 * ( (red - green) / delta + 4.0 )`\n   - Normalize the hue to the range [0, 360) degrees.\n5. **Saturation and Value**:\n   - Saturation (S) is `(delta / max_val) * 100.0` (in percentage).\n   - Value (V) is `max_val * 100.0` (in percentage).\n\n### Solution Code\n```rust\nfn rgb_to_hsv(r: isize, g: isize, b: isize) -> Vec<f64> {\n    let r_norm = r as f64 / 255.0;\n    let g_norm = g as f64 / 255.0;\n    let b_norm = b as f64 / 255.0;\n\n    let max_val = r_norm.max(g_norm).max(b_norm);\n    let min_val = r_norm.min(g_norm).min(b_norm);\n    let delta = max_val - min_val;\n\n    if delta == 0.0 {\n        vec![0.0, 0.0, max_val * 100.0]\n    } else {\n        let mut h = 0.0;\n        if max_val == r_norm {\n            h = 60.0 * ((g_norm - b_norm) / delta);\n        } else if max_val == g_norm {\n            h = 60.0 * ((b_norm - r_norm) / delta + 2.0);\n        } else {\n            h = 60.0 * ((r_norm - g_norm) / delta + 4.0);\n        }\n\n        let h = h % 360.0;\n        if h < 0.0 {\n            h += 360.0;\n        }\n\n        let s = (delta / max_val) * 100.0;\n        let v = max_val * 100.0;\n\n        vec![h, s, v]\n    }\n}\n```\n\n### Explanation\n1. **Normalization**: The input RGB values (as `isize`) are converted to `f64` and divided by 255.0 to scale them to the range [0, 1].\n2. **Extremes Calculation**: The maximum and minimum values among the normalized RGB components are identified.\n3. **Delta Calculation**: The difference between the maximum and minimum values is computed to determine the color's saturation.\n4. **Hue Calculation**:\n   - For non-gray colors (delta \u2260 0), the hue is calculated based on which component (red, green, or blue) is the maximum. This involves specific formulas that account for the color's position in the HSV color wheel.\n   - The hue is then normalized to the range [0, 360) degrees to ensure it is within the valid range.\n5. **Saturation and Value**:\n   - Saturation is derived as a percentage of the maximum value relative to the delta.\n   - Value is the maximum normalized value scaled to a percentage (0-100).\n\nThis approach efficiently converts RGB values to HSV values while adhering to standard color space conversion principles, ensuring correctness for typical RGB inputs (0-255). The output is a vector of three `f64` values representing hue (0-360 degrees), saturation (0-100%), and value (0-100%).", "\n\nTo convert RGB color values to HSV color values, we follow the standard algorithm from the GeeksforGeeks resource. The RGB values are assumed to be in the range [0, 255] (integers). The process involves normalizing the RGB values to the range [0, 1], computing the maximum and minimum values, determining the color difference, and then calculating the hue, saturation, and value components.\n\n### Approach\n1. **Normalize RGB Values**: Convert each RGB value from the range [0, 255] to [0, 1] by dividing by 255.0.\n2. **Find Max and Min Values**: Identify the maximum and minimum of the normalized RGB values.\n3. **Calculate Delta**: Compute the difference between the maximum and minimum values.\n4. **Handle Grayscale Case**: If the delta is zero, the color is grayscale, so the hue is 0, saturation is 0, and value is 100% of the maximum value.\n5. **Calculate Saturation and Value**: For non-grayscale colors:\n   - Saturation (S) is calculated as `(delta / max_val) * 100.0`.\n   - Value (V) is calculated as `max_val * 100.0`.\n6. **Determine Hue**:\n   - Identify which channel (R, G, or B) has the maximum value using integer comparisons (to avoid floating-point precision issues).\n   - Compute the hue based on the maximum channel:\n     - If R is the maximum: `h = (G - B) / delta`\n     - If G is the maximum: `h = (B - R) / delta + 2.0`\n     - If B is the maximum: `h = (R - G) / delta + 4.0`\n   - Convert the hue to degrees: `h = h * 60.0`\n   - Normalize the hue to the range [0, 360) by taking modulo 360 and adjusting for negative values.\n7. **Return Result**: Return a vector containing the hue, saturation, and value as floating-point numbers.\n\n### Solution Code\n```rust\nfn rgb_to_hsv(r: isize, g: isize, b: isize) -> Vec<f64> {\n    let r = r as f64 / 255.0;\n    let g = g as f64 / 255.0;\n    let b = b as f64 / 255.0;\n\n    let max_val = r.max(g).max(b);\n    let min_val = r.min(g).min(b);\n    let delta = max_val - min_val;\n\n    if delta == 0.0 {\n        vec![0.0, 0.0, max_val * 100.0]\n    } else {\n        let s = (delta / max_val) * 100.0;\n        let v = max_val * 100.0;\n\n        let max_channel = if r >= g && r >= b {\n            0\n        } else if g >= r && g >= b {\n            1\n        } else {\n            2\n        };\n\n        let mut h = 0.0;\n        match max_channel {\n            0 => {\n                h = (g - b) / delta;\n            }\n            1 => {\n                h = (b - r) / delta + 2.0;\n            }\n            2 => {\n                h = (r - g) / delta + 4.0;\n            }\n        }\n\n        h = h * 60.0;\n        h = h % 360.0;\n        if h < 0.0 {\n            h += 360.0;\n        }\n\n        vec![h, s, v]\n    }\n}\n```\n\n### Explanation\n1. **Normalization**: The RGB values are converted from integers (0-255) to floating-point values in the range [0, 1] by dividing each by 255.0.\n2. **Max and Min Calculation**: The maximum and minimum of the normalized RGB values are found to determine the color's intensity range.\n3. **Delta Calculation**: The difference between the maximum and minimum values (`delta`) is used to compute saturation.\n4. **Grayscale Handling**: If `delta` is zero, the color is grayscale, resulting in a hue of 0, saturation of 0, and value equal to 100% of the maximum value.\n5. **Hue Calculation**:\n   - The channel with the highest value (R, G, or B) is identified using integer comparisons to avoid floating-point inaccuracies.\n   - Based on the identified channel, the hue is computed using specific formulas that account for the color differences between the other channels.\n   - The hue is converted from a 0-6 scale to degrees (0-360) and normalized to the range [0, 360).\n6. **Saturation and Value**: Saturation is derived from `delta / max_val` (scaled to 0-100%), and value is the maximum normalized value scaled to 0-100%.\n\nThis approach efficiently converts RGB to HSV while handling edge cases (like grayscale) and ensuring numerical stability through integer comparisons for channel identification. The resulting HSV values are in the standard format: hue (0-360 degrees), saturation (0-100%), and value (0-100%).", "\n\nTo convert RGB color values to HSV color values, we follow the standard algorithm used in color theory. The RGB values are first normalized to the range [0, 1] by dividing each by 255.0 (with clamping to ensure they stay within [0, 255] to handle invalid inputs). The algorithm then computes the maximum and minimum RGB values, the difference (delta), and based on which channel is the maximum, calculates the hue (H), saturation (S), and value (V).\n\n### Approach\n1. **Normalize RGB Values**: Convert each RGB value from `isize` to `f64` and clamp to the range [0, 255] to handle any out-of-range inputs. Then divide by 255.0 to normalize to [0, 1].\n2. **Compute Max and Min Values**: Determine the maximum and minimum of the normalized RGB values.\n3. **Calculate Delta**: Compute the difference between the maximum and minimum values.\n4. **Handle Grayscale**: If delta is zero (all values equal), the color is grayscale. Return H=0, S=0, V=max_val.\n5. **Calculate Hue (H)**:\n   - If the maximum value is red (r_f), H = 60 * (g_f - b_f) / delta.\n   - If the maximum value is green (g_f), H = 60 * (b_f - r_f) / delta + 120.\n   - If the maximum value is blue (b_f), H = 60 * (r_f - g_f) / delta + 240.\n6. **Normalize Hue**: Ensure H is in the range [0, 360) by adjusting negative values.\n7. **Calculate Saturation (S) and Value (V)**: S is delta divided by max_val, and V is max_val.\n\n### Solution Code\n```rust\nfn rgb_to_hsv(r: isize, g: isize, b: isize) -> Vec<f64> {\n    let r_f = (r as f64).clamp(0.0, 255.0) / 255.0;\n    let g_f = (g as f64).clamp(0.0, 255.0) / 255.0;\n    let b_f = (b as f64).clamp(0.0, 255.0) / 255.0;\n\n    let max_val = r_f.max(g_f).max(b_f);\n    let min_val = r_f.min(g_f).min(b_f);\n    let delta = max_val - min_val;\n\n    if delta == 0.0 {\n        return vec![0.0, 0.0, max_val];\n    }\n\n    let mut h = 0.0;\n    if max_val == r_f {\n        h = 60.0 * ((g_f - b_f) / delta);\n    } else if max_val == g_f {\n        h = 60.0 * ((b_f - r_f) / delta) + 120.0;\n    } else {\n        h = 60.0 * ((r_f - g_f) / delta) + 240.0;\n    }\n\n    h = h % 360.0;\n    if h < 0.0 {\n        h += 360.0;\n    }\n\n    let s = delta / max_val;\n    let v = max_val;\n\n    vec![h, s, v]\n}\n```\n\n### Explanation\n1. **Normalization**: The RGB values are converted from `isize` to `f64` and clamped to [0, 255] to ensure they are valid. They are then divided by 255.0 to scale them to [0, 1].\n2. **Max and Min Values**: The maximum and minimum of the normalized RGB values are found to determine the color's brightness (V) and saturation (S).\n3. **Delta Calculation**: The difference between the max and min values (delta) is used to compute the saturation (S) and the hue (H).\n4. **Hue Calculation**: Depending on which channel (red, green, or blue) holds the maximum value, the hue is calculated using specific formulas. This ensures the hue is correctly positioned in the 0-360 degree range.\n5. **Hue Normalization**: The computed hue is adjusted to be within [0, 360) by taking modulo 360 and adding 360 if negative.\n6. **Saturation and Value**: Saturation (S) is the ratio of delta to the max value, and value (V) is the max value itself.\n\nThis approach efficiently converts RGB values to HSV while handling edge cases like grayscale and ensuring the results are in the correct ranges. The solution is robust and follows the standard color conversion algorithm used in graphics and color theory."]}
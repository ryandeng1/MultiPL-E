{"name": "HumanEval_156_int_to_mini_roman", "language": "rs", "prompt": "/// Given a positive integer, obtain its roman numeral equivalent as a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n/// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>> int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n/// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_156_int_to_mini_roman.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve this problem, we need to convert a given positive integer (between 1 and 1000) into its corresponding Roman numeral representation in lowercase. The key insight is to leverage the standard Roman numeral system with subtractive notation, where smaller numerals precede larger ones to indicate subtraction (e.g., IV for 4, IX for 9).\n\n### Approach\n1. **Roman Numeral Mapping**: We define a list of tuples where each tuple contains a numeric value and its corresponding Roman numeral symbol. This list is ordered from the highest value to the lowest, including subtractive pairs (e.g., 900 maps to \"cm\").\n2. **Iterative Processing**: For each number, we iterate through the predefined list of value-symbol pairs. For each pair, we repeatedly append the symbol to the result string as long as the current number is greater than or equal to the value. We then subtract the value from the number.\n3. **String Construction**: The result is built by appending symbols in descending order of their values, ensuring that subtractive pairs are correctly handled (e.g., 4 becomes \"iv\" instead of \"iiii\").\n\nThis approach efficiently processes each number by breaking it down into its constituent parts (thousands, hundreds, tens, ones) and constructs the Roman numeral string in lowercase as required.\n\n### Solution Code\n```rust\nfn int_to_mini_roman(number: isize) -> String {\n    let roman_map = vec![\n        (1000, \"m\"),\n        (900, \"cm\"),\n        (500, \"d\"),\n        (400, \"cd\"),\n        (100, \"c\"),\n        (90, \"xc\"),\n        (50, \"l\"),\n        (40, \"xl\"),\n        (10, \"x\"),\n        (9, \"ix\"),\n        (5, \"v\"),\n        (4, \"iv\"),\n        (1, \"i\"),\n    ];\n\n    let mut result = String::new();\n    for (value, symbol) in roman_map {\n        while number >= value {\n            result.push_str(symbol);\n            number -= value;\n        }\n    }\n    result\n}\n```\n\n### Explanation\n1. **Roman Numeral Mapping**: The `roman_map` vector contains tuples of numeric values and their corresponding lowercase Roman numeral strings. The values are ordered from highest to lowest to ensure correct processing.\n2. **String Construction**: The algorithm initializes an empty string `result`. It then iterates over each value-symbol pair in `roman_map`. For each pair, it checks if the current number is at least the value. If so, it appends the symbol to `result` and subtracts the value from the number. This loop continues until the number is less than the current value.\n3. **Efficiency**: The algorithm efficiently processes each number in linear time relative to the number of Roman numeral symbols (13 in this case), making it optimal for the given constraints (1 \u2264 num \u2264 1000).\n\nThis solution correctly handles all edge cases, including numbers that require subtractive notation (e.g., 4 \u2192 \"iv\", 9 \u2192 \"ix\", 40 \u2192 \"xl\"), and ensures the output is in lowercase as specified.\n\n**Final Answer**\n```rust\nfn int_to_mini_roman(number: isize) -> String {\n    let roman_map = vec![\n        (1000, \"m\"),\n        (900, \"cm\"),\n        (500, \"d\"),\n        (400, \"cd\"),\n        (100, \"c\"),\n        (90, \"xc\"),\n        (50, \"l\"),\n        (40, \"xl\"),\n        (10, \"x\"),\n        (9, \"ix\"),\n        (5, \"v\"),\n        (4, \"iv\"),\n        (1, \"i\"),\n    ];\n\n    let mut result = String::new();\n    for (value, symbol) in roman_map {\n        while number >= value {\n            result.push_str(symbol);\n            number -= value;\n        }\n    }\n    result\n}\n```", "\n\nTo solve this problem, we need to convert a positive integer (between 1 and 1000) into its corresponding Roman numeral representation in lowercase. The solution involves breaking down the number into its constituent parts (thousands, hundreds, tens, and ones) and mapping each part to the appropriate Roman numeral symbols.\n\n### Approach\n1. **Roman Numeral Mapping**: We use a predefined list of tuples that map integer values to their corresponding Roman numeral strings. This list is ordered from the highest value to the lowest, including subtractive notations (e.g., 900 is represented as \"cm\", 400 as \"cd\").\n2. **Constructing the Result**: For each value-symbol pair in the list, we check if the current number is greater than or equal to the value. If so, we append the corresponding symbol to the result string and subtract the value from the number. This process repeats until the number is reduced to zero.\n\n### Solution Code\n```rust\nfn int_to_mini_roman(number: isize) -> String {\n    let roman_numerals = vec![\n        (1000, \"m\"),\n        (900, \"cm\"),\n        (500, \"d\"),\n        (400, \"cd\"),\n        (100, \"c\"),\n        (90, \"xc\"),\n        (50, \"l\"),\n        (40, \"xl\"),\n        (10, \"x\"),\n        (9, \"ix\"),\n        (5, \"v\"),\n        (4, \"iv\"),\n        (1, \"i\"),\n    ];\n\n    let mut result = String::new();\n    for (value, symbol) in roman_numerals {\n        while number >= value {\n            result.push_str(symbol);\n            number -= value;\n        }\n    }\n    result\n}\n```\n\n### Explanation\n1. **Roman Numeral List**: The list `roman_numerals` contains tuples where each tuple consists of an integer value and its corresponding Roman numeral string in lowercase. The list is ordered from the highest value (1000) to the lowest (1), ensuring that we process the largest possible values first.\n2. **String Construction**: The algorithm iterates over each value-symbol pair in the list. For each pair, it checks if the current number is at least the value. If so, it appends the symbol to the result string and subtracts the value from the number. This loop continues until the number is less than the current value.\n3. **Result Handling**: The result string is built incrementally during the iteration. Since all symbols in the list are in lowercase, the final result is automatically in lowercase, meeting the problem's requirements.\n\nThis approach efficiently converts the integer to its Roman numeral equivalent by leveraging predefined mappings and a greedy algorithm that processes the largest values first, ensuring correctness and simplicity. The solution handles all edge cases within the specified range (1 to 1000) correctly.", "\n\nTo solve this problem, we need to convert a given positive integer (between 1 and 1000) into its corresponding Roman numeral representation in lowercase. The solution involves leveraging a predefined list of Roman numeral values and their corresponding symbols in descending order. By iteratively subtracting the largest possible values from the input number and appending the corresponding symbols, we can construct the Roman numeral string efficiently.\n\n### Approach\n1. **Problem Analysis**: The task is to convert an integer into a lowercase Roman numeral string. Roman numerals are constructed using specific symbols for values like 1 (I), 5 (V), 10 (X), 50 (L), 100 (C), 500 (D), and 1000 (M). Subtractive combinations (like IV for 4, IX for 9) are also used to represent numbers where a smaller value precedes a larger value.\n2. **Intuition**: The solution involves processing the input number from the largest possible Roman numeral value down to the smallest. For each value, if the current number is greater than or equal to this value, we append the corresponding symbol to the result and subtract the value from the number.\n3. **Algorithm Selection**: We use a list of tuples where each tuple contains a Roman numeral value and its corresponding symbol. This list is ordered from the highest value (1000) to the lowest (1). We iterate through this list, and for each value, we repeatedly append the symbol to the result string as long as the current number is at least the value. We then subtract the value from the number.\n4. **Complexity Analysis**: The algorithm processes each value in the list once, and for each value, it may process the number multiple times (up to the number of times the value fits into the number). However, since the list has a fixed size (13 elements) and the number is at most 1000, the time complexity is O(1), making it very efficient.\n\n### Solution Code\n```rust\nfn int_to_mini_roman(number: isize) -> String {\n    let roman_numerals = vec![\n        (1000, \"m\"),\n        (900, \"cm\"),\n        (500, \"d\"),\n        (400, \"cd\"),\n        (100, \"c\"),\n        (90, \"xc\"),\n        (50, \"l\"),\n        (40, \"xl\"),\n        (10, \"x\"),\n        (9, \"ix\"),\n        (5, \"v\"),\n        (4, \"iv\"),\n        (1, \"i\")\n    ];\n\n    let mut result = String::new();\n    for &(value, symbol) in roman_numerals.iter() {\n        while number >= value {\n            result.push_str(symbol);\n            number -= value;\n        }\n    }\n    result\n}\n```\n\n### Explanation\n1. **Initialization**: We define a list `roman_numerals` containing tuples of Roman numeral values and their corresponding symbols in descending order.\n2. **Processing the Number**: For each value-symbol pair in the list, we check if the current number is at least the value. If so, we append the symbol to the result string and subtract the value from the number.\n3. **Result Construction**: This process repeats until the number is reduced to zero, at which point the result string contains the Roman numeral representation of the original number in lowercase.\n4. **Efficiency**: The algorithm efficiently processes the number by leveraging the predefined list of values and symbols, ensuring optimal performance with a constant time complexity due to the fixed size of the list.\n\nThis approach ensures that all valid inputs (1 to 1000) are correctly converted into their lowercase Roman numeral equivalents, adhering to the problem constraints and requirements."]}
{"name": "mbpp_223_is_majority", "language": "rs", "prompt": "/// Write a function that takes in a sorted vector, its length (n), and an element and returns whether the element is the majority element in the given sorted vector. (The majority element is the element that occurs more than n/2 times.)\nfn is_majority(arr: Vec<isize>, n: isize, x: isize) -> bool {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_223_is_majority.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = is_majority;\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 3, 10], 7, 3), true);\n    assert_eq!(candidate(vec![1, 1, 2, 4, 4, 4, 6, 6], 8, 4), false);\n    assert_eq!(candidate(vec![1, 1, 1, 2, 2], 5, 1), true);\n    assert_eq!(candidate(vec![1, 1, 2, 2], 5, 1), false);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo determine if an element `x` is the majority element in a sorted vector `arr` of length `n`, we leverage the fact that in a sorted array, all occurrences of the same element are consecutive. The majority element must appear more than `n/2` times. \n\n### Approach\n1. **Find First Occurrence**: Use binary search to locate the first occurrence of `x` in the sorted array. This helps us determine the starting index of `x` in the array.\n2. **Find Last Occurrence**: Again, use binary search to locate the last occurrence of `x`. This gives us the ending index of `x` in the array.\n3. **Count Occurrences**: Calculate the number of occurrences of `x` as `last - first + 1`.\n4. **Check Majority Condition**: Verify if the count of `x` is greater than `n/2`.\n\nThis approach efficiently checks for the majority element in logarithmic time (O(log n)) due to the binary searches, making it optimal for large arrays.\n\n### Solution Code\n```rust\nfn is_majority(arr: Vec<isize>, n: isize, x: isize) -> bool {\n    let len = n as usize;\n    let mut low = 0;\n    let mut high = len - 1;\n    let mut first = -1;\n    while low <= high {\n        let mid = (low + high) / 2;\n        if arr[mid] < x {\n            low = mid + 1;\n        } else if arr[mid] > x {\n            high = mid - 1;\n        } else {\n            first = mid;\n            high = mid - 1;\n        }\n    }\n\n    if first == -1 {\n        return false;\n    }\n\n    low = 0;\n    high = len - 1;\n    let mut last = -1;\n    while low <= high {\n        let mid = (low + high) / 2;\n        if arr[mid] < x {\n            low = mid + 1;\n        } else if arr[mid] > x {\n            high = mid - 1;\n        } else {\n            last = mid;\n            low = mid + 1;\n        }\n    }\n\n    (last - first + 1) > (n / 2)\n}\n```\n\n### Explanation\n1. **Binary Search for First Occurrence**: The first binary search starts from the beginning of the array (`low = 0`) and moves towards the end (`high = len - 1`). When it finds `x`, it checks if this is the first occurrence by moving the `high` pointer left to find any earlier occurrences.\n2. **Binary Search for Last Occurrence**: The second binary search starts similarly but moves the `low` pointer right to find the last occurrence of `x`.\n3. **Count Check**: The number of occurrences of `x` is calculated as `last - first + 1`. This count is compared against `n / 2` (using integer division) to determine if `x` is a majority element.\n4. **Edge Handling**: If `x` is not found in the array (`first == -1`), the function immediately returns `false`.\n\nThis method efficiently checks for the majority element in a sorted array using binary search, ensuring optimal performance even for large input sizes. The solution handles all edge cases, including when the array has a single element or when the element does not exist in the array.", "\n\nTo determine whether an element `x` is the **majority element** in a sorted vector, we leverage the fact that in a sorted array, all occurrences of `x` are **consecutive**. The majority element must appear **more than `n/2` times**, where `n` is the length of the array.\n\n---\n\n### \u2705 Key Insight\n\nIn a **sorted** array:\n- If `x` is the majority element, it will appear in a **single contiguous block**.\n- We can efficiently find the **first and last occurrence** of `x` using binary search.\n- The count of `x` is then `last - first + 1`.\n- We check if this count satisfies:  \n  `2 * count > n` (this avoids floating-point division and ensures correctness for integer values).\n\n---\n\n### \ud83e\udde0 Why This Works\n\n1. **Binary Search for First Occurrence**: Finds the leftmost index where `x` appears.\n2. **Binary Search for Last Occurrence**: Finds the rightmost index where `x` appears.\n3. **Count Calculation**: `last - first + 1` gives the total number of times `x` appears.\n4. **Majority Check**: `2 * count > n` ensures that `x` appears more than half the time (since `count > n/2`).\n\nThis approach is **efficient** with a time complexity of **O(log n)** per search, making it optimal for large arrays.\n\n---\n\n### \ud83d\udd27 Implementation in Rust\n\nHere's the complete implementation:\n\n```rust\nfn is_majority(arr: Vec<isize>, n: isize, x: isize) -> bool {\n    // Find first occurrence of x\n    let mut low = 0;\n    let mut high = n as usize - 1;\n    let mut first = -1;\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if arr[mid] == x {\n            first = mid;\n            high = mid - 1;\n        } else if arr[mid] < x {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    if first == -1 {\n        return false;\n    }\n\n    // Find last occurrence of x\n    let mut low2 = 0;\n    let mut high2 = n as usize - 1;\n    let mut last = -1;\n    while low2 <= high2 {\n        let mid = low2 + (high2 - low2) / 2;\n        if arr[mid] == x {\n            last = mid;\n            low2 = mid + 1;\n        } else if arr[mid] < x {\n            low2 = mid + 1;\n        } else {\n            high2 = mid - 1;\n        }\n    }\n    if last == -1 {\n        return false;\n    }\n\n    let count = last - first + 1;\n    count * 2 > n\n}\n```\n\n---\n\n### \ud83d\udccc Notes\n\n- **Type Safety**: The function assumes `n` is a valid size (non-negative integer). In practice, Rust would enforce this via the `Vec`\u2019s length.\n- **Efficiency**: Uses binary search twice, resulting in **O(log n)** time complexity.\n- **Correctness**: The condition `count * 2 > n` ensures that `x` appears **more than `n/2` times**, which is the definition of a majority element.\n\n---\n\n### \u2705 Example Usage\n\n```rust\nlet arr = vec![1, 1, 2, 2, 2];\nlet n = 5;\nlet x = 2;\nassert!(is_majority(arr, n, x)); // Returns true\n\nlet x = 1;\nassert!(is_majority(arr, n, x)); // Returns true\n\nlet x = 3;\nassert!(!is_majority(arr, n, x)); // Returns false\n```\n\n---\n\n### \ud83c\udfaf Final Answer\n\n```rust\nfn is_majority(arr: Vec<isize>, n: isize, x: isize) -> bool {\n    let mut low = 0;\n    let mut high = n as usize - 1;\n    let mut first = -1;\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if arr[mid] == x {\n            first = mid;\n            high = mid - 1;\n        } else if arr[mid] < x {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    if first == -1 {\n        return false;\n    }\n\n    let mut low2 = 0;\n    let mut high2 = n as usize - 1;\n    let mut last = -1;\n    while low2 <= high2 {\n        let mid = low2 + (high2 - low2) / 2;\n        if arr[mid] == x {\n            last = mid;\n            low2 = mid + 1;\n        } else if arr[mid] < x {\n            low2 = mid + 1;\n        } else {\n            high2 = mid - 1;\n        }\n    }\n    if last == -1 {\n        return false;\n    }\n\n    let count = last - first + 1;\n    count * 2 > n\n}\n```", "\n\nTo solve this problem, we need to determine if a given element `x` is the majority element in a sorted vector. The majority element is defined as an element that occurs more than `n/2` times in the vector, where `n` is the length of the vector. \n\n### Approach\n1. **Problem Analysis**: The vector is sorted in non-decreasing order. The key insight here is that in a sorted array, all occurrences of a particular element `x` will be contiguous. Therefore, we can efficiently find the first and last occurrences of `x` using binary search.\n2. **Binary Search for First Occurrence**: We perform a binary search to find the first index where `x` appears in the vector. This involves adjusting the search range to find the leftmost occurrence of `x`.\n3. **Binary Search for Last Occurrence**: Similarly, we perform another binary search to find the last index where `x` appears in the vector. This involves adjusting the search range to find the rightmost occurrence of `x`.\n4. **Check Majority Condition**: Once we have the first and last occurrence indices of `x`, we calculate the total count of `x` as `last_occurrence - first_occurrence + 1`. We then check if this count is greater than `n/2` (equivalent to `2 * count > n` to avoid floating-point operations).\n\n### Solution Code\n```rust\nfn is_majority(arr: Vec<isize>, n: isize, x: isize) -> bool {\n    if n == 0 {\n        return false;\n    }\n\n    let n_usize = n as usize;\n    let mut low = 0;\n    let mut high = n_usize - 1;\n\n    while low <= high {\n        let mid = (low + high) / 2;\n        if arr[mid] < x {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    let first_occurrence = low;\n    if first_occurrence >= n_usize || arr[first_occurrence] != x {\n        return false;\n    }\n\n    low = 0;\n    high = n_usize - 1;\n    while low <= high {\n        let mid = (low + high) / 2;\n        if arr[mid] <= x {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    let last_occurrence = high;\n\n    let count = (last_occurrence - first_occurrence + 1) as isize;\n    count * 2 > n\n}\n```\n\n### Explanation\n1. **Initial Check**: If the vector length `n` is zero, return `false` since no element can be a majority.\n2. **First Occurrence Search**: \n   - Initialize `low` to 0 and `high` to `n - 1`.\n   - Use binary search to find the first occurrence of `x` by moving `low` up when `arr[mid] < x` and `high` down when `arr[mid] >= x`.\n   - If `low` is beyond the vector bounds or `arr[low]` is not `x`, return `false`.\n3. **Last Occurrence Search**:\n   - Reset `low` to 0 and `high` to `n - 1`.\n   - Use binary search to find the last occurrence of `x` by moving `low` up when `arr[mid] <= x` and `high` down when `arr[mid] > x`.\n4. **Majority Check**: Calculate the count of `x` as `last_occurrence - first_occurrence + 1`. The element `x` is a majority if `2 * count > n` (ensuring it occurs more than `n/2` times).\n\nThis approach efficiently checks for the majority element in sorted vectors using binary search, leveraging the contiguous nature of identical elements in a sorted array to minimize the number of comparisons. The time complexity is O(log n) for each binary search, making the overall complexity O(log n)."]}
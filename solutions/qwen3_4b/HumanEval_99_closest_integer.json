{"name": "HumanEval_99_closest_integer", "language": "rs", "prompt": "/// Create a function that takes a value (string) representing a number\n/// and returns the closest integer to it. If the number is equidistant\n/// from two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n/// Rounding away from zero means that if the given number is equidistant\n/// from two integers, the one you should return is the one that is the\n/// farthest from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"-14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_99_closest_integer.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"0\")), 0);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve this problem, we need to create a function that takes a string representing a number and returns the closest integer to it. If the number is equidistant from two integers, we round it **away from zero** (e.g., `14.5` becomes `15`, `-14.5` becomes `-15`).\n\n---\n\n### \ud83d\udd0d Key Insight\n\nThe problem requires rounding **away from zero** when the number is exactly halfway between two integers. This behavior is **exactly** what Rust's `f64::round()` function does by default. \n\n- For positive numbers: `0.5` rounds up to `1`.\n- For negative numbers: `-0.5` rounds down to `-1`.\n\nThis matches the requirement of rounding **away from zero** in the case of equidistant values.\n\n---\n\n### \u2705 Approach\n\n1. **Parse the input string** into a `f64` value.\n2. **Use `f64::round()`** to get the nearest integer (with halfway cases rounded away from zero).\n3. **Convert the result** to an `isize` for the final output.\n\nThis approach leverages Rust's built-in rounding behavior, which satisfies the problem's requirements without needing custom logic.\n\n---\n\n### \ud83e\udde0 Why This Works\n\n- The `f64::round()` function in Rust rounds to the nearest integer, **with halfway cases rounded away from zero**.\n- This aligns perfectly with the problem's specification:\n  - `14.5` \u2192 `15`\n  - `-14.5` \u2192 `-15`\n  - `15.3` \u2192 `15`\n  - `10` \u2192 `10`\n\n---\n\n### \ud83d\udce6 Final Implementation\n\n```rust\nfn closest_integer(value: String) -> isize {\n    let num = value.parse::<f64>().unwrap();\n    num.round() as isize\n}\n```\n\n---\n\n### \ud83e\uddea Example Tests\n\n| Input          | Output |\n|----------------|--------|\n| `\"10\"`         | `10`   |\n| `\"15.3\"`       | `15`   |\n| `\"14.5\"`       | `15`   |\n| `\"-14.5\"`      | `-15`  |\n\nAll examples match the expected behavior.\n\n---\n\n### \u2705 Conclusion\n\nBy leveraging Rust's built-in `f64::round()` function, we can efficiently and correctly implement the required rounding logic with minimal code. This solution is both concise and robust for the given problem constraints.\n\n```rust\nfn closest_integer(value: String) -> isize {\n    let num = value.parse::<f64>().unwrap();\n    num.round() as isize\n}\n```", "\n\nTo solve this problem, we need to create a function that takes a string representing a number and returns the closest integer to it. If the number is equidistant from two integers, we should round it away from zero. \n\n### Approach\n1. **Parse the Input String**: Convert the input string into a floating-point number (f64) to handle both integer and decimal values.\n2. **Determine Rounding Direction**:\n   - For non-negative numbers, add 0.5 and take the floor of the result. This effectively rounds half up (e.g., 14.5 becomes 15).\n   - For negative numbers, subtract 0.5 and take the ceiling of the result. This ensures rounding away from zero (e.g., -14.5 becomes -15).\n3. **Convert to Integer**: Convert the rounded floating-point result back to an `isize` for the final output.\n\nThis approach efficiently handles all edge cases, including numbers exactly halfway between two integers, by leveraging standard floating-point operations and conditional checks.\n\n### Solution Code\n```rust\nfn closest_integer(value: String) -> isize {\n    let num: f64 = value.parse().expect(\"Invalid number\");\n    let rounded = if num >= 0.0 {\n        (num + 0.5).floor()\n    } else {\n        (num - 0.5).ceil()\n    };\n    rounded as isize\n}\n```\n\n### Explanation\n1. **Parsing the Input**: The input string is parsed into an `f64` value. This allows us to handle both integer and decimal inputs uniformly.\n2. **Rounding Logic**:\n   - **Non-negative Numbers**: By adding 0.5 and taking the floor, we ensure that numbers like 14.5 are rounded up to 15.\n   - **Negative Numbers**: By subtracting 0.5 and taking the ceiling, we ensure numbers like -14.5 are rounded down to -15 (away from zero).\n3. **Conversion to Integer**: The rounded floating-point result is converted to an `isize` to meet the function's return type requirement.\n\nThis solution efficiently handles all specified cases, including equidistant numbers, by leveraging straightforward arithmetic operations and conditional checks, ensuring correctness across both positive and negative values.", "\n\nTo solve this problem, we need to create a function that takes a string representing a number and returns the closest integer to it. If the number is equidistant from two integers (i.e., it has a fractional part of exactly 0.5), we round it **away from zero**. \n\n### Approach\n1. **Parse the Input String**: Convert the input string into a `f64` value to handle floating-point arithmetic.\n2. **Calculate Fractional Part**: Compute the fractional part of the number by subtracting the floor value from the number itself.\n3. **Check for Equidistant Case**: If the fractional part is exactly 0.5:\n   - For positive numbers, round up (add 1 to the floor value).\n   - For negative numbers, round down (use the floor value directly).\n4. **Standard Rounding for Other Cases**: For numbers not equidistant from two integers, use standard rounding (`round()`) to get the nearest integer.\n\nThis approach ensures that numbers equidistant from two integers are rounded away from zero, as specified in the problem statement.\n\n### Solution Code\n```rust\nfn closest_integer(value: String) -> isize {\n    let x: f64 = value.parse().expect(\"Invalid number\");\n    let fractional = x - x.floor();\n    if fractional == 0.5 {\n        if x >= 0.0 {\n            (x.floor() as isize) + 1\n        } else {\n            x.floor() as isize\n        }\n    } else {\n        x.round() as isize\n    }\n}\n```\n\n### Explanation\n1. **Parsing the Input**: The input string is parsed into a `f64` value. This allows us to perform precise floating-point operations.\n2. **Fractional Part Calculation**: The fractional part is calculated as `x - x.floor()`, which gives the decimal portion of the number (e.g., `14.5 - 14.0 = 0.5`).\n3. **Handling Equidistant Cases**:\n   - If the fractional part is exactly `0.5`, we check if the number is positive or negative.\n     - For positive numbers (e.g., `14.5`), we round up to `15` by adding `1` to the floor value.\n     - For negative numbers (e.g., `-14.5`), we round down to `-15` by using the floor value directly.\n4. **Standard Rounding**: For numbers where the fractional part is not `0.5`, we use the standard `round()` method to get the nearest integer. This method handles all other cases correctly (e.g., `15.3` rounds to `15`).\n\nThis solution efficiently handles all edge cases, including numbers equidistant from two integers, by leveraging precise floating-point arithmetic and conditional checks to ensure the rounding behavior meets the problem's requirements."]}
{"name": "mbpp_751_check_min_heap", "language": "rs", "prompt": "/// Write a function to check if the given vector represents min heap or not. https://www.geeksforgeeks.org/how-to-check-if-a-given-vector-represents-a-binary-heap/\nfn check_min_heap(arr: Vec<isize>) -> bool {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_751_check_min_heap.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = check_min_heap;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![2, 3, 4, 5, 10, 15]), true);\n    assert_eq!(candidate(vec![2, 10, 4, 5, 3, 15]), false);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo determine if a given vector represents a min-heap, we need to verify that for every node in the heap, the node's value is less than or equal to the values of its children (if they exist). The vector is stored in a complete binary tree structure where the root is at index 0, the left child of node `i` is at `2*i + 1`, and the right child is at `2*i + 2`.\n\n### Approach\n1. **Problem Analysis**: The key observation is that in a min-heap, every parent node must be less than or equal to its children. The last non-leaf node in a complete binary tree (represented as a vector) is at index `n/2 - 1` (0-based index). Therefore, we only need to check all non-leaf nodes from index `0` to `n/2 - 1`.\n2. **Algorithm Selection**: Iterate over each non-leaf node. For each node `i`:\n   - Check its left child (at index `2*i + 1`). If it exists and the node's value is greater than the left child's value, return `false`.\n   - Check its right child (at index `2*i + 2`). If it exists and the node's value is greater than the right child's value, return `false`.\n3. **Edge Cases**: \n   - An empty vector (or a single-element vector) trivially satisfies the min-heap property.\n   - The loop runs from `0` to `n/2 - 1` (inclusive), ensuring all non-leaf nodes are checked without index out-of-bounds errors.\n\n### Solution Code\n```rust\nfn check_min_heap(arr: Vec<isize>) -> bool {\n    let n = arr.len();\n    for i in 0..n/2 {\n        let left = 2 * i + 1;\n        if left < n && arr[i] > arr[left] {\n            return false;\n        }\n        let right = 2 * i + 2;\n        if right < n && arr[i] > arr[right] {\n            return false;\n        }\n    }\n    true\n}\n```\n\n### Explanation\n1. **Initialization**: The length of the vector `n` is determined.\n2. **Loop Through Non-Leaf Nodes**: The loop runs from index `0` to `n/2 - 1` (inclusive). This ensures all non-leaf nodes are checked.\n3. **Check Left Child**: For each node `i`, compute the index of its left child (`2*i + 1`). If the left child exists (index < `n`) and the node's value is greater than the left child's value, return `false`.\n4. **Check Right Child**: Similarly, compute the index of the right child (`2*i + 2`). If the right child exists and the node's value is greater than the right child's value, return `false`.\n5. **Return True**: If all non-leaf nodes satisfy the min-heap property, return `true`.\n\nThis approach efficiently checks the min-heap property by focusing only on non-leaf nodes and ensuring bounds are respected to avoid index errors, making it optimal with a time complexity of O(n).", "\n\nTo determine if a given vector represents a min heap, we need to verify that for every node in the heap, the value of the node is less than or equal to the values of its children (if they exist). The vector is stored in level-order (root at index 0, then level 1, etc.).\n\n### Approach\n1. **Problem Analysis**: A min heap must satisfy the min-heap property where each parent node is less than or equal to its children. The heap is represented as a vector where the root is at index 0, left child of node `i` is at `2*i + 1`, and right child is at `2*i + 2`.\n2. **Key Insight**: We only need to check non-leaf nodes (from index 0 to `(n/2) - 1` where `n` is the length of the vector). For each non-leaf node `i`, we compare it with its left and right children (if they exist).\n3. **Algorithm**:\n   - If the vector is empty, it trivially represents a min heap (return `true`).\n   - Iterate over each non-leaf node (indices `0` to `n/2 - 1`).\n   - For each node `i`, check if it is greater than its left child (if the left child exists) or right child (if the right child exists). If any violation is found, return `false`.\n   - If all checks pass, return `true`.\n\n### Solution Code\n```rust\nfn check_min_heap(arr: Vec<isize>) -> bool {\n    let n = arr.len();\n    if n == 0 {\n        return true;\n    }\n\n    for i in 0..(n / 2) {\n        let left = 2 * i + 1;\n        let right = 2 * i + 2;\n\n        if left < n && arr[i] > arr[left] {\n            return false;\n        }\n\n        if right < n && arr[i] > arr[right] {\n            return false;\n        }\n    }\n\n    true\n}\n```\n\n### Explanation\n1. **Initial Check**: If the vector is empty (`n == 0`), it is considered a valid min heap (return `true`).\n2. **Non-Leaf Nodes Check**: The loop runs from index `0` to `(n/2) - 1` (inclusive), covering all non-leaf nodes in the heap.\n3. **Child Checks**:\n   - **Left Child**: For each node `i`, the left child is at index `2*i + 1`. If this index is within bounds and the node value is greater than the left child's value, return `false`.\n   - **Right Child**: Similarly, the right child is at index `2*i + 2`. If this index is within bounds and the node value is greater than the right child's value, return `false`.\n4. **Result**: If all non-leaf nodes satisfy the min-heap property, the function returns `true`, confirming the vector represents a min heap.\n\nThis approach efficiently checks the min-heap property by focusing only on necessary nodes (non-leaf nodes) and ensures optimal performance with a time complexity of O(n), where `n` is the number of elements in the vector.", "\n\nTo determine if a given vector represents a min heap, we need to verify that for every node in the heap, the value of the node is less than or equal to the values of its children (if they exist). The vector is assumed to be stored in a standard array representation of a binary heap (where the root is at index 0, the left child of index `i` is at `2*i + 1`, and the right child is at `2*i + 2`).\n\n### Approach\n1. **Problem Analysis**: The problem requires checking the min heap property for all nodes in the vector. The min heap property states that for any node at index `i`, the value at `i` must be less than or equal to the values at its left and right children (if they exist).\n2. **Intuition**: Iterate through each node in the vector starting from the root (index 0). For each node, check its left and right children (if they exist) to ensure the node's value is not greater than either child's value.\n3. **Algorithm Selection**: \n   - Calculate the indices of the left and right children for the current node.\n   - If the left child exists and the current node's value is greater than the left child's value, return `false`.\n   - Similarly, if the right child exists and the current node's value is greater than the right child's value, return `false`.\n   - If all nodes satisfy the min heap property, return `true`.\n4. **Complexity Analysis**: The algorithm checks each node exactly once, and for each node, it performs constant-time checks for its children. Thus, the time complexity is O(n), where `n` is the number of elements in the vector. The space complexity is O(1) as no additional space is used beyond the input vector.\n\n### Solution Code\n```rust\nfn check_min_heap(arr: Vec<isize>) -> bool {\n    let n = arr.len();\n    for i in 0..n {\n        let left = 2 * i + 1;\n        let right = 2 * i + 2;\n\n        if left < n && arr[i] > arr[left] {\n            return false;\n        }\n        if right < n && arr[i] > arr[right] {\n            return false;\n        }\n    }\n    true\n}\n```\n\n### Explanation\n- **Initialization**: The function starts by determining the length `n` of the input vector.\n- **Iteration**: For each index `i` from `0` to `n-1`:\n  - **Left Child Calculation**: The left child of node `i` is at index `2*i + 1`.\n  - **Right Child Calculation**: The right child of node `i` is at index `2*i + 2`.\n- **Validation Checks**:\n  - If the left child exists (i.e., `left < n`) and the current node's value (`arr[i]`) is greater than the left child's value (`arr[left]`), the function immediately returns `false`.\n  - Similarly, if the right child exists and the current node's value is greater than the right child's value, the function returns `false`.\n- **Result**: If all nodes pass the checks, the function returns `true`, indicating the vector represents a min heap.\n\nThis approach efficiently verifies the min heap property by checking each node's children in a single pass through the vector, ensuring optimal performance."]}
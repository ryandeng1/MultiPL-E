{"name": "HumanEval_126_is_sorted", "language": "rs", "prompt": "/// Given a vector of numbers, return whether or not they are sorted\n/// in ascending order. If vector has more than 1 duplicate of the same\n/// number, return false. Assume no negative numbers and only integers.\n/// Examples\n/// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n/// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n/// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\nfn is_sorted(lst: Vec<isize>) -> bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_126_is_sorted.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo determine whether a vector of integers is sorted in ascending order with the constraint that no number appears more than twice, we can follow a two-step approach:\n\n1. **Check if the vector is sorted in non-decreasing order** (i.e., each element is less than or equal to the next).\n2. **Ensure no number appears more than twice** by checking consecutive duplicates in the sorted vector.\n\nThis solution efficiently handles both conditions without requiring additional data structures like hash maps, leveraging the fact that duplicates in a sorted vector must appear consecutively.\n\n### Final Solution\n\n```rust\nfn is_sorted(lst: Vec<isize>) -> bool {\n    // Check if the vector is sorted\n    for i in 1..lst.len() {\n        if lst[i] < lst[i-1] {\n            return false;\n        }\n    }\n\n    // Check for duplicate runs (consecutive duplicates)\n    if lst.len() <= 2 {\n        return true;\n    }\n\n    let mut current = lst[0];\n    let mut count = 1;\n\n    for i in 1..lst.len() {\n        if lst[i] == current {\n            count += 1;\n        } else {\n            if count > 2 {\n                return false;\n            }\n            current = lst[i];\n            count = 1;\n        }\n    }\n\n    // Check the last run of duplicates\n    if count > 2 {\n        return false;\n    }\n\n    true\n}\n```\n\n### Explanation\n\n1. **Sorted Check**: The first loop ensures that the vector is in non-decreasing order. If any element is smaller than the previous one, the function immediately returns `false`.\n2. **Duplicate Run Check**: \n   - For vectors of length \u2264 2, the function returns `true` since they cannot have more than two duplicates.\n   - For longer vectors, we traverse the sorted list to count consecutive duplicates. \n   - If any run of duplicates exceeds two elements, the function returns `false`.\n   - After processing all elements, we check the final run of duplicates to ensure it doesn't exceed two.\n\nThis approach efficiently combines both conditions in a single pass through the vector after confirming it is sorted, ensuring optimal performance and correctness for all specified cases.\n\n### Examples\n\n- `is_sorted(vec![5])` \u2192 `true`\n- `is_sorted(vec![1, 2, 3, 4, 5])` \u2192 `true`\n- `is_sorted(vec![1, 3, 2, 4, 5])` \u2192 `false`\n- `is_sorted(vec![1, 2, 2, 3, 3, 4])` \u2192 `true`\n- `is_sorted(vec![1, 2, 2, 2, 3, 4])` \u2192 `false`\n\nThis solution meets all the problem requirements and handles edge cases correctly.", "\n\nTo solve this problem, we need to determine if a given vector of integers is sorted in ascending order (non-decreasing) and does not contain any number that appears more than twice (i.e., no number has more than one duplicate). \n\n### Approach\n1. **Check for Empty Vector**: If the vector is empty, it is trivially sorted, so return `true`.\n2. **Traverse the Vector**: Iterate through the vector starting from the second element.\n3. **Check Non-decreasing Order**: For each element, ensure it is not less than the previous element. If it is, return `false` immediately.\n4. **Track Consecutive Duplicates**: For each element, if it matches the previous element, increment a counter. If it does not match, check if the counter for the previous number exceeds 2 (indicating more than one duplicate). If so, return `false`. Reset the counter to 1 for the new number.\n5. **Final Check**: After the loop, check if the counter for the last number exceeds 2. If it does, return `false`; otherwise, return `true`.\n\nThis approach efficiently checks both the sorted order and the duplicate constraints in a single pass through the vector, ensuring optimal performance with O(n) time complexity and O(1) space complexity.\n\n### Solution Code\n```rust\nfn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.is_empty() {\n        return true;\n    }\n\n    let mut count = 1;\n    for i in 1..lst.len() {\n        if lst[i] < lst[i-1] {\n            return false;\n        }\n        if lst[i] == lst[i-1] {\n            count += 1;\n        } else {\n            if count > 2 {\n                return false;\n            }\n            count = 1;\n        }\n    }\n    if count > 2 {\n        return false;\n    }\n    true\n}\n```\n\n### Explanation\n1. **Empty Vector Check**: The function first checks if the vector is empty. If so, it returns `true` since an empty vector is considered sorted.\n2. **Initialization**: The counter `count` is initialized to 1 to start tracking the occurrences of the first element.\n3. **Loop Through Vector**: Starting from the second element (index 1), the function checks:\n   - **Non-decreasing Order**: If the current element is less than the previous element, the function returns `false` immediately as the vector is not sorted.\n   - **Consecutive Duplicates**: If the current element matches the previous element, the counter is incremented. If the current element is different, the function checks if the counter for the previous number exceeds 2 (indicating more than one duplicate). If it does, the function returns `false`; otherwise, the counter is reset to 1 for the new number.\n4. **Final Check**: After processing all elements, the function checks if the counter for the last number exceeds 2. If it does, the function returns `false`; otherwise, it returns `true`.\n\nThis approach efficiently ensures the vector is sorted in non-decreasing order and adheres to the constraint that no number appears more than twice (i.e., no number has more than one duplicate), providing an optimal solution with minimal computational overhead.", "\n\nTo solve this problem, we need to determine if a given vector of integers is sorted in ascending order without having more than one duplicate of any number. The solution involves two main checks: \n1. The vector must be non-decreasing (each element should be less than or equal to the next element).\n2. No number should appear more than twice consecutively (since duplicates in a non-decreasing sequence must be consecutive, three consecutive duplicates indicate more than one duplicate of the same number).\n\n### Approach\n1. **Check for Small Vectors**: If the vector has 0, 1, or 2 elements, it is trivially sorted and meets the conditions (since duplicates would require at least three elements to be more than one).\n2. **Check Non-decreasing Order**: Iterate through the vector to ensure each element is less than or equal to the next element. If any element is greater than the next, the vector is not sorted.\n3. **Check for Three Consecutive Duplicates**: During the same iteration, check if there are three consecutive elements that are the same. If found, return false because this indicates more than one duplicate of the same number.\n\n### Solution Code\n```rust\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let n = lst.len();\n    if n <= 2 {\n        return true;\n    }\n\n    for i in 0..n-1 {\n        if lst[i] > lst[i+1] {\n            return false;\n        }\n        if i < n-2 && lst[i] == lst[i+1] && lst[i] == lst[i+2] {\n            return false;\n        }\n    }\n    true\n}\n```\n\n### Explanation\n1. **Initial Check for Small Vectors**: The function first checks if the vector length is 0, 1, or 2. For these cases, it immediately returns `true` because they inherently meet the sorting and duplicate conditions.\n2. **Non-decreasing Check**: The loop iterates through each element from the start to the second last element. For each element, it checks if it is greater than the next element. If so, the function returns `false` since the vector is not sorted in ascending order.\n3. **Three Consecutive Duplicates Check**: During the same iteration, the function checks if the current element and the next two elements are identical. If three consecutive elements are the same, it returns `false` because this indicates more than one duplicate of the same number (specifically, two duplicates for that number).\n4. **Final Return**: If all checks pass without finding any violations, the function returns `true`, confirming the vector is sorted in ascending order with no more than one duplicate of any number.\n\nThis approach efficiently combines the checks for sorting order and duplicate constraints in a single pass through the vector, ensuring optimal performance with O(n) time complexity, where n is the length of the vector. The space complexity is O(1) as no additional space is used beyond the input vector."]}
{"name": "mbpp_102_snake_to_camel", "language": "rs", "prompt": "/// Write a function to convert a snake case string to camel case string.\nfn snake_to_camel(word: String) -> String {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_102_snake_to_camel.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = snake_to_camel;\n    assert_eq!(candidate(String::from(\"python_program\")), String::from(\"PythonProgram\"));\n    assert_eq!(candidate(String::from(\"python_language\")), String::from(\"PythonLanguage\"));\n    assert_eq!(candidate(String::from(\"programming_language\")), String::from(\"ProgrammingLanguage\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo convert a snake case string to camel case, we split the string by underscores, skip any empty parts (to handle consecutive underscores), and then process each part. The first part is added to the result as-is. For subsequent parts, the first character is converted to uppercase and appended to the result, followed by the rest of the part.\n\nHere's the implementation:\n\n```rust\nfn snake_to_camel(word: String) -> String {\n    let mut result = String::new();\n    for (i, part) in word.split('_').enumerate() {\n        if part.is_empty() {\n            continue;\n        }\n        if i == 0 {\n            result.push_str(part);\n        } else {\n            result.push(part[0].to_ascii_uppercase());\n            result.push_str(&part[1..]);\n        }\n    }\n    result\n}\n```\n\n**Explanation:**\n1. **Splitting the string**: The `word.split('_')` method splits the input string into parts using underscores as delimiters.\n2. **Skipping empty parts**: If a part is empty (due to consecutive underscores), it is skipped to maintain correct behavior.\n3. **Processing parts**:\n   - For the first part (`i == 0`), the part is added to the result directly.\n   - For subsequent parts (`i > 0`), the first character is converted to uppercase (using `to_ascii_uppercase` for ASCII compatibility) and appended to the result, followed by the rest of the part (from index 1 onwards).\n\nThis approach efficiently handles standard snake case strings and ensures the output is in camel case format, with the first word in lowercase and subsequent words starting with an uppercase letter.\n\n**Example Usage:**\n- Input: `\"hello_world\"` \u2192 Output: `\"helloWorld\"`\n- Input: `\"a_b_c\"` \u2192 Output: `\"aBC\"`\n- Input: `\"a__b\"` \u2192 Output: `\"aB\"` (handles consecutive underscores)", "\n\nTo convert a snake case string to camel case, we split the string by underscores, filter out any empty parts (to handle consecutive underscores), and then process each part. The first part is added to the result as-is (since snake case uses lowercase). For each subsequent part, the first character is converted to uppercase and the rest of the characters are converted to lowercase (to ensure standard camel case formatting). \n\nHere's the implementation:\n\n```rust\nfn snake_to_camel(word: String) -> String {\n    let parts: Vec<&str> = word.split('_').filter(|s| !s.is_empty()).collect();\n    if parts.is_empty() {\n        return word;\n    }\n    let mut result = parts[0].to_string();\n    for part in &parts[1..] {\n        result.push(part.chars().next().unwrap().to_ascii_uppercase());\n        result.push_str(part[1..].to_lowercase().as_str());\n    }\n    result\n}\n```\n\n**Explanation:**\n1. **Split and Filter:** The input string is split by underscores, and empty strings (from consecutive underscores) are filtered out.\n2. **Empty Check:** If the resulting parts list is empty (e.g., input was empty), return the original string.\n3. **First Part:** The first part of the split is added to the result as-is.\n4. **Subsequent Parts:** For each subsequent part:\n   - The first character is converted to uppercase using `to_ascii_uppercase`.\n   - The rest of the characters (if any) are converted to lowercase using `to_lowercase` and appended to the result.\n5. **Result Construction:** The processed parts are concatenated into a single string, which is the camel case version.\n\nThis approach ensures the output follows standard camel case conventions, handling typical snake case inputs correctly while being robust against edge cases like consecutive underscores or empty strings. The solution assumes the input is in standard snake case (all lowercase with underscores), but the lowercase conversion for the rest of the parts ensures correctness even if there are non-lowercase characters (though snake case typically avoids this).", "\n\nTo convert a snake case string to camel case, we split the input string by underscores, filter out any empty strings (to handle cases with consecutive underscores), and then construct the result string. The first word is added as-is (in lowercase), and each subsequent word starts with an uppercase letter followed by the rest of the word in lowercase.\n\nHere's the implementation:\n\n```rust\nfn snake_to_camel(word: String) -> String {\n    let words: Vec<&str> = word.split('_')\n        .filter(|s| !s.is_empty())\n        .collect();\n    let mut result = String::new();\n    for (i, w) in words.iter().enumerate() {\n        if i == 0 {\n            result.push_str(w);\n        } else {\n            let first_char = w.chars().next().unwrap();\n            result.push(first_char.to_ascii_uppercase());\n            result.push_str(&w[1..]);\n        }\n    }\n    result\n}\n```\n\n**Explanation:**\n1. **Split and Filter:** The input string is split into parts using `split('_')`, and empty strings are filtered out to handle any invalid snake case (e.g., consecutive underscores).\n2. **Construct Result:** \n   - For the first word, it is added to the result as-is.\n   - For each subsequent word, the first character is converted to uppercase (using `to_ascii_uppercase` for ASCII compatibility), and the rest of the word is appended.\n3. **Edge Handling:** The solution safely handles empty input (returns empty string) and ensures no empty words are processed.\n\n**Example Usage:**\n- `\"hello_world\"` \u2192 `\"helloWorld\"`\n- `\"a_b_c\"` \u2192 `\"aBC\"`\n- `\"user_id\"` \u2192 `\"userId\"`\n\nThis function adheres to standard camel case conventions for snake case conversion, ensuring clarity and correctness for typical use cases."]}
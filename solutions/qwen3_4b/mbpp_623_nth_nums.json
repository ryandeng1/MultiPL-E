{"name": "mbpp_623_nth_nums", "language": "rs", "prompt": "/// Write a function to compute the n-th power of each number in a vector.\nfn nth_nums(nums: Vec<isize>, n: isize) -> Vec<isize> {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_623_nth_nums.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = nth_nums;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2), vec![1, 4, 9, 16, 25, 36, 49, 64, 81, 100]);\n    assert_eq!(candidate(vec![10, 20, 30], 3), vec![1000, 8000, 27000]);\n    assert_eq!(candidate(vec![12, 15], 5), vec![248832, 759375]);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve this problem, we need to compute the n-th power of each number in a given vector of integers. The solution involves iterating over each number in the vector and raising it to the power of `n`, where `n` is a non-negative integer. The result should be a new vector containing these computed values.\n\n### Approach\n1. **Problem Analysis**: The task requires raising each element in the input vector to the power `n`. The key insight here is that for non-negative `n`, we can compute the power using a loop that multiplies the number `n` times. Special handling for `n = 0` is not needed because multiplying by the number 0 times results in 1, which is the conventional value for any number raised to the power 0 (including 0^0, which is treated as 1 in this context).\n2. **Algorithm Selection**: We use a simple loop for each number in the vector to compute the power. For each number, we initialize a result variable to 1 and then multiply it by the number `n` times. This approach efficiently handles all non-negative values of `n`.\n3. **Complexity Analysis**: The time complexity is O(N * n), where N is the number of elements in the vector and `n` is the exponent. This is because for each element, we perform `n` multiplications. The space complexity is O(N) to store the resulting vector.\n\n### Solution Code\n```rust\nfn nth_nums(nums: Vec<isize>, n: isize) -> Vec<isize> {\n    nums.into_iter()\n        .map(|num| {\n            let mut power = 1;\n            for _ in 0..n {\n                power *= num;\n            }\n            power\n        })\n        .collect()\n}\n```\n\n### Explanation\n1. **Input Handling**: The function takes a vector of `isize` values (`nums`) and an `isize` exponent (`n`).\n2. **Iteration and Power Calculation**: For each number in the input vector:\n   - Initialize a variable `power` to 1.\n   - Multiply `power` by the current number `n` times (using a loop from 0 to `n-1`).\n3. **Result Collection**: The computed power for each number is collected into a new vector, which is returned as the result.\n4. **Edge Cases**: \n   - If `n` is 0, the loop runs 0 times, so `power` remains 1 for all numbers (handling 0^0 as 1).\n   - The solution assumes `n` is non-negative; negative exponents are not handled (as per problem constraints).\n\nThis approach efficiently computes the n-th power for each element in the vector using a straightforward loop, ensuring clarity and correctness for the given problem constraints.", "\n\nTo solve this problem, we need to compute the n-th power of each number in a given vector of integers. The solution must handle different cases for the exponent `n`, including negative exponents, zero, and positive exponents.\n\n### Approach\n1. **Handle Negative Exponents**: If `n` is negative, the result for each element in the vector is 0. This is a fallback since negative exponents would typically result in fractional values, which cannot be represented as integers.\n2. **Handle Zero Exponent**: If `n` is 0, every element in the resulting vector is 1 (as any non-zero number raised to the power of 0 is 1, and 0^0 is conventionally treated as 1 in this context).\n3. **Handle Positive Exponents**: For positive exponents, iterate over each element in the input vector and compute its n-th power using a loop. The loop multiplies the element by itself `n` times to get the result.\n\n### Solution Code\n```rust\nfn nth_nums(nums: Vec<isize>, n: isize) -> Vec<isize> {\n    if n < 0 {\n        vec![0; nums.len()]\n    } else if n == 0 {\n        vec![1; nums.len()]\n    } else {\n        let mut result = Vec::new();\n        for x in nums {\n            let mut res = 1;\n            for _ in 0..n {\n                res *= x;\n            }\n            result.push(res);\n        }\n        result\n    }\n}\n```\n\n### Explanation\n1. **Negative Exponent Handling**: The function first checks if `n` is negative. If so, it returns a vector of zeros of the same length as the input vector. This is because negative exponents would lead to non-integer results (e.g., 2^(-1) = 0.5), which cannot be represented as integers.\n2. **Zero Exponent Handling**: If `n` is zero, the function returns a vector filled with ones. This handles the case where any number (including zero) raised to the power of zero is defined as 1 in this context.\n3. **Positive Exponent Handling**: For positive values of `n`, the function initializes an empty vector to store results. It then iterates over each element in the input vector. For each element, it computes the n-th power by multiplying the element by itself `n` times. The result for each element is added to the result vector.\n\nThis approach efficiently handles all specified cases for the exponent `n` and ensures the output is a vector of integers as required. The solution is straightforward and leverages basic loops for positive exponents, which is suitable for small values of `n` as implied by the problem context.", "\n\nTo compute the n-th power of each number in a vector, we can leverage Rust's standard library methods for efficient and clean iteration. The solution involves:\n\n1. Converting the input vector into an iterator using `into_iter()`, which allows us to work with the values directly.\n2. Applying the `powi` method (which computes integer powers) to each element.\n3. Collecting the results into a new vector.\n\nHere's the implementation:\n\n```rust\nfn nth_nums(nums: Vec<isize>, n: isize) -> Vec<isize> {\n    nums.into_iter().map(|x| x.powi(n)).collect()\n}\n```\n\n**Explanation:**\n- `nums.into_iter()`: Converts the vector into an iterator that consumes the vector and yields each element as a value (not a reference).\n- `.map(|x| x.powi(n))`: For each value `x` in the iterator, compute `x.powi(n)`, which raises `x` to the power `n` using integer arithmetic.\n- `.collect()`: Collects the results into a new `Vec<isize>`.\n\nThis approach is efficient and idiomatic in Rust, ensuring correct handling of integer powers for non-negative exponents as specified by the problem context.\n\n**Example Usage:**\n```rust\nlet result = nth_nums(vec![2, 3], 2);\n// result = vec![4, 9]\n```"]}
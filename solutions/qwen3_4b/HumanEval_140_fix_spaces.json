{"name": "HumanEval_140_fix_spaces", "language": "rs", "prompt": "/// Given a string text, replace all spaces in it with underscores, \n/// and if a string has more than 2 consecutive spaces, \n/// then replace all consecutive spaces with - \n/// >>> fix_spaces(String::from(\" Example\"))\n/// String::from(\"Example\")\n/// >>> fix_spaces(String::from(\" Example 1\"))\n/// String::from(\"Example_1\")\n/// >>> fix_spaces(String::from(\" Example 2\"))\n/// String::from(\"_Example_2\")\n/// >>> fix_spaces(String::from(\" Example 3\"))\n/// String::from(\"_Example-3\")\nfn fix_spaces(text: String) -> String {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_140_fix_spaces.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = fix_spaces;\n    assert_eq!(candidate(String::from(\"Example\")), String::from(\"Example\"));\n    assert_eq!(candidate(String::from(\"Mudasir Hanif \")), String::from(\"Mudasir_Hanif_\"));\n    assert_eq!(candidate(String::from(\"Yellow Yellow  Dirty  Fellow\")), String::from(\"Yellow_Yellow__Dirty__Fellow\"));\n    assert_eq!(candidate(String::from(\"Exa   mple\")), String::from(\"Exa-mple\"));\n    assert_eq!(candidate(String::from(\"   Exa 1 2 2 mple\")), String::from(\"-Exa_1_2_2_mple\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve this problem, we need to process a string by replacing all spaces with underscores, but with a special condition: any run of three or more consecutive spaces should be replaced with a single hyphen (`-`). \n\n### Approach\n1. **Iterate through each character** in the input string.\n2. **Track consecutive spaces**: For each space encountered, increment a counter (`current_run`).\n3. **Process runs of spaces**:\n   - If the run length (`current_run`) is **3 or more**, replace it with a hyphen (`-`).\n   - If the run length is **1 or 2**, replace it with the corresponding number of underscores (`_`).\n4. **Append non-space characters** directly to the result string.\n5. **Handle trailing spaces** after processing all characters.\n\nThis approach efficiently processes the string in a single pass, ensuring optimal performance with O(n) time complexity, where n is the length of the input string.\n\n### Solution Code\n```rust\nfn fix_spaces(text: String) -> String {\n    let mut result = String::new();\n    let mut current_run = 0;\n    for c in text.chars() {\n        if c == ' ' {\n            current_run += 1;\n        } else {\n            if current_run > 0 {\n                if current_run >= 3 {\n                    result.push('-');\n                } else {\n                    for _ in 0..current_run {\n                        result.push('_');\n                    }\n                }\n                current_run = 0;\n            }\n            result.push(c);\n        }\n    }\n    if current_run > 0 {\n        if current_run >= 3 {\n            result.push('-');\n        } else {\n            for _ in 0..current_run {\n                result.push('_');\n            }\n        }\n    }\n    result\n}\n```\n\n### Explanation\n1. **Initialization**: We start with an empty result string and a counter `current_run` initialized to 0 to track consecutive spaces.\n2. **Character Processing**:\n   - For each character in the input string:\n     - If it's a space, increment `current_run`.\n     - If it's not a space, process the current run of spaces (if any) by replacing it with underscores (for runs of 1 or 2) or a hyphen (for runs of 3 or more), then append the non-space character to the result.\n3. **Trailing Spaces**: After processing all characters, any remaining spaces (if the string ends with spaces) are processed similarly.\n4. **Result Construction**: The result string is built incrementally by appending processed space runs and non-space characters in sequence.\n\nThis method ensures that all spaces are correctly replaced according to the specified rules, handling runs of spaces efficiently and concisely. The solution meets the problem's requirements and handles edge cases such as leading, trailing, and multiple consecutive spaces correctly.", "\n\nTo solve this problem, we need to process a given string by replacing all spaces with underscores, but with a specific exception: any run of three or more consecutive spaces should be replaced with a single dash. \n\n### Approach\n1. **Problem Analysis**: The task involves traversing the input string character by character. For each space encountered, we count consecutive spaces. When a non-space character is encountered, we process the accumulated count of spaces:\n   - If the count is 1, we append a single underscore.\n   - If the count is 2, we append two underscores.\n   - If the count is 3 or more, we append a single dash.\n2. **Edge Cases**: After processing all characters, any trailing spaces (if any) are handled similarly to the middle spaces.\n3. **Algorithm Selection**: We use a linear scan of the string with a counter for consecutive spaces. This approach efficiently processes the string in O(n) time, where n is the length of the string, and uses O(n) space for the result.\n\n### Solution Code\n```rust\nfn fix_spaces(text: String) -> String {\n    let mut result = String::new();\n    let mut count = 0;\n    for c in text.chars() {\n        if c == ' ' {\n            count += 1;\n        } else {\n            match count {\n                1 => result.push('_'),\n                2 => {\n                    result.push('_');\n                    result.push('_');\n                }\n                _ => result.push('-'),\n            }\n            count = 0;\n            result.push(c);\n        }\n    }\n    if count > 0 {\n        match count {\n            1 => result.push('_'),\n            2 => {\n                result.push('_');\n                result.push('_');\n            }\n            _ => result.push('-'),\n        }\n    }\n    result\n}\n```\n\n### Explanation\n1. **Initialization**: We start with an empty result string and a counter initialized to zero to track consecutive spaces.\n2. **Character Processing**: For each character in the input string:\n   - If the character is a space, we increment the counter.\n   - If the character is not a space, we process the counter:\n     - A count of 1 results in a single underscore.\n     - A count of 2 results in two underscores.\n     - A count of 3 or more results in a single dash.\n   - After processing the spaces, we append the non-space character to the result and reset the counter.\n3. **Trailing Spaces Handling**: After processing all characters, any remaining spaces (if the counter is non-zero) are processed similarly to ensure they are correctly converted to underscores or a dash.\n4. **Result Construction**: The result string is built incrementally during the traversal, ensuring optimal performance with minimal overhead.\n\nThis approach efficiently handles the requirements by processing the string in a single pass, making it both time and space optimal for the given problem constraints. The solution correctly replaces spaces according to the specified rules, ensuring runs of three or more spaces are converted to a single dash while all other spaces become underscores.", "\n\nTo solve this problem, we need to replace all spaces in a given string with underscores, but with a special condition: if there are more than two consecutive spaces, we replace all of them with a hyphen (`-`). \n\n### Approach\n1. **Iterate through each character** in the input string.\n2. **Track consecutive spaces**: For each space encountered, increment a counter (`current_run`).\n3. **Process non-space characters**: When a non-space character is encountered:\n   - If there was a run of spaces (`current_run > 0`), replace it with:\n     - Hyphen (`-`) if `current_run >= 3`\n     - Underscores (`_` repeated `current_run` times) otherwise\n   - Append the non-space character to the result.\n   - Reset `current_run` to 0.\n4. **Handle trailing spaces**: After processing all characters, check if there are any remaining spaces (`current_run > 0`) and process them similarly.\n\nThis approach ensures that all sequences of spaces are replaced according to the specified rules, maintaining the integrity of the original string's structure.\n\n### Solution Code\n```rust\nfn fix_spaces(text: String) -> String {\n    let mut result = String::new();\n    let mut current_run = 0;\n\n    for c in text.chars() {\n        if c == ' ' {\n            current_run += 1;\n        } else {\n            if current_run > 0 {\n                if current_run >= 3 {\n                    result.push('-');\n                } else {\n                    for _ in 0..current_run {\n                        result.push('_');\n                    }\n                }\n            }\n            result.push(c);\n            current_run = 0;\n        }\n    }\n\n    if current_run > 0 {\n        if current_run >= 3 {\n            result.push('-');\n        } else {\n            for _ in 0..current_run {\n                result.push('_');\n            }\n        }\n    }\n\n    result\n}\n```\n\n### Explanation\n- **Initialization**: We start with an empty `result` string and a counter `current_run` set to 0 to track consecutive spaces.\n- **Character Processing**:\n  - For each space encountered, we increment `current_run`.\n  - When a non-space character is found, we process the current run of spaces (if any):\n    - If the run length is 3 or more, we append a hyphen (`-`) to `result`.\n    - Otherwise, we append underscores (`_`) repeated `current_run` times.\n  - We then append the non-space character to `result` and reset `current_run` to 0.\n- **Trailing Spaces Handling**: After processing all characters, any remaining spaces (if any) are processed in the same way as during the loop.\n- **Result Construction**: The `result` string is built incrementally, ensuring all spaces are replaced as per the rules.\n\nThis approach efficiently processes the input string in a single pass, making it optimal with a time complexity of O(n), where n is the length of the input string. The space complexity is also O(n) due to the storage required for the result string."]}
{"name": "mbpp_627_find_First_Missing", "language": "rs", "prompt": "/// Write a rsthon function to find the smallest missing number from a sorted vector of natural numbers.\nfn find_First_Missing(array: Vec<isize>) -> isize {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_627_find_First_Missing.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = find_First_Missing;\n    assert_eq!(candidate(vec![0, 1, 2, 3]), 4);\n    assert_eq!(candidate(vec![0, 1, 2, 6, 9]), 3);\n    assert_eq!(candidate(vec![2, 3, 5, 8, 9]), 0);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve the problem of finding the **smallest missing natural number** from a **sorted vector of natural numbers**, we can leverage the fact that the array is already sorted and contains **distinct natural numbers** (starting from 1). This allows us to efficiently determine the first missing number by checking each element against its expected position in the sequence.\n\n---\n\n### \u2705 Key Insight\n\nFor a sorted array of **distinct natural numbers**, the expected value at index `i` (0-based) is `i + 1`. If the current number does not match this expected value, then `i + 1` is the first missing number. If all numbers from 1 to `n` are present (where `n` is the length of the array), the first missing number is `n + 1`.\n\n---\n\n### \ud83e\udde0 Algorithm\n\n1. Iterate through the array with index `i`.\n2. For each element `num`, check if `num == i + 1`.\n3. If not, return `i + 1` as the first missing number.\n4. If all elements match their expected values, return `array.len() + 1`.\n\nThis approach runs in **O(n)** time and uses **O(1)** extra space, which is optimal for this problem.\n\n---\n\n### \ud83d\udc33 Rust Implementation\n\n```rust\nfn find_First_Missing(array: Vec<isize>) -> isize {\n    for (i, &num) in array.iter().enumerate() {\n        if num != i as isize + 1 {\n            return i as isize + 1;\n        }\n    }\n    (array.len() as isize) + 1\n}\n```\n\n---\n\n### \u2705 Examples\n\n| Input Array        | Output | Explanation |\n|---------------------|--------|---------------|\n| `[]`                | `1`    | Empty array \u2192 first missing is `1` |\n| `[1]`               | `2`    | Only `1` is present \u2192 first missing is `2` |\n| `[2]`               | `1`    | First number is `2` \u2192 first missing is `1` |\n| `[1, 2, 3]`         | `4`    | All numbers from `1` to `3` are present \u2192 first missing is `4` |\n| `[1, 3, 4]`         | `2`    | `2` is missing \u2192 first missing is `2` |\n| `[1, 2, 4]`         | `3`    | `3` is missing \u2192 first missing is `3` |\n\n---\n\n### \ud83d\udccc Notes\n\n- The function assumes that the input array contains **distinct natural numbers** (starting from 1).\n- It works for **empty arrays** and handles edge cases correctly.\n- The solution is efficient and optimal for the given constraints.\n\n---\n\n### \u2705 Final Answer\n\n```rust\nfn find_First_Missing(array: Vec<isize>) -> isize {\n    for (i, &num) in array.iter().enumerate() {\n        if num != i as isize + 1 {\n            return i as isize + 1;\n        }\n    }\n    (array.len() as isize) + 1\n}\n```", "\n\nTo solve the problem of finding the smallest missing number in a sorted vector of natural numbers, we can leverage the fact that the array is already sorted. The key insight is that for a sorted array of natural numbers (starting from 0), the smallest missing number corresponds to the first index `i` where the value at that index is not equal to `i`.\n\n### Approach\n1. **Iterate through the array**: For each index `i` (0-based) in the array, check if the value at that index equals `i`.\n2. **Check for mismatch**: If at any point the value does not match `i`, return `i` immediately as it is the smallest missing number.\n3. **Handle full coverage**: If all elements in the array match their respective indices (i.e., the array contains all numbers from 0 to `n-1` where `n` is the length of the array), then the smallest missing number is `n` (the next natural number after the last element).\n\nThis approach efficiently checks for the smallest missing number in linear time, O(n), where n is the number of elements in the array. The space complexity is O(1) since we only use a constant amount of additional space.\n\n### Solution Code\n```rust\nfn find_First_Missing(array: Vec<isize>) -> isize {\n    for (i, num) in array.iter().enumerate() {\n        if num != i as isize {\n            return i as isize;\n        }\n    }\n    array.len() as isize\n}\n```\n\n### Explanation\n- **Initialization**: The function starts by iterating over each element in the sorted vector using `iter().enumerate()`, which provides both the index `i` and the value `num`.\n- **Check for mismatch**: For each index `i`, the code checks if the current value `num` equals `i` (converted to `isize`). If it does not, the function immediately returns `i` as the smallest missing number.\n- **Full coverage check**: If the loop completes without finding any mismatches, it means the array contains all numbers from 0 to `array.len() - 1`. In this case, the smallest missing number is `array.len()` (the next natural number after the last element in the array).\n\nThis solution efficiently handles all edge cases, including empty arrays, arrays with duplicates, and arrays that fully cover the sequence from 0 up to `n-1`. The algorithm ensures optimal performance with minimal computational overhead.", "\n\nTo solve the problem of finding the smallest missing natural number in a sorted vector of natural numbers, we can leverage the fact that the input array is already sorted. The key insight is that the smallest missing natural number must be the first number in the sequence of natural numbers (starting from 1) that does not appear in the array.\n\n### Approach\n1. **Initialization**: Start with `expected` set to 1, representing the smallest natural number we are checking for.\n2. **Iteration**: Traverse each number in the sorted array:\n   - If the current number equals `expected`, increment `expected` by 1 (indicating we've found the next natural number).\n   - If the current number is greater than `expected`, return `expected` immediately (since it's the first missing number).\n3. **Completion**: If the entire array is processed without finding a missing number, `expected` will be the smallest missing number (i.e., `array.len() + 1`).\n\nThis approach efficiently checks for the first missing number in linear time, O(n), where n is the length of the array, making it optimal for this problem.\n\n### Solution Code\n```rust\nfn find_First_Missing(array: Vec<isize>) -> isize {\n    let mut expected = 1;\n    for num in array {\n        if num == expected {\n            expected += 1;\n        } else if num > expected {\n            return expected;\n        }\n    }\n    expected\n}\n```\n\n### Explanation\n- **Initialization**: The variable `expected` starts at 1, the smallest natural number.\n- **Loop Through Array**: For each number in the sorted array:\n  - If the number matches `expected`, we move to the next natural number by incrementing `expected`.\n  - If the number is larger than `expected`, it means `expected` is missing, so we return it immediately.\n- **Final Check**: If the loop completes without returning, `expected` will be the first missing number (since the array contains all natural numbers from 1 up to `array.len()`).\n\nThis solution efficiently handles all edge cases, including empty arrays, arrays with duplicates, and arrays where the missing number is at the beginning or end of the sequence. The algorithm ensures optimal performance with a single pass through the array, making it both time and space efficient."]}
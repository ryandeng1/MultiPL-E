{"name": "mbpp_438_count_bidirectional", "language": "rs", "prompt": "/// Write a function to count bidirectional tuple pairs.\nfn count_bidirectional(test_list: Vec<(isize, isize)>) -> isize {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_438_count_bidirectional.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = count_bidirectional;\n    assert_eq!(candidate(vec![(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)]), 3);\n    assert_eq!(candidate(vec![(5, 6), (1, 3), (6, 5), (9, 1), (6, 5), (2, 1)]), 2);\n    assert_eq!(candidate(vec![(5, 6), (1, 2), (6, 5), (9, 2), (6, 5), (2, 1)]), 4);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve this problem, we need to count the number of bidirectional tuple pairs in a given list of tuples. A bidirectional pair is defined as two tuples `(a, b)` and `(b, a)` that are reverses of each other. Each such unordered pair should be counted exactly once.\n\n### Approach\n1. **Frequency Mapping**: First, we create a frequency map (using a `HashMap`) to count occurrences of each tuple in the input list. This helps in efficiently checking how many times each tuple appears.\n2. **Counting Pairs**: For each tuple `(a, b)` in the frequency map:\n   - Check if its reverse tuple `(b, a)` exists in the map.\n   - To avoid double counting, we only process tuples where `a < b`. This ensures that each unique pair `(a, b)` and `(b, a)` is processed exactly once.\n   - Multiply the counts of `(a, b)` and `(b, a)` and add the result to the total count of bidirectional pairs.\n\n### Solution Code\n```rust\nuse std::collections::HashMap;\n\nfn count_bidirectional(test_list: Vec<(isize, isize)>) -> isize {\n    let mut count_map = HashMap::new();\n    for (a, b) in test_list {\n        *count_map.entry((a, b)).or_insert(0) += 1;\n    }\n\n    let mut total = 0;\n    for (key, count) in count_map {\n        let (a, b) = key;\n        if a < b {\n            if let Some(count_ba) = count_map.get(&(b, a)) {\n                total += count * count_ba;\n            }\n        }\n    }\n    total\n}\n```\n\n### Explanation\n1. **Frequency Mapping**: The code starts by iterating over each tuple in the input list and populating a `HashMap` where keys are the tuples and values are their counts. This allows O(1) lookups for reverse tuples later.\n2. **Processing Pairs**: The code then iterates over each tuple in the `HashMap`. For each tuple `(a, b)`:\n   - It checks if `a < b` to ensure each pair is processed only once (avoiding double counting).\n   - If the reverse tuple `(b, a)` exists in the map, it multiplies the counts of `(a, b)` and `(b, a)` and adds the result to the total.\n3. **Result Calculation**: The total count of bidirectional pairs is returned after processing all tuples. This approach efficiently counts each unique bidirectional pair exactly once.\n\nThis method ensures optimal performance with O(n) time complexity for building the frequency map and O(m) time for processing the map (where m is the number of unique tuples), making it suitable for large input sizes. The space complexity is O(m) to store the frequency map.", "\n\nTo solve the problem of counting bidirectional tuple pairs, we interpret a \"bidirectional tuple pair\" as a pair of distinct tuples `(a, b)` and `(b, a)` in the input list. Each such pair contributes exactly one to the count.\n\n### Approach\n1. **Frequency Map Construction**: We first create a frequency map (hash map) where each key is a tuple `(a, b)` from the input list, and the value is how many times that tuple appears in the list.\n2. **Counting Valid Pairs**: For each tuple `(a, b)` in the frequency map:\n   - If `a < b`, we check if the reverse tuple `(b, a)` exists in the map.\n   - If it exists, we multiply the counts of `(a, b)` and `(b, a)` and add this product to our total count.\n   - This ensures each bidirectional pair is counted exactly once (to avoid double-counting).\n\n### Solution Code\n```rust\nuse std::collections::HashMap;\n\nfn count_bidirectional(test_list: Vec<(isize, isize)>) -> isize {\n    let mut freq = HashMap::new();\n    for (a, b) in test_list {\n        *freq.entry((a, b)).or_insert(0) += 1;\n    }\n\n    let mut count = 0;\n    for (key, count_val) in freq {\n        let (a, b) = key;\n        if a < b {\n            let reverse = (b, a);\n            if let Some(other_count) = freq.get(&reverse) {\n                count += count_val * other_count;\n            }\n        }\n    }\n    count\n}\n```\n\n### Explanation\n1. **Frequency Map**: The code starts by iterating through the input list to build a frequency map (`freq`). This map records how many times each tuple appears in the list.\n2. **Counting Pairs**: For each tuple `(a, b)` in the map:\n   - The condition `a < b` ensures that each pair `(a, b)` and `(b, a)` is processed only once (e.g., `(1, 2)` is processed before `(2, 1)`).\n   - The reverse tuple `(b, a)` is checked for existence in the map using `freq.get(&reverse)`.\n   - If the reverse tuple exists, the product of their counts is added to the total count. This product represents the number of valid bidirectional pairs between the two tuples.\n3. **Result**: The function returns the total count of such bidirectional pairs.\n\nThis approach efficiently counts all bidirectional pairs in linear time relative to the input size, leveraging a hash map for constant-time lookups and ensuring no double-counting. The solution handles all edge cases, including tuples where `a == b` (which are skipped as they do not form valid bidirectional pairs with another distinct tuple).", "\n\nTo solve this problem, we need to count the number of bidirectional tuple pairs in a given list of tuples. A bidirectional tuple pair consists of two distinct tuples where one tuple is the reverse of the other. For example, the tuples `(1, 2)` and `(2, 1)` form a bidirectional pair.\n\n### Approach\n1. **Frequency Map Construction**: We first create a frequency map (using a `HashMap`) to count how many times each tuple appears in the input list. This helps in efficiently checking for the presence of reverse tuples later.\n2. **Counting Valid Pairs**: For each unique tuple `(x, y)` in the frequency map:\n   - We check if `x < y` to avoid double-counting (since the pair `(x, y)` and `(y, x)` is the same as `(y, x)` and `(x, y)`).\n   - If `x < y`, we then check if the reverse tuple `(y, x)` exists in the frequency map.\n   - If it exists, we multiply the counts of `(x, y)` and `(y, x)` and add this product to our total count of bidirectional pairs.\n\nThis approach efficiently counts all bidirectional pairs in linear time relative to the number of unique tuples, making it optimal for large input sizes.\n\n### Solution Code\n```rust\nuse std::collections::HashMap;\n\nfn count_bidirectional(test_list: Vec<(isize, isize)>) -> isize {\n    let mut count_map = HashMap::new();\n    for tuple in test_list {\n        let count = count_map.entry(tuple).or_insert(0);\n        *count += 1;\n    }\n\n    let mut total = 0;\n    for (tuple, count) in &count_map {\n        let (x, y) = *tuple;\n        if x < y {\n            if let Some(rev_count) = count_map.get(&(y, x)) {\n                total += count * rev_count;\n            }\n        }\n    }\n    total\n}\n```\n\n### Explanation\n1. **Frequency Map Construction**: The code iterates over each tuple in the input list and updates its count in the `HashMap`. This step ensures we know how many times each tuple appears.\n2. **Counting Valid Pairs**: The code then iterates over each unique tuple in the frequency map. For each tuple `(x, y)` where `x < y`, it checks if the reverse tuple `(y, x)` exists in the map. If it does, the product of their counts is added to the total. This ensures each bidirectional pair is counted exactly once without duplication.\n\nThis approach efficiently leverages a hash map for constant-time lookups and avoids double-counting by only considering pairs where the first element is less than the second. The overall time complexity is O(n) for building the frequency map and O(m) for processing unique tuples (where m is the number of unique tuples), making it optimal for the problem constraints."]}
{"name": "HumanEval_161_solve", "language": "rs", "prompt": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_161_solve.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve this problem, we need to transform a given string according to specific rules. The transformation involves reversing the case of each alphabetic character in the string if there is at least one alphabetic character present. If the string contains no alphabetic characters, we simply reverse the entire string.\n\n### Approach\n1. **Check for Alphabetic Characters**: First, we check if the input string contains any alphabetic characters. This is done using the `any` method on the string's characters, which checks if at least one character is alphabetic.\n2. **Transform Characters if Alphabetic Present**: If there are alphabetic characters in the string, we iterate over each character:\n   - For each alphabetic character, we reverse its case (uppercase to lowercase and vice versa).\n   - Non-alphabetic characters remain unchanged.\n3. **Reverse String if No Alphabetic Characters**: If the string contains no alphabetic characters, we reverse the entire string.\n\n### Solution Code\n```rust\nfn solve(s: String) -> String {\n    if s.chars().any(|c| c.is_ascii_alphabetic()) {\n        s.chars().map(|c| {\n            if c.is_ascii_alphabetic() {\n                if c.is_ascii_uppercase() {\n                    c.to_ascii_lowercase()\n                } else {\n                    c.to_ascii_uppercase()\n                }\n            } else {\n                c\n            }\n        }).collect()\n    } else {\n        s.chars().rev().collect()\n    }\n}\n```\n\n### Explanation\n1. **Checking for Alphabetic Characters**: The expression `s.chars().any(|c| c.is_ascii_alphabetic())` checks if there is at least one alphabetic character in the string. This is efficient as it stops processing once it finds the first alphabetic character.\n2. **Character Transformation**: \n   - For each character in the string, if it is alphabetic, we check if it is uppercase. If so, we convert it to lowercase; otherwise, we convert it to uppercase.\n   - Non-alphabetic characters are left unchanged.\n3. **String Reversal**: If no alphabetic characters are found, the entire string is reversed using `s.chars().rev().collect()`, which efficiently reverses the string and collects it into a new `String`.\n\nThis approach efficiently handles both scenarios (presence or absence of alphabetic characters) with clear and concise code, leveraging Rust's string and character handling capabilities. The solution processes the string in linear time, making it optimal for the given problem constraints.", "\n\nTo solve this problem, we need to process a string according to specific rules:\n1. If a character in the string is a letter (ASCII), reverse its case (lowercase to uppercase or vice versa).\n2. If the string contains no letters, reverse the entire string.\n\n### Approach\n1. **Check for Letters**: First, we determine if the string contains any ASCII letters. This is done by checking if all characters in the string are non-letters.\n2. **Reverse String if No Letters**: If the string has no letters, we simply reverse the entire string.\n3. **Flip Case for Letters**: If the string contains at least one letter, we iterate through each character:\n   - For lowercase letters, convert them to uppercase.\n   - For uppercase letters, convert them to lowercase.\n   - Non-letter characters remain unchanged.\n\nThis approach efficiently handles both scenarios (with and without letters) by leveraging Rust's standard library functions for character checks and transformations.\n\n### Solution Code\n```rust\nfn solve(s: String) -> String {\n    if s.chars().all(|c| !c.is_ascii_alphabetic()) {\n        s.chars().rev().collect()\n    } else {\n        s.chars().map(|c| {\n            if c.is_ascii_lowercase() {\n                c.to_ascii_uppercase()\n            } else if c.is_ascii_uppercase() {\n                c.to_ascii_lowercase()\n            } else {\n                c\n            }\n        }).collect()\n    }\n}\n```\n\n### Explanation\n1. **Check for Letters**: The expression `s.chars().all(|c| !c.is_ascii_alphabetic())` checks if every character in the string is not an ASCII letter. If true, the string has no letters.\n2. **Reverse String**: If the string has no letters, `s.chars().rev().collect()` reverses the string and returns it as a `String`.\n3. **Flip Case for Letters**: For strings containing letters:\n   - `c.is_ascii_lowercase()` checks if a character is lowercase.\n   - `c.to_ascii_uppercase()` converts a lowercase letter to uppercase.\n   - `c.is_ascii_uppercase()` checks if a character is uppercase.\n   - `c.to_ascii_lowercase()` converts an uppercase letter to lowercase.\n   - Non-letter characters are left unchanged.\n   \nThe `map` function applies these transformations to each character in the string, and `collect` gathers the transformed characters into a new `String`.\n\nThis solution efficiently handles all specified cases, ensuring correct transformation of letters and proper string reversal when necessary. The use of ASCII-specific checks ensures compatibility with the problem's context and examples.", "\n\nTo solve this problem, we need to process a string according to specific rules: reverse the case of each alphabetic character (lowercase to uppercase and vice versa), while keeping non-alphabetic characters unchanged. If the string contains no alphabetic characters, we reverse the entire string.\n\n### Approach\n1. **Check for Alphabetic Characters**: Iterate through each character in the input string to determine if it is an alphabetic character (specifically ASCII letters 'a'-'z' and 'A'-'Z').\n2. **Flip Case for Alphabetic Characters**: For each alphabetic character encountered, flip its case (lowercase to uppercase and vice versa).\n3. **Handle No Letters Case**: If no alphabetic characters are found during the iteration, reverse the entire string.\n4. **Construct Result**: Build the result string by processing each character as described.\n\nThe key insight is to first determine if there are any alphabetic characters in the original string. If there are, process each character individually; otherwise, reverse the string.\n\n### Solution Code\n```rust\nfn solve(s: String) -> String {\n    let mut has_letter = false;\n    let mut result = String::new();\n    for c in s.chars() {\n        if c >= 'a' && c <= 'z' {\n            has_letter = true;\n            result.push((c as u8 - 32) as char);\n        } else if c >= 'A' && c <= 'Z' {\n            has_letter = true;\n            result.push((c as u8 + 32) as char);\n        } else {\n            result.push(c);\n        }\n    }\n    if !has_letter {\n        result.chars().rev().collect()\n    } else {\n        result\n    }\n}\n```\n\n### Explanation\n1. **Initialization**: We initialize a boolean `has_letter` to track if any alphabetic characters are found and a `String` `result` to build the output.\n2. **Character Processing**: For each character in the input string:\n   - If the character is a lowercase letter ('a'-'z'), flip it to uppercase by subtracting 32 from its ASCII value (since 'A' is 32 positions above 'a' in ASCII).\n   - If the character is an uppercase letter ('A'-'Z'), flip it to lowercase by adding 32 to its ASCII value.\n   - Non-alphabetic characters are added to the result as-is.\n3. **Result Construction**: After processing all characters, if no alphabetic characters were found (`has_letter` remains `false`), the result string is reversed. Otherwise, the processed string is returned as-is.\n\nThis approach efficiently handles the problem requirements by leveraging ASCII character properties for case flipping and ensures optimal performance with a single pass through the string. The solution is both clear and concise, adhering to the problem constraints and examples."]}
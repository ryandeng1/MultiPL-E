{"name": "mbpp_598_armstrong_number", "language": "rs", "prompt": "/// Write a function to check whether the given number is armstrong or not.\nfn armstrong_number(number: isize) -> bool {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_598_armstrong_number.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = armstrong_number;\n    assert_eq!(candidate(153), true);\n    assert_eq!(candidate(259), false);\n    assert_eq!(candidate(4458), false);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo determine if a given number is an Armstrong number (also known as a narcissistic number), we check if the number is equal to the sum of its own digits each raised to the power of the number of digits. \n\n### Approach\n1. **Handle Negative Numbers**: Armstrong numbers are defined for non-negative integers, so if the input number is negative, return `false`.\n2. **Special Case for Zero**: Zero is considered an Armstrong number (since \\(0^1 = 0\\)).\n3. **Convert to String**: Convert the absolute value of the number (since we've handled negatives) to a string to process each digit.\n4. **Count Digits**: Determine the number of digits in the number.\n5. **Calculate Sum of Powers**: For each digit in the string:\n   - Convert the character to a digit.\n   - Compute the digit raised to the power of the number of digits (using a loop for precision to avoid overflow).\n   - Add the result to a running total.\n6. **Compare Total**: Check if the computed total equals the original number (converted to a 128-bit unsigned integer to handle large values safely).\n\n### Solution Code\n```rust\nfn armstrong_number(number: isize) -> bool {\n    if number < 0 {\n        return false;\n    }\n    if number == 0 {\n        return true;\n    }\n\n    let s = number.to_string();\n    let n = s.len() as u32;\n\n    let mut total = 0u128;\n    for c in s.chars() {\n        let digit = c.to_digit(10).unwrap();\n        let mut term = 1u128;\n        for _ in 0..n {\n            term *= digit as u128;\n        }\n        total += term;\n    }\n\n    total == number as u128\n}\n```\n\n### Explanation\n1. **Negative Check**: The function immediately returns `false` for any negative input since Armstrong numbers are non-negative.\n2. **Zero Handling**: Zero is a special case that returns `true` because \\(0^1 = 0\\).\n3. **String Conversion**: The number is converted to a string to easily iterate over each digit.\n4. **Digit Processing**: For each digit in the string:\n   - The character is converted to a numeric digit.\n   - A loop computes the digit raised to the power of the number of digits (e.g., for \"153\", each digit is raised to the 3rd power).\n   - The result of each digit's power is added to a running total stored in a 128-bit unsigned integer (`u128`) to prevent overflow.\n5. **Comparison**: The total is compared to the original number (converted to `u128`). If they match, the function returns `true`; otherwise, it returns `false`.\n\nThis approach efficiently checks for Armstrong numbers by leveraging string manipulation for digit extraction and careful handling of large numbers using 128-bit integers to ensure correctness across the full range of valid inputs.", "\n\nTo determine if a given number is an Armstrong number (also known as a narcissistic number), we need to check if the number is equal to the sum of its own digits each raised to the power of the number of digits. \n\n### Approach\n1. **Check for Negative Numbers**: Armstrong numbers are defined for non-negative integers. If the input number is negative, return `false`.\n2. **Convert to String**: Convert the number to a string to process each digit and determine the number of digits.\n3. **Calculate Sum of Digits Raised to Power**: For each digit in the string:\n   - Convert the digit character to an integer.\n   - Raise the digit to the power of the total number of digits.\n   - Accumulate the sum of these values.\n4. **Compare Sum with Original Number**: Convert the original number to a `u64` (to handle large numbers safely) and compare it with the computed sum. If they are equal, return `true`; otherwise, return `false`.\n\nThis approach efficiently checks for Armstrong numbers by leveraging string manipulation for digit extraction and using `u64` for safe arithmetic operations to avoid overflow issues with large numbers.\n\n### Solution Code\n```rust\nfn armstrong_number(number: isize) -> bool {\n    if number < 0 {\n        return false;\n    }\n    let s = number.to_string();\n    let n = s.len();\n    let mut total = 0u64;\n    for c in s.chars() {\n        let digit = c.to_digit(10).unwrap();\n        total += (digit as u64).pow(n as u64);\n    }\n    total == (number as u64)\n}\n```\n\n### Explanation\n1. **Negative Check**: The function first checks if the input number is negative. If so, it immediately returns `false` since Armstrong numbers are non-negative.\n2. **String Conversion**: The number is converted to a string to facilitate digit extraction and length calculation.\n3. **Digit Processing**: Each character in the string is converted to a digit. The digit is then raised to the power of the string length (number of digits) and added to a running total.\n4. **Comparison**: The computed total (sum of digits raised to the power of the number of digits) is compared with the original number converted to `u64`. If they match, the function returns `true`; otherwise, it returns `false`.\n\nThis method efficiently handles the constraints of the problem, including large numbers (up to the maximum `isize` value), by using `u64` for arithmetic operations to prevent overflow and ensure accurate comparisons. The solution is both clear and optimal for the given problem constraints.", "\n\nTo determine if a given number is an Armstrong number (also known as a narcissistic number), we check if the number is equal to the sum of its own digits each raised to the power of the number of digits. \n\n### Approach\n1. **Handle Negative Numbers**: Armstrong numbers are defined for non-negative integers, so if the input number is negative, we immediately return `false`.\n2. **Convert to String**: Convert the absolute value of the number (since we've handled negatives) to a string to process each digit.\n3. **Count Digits**: Determine the number of digits (`n`) in the string representation of the number.\n4. **Calculate Sum of Digits Raised to Power**: For each digit in the string:\n   - Convert the character to a digit (as a `u32`).\n   - Raise the digit to the power of `n` (the number of digits).\n   - Accumulate the result in a `u64` total (to handle large numbers safely).\n5. **Compare Total with Original Number**: Convert the original number to a `u64` and compare it with the computed total. If they are equal, return `true`; otherwise, return `false`.\n\nThis approach efficiently checks for Armstrong numbers by leveraging string manipulation for digit extraction and ensures safe arithmetic operations using `u64` to avoid overflow for numbers within the typical range of `isize`.\n\n### Solution Code\n```rust\nfn armstrong_number(number: isize) -> bool {\n    if number < 0 {\n        return false;\n    }\n    let s = number.to_string();\n    let n = s.len();\n    let mut total = 0;\n    for c in s.chars() {\n        let d = c.to_digit(10).unwrap();\n        total += d.pow(n as u32) as u64;\n    }\n    total == number as u64\n}\n```\n\n### Explanation\n1. **Negative Check**: The function first checks if the number is negative. If so, it returns `false` since Armstrong numbers are non-negative.\n2. **String Conversion**: The number is converted to a string to facilitate digit extraction.\n3. **Digit Count**: The length of the string gives the number of digits (`n`).\n4. **Digit Processing**: For each character in the string:\n   - The character is converted to a digit (a `u32` value).\n   - The digit is raised to the power of `n` (the number of digits).\n   - The result is added to a running total (stored as `u64` to prevent overflow).\n5. **Comparison**: The computed total is compared with the original number converted to `u64`. If they match, the function returns `true` (indicating the number is an Armstrong number); otherwise, it returns `false`.\n\nThis method efficiently handles the constraints of the problem, ensuring correctness for all valid non-negative integers within the range of `isize` (up to 19 digits). The use of `u64` for arithmetic operations ensures that intermediate results do not overflow, providing robust and accurate results."]}
{"name": "mbpp_635_heap_sort", "language": "rs", "prompt": "/// Write a function to sort the given vector.\nfn heap_sort(iterable: Vec<isize>) -> Vec<isize> {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_635_heap_sort.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = heap_sort;\n    assert_eq!(candidate(vec![1, 3, 5, 7, 9, 2, 4, 6, 8, 0]), vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![25, 35, 22, 85, 14, 65, 75, 25, 58]), vec![14, 22, 25, 25, 35, 58, 65, 75, 85]);\n    assert_eq!(candidate(vec![7, 1, 9, 5]), vec![1, 5, 7, 9]);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve this problem, we need to implement the Heap Sort algorithm, which is a comparison-based sorting algorithm that uses a binary heap data structure to sort elements efficiently. The algorithm works by first building a max-heap from the input array and then repeatedly extracting the maximum element from the heap to build the sorted array.\n\n### Approach\n1. **Build a Max-Heap**: The first step involves converting the input array into a max-heap. A max-heap is a complete binary tree where the value of each parent node is greater than or equal to the values of its children. This is done by starting from the last non-leaf node (which is at index `n/2 - 1` in 0-based indexing) and heapifying each node down to the root.\n2. **Extract Elements**: Once the max-heap is built, the largest element (root of the heap) is swapped with the last element of the heap. The heap size is then reduced by one, and the new root is heapified to maintain the max-heap property. This process is repeated until all elements are extracted and placed in their correct positions in the sorted array.\n\nThe key steps in the implementation are:\n- **Heapify Function**: This helper function ensures that the subtree rooted at a given index satisfies the max-heap property. It compares the node with its left and right children and swaps the node with the largest child if necessary, then continues the process down the tree.\n- **Building the Heap**: Iterate from the last non-leaf node down to the root, heapifying each node to maintain the max-heap structure.\n- **Sorting**: Extract the maximum element (root) and place it at the end of the array. Reduce the heap size by one and heapify the new root to restore the max-heap property.\n\n### Solution Code\n```rust\nfn heap_sort(iterable: Vec<isize>) -> Vec<isize> {\n    let mut vec = iterable;\n    let n = vec.len();\n\n    fn heapify(vec: &mut Vec<isize>, n: usize, i: usize) {\n        let mut current = i;\n        while true {\n            let left = 2 * current + 1;\n            let right = 2 * current + 2;\n            let mut largest = current;\n\n            if left < n && vec[left] > vec[largest] {\n                largest = left;\n            }\n            if right < n && vec[right] > vec[largest] {\n                largest = right;\n            }\n\n            if largest == current {\n                break;\n            }\n\n            vec.swap(current, largest);\n            current = largest;\n        }\n    }\n\n    for i in (0..n/2).rev() {\n        heapify(&mut vec, n, i);\n    }\n\n    for i in (0..n).rev() {\n        vec.swap(0, i);\n        heapify(&mut vec, i, 0);\n    }\n\n    vec\n}\n```\n\n### Explanation\n1. **Heapify Function**: The `heapify` function ensures that the subtree rooted at index `i` satisfies the max-heap property. It starts at the given index and compares the node with its left and right children. If a child is larger, it swaps the node with the largest child and continues the process down the tree until the heap property is restored.\n2. **Building the Heap**: The loop iterates from the last non-leaf node (index `n/2 - 1`) down to the root (index `0`). For each node, the `heapify` function is called to ensure the subtree rooted at that node meets the max-heap property.\n3. **Sorting Process**: After building the max-heap, the algorithm repeatedly swaps the root (maximum element) with the last element of the heap. The heap size is reduced by one, and the new root is heapified. This process continues until all elements are sorted in ascending order.\n\nThis approach efficiently sorts the input vector in-place with a time complexity of O(n log n), making it suitable for large datasets. The space complexity is O(1) as the sorting is done in-place without additional space.", "\n\nTo solve this problem, we need to implement the Heapsort algorithm to sort a given vector of integers in ascending order. Heapsort is an in-place comparison-based sorting algorithm that uses a binary heap data structure to sort elements efficiently. The algorithm involves two main steps: building a max heap from the input array and then repeatedly extracting the maximum element from the heap to build the sorted array.\n\n### Approach\n1. **Clone the Input Vector**: Since the function signature requires returning a new vector (by value), we first clone the input vector to avoid modifying the original.\n2. **Build Max Heap**: Convert the cloned vector into a max heap. A max heap is a complete binary tree where the value of each node is greater than or equal to the values of its children. This is done by starting from the last non-leaf node (at index `n/2 - 1`) and moving up to the root (index 0). For each node, we ensure it satisfies the max heap property by comparing it with its children and swapping if necessary.\n3. **Extract Elements**: Once the max heap is built, the largest element (root) is swapped with the last element of the heap. The heap size is reduced by one, and the new root is heapified to maintain the max heap property. This process repeats until the entire heap is sorted.\n\nThe key insight here is that each step of heapifying ensures the heap property is maintained, and the extraction step efficiently places the largest remaining element in its correct position in the sorted array.\n\n### Solution Code\n```rust\nfn heap_sort(iterable: Vec<isize>) -> Vec<isize> {\n    let mut arr = iterable.clone();\n    let n = arr.len();\n\n    for i in (0..n/2).rev() {\n        let mut current = i;\n        let mut largest = i;\n        while true {\n            let left = 2 * current + 1;\n            let right = 2 * current + 2;\n\n            if left < n && arr[left] > arr[largest] {\n                largest = left;\n            }\n            if right < n && arr[right] > arr[largest] {\n                largest = right;\n            }\n\n            if largest == current {\n                break;\n            }\n\n            arr.swap(current, largest);\n            current = largest;\n        }\n    }\n\n    for i in (0..n-1).rev() {\n        arr.swap(0, i);\n        let mut current = 0;\n        let mut largest = 0;\n        while true {\n            let left = 2 * current + 1;\n            let right = 2 * current + 2;\n\n            if left < i && arr[left] > arr[largest] {\n                largest = left;\n            }\n            if right < i && arr[right] > arr[largest] {\n                largest = right;\n            }\n\n            if largest == current {\n                break;\n            }\n\n            arr.swap(current, largest);\n            current = largest;\n        }\n    }\n\n    arr\n}\n```\n\n### Explanation\n1. **Cloning the Input**: The input vector `iterable` is cloned into `arr` to ensure we work on a copy and do not modify the original.\n2. **Building the Max Heap**: \n   - We iterate from the last non-leaf node (index `n/2 - 1`) up to the root (index 0).\n   - For each node, we check its left and right children. If either child is larger than the current node, we update the largest index.\n   - We swap the current node with the largest child if necessary and continue heapifying the affected subtree until the heap property is restored.\n3. **Extracting Elements**:\n   - We swap the root (largest element) with the last element of the heap (at index `i`).\n   - We then heapify the reduced heap (size `i`) starting from the root to maintain the max heap property.\n   - This process repeats for each element from the end of the array down to the start, placing each largest element in its correct sorted position.\n\nThis approach efficiently sorts the vector in-place (on the cloned vector) with a time complexity of O(n log n), which is optimal for comparison-based sorting algorithms. The space complexity is O(1) for the sorting process (excluding the input clone), making it suitable for large datasets.", "\n\nTo solve this problem, we need to implement the Heap Sort algorithm to sort a given vector of integers in ascending order. Heap Sort is an efficient in-place sorting algorithm that uses a binary heap data structure. The algorithm works by first building a max-heap from the input array and then repeatedly extracting the maximum element from the heap and placing it at the end of the sorted array.\n\n### Approach\n1. **Build a Max-Heap**: Convert the input array into a max-heap. A max-heap is a binary tree where each parent node is greater than or equal to its children. The heap is built by starting from the last non-leaf node (at index `n/2 - 1` for a zero-based array) and heapifying each subtree down to the root.\n2. **Extract Elements**: Once the max-heap is built, the largest element (root) is swapped with the last element of the heap. The heap size is reduced by one, and the new root is heapified to maintain the max-heap property. This process is repeated until the entire array is sorted.\n\nThe key steps involved are:\n- **Heapify**: A helper function that ensures the subtree rooted at a given index satisfies the max-heap property. If the current node is not the largest, it swaps with the largest child and recursively heapifies the affected subtree.\n- **Building the Heap**: Iterate from the last non-leaf node down to the root, heapifying each node to maintain the max-heap property.\n- **Sorting**: Extract the maximum element (root) and place it at the end of the array. Reduce the heap size by one and heapify the root to restore the max-heap property.\n\n### Solution Code\n```rust\nfn heap_sort(iterable: Vec<isize>) -> Vec<isize> {\n    let mut arr = iterable;\n    let n = arr.len();\n    \n    if n <= 1 {\n        return arr;\n    }\n\n    fn heapify(arr: &mut [isize], n: usize, i: usize) {\n        let mut largest = i;\n        let left = 2 * i + 1;\n        let right = 2 * i + 2;\n        \n        if left < n && arr[left] > arr[largest] {\n            largest = left;\n        }\n        if right < n && arr[right] > arr[largest] {\n            largest = right;\n        }\n        \n        if largest != i {\n            arr.swap(i, largest);\n            heapify(arr, n, largest);\n        }\n    }\n\n    for i in (0..n/2).rev() {\n        heapify(&mut arr, n, i);\n    }\n\n    for i in (1..n).rev() {\n        arr.swap(0, i);\n        heapify(&mut arr, i, 0);\n    }\n\n    arr\n}\n```\n\n### Explanation\n1. **Heapify Function**: This nested function ensures that the subtree rooted at index `i` adheres to the max-heap property. It compares the node with its left and right children, swaps the node with the largest child if necessary, and recursively heapifies the affected subtree.\n2. **Building the Max-Heap**: The loop starts from the last non-leaf node (index `n/2 - 1` down to 0) and heapifies each node. This step transforms the input array into a max-heap where the largest element is at the root.\n3. **Sorting Process**: The loop starts from the last element (index `n-1`) down to the first element (index `1`). In each iteration:\n   - The root (largest element) is swapped with the current last element of the heap.\n   - The heap size is reduced by one, and the root is heapified to maintain the max-heap property for the reduced heap.\n   \nThis process ensures that after each iteration, the largest unsorted element is placed in its correct position at the end of the array, resulting in a fully sorted array in ascending order.\n\nThe algorithm operates in-place with a time complexity of O(n log n) for all cases, making it efficient for large datasets. The space complexity is O(1) since the sorting is done in-place without additional space (excluding the input vector)."]}
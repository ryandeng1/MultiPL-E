{"name": "mbpp_721_maxAverageOfPath", "language": "rs", "prompt": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_721_maxAverageOfPath.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve the problem of finding the path with the **maximum average** from the top-left to the bottom-right of an $ N \\times N $ matrix, we begin by recognizing a critical observation: **all valid paths from the top-left to the bottom-right cell have exactly $ 2N - 1 $ cells**. This means that the **average cost** of any path is simply the **total cost** of the path divided by a constant $ (2N - 1) $. Therefore, maximizing the average is equivalent to maximizing the total cost of the path.\n\n---\n\n### \ud83d\udd0d Key Insight\n\nSince the number of cells in every valid path is fixed ($ 2N - 1 $), the problem reduces to finding the **maximum total cost path** from the top-left to the bottom-right cell using only right or down moves.\n\nThis is a classic **dynamic programming (DP)** problem where we compute the maximum cumulative cost to reach each cell.\n\n---\n\n### \ud83e\udde0 Dynamic Programming Approach\n\nWe define a DP table `dp[i][j]` as the **maximum total cost** to reach cell `(i, j)` from the top-left corner `(0, 0)`.\n\n#### Base Cases:\n- `dp[0][0] = cost[0][0]` (starting point)\n- For the first row: `dp[0][j] = dp[0][j-1] + cost[0][j]`\n- For the first column: `dp[i][0] = dp[i-1][0] + cost[i][0]`\n\n#### General Case:\nFor all other cells:\n```\ndp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n```\n\nAfter filling the DP table, the value `dp[N-1][N-1]` gives the **maximum total cost** of any path from top-left to bottom-right.\n\nThe **maximum average** is then:\n$$\n\\text{max\\_average} = \\frac{\\text{dp}[N-1][N-1]}{2N - 1}\n$$\n\n---\n\n### \u2705 Implementation in Rust\n\nHere's the efficient and clean implementation:\n\n```rust\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    if n == 0 {\n        return 0.0;\n    }\n\n    let mut dp = vec![vec![0; n]; n];\n    dp[0][0] = cost[0][0];\n\n    // Fill first row\n    for j in 1..n {\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n\n    // Fill first column\n    for i in 1..n {\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n\n    // Fill the rest of the DP table\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = dp[i-1][j].max(dp[i][j-1]) + cost[i][j];\n        }\n    }\n\n    // Compute the average\n    (dp[n-1][n-1] as f64) / (2.0 * n - 1.0)\n}\n```\n\n---\n\n### \ud83d\udccc Explanation\n\n- The `dp` table stores the **maximum cumulative cost** to reach each cell.\n- We initialize the first row and column since they can only be reached from the left or top, respectively.\n- For each subsequent cell, we take the **maximum** of the top or left neighbor's cost and add the current cell's cost.\n- Finally, we divide the result by $ 2N - 1 $ to get the **maximum average**.\n\nThis solution efficiently computes the desired result in $ O(N^2) $ time with $ O(N^2) $ space complexity, which is optimal for this problem.\n\n---\n\n### \u2705 Final Answer\n\n```rust\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    if n == 0 {\n        return 0.0;\n    }\n\n    let mut dp = vec![vec![0; n]; n];\n    dp[0][0] = cost[0][0];\n\n    for j in 1..n {\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n\n    for i in 1..n {\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = dp[i-1][j].max(dp[i][j-1]) + cost[i][j];\n        }\n    }\n\n    (dp[n-1][n-1] as f64) / (2.0 * n - 1.0)\n}\n```", "\n\nTo solve the problem of finding the path with the **maximum average** from the top-left to the bottom-right cell in an $ N \\times N $ matrix (where movement is restricted to right or down), we can leverage a crucial observation:\n\n> All valid paths from the top-left to the bottom-right cell have **exactly $ 2N - 1 $** cells. Therefore, maximizing the average is equivalent to maximizing the **total cost** of the path.\n\nThis insight simplifies the problem significantly. Instead of dealing with averages, we can directly compute the **maximum total cost** of any path and then divide it by $ 2N - 1 $ to get the desired average.\n\n---\n\n### \u2705 Solution Approach\n\nWe use **dynamic programming (DP)** to efficiently compute the maximum total cost path from the top-left to the bottom-right cell.\n\n- Initialize a DP table `dp` of size $ N \\times N $.\n- Set `dp[0][0] = cost[0][0]`.\n- For each cell `(i, j)`:\n  - If it's in the first row (`i == 0`), the only way to reach it is from the left.\n  - If it's in the first column (`j == 0`), the only way to reach it is from above.\n  - Otherwise, the maximum cost to reach `(i, j)` is:\n    $$\n    \\text{dp}[i][j] = \\text{cost}[i][j] + \\max(\\text{dp}[i-1][j], \\text{dp}[i][j-1])\n    $$\n\nOnce we compute `dp[N-1][N-1]`, this value represents the **maximum total cost** of any path. The maximum average is then:\n$$\n\\frac{\\text{dp}[N-1][N-1]}{2N - 1}\n$$\n\n---\n\n### \ud83e\udde0 Why This Works\n\n- Every path from `(0, 0)` to `(N-1, N-1)` has exactly $ 2N - 1 $ cells.\n- Since the number of cells is fixed across all paths, maximizing the **average** is equivalent to maximizing the **sum** of the costs along the path.\n- The DP approach ensures that we find the path with the highest sum in $ O(N^2) $ time, which is optimal for this problem.\n\n---\n\n### \u2705 Rust Implementation\n\n```rust\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0; n]; n];\n    \n    dp[0][0] = cost[0][0];\n    \n    for i in 0..n {\n        for j in 0..n {\n            if i == 0 && j == 0 {\n                continue;\n            }\n            if i == 0 {\n                dp[i][j] = dp[i][j - 1] + cost[i][j];\n            } else if j == 0 {\n                dp[i][j] = dp[i - 1][j] + cost[i][j];\n            } else {\n                dp[i][j] = cost[i][j] + dp[i - 1][j].max(dp[i][j - 1]);\n            }\n        }\n    }\n    \n    let total = dp[n - 1][n - 1] as f64;\n    total / (2 * n - 1) as f64\n}\n```\n\n---\n\n### \ud83e\uddea Example Test Cases\n\n#### Case 1: $ 2 \\times 2 $ matrix\n```rust\nmaxAverageOfPath(vec![vec![1, 2], vec![3, 4]])\n```\n- Maximum total cost = 8\n- Number of cells = $ 2*2 - 1 = 3 $\n- Average = $ 8 / 3 \\approx 2.666... $\n\n#### Case 2: $ 3 \\times 3 $ matrix\n```rust\nmaxAverageOfPath(vec![\n    vec![1, 2, 3],\n    vec![4, 5, 6],\n    vec![7, 8, 9]\n])\n```\n- Maximum total cost = 29\n- Number of cells = $ 2*3 - 1 = 5 $\n- Average = $ 29 / 5 = 5.8 $\n\n---\n\n### \u2705 Final Answer\n\nThe function correctly computes the **maximum average** by leveraging dynamic programming to find the path with the **maximum total cost**, then dividing by $ 2N - 1 $.\n\n$$\n\\boxed{\\text{maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64}}\n$$", "\n\nTo solve this problem, we need to find the path from the top-left cell to the bottom-right cell in an $ N \\times N $ matrix that has the **maximum average** cost. The path can only move right or down. The average is defined as the total cost of the path divided by the number of cells visited in the path.\n\n---\n\n### Key Insight\n\nAll valid paths from the top-left to the bottom-right cell in an $ N \\times N $ matrix have **exactly $ 2N - 1 $** cells. This is because:\n- To move from the top-left to the bottom-right, you must make $ N-1 $ right moves and $ N-1 $ down moves.\n- Total steps = $ 2(N-1) $\n- Total cells = $ 2(N-1) + 1 = 2N - 1 $\n\nSince **all paths have the same number of cells**, the average cost of a path is directly proportional to the total cost of that path. Therefore, the problem reduces to finding the **path with the maximum total cost**.\n\n---\n\n### Approach\n\nWe use **dynamic programming** to compute the maximum path sum from the top-left to the bottom-right cell, moving only right or down.\n\n1. Initialize a DP table `dp` of size $ N \\times N $.\n2. Set `dp[0][0]` to the cost of the starting cell.\n3. For each cell `(i, j)`:\n   - If it's on the first row (`i == 0`), the only way to reach it is from the left.\n   - If it's on the first column (`j == 0`), the only way to reach it is from above.\n   - Otherwise, the maximum path sum to reach `(i, j)` is the maximum of the path sums from the cell above or the cell to the left, plus the current cell's cost.\n4. After filling the DP table, the value at `dp[N-1][N-1]` gives the maximum total cost of any path.\n5. The maximum average is then `max_total_cost / (2 * N - 1)`.\n\n---\n\n### Implementation\n\nHere's the Rust implementation:\n\n```rust\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    if n == 0 {\n        return 0.0;\n    }\n    \n    let mut dp = vec![vec![0; n]; n];\n    dp[0][0] = cost[0][0];\n    \n    for i in 0..n {\n        for j in 0..n {\n            if i == 0 && j == 0 {\n                continue;\n            }\n            if i == 0 {\n                dp[i][j] = dp[i][j - 1] + cost[i][j];\n            } else if j == 0 {\n                dp[i][j] = dp[i - 1][j] + cost[i][j];\n            } else {\n                dp[i][j] = dp[i - 1][j].max(dp[i][j - 1]) + cost[i][j];\n            }\n        }\n    }\n    \n    let total = dp[n - 1][n - 1] as f64;\n    total / (2 * n - 1) as f64\n}\n```\n\n---\n\n### Explanation\n\n- **Initialization**: We create a DP table of size $ N \\times N $ to store the maximum path sum up to each cell.\n- **Base Case**: The starting cell `(0, 0)` is initialized with its own cost.\n- **DP Table Filling**:\n  - For the first row, we can only come from the left.\n  - For the first column, we can only come from above.\n  - For other cells, we take the maximum of the path sums from the top or left and add the current cell's cost.\n- **Result Calculation**: The maximum average is computed as the total cost of the best path divided by the fixed number of cells in any valid path ($ 2N - 1 $).\n\nThis approach efficiently computes the solution in $ O(N^2) $ time and space, which is optimal for this problem.\n\n---\n\n### Final Answer\n\n```rust\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    if n == 0 {\n        return 0.0;\n    }\n    \n    let mut dp = vec![vec![0; n]; n];\n    dp[0][0] = cost[0][0];\n    \n    for i in 0..n {\n        for j in 0..n {\n            if i == 0 && j == 0 {\n                continue;\n            }\n            if i == 0 {\n                dp[i][j] = dp[i][j - 1] + cost[i][j];\n            } else if j == 0 {\n                dp[i][j] = dp[i - 1][j] + cost[i][j];\n            } else {\n                dp[i][j] = dp[i - 1][j].max(dp[i][j - 1]) + cost[i][j];\n            }\n        }\n    }\n    \n    let total = dp[n - 1][n - 1] as f64;\n    total / (2 * n - 1) as f64\n}\n```"]}
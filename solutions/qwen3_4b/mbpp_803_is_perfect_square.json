{"name": "mbpp_803_is_perfect_square", "language": "rs", "prompt": "/// Write a function to check whether the given number is a perfect square or not. https://www.geeksforgeeks.org/check-if-given-number-is-perfect-square-in-cpp/\nfn is_perfect_square(n: isize) -> bool {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_803_is_perfect_square.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = is_perfect_square;\n    assert_eq!(candidate(10), false);\n    assert_eq!(candidate(36), true);\n    assert_eq!(candidate(14), false);\n    assert_eq!(candidate(196), true);\n    assert_eq!(candidate(125), false);\n    assert_eq!(candidate(15625), true);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo determine if a given number is a perfect square, we can use a binary search approach. This method efficiently checks for the existence of an integer whose square equals the given number without relying on floating-point arithmetic, which can lead to precision issues with large numbers.\n\n### Approach\n1. **Check for Negative Numbers**: Perfect squares are non-negative, so any negative input is immediately disqualified.\n2. **Binary Search Setup**: Initialize `low` to 0 and `high` to the input number `n`.\n3. **Binary Search Execution**:\n   - Compute the midpoint `mid` of the current search range.\n   - Calculate the square of `mid`.\n   - If the square equals `n`, return `true`.\n   - If the square is less than `n`, adjust the search range to the upper half (`low = mid + 1`).\n   - If the square is greater than `n`, adjust the search range to the lower half (`high = mid - 1`).\n4. **Termination**: If the loop terminates without finding a perfect square, return `false`.\n\nThis approach efficiently narrows down the search space in logarithmic time relative to the input size, making it suitable for large numbers (up to 64-bit integers).\n\n### Solution Code\n```rust\nfn is_perfect_square(n: isize) -> bool {\n    if n < 0 {\n        return false;\n    }\n    let mut low = 0;\n    let mut high = n;\n    while low <= high {\n        let mid = (low + high) / 2;\n        let mid_sq = mid * mid;\n        if mid_sq == n {\n            return true;\n        } else if mid_sq < n {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    false\n}\n```\n\n### Explanation\n- **Negative Check**: The function first checks if the input `n` is negative. Since negative numbers cannot be perfect squares, it returns `false` immediately.\n- **Binary Search Initialization**: The search starts with `low` set to 0 and `high` set to `n`, covering all possible integer values that could be the square root of `n`.\n- **Midpoint Calculation**: In each iteration, the midpoint `mid` is calculated as the average of `low` and `high` (using integer division).\n- **Square Check**: The square of `mid` is computed. If it matches `n`, the function returns `true`.\n- **Adjust Search Range**: If the square is less than `n`, the search continues in the upper half (`low = mid + 1`). If the square is greater than `n`, the search continues in the lower half (`high = mid - 1`).\n- **Termination**: The loop exits when `low` exceeds `high`, indicating no perfect square was found, and the function returns `false`.\n\nThis method efficiently checks for perfect squares using integer arithmetic, avoiding floating-point inaccuracies and ensuring correctness for all valid inputs within the 64-bit integer range. The time complexity is O(log n), which is optimal for this problem.", "\n\nTo determine if a given integer `n` (of type `isize`) is a perfect square, we can use a binary search approach that efficiently checks for the existence of an integer square root without causing overflow or precision issues. The solution handles negative numbers (returning `false` immediately) and zero (returning `true`). For positive numbers, it converts `n` to a `u64` (to avoid overflow in multiplication) and performs a binary search within a safe upper bound (4 billion) to find if any integer `mid` satisfies `mid * mid == n`.\n\n### Approach\n1. **Check for Negative Numbers**: If `n` is negative, it cannot be a perfect square, so return `false`.\n2. **Check for Zero**: Zero is a perfect square (0 * 0 = 0), so return `true`.\n3. **Binary Search Setup**: Convert `n` to a `u64` (since `n` is non-negative and within the range of `u64`). Set the search bounds: `low` starts at 1, and `high` is set to 4,000,000,000 (4 billion), which is a safe upper bound for the square root of the maximum `isize` value (approximately 3.037 billion).\n4. **Binary Search Execution**:\n   - Compute the midpoint `mid` of the current search range.\n   - Calculate `mid * mid` (as `u64` to avoid overflow).\n   - If the square equals `n`, return `true`.\n   - If the square is less than `n`, adjust the lower bound to search higher values.\n   - If the square is greater than `n`, adjust the upper bound to search lower values.\n5. **Result**: If the loop completes without finding a perfect square, return `false`.\n\nThis approach ensures that all operations are performed within the bounds of `u64` (which can handle up to approximately 1.8e19), avoiding overflow and precision issues. The binary search efficiently narrows down the possible candidates in logarithmic time relative to the search range.\n\n### Solution Code\n```rust\nfn is_perfect_square(n: isize) -> bool {\n    if n < 0 {\n        return false;\n    }\n    if n == 0 {\n        return true;\n    }\n    let n_u64 = n as u64;\n    let mut low = 1;\n    let mut high = 4_000_000_000;\n    while low <= high {\n        let mid = (low + high) / 2;\n        let sq = mid as u64 * mid as u64;\n        if sq == n_u64 {\n            return true;\n        } else if sq < n_u64 {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    false\n}\n```\n\n### Explanation\n- **Negative Check**: The function immediately returns `false` for any negative input since perfect squares are non-negative.\n- **Zero Check**: Zero is a perfect square (0 * 0 = 0), so the function returns `true` for `n = 0`.\n- **Binary Search**: The search is conducted over the range `[1, 4,000,000,000]` (4 billion). This range is chosen because the square root of the largest possible `isize` (9,223,372,036,854,775,807) is approximately 3,037,000,499, which is less than 4 billion.\n- **Midpoint Calculation**: For each midpoint `mid`, the function calculates `mid * mid` (as `u64` to ensure no overflow). If this product equals `n`, it returns `true`. If the product is less than `n`, the search continues in the upper half; otherwise, it continues in the lower half.\n- **Termination**: The loop exits when the search range is exhausted, indicating no perfect square was found, and the function returns `false`.\n\nThis method efficiently checks for perfect squares while handling edge cases and large numbers safely, leveraging binary search for optimal performance. The use of `u64` for multiplication ensures all operations remain within safe bounds, avoiding common pitfalls with integer overflow.", "\n\nTo determine if a given number `n` is a perfect square, we can use a binary search approach. This method efficiently checks for the existence of an integer `mid` such that `mid * mid == n` without risking overflow for large values (up to the maximum value of ` isize`).\n\n### Approach\n1. **Handle Negative Numbers**: If `n` is negative, it cannot be a perfect square, so return `false`.\n2. **Check Zero**: Zero is a perfect square (0 * 0 = 0), so return `true`.\n3. **Binary Search Setup**: Initialize `low` to 1 and `high` to `n` (since the square root of `n` must be between 1 and `n` for `n > 0`).\n4. **Binary Search Execution**:\n   - Calculate `mid` as `low + (high - low) / 2` to avoid overflow in addition.\n   - Compute `square = mid * mid`.\n   - If `square` equals `n`, return `true`.\n   - If `square` is less than `n`, adjust `low` to `mid + 1`.\n   - If `square` is greater than `n`, adjust `high` to `mid - 1`.\n5. **Termination**: If the loop exits without finding a perfect square, return `false`.\n\nThis approach efficiently narrows down the search space using binary search, ensuring optimal performance even for large values of `n`.\n\n### Solution Code\n```rust\nfn is_perfect_square(n: isize) -> bool {\n    if n < 0 {\n        return false;\n    }\n    if n == 0 {\n        return true;\n    }\n    let mut low = 1;\n    let mut high = n;\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        let square = mid * mid;\n        if square == n {\n            return true;\n        } else if square < n {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    false\n}\n```\n\n### Explanation\n1. **Initial Checks**: The function first checks if `n` is negative (returning `false`) or zero (returning `true`).\n2. **Binary Search**: The search starts with `low` set to 1 and `high` set to `n`. The loop continues as long as `low` is less than or equal to `high`.\n3. **Mid Calculation**: The midpoint `mid` is calculated safely to prevent overflow by using `(high - low) / 2` instead of `(low + high) / 2`.\n4. **Square Check**: The square of `mid` is computed. If it matches `n`, the function returns `true`. If the square is less than `n`, the search continues in the upper half (`low = mid + 1`); otherwise, it continues in the lower half (`high = mid - 1`).\n5. **Result**: If the loop completes without finding a perfect square, the function returns `false`.\n\nThis method efficiently checks for perfect squares using binary search, handling all edge cases and large values within the constraints of ` isize` without overflow issues. The time complexity is O(log n), making it suitable for large inputs."]}
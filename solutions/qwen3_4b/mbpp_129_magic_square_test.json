{"name": "mbpp_129_magic_square_test", "language": "rs", "prompt": "/// Write a function to calculate whether the matrix is a magic square.\nfn magic_square_test(my_matrix: Vec<Vec<isize>>) -> bool {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_129_magic_square_test.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = magic_square_test;\n    assert_eq!(candidate(vec![vec![7, 12, 1, 14], vec![2, 13, 8, 11], vec![16, 3, 10, 5], vec![9, 6, 15, 4]]), true);\n    assert_eq!(candidate(vec![vec![2, 7, 6], vec![9, 5, 1], vec![4, 3, 8]]), true);\n    assert_eq!(candidate(vec![vec![2, 7, 6], vec![9, 5, 1], vec![4, 3, 7]]), false);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo determine if a given matrix is a magic square, we need to verify that it meets the following conditions:\n1. The matrix is square (i.e., the number of rows equals the number of columns).\n2. All rows have the same sum (the target sum).\n3. All columns have the same sum (the target sum).\n4. Both the main diagonal (top-left to bottom-right) and the anti-diagonal (top-right to bottom-left) have the same sum as the target.\n\nThe solution involves:\n1. Checking if the matrix is empty (returns `false`).\n2. Verifying all rows have the same length (ensuring the matrix is square).\n3. Calculating the target sum from the first row.\n4. Checking that every row sums to the target.\n5. Checking that every column sums to the target.\n6. Checking that both diagonals sum to the target.\n\nHere's the implementation:\n\n```rust\nfn magic_square_test(my_matrix: Vec<Vec<isize>>) -> bool {\n    let n = my_matrix.len();\n    if n == 0 {\n        return false;\n    }\n\n    for row in &my_matrix {\n        if row.len() != n {\n            return false;\n        }\n    }\n\n    let target = my_matrix[0].iter().sum();\n\n    for i in 0..n {\n        if my_matrix[i].iter().sum() != target {\n            return false;\n        }\n    }\n\n    for j in 0..n {\n        let mut col_sum = 0;\n        for i in 0..n {\n            col_sum += my_matrix[i][j];\n        }\n        if col_sum != target {\n            return false;\n        }\n    }\n\n    let diag1 = (0..n).fold(0, |acc, i| acc + my_matrix[i][i]);\n    let diag2 = (0..n).fold(0, |acc, i| acc + my_matrix[i][n - 1 - i]);\n\n    diag1 == target && diag2 == target\n}\n```\n\n**Explanation:**\n- **Square Check:** The code first checks if the matrix is empty (`n == 0`) and if all rows have the same length (`n`).\n- **Target Sum:** The target sum is derived from the sum of the first row.\n- **Row Check:** Each row's sum is compared against the target sum.\n- **Column Check:** For each column, the sum of elements is computed and compared against the target sum.\n- **Diagonal Check:** The sums of both the main diagonal (elements where row index equals column index) and the anti-diagonal (elements where column index is `n-1-i` for row index `i`) are checked against the target sum.\n\nThis implementation efficiently verifies all conditions required for a matrix to be a magic square, adhering to the problem's specifications without additional constraints on the elements (e.g., distinct positive integers). The solution handles matrices of any size (as long as they are square) and uses standard Rust idioms for clarity and correctness.", "\n\nTo determine if a given matrix is a magic square, we need to verify several conditions based on the standard definition of a magic square. A magic square is a square matrix where:\n1. All elements are distinct integers ranging from 1 to \\(n^2\\) (where \\(n\\) is the size of the matrix).\n2. The sum of the elements in each row, each column, and both main diagonals is the same (known as the magic constant).\n\n### Approach\n1. **Check Matrix Size**: Ensure the matrix is square (all rows have the same length \\(n\\)).\n2. **Check Distinctness and Range**: Verify all elements in the matrix are distinct and fall within the range [1, \\(n^2\\)].\n3. **Calculate Magic Constant**: Compute the target sum for each row, column, and diagonal using the formula \\( \\frac{n(n^2 + 1)}{2} \\).\n4. **Validate Rows**: Ensure the sum of each row equals the magic constant.\n5. **Validate Columns**: Ensure the sum of each column equals the magic constant.\n6. **Validate Diagonals**: Ensure the sums of both main diagonals equal the magic constant.\n\n### Solution Code\n```rust\nuse std::collections::HashSet;\n\nfn magic_square_test(my_matrix: Vec<Vec<isize>>) -> bool {\n    let n = my_matrix.len();\n    if n == 0 {\n        return false;\n    }\n\n    for row in &my_matrix {\n        if row.len() != n {\n            return false;\n        }\n    }\n\n    let total = n * n;\n    let mut nums = Vec::with_capacity(total);\n    for row in &my_matrix {\n        for num in row {\n            nums.push(*num);\n        }\n    }\n\n    let mut set = HashSet::new();\n    for num in &nums {\n        set.insert(*num);\n    }\n    if set.len() != total {\n        return false;\n    }\n\n    let min_val = *nums.iter().min().unwrap();\n    let max_val = *nums.iter().max().unwrap();\n    if min_val != 1 || max_val != (n as isize) * (n as isize) {\n        return false;\n    }\n\n    let target = (n as isize) * (n as isize * n as isize + 1) / 2;\n\n    for row in &my_matrix {\n        if row.iter().sum::<isize>() != target {\n            return false;\n        }\n    }\n\n    for j in 0..n {\n        let mut col_sum = 0;\n        for i in 0..n {\n            col_sum += my_matrix[i][j];\n        }\n        if col_sum != target {\n            return false;\n        }\n    }\n\n    let diag1 = my_matrix[0][0];\n    for i in 1..n {\n        diag1 += my_matrix[i][i];\n    }\n\n    let diag2 = my_matrix[0][n-1];\n    for i in 1..n {\n        diag2 += my_matrix[i][n-1 - i];\n    }\n\n    diag1 == target && diag2 == target\n}\n```\n\n### Explanation\n1. **Matrix Size Check**: The function first checks if the matrix is empty or if all rows have the same length \\(n\\).\n2. **Distinctness and Range Check**: The function collects all elements into a vector and checks for distinctness using a `HashSet`. It also verifies that the smallest element is 1 and the largest is \\(n^2\\).\n3. **Magic Constant Calculation**: The target sum for each row, column, and diagonal is calculated as \\( \\frac{n(n^2 + 1)}{2} \\).\n4. **Row Validation**: Each row's sum is compared to the target sum.\n5. **Column Validation**: Each column's sum is computed and compared to the target sum.\n6. **Diagonal Validation**: The sums of both main diagonals are computed and compared to the target sum.\n\nIf all checks pass, the function returns `true`; otherwise, it returns `false`. This approach ensures the matrix meets all criteria of a standard magic square as defined in mathematics.", "\n\nTo determine if a given matrix is a magic square, we need to verify that the matrix is square (i.e., the number of rows equals the number of columns) and that the sums of all rows, columns, and both main diagonals are equal. The solution follows these steps:\n\n1. **Check for an empty matrix**: If the matrix is empty, it cannot be a magic square.\n2. **Verify the matrix is square**: The number of rows must equal the number of columns.\n3. **Compute the target sum**: The sum of the first row is used as the target sum for all rows, columns, and diagonals.\n4. **Check all rows**: Each row's sum must equal the target sum.\n5. **Check all columns**: Each column's sum must equal the target sum.\n6. **Check both diagonals**: The sum of the main diagonal (top-left to bottom-right) and the anti-diagonal (top-right to bottom-left) must both equal the target sum.\n\nHere is the implementation:\n\n```rust\nfn magic_square_test(my_matrix: Vec<Vec<isize>>) -> bool {\n    if my_matrix.is_empty() {\n        return false;\n    }\n\n    let n = my_matrix[0].len();\n    if my_matrix.len() != n {\n        return false;\n    }\n\n    let target = my_matrix[0].iter().sum();\n\n    for i in 0..n {\n        if my_matrix[i].iter().sum() != target {\n            return false;\n        }\n    }\n\n    for j in 0..n {\n        let mut col_sum = 0;\n        for i in 0..n {\n            col_sum += my_matrix[i][j];\n        }\n        if col_sum != target {\n            return false;\n        }\n    }\n\n    let diag1 = my_matrix.iter().enumerate().map(|(i, row)| row[i]).sum();\n    let diag2 = my_matrix.iter().enumerate().map(|(i, row)| row[n - 1 - i]).sum();\n\n    diag1 == target && diag2 == target\n}\n```\n\n**Explanation**:\n- **Empty Matrix Check**: The function first checks if the matrix is empty, returning `false` immediately.\n- **Square Matrix Check**: It verifies that the matrix has the same number of rows and columns. If not, it returns `false`.\n- **Target Sum Calculation**: The sum of the first row is taken as the target sum.\n- **Row Check**: Each row's sum is computed and compared to the target sum. If any row fails, the function returns `false`.\n- **Column Check**: For each column, the sum of elements is computed and compared to the target sum. If any column fails, the function returns `false`.\n- **Diagonal Checks**: The sums of both diagonals are computed. If either diagonal sum does not match the target, the function returns `false`. Otherwise, it returns `true`.\n\nThis solution efficiently checks all necessary conditions for a matrix to be a magic square based on the standard definition (sums of rows, columns, and diagonals are equal), without requiring distinct or positive integers, as the problem does not specify these constraints. The time complexity is O(n\u00b2) where n is the size of the matrix, which is optimal for this problem."]}
{"name": "HumanEval_61_correct_bracketing", "language": "rs", "prompt": "/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"(\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n/// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\")(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_61_correct_bracketing.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo determine if a string of parentheses is correctly balanced, we can use a **counter-based approach**. This method efficiently checks for balanced brackets by tracking the number of open brackets that haven't been closed yet.\n\n---\n\n### \u2705 Why This Works\n\n- **For each '('**, we increment a counter (indicating an open bracket).\n- **For each ')'**, we decrement the counter (indicating a closing bracket).\n- If at any point the counter becomes **negative**, it means there's a closing bracket without a matching open bracket \u2192 return `false`.\n- After processing all characters, if the counter is **zero**, all brackets are properly matched \u2192 return `true`.\n\nThis approach ensures:\n- **O(n)** time complexity (where `n` is the length of the string)\n- **O(1)** space complexity (only a single integer is used)\n\n---\n\n### \ud83e\udde0 Implementation in Rust\n\nHere's the concise and efficient implementation:\n\n```rust\nfn correct_bracketing(brackets: String) -> bool {\n    let mut count = 0;\n    for c in brackets.chars() {\n        if c == '(' {\n            count += 1;\n        } else {\n            count -= 1;\n            if count < 0 {\n                return false;\n            }\n        }\n    }\n    count == 0\n}\n```\n\n---\n\n### \ud83d\udd0d Examples\n\n| Input              | Output | Explanation |\n|---------------------|--------|---------------|\n| `\"(\"`               | `false` | One unmatched open bracket |\n| `\"()\"`              | `true`  | Balanced |\n| `\"(()())\"`          | `true`  | Fully balanced |\n| `\")(()\"`            | `false` | First character is `)` \u2192 invalid |\n\n---\n\n### \u2705 Final Answer\n\n```rust\nfn correct_bracketing(brackets: String) -> bool {\n    let mut count = 0;\n    for c in brackets.chars() {\n        if c == '(' {\n            count += 1;\n        } else {\n            count -= 1;\n            if count < 0 {\n                return false;\n            }\n        }\n    }\n    count == 0\n}\n```", "\n\nTo solve this problem, we need to determine if every opening bracket `(` in a given string has a corresponding closing bracket `)`. The solution involves checking that the brackets are properly nested and balanced.\n\n### Approach\n1. **Problem Analysis**: The problem requires verifying that for every opening bracket `(`, there is a matching closing bracket `)` in the correct order. The string consists only of `(` and `)` characters.\n2. **Intuition**: We can use a counter to track the balance of brackets. As we iterate through each character in the string:\n   - For every `(` encountered, we increment the counter.\n   - For every `)` encountered, we decrement the counter. If at any point the counter becomes negative, it means there's a closing bracket without a matching opening bracket, so we immediately return `false`.\n3. **Algorithm Selection**: The counter-based approach efficiently checks for balanced brackets in linear time, O(n), where n is the length of the string. This approach is optimal as it processes each character exactly once.\n4. **Edge Cases**: \n   - An empty string is considered balanced (returns `true`).\n   - A string starting with `)` (e.g., `\")\"`) is unbalanced (returns `false`).\n   - A string with unmatched opening brackets (e.g., `\"(\"` or `\"(()\"`) returns `false`.\n\n### Solution Code\n```rust\nfn correct_bracketing(brackets: String) -> bool {\n    let mut count = 0;\n    for c in brackets.chars() {\n        if c == '(' {\n            count += 1;\n        } else if c == ')' {\n            count -= 1;\n            if count < 0 {\n                return false;\n            }\n        }\n    }\n    count == 0\n}\n```\n\n### Explanation\n1. **Initialization**: We start with a counter set to `0`.\n2. **Iteration**: For each character in the input string:\n   - If the character is `(`, we increment the counter.\n   - If the character is `)`, we decrement the counter. If the counter becomes negative at any point, it indicates an extra closing bracket without a matching opening bracket, so we return `false` immediately.\n3. **Final Check**: After processing all characters, if the counter is `0`, all opening brackets have corresponding closing brackets in the correct order, so we return `true`. Otherwise, we return `false`.\n\nThis approach efficiently checks for balanced brackets by maintaining a running count of unmatched opening brackets, ensuring optimal performance with minimal computational overhead. The solution handles all edge cases, including empty strings and strings with incorrect bracket sequences.", "\n\nTo determine if a string of parentheses is correctly bracketed, we can use a **balance counter** approach. This method efficiently checks for valid bracketing by tracking the difference between opening and closing brackets as we iterate through the string.\n\n---\n\n### \u2705 Approach\n\n1. **Initialize a balance counter** to 0.\n2. **Iterate through each character** in the input string:\n   - For every `'('`, increment the balance by 1.\n   - For every `')'`, decrement the balance by 1.\n   - If at any point the balance becomes **negative**, return `false` immediately (this indicates an extra closing bracket without a matching opening one).\n3. After processing all characters, if the **final balance is 0**, return `true`; otherwise, return `false`.\n\nThis approach ensures that:\n- We never have more closing brackets than opening ones at any point.\n- All opening brackets eventually get closed.\n\n---\n\n### \ud83e\udde0 Why This Works\n\nThe balance counter effectively simulates the stack behavior:\n- A positive balance means we have more opening brackets than closing ones.\n- A negative balance means we have more closing brackets than opening ones (invalid).\n- A zero balance at the end means all brackets are properly matched.\n\nSince the problem guarantees that the input consists **only** of `'('` and `')'`, we don\u2019t need to handle invalid characters.\n\n---\n\n### \ud83d\udca1 Code Implementation\n\n```rust\nfn correct_bracketing(brackets: String) -> bool {\n    let mut balance = 0;\n    for c in brackets.chars() {\n        if c == '(' {\n            balance += 1;\n        } else {\n            balance -= 1;\n        }\n        if balance < 0 {\n            return false;\n        }\n    }\n    balance == 0\n}\n```\n\n---\n\n### \u2705 Examples\n\n| Input         | Output |\n|----------------|--------|\n| `\"(\"`          | `false` |\n| `\"()``         | `true`  |\n| `\"(()())\"`     | `true`  |\n| `\")(()\"`       | `false` |\n\nAll match the expected behavior.\n\n---\n\n### \ud83d\udccc Final Answer\n\n```rust\nfn correct_bracketing(brackets: String) -> bool {\n    let mut balance = 0;\n    for c in brackets.chars() {\n        if c == '(' {\n            balance += 1;\n        } else {\n            balance -= 1;\n        }\n        if balance < 0 {\n            return false;\n        }\n    }\n    balance == 0\n}\n```"]}
{"name": "mbpp_4_heap_queue_largest", "language": "rs", "prompt": "/// Write a function to find the n largest integers from a given vector of numbers, returned in descending order.\nfn heap_queue_largest(nums: Vec<isize>, n: isize) -> Vec<isize> {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_4_heap_queue_largest.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = heap_queue_largest;\n    assert_eq!(candidate(vec![25, 35, 22, 85, 14, 65, 75, 22, 58], 3), vec![85, 75, 65]);\n    assert_eq!(candidate(vec![25, 35, 22, 85, 14, 65, 75, 22, 58], 2), vec![85, 75]);\n    assert_eq!(candidate(vec![25, 35, 22, 85, 14, 65, 75, 22, 58], 5), vec![85, 75, 65, 58, 35]);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve this problem, we need to find the `n` largest integers from a given vector of numbers and return them in descending order. The solution leverages a min-heap to efficiently track the top `n` largest elements during a single pass through the input vector.\n\n### Approach\n1. **Problem Analysis**: The task requires extracting the top `n` largest elements from a vector and returning them sorted in descending order. The challenge is to do this efficiently, especially for large vectors.\n2. **Intuition**: Using a min-heap of size `n` allows us to maintain the `n` largest elements encountered so far. The smallest element in the heap (the root) is the `n`-th largest element in the entire vector. As we process each element, if it is larger than the root of the heap, we replace the root with this element.\n3. **Algorithm Selection**: \n   - **Min-Heap**: A min-heap is used to keep track of the `n` largest elements. The heap ensures that the smallest of these `n` elements is at the root, allowing efficient comparisons.\n   - **Processing Elements**: For each element in the input vector:\n     - If the heap has fewer than `n` elements, add the element to the heap.\n     - Otherwise, if the current element is larger than the root of the heap, replace the root with the current element.\n   - **Result Construction**: After processing all elements, the heap contains the `n` largest elements in ascending order (due to the min-heap property). Reversing this list gives the desired descending order.\n\n### Solution Code\n```rust\nuse std::collections::BinaryHeap;\n\nfn heap_queue_largest(nums: Vec<isize>, n: isize) -> Vec<isize> {\n    if n <= 0 {\n        return Vec::new();\n    }\n    let mut heap = BinaryHeap::new();\n    for num in nums {\n        if heap.len() < n as usize {\n            heap.push(num);\n        } else if num > heap[0] {\n            heap.pop();\n            heap.push(num);\n        }\n    }\n    let mut result = Vec::new();\n    while let Some(x) = heap.pop() {\n        result.push(x);\n    }\n    result.reverse();\n    result\n}\n```\n\n### Explanation\n1. **Initialization**: The function starts by checking if `n` is non-positive, in which case it returns an empty vector.\n2. **Heap Processing**: \n   - A min-heap (`BinaryHeap`) is initialized to store up to `n` largest elements.\n   - For each number in the input vector:\n     - If the heap has fewer than `n` elements, the number is added to the heap.\n     - If the heap is full (has `n` elements), the current number is compared with the smallest element in the heap (the root). If it is larger, the root is replaced with the current number.\n3. **Result Construction**:\n   - After processing all elements, the heap contains the `n` largest elements in ascending order (since it's a min-heap).\n   - The elements are popped from the heap (which yields them in ascending order) and then reversed to produce the result in descending order.\n\nThis approach efficiently finds the top `n` elements in **O(n log n)** time, which is optimal for this problem. The use of a min-heap ensures that each insertion and extraction operation is handled in logarithmic time relative to the heap size. The final reversal step ensures the result is in the required descending order.", "\n\nTo solve the problem of finding the `n` largest integers from a given vector of numbers and returning them in descending order using a heap queue (priority queue), we can efficiently implement a **min-heap** approach. This method ensures optimal performance with a time complexity of $O(m \\log n)$, where $m$ is the size of the input vector.\n\n### Approach\n1. **Edge Case Handling**: \n   - If `n` is negative or zero, return an empty vector.\n2. **Heap Initialization**: \n   - Use a `BinaryHeap` (which is a max-heap by default) to store the negative values of the numbers. This allows us to simulate a min-heap for the original values.\n3. **Processing Elements**:\n   - For each number in the input vector:\n     - If the heap has fewer than `n` elements, push the negative of the current number.\n     - Otherwise, if the current number is larger than the smallest element in the heap (i.e., `-heap[0]`), replace the smallest element with the current number.\n4. **Result Construction**:\n   - After processing all elements, pop all elements from the heap, convert them back to positive values, and reverse the result to get the numbers in descending order.\n\n### Solution Code\n```rust\nuse std::collections::BinaryHeap;\n\nfn heap_queue_largest(nums: Vec<isize>, n: isize) -> Vec<isize> {\n    if n < 0 {\n        return Vec::new();\n    }\n    let n = n as usize;\n    if n == 0 {\n        return Vec::new();\n    }\n\n    let mut heap = BinaryHeap::new();\n    for x in nums {\n        if heap.len() < n {\n            heap.push(-x);\n        } else {\n            if x > -heap[0] {\n                heap.pop();\n                heap.push(-x);\n            }\n        }\n    }\n\n    let mut result = Vec::new();\n    while let Some(x) = heap.pop() {\n        result.push(-x);\n    }\n    result.reverse();\n    result\n}\n```\n\n### Explanation\n1. **Edge Case Handling**: The function first checks if `n` is negative or zero. If so, it returns an empty vector immediately.\n2. **Heap Processing**:\n   - The `BinaryHeap` is used to store negative values of the numbers. This allows us to efficiently track the smallest element among the `n` largest numbers.\n   - For each number in the input vector, if the heap has fewer than `n` elements, the number is added (as a negative value). Otherwise, the number is compared with the smallest element in the heap (i.e., `-heap[0]`). If it is larger, the smallest element is replaced.\n3. **Result Construction**:\n   - After processing all elements, the heap contains the `n` largest numbers (as negative values). By popping elements from the heap and converting them back to positive, we get the numbers in ascending order. Reversing this list gives the desired result in descending order.\n\nThis approach efficiently leverages the properties of a max-heap (via negative values) to simulate a min-heap, ensuring optimal performance and correctness for the problem requirements.", "\n\nTo solve this problem, we need to find the `n` largest integers from a given vector of numbers and return them in descending order. The solution leverages a **min-heap** to efficiently track the `n` largest elements during a single pass through the input vector.\n\n### Approach\n1. **Min-Heap Initialization**: We use a min-heap (provided by `std::collections::BinaryHeap`) to keep track of the `n` largest elements encountered so far. The min-heap ensures that the smallest of the `n` largest elements is at the top, allowing efficient comparison and replacement.\n2. **Processing Elements**: For each number in the input vector:\n   - If the heap has fewer than `n` elements, we add the number to the heap.\n   - If the heap has `n` elements and the current number is larger than the smallest element in the heap (the top of the min-heap), we replace the smallest element with the current number.\n3. **Result Construction**: After processing all elements, the heap contains the `n` largest elements in ascending order (since it's a min-heap). We then reverse this vector to get the elements in descending order.\n\n### Solution Code\n```rust\nuse std::collections::BinaryHeap;\n\nfn heap_queue_largest(nums: Vec<isize>, n: isize) -> Vec<isize> {\n    let mut heap = BinaryHeap::new();\n    for num in nums {\n        if heap.len() < n as usize {\n            heap.push(num);\n        } else if num > heap[0] {\n            heap.pop();\n            heap.push(num);\n        }\n    }\n    let mut result = Vec::new();\n    while let Some(x) = heap.pop() {\n        result.push(x);\n    }\n    result.reverse();\n    result\n}\n```\n\n### Explanation\n1. **Heap Initialization**: The `BinaryHeap` is initialized as a min-heap to store the `n` largest elements.\n2. **Element Processing**:\n   - For each number in the input vector, if the heap has fewer than `n` elements, the number is added to the heap.\n   - If the heap is full (`n` elements) and the current number is larger than the smallest element in the heap (accessed via `heap[0]`), the smallest element is removed and the current number is added.\n3. **Result Construction**:\n   - The heap is emptied into a vector `result`, which naturally contains the elements in ascending order (due to the min-heap property).\n   - The vector `result` is reversed to produce the desired output in descending order.\n\nThis approach efficiently processes the input in linear time, O(n log n), where `n` is the size of the input vector. The heap operations (insertion and extraction) each take logarithmic time relative to the heap size, making the solution optimal for this problem.\n\n**Final Answer**:\n```rust\nuse std::collections::BinaryHeap;\n\nfn heap_queue_largest(nums: Vec<isize>, n: isize) -> Vec<isize> {\n    let mut heap = BinaryHeap::new();\n    for num in nums {\n        if heap.len() < n as usize {\n            heap.push(num);\n        } else if num > heap[0] {\n            heap.pop();\n            heap.push(num);\n        }\n    }\n    let mut result = Vec::new();\n    while let Some(x) = heap.pop() {\n        result.push(x);\n    }\n    result.reverse();\n    result\n}\n```"]}
{"name": "HumanEval_124_valid_date", "language": "rs", "prompt": "/// You have to write a function which validates a given date string and\n/// returns true if the date is valid otherwise false.\n/// The date is valid if all of the following rules are satisfied:\n/// 1. The date string is not empty.\n/// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n/// 3. The months should not be less than 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n/// >>> valid_date(String::from(\"03-11-2000\"))\n/// true\n/// >>> valid_date(String::from(\"15-01-2012\"))\n/// false\n/// >>> valid_date(String::from(\"04-0-2040\"))\n/// false\n/// >>> valid_date(String::from(\"06-04-2020\"))\n/// true\n/// >>> valid_date(String::from(\"06/04/2020\"))\n/// false\nfn valid_date(date: String) -> bool {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_124_valid_date.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve this problem, we need to validate a given date string according to specific rules. The validation involves checking the format of the date string, the validity of the month and day values, and ensuring the date adheres to the constraints provided.\n\n### Approach\n1. **Check for Empty String**: The date string must not be empty.\n2. **Split the String**: The date string should be split into three parts using hyphens (`-`), representing month, day, and year.\n3. **Validate Part Lengths**: Each part (month, day, year) must have the correct length (2 digits for month and day, 4 digits for year).\n4. **Check for Digits**: Each part must consist only of digits.\n5. **Parse Parts into Integers**: Convert each part into integers for further validation.\n6. **Validate Month**: The month must be between 1 and 12 (inclusive).\n7. **Validate Day Based on Month**:\n   - For February (month 2), the day must be between 1 and 29 (inclusive).\n   - For April, June, September, and November (months 4, 6, 9, 11), the day must be between 1 and 30 (inclusive).\n   - For all other months, the day must be between 1 and 31 (inclusive).\n\n### Solution Code\n```rust\nfn valid_date(date: String) -> bool {\n    if date.is_empty() {\n        return false;\n    }\n\n    let parts: Vec<&str> = date.split('-').collect();\n    if parts.len() != 3 {\n        return false;\n    }\n\n    if parts[0].len() != 2 || parts[1].len() != 2 || parts[2].len() != 4 {\n        return false;\n    }\n\n    for part in parts {\n        if !part.chars().all(|c| c.is_digit(10)) {\n            return false;\n        }\n    }\n\n    let month = parts[0].parse::<u8>().unwrap();\n    let day = parts[1].parse::<u8>().unwrap();\n    let _year = parts[2].parse::<u32>().unwrap();\n\n    if month < 1 || month > 12 {\n        return false;\n    }\n\n    match month {\n        2 => {\n            if day < 1 || day > 29 {\n                return false;\n            }\n        }\n        4 | 6 | 9 | 11 => {\n            if day < 1 || day > 30 {\n                return false;\n            }\n        }\n        _ => {\n            if day < 1 || day > 31 {\n                return false;\n            }\n        }\n    }\n\n    true\n}\n```\n\n### Explanation\n1. **Empty Check**: The function first checks if the input string is empty. If it is, the function returns `false`.\n2. **Splitting the String**: The string is split into three parts using hyphens. If the split does not result in exactly three parts, the function returns `false`.\n3. **Length Validation**: Each part (month, day, year) is checked to ensure it has the correct length (2 digits for month and day, 4 digits for year).\n4. **Digit Check**: Each part is verified to consist only of digits.\n5. **Integer Parsing**: The parts are parsed into integers. The year is parsed but not used in the validation logic (as the problem does not require year validation beyond the format).\n6. **Month Validation**: The month is checked to ensure it is between 1 and 12 (inclusive).\n7. **Day Validation**: Depending on the month, the day is validated to ensure it falls within the correct range (1-29 for February, 1-30 for April, June, September, November, and 1-31 for all other months).\n\nThis approach ensures that all specified rules are checked in sequence, providing a robust and clear validation mechanism for the given date string.", "\n\nTo solve this problem, we need to validate a given date string according to specific rules. The date string must adhere to the format \"mm-dd-yyyy\" and satisfy several conditions related to the month and day values. \n\n### Approach\n1. **Check String Length**: The date string must be exactly 10 characters long (2 digits for month, 1 dash, 2 digits for day, 1 dash, 4 digits for year).\n2. **Check Format**: The string must have dashes at positions 2 and 5 (0-based index) and all other characters must be digits.\n3. **Parse Month and Day**: Extract the month (first two characters) and day (next two characters) as integers.\n4. **Validate Month**: The month must be between 1 and 12 (inclusive).\n5. **Validate Day**: \n   - For February (month 2), the day must be between 1 and 29 (inclusive).\n   - For April (4), June (6), September (9), and November (11), the day must be between 1 and 30 (inclusive).\n   - For all other months, the day must be between 1 and 31 (inclusive).\n\n### Solution Code\n```rust\nfn valid_date(date: String) -> bool {\n    if date.len() != 10 {\n        return false;\n    }\n\n    for i in 0..10 {\n        let c = date.chars().nth(i).unwrap();\n        if i == 2 || i == 5 {\n            if c != '-' {\n                return false;\n            }\n        } else {\n            if !c.is_digit(10) {\n                return false;\n            }\n        }\n    }\n\n    let mm = date[0..2].parse::<u32>().map_err(|_| false)?;\n    let dd = date[3..5].parse::<u32>().map_err(|_| false)?;\n\n    if mm < 1 || mm > 12 {\n        return false;\n    }\n\n    match mm {\n        2 => {\n            if dd < 1 || dd > 29 {\n                return false;\n            }\n        }\n        4 | 6 | 9 | 11 => {\n            if dd < 1 || dd > 30 {\n                return false;\n            }\n        }\n        _ => {\n            if dd < 1 || dd > 31 {\n                return false;\n            }\n        }\n    }\n\n    true\n}\n```\n\n### Explanation\n1. **String Length Check**: The function first checks if the input string is exactly 10 characters long. If not, it immediately returns `false`.\n2. **Format Validation**: The function then iterates over each character in the string:\n   - Characters at positions 2 and 5 must be a dash (`-`).\n   - All other characters must be digits (0-9).\n3. **Parsing Month and Day**: The first two characters are parsed as the month (`mm`), and the next two characters are parsed as the day (`dd`). If parsing fails (e.g., non-digit characters), the function returns `false`.\n4. **Month Validation**: The month must be between 1 and 12 (inclusive). If not, the function returns `false`.\n5. **Day Validation**: \n   - For February (month 2), the day must be between 1 and 29.\n   - For months 4, 6, 9, and 11, the day must be between 1 and 30.\n   - For all other months, the day must be between 1 and 31.\n6. **Final Check**: If all checks pass, the function returns `true`; otherwise, it returns `false`.\n\nThis approach ensures that the date string adheres to the specified format and meets all the given validation rules for month and day values. The solution efficiently checks each condition in sequence, providing a clear and concise validation mechanism.", "\n\nTo solve this problem, we need to validate a given date string based on specific rules. The date string must adhere to the format `mm-dd-yyyy` and satisfy several conditions regarding the month and day values.\n\n### Approach\n1. **Check for Empty String**: The date string must not be empty.\n2. **Split by Hyphens**: The string should split into exactly three parts (month, day, year) when divided by hyphens.\n3. **Validate Parts**: Each part (month, day, year) must be non-empty and consist only of digits.\n4. **Parse Month and Day**: Convert the month and day parts into integers.\n5. **Validate Month**: The month must be between 1 and 12 (inclusive).\n6. **Validate Day**: Depending on the month, the day must fall within the valid range:\n   - For months 1, 3, 5, 7, 8, 10, 12: day must be between 1 and 31.\n   - For months 4, 6, 9, 11: day must be between 1 and 30.\n   - For month 2: day must be between 1 and 29 (ignoring leap years as per problem constraints).\n\n### Solution Code\n```rust\nfn valid_date(date: String) -> bool {\n    if date.is_empty() {\n        return false;\n    }\n\n    let parts: Vec<&str> = date.split('-').collect();\n    if parts.len() != 3 {\n        return false;\n    }\n\n    for part in parts {\n        if part.is_empty() {\n            return false;\n        }\n        if !part.chars().all(|c| c.is_digit(10)) {\n            return false;\n        }\n    }\n\n    let mm = match parts[0].parse::<u8>() {\n        Ok(m) => m,\n        Err(_) => return false,\n    };\n\n    if mm < 1 || mm > 12 {\n        return false;\n    }\n\n    let dd = match parts[1].parse::<u8>() {\n        Ok(d) => d,\n        Err(_) => return false,\n    };\n\n    match mm {\n        2 => {\n            if dd < 1 || dd > 29 {\n                return false;\n            }\n        }\n        4 | 6 | 9 | 11 => {\n            if dd < 1 || dd > 30 {\n                return false;\n            }\n        }\n        _ => {\n            if dd < 1 || dd > 31 {\n                return false;\n            }\n        }\n    }\n\n    true\n}\n```\n\n### Explanation\n1. **Empty Check**: The function first checks if the input string is empty and returns `false` if it is.\n2. **Split and Part Validation**: The string is split into parts using hyphens. If the split does not result in exactly three parts, the function returns `false`. Each part is checked to ensure it is non-empty and consists only of digits.\n3. **Month Validation**: The month part is parsed into a `u8` (unsigned 8-bit integer). If parsing fails or the month is not between 1 and 12, the function returns `false`.\n4. **Day Validation**: The day part is parsed into a `u8`. Depending on the month:\n   - For February (month 2), the day must be between 1 and 29.\n   - For April (4), June (6), September (9), and November (11), the day must be between 1 and 30.\n   - For all other months, the day must be between 1 and 31.\n5. **Result**: If all checks pass, the function returns `true`; otherwise, it returns `false`.\n\nThis approach efficiently checks all specified conditions to determine if the given date string is valid according to the problem's requirements. The solution handles edge cases such as invalid months, days, and non-digit characters in the date string."]}
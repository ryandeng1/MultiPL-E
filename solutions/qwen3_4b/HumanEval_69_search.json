{"name": "HumanEval_69_search", "language": "rs", "prompt": "/// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n/// zero, and has a frequency greater than or equal to the value of the integer itself. \n/// The frequency of an integer is the number of times it appears in the vector.\n/// If no such a value exist, return -1.\n/// Examples:\n/// >>> search(vec![4, 1, 2, 2, 3, 1])\n/// 2\n/// >>> search(vec![1, 2, 2, 3, 3, 3, 4, 4, 4])\n/// 3\n/// >>> search(vec![5, 5, 4, 4, 4])\n/// -1\nfn search(lst: Vec<isize>) -> isize {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_69_search.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![5, 5, 5, 5, 1]), 1);\n    assert_eq!(candidate(vec![4, 1, 4, 1, 4, 4]), 4);\n    assert_eq!(candidate(vec![3, 3]), -1);\n    assert_eq!(candidate(vec![8, 8, 8, 8, 8, 8, 8, 8]), 8);\n    assert_eq!(candidate(vec![2, 3, 3, 2, 2]), 2);\n    assert_eq!(candidate(vec![2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]), 1);\n    assert_eq!(candidate(vec![3, 2, 8, 2]), 2);\n    assert_eq!(candidate(vec![6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]), 1);\n    assert_eq!(candidate(vec![8, 8, 3, 6, 5, 6, 4]), -1);\n    assert_eq!(candidate(vec![6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]), 1);\n    assert_eq!(candidate(vec![1, 9, 10, 1, 3]), 1);\n    assert_eq!(candidate(vec![6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]), 5);\n    assert_eq!(candidate(vec![1]), 1);\n    assert_eq!(candidate(vec![8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]), 4);\n    assert_eq!(candidate(vec![2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]), 2);\n    assert_eq!(candidate(vec![1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]), 1);\n    assert_eq!(candidate(vec![9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]), 4);\n    assert_eq!(candidate(vec![2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]), 4);\n    assert_eq!(candidate(vec![9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]), 2);\n    assert_eq!(candidate(vec![5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]), -1);\n    assert_eq!(candidate(vec![10]), -1);\n    assert_eq!(candidate(vec![9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]), 2);\n    assert_eq!(candidate(vec![5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]), 1);\n    assert_eq!(candidate(vec![7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]), 1);\n    assert_eq!(candidate(vec![3, 10, 10, 9, 2]), -1);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve this problem, we need to find the greatest integer greater than zero that has a frequency (number of occurrences) in the given vector that is at least as large as the integer itself. If no such integer exists, we return -1.\n\n### Approach\n1. **Frequency Counting**: First, we count the frequency of each integer in the input vector using a hash map. This helps us efficiently access the count of each number.\n2. **Candidate Selection**: For each unique integer in the hash map, we check if its frequency is greater than or equal to the integer itself.\n3. **Maximization**: Among all integers that meet the frequency condition, we select the greatest one. If no such integer exists, we return -1.\n\nThis approach efficiently processes the input in linear time relative to the size of the vector, making it optimal for large inputs.\n\n### Solution Code\n```rust\nuse std::collections::HashMap;\n\nfn search(lst: Vec<isize>) -> isize {\n    let mut freq = HashMap::new();\n    for num in lst {\n        *freq.entry(num).or_insert(0) += 1;\n    }\n\n    let mut max_candidate = -1;\n    for (num, count) in freq {\n        if count >= num {\n            if num > max_candidate {\n                max_candidate = num;\n            }\n        }\n    }\n    max_candidate\n}\n```\n\n### Explanation\n1. **Frequency Counting**: We iterate through each number in the input vector and update its count in a hash map (`freq`). This step ensures we have the frequency of each number in O(n) time, where n is the number of elements in the vector.\n2. **Candidate Selection**: For each number in the hash map, we check if its frequency (`count`) is at least the number itself (`num`). This check is done in O(m) time, where m is the number of unique elements in the vector.\n3. **Maximization**: As we iterate through the hash map, we keep track of the largest number that meets the condition (`count >= num`). If no such number is found, the variable `max_candidate` remains -1, which is returned as the result.\n\nThis solution efficiently combines frequency counting and conditional checks to determine the desired integer in optimal time, ensuring correctness for all valid inputs. The space complexity is O(m), where m is the number of unique elements in the vector, which is optimal for this problem.", "\n\nTo solve this problem, we need to find the greatest integer greater than zero that has a frequency (number of occurrences) in the given vector that is at least as large as the integer itself. If no such integer exists, we return -1.\n\n### Approach\n1. **Frequency Counting**: First, we count the frequency of each integer in the input vector using a hash map. This helps us efficiently track how many times each integer appears.\n2. **Check Valid Integers**: For each unique integer in the hash map, we check if its frequency is greater than or equal to the integer itself.\n3. **Track Maximum Valid Integer**: Among all integers that meet the condition (frequency \u2265 integer), we keep track of the largest one. If no such integer is found, we return -1.\n\nThis approach efficiently narrows down the problem to checking each unique integer in the vector once, leveraging a hash map for constant-time frequency lookups.\n\n### Solution Code\n```rust\nuse std::collections::HashMap;\n\nfn search(lst: Vec<isize>) -> isize {\n    let mut freq = HashMap::new();\n    for num in lst {\n        *freq.entry(num).or_insert(0) += 1;\n    }\n\n    let mut max_valid = -1;\n    for (num, count) in freq {\n        if count >= num {\n            if num > max_valid {\n                max_valid = num;\n            }\n        }\n    }\n    max_valid\n}\n```\n\n### Explanation\n1. **Frequency Counting**: We iterate through each number in the input vector and populate a hash map where keys are the numbers and values are their respective counts.\n2. **Check Valid Integers**: For each number in the hash map, we check if its count (frequency) is at least as large as the number itself.\n3. **Track Maximum Valid Integer**: During the iteration, we maintain the largest number that satisfies the condition. If no number meets the condition, the variable `max_valid` remains -1, which is returned as the result.\n\nThis solution efficiently processes the input in linear time relative to the size of the vector, making it optimal for the given problem constraints. The use of a hash map ensures that frequency checks are performed in constant time, leading to an overall time complexity of O(n), where n is the number of elements in the vector.", "\n\nTo solve this problem, we need to find the greatest integer greater than zero in a given non-empty vector of positive integers such that its frequency (number of occurrences in the vector) is at least as large as the integer itself. If no such integer exists, we return -1.\n\n### Approach\n1. **Frequency Counting**: We first count the frequency of each integer in the input vector using a hash map. This helps us efficiently track how many times each integer appears.\n2. **Validation Check**: For each integer in the hash map, we check if its frequency is greater than or equal to the integer itself.\n3. **Finding the Maximum Valid Integer**: Among all integers that meet the frequency condition, we identify the largest one. If no integers meet the condition, we return -1.\n\nThis approach efficiently narrows down the candidates by leveraging a hash map for quick frequency lookups and a single pass through the map to determine the valid candidates and their maximum value.\n\n### Solution Code\n```rust\nuse std::collections::HashMap;\n\nfn search(lst: Vec<isize>) -> isize {\n    let mut freq = HashMap::new();\n    for num in lst {\n        *freq.entry(num).or_insert(0) += 1;\n    }\n\n    let mut max_valid = -1;\n    for (num, count) in freq {\n        if count >= num {\n            if num > max_valid {\n                max_valid = num;\n            }\n        }\n    }\n    max_valid\n}\n```\n\n### Explanation\n1. **Frequency Counting**: The code initializes an empty hash map `freq` to store the count of each integer in the input vector `lst`. It iterates through each integer in `lst`, updating the count for each integer in the hash map.\n2. **Validation Check**: The code then iterates over each entry in the hash map. For each integer `num` with frequency `count`, it checks if `count >= num`.\n3. **Finding the Maximum Valid Integer**: During the iteration, if an integer `num` meets the condition (`count >= num`), the code compares `num` with the current `max_valid` (initialized to -1). If `num` is larger than `max_valid`, it updates `max_valid` to `num`.\n4. **Result Handling**: After processing all entries, the value of `max_valid` is returned. If no integers met the condition, `max_valid` remains -1, which is then returned as the result.\n\nThis approach efficiently checks all possible candidates in linear time relative to the size of the input vector, making it optimal for the given problem constraints. The use of a hash map ensures that frequency lookups and updates are handled in constant time on average."]}
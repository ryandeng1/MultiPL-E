{"name": "mbpp_80_tetrahedral_number", "language": "rs", "prompt": "/// Write a function to find the nth tetrahedral number.\nfn tetrahedral_number(n: isize) -> isize {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_80_tetrahedral_number.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = tetrahedral_number;\n    assert_eq!(candidate(5), 35);\n    assert_eq!(candidate(6), 56);\n    assert_eq!(candidate(7), 84);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo find the nth tetrahedral number, we can use the well-known mathematical formula derived from the sum of the first $ n $ triangular numbers. The formula for the $ n $-th tetrahedral number is:\n\n$$\nT_n = \\frac{n(n + 1)(n + 2)}{6}\n$$\n\nThis formula is exact because the product $ n(n + 1)(n + 2) $ is always divisible by 6 for any integer $ n $, ensuring that the division results in an integer.\n\n---\n\n### Implementation in Rust\n\nHere's the implementation of the function:\n\n```rust\nfn tetrahedral_number(n: isize) -> isize {\n    n * (n + 1) * (n + 2) / 6\n}\n```\n\nThis function computes the $ n $-th tetrahedral number directly using the closed-form formula. It handles all valid integer inputs (positive, zero, or negative) as per the formula, though in practice, tetrahedral numbers are defined for positive integers $ n \\geq 1 $.\n\n---\n\n### Why This Works\n\n- **Triangular Numbers**: Each triangular number $ T_k = \\frac{k(k + 1)}{2} $ represents the number of objects that can form a triangle with $ k $ rows.\n- **Tetrahedral Numbers**: These are the sum of the first $ n $ triangular numbers, which geometrically represent the number of objects that can form a tetrahedron with $ n $ layers.\n- **Closed Formula**: The sum of the first $ n $ triangular numbers simplifies to $ \\frac{n(n + 1)(n + 2)}{6} $, which is efficient and avoids unnecessary loops or recursion.\n\n---\n\n### Example Usage\n\n```rust\nprintln!(\"{}\", tetrahedral_number(1)); // Output: 1\nprintln!(\"{}\", tetrahedral_number(2)); // Output: 4\nprintln!(\"{}\", tetrahedral_number(3)); // Output: 10\nprintln!(\"{}\", tetrahedral_number(4)); // Output: 20\n```\n\nThese outputs match the known tetrahedral numbers.\n\n---\n\n### Final Answer\n\n```rust\nfn tetrahedral_number(n: isize) -> isize {\n    n * (n + 1) * (n + 2) / 6\n}\n```", "\n\nTo solve this problem, we need to compute the nth tetrahedral number. The tetrahedral numbers are a sequence of numbers that represent the number of objects that can form a tetrahedron. The nth tetrahedral number is given by the formula \\( T(n) = \\frac{n(n+1)(n+2)}{6} \\).\n\n### Approach\n1. **Problem Analysis**: The tetrahedral number for a given non-negative integer \\( n \\) is calculated using the formula \\( \\frac{n(n+1)(n+2)}{6} \\). The problem specifies that the function should handle `isize` inputs, which can be negative. However, tetrahedral numbers are defined for non-negative integers (where \\( n \\geq 0 \\)). For negative inputs, we return 0 as they are not part of the standard tetrahedral sequence.\n2. **Key Insight**: The formula \\( \\frac{n(n+1)(n+2)}{6} \\) is exact for non-negative integers because the product \\( n(n+1)(n+2) \\) is always divisible by 6. This is due to the properties of three consecutive integers (one is divisible by 2 and one by 3).\n3. **Handling Negative Inputs**: If the input \\( n \\) is negative, we return 0 since tetrahedral numbers are not defined for negative indices.\n4. **Overflow Consideration**: For very large values of \\( n \\) (close to the maximum `isize` value), the product \\( n(n+1)(n+2) \\) might overflow. However, given the problem context and typical test cases, we assume \\( n \\) is small enough to avoid overflow in the intended scenarios.\n\n### Solution Code\n```rust\nfn tetrahedral_number(n: isize) -> isize {\n    if n < 0 {\n        0\n    } else {\n        n * (n + 1) * (n + 2) / 6\n    }\n}\n```\n\n### Explanation\n1. **Input Check**: The function first checks if the input \\( n \\) is negative. If so, it returns 0 immediately, as tetrahedral numbers are only defined for non-negative integers.\n2. **Formula Application**: For non-negative \\( n \\), the function computes the tetrahedral number using the formula \\( \\frac{n(n+1)(n+2)}{6} \\). This is done by multiplying \\( n \\) with \\( (n+1) \\) and \\( (n+2) \\), then performing integer division by 6.\n3. **Correctness**: The formula ensures that the result is an integer because the product of three consecutive integers is always divisible by 6. For example:\n   - When \\( n = 1 \\), \\( 1 \\times 2 \\times 3 = 6 \\), and \\( 6 / 6 = 1 \\).\n   - When \\( n = 2 \\), \\( 2 \\times 3 \\times 4 = 24 \\), and \\( 24 / 6 = 4 \\).\n   - When \\( n = 0 \\), \\( 0 \\times 1 \\times 2 = 0 \\), and \\( 0 / 6 = 0 \\).\n\nThis approach efficiently computes the nth tetrahedral number while handling edge cases (negative inputs) appropriately. The solution is optimal for typical problem constraints and leverages the mathematical properties of tetrahedral numbers.", "\n\nTo solve this problem, we need to compute the nth tetrahedral number. The tetrahedral numbers are a sequence of numbers where each number is the sum of the first n triangular numbers. The formula for the nth tetrahedral number is derived as \\( \\frac{n(n+1)(n+2)}{6} \\). This formula efficiently calculates the tetrahedral number without iterating through each triangular number, making it optimal for large values of n.\n\n### Approach\n1. **Problem Analysis**: The tetrahedral number for a given n is the sum of the first n triangular numbers. The triangular number for k is \\( \\frac{k(k+1)}{2} \\). Summing these from k=1 to n gives the tetrahedral number. The closed-form formula for the nth tetrahedral number is \\( \\frac{n(n+1)(n+2)}{6} \\).\n2. **Key Insight**: The product \\( n(n+1)(n+2) \\) is always divisible by 6 for any integer n, ensuring that the division by 6 results in an exact integer.\n3. **Algorithm Selection**: Directly apply the formula \\( \\frac{n(n+1)(n+2)}{6} \\) using integer arithmetic. This avoids the need for loops or additional checks, providing an O(1) time complexity solution.\n4. **Edge Cases**: The formula naturally handles n=0 (returning 0) and non-negative n values. Negative n values are not part of the tetrahedral sequence definition, but the formula still computes a valid integer (though it may not correspond to a standard tetrahedral number). The problem assumes n is non-negative as per typical usage.\n\n### Solution Code\n```rust\nfn tetrahedral_number(n: isize) -> isize {\n    n * (n + 1) * (n + 2) / 6\n}\n```\n\n### Explanation\n- **Formula Application**: The function computes the nth tetrahedral number using the formula \\( \\frac{n(n+1)(n+2)}{6} \\). This is done by multiplying three consecutive integers (n, n+1, n+2) and then dividing the product by 6.\n- **Efficiency**: The solution runs in constant time O(1) since it involves only basic arithmetic operations (multiplication and division) regardless of the input size.\n- **Correctness**: For any non-negative integer n, the formula produces the correct tetrahedral number. For example:\n  - When n=1, the result is \\( \\frac{1 \\times 2 \\times 3}{6} = 1 \\).\n  - When n=2, the result is \\( \\frac{2 \\times 3 \\times 4}{6} = 4 \\).\n  - When n=3, the result is \\( \\frac{3 \\times 4 \\times 5}{6} = 10 \\).\n- **Handling Large Values**: The solution uses `isize` for both input and output, which is suitable for reasonably large n (within the bounds of `isize`'s range). The product \\( n(n+1)(n+2) \\) may overflow for extremely large n (e.g., n close to the maximum `isize`), but the problem context typically assumes n is within practical limits.\n\nThis approach efficiently computes the nth tetrahedral number using a direct mathematical formula, ensuring optimal performance and correctness for all valid non-negative inputs."]}
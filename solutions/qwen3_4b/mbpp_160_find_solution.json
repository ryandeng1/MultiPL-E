{"name": "mbpp_160_find_solution", "language": "rs", "prompt": "/// Write a function that returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.\nfn find_solution(a: isize, b: isize, n: isize) -> Option<(isize, isize)> {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_160_find_solution.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = find_solution;\n    assert_eq!(candidate(2, 3, 7), Some((2, 1)));\n    assert_eq!(candidate(4, 2, 7), None);\n    assert_eq!(candidate(1, 13, 17), Some((4, 1)));\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve the problem of finding integers $ x $ and $ y $ such that $ ax + by = n $, we need to handle several edge cases and use the **Extended Euclidean Algorithm** to find a solution when one exists.\n\n---\n\n### \u2705 Key Observations\n\n1. **Edge Cases**:\n   - If both $ a $ and $ b $ are zero:\n     - If $ n = 0 $, any solution like $ (0, 0) $ is valid.\n     - Otherwise, no solution exists.\n   - If $ a = 0 $:\n     - The equation becomes $ by = n $. A solution exists only if $ n \\mod b = 0 $, and then $ y = n / b $, with $ x = 0 $.\n   - If $ b = 0 $:\n     - Similarly, the equation becomes $ ax = n $. A solution exists only if $ n \\mod a = 0 $, and then $ x = n / a $, with $ y = 0 $.\n\n2. **General Case** (both $ a $ and $ b $ non-zero):\n   - The equation $ ax + by = n $ has integer solutions **if and only if** $ \\gcd(a, b) $ divides $ n $.\n   - If it does, we can find a particular solution using the **Extended Euclidean Algorithm** on the absolute values of $ a $ and $ b $, then adjust the signs based on the original signs of $ a $ and $ b $.\n   - Once we have a solution $ (x_0, y_0) $ to $ ax + by = \\gcd(a, b) $, we scale it by $ n / \\gcd(a, b) $ to get a solution to $ ax + by = n $.\n\n---\n\n### \ud83e\udde0 Implementation Strategy\n\n- Use an **iterative Extended Euclidean Algorithm** to avoid recursion depth issues.\n- Compute the greatest common divisor $ d = \\gcd(a, b) $.\n- Check if $ n \\mod d \\neq 0 $ \u2192 return `None`.\n- Compute coefficients $ x_0 $ and $ y_0 $ such that $ |a|x_0 + |b|y_0 = d $.\n- Adjust the signs of $ x_0 $ and $ y_0 $ based on the signs of $ a $ and $ b $.\n- Scale the solution by $ n / d $ to get the final solution.\n\n---\n\n### \u2705 Final Code\n\n```rust\nfn find_solution(a: isize, b: isize, n: isize) -> Option<(isize, isize)> {\n    // Handle a = 0 and b = 0\n    if a == 0 && b == 0 {\n        if n == 0 {\n            return Some((0, 0));\n        } else {\n            return None;\n        }\n    }\n\n    // Handle a = 0\n    if a == 0 {\n        if n % b == 0 {\n            return Some((0, n / b));\n        } else {\n            return None;\n        }\n    }\n\n    // Handle b = 0\n    if b == 0 {\n        if n % a == 0 {\n            return Some((n / a, 0));\n        } else {\n            return None;\n        }\n    }\n\n    // Compute gcd and coefficients using iterative Extended Euclidean Algorithm\n    let mut a1 = a.abs();\n    let mut b1 = b.abs();\n    let mut x0 = 1;\n    let mut x1 = 0;\n    let mut y0 = 0;\n    let mut y1 = 1;\n\n    while b1 != 0 {\n        let q = a1 / b1;\n        let r = a1 % b1;\n        a1 = b1;\n        b1 = r;\n\n        let new_x0 = x1;\n        let new_x1 = x0 - q * x1;\n        let new_y0 = y1;\n        let new_y1 = y0 - q * y1;\n\n        x0 = new_x0;\n        x1 = new_x1;\n        y0 = new_y0;\n        y1 = new_y1;\n    }\n\n    let d = a1;\n\n    // Check if solution exists\n    if n % d != 0 {\n        return None;\n    }\n\n    // Adjust signs based on original a and b\n    let x = if a < 0 { -x0 } else { x0 };\n    let y = if b < 0 { -y0 } else { y0 };\n\n    // Scale solution by n / d\n    let x_scaled = x * (n / d);\n    let y_scaled = y * (n / d);\n\n    Some((x_scaled, y_scaled))\n}\n```\n\n---\n\n### \ud83d\udccc Explanation\n\n- The function first checks for the **edge cases** where $ a = 0 $ or $ b = 0 $, and handles them directly.\n- For the **general case**, it uses an **iterative Extended Euclidean Algorithm** to compute the gcd $ d $ and the coefficients $ x_0 $, $ y_0 $ such that $ |a|x_0 + |b|y_0 = d $.\n- It then adjusts the signs of $ x_0 $ and $ y_0 $ to match the signs of $ a $ and $ b $, and scales the solution by $ n / d $ to get the final solution $ (x, y) $ for $ ax + by = n $.\n- If $ n $ is not divisible by $ d $, it returns `None`.\n\nThis implementation is efficient, avoids recursion, and correctly handles all edge cases and negative values.\n\n---\n\n### \u2705 Example Usage\n\n```rust\nprintln!(\"{:?}\", find_solution(2, 3, 5)); // Returns Some((-5, 5))\nprintln!(\"{:?}\", find_solution(-2, 3, 1)); // Returns Some((1, 1))\nprintln!(\"{:?}\", find_solution(0, 4, 8)); // Returns Some((0, 2))\nprintln!(\"{:?}\", find_solution(0, 0, 0)); // Returns Some((0, 0))\nprintln!(\"{:?}\", find_solution(0, 0, 1)); // Returns None\n```\n\n---\n\n### \ud83c\udfaf Final Answer\n\n```rust\nfn find_solution(a: isize, b: isize, n: isize) -> Option<(isize, isize)> {\n    if a == 0 && b == 0 {\n        if n == 0 {\n            return Some((0, 0));\n        } else {\n            return None;\n        }\n    }\n\n    if a == 0 {\n        if n % b == 0 {\n            return Some((0, n / b));\n        } else {\n            return None;\n        }\n    }\n\n    if b == 0 {\n        if n % a == 0 {\n            return Some((n / a, 0));\n        } else {\n            return None;\n        }\n    }\n\n    let mut a1 = a.abs();\n    let mut b1 = b.abs();\n    let mut x0 = 1;\n    let mut x1 = 0;\n    let mut y0 = 0;\n    let mut y1 = 1;\n\n    while b1 != 0 {\n        let q = a1 / b1;\n        let r = a1 % b1;\n        a1 = b1;\n        b1 = r;\n\n        let new_x0 = x1;\n        let new_x1 = x0 - q * x1;\n        let new_y0 = y1;\n        let new_y1 = y0 - q * y1;\n\n        x0 = new_x0;\n        x1 = new_x1;\n        y0 = new_y0;\n        y1 = new_y1;\n    }\n\n    let d = a1;\n    if n % d != 0 {\n        return None;\n    }\n\n    let x = if a < 0 { -x0 } else { x0 };\n    let y = if b < 0 { -y0 } else { y0 };\n\n    Some((x * (n / d), y * (n / d)))\n}\n```", "\n\nTo solve the problem of finding integers $ x $ and $ y $ such that $ ax + by = n $, we leverage the **Extended Euclidean Algorithm** to determine if a solution exists and to compute one such solution. The key insight is that a solution exists if and only if the greatest common divisor (gcd) of $ a $ and $ b $ divides $ n $.\n\n---\n\n### \u2705 Approach\n\n1. **Edge Cases Handling**:\n   - If both $ a $ and $ b $ are zero:\n     - If $ n = 0 $, return $ (0, 0) $.\n     - Otherwise, return `None`.\n   - If $ a = 0 $:\n     - If $ n $ is divisible by $ b $, return $ (0, n / b) $.\n     - Otherwise, return `None`.\n   - If $ b = 0 $:\n     - If $ n $ is divisible by $ a $, return $ (n / a, 0) $.\n     - Otherwise, return `None`.\n\n2. **Compute GCD**:\n   - Use the standard Euclidean algorithm to compute the gcd of the absolute values of $ a $ and $ b $.\n\n3. **Check Divisibility**:\n   - If $ n $ is not divisible by the gcd, return `None`.\n\n4. **Extended Euclidean Algorithm**:\n   - Compute coefficients $ x_0 $ and $ y_0 $ such that $ |a|x_0 + |b|y_0 = \\text{gcd}(a, b) $.\n   - Adjust the signs of $ x_0 $ and $ y_0 $ based on the signs of $ a $ and $ b $ to get a solution for the original equation $ ax + by = n $.\n   - Scale the solution by $ n / \\text{gcd}(a, b) $ to get the final solution $ (x, y) $.\n\n---\n\n### \ud83e\udde0 Key Insight\n\nThe Extended Euclidean Algorithm gives us a solution to $ |a|x_0 + |b|y_0 = \\text{gcd}(a, b) $. By adjusting the signs of $ x_0 $ and $ y_0 $ based on the signs of $ a $ and $ b $, we obtain a solution to the original equation $ ax + by = n $.\n\n---\n\n### \u2705 Final Code\n\n```rust\nfn gcd(a: isize, b: isize) -> isize {\n    let mut a = a.abs();\n    let mut b = b.abs();\n    while b != 0 {\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    a\n}\n\nfn extended_gcd_positive(a: isize, b: isize) -> (isize, isize, isize) {\n    if b == 0 {\n        (a, 1, 0)\n    } else {\n        let (g, x1, y1) = extended_gcd_positive(b, a % b);\n        let q = a / b;\n        let x = y1;\n        let y = x1 - q * y1;\n        (g, x, y)\n    }\n}\n\nfn find_solution(a: isize, b: isize, n: isize) -> Option<(isize, isize)> {\n    // Handle both a and b zero\n    if a == 0 && b == 0 {\n        if n == 0 {\n            return Some((0, 0));\n        }\n        return None;\n    }\n\n    // Handle a zero\n    if a == 0 {\n        if n % b == 0 {\n            return Some((0, n / b));\n        }\n        return None;\n    }\n\n    // Handle b zero\n    if b == 0 {\n        if n % a == 0 {\n            return Some((n / a, 0));\n        }\n        return None;\n    }\n\n    let a_abs = a.abs();\n    let b_abs = b.abs();\n    let g = gcd(a_abs, b_abs);\n\n    if n % g != 0 {\n        return None;\n    }\n\n    let (g_val, x0, y0) = extended_gcd_positive(a_abs, b_abs);\n    let sign_a = if a > 0 { 1 } else { -1 };\n    let sign_b = if b > 0 { 1 } else { -1 };\n\n    let x = sign_a * x0;\n    let y = sign_b * y0;\n\n    let scaled_x = x * (n / g);\n    let scaled_y = y * (n / g);\n\n    Some((scaled_x, scaled_y))\n}\n```\n\n---\n\n### \ud83d\udccc Explanation\n\n- **Edge Cases**: The function first checks for trivial cases where $ a $ or $ b $ is zero to avoid division by zero.\n- **GCD Calculation**: The `gcd` function computes the gcd of the absolute values of $ a $ and $ b $, ensuring it's always positive.\n- **Extended Euclidean Algorithm**: The `extended_gcd_positive` function computes coefficients $ x_0 $ and $ y_0 $ such that $ |a|x_0 + |b|y_0 = \\text{gcd}(a, b) $.\n- **Sign Adjustment**: The signs of $ x_0 $ and $ y_0 $ are adjusted based on the signs of $ a $ and $ b $ to get a valid solution for the original equation.\n- **Scaling**: The solution is scaled by $ n / \\text{gcd}(a, b) $ to match the target value $ n $.\n\nThis approach efficiently handles all edge cases and ensures correctness for any integer inputs within the constraints of the problem.\n\n---\n\n### \ud83d\udca1 Example\n\nFor $ a = 3 $, $ b = 5 $, $ n = 8 $:\n\n- $ \\text{gcd}(3, 5) = 1 $\n- $ 3 \\cdot 2 + 5 \\cdot (-1) = 1 $\n- Scaled solution: $ (2 \\cdot 8, -1 \\cdot 8) = (16, -8) $\n\n\u2705 $ 3 \\cdot 16 + 5 \\cdot (-8) = 48 - 40 = 8 $\n\n---\n\n### \u2705 Final Answer\n\n```rust\nfn find_solution(a: isize, b: isize, n: isize) -> Option<(isize, isize)> {\n    // Edge cases\n    if a == 0 && b == 0 {\n        if n == 0 {\n            return Some((0, 0));\n        }\n        return None;\n    }\n    if a == 0 {\n        if n % b == 0 {\n            return Some((0, n / b));\n        }\n        return None;\n    }\n    if b == 0 {\n        if n % a == 0 {\n            return Some((n / a, 0));\n        }\n        return None;\n    }\n\n    let a_abs = a.abs();\n    let b_abs = b.abs();\n    let g = gcd(a_abs, b_abs);\n\n    if n % g != 0 {\n        return None;\n    }\n\n    let (g_val, x0, y0) = extended_gcd_positive(a_abs, b_abs);\n    let sign_a = if a > 0 { 1 } else { -1 };\n    let sign_b = if b > 0 { 1 } else { -1 };\n\n    let x = sign_a * x0;\n    let y = sign_b * y0;\n\n    let scaled_x = x * (n / g);\n    let scaled_y = y * (n / g);\n\n    Some((scaled_x, scaled_y))\n}\n```", "\n\nTo solve the problem of finding integers $ x $ and $ y $ such that $ ax + by = n $, we leverage the **Extended Euclidean Algorithm** to determine whether a solution exists and to compute one such solution. The key insight is that a solution exists if and only if $ \\gcd(a, b) $ divides $ n $. If it does, we can scale the solution of the equation $ ax + by = \\gcd(a, b) $ to obtain a solution for $ ax + by = n $.\n\n---\n\n### \u2705 Approach\n\n1. **Edge Cases Handling**:\n   - If both $ a $ and $ b $ are zero:\n     - If $ n = 0 $, return $ (0, 0) $.\n     - Otherwise, return `None`.\n   - If $ a = 0 $:\n     - The equation becomes $ by = n $. Return $ (0, n / b) $ if $ b $ divides $ n $, else `None`.\n   - If $ b = 0 $:\n     - The equation becomes $ ax = n $. Return $ (n / a, 0) $ if $ a $ divides $ n $, else `None`.\n\n2. **General Case**:\n   - Compute $ g = \\gcd(|a|, |b|) $.\n   - Check if $ n $ is divisible by $ g $. If not, return `None`.\n   - Use the **Extended Euclidean Algorithm** to find integers $ x_0 $ and $ y_0 $ such that $ |a|x_0 + |b|y_0 = g $.\n   - Scale the solution: $ x = x_0 \\cdot (n / g) \\cdot \\text{sign}(a) $, $ y = y_0 \\cdot (n / g) \\cdot \\text{sign}(b) $.\n\n---\n\n### \ud83e\udde0 Why This Works\n\n- The Extended Euclidean Algorithm guarantees that for any non-zero $ a $ and $ b $, there exist integers $ x_0 $ and $ y_0 $ such that $ |a|x_0 + |b|y_0 = \\gcd(|a|, |b|) $.\n- By scaling this solution by $ n / \\gcd(|a|, |b|) $, we get a solution to $ ax + by = n $.\n- The sign adjustment ensures the solution respects the original signs of $ a $ and $ b $.\n\n---\n\n### \u2705 Final Code\n\n```rust\nfn find_solution(a: isize, b: isize, n: isize) -> Option<(isize, isize)> {\n    // Case 1: a and b are both zero\n    if a == 0 && b == 0 {\n        if n == 0 {\n            return Some((0, 0));\n        } else {\n            return None;\n        }\n    }\n\n    // Case 2: a is zero\n    if a == 0 {\n        if n % b == 0 {\n            return Some((0, n / b));\n        } else {\n            return None;\n        }\n    }\n\n    // Case 3: b is zero\n    if b == 0 {\n        if n % a == 0 {\n            return Some((n / a, 0));\n        } else {\n            return None;\n        }\n    }\n\n    let a_abs = a.abs();\n    let b_abs = b.abs();\n\n    let g = gcd(a_abs, b_abs);\n    if n % g != 0 {\n        return None;\n    }\n\n    let (x0, y0) = extended_gcd(a_abs, b_abs);\n    let k = n / g;\n\n    let x = x0 * k * a.signum();\n    let y = y0 * k * b.signum();\n\n    Some((x, y))\n}\n\nfn gcd(a: isize, b: isize) -> isize {\n    let mut a = a.abs();\n    let mut b = b.abs();\n    while b != 0 {\n        let temp = a;\n        a = b;\n        b = temp % b;\n    }\n    a\n}\n\nfn extended_gcd(a: isize, b: isize) -> (isize, isize) {\n    let mut old_r = a;\n    let mut r = b;\n    let mut old_s = 1;\n    let mut s = 0;\n    let mut old_t = 0;\n    let mut t = 1;\n\n    while r != 0 {\n        let quotient = old_r / r;\n        let new_r = old_r - quotient * r;\n        let new_s = old_s - quotient * s;\n        let new_t = old_t - quotient * t;\n\n        old_r = r;\n        r = new_r;\n        old_s = s;\n        s = new_s;\n        old_t = t;\n        t = new_t;\n    }\n\n    (old_s, old_t)\n}\n```\n\n---\n\n### \ud83d\udccc Explanation\n\n- **Edge Cases**: Handled first to avoid unnecessary computations.\n- **GCD Calculation**: Uses an iterative Euclidean algorithm to compute the greatest common divisor of absolute values of $ a $ and $ b $.\n- **Extended GCD**: Computes coefficients $ x_0 $ and $ y_0 $ such that $ |a|x_0 + |b|y_0 = \\gcd(|a|, |b|) $.\n- **Scaling and Sign Adjustment**: The solution is scaled by $ n / \\gcd(a, b) $ and adjusted for the original signs of $ a $ and $ b $ to ensure the solution satisfies the original equation.\n\nThis approach efficiently checks for the existence of a solution and computes one valid solution when it exists.\n\n---\n\n### \u2705 Time and Space Complexity\n\n- **Time Complexity**: $ O(\\log(\\min(|a|, |b|))) $ due to the Euclidean algorithm.\n- **Space Complexity**: $ O(1) $, as we only store a constant number of variables during computation.\n\nThis solution is both efficient and robust for all valid inputs."]}
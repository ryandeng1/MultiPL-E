{"name": "mbpp_162_sum_series", "language": "rs", "prompt": "/// Write a function to calculate the sum (n - 2*i) from i=0 to n // 2, for instance n + (n-2) + (n-4)... (until n-x =< 0).\nfn sum_series(n: isize) -> isize {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_162_sum_series.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = sum_series;\n    assert_eq!(candidate(6), 12);\n    assert_eq!(candidate(10), 30);\n    assert_eq!(candidate(9), 25);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve the problem of calculating the sum of the series $ n + (n-2) + (n-4) + \\ldots $ until the term becomes less than or equal to zero, we can observe that this forms an arithmetic sequence with a common difference of $-2$. The key insight is recognizing the pattern and using a mathematical formula to compute the sum efficiently without iterating through each term.\n\n---\n\n### \ud83d\udd0d Problem Analysis\n\nWe are given a non-negative integer `n`, and we want to compute:\n\n$$\n\\sum_{i=0}^{\\lfloor n/2 \\rfloor} (n - 2i)\n$$\n\nThis series starts at $ n $ and decreases by 2 for each subsequent term. The series stops when the next term would be less than or equal to zero.\n\nFor example:\n- If $ n = 5 $, the series is $ 5 + 3 + 1 = 9 $\n- If $ n = 4 $, the series is $ 4 + 2 + 0 = 6 $\n\nThis is a standard arithmetic sequence where:\n- First term $ a = n $\n- Last term $ l = n - 2 \\cdot \\lfloor n/2 \\rfloor $\n- Number of terms $ k + 1 $, where $ k = \\lfloor n/2 \\rfloor $\n\nThe sum of an arithmetic sequence is:\n\n$$\n\\text{Sum} = \\frac{\\text{number of terms}}{2} \\times (\\text{first term} + \\text{last term})\n$$\n\nSubstituting in our values:\n\n$$\n\\text{Sum} = (k + 1) \\cdot (n - k)\n$$\n\nWhere $ k = \\lfloor n/2 \\rfloor $\n\nThis formula gives us the sum directly without any loops, which is efficient and avoids potential overflow issues in large numbers.\n\n---\n\n### \u2705 Implementation in Rust\n\nHere's the implementation of the function:\n\n```rust\nfn sum_series(n: isize) -> isize {\n    let k = n / 2;\n    (k + 1) * (n - k)\n}\n```\n\n**Explanation:**\n- `n / 2` computes the floor of $ n/2 $ using integer division (which truncates toward zero in Rust).\n- `(k + 1)` gives the number of terms in the series.\n- `(n - k)` gives the value of the last term in the series.\n- Multiplying these two gives the total sum of the series.\n\nThis approach is both time-efficient ($ O(1) $) and handles all valid non-negative integer inputs correctly.\n\n---\n\n### \ud83e\uddea Example Tests\n\n| Input | Expected Output | Explanation |\n|-------|------------------|---------------|\n| 5     | 9                | $ 5 + 3 + 1 = 9 $ |\n| 4     | 6                | $ 4 + 2 + 0 = 6 $ |\n| 3     | 4                | $ 3 + 1 = 4 $ |\n| 2     | 2                | $ 2 + 0 = 2 $ |\n| 1     | 1                | $ 1 = 1 $ |\n| 0     | 0                | $ 0 = 0 $ |\n\nAll examples match the expected results.\n\n---\n\n### \ud83d\udccc Final Answer\n\n```rust\nfn sum_series(n: isize) -> isize {\n    let k = n / 2;\n    (k + 1) * (n - k)\n}\n```", "\n\nTo solve the problem of calculating the sum $ n + (n - 2) + (n - 4) + \\dots $ until the term becomes less than or equal to zero, we can recognize that this forms an **arithmetic series** with a common difference of $-2$. \n\n---\n\n### \ud83d\udd0d Key Insight\n\nThe sequence starts at $ n $ and decreases by 2 each time. The last term included in the sum is the largest value such that $ n - 2i > 0 $. This leads us to determine the number of terms $ m $ as:\n\n$$\nm = \\left\\lfloor \\frac{n + 1}{2} \\right\\rfloor\n$$\n\nThis formula ensures we include all positive terms in the sequence.\n\nUsing the standard arithmetic series sum formula:\n\n$$\n\\text{Sum} = m \\cdot \\left( \\text{first term} + \\text{last term} \\right) / 2\n$$\n\nWe find that the sum simplifies to:\n\n$$\n\\text{Sum} = m \\cdot (n - m + 1)\n$$\n\nThis avoids the need for a loop and gives us an efficient, constant-time solution.\n\n---\n\n### \u2705 Final Implementation\n\nHere's the Rust function that implements this logic:\n\n```rust\nfn sum_series(n: isize) -> isize {\n    let m = (n + 1) / 2;\n    m * (n - m + 1)\n}\n```\n\n---\n\n### \ud83e\uddea Example Tests\n\n| Input | Expected Output | Explanation |\n|-------|------------------|---------------|\n| 5     | 9                | $ 5 + 3 + 1 = 9 $ |\n| 4     | 6                | $ 4 + 2 = 6 $ |\n| 6     | 12               | $ 6 + 4 + 2 = 12 $ |\n| 0     | 0                | No positive terms |\n| 1     | 1                | $ 1 $ |\n\n---\n\n### \ud83d\udccc Notes\n\n- This solution works for **non-negative integers** $ n $.\n- It uses **integer division** to compute the number of terms $ m $.\n- The formula is derived from properties of arithmetic sequences and avoids any unnecessary loops or condition checks.\n- The time complexity is **O(1)**, making it very efficient even for large values of $ n $.\n\n---\n\n### \u2705 Final Answer\n\n```rust\nfn sum_series(n: isize) -> isize {\n    let m = (n + 1) / 2;\n    m * (n - m + 1)\n}\n```", "\n\nTo solve the problem of calculating the sum of the series $ n + (n-2) + (n-4) + \\dots $ until the term becomes less than or equal to zero, we can leverage the properties of arithmetic sequences.\n\n---\n\n### \ud83d\udd0d Understanding the Series\n\nThe series is defined as:\n$$\n\\text{sum} = \\sum_{i=0}^{k-1} (n - 2i)\n$$\nWhere $ k $ is the number of terms in the sequence such that all terms are **positive**.\n\nThis forms an **arithmetic sequence** with:\n- First term: $ a = n $\n- Common difference: $ d = -2 $\n- Last term: $ l = n - 2(k - 1) $\n\nThe sum of an arithmetic sequence is given by:\n$$\n\\text{sum} = \\frac{k}{2} \\cdot (a + l)\n$$\n\nSubstituting $ a = n $ and $ l = n - 2(k - 1) $, we get:\n$$\n\\text{sum} = \\frac{k}{2} \\cdot (n + n - 2(k - 1)) = \\frac{k}{2} \\cdot (2n - 2k + 2) = k(n - k + 1)\n$$\n\nSo the final formula becomes:\n$$\n\\text{sum} = k \\cdot (n - k + 1)\n$$\nWhere $ k = \\left\\lfloor \\frac{n + 1}{2} \\right\\rfloor $\n\n---\n\n### \u2705 Implementation in Rust\n\nWe can compute $ k $ using integer division in Rust:\n```rust\nfn sum_series(n: isize) -> isize {\n    let k = (n + 1) / 2;\n    k * (n - k + 1)\n}\n```\n\nThis function works for **non-negative** values of `n`. It correctly computes the sum of the sequence up to the last positive term.\n\n---\n\n### \ud83e\uddea Examples\n\n| `n` | Sequence | Sum |\n|-----|-----------|-----|\n| 5   | 5, 3, 1   | 9   |\n| 4   | 4, 2      | 6   |\n| 6   | 6, 4, 2   | 12  |\n| 0   | \u2014         | 0   |\n\nAll match the expected results.\n\n---\n\n### \u2705 Final Answer\n\n```rust\nfn sum_series(n: isize) -> isize {\n    let k = (n + 1) / 2;\n    k * (n - k + 1)\n}\n```"]}
{"name": "mbpp_126_sum", "language": "rs", "prompt": "/// Write a rsthon function to find the sum of common divisors of two given numbers.\nfn sum(a: isize, b: isize) -> isize {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_126_sum.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = sum;\n    assert_eq!(candidate(10, 15), 6);\n    assert_eq!(candidate(100, 150), 93);\n    assert_eq!(candidate(4, 6), 3);\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve the problem of finding the **sum of common divisors** of two given numbers in Rust, we can leverage a key mathematical insight: the **common divisors** of two numbers are exactly the **divisors of their greatest common divisor (GCD)**. \n\n---\n\n### \ud83d\udd0d Step-by-Step Explanation\n\n1. **Compute the GCD** of the two numbers using the **Euclidean algorithm**.\n   - This algorithm efficiently computes the GCD by repeatedly replacing the larger number with the remainder of the division of the larger by the smaller until one of the numbers becomes zero.\n   - We take the absolute values of the inputs to handle negative numbers correctly.\n\n2. **Find all positive divisors** of the GCD.\n   - Iterate from `1` to `GCD` (inclusive).\n   - For each number `i`, check if `GCD % i == 0`. If true, it's a divisor.\n\n3. **Sum all valid divisors** and return the result.\n\n---\n\n### \u2705 Final Rust Code\n\n```rust\nfn sum(a: isize, b: isize) -> isize {\n    let mut a = a.abs();\n    let mut b = b.abs();\n    while b != 0 {\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    let g = a;\n    let mut total = 0;\n    for i in 1..=g {\n        if g % i == 0 {\n            total += i;\n        }\n    }\n    total\n}\n```\n\n---\n\n### \ud83e\uddea Example Usage\n\n- `sum(12, 18)` \u2192 GCD = 6 \u2192 Divisors: [1, 2, 3, 6] \u2192 Sum = **12**\n- `sum(10, 15)` \u2192 GCD = 5 \u2192 Divisors: [1, 5] \u2192 Sum = **6**\n- `sum(5, 5)` \u2192 GCD = 5 \u2192 Divisors: [1, 5] \u2192 Sum = **6**\n\n---\n\n### \ud83d\udcdd Notes\n\n- The function handles **negative inputs** by taking absolute values.\n- It efficiently computes the GCD using the **Euclidean algorithm**.\n- It iterates through all numbers from `1` to the GCD to find and sum the divisors.\n- The solution assumes **positive divisors** as is standard in such problems.\n\nThis implementation is both **efficient** and **clear**, and it adheres to Rust best practices for handling integer arithmetic and loops.\n\n---\n\n### \u2705 Final Answer\n\n```rust\nfn sum(a: isize, b: isize) -> isize {\n    let mut a = a.abs();\n    let mut b = b.abs();\n    while b != 0 {\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    let g = a;\n    let mut total = 0;\n    for i in 1..=g {\n        if g % i == 0 {\n            total += i;\n        }\n    }\n    total\n}\n```", "\n\nTo solve this problem, we need to find the sum of all common divisors of two given numbers. The common divisors of two numbers are the divisors of their greatest common divisor (GCD). \n\n### Approach\n1. **Take Absolute Values**: Since divisors are typically considered for positive numbers, we first convert both input numbers to their absolute values.\n2. **Handle Zero Case**: If both numbers are zero, there are no common divisors, so we return 0.\n3. **Compute GCD**: Using the Euclidean algorithm, we compute the GCD of the absolute values of the two numbers. The Euclidean algorithm efficiently finds the GCD by repeatedly replacing the larger number with the remainder of dividing the larger number by the smaller number until the smaller number becomes zero.\n4. **Find Divisors of GCD**: Once the GCD is found, we determine all its divisors by iterating from 1 to the square root of the GCD. For each divisor `i` found, we add both `i` and `GCD / i` to the total sum (if they are distinct).\n\n### Solution Code\n```rust\nfn sum(a: isize, b: isize) -> isize {\n    let a = a.abs();\n    let b = b.abs();\n\n    if a == 0 && b == 0 {\n        return 0;\n    }\n\n    let mut x = a;\n    let mut y = b;\n    while y != 0 {\n        let temp = y;\n        y = x % y;\n        x = temp;\n    }\n    let g = x;\n\n    let mut total = 0;\n    let mut i = 1;\n    while i * i <= g {\n        if g % i == 0 {\n            total += i;\n            if i != g / i {\n                total += g / i;\n            }\n        }\n        i += 1;\n    }\n    total\n}\n```\n\n### Explanation\n1. **Absolute Values Handling**: The inputs `a` and `b` are converted to their absolute values to ensure we work with non-negative numbers, which simplifies the divisor calculation.\n2. **Zero Check**: If both numbers are zero, the function immediately returns 0 since there are no common divisors.\n3. **GCD Calculation**: The Euclidean algorithm is used to compute the GCD. The algorithm works by repeatedly taking the remainder of the division of the larger number by the smaller number until the remainder is zero. The last non-zero remainder is the GCD.\n4. **Divisor Sum Calculation**: For each number from 1 up to the square root of the GCD, we check if it divides the GCD evenly. If it does, we add both the divisor and its complement (GCD divided by the divisor) to the total sum. This ensures we efficiently capture all divisors without redundant checks.\n\nThis approach efficiently computes the sum of common divisors by leveraging mathematical properties of GCD and divisors, ensuring optimal performance even for large numbers. The solution handles edge cases such as zero inputs and negative numbers gracefully.", "\n\nTo solve this problem, we need to find the sum of all common divisors of two given integers. The common divisors of two numbers are the divisors of their greatest common divisor (GCD). \n\n### Approach\n1. **Handle Special Case**: If both numbers are zero, return 0 because there are no common divisors.\n2. **Compute GCD**: Use the Euclidean algorithm to compute the GCD of the absolute values of the two numbers. This ensures the GCD is non-negative and handles negative inputs correctly.\n3. **Sum Divisors**: Iterate from 1 to the square root of the GCD to find all divisors. For each divisor `i` found:\n   - Add `i` to the total sum.\n   - If `i` is not the square root of the GCD, add the corresponding divisor `g / i` to the total sum.\n\nThis approach efficiently computes the sum of common divisors by leveraging the mathematical property that common divisors of two numbers are exactly the divisors of their GCD.\n\n### Solution Code\n```rust\nfn sum(a: isize, b: isize) -> isize {\n    if a == 0 && b == 0 {\n        return 0;\n    }\n\n    let mut x = a.abs();\n    let mut y = b.abs();\n\n    while y != 0 {\n        let t = y;\n        y = x % y;\n        x = t;\n    }\n\n    let g = x;\n\n    let mut total = 0;\n    let mut i = 1;\n    while i * i <= g {\n        if g % i == 0 {\n            total += i;\n            if i != g / i {\n                total += g / i;\n            }\n        }\n        i += 1;\n    }\n\n    total\n}\n```\n\n### Explanation\n1. **Special Case Handling**: The function first checks if both inputs are zero. If so, it returns 0 since there are no common divisors.\n2. **GCD Calculation**: The Euclidean algorithm is used to compute the GCD of the absolute values of the inputs. This ensures the GCD is positive and correctly handles negative inputs.\n3. **Divisor Sum Calculation**: The function then iterates from 1 to the square root of the GCD. For each integer `i` that divides the GCD without a remainder:\n   - `i` is added to the total sum.\n   - If `i` is not the square root of the GCD, the corresponding divisor `g / i` is also added to the sum.\n   \nThis method efficiently computes the sum of all common divisors by leveraging the GCD and iterating only up to the square root of the GCD, optimizing the solution for performance. The solution handles all edge cases, including zero inputs and negative numbers, by using absolute values during the GCD computation."]}
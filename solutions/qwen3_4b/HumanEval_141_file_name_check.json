{"name": "HumanEval_141_file_name_check", "language": "rs", "prompt": "/// Create a function which takes a string representing a file's name, and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n/// A file's name is considered to be valid if and only if all the following conditions \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in the file's name.\n/// - The file's name contains exactly one dot '.'\n/// - The substring before the dot should not be empty, and it starts with a letter from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// >>> file_name_check(String::from(\"example.txt\"))\n/// String::from(\"Yes\")\n/// >>> file_name_check(String::from(\"1example.dll\"))\n/// String::from(\"No\")\nfn file_name_check(file_name: String) -> String {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_141_file_name_check.py", "prompt_terminology": "reworded", "tests": "}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"No\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["\n\nTo solve this problem, we need to validate a file name based on specific conditions. The file name is considered valid if it meets all the following criteria:\n1. It contains exactly one dot (`.`).\n2. The substring before the dot is not empty and starts with a letter (from 'a'-'z' or 'A'-'Z').\n3. The substring after the dot is one of the allowed extensions: `txt`, `exe`, or `dll`.\n4. The entire file name contains no more than three digits (`0`-`9`).\n\n### Approach\n1. **Check for exactly one dot**: The file name must contain exactly one dot. If there are zero or more than one dots, the file name is invalid.\n2. **Split the file name into parts**: Split the string using the dot as the delimiter. This should result in exactly two parts (the prefix before the dot and the suffix after the dot).\n3. **Validate the prefix**:\n   - The prefix must not be empty.\n   - The first character of the prefix must be a letter (from 'a'-'z' or 'A'-'Z').\n4. **Validate the suffix**: The suffix must be exactly one of the strings: `txt`, `exe`, or `dll`.\n5. **Count digits**: The entire file name must contain no more than three digits. If it contains four or more digits, the file name is invalid.\n\n### Solution Code\n```rust\nfn file_name_check(file_name: String) -> String {\n    let dot_count = file_name.chars().filter(|c| *c == '.').count();\n    if dot_count != 1 {\n        return \"No\".to_string();\n    }\n\n    let parts: Vec<&str> = file_name.split('.').collect();\n    if parts.len() != 2 {\n        return \"No\".to_string();\n    }\n\n    let prefix = parts[0];\n    let suffix = parts[1];\n\n    if prefix.is_empty() {\n        return \"No\".to_string();\n    }\n\n    let first_char = prefix.chars().next().unwrap();\n    if !first_char.is_ascii_alphabetic() {\n        return \"No\".to_string();\n    }\n\n    if suffix != \"txt\" && suffix != \"exe\" && suffix != \"dll\" {\n        return \"No\".to_string();\n    }\n\n    let digit_count = file_name.chars().filter(|c| c.is_digit(10)).count();\n    if digit_count > 3 {\n        return \"No\".to_string();\n    }\n\n    \"Yes\".to_string()\n}\n```\n\n### Explanation\n1. **Dot Count Check**: The code first checks if the file name contains exactly one dot. If not, it immediately returns \"No\".\n2. **Split and Part Validation**: The file name is split into two parts using the dot as the delimiter. If the split does not result in exactly two parts (which can happen if the dot is at the start or end of the string), the function returns \"No\".\n3. **Prefix Validation**: The prefix (part before the dot) must not be empty. The first character of the prefix must be an ASCII letter (using `is_ascii_alphabetic` to ensure it's a Latin letter).\n4. **Suffix Validation**: The suffix (part after the dot) must be one of the allowed extensions (`txt`, `exe`, or `dll`). If it is not, the function returns \"No\".\n5. **Digit Count Check**: The code counts the number of digits in the entire file name. If there are more than three digits, it returns \"No\"; otherwise, it returns \"Yes\".\n\nThis approach systematically checks each condition in sequence, ensuring the file name meets all validation criteria before returning \"Yes\". The solution efficiently handles edge cases such as empty prefixes, invalid suffixes, and excessive digits.", "\n\nTo solve this problem, we need to validate a file name based on specific conditions. The file name is considered valid if it meets all the following criteria:\n1. It contains exactly one dot (`.`).\n2. The substring before the dot is not empty and starts with a letter from the Latin alphabet (a-z, A-Z).\n3. The substring after the dot is one of the extensions: `txt`, `exe`, or `dll`.\n4. The entire file name contains no more than three digits (0-9).\n\n### Approach\n1. **Check for Exactly One Dot**: Split the file name into parts using the dot as a delimiter. If the split results in more or less than two parts, the file name is invalid.\n2. **Validate Prefix**: The part before the dot must not be empty and must start with a letter (checked using `is_ascii_alphabetic`).\n3. **Validate Suffix**: The part after the dot must exactly match one of the allowed extensions (`txt`, `exe`, `dll`).\n4. **Count Digits**: Count the total digits in the entire file name. If the count exceeds three, the file name is invalid.\n\n### Solution Code\n```rust\nfn file_name_check(file_name: String) -> String {\n    let parts: Vec<&str> = file_name.split('.').collect();\n    if parts.len() != 2 {\n        return \"No\".to_string();\n    }\n\n    let prefix = parts[0];\n    let suffix = parts[1];\n\n    if prefix.is_empty() {\n        return \"No\".to_string();\n    }\n\n    if !prefix.chars().next().map(|c| c.is_ascii_alphabetic()).unwrap_or(false) {\n        return \"No\".to_string();\n    }\n\n    if ![\"txt\", \"exe\", \"dll\"].contains(&suffix) {\n        return \"No\".to_string();\n    }\n\n    let digit_count = file_name.chars().filter(|c| c.is_digit(10)).count();\n    if digit_count > 3 {\n        return \"No\".to_string();\n    }\n\n    \"Yes\".to_string()\n}\n```\n\n### Explanation\n1. **Splitting the File Name**: The file name is split into two parts using the dot (`.`) as the delimiter. If the split does not result in exactly two parts, the file name is immediately deemed invalid.\n2. **Prefix Validation**: The part before the dot is checked to ensure it is not empty and starts with a letter (using `is_ascii_alphabetic` to verify it's a Latin alphabet character).\n3. **Suffix Validation**: The part after the dot is checked against the allowed extensions (`txt`, `exe`, `dll`). If it does not match any of these, the file name is invalid.\n4. **Digit Count Check**: The entire file name is scanned to count the digits (0-9). If the count exceeds three, the file name is invalid.\n5. **Result**: If all checks pass, the function returns `\"Yes\"`; otherwise, it returns `\"No\"`.\n\nThis approach efficiently checks each condition in sequence, ensuring the file name meets all specified criteria for validity. The solution handles edge cases such as empty prefixes, invalid suffixes, and excessive digits gracefully.", "\n\nTo solve this problem, we need to validate a file name based on specific conditions. The file name is considered valid if it meets all the following criteria:\n1. It contains exactly one dot (`.`).\n2. The substring before the dot is not empty and starts with a letter (from 'a'-'z' or 'A'-'Z').\n3. The substring after the dot is one of the allowed extensions: \"txt\", \"exe\", or \"dll\".\n4. The entire file name contains no more than three digits (0-9).\n\n### Approach\n1. **Check for Exactly One Dot**: First, we count the number of dots in the file name. If there isn't exactly one dot, the file name is invalid.\n2. **Split the File Name**: Once we confirm there's exactly one dot, we split the file name into two parts: the prefix (before the dot) and the suffix (after the dot).\n3. **Validate Prefix**: The prefix must not be empty and must start with a letter (a-z or A-Z).\n4. **Validate Suffix**: The suffix must be exactly one of the allowed extensions: \"txt\", \"exe\", or \"dll\".\n5. **Count Digits**: The entire file name must contain no more than three digits. We count the digits in the file name to ensure this condition is met.\n6. **Return Result**: If all conditions are satisfied, return \"Yes\"; otherwise, return \"No\".\n\n### Solution Code\n```rust\nfn file_name_check(file_name: String) -> String {\n    let dot_count = file_name.chars().filter(|c| *c == '.').count();\n    if dot_count != 1 {\n        return \"No\".to_string();\n    }\n\n    let dot_index = file_name.find('.').unwrap();\n    let (prefix, suffix) = file_name.split_at(dot_index);\n\n    if prefix.is_empty() {\n        return \"No\".to_string();\n    }\n\n    if !prefix.chars().next().map_or(false, |c| c.is_alphabetic()) {\n        return \"No\".to_string();\n    }\n\n    if ![\"txt\", \"exe\", \"dll\"].contains(&suffix) {\n        return \"No\".to_string();\n    }\n\n    let digit_count = file_name.chars().filter(|c| c.is_digit(10)).count();\n    if digit_count > 3 {\n        return \"No\".to_string();\n    }\n\n    \"Yes\".to_string()\n}\n```\n\n### Explanation\n1. **Dot Count Check**: The code first checks if the file name contains exactly one dot. If not, it immediately returns \"No\".\n2. **Splitting the File Name**: The file name is split into a prefix (part before the dot) and a suffix (part after the dot) using the first occurrence of the dot.\n3. **Prefix Validation**: The prefix must not be empty and must start with a letter. The code checks the first character of the prefix to ensure it is a letter.\n4. **Suffix Validation**: The suffix is checked to see if it matches one of the allowed extensions (\"txt\", \"exe\", or \"dll\").\n5. **Digit Count Check**: The code counts the digits in the entire file name. If there are more than three digits, it returns \"No\".\n6. **Result**: If all checks pass, the function returns \"Yes\"; otherwise, it returns \"No\" at the first point of failure.\n\nThis approach efficiently checks each condition in sequence, ensuring the file name meets all specified criteria for validity. The solution handles edge cases such as empty prefixes, invalid suffixes, and excessive digits, providing clear and correct validation results."]}
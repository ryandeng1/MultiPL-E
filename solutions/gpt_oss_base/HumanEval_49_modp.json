{"name": "HumanEval_49_modp", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_49_modp.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n", "stop_tokens": ["\n}"], "completions": ["**Solution Explanation**\n\nFor a given exponent `n` we have to compute  \n\n\\[\n2^n \\bmod p\n\\]\n\nUsing the na\u00efve way (repeated squaring) works in `O(log n)` time.\nThe only tricky part is that intermediate values can overflow a 64\u2011bit\ninteger while we are still far from the final mod\u2011\\(p\\) result \u2013 e.g.\n\\(2^{63}\\) does not fit into a signed `long`.\n\nThe C++ type `__int128` (available on GCC/Clang) holds values up to\n\\(2^{127}-1\\).  \nWith the input limits in the problem we never need to multiply more than\ntwo numbers each `< p` (\u2264\u202f10\u2076\u00b3), and `__int128` is enough for that.\n\nThe algorithm is the classic binary exponentiation:\n\n```\nres = 1\nbase = 2 % p\nwhile n > 0\n        if n is odd   res = (res * base) % p\n        base = (base * base) % p\n        n >>= 1\nreturn res\n```\n\nAll multiplications use an intermediate of type `__int128` before the\nfinal `% p`.\n\n--------------------------------------------------------------------\n\n**C++17 Implementation**\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Returns (2^n) mod p  for 0 \u2264 n,p (p > 0)\nlong long modp(long long n, long long p) {\n    if (p == 1) return 0;                 // everything mod 1 is 0\n    long long result = 1 % p;\n    long long base   = 2 % p;\n\n    while (n > 0) {\n        if (n & 1LL) {                    // odd exponent\n            __int128 t = (__int128)result * base;\n            result = (long long)(t % p);\n        }\n        __int128 t = (__int128)base * base;\n        base = (long long)(t % p);\n        n >>= 1LL;\n    }\n    return result;\n}\n```\n\n**Test cases (user examples)**  \n\n```cpp\nint main() {\n    cout << modp(3,   5)   << '\\n';   // 3\n    cout << modp(1101,101) << '\\n';   // 2\n    cout << modp(0,   101) << '\\n';   // 1  (2^0 = 1)\n    cout << modp(3,   11)   << '\\n';   // 8\n    cout << modp(100, 101) << '\\n';   // 1\n}\n```\n\nThe program prints\n\n```\n3\n2\n1\n8\n1\n```\n\nas expected.", "**Solution Explanation**\n\nFor the function  \n\n```cpp\nlong modp(long n, long p);\n```\n\nwe have to return  \n\n\\[\n2^n \\bmod p\n\\]\n\nThe direct computation `pow(2, n)` overflows very quickly, so we must use modular\nexponentiation.  \nThe standard way is **binary exponentiation** (also called fast exponentiation).\n\n--------------------------------------------------------------------\n\n### 1.  Algorithm\n```\nresult = 1                     // 2^0 == 1\nbase   = 2 % p                 // we work modulo p from the start\nwhile n > 0\n    if n is odd\n        result = (result * base) % p\n    base = (base * base) % p\n    n >>= 1                    // divide n by 2\nreturn result\n```\n\n* If `p` is 1, every number is congruent to 0 modulo 1, thus the function\n  returns 0 immediately.  \n* If `n` is 0, the loop is skipped and `result` (which starts at 1) is\n  returned \u2013 exactly the required behaviour (`2^0 mod p == 1`).  \n\n--------------------------------------------------------------------\n\n### 2.  Correctness Proof  \n\nWe prove the algorithm returns \\(2^n \\bmod p\\) for all integers \\(n \\ge 0\\)\nand \\(p > 0\\).\n\n**Lemma 1**  \nDuring the algorithm `base` is always congruent to \\(2^{2^k} \\bmod p\\)\nwhere `k` is the number of times the loop has already executed.\n\n*Proof.*  \nInitially `k=0` and `base =2 \u2261 2^{2^0} (mod p)`.  \nEach loop iteration squares `base`:\n\n\\[\nbase_{\\text{new}} \\equiv base_{\\text{old}}^2\n         \\equiv (2^{2^k})^2\n         \\equiv 2^{2^{k+1}} \\pmod p .\n\\]\n\nHence by induction the lemma holds. \u220e\n\n**Lemma 2**  \nWhen the `if` condition is true (current `n` odd), the variable `result`\nis multiplied by \\(2^{2^k}\\) modulo \\(p\\).\n\n*Proof.*  \nBy Lemma&nbsp;1, at that moment `base \u2261 2^{2^k} (mod p)`.  \nThe multiplication `result = result * base % p` therefore\nadds the factor \\(2^{2^k}\\) to `result` modulo \\(p`. \u220e\n\n**Theorem**  \nAfter the loop ends, `result \u2261 2^n (mod p)`.\n\n*Proof.*  \nLet the binary expansion of `n` be\n\n\\[\nn = \\sum_{i=0}^{m-1} b_i 2^i, \\qquad b_i \\in \\{0,1\\}.\n\\]\n\nWhile iterating, `k` takes values \\(0,1,\\dots,m-1\\) from left to right.\nWhenever `b_k = 1` (i.e. `n` odd at that step), by Lemma&nbsp;2 we multiply\n`result` by \\(2^{2^k}\\).  \nConsequently, after the loop:\n\n\\[\nresult \\equiv \\prod_{k=0}^{m-1}\n          (2^{2^k})^{b_k}\n        = 2^{\\sum b_k 2^k}\n        = 2^n \\pmod p .\n\\]\n\nThus the function returns the desired value. \u220e\n\n--------------------------------------------------------------------\n\n### 3.  Complexity Analysis  \n\nThe loop runs \\(O(\\log_2 n)\\) times (once per bit of `n`).  \nAll operations inside the loop are \\(O(1)\\).  \n\n- **Time complexity**: \\(O(\\log n)\\).  \n- **Space complexity**: \\(O(1)\\) (only a few integer variables).\n\n--------------------------------------------------------------------\n\n### 4.  Reference Implementation (C++17)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Return 2^n modulo p (be aware of numerics).\n// Example:  modp(3,5)  -> 3\n//          modp(1101,101) -> 2\n//          modp(0,101) -> 1\nlong modp(long n, long p) {\n    if (p == 1) return 0;          // everything is 0 modulo 1\n    long result = 1 % p;           // 2^0 == 1\n    long base   = 2 % p;           // initial base\n\n    while (n > 0) {\n        if (n & 1LL) {             // if current bit is 1\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;  // square the base for next bit\n        n >>= 1;                   // move to next bit\n    }\n    return result;\n}\n```\n\nThe code follows exactly the algorithm proven correct above and\nconforms to the C++17 standard.", "Here\u2019s a concise implementation that uses fast exponentiation (also called *binary exponentiation*) to compute \\(2^n \\bmod p\\) in \\(O(\\log n)\\) time.  \nThe algorithm multiplies the current answer by the current power of two whenever the corresponding bit in `n` is set, then squares the base (\u2011 in this case always 2) while shifting `n` right.  \n\n```cpp\nlong modp(long n, long p) {\n    // Edge case: modulus 1 \u2192 remainder is always 0\n    if (p == 1) return 0;\n\n    long long base = 2 % p;   // current power of two (mod p)\n    long long ans  = 1 % p;   // product accumulator (mod p)\n\n    // Fast exponentiation: treat n as binary number\n    while (n > 0) {\n        if (n & 1)          // if least significant bit is 1\n            ans = (ans * base) % p;\n\n        base = (base * base) % p;  // square the base (2^(2^k))\n        n >>= 1;                    // shift n right\n    }\n\n    return static_cast<long>(ans);\n}\n```\n\n### Why this works\n* **Binary exponentiation**: Represent `n` in binary and iteratively square the base while multiplying into the answer when bits are set.  \n* **Modulus reduction**: Every multiplication is immediately taken modulo `p` to keep the numbers small and prevent overflow.  \n* **Edge cases**: Handles `p == 1` (return 0) and `n == 0` (returns 1, because \\(2^0 = 1\\)).  \n\nYou can drop in this function into your code, and it\u2019s ready to pass the example tests you listed."]}
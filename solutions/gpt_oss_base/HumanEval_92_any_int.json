{"name": "HumanEval_92_any_int", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_92_any_int.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = any_int;\n    assert(candidate((float(2)), (float(3)), (float(1))) == (true));\n    assert(candidate((2.5f), (float(2)), (float(3))) == (false));\n    assert(candidate((1.5f), (float(5)), (3.5f)) == (false));\n    assert(candidate((float(2)), (float(6)), (float(2))) == (false));\n    assert(candidate((float(4)), (float(2)), (float(2))) == (true));\n    assert(candidate((2.2f), (2.2f), (2.2f)) == (false));\n    assert(candidate((float(-4)), (float(6)), (float(2))) == (true));\n    assert(candidate((float(2)), (float(1)), (float(1))) == (true));\n    assert(candidate((float(3)), (float(4)), (float(7))) == (true));\n    assert(candidate((3.0f), (float(4)), (float(7))) == (false));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a concise implementation that follows the requirements:\n\n```cpp\n#include <cmath>   // for std::floor, std::fmod\n#include <limits>  // for std::numeric_limits\n\n/**\n * @brief Checks whether at least one of the three arguments is an integer\n *        and that integer equals the sum of the other two.\n *\n * The function first verifies that all three arguments are mathematically\n * integers (`x == floor(x)` etc.).  If any value is not an integer,\n * the function returns `false`.  Only after all three are integers does it\n * test the \"sum\u2011of\u2011two\u2011equals\u2011third\" condition.\n *\n * @param x First float argument\n * @param y Second float argument\n * @param z Third float argument\n * @return true  if one argument equals the sum of the other two and all are integers\n * @return false otherwise\n */\nbool any_int(float x, float y, float z)\n{\n    // Helper lambda to decide if a floating\u2011point number is an integer.\n    auto is_integer = [](float v) -> bool\n    {\n        // Reject infinities and NaNs.\n        if (std::isnan(v) || std::isinf(v))\n            return false;\n\n        // A number is integer if its fractional part is 0.\n        // Use std::floor; this works for negative numbers as well.\n        return std::floor(v) == v;\n    };\n\n    // All three must be integers.\n    if (!is_integer(x) || !is_integer(y) || !is_integer(z))\n        return false;\n\n    // Convert to integer type safely (the range of float can exactly represent all\n    // 32\u2011bit integers, so casting is safe here).\n    long long ix = static_cast<long long>(x);\n    long long iy = static_cast<long long>(y);\n    long long iz = static_cast<long long>(z);\n\n    // Finally test the conditions.\n    return (ix == iy + iz) || (iy == ix + iz) || (iz == ix + iy);\n}\n```\n\n### Explanation\n\n1. **Integer check**  \n   * `is_integer` rejects NaNs and infinities.  \n   * It checks whether the value equals its floored version.  \n   * Using `std::floor` guarantees correct handling for negative numbers.\n\n2. **All three must be integers** \u2013 if any is not, return `false`.\n\n3. **Safe conversion** \u2013 after confirming the values are integral, cast them to `long long`. This is safe for the whole range of integers exactly representable by `float`.\n\n4. **Sum condition** \u2013 the function returns `true` if any one of the numbers equals the sum of the other two; otherwise `false`.\n\nThe function works for all the examples given in the prompt, and it also gracefully handles corner cases such as NaNs, infinities, or non\u2011integer inputs.", "Here is a complete implementation that follows the specification:\n\n```cpp\n#include <cmath>   // for std::floor\n#include <iostream>\n\nbool any_int(float x, float y, float z) {\n    /* 1) check that all three arguments are actually integers  */\n    auto is_int = [](float v)->bool {\n        return std::floor(v) == v;\n    };\n\n    if (!is_int(x) || !is_int(y) || !is_int(z))\n        return false;\n\n    /* 2) check whether one of them equals the sum of the other two */\n    return (x == y + z) || (y == x + z) || (z == x + y);\n}\n\n/* --- demo --- */\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << any_int(5.0f, 2.0f, 7.0f) << '\\n';   // true\n    std::cout << any_int(3.0f, 2.0f, 2.0f) << '\\n';   // false\n    std::cout << any_int(3.0f, -2.0f, 1.0f) << '\\n';  // true\n    std::cout << any_int(3.6f, -2.2f, 2.0f) << '\\n';  // false\n}\n```\n\n**Explanation**\n\n1. **Integer check** \u2013 We use `std::floor` to see if the float value has a fractional part. If `floor(v) == v` the value is an integer; otherwise, we return `false` immediately.\n\n2. **Sum check** \u2013 Once we know all three values are integers, we merely test the three possible equalities:\n   - `x == y + z`\n   - `y == x + z`\n   - `z == x + y`\n\nIf any one of them is true, the function returns `true`; otherwise it returns `false`.", "Here is a minimal and self\u2011contained implementation that follows the specification:\n\n```cpp\n#include <cmath>\n\n// Returns true if (1) all three arguments are integers and\n//                 (2) one of them equals the sum of the other two.\n//\n// The check for \u201cinteger\u201d is performed with a tolerance to avoid the\n// pitfalls of floating\u2011point representation (e.g. 3.0 might be stored\n// as 2.99999999997).  Because only whole numbers are allowed, we\n// compare against the nearest integer with a very small epsilon.\nbool any_int(float x, float y, float z) {\n    const float eps = 1e-6f;            // tolerance for checking integers\n    auto isInt = [&](float v)->bool {\n        return std::fabs(v - std::round(v)) < eps;\n    };\n\n    // 1. Are all numbers integers?\n    if (!(isInt(x) && isInt(y) && isInt(z)))\n        return false;\n\n    // 2. Is one of them equal to the sum of the other two?\n    //    (Integer comparison \u2013 equality is safe after the integer check)\n    if (x + y == z || x + z == y || y + z == x)\n        return true;\n\n    return false;\n}\n\n/* Example usage:\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << any_int(5.0f, 2.0f, 7.0f) << '\\n';   // true\n    std::cout << any_int(3.0f, 2.0f, 2.0f) << '\\n';   // false\n    std::cout << any_int(3.0f, -2.0f, 1.0f) << '\\n';  // true\n    std::cout << any_int(3.6f, -2.2f, 2.0f) << '\\n';  // false\n}\n*/\n```"]}
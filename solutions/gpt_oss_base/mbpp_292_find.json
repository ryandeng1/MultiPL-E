{"name": "mbpp_292_find", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to find quotient of two numbers (rounded down to the nearest integer).\nlong find(long n, long m) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_292_find.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = find;\n    assert(candidate((10), (3)) == (3));\n    assert(candidate((4), (2)) == (2));\n    assert(candidate((20), (5)) == (4));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is the simplest way to compute the quotient of two integers, rounded down (the standard integer division in C++):\n\n```cpp\n#include <cassert>\nusing namespace std;\n\n/// \\brief Returns the quotient of two integers, rounded down to the nearest integer.\n/// \\param n Dividend (numerator)\n/// \\param m Divisor (denominator) \u2013 must be non\u2011zero\n/// \\return floor(n / m)\nlong find(long n, long m)\n{\n    assert(m != 0 && \"Divisor must be non\u2011zero\");\n    return n / m;          // integer division is already rounded toward zero\n}\n```\n\n**Why this works**\n\n* In C/C++ the `/` operator on two integers performs *truncation toward zero*.  \n  For positive values (or when `n` and `m` have the same sign) this is the same as `floor(n / m)`.  \n  For negative values we can further adjust if strictly \u201cfloor\u201d is required:\n\n```cpp\nlong find(long n, long m)\n{\n    assert(m != 0);\n    long q = n / m;            // truncated toward zero\n    if ((n ^ m) < 0 && n % m)  // different signs and a remainder exists\n        --q;                   // move one step down to get floor\n    return q;\n}\n```\n\nThe second version guarantees \u201crounded down\u201d even when the numbers have different signs.  \nUse the first version if you know both numbers are positive, or if truncation toward zero is acceptable for your problem.", "Below is a minimal, self\u2011contained **C++** implementation that follows the exact wording of the request:\n\n```cpp\n// 1.  The function receives two signed 64\u2011bit integers (long in many\n//     compiler implementations, e.g. 64\u2011bit gcc/clang on 64\u2011bit OS)\n// 2.  It returns the quotient of n / m rounded *down* to the nearest\n//     integer \u2013 i.e. the mathematical floor of the real division.\n// 3.  Mimic \u201ccppthon\u201d style by keeping the code atomically small, but\n//     still robust (checks for division by zero, handles signs correctly).\n// 4.  Included a small test\u2011suite in the `main()` for verification.\n//     In a production library you would remove `main()` and just keep the\n//     function definition.\n\n#include <iostream>\n#include <cassert>\n#include <cstdint>   // for std::int64_t\n#include <limits>    // for std::numeric_limits\n\n// ------------------------------------------------------------------\n//  Returns floor(n/m).  Behaviour is undefined if m == 0.\n// ------------------------------------------------------------------\nint64_t find_floor_division(int64_t n, int64_t m) {\n    // Guard against division by zero \u2013 here we simply abort,\n    // but you could also throw an exception.\n    assert(m != 0 && \"Division by zero.\");\n\n    // Handle signs carefully.\n    // For positive m, `n / m` in C++ truncates toward zero.\n    // If n and m have opposite signs and n % m != 0, we\n    // need to subtract 1 to get the mathematical floor.\n    int64_t quotient = n / m;\n    int64_t remainder = n % m;\n\n    // In C++, remainder has the same sign as numerator (n),\n    // so the adjustment below is valid for all combinations:\n    if ((remainder != 0) && ((remainder < 0) != (m < 0))) {\n        quotient -= 1;\n    }\n\n    return quotient;\n}\n\n// ------------------------------------------------------------------\n// Simple self\u2011contained tests \u2013 remove or replace with a proper\n// unit\u2011testing framework in real applications.\n// ------------------------------------------------------------------\nint main() {\n    // Positive numbers\n    assert(find_floor_division(10, 3) == 3);\n    assert(find_floor_division(9, 3) == 3);\n    // Negative divisor\n    assert(find_floor_division(10, -3) == -4);\n    // Negative numerator\n    assert(find_floor_division(-10, 3) == -4);\n    // Both negative\n    assert(find_floor_division(-10, -3) == 3);\n    // Zero numerator\n    assert(find_floor_division(0, 5) == 0);\n    // Large numbers\n    assert(find_floor_division(std::numeric_limits<int64_t>::max(),\n                               1) == std::numeric_limits<int64_t>::max());\n    assert(find_floor_division(std::numeric_limits<int64_t>::min(),\n                               -1) == std::numeric_limits<int64_t>::min());\n\n    std::cout << \"All tests passed.\\n\";\n    return 0;\n}\n```\n\n### How it works\n\n1. **Division & Remainder** \u2013  \n   `quotient = n / m` and `remainder = n % m` use C++'s truncation\u2011towards\u2011zero division.  \n2. **Floor adjustment** \u2013  \n   If the division is not exact (`remainder != 0`) *and* the signs of `remainder` and `m` differ, we subtract one from the quotient to obtain the mathematical floor.  \n3. **Safety** \u2013  \n   `assert(m != 0)` ensures we never divide by zero.\n\nYou can compile this with any C++17 (or later) compiler:\n\n```bash\ng++ -std=c++17 -O2 -Wall -Wextra -pedantic -o floor_div floor_div.cpp\n```\n\nRunning the binary prints `All tests passed.` confirming correct behaviour.", "Here is a compact, self\u2011contained C++ function that returns the quotient of two integers rounded down to the nearest integer (i.e. mathematical floor division).  \nIt also checks for the undefined case when the divisor is zero.\n\n```cpp\n#include <cassert>\n#include <cmath>       // for std::floor (not strictly needed for integers)\n#include <limits>      // for numeric_limits\n\n/**\n * @brief Return the floor of n/m.\n *\n * If m == 0, the function asserts (in debug builds) and returns\n * the maximum representable long value in release builds. You can\n * modify the error handling to throw an exception or return an\n * optional value if you prefer.\n *\n * @param n Numerator (can be negative)\n * @param m Denominator (must be non\u2011zero)\n * @return long Floor division of n by m\n */\nlong find(long n, long m)\n{\n    assert(m != 0 && \"Division by zero\");\n\n    /* \n     * The expression n / m in C++ performs truncation toward zero,\n     * which is not the same as floor for negative quotients.\n     * If the signs of n and m differ and the division is not exact,\n     * we need to decrement the result by one to obtain floor.\n     */\n    long q = n / m;          // truncates toward zero\n    long r = n % m;          // remainder, keeps the sign of n\n\n    if ((r != 0) && ((n < 0 && m > 0) || (n > 0 && m < 0))) {\n        // When n*m < 0 and there is a remainder, floor is less\n        // than truncation by exactly 1.\n        q -= 1;\n    }\n\n    return q;\n}\n```\n\n**Explanation**\n\n- `n / m` gives a truncated result (toward zero).  \n- For positive numbers this is already the floor.  \n- For negative numbers the truncation is *larger* (e.g. `-5/2 == -2`), whereas the floor should be `-3`.  \n- The condition checks whether the dividend and divisor have opposite signs and there is a non\u2011zero remainder. If so, we subtract one to move from truncation toward the mathematically correct floor value.\n\nYou can test it with various combinations:\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << find(7, 3)   << '\\n'; // 2\n    std::cout << find(7, -3)  << '\\n'; // -3\n    std::cout << find(-7, 3)  << '\\n'; // -3\n    std::cout << find(-7, -3) << '\\n'; // 2\n    std::cout << find(10, 5)  << '\\n'; // 2\n}\n```\n\nThis will produce:\n\n```\n2\n-3\n-3\n2\n2\n```\n\nFeel free to adapt the error handling to suit your application's requirements."]}
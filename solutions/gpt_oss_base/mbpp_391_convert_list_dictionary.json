{"name": "mbpp_391_convert_list_dictionary", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to convert more than one vector to nested map.\nstd::vector<std::map<std::string,std::map<std::string,long>>> convert_list_dictionary(std::vector<std::string> l1, std::vector<std::string> l2, std::vector<long> l3) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_391_convert_list_dictionary.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = convert_list_dictionary;\n    assert(candidate((std::vector<std::string>({(std::string)\"S001\", (std::string)\"S002\", (std::string)\"S003\", (std::string)\"S004\"})), (std::vector<std::string>({(std::string)\"Adina Park\", (std::string)\"Leyton Marsh\", (std::string)\"Duncan Boyle\", (std::string)\"Saim Richards\"})), (std::vector<long>({(long)85, (long)98, (long)89, (long)92}))) == (std::vector<std::map<std::string,std::map<std::string,long>>>({(std::map<std::string,std::map<std::string,long>>)std::map<std::string,std::map<std::string,long>>({{\"S001\", std::map<std::string,long>({{\"Adina Park\", 85}})}}), (std::map<std::string,std::map<std::string,long>>)std::map<std::string,std::map<std::string,long>>({{\"S002\", std::map<std::string,long>({{\"Leyton Marsh\", 98}})}}), (std::map<std::string,std::map<std::string,long>>)std::map<std::string,std::map<std::string,long>>({{\"S003\", std::map<std::string,long>({{\"Duncan Boyle\", 89}})}}), (std::map<std::string,std::map<std::string,long>>)std::map<std::string,std::map<std::string,long>>({{\"S004\", std::map<std::string,long>({{\"Saim Richards\", 92}})}})})));\n    assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"def\", (std::string)\"ghi\", (std::string)\"jkl\"})), (std::vector<std::string>({(std::string)\"python\", (std::string)\"program\", (std::string)\"language\", (std::string)\"programs\"})), (std::vector<long>({(long)100, (long)200, (long)300, (long)400}))) == (std::vector<std::map<std::string,std::map<std::string,long>>>({(std::map<std::string,std::map<std::string,long>>)std::map<std::string,std::map<std::string,long>>({{\"abc\", std::map<std::string,long>({{\"python\", 100}})}}), (std::map<std::string,std::map<std::string,long>>)std::map<std::string,std::map<std::string,long>>({{\"def\", std::map<std::string,long>({{\"program\", 200}})}}), (std::map<std::string,std::map<std::string,long>>)std::map<std::string,std::map<std::string,long>>({{\"ghi\", std::map<std::string,long>({{\"language\", 300}})}}), (std::map<std::string,std::map<std::string,long>>)std::map<std::string,std::map<std::string,long>>({{\"jkl\", std::map<std::string,long>({{\"programs\", 400}})}})})));\n    assert(candidate((std::vector<std::string>({(std::string)\"A1\", (std::string)\"A2\", (std::string)\"A3\", (std::string)\"A4\"})), (std::vector<std::string>({(std::string)\"java\", (std::string)\"C\", (std::string)\"C++\", (std::string)\"DBMS\"})), (std::vector<long>({(long)10, (long)20, (long)30, (long)40}))) == (std::vector<std::map<std::string,std::map<std::string,long>>>({(std::map<std::string,std::map<std::string,long>>)std::map<std::string,std::map<std::string,long>>({{\"A1\", std::map<std::string,long>({{\"java\", 10}})}}), (std::map<std::string,std::map<std::string,long>>)std::map<std::string,std::map<std::string,long>>({{\"A2\", std::map<std::string,long>({{\"C\", 20}})}}), (std::map<std::string,std::map<std::string,long>>)std::map<std::string,std::map<std::string,long>>({{\"A3\", std::map<std::string,long>({{\"C++\", 30}})}}), (std::map<std::string,std::map<std::string,long>>)std::map<std::string,std::map<std::string,long>>({{\"A4\", std::map<std::string,long>({{\"DBMS\", 40}})}})})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a compact, self\u2011contained implementation that turns three parallel vectors  \n`l1`, `l2` and `l3` into a **nested map** of the form\n\n```\nstd::vector<std::map<std::string,\n                    std::map<std::string,long>>>\n```\n\nEach element in the `std::vector` corresponds to one \u201crow\u201d of data, i.e. the\n* i \u2013th element holds a `map` keyed by the `l1[i]` value; that key maps to\nanother `map` whose key is `l2[i]` and value is `l3[i]`.\n\n```cpp\n#include <vector>\n#include <map>\n#include <string>\n#include <stdexcept>\n\n// ------------------------------------------------------------------------\n// convert_list_dictionary\n//\n// Parameters\n//   l1 \u2013 vector of first\u2011level keys\n//   l2 \u2013 vector of second\u2011level keys (must be the same length)\n//   l3 \u2013 vector of the associated long values (must be the same length)\n// ------------------------------------------------------------------------\ninline std::vector<std::map<std::string,\n                            std::map<std::string,long>>>\nconvert_list_dictionary(const std::vector<std::string>& l1,\n                        const std::vector<std::string>& l2,\n                        const std::vector<long>&         l3)\n{\n    // 1. Sanity check \u2013 all input vectors must have the same size\n    if (l1.size() != l2.size() || l1.size() != l3.size())\n        throw std::invalid_argument(\"All input vectors must have the same size\");\n\n    // 2. Prepare result container\n    std::vector<std::map<std::string,\n                         std::map<std::string,long>>> result;\n    result.reserve(l1.size());   // reserve to avoid repeated reallocations\n\n    // 3. Build the nested maps row by row\n    for (size_t i = 0; i < l1.size(); ++i)\n    {\n        std::map<std::string,long> inner;\n        inner[l2[i]] = l3[i];           // second\u2011level key \u2192 value\n\n        std::map<std::string,\n                 std::map<std::string,long>> outer;\n        outer[l1[i]] = std::move(inner); // first\u2011level key \u2192 inner map\n\n        result.emplace_back(std::move(outer));\n    }\n\n    return result;\n}\n```\n\n### Why this implementation?\n\n| Requirement | How it is satisfied |\n|-------------|---------------------|\n| **Fast** | `reserve` prevents re\u2011allocations; `std::move` avoids copies |\n| **Robust** | The function checks that all three vectors have equal length and throws a clear exception otherwise |\n| **Clear** | Uses named intermediate variables (`inner`, `outer`) and descriptive comments |\n| **Portable** | Only standard library containers and C++14/17 features are used |\n\n### Example usage\n\n```cpp\n#include <iostream>\n#include <iomanip>\n\nint main()\n{\n    std::vector<std::string> l1 = {\"group1\", \"group2\", \"group1\"};\n    std::vector<std::string> l2 = {\"itemA\", \"itemB\", \"itemC\"};\n    std::vector<long>        l3 = {10, 20, 30};\n\n    auto v = convert_list_dictionary(l1, l2, l3);\n\n    // Pretty\u2011print the result\n    for (const auto& outer : v)\n    {\n        for (const auto& pair1 : outer)\n        {\n            std::cout << pair1.first << \" => {\\n\";\n            for (const auto& pair2 : pair1.second)\n            {\n                std::cout << \"  \" << pair2.first\n                          << \" : \" << pair2.second << \"\\n\";\n            }\n            std::cout << \"}\\n\";\n        }\n    }\n}\n```\n\nRunning the program will output:\n\n```\ngroup1 => {\n  itemA : 10\n}\ngroup2 => {\n  itemB : 20\n}\ngroup1 => {\n  itemC : 30\n}\n```\n\nFeel free to modify the function to suit any particular ordering, uniqueness or merging policy you might need.", "Below is a minimal, self\u2011contained implementation that does exactly what you asked for:\n\n```cpp\n#include <vector>\n#include <string>\n#include <map>\n\n/*\n *  convert_list_dictionary\n *\n *  Given three vectors of the same length:\n *      - l1: keys of the outer map (std::string)\n *      - l2: keys of the inner map (std::string)\n *      - l3: values of the inner map (long)\n *\n *  It builds a vector of maps such that each element of the\n *  vector contains one nested map:\n *      { l1[i] -> { l2[i] -> l3[i] } }\n *\n *  Assumptions:\n *      \u2022 All three input vectors have the same size.\n *      \u2022 l1, l2 and l3 are non\u2011empty.\n *\n *  Complexity:\n *      O(n) time and O(n) extra space, where n = l1.size().\n */\nstd::vector<std::map<std::string, std::map<std::string, long>>>\nconvert_list_dictionary(const std::vector<std::string>& l1,\n                        const std::vector<std::string>& l2,\n                        const std::vector<long>&       l3)\n{\n    // Basic input validation\n    if (l1.size() != l2.size() || l1.size() != l3.size())\n        throw std::invalid_argument(\"All input vectors must have identical length\");\n\n    std::vector<std::map<std::string, std::map<std::string, long>>> result;\n    result.reserve(l1.size());                    // avoid reallocations\n\n    for (size_t i = 0; i < l1.size(); ++i)\n    {\n        // inner map: { l2[i] -> l3[i] }\n        std::map<std::string, long> inner{ { l2[i], l3[i] } };\n\n        // outer map: { l1[i] -> inner }\n        std::map<std::string, std::map<std::string, long>> outer{ { l1[i], inner } };\n\n        result.push_back(std::move(outer));\n    }\n\n    return result;\n}\n```\n\n### Quick usage example\n\n```cpp\nint main()\n{\n    std::vector<std::string> l1 = {\"A\", \"B\", \"C\"};\n    std::vector<std::string> l2 = {\"x\", \"y\", \"z\"};\n    std::vector<long>       l3 = {10, 20, 30};\n\n    auto res = convert_list_dictionary(l1, l2, l3);\n\n    // Print the result\n    for (const auto& outer : res)\n    {\n        for (const auto& [k1, inner] : outer)\n        {\n            for (const auto& [k2, v] : inner)\n                std::cout << k1 << \" -> \" << k2 << \" : \" << v << '\\n';\n        }\n    }\n}\n```\n\nExpected output:\n\n```\nA -> x : 10\nB -> y : 20\nC -> z : 30\n```\n\nFeel free to drop the implementation into your project or tweak it if you need a different layout (e.g., a single nested map instead of a vector of maps).", "Here is a compact, self\u2011contained implementation that turns three parallel vectors (`l1`, `l2` and `l3`) into a **vector of nested maps**.  \nThe outer vector holds a map for every record;  \nthe outer map is keyed by the value from `l1`,  \nand contains an inner map that is keyed by the element from `l2` with the\ncorresponding `long` value taken from `l3`.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <cassert>\n\n/*\n * Given three vectors of equal size:\n *   \u2022 l1 - keys of the outer map\n *   \u2022 l2 - keys of the inner map\n *   \u2022 l3 - values for the inner map\n *\n * The function builds a vector where each element is a map<std::string,\n *              std::map<std::string,long>> representing one record.\n *\n * Example:\n *   l1 = {\"a\",\"b\"}\n *   l2 = {\"x\",\"y\"}\n *   l3 = {10,20}\n *\n * The result will be:\n *   [ {\"a\" : { \"x\" : 10 }},\n *     {\"b\" : { \"y\" : 20 }} ]\n */\nstd::vector<std::map<std::string, std::map<std::string, long>>>\nconvert_list_dictionary(const std::vector<std::string>& l1,\n                        const std::vector<std::string>& l2,\n                        const std::vector<long>& l3)\n{\n    // Quick sanity check \u2013 all input vectors must have the same length.\n    assert(!l1.empty() && l1.size() == l2.size() && l1.size() == l3.size());\n\n    std::vector<std::map<std::string, std::map<std::string, long>>> result;\n    result.reserve(l1.size());\n\n    for (size_t i = 0; i < l1.size(); ++i) {\n        // Build the inner map for this record.\n        std::map<std::string, long> inner;\n        inner[l2[i]] = l3[i];\n\n        // Build the outer map that has a single key (l1[i]).\n        std::map<std::string, std::map<std::string, long>> outer;\n        outer[l1[i]] = inner;\n\n        result.emplace_back(std::move(outer));\n    }\n    return result;\n}\n\n/* ----------  Demo: How to use the conversion function ---------- */\nint main()\n{\n    std::vector<std::string> l1 = {\"alpha\", \"beta\", \"gamma\"};\n    std::vector<std::string> l2 = {\"x\", \"y\", \"z\"};\n    std::vector<long>        l3 = {100, 200, 300};\n\n    auto nested = convert_list_dictionary(l1, l2, l3);\n\n    // Print the structure to verify.\n    for (const auto& outer_map : nested) {\n        for (const auto& outer_pair : outer_map) {\n            std::cout << outer_pair.first << \" : { \";\n            for (const auto& inner_pair : outer_pair.second) {\n                std::cout << inner_pair.first << \" = \" << inner_pair.second << \" \";\n            }\n            std::cout << \"}\\n\";\n        }\n    }\n    return 0;\n}\n```\n\n### What the code does\n\n1. **Validation** \u2013 Asserts that the three vectors are non\u2011empty and share the same length.\n2. **Loop** \u2013 Iterates over the indices of the vectors.\n3. **Inner map** \u2013 Stores `l2[i]` \u2192 `l3[i]`.\n4. **Outer map** \u2013 Stores `l1[i]` \u2192 the inner map created in step\u202f3.\n5. **Convenience** \u2013 The outer vector holds each outer map separately, which keeps the function flexible (you can return a single map if that\u2019s all you need).\n\nFeel free to adjust the return type if you prefer a single combined map or other data structures."]}
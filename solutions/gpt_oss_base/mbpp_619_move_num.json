{"name": "mbpp_619_move_num", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to move all the numbers to the end of the given string.\nstd::string move_num(std::string test_str) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_619_move_num.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = move_num;\n    assert(candidate((\"I1love143you55three3000thousand\")) == (\"Iloveyouthreethousand1143553000\"));\n    assert(candidate((\"Avengers124Assemble\")) == (\"AvengersAssemble124\"));\n    assert(candidate((\"Its11our12path13to14see15things16do17things\")) == (\"Itsourpathtoseethingsdothings11121314151617\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a complete, self\u2011contained implementation of the requested function.   \nThe function keeps the relative order of the alphabetic characters and the numeric characters, but all the numerals are moved to the very end of the resulting string.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Move all digits to the end while preserving the order of letters and digits\nstd::string move_num(const std::string& test_str) {\n    string letters;   // to hold all non\u2011digit characters\n    string digits;    // to hold all digit characters\n\n    for (char ch : test_str) {\n        if (isdigit(static_cast<unsigned char>(ch))) {\n            digits.push_back(ch);          // keep order\n        } else {\n            letters.push_back(ch);         // keep order\n        }\n    }\n    // Concatenate non\u2011digits first, then digits\n    return letters + digits;\n}\n\n// ------------------------------------------------------------------\n// Simple test harness \u2013 not required, but useful for quick checks\n// ------------------------------------------------------------------\n#ifdef LOCAL\nint main() {\n    vector<string> tests = {\n        \"a1b2c3\",\n        \"123abc\",\n        \"abc\",\n        \"a!@#1$2\",\n        \"\",\n        \"0a0b0\"\n    };\n    for (auto& s : tests) {\n        cout << \"\\\"\" << s << \"\\\" \u2192 \\\"\" << move_num(s) << \"\\\"\\n\";\n    }\n}\n#endif\n```\n\n### How it works\n\n1. **Two temporary strings**  \n   - `letters`: stores every character that is **not** a digit.  \n   - `digits`: stores every digit (`'0'`\u2013`'9'`).  \n\n   Both strings retain the order in which the characters appear in the original string.\n\n2. **Iteration**  \n   For each character `ch` in `test_str`:\n   - If `ch` is a digit (`isdigit`), it is appended to `digits`.  \n   - Otherwise it is appended to `letters`.\n\n3. **Return** the concatenation `letters + digits`, which places all digits at the end.\n\n### Why it meets the requirements\n\n- **Preserves order**: Both letters and digits keep their relative order from the original string.  \n- **All numbers at the end**: By construction, all digits are stored in `digits` and appended after `letters`.  \n- **No side\u2011effects on the input**: The input string is taken by const reference and never modified.  \n\nFeel free to drop the test harness (`#ifdef LOCAL \u2026`) into your project or adapt it as you wish.", "Below is a complete, minimal, and well\u2011commented implementation of `move_num`.  \nThe function keeps the relative order of the non\u2011digit characters and concatenates all digits **as they appear** at the end of the string.\n\n```cpp\n#include <string>\n#include <cctype>           // std::isdigit\n#include <algorithm>        // std::erase_if (C++20) / std::remove_if\n\n/*  move_num\n *  ----------------------------\n *  Moves all digit characters (0\u20119) in the input string to its end,\n *  preserving the order of both the non\u2011digits and the digits.\n *\n *  Example:\n *      \"ab12cd3\" -> \"abcd123\"\n *\n *  Complexity:\n *      O(n) time, O(n) additional space\n *\n *  Note: Uses only the C++ Standard Library; no platform\u2011specific headers.\n */\nstd::string move_num(const std::string &s)\n{\n    std::string non_digits;\n    std::string digits;\n\n    non_digits.reserve(s.size());\n    digits.reserve(s.size());\n\n    for (char c : s) {\n        if (std::isdigit(static_cast<unsigned char>(c)))  // safe for signed char\n            digits.push_back(c);\n        else\n            non_digits.push_back(c);\n    }\n\n    return non_digits + digits;\n}\n```\n\n### Why this implementation?\n\n| Requirement | How it\u2019s satisfied |\n|-------------|--------------------|\n| **All digits at the end** | Each character is inspected once and placed in `digits`. |\n| **Order preserved** | We simply `push_back` keeping the order during the scan. |\n| **No side\u2011effects** | The function is `const`\u2011qualified and does not modify the input string. |\n| **Standard C++** | Only `<string>` and `<cctype>` are required (both part of the C++ standard). |\n\n### Usage example\n\n```cpp\n#include <iostream>\nint main() {\n    std::string input = \"A1B2C3D\";\n    std::cout << move_num(input);   // Output: \"ABCD123\"\n}\n```\n\nFeel free to adapt the function if you need additional constraints (e.g., treating locale\u2011specific digits).", "Below is a clean, self\u2011contained implementation of **`move_num`** that takes a string and moves all digits (`0`\u2011`9`) to the end while keeping the relative ordering of both digits and non\u2011digits intact.  \n\n```cpp\n#include <string>\n#include <cctype>\n\n// Move all numeric characters to the end of the string.\n// The relative order of letters and digits is preserved.\nstd::string move_num(const std::string& test_str)\n{\n    std::string letters;   // will hold all non\u2011digit characters\n    std::string digits;    // will hold all digit characters\n\n    // Scan the string once, separating the characters.\n    for (char ch : test_str) {\n        if (std::isdigit(static_cast<unsigned char>(ch)))\n            digits.push_back(ch);          // collect digits\n        else\n            letters.push_back(ch);         // collect the rest\n    }\n\n    // Concatenate: non\u2011digits first, digits second.\n    return letters + digits;\n}\n```\n\n**Explanation**\n\n1. **Separation** \u2013 The loop walks through the string once, placing each character into either `letters` (non\u2011digits) or `digits` (digits).  \n2. **Character classification** \u2013 `std::isdigit` requires an `unsigned char` cast to avoid undefined behaviour for negative `char`.  \n3. **Result** \u2013 Concatenating `letters` with `digits` yields the desired string.  \n\nThis function works for any mixture of ASCII characters, spaces, punctuation, etc., and runs in linear time \\(O(n)\\) with linear additional space."]}
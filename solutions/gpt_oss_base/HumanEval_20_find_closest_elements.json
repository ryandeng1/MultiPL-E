{"name": "HumanEval_20_find_closest_elements", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_20_find_closest_elements.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = find_closest_elements;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(3.9f, 4.0f)));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f}))) == (std::make_tuple(5.0f, 5.9f)));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(2.0f, 2.2f)));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f}))) == (std::make_tuple(2.0f, 2.0f)));\n    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f}))) == (std::make_tuple(2.2f, 3.1f)));\n}\n", "stop_tokens": ["\n}"], "completions": ["```cpp\n#include <algorithm>\n#include <tuple>\n#include <vector>\n#include <cmath>\n\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers)\n{\n    // The problem statement guarantees that the vector has at least two elements.\n    // However, we guard against an empty vector for robustness.\n    if (numbers.size() < 2)\n        throw std::invalid_argument(\"Input vector must contain at least two elements.\");\n\n    // Sort the numbers \u2013 this makes it trivial to find the smallest gap\n    std::sort(numbers.begin(), numbers.end());\n\n    // Initialize best distance with the first adjacent pair.\n    float best_dist = std::abs(numbers[1] - numbers[0]);\n    float a = numbers[0];\n    float b = numbers[1];\n\n    // Scan the sorted array looking for a smaller distance.\n    for (std::size_t i = 1; i + 1 < numbers.size(); ++i)\n    {\n        float dist = std::abs(numbers[i + 1] - numbers[i]);\n        if (dist < best_dist)\n        {\n            best_dist = dist;\n            a = numbers[i];\n            b = numbers[i + 1];\n        }\n    }\n\n    // In case of duplicate values, best_dist can be zero, which is fine.\n    // Return the pair in ascending order \u2013 already guaranteed by sorting.\n    return std::make_tuple(a, b);\n}\n```\n\n## Explanation\n\n1. **Sorting** \u2013 After sorting, the two numbers that are closest to each other must be neighbours in the sorted list.  \n2. **Scan** \u2013 Loop through adjacent pairs, track the minimum distance and keep the corresponding pair.  \n3. **Return** \u2013 The pair is returned as a `std::tuple<float, float>` with the smaller value first (the sorted order guarantees this).\n\nThe function handles all corner cases: duplicate values, negatives, floating\u2011point numbers, etc.", "Here is a clean, self\u2011contained implementation that works for any numeric type (int, float, double, etc.) and follows the behaviour described in the doc\u2011string. The function:\n\n1. **Validates** that the input vector has at least two elements.  \n2. **Finds** the pair of numbers with the smallest absolute difference.  \n3. **Returns** the pair in ascending order as a `std::tuple`.\n\n```cpp\n#include <tuple>\n#include <vector>\n#include <stdexcept>\n#include <limits>\n#include <algorithm>\n\n/*------------------------------------------------------------------\n  Return a tuple containing the two numbers in `numbers` that are\n  numerically closest to each other.  The tuple is ordered\n  (smaller, larger).\n------------------------------------------------------------------*/\ntemplate <typename T>\nstd::tuple<T, T> find_closest_elements(std::vector<T> numbers)\n{\n    // 1. Validation\n    if (numbers.size() < 2)\n        throw std::invalid_argument(\"find_closest_elements requires at least two elements\");\n\n    // 2. Find the pair with the smallest difference\n    T bestA = numbers[0], bestB = numbers[1];\n    T bestDiff = std::numeric_limits<T>::infinity();\n\n    for (size_t i = 0; i < numbers.size(); ++i)\n    {\n        for (size_t j = i + 1; j < numbers.size(); ++j)\n        {\n            T diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < bestDiff)\n            {\n                bestDiff = diff;\n                bestA = numbers[i];\n                bestB = numbers[j];\n            }\n        }\n    }\n\n    // 3. Order the result\n    if (bestA > bestB) std::swap(bestA, bestB);\n    return std::make_tuple(bestA, bestB);\n}\n```\n\n### Why this implementation?\n\n| Feature | Design choice | Reason |\n|---------|---------------|--------|\n| **Template** | `template <typename T>` | Works with any arithmetic type. |\n| **Exception** | `std::invalid_argument` | Signals misuse clearly. |\n| **Brute\u2011force O(n\u00b2)** | Nested loops | Simplicity and correctness for moderate `n`. For very large vectors, a sort\u2011and\u2011scan O(n log n) approach can be used. |\n| **Infinity initial diff** | `std::numeric_limits<T>::infinity()` | Guarantees the first pair becomes the current best. |\n| **Ordering** | Swap if necessary | Guarantees the tuple is `(smaller, larger)` as required. |\n\n#### Example usage\n\n```cpp\nint main() {\n    auto r1 = find_closest_elements(std::vector<float>{1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 2.2f});\n    // r1 == (2.0f, 2.2f)\n\n    auto r2 = find_closest_elements(std::vector<float>{1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 2.0f});\n    // r2 == (2.0f, 2.0f)\n}\n```\n\nFeel free to replace the double loop with a sort\u2011and\u2011scan implementation if you expect large input sizes.", "Here is a simple, efficient implementation that follows the specification:\n\n```cpp\n#include <cassert>\n#include <algorithm>\n#include <tuple>\n#include <vector>\n\n/// Find the two numbers that are the closest to each other in `numbers`,  \n/// and return them as a tuple `(smaller, larger)`.\n/// The input vector must contain at least two elements.\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers)\n{\n    // Sanity check \u2013 the contract says the vector has at least two values\n    assert(numbers.size() >= 2u);\n\n    // Sort the vector so that adjacent elements are the only candidates\n    // that can be the closest pair.\n    std::sort(numbers.begin(), numbers.end());\n\n    // Initialise with the first pair.\n    float bestDiff = numbers[1] - numbers[0];\n    float first = numbers[0];\n    float second = numbers[1];\n\n    // Scan the sorted array and keep the minimal difference pair\n    for (size_t i = 2; i < numbers.size(); ++i)\n    {\n        float diff = numbers[i] - numbers[i-1];\n        if (diff < bestDiff)\n        {\n            bestDiff = diff;\n            first = numbers[i-1];\n            second = numbers[i];\n        }\n    }\n\n    return std::make_tuple(first, second);\n}\n```\n\n### How it works\n\n1. **Sorting** \u2013 After sorting, the nearest neighbours in the sorted list are the only candidates for the minimal difference.  \n2. **Linear scan** \u2013 A single pass finds the pair with the smallest absolute difference.  \n3. **Return value** \u2013 We always return the smaller number first, as required.\n\n### Example usage\n\n```cpp\n#include <iostream>\n#include <iomanip>\n\nint main()\n{\n    auto [a, b] = find_closest_elements(\n        {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 2.2f});\n    std::cout << std::setprecision(1) << a << \", \" << b << '\\n'; // 2.0, 2.2\n\n    auto [c, d] = find_closest_elements(\n        {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 2.0f});\n    std::cout << c << \", \" << d << '\\n'; // 2.0, 2.0\n}\n```\n\nThe algorithm runs in `O(n log n)` time due to the sort, with `O(1)` additional space beyond the input vector."]}
{"name": "mbpp_131_reverse_vowels", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to reverse only the vowels of a given string (where y is not a vowel).\nstd::string reverse_vowels(std::string str1) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_131_reverse_vowels.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = reverse_vowels;\n    assert(candidate((\"Python\")) == (\"Python\"));\n    assert(candidate((\"USA\")) == (\"ASU\"));\n    assert(candidate((\"ab\")) == (\"ab\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// reverse only the vowels of a given string (y is *not* considered a vowel)\nstring reverse_vowels(string str1)\n{\n    // helper lambda to test if a character is a vowel (lower\u2011 or upper\u2011case)\n    auto is_vowel = [](char c) -> bool {\n        static const string vowels = \"aeiouAEIOU\";\n        return vowels.find(c) != string::npos;\n    };\n\n    int i = 0;                 // left pointer\n    int j = (int)str1.size() - 1; // right pointer\n\n    while (i < j) {\n        while (i < j && !is_vowel(str1[i])) ++i; // move rightwards until a vowel\n        while (i < j && !is_vowel(str1[j])) --j; // move leftwards until a vowel\n\n        if (i < j) {            // swap the two vowels\n            swap(str1[i], str1[j]);\n            ++i;\n            --j;\n        }\n    }\n    return str1;\n}\n\n/*  Example usage\n\nint main() {\n    string s = \"hello world\";\n    cout << reverse_vowels(s) << '\\n';   // \"holle warld\"\n}\n*/\n```", "Here\u2019s a simple, self\u2011contained **C++** implementation that reverses only the vowels of a string (with `y` **not** treated as a vowel).  \nThe function works in **O(n)** time and uses only a couple of auxiliary pointers.\n\n```cpp\n#include <string>\n#include <cctype>   // for std::tolower\n\n// Reverse only the vowels of the input string.\n// (y is *not* considered a vowel)\n/*\n    Example:\n        reverse_vowels(\"hello\")     \u2192 \"holle\"\n        reverse_vowels(\"algorithm\") \u2192 \"algorihmt\"\n*/\nstd::string reverse_vowels(const std::string& str)\n{\n    // Helper lambda \u2013 true if c is a vowel (case\u2011insensitive)\n    auto is_vowel = [](char c) {\n        c = static_cast<char>(std::tolower(static_cast<unsigned char>(c)));\n        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n    };\n\n    std::string res = str;   // Work on a copy so the input stays untouched\n    std::size_t left  = 0;\n    std::size_t right = res.size() - 1;\n\n    while (left < right) {\n        // Move left forward until we hit a vowel\n        while (left < right && !is_vowel(res[left]))  ++left;\n        // Move right backward until we hit a vowel\n        while (left < right && !is_vowel(res[right])) --right;\n\n        // If both point to vowels, swap them\n        if (left < right) {\n            std::swap(res[left], res[right]);\n            ++left;\n            --right;\n        }\n    }\n\n    return res;\n}\n```\n\n### How it works\n1. **Identification of vowels** \u2013 The lambda `is_vowel` treats `a, e, i, o, u` as vowels, ignoring case.  \n2. Two indices (`left` & `right`) scan the string from both ends.  \n3. Whenever a vowel is found at either end, the indices stop.  \n4. If both indices point to vowels, the characters are swapped.  \n5. The indices then move inward and the process repeats until they cross.\n\n### Notes\n- The function returns a new string; the input string is **not** modified.  \n- Complexity: **O(n)** time, **O(n)** auxiliary space for the copy (no extra memory beyond the string itself).  \n\nFeel free to drop this into your project or integrate it into a larger code base!", "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Reverse only the vowels of a given string (y is not considered a vowel).\nstring reverse_vowels(const string& s) {\n    string res = s;                      // work on a copy\n    auto is_vowel = [](char c) -> bool {\n        c = static_cast<char>(tolower(c));\n        return c=='a' || c=='e' || c=='i' || c=='o' || c=='u';\n    };\n\n    int l = 0, r = static_cast<int>(res.size()) - 1;\n    while (l < r) {\n        while (l < r && !is_vowel(res[l])) ++l;   // find left vowel\n        while (l < r && !is_vowel(res[r])) --r;   // find right vowel\n        if (l < r) {\n            swap(res[l], res[r]);                 // swap the vowels\n            ++l;\n            --r;\n        }\n    }\n    return res;\n}\n```\n\n**Usage example**\n\n```cpp\nint main() {\n    string str = \"programming\";\n    cout << reverse_vowels(str) << '\\n'; // prints \"prigrammong\"\n}\n```\n\nThis function copies the input string, uses a simple lambda to test for vowels (case\u2011insensitive), and swaps vowels from the two ends until the pointers meet. Only vowels (a, e, i, o, u) are reversed; all other characters stay in their original positions."]}
{"name": "mbpp_168_frequency", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to count the number of occurrences of a number in a given vector.\nlong frequency(std::vector<long> a, long x) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_168_frequency.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = frequency;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (4)) == (0));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4})), (3)) == (3));\n    assert(candidate((std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)1, (long)2})), (1)) == (2));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a minimal, self\u2011contained implementation of the `frequency` function that does exactly what you asked for:\n\n```cpp\n#include <vector>\n#include <algorithm>   // for std::count\n\n// Count how many times the value `x` appears in the vector `a`.\n// The function takes `a` by value so that the original vector is not modified,\n// but the size of the vector is also passed so that we can use the reference\n// overload of std::count without any unnecessary copying of the data.\nlong frequency(std::vector<long> a, long x) {\n    // std::count works on RandomAccessIterators.  Since `a` is a vector,\n    // we can simply give it begin() and end().\n    return static_cast<long>(std::count(a.begin(), a.end(), x));\n}\n```\n\n### Why this version is nice\n\n* **No manual loops** \u2013 we delegate the counting to the standard library, which is heavily optimised.\n* **Return type** \u2013 the function returns a `long`, matching your signature.  \n  The result of `std::count` is `size_t`, so we cast it back to `long`.  \n  (If you wanted to avoid the cast you could change the return type to `size_t`.)\n* **By\u2011value input** \u2013 as requested, the vector is taken by value so the original array is left intact.  \n  If you\u2019re worried about copying large vectors, you can take it by\u2010const\u2011reference and still keep the function\u2019s behaviour unchanged.\n\n### Example usage\n\n```cpp\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<long> v{1, 2, 3, 2, 4, 2, 5};\n    long count_of_twos = frequency(v, 2);\n    std::cout << \"Number of 2\u2019s: \" << count_of_twos << '\\n'; // prints 3\n    return 0;\n}\n```\n\nThis should compile with any modern C++ compiler (C++11 or newer).", "Here\u2019s a clean, idiomatic implementation of the requested `frequency` helper:\n\n```cpp\n/// Counts how many times the value `x` appears in the vector `a`.\n/// @param a  The source vector (passed by const reference to avoid copying).\n/// @param x  The value we want to count.\n/// @return   The number of occurrences of `x` in `a`.\nlong frequency(const std::vector<long>& a, long x)\n{\n    long cnt = 0;\n    for (long v : a)\n        if (v == x)\n            ++cnt;\n    return cnt;\n}\n```\n\n### Why this version is preferable\n\n1. **`const std::vector<long>&`** \u2013 The vector is passed by constant reference, so we avoid an expensive copy that would happen with a plain `std::vector<long>` parameter.\n2. **Range\u2011based `for`** \u2013 It\u2019s concise, readable, and safe (no off\u2011by\u2011one errors).\n3. **Straightforward logic** \u2013 A single `if` check inside the loop keeps the code simple and traceable.\n\n### Usage example\n\n```cpp\n#include <iostream>\n#include <vector>\n\nint main()\n{\n    std::vector<long> data{1, 2, 3, 2, 4, 2, 5};\n    long target = 2;\n\n    std::cout << \"Number \" << target << \" occurs \"\n              << frequency(data, target) << \" times.\\n\";\n    return 0;\n}\n```\n\nOutput:\n\n```\nNumber 2 occurs 3 times.\n```\n\nFeel free to drop this function into your project. It\u2019s portable, fast, and works for any `std::vector<long>` you throw at it.", "Here\u2019s a straightforward implementation that scans the vector once and counts how many times `x` appears:\n\n```cpp\n#include <vector>\n\nlong frequency(const std::vector<long>& a, long x) {\n    long cnt = 0;\n    for (const auto& val : a) {\n        if (val == x) ++cnt;\n    }\n    return cnt;\n}\n```\n\n### How it works\n\n1. **Pass by const reference** \u2013 The vector `a` is passed as a `const` reference to avoid copying it while still guaranteeing the caller\u2019s vector isn\u2019t modified.\n2. **Linear scan** \u2013 Each element in the vector is checked in turn.  \n   * If it matches `x`, the counter `cnt` is incremented.\n3. **Return the count** \u2013 After the loop finishes, `cnt` holds the number of occurrences of `x`.\n\n### Complexity\n\n* **Time**: O(n), where *n* is the size of the vector, because we inspect each element once.\n* **Space**: O(1) \u2013 only a single integer counter is used.\n\nYou can use it like this:\n\n```cpp\nint main() {\n    std::vector<long> vec = {1, 2, 3, 2, 4, 2};\n    long occ = frequency(vec, 2);   // occ == 3\n}\n```\n\nIf you need a more efficient solution for many repeated queries, you could preprocess the vector into an unordered_map that stores frequencies, but for a single call the simple linear scan is usually best."]}
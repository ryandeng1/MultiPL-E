{"name": "HumanEval_34_unique", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_34_unique.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = unique;\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123})));\n}\n", "stop_tokens": ["\n}"], "completions": ["```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Return a vector with all the unique elements of `l` sorted increasingly.\nvector<long> unique(vector<long> l) {\n    // Use a set to automatically drop duplicates and sort.\n    // We keep a copy of the elements in a set, then copy back to a vector.\n    std::set<long> st(l.begin(), l.end());          // construct set from vector\n    return std::vector<long>(st.begin(), st.end()); // copy into vector\n}\n\n// Simple test to check the function works as expected\n#ifdef UNIT_TEST\nint main() {\n    vector<long> inp{5, 3, 5, 2, 3, 3, 9, 0, 123};\n    vector<long> expected{0, 2, 3, 5, 9, 123};\n\n    vector<long> result = unique(inp);\n    assert(result == expected);\n\n    cout << \"All tests passed!\\n\";\n    return 0;\n}\n#endif\n```\n\n**Explanation**\n\n1. **Constructors**: `std::set` automatically removes duplicates and stores its elements in ascending order.  \n2. **Conversion**: After inserting all elements from the input vector into the set, we create a new vector by copying the set's iterators, giving us the desired unique sorted result.  \n3. **Testing**: The `UNIT_TEST` block (enabled with `-DUNIT_TEST`) demonstrates a quick sanity check using `assert`.", "Here\u2019s a small, self\u2011contained implementation that takes a vector of `long`, removes duplicates and returns a **sorted** vector containing each element only once.\n\n```cpp\n#include <algorithm>\n#include <vector>\n\n/*  Return a vector that contains the unique elements \n    of `l`, sorted in ascending order.\n*/\nstd::vector<long> unique(std::vector<long> l)\n{\n    // Step 1 \u2013 sort the input\n    std::sort(l.begin(), l.end());\n\n    // Step 2 \u2013 erase duplicates in\u2011place\n    auto last = std::unique(l.begin(), l.end());\n    l.erase(last, l.end());          // keep only the first occurrences\n\n    return l;                        // already sorted, unique\n}\n```\n\n### Why this works\n1. **`std::sort`**orders the elements, which is required for `std::unique` to work correctly.\n2. **`std::unique`** rewrites the vector so that each unique element appears only once at the beginning; it returns an iterator to the new logical end.\n3. **`erase`** removes the trailing duplicate elements, leaving a clean, sorted vector.\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<long> v = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    auto res = unique(v);\n\n    for (long x : res)\n        std::cout << x << ' ';\n    // Output: 0 2 3 5 9 123\n}\n```\n\nFeel free to adapt this snippet to fit your coding style or constraints (e.g., passing by reference to avoid copying).", "```cpp\n#include <vector>\n#include <algorithm>\n\n/*\n * Return a sorted vector that contains only the unique\n * elements from the input vector `l`.\n *\n * Example\n * -------\n * auto res = unique({5,3,5,2,3,3,9,0,123});\n * // res == {0,2,3,5,9,123}\n */\nstd::vector<long> unique(std::vector<long> l) {\n    // 1. Sort the vector so that equal elements are adjacent\n    std::sort(l.begin(), l.end());\n\n    // 2. Remove duplicates in\u2011place (`std::unique` just reorders the\n    //    unique elements to the front and returns an iterator to the\n    //    new logical end).\n    auto new_end = std::unique(l.begin(), l.end());\n\n    // 3. Erase the trailing duplicate elements\n    l.erase(new_end, l.end());\n\n    return l;\n}\n```\n\n### How it works\n\n| Step | Command | What it does |\n|------|---------|--------------|\n| 1 | `std::sort(l.begin(), l.end());` | Tells the compiler to order the elements. After this call `5,5,3,3,3,2,9,0,123` becomes `0,2,3,3,3,5,5,9,123`. |\n| 2 | `auto new_end = std::unique(l.begin(), l.end());` | Moves all distinct values to the front and returns an iterator (`new_end`) that points just past the last unique element. The vector now looks like `0,2,3,5,9,123,5,9,123`. |\n| 3 | `l.erase(new_end, l.end());` | Deletes everything from `new_end` to the actual end of the vector, leaving a clean, sorted vector of unique values. |\n\nThe function respects the original type (`long`) and returns a **new** vector (the original is not modified). It also works for an empty input vector."]}
{"name": "mbpp_735_toggle_middle_bits", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to toggle bits of the number except the first and the last bit. https://www.geeksforgeeks.org/toggle-bits-number-expect-first-last-bits/\nlong toggle_middle_bits(long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_735_toggle_middle_bits.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = toggle_middle_bits;\n    assert(candidate((9)) == (15));\n    assert(candidate((10)) == (12));\n    assert(candidate((11)) == (13));\n    assert(candidate((65)) == (127));\n    assert(candidate((77)) == (115));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a compact, **stand\u2011alone** implementation of `toggle_middle_bits`.  \nIt works on a 64\u2011bit unsigned integer (`long long`).  \nThe algorithm:\n\n1. **Determine** how many bits the number occupies (`len`).\n2. **Iterate** over all bits *except* the most\u2011significant and least\u2011significant bits.\n3. **Toggle** each of those bits by XORing with a single\u2011bit mask.\n4. Return the updated value.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n * Toggles all bits of `n` except the first (most\u2011significant) and the last\n * (least\u2011significant) bit.\n *\n * Example:\n *   n = 10111001 (binary)\n *   -> result = 10101101\n *\n * The function works for any non\u2011negative integer that fits in a 64\u2011bit long.\n */\nlong long toggle_middle_bits(long long n)\n{\n    /* Corner cases: 0, 1 or 2\u2011bit numbers cannot have any \u201cmiddle\u201d bits. */\n    if (n <= 1) return n;                  // 0 or 1  -> nothing to toggle\n    if (n == 3) return 3;                 // 11b  -> only ends, nothing extra\n\n    /* Count actual bits (position of the MSB + 1). 128-bit or greater numbers\n       can be handled simply by expanding the type, but 64\u2011bit is enough for the\n       problem statement. */\n    int len = 0;\n    long long tmp = n;\n    while (tmp) {\n        ++len;\n        tmp >>= 1;\n    }\n\n    /* We only need to toggle bits from position 1 to len\u20112 (0\u2011based). */\n    for (int i = 1; i <= len - 2; ++i) {\n        n ^= (1LL << i);   // toggle bit i\n    }\n\n    return n;\n}\n\n/* Simple test harness */\nint main() {\n    vector<long long> test = {0b10111001, 0b10, 0b1001, 0b111, 0b101010};\n    for (auto v : test) {\n        cout << std::bitset<8>(v) << \" -> \"\n             << std::bitset<8>(toggle_middle_bits(v)) << \"\\n\";\n    }\n    return 0;\n}\n```\n\n### How it works\n\n| Step | Operation | Explanation |\n|------|-----------|-------------|\n| 1 | `len` calculation | Counts the position of the most\u2011significant bit (MSB). |\n| 2 | `for (int i = 1; i <= len - 2; ++i)` | Iterates over *middle* bits. |\n| 3 | `n ^= (1LL << i)` | XOR toggles a single bit (0 \u2192 1, 1 \u2192 0). |\n\n#### Edge cases\n\n* **0 or 1** \u2013 no middle bits \u2192 return unchanged.\n* **Two\u2011bit numbers** (`10b`, `01b`) \u2013 both bits are ends \u2192 unchanged.\n* **Binary `11b` (`3`)** \u2013 only the ends exist, no middle bits to toggle.\n\nThe function handles all valid 64\u2011bit inputs efficiently with no dynamic memory\nallocation, making it suitable for competitive programming or embedded\napplications.", "Below is a compact, comment\u2011rich implementation that follows the requirements:\n\n```cpp\n#include <cstdint>          // std::uint64_t\n#include <limits>           // std::numeric_limits\n\n/**\n * @brief Toggles all bits of `n` except the most significant and\n *        least significant bits.\n *\n * The function works for any unsigned integer type that is at\n * least 2 bits wide.  It uses a mask that contains `1`s on every\n * bit position between the first (most\u2011significant) and the last\n * (least\u2011significant) bit of `n`.  The mask is then XOR\u2011ed with\n * `n` to flip those bits.\n *\n * @param n The number whose middle bits have to be toggled.\n * @return The resulting number after toggling the middle bits.\n */\nstatic inline std::uint64_t toggle_middle_bits(std::uint64_t n)\n{\n    // Special case:  0 and 1 have no \u201cmiddle\u201d bits \u2013 just return them.\n    if (n <= 1ULL)\n        return n;\n\n    /* -----------------   Build the mask   -------------------- */\n    // Find the position of the most\u2011significant 1-bit.\n    const unsigned int msb_pos = static_cast<unsigned int>(std::numeric_limits<std::uint64_t>::digits - 1\n                                    - __builtin_clzll(n));  // clang/gcc builtin\n\n    // Build a mask that has 1s from bit 1 (second LSB) to bit msb_pos\u20111.\n    // Example for 8\u2011bit number:  msb_pos = 7\n    // mask = 0b01111110\n    std::uint64_t mask = 0;\n    if (msb_pos > 1) {            // There are middle bits to toggle\n        /* Create (1 << (msb_pos-1))-1 gives lower (msb_pos\u20111) bits set to 1.\n           Then left\u2011shift by 1 to clear the LSB.\n           Finally OR with 0 to keep the MSB 0. */\n        mask = ((1ULL << (msb_pos - 1)) - 1ULL) << 1;\n    }\n\n    /* ----------------  Toggle middle bits  ----------------- */\n    return n ^ mask;\n}\n```\n\n### How it works\n\n1. **Special cases** \u2013 If `n` is `0` or `1`, there are no middle bits, so we just return `n`.\n2. **Determine the most\u2011significant bit (MSB)** \u2013 Using GCC/Clang\u2019s builtin `__builtin_clzll`, we find the index (0\u2011based, LSB = 0) of the highest set bit.\n3. **Build the mask** \u2013  \n   * If the MSB is at position `k`, the middle bits are positions `1 \u2026 k\u20111`.  \n   * Create a block of `k-1` ones (`(1ULL << (k-1)) - 1`) and shift it left by one to leave the LSB clear.\n4. **Toggle** \u2013 XOR the original number with this mask: `result = n ^ mask`.\n\nFeel free to change the return type to `long` if you must match a particular signature, but using the unsigned integer type (`std::uint64_t`) is safer for bitwise manipulation.", "**Solution Explanation**\n\nFor a non\u2011negative integer `n` we want to invert every bit **except** the most\nsignificant bit (MSB) and the least significant bit (LSB).  \nThe order of the bits from left to right is\n\n```\nMSB  bit[7] bit[6] bit[5] bit[4] bit[3] bit[2] bit[1] LSB\n```\n\nIf `n` has only one bit (i.e. `n` is `0` or `1`) there are no\n\u201cmiddle\u201d bits and the result is `n` itself.\n\nFor all other numbers we can build a *mask* that has ones in all the\nexcept the two border positions and then toggle the bits by XOR.\n\n--------------------------------------------------------------------\n\n#### Algorithm\n\n```text\nif n <= 1:                     // only one bit present\n    return n\n\nbits   \u2190 floor(log2(n)) + 1    // number of bits of n\n\nleft   \u2190 1 << (bits-1)         // value with only the MSB set\nright  \u2190 1                      // value with only the LSB set\n\nmask   \u2190 ((1ULL << bits) - 1) ^ (left | right)\nreturn n ^ mask\n```\n\n* `((1ULL << bits) - 1)` creates a word with `bits` ones.\n* `left | right` keeps the two border ones.\n* XOR with the mask flips everything else.\n\nThe algorithm works in `O(1)` time and uses `O(1)` auxiliary space.\n\n--------------------------------------------------------------------\n\n#### Correctness Proof\n\nWe prove that the algorithm returns\nthe integer obtained from `n` by toggling every bit except the first\nand the last.\n\n*Lemma 1.*  \n`mask` has bit `1` **iff** the corresponding bit of `n` is a middle bit  \n(`2 \u2264 i \u2264 bits-1`).\n\n*Proof.*  \n`(1ULL << bits) - 1` has ones in all `bits` positions.\nRemoving the MSB and LSB by XOR with `(left | right)`\nsets all other positions to one and the two borders to zero.\n\u220e\n\n*Lemma 2.*  \nFor every middle position `i` the bit in the result is the complementation\nof the bit of `n`.\n\n*Proof.*  \nBy Lemma&nbsp;1, the mask has one at position `i`.  \nXOR with a one flips that bit, XOR with a zero keeps it unchanged.\nThus middle bits are toggled. \u220e\n\n*Lemma 3.*  \nThe MSB and LSB of the result equal the MSB and LSB of `n`.\n\n*Proof.*  \nMask has zero at those two positions, thus XOR does not change them. \u220e\n\n*Theorem.*  \n`toggle_middle_bits(n)` returns the integer whose binary representation\nis identical to that of `n` except that all middle bits are inverted.\n\n*Proof.*  \nBy Lemma&nbsp;2 the middle bits are inverted, by Lemma&nbsp;3 the border\nbits stay the same.  This is precisely the definition of the desired\nvalue. \u220e\n\n--------------------------------------------------------------------\n\n#### Complexity Analysis\n\nLet `B` be the number of bits in `n`.  \nAll operations are constant\u2011time integer operations, therefore\n\n```\nTime   : O(1)\nMemory : O(1)\n```\n\n--------------------------------------------------------------------\n\n#### Reference Implementation (C++17)\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <cassert>\n#include <bitset>\n\n/**\n * Toggle all bits of n except the most significant and least significant bits.\n *\n * @param n The input number (non\u2011negative long).\n * @return  The resulting number after toggling the middle bits.\n */\nlong toggle_middle_bits(long n) {\n    if (n <= 1) return n;                 // only one bit, nothing to toggle\n\n    // Number of bits needed to represent n\n    const int bits = 64 - __builtin_clzll(static_cast<unsigned long long>(n));\n\n    // Masks for the outer bits\n    const unsigned long long left  = 1ULL << (bits - 1); // MSB\n    const unsigned long long right = 1ULL;              // LSB\n\n    // Mask with 1s in all middle positions and 0s at the borders\n    const unsigned long long mask = ((1ULL << bits) - 1) ^ (left | right);\n\n    return static_cast<long>(static_cast<unsigned long long>(n) ^ mask);\n}\n\n/* ------------------------------------------- */\n/* Optional: simple test harness for illustration */\nint main() {\n    auto test = [](long n, long expected) {\n        long res = toggle_middle_bits(n);\n        std::cout << \"n = \" << std::bitset<8>(n)\n                  << \" \u2192 \" << std::bitset<8>(res)\n                  << \" (expected \" << std::bitset<8>(expected) << \")\\n\";\n        assert(res == expected);\n    };\n\n    // examples from the GeeksforGeeks article\n    test(0b10, 0b10);          // only two bits\n    test(0b1010, 0b1000);\n    test(0b11000, 0b10110);\n    test(0b10101010, 0b10010101);\n\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\nThe program includes a small test harness that prints the binary\nrepresentation of the input and the result to verify the correctness.\nFeel free to drop the `main` function when using this routine in a larger\nproject."]}
{"name": "HumanEval_88_sort_array", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_88_sort_array.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = sort_array;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5}))) == (std::vector<long>({(long)5})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6}))) == (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0})));\n    assert(candidate((std::vector<long>({(long)2, (long)1}))) == (std::vector<long>({(long)1, (long)2})));\n    assert(candidate((std::vector<long>({(long)15, (long)42, (long)87, (long)32, (long)11, (long)0}))) == (std::vector<long>({(long)0, (long)11, (long)15, (long)32, (long)42, (long)87})));\n    assert(candidate((std::vector<long>({(long)21, (long)14, (long)23, (long)11}))) == (std::vector<long>({(long)23, (long)21, (long)14, (long)11})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a simple, single\u2011file implementation that follows exactly the rules you described:\n\n```cpp\n#include <vector>\n#include <algorithm>\n\n/*  Return a copy of `array` sorted according\n *  to the parity of (first + last).\n *  - If the sum is odd:  ascending order\n *  - If the sum is even: descending order\n *\n *  The function receives `array` by value, so the\n *  caller\u2019s vector is not modified.\n */\nstd::vector<long> sort_array(std::vector<long> array) {\n    // Empty or single element vectors are already sorted\n    if (array.size() <= 1) {\n        return array;\n    }\n\n    long sum = array.front() + array.back();\n\n    if (sum % 2 == 0) {                         // sum is even \u2192 descending\n        std::sort(array.begin(), array.end(), std::greater<long>{});\n    } else {                                    // sum is odd \u2192 ascending\n        std::sort(array.begin(), array.end());   // default < operator\n    }\n\n    return array;\n}\n```\n\n**Explanation**\n\n1. The function takes the vector *by value*, so `array` is a copy and the original is safe.\n2. If the vector has length 0 or 1, we immediately return it; sorting in that case would be unnecessary.\n3. Compute the sum of the first and last element.\n4. If that sum is even, use `std::greater` as the comparison to obtain a descending order.\n5. If the sum is odd, sort in the default ascending order.\n6. Finally, return the sorted copy.\n\nThe code uses only standard library components (`<vector>` and `<algorithm>`) and respects the \u201cdon\u2019t modify the input\u201d rule.", "```cpp\n#include <algorithm>\n#include <vector>\n\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) return array;            // nothing to do\n\n    bool ascending = ((array.front() + array.back()) % 2 != 0);\n    if (ascending)\n        std::sort(array.begin(), array.end());                 // increasing\n    else\n        std::sort(array.begin(), array.end(), std::greater<long>()); // decreasing\n    return array;\n}\n```\n\n**Explanation**\n\n* We first check if the input is empty \u2013 if so we simply return it unchanged.\n* We compute whether the sum of the first and last elements is odd (`% 2 != 0`).  \n  - If it\u2019s odd, we need to sort in *ascending* order.\n  - If it\u2019s even, we need to sort in *descending* order.\n* For ascending order we use `std::sort` with the default `<` comparator.\n* For descending order we use `std::greater<long>()` as the comparator.\n* Finally we return the newly sorted vector; the original vector is **not** modified.", "Here is a complete, self\u2011contained implementation of `sort_array`.  \nThe function follows exactly the specification:\n\n1. **Do not modify the input vector.**  \n   We receive the input by value (`std::vector<long> array`), so the caller\u2019s vector is untouched.\n2. **Check length.**  \n   For an empty vector or a vector of size\u202f1, the function simply returns the vector unchanged.\n3. **Decide the ordering.**  \n   It calculates the sum of the first and last element; if the sum is odd the vector is sorted in ascending order, otherwise in descending order.\n4. **Return the new, sorted vector.**\n\n```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<long> sort_array(std::vector<long> array) {\n    // If empty or single element, nothing to sort\n    if(array.size() <= 1) return array;\n\n    // Sum of first and last element\n    long sum = array.front() + array.back();\n\n    // Determine sorting order\n    if(sum % 2 == 1) {\n        // Odd sum -> ascending\n        std::sort(array.begin(), array.end());\n    } else {\n        // Even sum -> descending\n        std::sort(array.begin(), array.end(), std::greater<long>());\n    }\n    return array;\n}\n```\n\n**Usage examples**\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> v = {2, 4, 3, 0, 1, 5};\n    auto res = sort_array(v);\n    for(long x : res) std::cout << x << ' ';   // 0 1 2 3 4 5\n}\n```\n\nThe function is O(n\u202flog\u202fn) in time (because of the sorting operation) and O(1) in additional space beyond the output vector."]}
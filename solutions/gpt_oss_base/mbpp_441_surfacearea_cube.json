{"name": "mbpp_441_surfacearea_cube", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the surface area of a cube of a given size.\nlong surfacearea_cube(long l) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_441_surfacearea_cube.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = surfacearea_cube;\n    assert(candidate((5)) == (150));\n    assert(candidate((3)) == (54));\n    assert(candidate((10)) == (600));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a simple, clean implementation that follows the requirement \u2013 the function takes a `long` for the side length and returns the surface area of a cube (`6 \u00d7 side\u00b2`).  \nIt also guards against negative inputs with an `assert` (you can replace that with your own error handling if needed).\n\n```cpp\n#include <cassert>\n\n/*  Return the surface area of a cube whose side length is l.\n    For a cube, surface area = 6 * l * l. */\nlong surfacearea_cube(long l)\n{\n    // A cube cannot have a negative side length.\n    assert(l >= 0);\n\n    // Compute 6 * l * l using long arithmetic.\n    return 6 * l * l;\n}\n```\n\nFeel free to add any additional checks or use the same logic inside a larger program.", "Here\u2019s a simple, self\u2011contained implementation of the function that returns the surface area of a cube.  \nThe function checks that the side length is non\u2011negative (a cube cannot have a negative side length) and then computes \\(6 \\times l^2\\). It uses strictly standard library headers only, so you can drop the `#include<bits/stdc++.h>` and keep this snippet portable.\n\n```cpp\n#include <cstddef>   // for std::size_t\n#include <cassert>   // for assert\n\n/**\n * @brief  Returns the surface area of a cube.\n *\n * @param l Side length of the cube (must be non\u2011negative).\n *\n * @return Surface area of the cube, i.e. 6 \u00d7 l^2.\n *\n * @note  The function uses `long long` to avoid overflow for moderately large\n *        inputs (up to roughly 9\u00d710^9). If you need larger numbers consider\n *        using an arbitrary\u2011precision type or check for overflow.\n */\nlong long surfacearea_cube(long long l)\n{\n    // A cube\u2019s side length cannot be negative.\n    // The assertion helps catch bugs during development; it\n    // will be removed in an optimized release build.\n    assert(l >= 0);\n\n    // Compute 6 * l^2\n    return 6LL * l * l;\n}\n```\n\n### Why `long long` / `6LL`?\n\nThe original signature used `long`. In many compilers `long` is 32\u2011bit on 32\u2011bit targets and 64\u2011bit on 64\u2011bit targets. To be explicit and avoid ambiguity, we use `long long` (64\u2011bit on virtually all platforms).  \n`6LL` guarantees the multiplication is done in 64\u2011bit arithmetic to prevent accidental 32\u2011bit overflow.\n\n### Usage\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    long long len = 5;\n    std::cout << \"Surface area of a cube with side \" << len\n              << \" is \" << surfacearea_cube(len) << '\\n';\n    return 0;\n}\n```\n\nThis will compile with any standard\u2011conforming C++ compiler (`-std=c++11` and newer are fine).", "Here\u2019s a concise implementation of the surface\u2011area function for a cube.  \nThe function:\n\n1. Checks that the side length is positive (using `assert` \u2013 this is optional but helps catch errors early).  \n2. Computes the surface area (`6 \u00d7 l\u00b2`).  \n3. Returns the result as a `long`.\n\n```cpp\n#include <assert.h>\n#include <bits/stdc++.h>\n\n// Return the surface area of a cube whose side length is l.\nlong surfacearea_cube(long l)\n{\n    // The side length of a cube must be a positive integer.\n    assert(l > 0 && \"Side length must be positive\");\n\n    // Surface area of a cube = 6 * (side length)^2\n    return 6 * l * l;\n}\n```\n\nYou can now use `surfacearea_cube` wherever you need to calculate the covering surface of a cube."]}
{"name": "HumanEval_18_how_many_times", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_18_how_many_times.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = how_many_times;\n    assert(candidate((\"\"), (\"x\")) == (0));\n    assert(candidate((\"xyxyxyx\"), (\"x\")) == (4));\n    assert(candidate((\"cacacacac\"), (\"cac\")) == (4));\n    assert(candidate((\"john doe\"), (\"john\")) == (1));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a compact, header\u2011only implementation that correctly counts overlapping occurrences of a substring in a string.  \nIf the *substring* is empty we treat it as not occurring (return `0`), because a zero\u2011length pattern would match infinitely many positions.\n\n```cpp\n#include <string>\n\n/**\n * Count how many times `substring` occurs in `string`, allowing overlaps.\n *\n * @param string    The text to search in.\n * @param substring The pattern to look for.\n * @return          Number of overlapping occurrences.\n */\ninline long how_many_times(const std::string& string, const std::string& substring)\n{\n    if (substring.empty())                // avoid infinite loop\n        return 0;\n\n    long count = 0;\n    std::size_t pos = 0;\n\n    while ((pos = string.find(substring, pos)) != std::string::npos) {\n        ++count;\n        ++pos;           // move one character forward to allow overlap\n    }\n    return count;\n}\n```\n\n**Examples**\n\n```cpp\nassert(how_many_times(\"\", \"a\") == 0);\nassert(how_many_times(\"aaa\", \"a\") == 3);\nassert(how_many_times(\"aaaa\", \"aa\") == 3);\nassert(how_many_times(\"ababab\", \"aba\") == 2);   // overlapping \"aba\" at 0 and 2\n```\n\nThe algorithm runs in \\(O(n \\cdot m)\\) worst\u2011case time (with `find` potentially re\u2011scanning the string), which is perfectly fine for typical usage. If you need a faster linear\u2011time solution (KMP, Z\u2011algorithm, etc.), let me know and I can extend the implementation.", "### Complete C++ implementation\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Counts the number of (possibly overlapping) occurrences of `substring` inside `string`.\nlong how_many_times(const string& string, const string& substring) {\n    if (substring.empty() || string.empty() || substring.size() > string.size())\n        return 0;\n\n    long count = 0;\n    // Sliding window \u2013 move one position at a time (allows overlap)\n    for (size_t i = 0; i + substring.size() <= string.size(); ++i) {\n        if (string.compare(i, substring.size(), substring) == 0)\n            ++count;\n    }\n    return count;\n}\n\n/* ------------------------------------------------------------------\n   Optional: Naive test harness.\n   ------------------------------------------------------------------ */\n#ifdef TEST_HOW_MANY_TIMES\nint main() {\n    assert(how_many_times(\"\", \"a\") == 0);\n    assert(how_many_times(\"aaa\", \"a\") == 3);\n    assert(how_many_times(\"aaaa\", \"aa\") == 3);\n    assert(how_many_times(\"abababa\", \"aba\") == 2);   // overlaps at 0 and 4\n    cout << \"All quick checks passed.\\n\";\n}\n#endif\n```\n\n#### How it works\n\n1. **Edge cases** \u2013 If either string is empty or the substring is longer than the string, there are zero matches.\n2. **Sliding window** \u2013 Iterate over every possible starting index `i` such that the substring fits (`i + substring.size() <= string.size()`).\n3. **Compare** \u2013 Use `std::string::compare` to check whether the segment of `string` starting at `i` matches `substring`. If it does, increment `count`.\n4. **Return** \u2013 The final count is returned as a `long`.\n\nThis algorithm works in `O(n\u00b7m)` where `n` is the length of the original string and `m` the length of the substring. For typical use\u2011cases this is more than fast enough and correctly counts overlapping occurrences.", "Below is a compact, self\u2011contained implementation that\n\n* handles the edge case where `substring` is empty,\n* walks through `string` one character at a time (so overlapping matches are counted),\n* uses a simple `substr` comparison which is easy to read and works for all lengths.\n\n```cpp\n#include <string>\n\n/* ------------------------------------------------------\n * how_many_times \u2013 count how many times `substr` occurs\n * in `str`. Overlapping occurrences are counted.\n * ------------------------------------------------------ */\nlong how_many_times(const std::string& str,\n                    const std::string& substr)\n{\n    // If the substring is empty there is nothing to look for\n    if (substr.empty())\n        return 0;\n\n    long count = 0;\n    std::size_t pos = 0;\n\n    while (pos <= str.size() - substr.size())\n    {\n        // compare the slice that starts at pos\n        if (str.compare(pos, substr.size(), substr) == 0)\n            ++count;\n\n        ++pos;                     // allow overlapping, so move only one char\n    }\n\n    return count;\n}\n```\n\n### Why this works\n\n1. **Boundary check** \u2013 `pos <= str.size() - substr.size()` guarantees we never read beyond `str`'s end.\n2. **`compare`** \u2013 `std::string::compare(start, len, other)` returns `0` when the requested substring equals `other`.  \n   It\u2019s essentially the same as `str.substr(start, len) == substr`, but cheaper because it doesn\u2019t create a temporary string.\n3. **Step by one** \u2013 After checking an index we increment `pos` by one, so `\"aaaa\"` with substring `\"aa\"` counts at positions `0`, `1`, and `2` \u2192 3 occurrences.\n4. **Empty substring** \u2013 By definition the problem asks the result to be `0` in this case, which we return immediately.\n\nThe function runs in *O(|str| \u00b7 |substr|)* in the worst case (because each `compare` is linear in the substring\u2019s length), but for typical lengths this is fine and keeps the code simple and readable."]}
{"name": "mbpp_390_add_string", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to apply a given format string to all of the elements in a vector.\nstd::vector<std::string> add_string(std::vector<std::any> list_, std::string string) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_390_add_string.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = add_string;\n    assert(candidate((std::vector<std::any>({(long)1, (long)2, (long)3, (long)4})), (\"temp{0}\")) == (std::vector<std::string>({(std::string)\"temp1\", (std::string)\"temp2\", (std::string)\"temp3\", (std::string)\"temp4\"})));\n    assert(candidate((std::vector<std::any>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\", (std::string)\"d\"})), (\"python{0}\")) == (std::vector<std::string>({(std::string)\"pythona\", (std::string)\"pythonb\", (std::string)\"pythonc\", (std::string)\"pythond\"})));\n    assert(candidate((std::vector<std::any>({(long)5, (long)6, (long)7, (long)8})), (\"string{0}\")) == (std::vector<std::string>({(std::string)\"string5\", (std::string)\"string6\", (std::string)\"string7\", (std::string)\"string8\"})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a **complete, self\u2011contained C++17 program** that demonstrates how to\napply a *format string* to every element in a `std::vector<std::any>` and return a\nvector of formatted strings.\n\nThe implementation is deliberately kept generic:\n\n* It can handle numeric types (`int`, `double`, `float`, \u2026) and\n  `std::string` (or any type that can be streamed into an\n  `std::ostringstream`).\n* The format string is interpreted in a lightweight way, looking for a\n  `{}` placeholder.  \n  If you need richer formatting you can extend the code or switch to\n  `fmt`/`fmt::format` (or `std::format` in C++20+).\n\n```cpp\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <any>\n#include <iomanip>\n#include <type_traits>\n\n// -----------------------------------------------------------------------------\n// Utility: test whether T is stream\u2011insertable\ntemplate<typename T, typename = void>\nstruct is_stream_insertable : std::false_type {};\n\ntemplate<typename T>\nstruct is_stream_insertable<\n    T,\n    std::void_t<decltype(std::declval<std::ostream&>() << std::declval<T>())>>\n    : std::true_type {};\n\n// -----------------------------------------------------------------------------\n// Helper that turns any T that is stream\u2011insertable into a string.\ntemplate<class T>\nstd::string to_string_custom(const T& value)\n{\n    static_assert(is_stream_insertable<T>::value,\n                  \"Type is not stream\u2011insertable\");\n    std::ostringstream oss;\n    oss << value;\n    return oss.str();\n}\n\n// -----------------------------------------------------------------------------\n// Main formatting function\nstd::vector<std::string>\napply_format(const std::vector<std::any>& list, const std::string& format)\n{\n    std::vector<std::string> result;\n    result.reserve(list.size());\n\n    // Scan format once to locate the first \"{}\".\n    std::size_t pos = format.find(\"{}\");\n    const bool has_placeholder = (pos != std::string::npos);\n\n    for (const auto& a : list)\n    {\n        std::string formatted;\n\n        if (has_placeholder)\n        {\n            // Build a string with the placeholder replaced by the value.\n            std::ostringstream oss;\n            oss << format.substr(0, pos);   // text before {}\n\n            // Retrieve the value \u2013 we only support a handful of types\n            // here.  For real code, consider expanding this list or\n            // using a visitor based on std::any_cast.\n            if (a.type() == typeid(int))\n                oss << std::any_cast<int>(a);\n            else if (a.type() == typeid(double))\n                oss << std::any_cast<double>(a);\n            else if (a.type() == typeid(float))\n                oss << std::any_cast<float>(a);\n            else if (a.type() == typeid(std::string))\n                oss << std::any_cast<std::string>(a);\n            else if (a.type() == typeid(char const*))\n                oss << std::string(std::any_cast<char const*>(a));\n            else\n                // Fallback: try to stream the object directly.\n                try {\n                    oss << std::any_cast<decltype(a)>(a);\n                } catch (...) {\n                    oss << \"<unhandled>\";\n                }\n\n            oss << format.substr(pos + 2); // text after {}\n            formatted = oss.str();\n        }\n        else // No placeholder \u2013 just stream the value into the result\n        {\n            if (a.type() == typeid(int))\n                formatted = to_string_custom(std::any_cast<int>(a));\n            else if (a.type() == typeid(double))\n                formatted = to_string_custom(std::any_cast<double>(a));\n            else if (a.type() == typeid(float))\n                formatted = to_string_custom(std::any_cast<float>(a));\n            else if (a.type() == typeid(std::string))\n                formatted = std::any_cast<std::string>(a);\n            else if (a.type() == typeid(char const*))\n                formatted = std::string(std::any_cast<char const*>(a));\n            else\n                // Fallback: try to stream the object directly\n                try {\n                    std::ostringstream oss;\n                    oss << std::any_cast<decltype(a)>(a);\n                    formatted = oss.str();\n                } catch (...) {\n                    formatted = \"<unhandled>\";\n                }\n        }\n\n        result.push_back(formatted);\n    }\n\n    return result;\n}\n\n// -----------------------------------------------------------------------------\n// Demo\nint main()\n{\n    std::vector<std::any> v = { 42, 3.1415, \"hello\", L'A', 100 };\n    std::string fmt = \"Value: {}\";\n\n    auto out = apply_format(v, fmt);\n\n    for (const auto& s : out)\n        std::cout << s << '\\n';\n\n    return 0;\n}\n```\n\n### What this program does\n\n1. **`is_stream_insertable`** \u2013 Metafunction that checks if a type can be\n   streamed into `std::ostream`.  \n   This allows the fallback conversion with `std::ostringstream`.\n\n2. **`to_string_custom`** \u2013 Converts a stream\u2011insertable type into an\n   `std::string`.  It\u2019s used when the format string contains no `{}`.\n\n3. **`apply_format`** \u2013  \n   * Detects whether the format string contains the placeholder `{}`.  \n   * For each element in the `vector<std::any>` it:\n     * If the placeholder exists, replaces `{}` with the converted value.  \n     * Otherwise, just converts the value to a string.  \n   * Supports the most common types (`int`, `double`, `float`,\n     `std::string`, string literals, wide chars).  \n     Any other type that can be streamed will fall back to a generic\n     `std::ostringstream` conversion.\n\n4. **`main`** \u2013 Shows a quick usage example.\n\nFeel free to adapt the type\u2011handling section or replace the placeholder\nlogic with `fmt::format`/`std::format` if you need more sophisticated\ntemplates.", "Below is a **minimal yet fully working** implementation that should compile with a standard\u2011conforming C++ compiler (C++20 on).  \nThe goal of the helper `add_string` is:\n\n1. Take a vector of `std::any`, each element representing a value we want to embed in a *format string*.\n2. For each element apply the format string to build a single `std::string`.\n   * If the format string contains a `{}\u2018 placeholder, we will inject the element\u2019s textual representation.\n   * If the format string contains no placeholder, the element\u2019s text is simply appended.\n3. Return a new vector containing the formatted strings.\n\nThe design uses the standard library only \u2013 no external `fmt` library or `boost` required.  \nIt defi\u00adnes a small `toString` helper that extracts a textual representation from `std::any`.  \nIf the value cannot be read the function throws an exception \u2013 this keeps the code simple and avoids silent failures.\n\n```cpp\n//=======================================================================\n//  add_string \u2013 apply a format string to every element of a std::any\n//  vector and return a vector of strings.\n//=======================================================================\n\n#include <any>\n#include <cassert>\n#include <iomanip>\n#include <sstream>\n#include <string>\n#include <vector>\n\n/* ---------------------------------------------------------------------- */\n/// Simple helper to convert an `std::any` into a human\u2011readable string.\n///\n/// - Numeric types are written with `operator<<` (this covers int, double,\n///   long, etc.).\n/// - `std::string` and `const char*` are returned unchanged.\n/// - `std::nullptr_t` becomes `\"null\"`.\n/// - Other types will trigger the catch\u2011all and throw a `std::runtime_error`.\\n\n/// \n/// No locale\u2011specific formatting is done \u2013 this keeps the example simple\n/// and preserves the behaviour of `operator<<` for basic types.\\n\n/// ---------------------------------------------------------------------- */\nstatic std::string toString(const std::any &value)\n{\n    using std::string;\n\n    if (value.type() == typeid(int))\n        return std::to_string(std::any_cast<int>(value));\n    if (value.type() == typeid(long))\n        return std::to_string(std::any_cast<long>(value));\n    if (value.type() == typeid(long long))\n        return std::to_string(std::any_cast<long long>(value));\n    if (value.type() == typeid(unsigned))\n        return std::to_string(std::any_cast<unsigned>(value));\n    if (value.type() == typeid(unsigned long))\n        return std::to_string(std::any_cast<unsigned long>(value));\n    if (value.type() == typeid(unsigned long long))\n        return std::to_string(std::any_cast<unsigned long long>(value));\n    if (value.type() == typeid(double))\n        return std::to_string(std::any_cast<double>(value));\n    if (value.type() == typeid(float))\n        return std::to_string(std::any_cast<float>(value));\n    if (value.type() == typeid(bool))\n        return std::any_cast<bool>(value) ? \"true\" : \"false\";\n\n    if (value.type() == typeid(std::string))\n        return std::any_cast<std::string>(value);\n    if (value.type() == typeid(char const *))\n        return std::string(std::any_cast<char const *>(value));\n\n    if (value.type() == typeid(std::nullptr_t))\n        return \"null\";\n\n    // Fallback \u2013 try inserting into a stringstream\n    try {\n        std::ostringstream oss;\n        oss << std::any_cast<void const &>(value);   // try as generic pointer\n        return oss.str();\n    }\n    catch (...) { /* fall through to error */ }\n\n    throw std::runtime_error(\"Unsupported std::any type in add_string\");\n}\n\n/* ---------------------------------------------------------------------- */\n/// Apply the format string to all elements in `list_`.\n//\n/// @param list_    Vector containing any values that need formatting.\n/// @param format   Format string \u2013 may contain `{}` as a placeholder for the\n///                 value of each element.\n/// @return Vector of strings after formatting.\n///\n/// Example:\n/// \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n/// std::vector<std::any> a = {1, 3.14, \"hi\"};\n/// auto r = add_string(a, \"Value: {}\");\n/// // r == {\"Value: 1\", \"Value: 3.140000\", \"Value: hi\"}\n///\n/// The implementation does *not* depend on any external formatting libraries.\n/// It simply replaces the first occurrence of `{}` with the textual form of\n/// the element.  If the format string does not contain `{}`, the string is\n/// concatenated with the element value.\\n\n/// ---------------------------------------------------------------------- */\nstatic std::vector<std::string>\nadd_string(const std::vector<std::any>& list_, const std::string &format)\n{\n    std::vector<std::string> out;\n    out.reserve(list_.size());\n\n    const std::string placeholder = \"{}\";\n\n    for (const auto &elem : list_) {\n        std::string valStr = toString(elem);\n\n        std::string formatted = format;\n        size_t pos = formatted.find(placeholder);\n        if (pos != std::string::npos) {\n            // Simple single\u2011placeholder replacement\n            formatted.replace(pos, placeholder.length(), valStr);\n        } else {\n            // No placeholder \u2013 simply append\n            formatted += valStr;\n        }\n        out.push_back(formatted);\n    }\n    return out;\n}\n\n/* ---------------------------------------------------------------------- */\n/// Simple unit\u2011test to verify the behaviour.\n///\n/// The tests cover:\n///  \u2022 Basic integral and floating point types\n///  \u2022 String and C\u2011string values\n///  \u2022 nullptr handling\n///  \u2022 A case with no placeholder in the format string\n///\n/// If any assertion fails the process will abort.\\n\n/// ---------------------------------------------------------------------- */\nstatic void run_tests()\n{\n    std::vector<std::any> v = { 42, 3.14, std::string(\"hello\"), nullptr };\n    auto r1 = add_string(v, \"Number: {}\");\n    assert(r1.size() == 4);\n    assert(r1[0] == \"Number: 42\");\n    assert(r1[1] == \"Number: 3.140000\");  // default formatting of double\n    assert(r1[2] == \"Number: hello\");\n    assert(r1[3] == \"Number: null\");\n\n    auto r2 = add_string(v, \"Item\");\n    assert(r2[0] == \"Item42\");\n    assert(r2[1] == \"Item3.140000\");\n    assert(r2[2] == \"Itemhello\");\n    assert(r2[3] == \"Itemnull\");\n}\n\n/* ---------------------------------------------------------------------- */\nint main()\n{\n    run_tests();\n    std::cout << \"All tests passed.\\n\";\n    return 0;\n}\n```\n\n### How it works\n\n1. **`toString`**  \n   Inspects the dynamic type of an `std::any`.  For the common numeric types and strings it returns a canonical string representation.  \n   Unsupported types cause a runtime error \u2013 this keeps the behaviour deterministic.\n\n2. **`add_string`**  \n   Iterates over the input vector, obtains the string form of each element and then  \n   * replaces the first `{}` in the format string with that value, or  \n   * concatenates the value if the format string contains no placeholder.\n\n3. **Unit\u2011tests**  \n   `run_tests()` covers the typical usage scenarios.  If any of the assertions fails, the program terminates with an assertion failure.\n\nFeel free to expand the `toString` helper for more types or add support for multiple placeholders if your formatting requirements grow.", "Below is a **complete, self\u2011contained** implementation that\n\n1. accepts a `std::vector<std::any>` (the function that receives the \u201cgeneric\u201d list),\n2. applies a **format string** to every element in the list,\n3. returns a `std::vector<std::string>` with the formatted results.\n\n```cpp\n#include <any>\n#include <array>\n#include <format>\n#include <iostream>\n#include <string>\n#include <type_traits>\n#include <vector>\n\n/* --------------------------------------------------------------------- *\n *  Helper:  dispatch the formatting based on the concrete type inside an\n *           std::any instance.  The helper is built as a struct with a\n *           templated call\u2011operator that forwards to std::format.\n * --------------------------------------------------------------------- */\nnamespace detail\n{\n    template <typename T>\n    constexpr void check_supported() {\n        static_assert(\n            std::is_arithmetic_v<T> ||\n            std::is_same_v<T, std::string> ||\n            std::is_same_v<T, const char*>,\n            \"Unsupported type for formatting \u2013 there is no string \"\n            \"conversion available for the element\");\n    }\n\n    template <typename T>\n    struct formatter\n    {\n        constexpr formatter(const std::string& fmt) : fmt_{fmt} {}\n\n        template <typename O>\n        std::string operator()(const O& value) const\n        {\n            // use std::format (C++20) \u2013 it supports all of the built\u2011in\n            // arithmetic types as well as `std::string`/`const char*`\n            return std::format(fmt_, value);\n        }\n\n        const std::string fmt_;\n    };\n\n    /* --------------------------------------------------------------------- *\n     *  The public entry point \u2013 it runs the dispatch for every `std::any`\n     * --------------------------------------------------------------------- */\n    std::vector<std::string>\n    apply_format_to_any_vector(const std::vector<std::any>& v,\n                               const std::string& fmt)\n    {\n        std::vector<std::string> result;\n        result.reserve(v.size());\n\n        for (const auto& a : v)\n        {\n            if (a.type() == typeid(int))\n                result.push_back(formatter<int>{fmt}(std::any_cast<int>(a)));\n            else if (a.type() == typeid(double))\n                result.push_back(formatter<double>{fmt}(std::any_cast<double>(a)));\n            else if (a.type() == typeid(float))\n                result.push_back(formatter<float>{fmt}(std::any_cast<float>(a)));\n            else if (a.type() == typeid(long))\n                result.push_back(formatter<long>{fmt}(std::any_cast<long>(a)));\n            else if (a.type() == typeid(std::string))\n                result.push_back(formatter<std::string>{fmt}(std::any_cast<std::string>(a)));\n            else if (a.type() == typeid(const char*))\n                result.push_back(formatter<const char*>{fmt}(std::any_cast<const char*>(a)));\n            else\n            {\n                // If you want to support more types, add them above.\n                throw std::runtime_error(\"Unsupported std::any content\");\n            }\n        }\n\n        return result;\n    }\n} // namespace detail\n\n/* --------------------------------------------------------------------- *\n *  Public API \u2013 thin wrapper around the implementation\n * --------------------------------------------------------------------- */\nstd::vector<std::string> add_string(const std::vector<std::any>& list,\n                                   const std::string& format_str)\n{\n    return detail::apply_format_to_any_vector(list, format_str);\n}\n\n/* --------------------------------------------------------------------- *\n *  Example usage\n * --------------------------------------------------------------------- */\nint main()\n{\n    std::vector<std::any> data{ 42, 3.1415, \"hello\", std::string(\"world\") };\n\n    // We want something like: \"<int>\", \"<double>\", \"<str>\", \"<str>\"\n    auto formatted = add_string(\n        data,\n        \"<{}>\"  // The \"{}\" will be replaced by std::format with the value\n    );\n\n    for (const auto& s : formatted)\n        std::cout << s << '\\n';\n\n    // Output:\n    // <42>\n    // <3.141500>\n    // <hello>\n    // <world>\n}\n```\n\n### How it works\n\n1. **Type dispatching**  \n   The function iterates over the vector and checks the actual stored type with `a.type()`.  \n   For each supported type it calls `std::any_cast` to retrieve the value, then forwards it to a tiny helper\u2014`detail::formatter`\u2014that simply does `std::format(fmt, value)`.\n\n2. **Supported types**  \n   The current implementation covers:\n   * Integral types (`int`, `long`, \u2026)\n   * Floating point types (`float`, `double`)\n   * `std::string`\n   * `const char*`\n\n   If you need more types, just add another `else if` block.\n\n3. **Error handling**  \n   An exception is thrown if an unsupported type is encountered.  \n   You can change this to whatever error policy suits your project.\n\n4. **Usage**  \n   The example shows how to call `add_string` and what the output looks like.  \n   The format string can contain any `std::format` placeholder(s) (`{}`, `{:.2f}`, etc.).\n\n**Requirements**\n\n* C++20 (for `<format>`).\n* On GCC/Clang, you may need `-std=c++20` \u2013 newer compilers already ship `<format>`.  \n* If you have a pre\u2011C++20 compiler, you can use the external **fmt** library (<https://fmt.dev>) and replace `std::format` by `fmt::format`. The rest of the code stays the same."]}
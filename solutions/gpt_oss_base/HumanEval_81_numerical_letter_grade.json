{"name": "HumanEval_81_numerical_letter_grade", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_81_numerical_letter_grade.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = numerical_letter_grade;\n    assert(candidate((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f}))) == (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"})));\n    assert(candidate((std::vector<float>({(float)1.2f}))) == (std::vector<std::string>({(std::string)\"D+\"})));\n    assert(candidate((std::vector<float>({(float)0.5f}))) == (std::vector<std::string>({(std::string)\"D-\"})));\n    assert(candidate((std::vector<float>({(float)0.0f}))) == (std::vector<std::string>({(std::string)\"E\"})));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)0.3f, (float)1.5f, (float)2.8f, (float)3.3f}))) == (std::vector<std::string>({(std::string)\"D\", (std::string)\"D-\", (std::string)\"C-\", (std::string)\"B\", (std::string)\"B+\"})));\n    assert(candidate((std::vector<float>({(float)0.0f, (float)0.7f}))) == (std::vector<std::string>({(std::string)\"E\", (std::string)\"D-\"})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a complete implementation that follows the table you gave.  \nThe function iterates over the input GPA vector, checks the value against the\nthresholds in descending order, pushes the corresponding letter grade into a\nnew vector and finally returns that vector.\n\n```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> numerical_letter_grade(const std::vector<float>& grades) {\n    std::vector<std::string> result;\n    result.reserve(grades.size());          // avoid reallocations\n\n    for (float gpa : grades) {\n        if (gpa == 4.0f)          result.emplace_back(\"A+\");\n        else if (gpa > 3.7f)      result.emplace_back(\"A\");\n        else if (gpa > 3.3f)      result.emplace_back(\"A-\");\n        else if (gpa > 3.0f)      result.emplace_back(\"B+\");\n        else if (gpa > 2.7f)      result.emplace_back(\"B\");\n        else if (gpa > 2.3f)      result.emplace_back(\"B-\");\n        else if (gpa > 2.0f)      result.emplace_back(\"C+\");\n        else if (gpa > 1.7f)      result.emplace_back(\"C\");\n        else if (gpa > 1.3f)      result.emplace_back(\"C-\");\n        else if (gpa > 1.0f)      result.emplace_back(\"D+\");\n        else if (gpa > 0.7f)      result.emplace_back(\"D\");\n        else if (gpa > 0.0f)      result.emplace_back(\"D-\");\n        else                      result.emplace_back(\"E\");\n    }\n    return result;\n}\n```\n\n### How it works\n\n| Condition | Letter grade |\n|-----------|--------------|\n| `gpa == 4.0f` | `\"A+\"` |\n| `gpa > 3.7f` | `\"A\"` |\n| `gpa > 3.3f` | `\"A-\"` |\n| `gpa > 3.0f` | `\"B+\"` |\n| `gpa > 2.7f` | `\"B\"` |\n| `gpa > 2.3f` | `\"B-\"` |\n| `gpa > 2.0f` | `\"C+\"` |\n| `gpa > 1.7f` | `\"C\"` |\n| `gpa > 1.3f` | `\"C-\"` |\n| `gpa > 1.0f` | `\"D+\"` |\n| `gpa > 0.7f` | `\"D\"` |\n| `gpa > 0.0f` | `\"D-\"` |\n| else | `\"E\"` |\n\nThe checks are ordered from the highest threshold down to the lowest to\nensure the correct letter grade is chosen. The function is `constexpr`\u2011friendly\nand works for both `float` and `double` values if you change the parameter type.", "**Solution Explanation**\n\nWe have to transform a list of numeric GPAs into their corresponding letter\ngrades.  \nThe mapping is\n\n| GPA  | Letter grade |\n|------|--------------|\n| 4.0  | A+           |\n| >3.7 | A            |\n| >3.3 | A-           |\n| >3.0 | B+           |\n| >2.7 | B            |\n| >2.3 | B-           |\n| >2.0 | C+           |\n| >1.7 | C            |\n| >1.3 | C-           |\n| >1.0 | D+           |\n| >0.7 | D            |\n| >0.0 | D-           |\n| 0.0  | E            |\n\n**Observations**\n\n* The boundaries are strictly *greater than* except for the topmost\n  (`4.0`) and the bottommost (`0.0`).\n* The function must work for any length of the input vector.\n\n**Algorithm**\n\nFor each GPA `g` in the input vector:\n\n1. If `g >= 4.0f` \u2192 `\"A+\"`\n2. Else if `g > 3.7f` \u2192 `\"A\"`\n3. Else if `g > 3.3f` \u2192 `\"A-\"`\n4. Else if `g > 3.0f` \u2192 `\"B+\"`\n5. Else if `g > 2.7f` \u2192 `\"B\"`\n6. Else if `g > 2.3f` \u2192 `\"B-\"`\n7. Else if `g > 2.0f` \u2192 `\"C+\"`\n8. Else if `g > 1.7f` \u2192 `\"C\"`\n9. Else if `g > 1.3f` \u2192 `\"C-\"`\n10. Else if `g > 1.0f` \u2192 `\"D+\"`\n11. Else if `g > 0.7f` \u2192 `\"D\"`\n12. Else if `g > 0.0f` \u2192 `\"D-\"`\n13. Else \u2192 `\"E\"`\n\nAppend the resulting string to an output vector and finally return it.\n\n**Complexity**\n\n*Time* \u2013 We loop once over the input vector, performing a constant amount of\nwork per element: `O(n)` where `n` is the number of GPAs.  \n*Space* \u2013 We store the output vector of the same size: `O(n)`.\n\n**Reference Implementation (C++17)**\n\n```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n    std::vector<std::string> result;\n    result.reserve(grades.size());          // avoid reallocations\n\n    for (float g : grades) {\n        if (g >= 4.0f) {\n            result.push_back(\"A+\");\n        } else if (g > 3.7f) {\n            result.push_back(\"A\");\n        } else if (g > 3.3f) {\n            result.push_back(\"A-\");\n        } else if (g > 3.0f) {\n            result.push_back(\"B+\");\n        } else if (g > 2.7f) {\n            result.push_back(\"B\");\n        } else if (g > 2.3f) {\n            result.push_back(\"B-\");\n        } else if (g > 2.0f) {\n            result.push_back(\"C+\");\n        } else if (g > 1.7f) {\n            result.push_back(\"C\");\n        } else if (g > 1.3f) {\n            result.push_back(\"C-\");\n        } else if (g > 1.0f) {\n            result.push_back(\"D+\");\n        } else if (g > 0.7f) {\n            result.push_back(\"D\");\n        } else if (g > 0.0f) {\n            result.push_back(\"D-\");\n        } else {                      // g == 0.0f\n            result.push_back(\"E\");\n        }\n    }\n\n    return result;\n}\n```\n\nThis implementation follows exactly the grading table provided and\nconforms to C++17 standards.", "Here is a straightforward implementation that follows the table exactly.  \nThe function iterates over each GPA value and, using a series of `if\u2011else` checks, appends the correct letter\u2011grade string to the result vector.\n\n```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> numerical_letter_grade(const std::vector<float>& grades) {\n    std::vector<std::string> result;\n    result.reserve(grades.size());          // to avoid many reallocations\n\n    for (float gpa : grades) {\n        if (gpa == 4.0f) {\n            result.emplace_back(\"A+\");\n        } else if (gpa > 3.7f) {\n            result.emplace_back(\"A\");\n        } else if (gpa > 3.3f) {\n            result.emplace_back(\"A-\");\n        } else if (gpa > 3.0f) {\n            result.emplace_back(\"B+\");\n        } else if (gpa > 2.7f) {\n            result.emplace_back(\"B\");\n        } else if (gpa > 2.3f) {\n            result.emplace_back(\"B-\");\n        } else if (gpa > 2.0f) {\n            result.emplace_back(\"C+\");\n        } else if (gpa > 1.7f) {\n            result.emplace_back(\"C\");\n        } else if (gpa > 1.3f) {\n            result.emplace_back(\"C-\");\n        } else if (gpa > 1.0f) {\n            result.emplace_back(\"D+\");\n        } else if (gpa > 0.7f) {\n            result.emplace_back(\"D\");\n        } else if (gpa > 0.0f) {\n            result.emplace_back(\"D-\");\n        } else {            // gpa == 0.0\n            result.emplace_back(\"E\");\n        }\n    }\n\n    return result;\n}\n```\n\n### How it works\n- The GPA values are processed in order.\n- Each `if\u2011else` block checks the GPA against the thresholds from highest to lowest.\n- `emplace_back` is used to construct the string directly in the result vector.\n- The function returns a new vector containing the letter grades in the same order as the input GPAs.\n\nThis implementation respects all the comparison rules stated in the grading table."]}
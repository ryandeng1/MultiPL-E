{"name": "mbpp_17_square_perimeter", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns the perimeter of a square given its side length as input.\nlong square_perimeter(long a) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_17_square_perimeter.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = square_perimeter;\n    assert(candidate((10)) == (40));\n    assert(candidate((5)) == (20));\n    assert(candidate((4)) == (16));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a complete, clean implementation that simply multiplies the side length by\u202f4.  \nI\u2019ve also added a small test harness so you can see it in action.  \nFeel free to drop just the function body (`square_perimeter`) into your codebase if you don\u2019t need the demo.\n\n```cpp\n#include <cassert>\n#include <iostream>\n#include <cmath>\n\n/*\n * Return the perimeter of a square when the side length is given.\n * A square has 4 equal sides, so perimeter = 4 * side.\n */\nlong square_perimeter(long a) {\n    // For this simple problem we can safely compute the product.\n    // If you want to guard against overflow for extremely large values,\n    // you could use a wider integral type (e.g., long long) or do checks.\n    return 4 * a;\n}\n\n/* ----------- optional demo / test harness -------------- */\nint main() {\n    // Basic checks\n    assert(square_perimeter(0) == 0);\n    assert(square_perimeter(1) == 4);\n    assert(square_perimeter(5) == 20);\n    assert(square_perimeter(123456789) == 493827156);\n\n    // Print a quick example\n    long side = 7;\n    std::cout << \"Side: \" << side\n              << \" => Perimeter: \" << square_perimeter(side) << \"\\n\";\n\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\n### Notes\n1. **Data type** \u2013 If you anticipate side lengths that could cause `long` overflow when multiplied by 4, use a wider type such as `long long` or even `__int128` on compilers that support it.\n\n2. **No edge\u2011case handling needed** \u2013 Perimeter is defined for any numeric side length, including negative numbers, in a purely arithmetic sense. If your application demands non\u2011negative side lengths, you can add an `assert` or guard clause.\n\n3. **Header choice** \u2013 Using `<bits/stdc++.h>` is convenient for contests but not a good practice for production code. Stick to the minimal headers you actually need (`<iostream>`, `<cassert>`, etc.).", "Sure! Here\u2019s a straightforward implementation of the `square_perimeter` function in C++:\n\n```cpp\n#include <assert.h>\n\n// Calculate the perimeter of a square given side length `a`.\n// We assume the side length is non\u2011negative; otherwise the result might be\n// logically nonsensical but the function will still return 4 * a.\nlong square_perimeter(long a) {\n    return 4 * a;\n}\n```\n\nYou can optionally add assertions or checks if you want to guard against invalid inputs:\n\n```cpp\nlong square_perimeter(long a) {\n    assert(a >= 0 && \"Side length must be non\u2011negative\");\n    return 4 * a;\n}\n```\n\nNow you can call `square_perimeter(5)` and it will correctly return `20`.", "Here is a simple implementation of the `square_perimeter` function:\n\n```cpp\n// Returns the perimeter of a square with side length `a`.\nlong square_perimeter(long a) {\n    // The perimeter of a square = 4 * side length.\n    return 4 * a;\n}\n```\n\nThis function takes a `long` integer `a` (the side length) and returns `4 * a`, which is the perimeter of the square."]}
{"name": "mbpp_578_interleave_lists", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to interleave 3 vectors of the same length into a single flat vector.\nstd::vector<long> interleave_lists(std::vector<long> list1, std::vector<long> list2, std::vector<long> list3) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_578_interleave_lists.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = interleave_lists;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})), (std::vector<long>({(long)10, (long)20, (long)30, (long)40, (long)50, (long)60, (long)70})), (std::vector<long>({(long)100, (long)200, (long)300, (long)400, (long)500, (long)600, (long)700}))) == (std::vector<long>({(long)1, (long)10, (long)100, (long)2, (long)20, (long)200, (long)3, (long)30, (long)300, (long)4, (long)40, (long)400, (long)5, (long)50, (long)500, (long)6, (long)60, (long)600, (long)7, (long)70, (long)700})));\n    assert(candidate((std::vector<long>({(long)10, (long)20})), (std::vector<long>({(long)15, (long)2})), (std::vector<long>({(long)5, (long)10}))) == (std::vector<long>({(long)10, (long)15, (long)5, (long)20, (long)2, (long)10})));\n    assert(candidate((std::vector<long>({(long)11, (long)44})), (std::vector<long>({(long)10, (long)15})), (std::vector<long>({(long)20, (long)5}))) == (std::vector<long>({(long)11, (long)10, (long)20, (long)44, (long)15, (long)5})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a complete, self\u2011contained implementation of `interleave_lists`.  \nThe function assumes all three input vectors have the same length.  \nIf you want a robust version that checks the sizes at runtime you can   \neither leave the `assert` in place or replace it with a more user\u2011friendly  \nexception.\n\n```cpp\n#include <vector>\n#include <cassert>\n\n/**\n * @brief Interleaves three vectors of equal length into a single vector.\n *\n * The resulting vector contains elements in the order:\n *   list1[0], list2[0], list3[0], list1[1], list2[1], list3[1], \u2026\n *\n * @param list1 The first vector.\n * @param list2 The second vector.\n * @param list3 The third vector.\n * @return A new vector containing the interleaved elements.\n *\n * @throws std::invalid_argument if the input vectors do not have the same length\n *          (only in the error\u2011handling version; the assert\n *          below will terminate the program in debug builds).\n */\nstd::vector<long> interleave_lists(std::vector<long> list1,\n                                   std::vector<long> list2,\n                                   std::vector<long> list3)\n{\n    // In debug mode we trigger an assert if the sizes differ.\n    // In a production build you might want to throw an exception instead.\n    assert(!list1.empty() && list1.size() == list2.size() && list1.size() == list3.size());\n\n    const size_t n = list1.size();\n    std::vector<long> result;\n    result.reserve(3 * n);            // pre\u2011allocate to avoid reallocations\n\n    for (size_t i = 0; i < n; ++i) {\n        result.push_back(list1[i]);\n        result.push_back(list2[i]);\n        result.push_back(list3[i]);\n    }\n\n    return result;\n}\n```\n\n### Example usage\n\n```cpp\nint main() {\n    std::vector<long> a{1, 4, 7};\n    std::vector<long> b{2, 5, 8};\n    std::vector<long> c{3, 6, 9};\n\n    auto interleaved = interleave_lists(a, b, c);\n    // interleaved == {1,2,3,4,5,6,7,8,9}\n}\n```\n\nFeel free to adapt the error\u2011handling strategy to fit your project\u2019s conventions.", "Below is a complete, self\u2011contained implementation of the requested function.  \nIt performs a quick assertion that all three input vectors have the same length, then creates a result vector whose size is the sum of the three lists, and finally interleaves the elements from each list in the order `list1[i]`, `list2[i]`, `list3[i]`.\n\n```cpp\n#include <cassert>\n#include <vector>\n\n/**\n * @brief Interleaves three vectors of the same length into one flat vector.\n *\n * Elements are taken in the following order:\n *   list1[0], list2[0], list3[0], list1[1], list2[1], list3[1], \u2026\n *\n * @param list1  First source vector.\n * @param list2  Second source vector.\n * @param list3  Third source vector.\n * @return       A single vector containing all elements in the interleaved order.\n *\n * @pre  All three input vectors must have the same non\u2011negative length.\n * @throws std::invalid_argument if the lengths differ.\n */\nstd::vector<long> interleave_lists(const std::vector<long>& list1,\n                                   const std::vector<long>& list2,\n                                   const std::vector<long>& list3)\n{\n    // Make sure the lengths match \u2013 this is a logical pre\u2011condition.\n    if (list1.size() != list2.size() || list1.size() != list3.size()) {\n        throw std::invalid_argument(\"All input vectors must have the same length\");\n    }\n\n    const std::size_t n = list1.size();          // length of each input list\n    std::vector<long> result;\n    result.reserve(3 * n);                       // pre\u2011allocate to avoid reallocations\n\n    for (std::size_t i = 0; i < n; ++i) {\n        result.push_back(list1[i]);\n        result.push_back(list2[i]);\n        result.push_back(list3[i]);\n    }\n\n    return result;\n}\n```\n\n### Usage example\n\n```cpp\nint main() {\n    std::vector<long> a = {1, 4, 7};\n    std::vector<long> b = {2, 5, 8};\n    std::vector<long> c = {3, 6, 9};\n\n    auto interleaved = interleave_lists(a, b, c);\n\n    for (auto v : interleaved) {\n        std::cout << v << ' ';\n    }\n    // Output: 1 2 3 4 5 6 7 8 9\n}\n```\n\nThis function is efficient (`O(n)` time, `O(3n)` additional space) and robust, throwing a clear exception when the pre\u2011condition is violated.", "Here is a complete implementation of the function that takes three vectors of the same length (you can add a runtime check if you like) and returns a new vector that contains the elements in interleaved order \u2013 first element of *list1*, first element of *list2*, first element of *list3*, second element of *list1*, \u2026 and so on.\n\n```cpp\n#include <vector>\n#include <cassert>   // for assert\n#include <algorithm> // for std::size\n\n// Interleave three vectors of the same length into a single flat vector.\nstd::vector<long> interleave_lists(const std::vector<long>& list1,\n                                   const std::vector<long>& list2,\n                                   const std::vector<long>& list3)\n{\n    // Ensure all input lists have the same length \u2013 a runtime precondition.\n    assert(list1.size() == list2.size() && list2.size() == list3.size());\n\n    std::size_t n = list1.size();          // all the same\n    std::vector<long> result;\n    result.reserve(3 * n);                 // pre\u2011allocate storage\n\n    for (std::size_t i = 0; i < n; ++i) {\n        result.push_back(list1[i]);       // first list\n        result.push_back(list2[i]);       // second list\n        result.push_back(list3[i]);       // third list\n    }\n\n    return result;\n}\n```\n\n### How it works\n\n1. **Assert the precondition** \u2013 if the three input vectors differ in length the program will abort, making the bug obvious during development.  \n2. **Reserve space** \u2013 `reserve(3*n)` prevents multiple reallocations while we fill `result`.  \n3. **Loop over the indices** \u2013 for each index `i` we append the corresponding element from each of the three input vectors, thereby interleaving them.\n\n### Usage example\n\n```cpp\nint main() {\n    std::vector<long> a{1, 4, 7};\n    std::vector<long> b{2, 5, 8};\n    std::vector<long> c{3, 6, 9};\n\n    auto flat = interleave_lists(a, b, c);\n    for (auto v : flat) std::cout << v << ' ';  // prints: 1 2 3 4 5 6 7 8 9\n}\n```\n\nFeel free to replace `assert` with a more production\u2011ready error handling strategy (throwing an exception, returning an optional, etc.) if your application requires it."]}
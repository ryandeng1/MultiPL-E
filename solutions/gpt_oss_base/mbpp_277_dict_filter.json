{"name": "mbpp_277_dict_filter", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes in a map and integer n and filters the map to only include entries with values greater than or equal to n.\nstd::map<std::string,long> dict_filter(std::map<std::string,long> dict, long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_277_dict_filter.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = dict_filter;\n    assert(candidate((std::map<std::string,long>({{\"Cierra Vega\", 175}, {\"Alden Cantrell\", 180}, {\"Kierra Gentry\", 165}, {\"Pierre Cox\", 190}})), (170)) == (std::map<std::string,long>({{\"Cierra Vega\", 175}, {\"Alden Cantrell\", 180}, {\"Pierre Cox\", 190}})));\n    assert(candidate((std::map<std::string,long>({{\"Cierra Vega\", 175}, {\"Alden Cantrell\", 180}, {\"Kierra Gentry\", 165}, {\"Pierre Cox\", 190}})), (180)) == (std::map<std::string,long>({{\"Alden Cantrell\", 180}, {\"Pierre Cox\", 190}})));\n    assert(candidate((std::map<std::string,long>({{\"Cierra Vega\", 175}, {\"Alden Cantrell\", 180}, {\"Kierra Gentry\", 165}, {\"Pierre Cox\", 190}})), (190)) == (std::map<std::string,long>({{\"Pierre Cox\", 190}})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a simple implementation that builds a new map containing only the entries whose values are **greater than or equal to** `n`.\n\n```cpp\n#include <map>\n#include <string>\n#include <iostream>\n#include <cassert>\n\n// Return a copy of `dict` that contains only the entries\n// whose values are >= n.\nstd::map<std::string, long>\ndict_filter(const std::map<std::string, long>& dict, long n)\n{\n    std::map<std::string, long> filtered;\n\n    // Iterate over the original map and insert only the qualifying elements\n    for (const auto& kv : dict) {\n        if (kv.second >= n) {\n            filtered.emplace(kv.first, kv.second);\n        }\n    }\n\n    return filtered;\n}\n\n// ---------- Demo / unit test ----------\nint main() {\n    std::map<std::string, long> src = {\n        {\"a\", 2},\n        {\"b\", 5},\n        {\"c\", 1},\n        {\"d\", 4}\n    };\n\n    auto res = dict_filter(src, 3);\n\n    // Expect {b=5, d=4}\n    assert(res.size() == 2);\n    assert(res.at(\"b\") == 5);\n    assert(res.at(\"d\") == 4);\n\n    // Print the result\n    for (const auto& kv : res){\n        std::cout << kv.first << \" : \" << kv.second << '\\n';\n    }\n\n    std::cout << \"All good!\\n\";\n}\n```\n\n### Explanation\n\n1. **Signature**  \n   ```cpp\n   std::map<std::string, long> dict_filter(const std::map<std::string, long>& dict, long n);\n   ```\n   The original map is passed by `const&` to avoid copying. The function returns a *new* map.\n\n2. **Iteration**  \n   Using a range\u2011based for loop, each key\u2011value pair (`kv`) is inspected.  \n   `kv.second` holds the value.\n\n3. **Condition**  \n   ```cpp\n   if (kv.second >= n)\n   ```\n   Only when the value meets the condition do we copy the pair into `filtered`.  \n   `emplace(kv.first, kv.second)` inserts the pair without an extra copy.\n\n4. **Return**  \n   The filtered map is returned by value; move semantics will ensure this is efficient.\n\n5. **Demo**  \n   The `main()` function shows a tiny test and prints the result (`b : 5` and `d : 4`).  \n\nFeel free to drop this function into any project that uses `std::map<std::string,long>`!", "Here\u2019s a small, self\u2011contained snippet that does exactly what you described:  \n*It receives a `std::map<std::string, long>` and an integer threshold `n`, and returns a **new** map that only contains the key/value pairs whose value is **\u2265\u202fn**.*\n\n```cpp\n#include <map>\n#include <string>\n\n// ------------------------------------------------------------------\n///  Filters the given map and keeps only entries whose value is\n///  greater than or equal to `n`.\n///\n///  @param dict  The map to filter (key  = string, value = long).\n///  @param n     The minimum value threshold.\n///  @return      A new map that contains only the qualified\n///                key/value pairs.\n///\nstd::map<std::string, long>\ndict_filter(const std::map<std::string, long>& dict, long n)\n{\n    std::map<std::string, long> result;\n\n    for (const auto& kv : dict)          // read\u2011only iteration\n    {\n        if (kv.second >= n)              // value check\n        {\n            result.emplace(kv.first, kv.second);\n        }\n    }\n\n    return result;                       // return by value (copy elision)\n}\n```\n\n### How it works\n1. **`for (const auto& kv : dict)`** \u2013 iterates over the source map without modifying it.\n2. **`if (kv.second >= n)`** \u2013 keeps only those entries whose value meets the threshold.\n3. **`result.emplace(kv.first, kv.second);`** \u2013 inserts the accepted pair into the result map.\n4. The function returns a freshly constructed map \u2013 the caller can decide to keep it or discard it.\n\nYou can call it like this:\n\n```cpp\nint main()\n{\n    std::map<std::string, long> data = {{\"a\", 10}, {\"b\", 5}, {\"c\", 20}};\n    auto filtered = dict_filter(data, 10);\n\n    for (const auto& p : filtered)\n        std::cout << p.first << \": \" << p.second << '\\n'; // prints a:10, c:20\n}\n```\n\nFeel free to adapt the signature (e.g., pass by reference if you want to mutate the original map) or the container type (e.g., `unordered_map`) depending on your specific needs.", "Here\u2019s a clean, self\u2011contained implementation of `dict_filter`.  \nThe function copies the original map and removes any entry whose value is **strictly** lower than the supplied threshold `n`.  \nI also added a small unit\u2011test in the `main()` function so you can see the behaviour immediately when you compile and run the program.\n\n```cpp\n#include <iostream>\n#include <map>\n#include <string>\n\n// ------------------------------------------------------------------\n// dict_filter\n//\n// Parameters:\n//   dict : the input map whose contents we want to filter.\n//   n    : the threshold value.\n//\n// Returns:\n//   A new std::map<std::string,long> that contains only those\n//   key/value pairs from *dict whose value is >= n*.\n//\n//   The original map is left untouched \u2013 we work on a copy.\n// ------------------------------------------------------------------\nstd::map<std::string,long> dict_filter(\n    const std::map<std::string,long>& dict, long n)\n{\n    // Make a copy \u2013 the caller passes by reference so we don't modify\n    // the original map in place.\n    std::map<std::string,long> result = dict;\n\n    for (auto it = result.begin(); it != result.end(); )\n    {\n        if (it->second < n)\n            it = result.erase(it);      // erase returns the next iterator\n        else\n            ++it;\n    }\n\n    return result;\n}\n\n// ------------------------------------------------------------------\n// Demo / simple test\n// ------------------------------------------------------------------\nint main()\n{\n    std::map<std::string,long> m;\n    m[\"apple\"]  =  4;\n    m[\"banana\"] =  2;\n    m[\"cherry\"] =  7;\n    m[\"date\"]   =  1;\n\n    std::cout << \"Original map:\\n\";\n    for (auto const &p : m)\n        std::cout << \"  \" << p.first << \" -> \" << p.second << '\\n';\n\n    long threshold = 3;\n    std::map<std::string,long> filtered = dict_filter(m, threshold);\n\n    std::cout << \"\\nFiltered (>= \" << threshold << \"):\\n\";\n    for (auto const &p : filtered)\n        std::cout << \"  \" << p.first << \" -> \" << p.second << '\\n';\n\n    return 0;\n}\n```\n\n### How it works\n1. **Copy** the input map (`result = dict`).  \n   *The caller provided a `const&` so the original remains untouched.*\n\n2. Iterate over `result` using an iterator.  \n   If `it->second` (the stored `long`) is **less** than `n`, erase that element.  \n   `erase` returns an iterator pointing to the next element, which we use to continue the loop.\n\n3. When the loop finishes, `result` contains only entries with values `>= n`, and we return it.\n\n### Compile & run\n```bash\ng++ -std=c++17 -O2 -Wall -pedantic demo.cpp -o demo\n./demo\n```\n\nYou should see something like:\n\n```\nOriginal map:\n  apple -> 4\n  banana -> 2\n  cherry -> 7\n  date -> 1\n\nFiltered (>= 3):\n  apple -> 4\n  cherry -> 7\n```\n\nFeel free to adjust the `threshold` or input data to suit your needs."]}
{"name": "HumanEval_104_unique_digits", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_104_unique_digits.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = unique_digits;\n    assert(candidate((std::vector<long>({(long)15, (long)33, (long)1422, (long)1}))) == (std::vector<long>({(long)1, (long)15, (long)33})));\n    assert(candidate((std::vector<long>({(long)152, (long)323, (long)1422, (long)10}))) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)12345, (long)2033, (long)111, (long)151}))) == (std::vector<long>({(long)111, (long)151})));\n    assert(candidate((std::vector<long>({(long)135, (long)103, (long)31}))) == (std::vector<long>({(long)31, (long)135})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a complete and idiomatic implementation of `unique_digits`.  \nIt iterates over the input vector, checks each number for the presence of an\neven digit, keeps those that have **only odd digits**, sorts the result, and\nreturns it.\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <cctype>   // for std::isdigit\n\n// return a sorted vector of all elements that don't contain any even digit\nstd::vector<long> unique_digits(std::vector<long> x)\n{\n    std::vector<long> result;\n\n    for (long num : x)\n    {\n        // work with the absolute value in case negative numbers were ever\n        // introduced \u2013 the statement says \u201cpositive integers\u201d, but this keeps\n        // the function robust.\n        long n = std::abs(num);\n\n        bool has_even = false;\n        if (n == 0)           // 0 has an even digit\n            has_even = true;\n        else\n        {\n            while (n > 0)\n            {\n                int digit = n % 10;          // extract last digit\n                if (digit % 2 == 0)          // even digit found\n                {\n                    has_even = true;\n                    break;\n                }\n                n /= 10;\n            }\n        }\n\n        if (!has_even)     // keep numbers that contain only odd digits\n            result.push_back(num);\n    }\n\n    std::sort(result.begin(), result.end());   // increasing order\n    return result;\n}\n```\n\n### What the code does\n\n1. **Loop over each number** in `x`.\n2. **Extract digits** using modulo/division.\n3. **Stop early** if an even digit is detected.\n4. **Collect** numbers that contain only odd digits.\n5. **Sort** the collected numbers in ascending order before returning.\n\nThe implementation runs in \\(O(n \\log n + D)\\) time where `n` is the size of\nthe input vector and `D` is the total number of decimal digits in all\nelements. It uses only standard library facilities and compiles under\nC++11 and later.", "Here\u2019s a clean, modern implementation of the required function.  \nIt uses only the standard library and follows the C++17 (or newer) style.\n\n```cpp\n#include <vector>\n#include <algorithm>\n\n/// Return a sorted vector containing all numbers of @p v that\n/// consist of digits 1\u20119 only (i.e. no even digit).\n/// @param v Input vector of positive integers.\n/// @return Sorted vector with the desired values.\n/// @note If @p v is empty, the returned vector is empty.\nstd::vector<long> unique_digits(const std::vector<long>& v)\n{\n    std::vector<long> result;\n\n    for (auto n : v)            // iterate through the original vector\n    {\n        long temp = n;\n        bool ok = true;\n\n        if (temp == 0)          // quick rejection \u2013 0 contains even digit 0\n            ok = false;\n\n        while (temp > 0 && ok)\n        {\n            int digit = static_cast<int>(temp % 10);\n            if (digit % 2 == 0) // even digit found\n                ok = false;\n            temp /= 10;\n        }\n\n        if (ok)\n            result.push_back(n);\n    }\n\n    std::sort(result.begin(), result.end());\n    return result;\n}\n```\n\n### Why this implementation?\n\n* **Safety & clarity** \u2013 we treat the input as `const` so we don\u2019t modify it.\n* **No external dependencies** \u2013 only `vector` and `algorithm` are used.\n* **Single pass** \u2013 each number is examined once, with a simple modulus\u2011by\u201110 loop.\n* **Constant extra space per element** \u2013 aside from the output vector, no extra memory is used.\n\nFeel free to adjust the signature (e.g., pass by value or move semantic) if you prefer a different calling convention.", "Here is a minimal, self\u2011contained implementation that fulfills the requirements:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic bool has_even_digit(long v) {\n    if (v == 0) return true;          // 0 is an even digit\n    while (v > 0) {\n        long d = v % 10;\n        if (d % 2 == 0) return true;  // found even digit\n        v /= 10;\n    }\n    return false;                     // all digits are odd\n}\n\nvector<long> unique_digits(vector<long> x) {\n    vector<long> result;\n    result.reserve(x.size());\n\n    for (long v : x) {\n        if (!has_even_digit(v))   // keep only numbers with no even digit\n            result.push_back(v);\n    }\n\n    sort(result.begin(), result.end());   // ascending order\n    return result;\n}\n```\n\n**Explanation**\n\n1. `has_even_digit` scans the decimal representation of a number looking for any even digit (0, 2, 4, 6, 8).  \n2. In `unique_digits`, every element of the input vector is tested; those passing the test are collected.  \n3. The resulting vector is sorted before being returned, guaranteeing the order required by the problem statement.\n\nThis implementation works with the examples:\n\n```cpp\nunique_digits({15, 33, 1422, 1});      // \u2192 {1,15,33}\nunique_digits({152, 323, 1422, 10});   // \u2192 {}\n```\n"]}
{"name": "HumanEval_82_prime_length", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_82_prime_length.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = prime_length;\n    assert(candidate((\"Hello\")) == (true));\n    assert(candidate((\"abcdcba\")) == (true));\n    assert(candidate((\"kittens\")) == (true));\n    assert(candidate((\"orange\")) == (false));\n    assert(candidate((\"wow\")) == (true));\n    assert(candidate((\"world\")) == (true));\n    assert(candidate((\"MadaM\")) == (true));\n    assert(candidate((\"Wow\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"HI\")) == (true));\n    assert(candidate((\"go\")) == (true));\n    assert(candidate((\"gogo\")) == (false));\n    assert(candidate((\"aaaaaaaaaaaaaaa\")) == (false));\n    assert(candidate((\"Madam\")) == (true));\n    assert(candidate((\"M\")) == (false));\n    assert(candidate((\"0\")) == (false));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a minimal, self\u2011contained implementation that follows the behaviour shown in the\nexamples.  \nThe function returns `true` if the length of the supplied string is a prime\nnumber and `false` otherwise.  It contains a small helper to test for primality,\nand doesn't use any non\u2011standard headers, so it compiles with a standard C++ compiler.\n\n```cpp\n#include <string>\n#include <cmath>    // for std::sqrt\n\n// Helper that tells if a number is prime\nbool is_prime(size_t n) {\n    if (n < 2)            return false;   // 0, 1 are not prime\n    if (n == 2 || n == 3) return true;    // 2 and 3 are prime\n    if (n % 2 == 0)       return false;   // even numbers >2 are not prime\n\n    // test odd divisors up to sqrt(n)\n    for (size_t d = 3; d <= static_cast<size_t>(std::sqrt(n)); d += 2) {\n        if (n % d == 0) return false;\n    }\n    return true;\n}\n\n// ---------------------------------------------------------------\n// Returns true if the length of `str` is a prime number.\nbool prime_length(const std::string& str) {\n    return is_prime(str.size());\n}\n```\n\n### How it works\n1. **Prime test (`is_prime`)**  \n   * Handles edge cases: `0` and `1` are not prime.  \n   * 2 and 3 are the only even prime.  \n   * Any even number larger than 2 is composite.  \n   * For odd numbers, we only need to try divisors up to the square root,\n     skipping even divisors.\n\n2. **`prime_length`**  \n   Simply forwards the length of the string to `is_prime`.  \n   The function takes the string by `const` reference to avoid an unnecessary copy.\n\n### Example usage\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << prime_length(\"Hello\")     << '\\n'; // true (length 5)\n    std::cout << prime_length(\"abcdcba\")   << '\\n'; // true (length 7)\n    std::cout << prime_length(\"kittens\")   << '\\n'; // true (length 7)\n    std::cout << prime_length(\"orange\")    << '\\n'; // false (length 6)\n}\n```\n\nThis implementation is concise, easy to read, and fully compliant with modern C++ standards.", "Here\u2019s a concise, self\u2011contained implementation that follows the signature you gave:\n\n```cpp\n#include <string>\n#include <cmath>\n\nbool prime_length(const std::string& s) {\n    size_t n = s.length();\n\n    // 0 and 1 are not prime\n    if (n < 2) return false;\n\n    // even numbers greater than 2 are not prime\n    if (n % 2 == 0) return n == 2;\n\n    // check odd divisors up to sqrt(n)\n    for (size_t d = 3; d <= static_cast<size_t>(std::sqrt(n)); d += 2) {\n        if (n % d == 0) return false;\n    }\n    return true;\n}\n```\n\n### How it works\n1. **Length**: We get the length of the string (`s.length()`).\n2. **Fast checks**:  \n   - If `n < 2`, it isn\u2019t prime.  \n   - If `n` is even, it\u2019s prime only when it\u2019s `2`.  \n3. **Trial division**: We test odd divisors from `3` up to `sqrt(n)`; if any divide `n`, it isn\u2019t prime.\n4. **Return**: If no divisor is found, the length is prime.\n\nYou can test it with the examples you gave:\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << prime_length(\"Hello\") << '\\n';      // 5 -> true\n    std::cout << prime_length(\"abcdcba\") << '\\n';    // 7 -> true\n    std::cout << prime_length(\"kittens\") << '\\n';    // 7 -> true\n    std::cout << prime_length(\"orange\") << '\\n';     // 6 -> false\n}\n```\n\nCompile with `g++ -std=c++17 -Wall` and run; the output matches the expected results.", "Here\u2019s a minimal, self\u2011contained implementation that follows the specification and also includes the guard for the function name.  \nIt uses a small helper to test primality, works with any C++17/20 compiler, and contains a `main` demonstrating the examples.\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cmath>\n\n// ---------- helper: is a number prime? ----------\nbool is_prime(size_t n) {\n    if (n < 2) return false;          // 0 and 1 are not prime\n    if (n == 2) return true;          // 2 is the only even prime\n    if (n % 2 == 0) return false;     // eliminate even numbers\n\n    // trial division up to sqrt(n)\n    for (size_t d = 3; d <= static_cast<size_t>(std::sqrt(n)); d += 2) {\n        if (n % d == 0) return false;\n    }\n    return true;\n}\n\n// ---------- required function ----------\nbool prime_length(const std::string& s) {\n    return is_prime(s.size());\n}\n\n// ---------- demo (for your own verification) ----------\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << \"prime_length(\\\"Hello\\\") -> \" << prime_length(\"Hello\") << '\\n';        // true\n    std::cout << \"prime_length(\\\"abcdcba\\\") -> \" << prime_length(\"abcdcba\") << '\\n';    // true\n    std::cout << \"prime_length(\\\"kittens\\\") -> \" << prime_length(\"kittens\") << '\\n';    // true\n    std::cout << \"prime_length(\\\"orange\\\") -> \" << prime_length(\"orange\") << '\\n';      // false\n    return 0;\n}\n```\n\n### How it works\n1. **Prime check** \u2013 `is_prime` efficiently determines if an integer `n` is prime by checking divisibility up to `sqrt(n)`.  \n2. **`prime_length`** \u2013 simply passes the string\u2019s length to `is_prime`.  \n3. The `main` function is an optional test harness; you can remove it if you only need the function.\n\nFeel free to copy\u2011paste this into your project. If you prefer a more optimized or alternative primality test, just replace the `is_prime` implementation."]}
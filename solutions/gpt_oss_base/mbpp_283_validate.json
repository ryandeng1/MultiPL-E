{"name": "mbpp_283_validate", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function takes in an integer and check whether the frequency of each digit in the integer is less than or equal to the digit itself.\nbool validate(long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_283_validate.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = validate;\n    assert(candidate((1234)) == (true));\n    assert(candidate((51241)) == (false));\n    assert(candidate((321)) == (true));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a complete, minimal implementation that follows the specification:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// @brief Checks whether the frequency of each decimal digit in `n`\n///        is less than or equal to the digit itself.\n/// @param n The integer to validate.  Can be negative; the sign\n///          is ignored for the purpose of frequency counting.\n///\n/// @return true  \u2013 if for every digit d (0\u20119) the number of times d\n///                 appears in |n| is \u2264 d.\n/// @return false \u2013 otherwise.\nbool validate(long long n)\n{\n    // Work with the absolute value because negative sign\n    // does not contribute to the digit frequencies.\n    n = llabs(n);\n\n    // Count occurrences of every digit 0\u20119.\n    int freq[10] = {0};\n\n    // Special case : 0 itself.\n    if (n == 0) {\n        freq[0] = 1;\n    } else {\n        while (n > 0) {\n            int digit = n % 10;\n            ++freq[digit];\n            n /= 10;\n        }\n    }\n\n    // Verify the condition for every digit.\n    for (int d = 0; d <= 9; ++d) {\n        if (freq[d] > d) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/* --------------------------------------------------------------------\n   Example usage\n   -------------------------------------------------------------------- */\nint main()\n{\n    vector<long long> tests = {0, 123, 224, 1112, 0012345678LL};\n\n    for (long long x : tests) {\n        cout << x << \" \u2192 \" << (validate(x) ? \"valid\" : \"invalid\") << '\\n';\n    }\n    return 0;\n}\n```\n\n### How it works\n\n1. **Absolute value** \u2013 The leading sign doesn\u2019t matter for digit counts, so we convert `n` to its absolute value.\n2. **Frequency array** \u2013 `freq[d]` holds how many times digit `d` occurs.\n3. **Special case for zero** \u2013 Because the loop `while (n > 0)` would skip `0`, we handle it explicitly by setting `freq[0] = 1` if the number itself is `0`.\n4. **Validation** \u2013 After counting, we check each digit `d`.  \n   If `freq[d]` exceeds `d`, the condition fails and the function returns `false`.  \n   If all digits satisfy the condition, it returns `true`.\n\n### Complexity\n\n- **Time:**  \\(O(\\log_{10} n)\\) \u2013 we inspect each decimal digit once.\n- **Space:**  \\(O(1)\\) \u2013 only the fixed\u2011size frequency array.\n\nFeel free to adapt the `main()` function or integrate `validate()` into your own codebase.", "Below is a complete, self\u2011contained C++ implementation that follows the description:\n\n* **Goal** \u2013 For a given non\u2011negative integer `n`, verify that for every digit `d` in `n` the number of times that `d` appears in the decimal representation of `n` is **\u2264\u202fd**.\n* **Behaviour** \u2013  \n  * For digits 0\u20139 the rule is checked individually.  \n  * Leading zeros do not occur in the standard decimal representation of an integer, so they are never counted.  \n  * If `n` is 0, the only digit is 0 and it appears once \u2013 the rule **fails** because `1 > 0`.  \n* **Return value** \u2013 `true` if the rule holds for all digits, otherwise `false`.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// @brief Checks whether each digit d in n occurs at most d times.\n/// @param n Non\u2011negative integer to test.\n/// @return true if the condition holds for all digits, false otherwise.\nbool validate(long long n) {\n    if (n < 0) return false;          // The problem statement talks about \u201cinteger\u201d,\n                                      // but we only consider non\u2011negative values.\n\n    // Frequency array for digits 0\u20119\n    int freq[10] = {0};\n\n    // Special case: n == 0 \u2013 its only digit is 0\n    if (n == 0) {\n        freq[0] = 1;                   // one occurrence of digit 0\n    } else {\n        // Count every digit in n\n        while (n > 0) {\n            int d = n % 10;\n            ++freq[d];\n            n /= 10;\n        }\n    }\n\n    // Validate the condition for each digit\n    for (int d = 0; d <= 9; ++d) {\n        if (freq[d] > d) {\n            return false;              // rule violated\n        }\n    }\n    return true;                       // all digits satisfy freq <= digit\n}\n\n/* ---------------------  Example usage & tests  --------------------- */\nint main() {\n    vector<long long> tests = {123, 122345, 1111, 20, 0, 121, 555, 9876543210LL};\n\n    for (auto n : tests) {\n        cout << n << \" -> \" << (validate(n) ? \"VALID\" : \"INVALID\") << '\\n';\n    }\n    return 0;\n}\n```\n\n### Explanation of the algorithm\n\n1. **Frequency counting**  \n   * We use a small array `freq[10]` to keep the number of occurrences of each digit 0\u20139.  \n   * The standard digit\u2011extraction loop (`n % 10` / `n /= 10`) fills this array.\n\n2. **Validation**  \n   * After all digits are counted, we simply compare each `freq[d]` with its digit `d`.  \n   * If any frequency exceeds the digit value, we immediately return `false`.\n\n3. **Complexity**  \n   * The algorithm scans each decimal digit exactly once, so the running time is  \n     **O(number\u202fof\u202fdigits)** \u2013 in practice O(log\u2081\u2080\u202fn).  \n   * The memory usage is constant: five integers for the frequency array.\n\nFeel free to drop the `main()` test harness into any project that needs this check.", "Here\u2019s a concise, ANSI\u2011C++ compliant implementation that does exactly what you described:\n\n```cpp\n#include <cstdint>\n#include <array>\n\n/*  validate\n *\n *  Parameters\n *      n \u2013 a non\u2011negative integer (its sign is ignored because a\n *           negative sign cannot appear in the digit frequency).\n *\n *  Return\n *      true  \u2013 for every digit d that appears in n, the number of\n *               occurrences of d is \u2264 d.\n *      false \u2013 otherwise.\n *\n *  Example\n *      n = 122333  \u2192  1 appears once, 2 appears twice (\u22642), 3 appears\n *                      three times (\u22643) \u2192 true\n *      n = 4445    \u2192 4 appears three times (\u22644) but 5 appears once\n *                      (\u22645) \u2192 true   (but 0 never appears, so we\n *                      ignore it); if some digit were to appear\n *                      more times than its value, the function\n *                      would return false.\n *\n *  Note: 0 is ignored because we cannot ask \u201cis the number of zeros\n *  \u2264 0?\u201d \u2013 the only possible value (0) would always satisfy the\n *  condition, but for the purpose of this problem you can treat it\n *  as a special case if you want.  The code below explicitly skips\n *  digit 0 so that 0 does not affect the result.\n */\nbool validate(int64_t n)\n{\n    if (n < 0) n = -n;          // work only with the absolute value\n\n    // We only need 10 counters \u2013 one for each decimal digit 0\u20139.\n    std::array<int,10> freq{};\n\n    // Count the digits\n    do {\n        ++freq[ n % 10 ];\n        n /= 10;\n    } while (n > 0);\n\n    // Verify the constraint\n    for (int d = 1; d <= 9; ++d)   // we skip d = 0\n    {\n        if (freq[d] > d) return false;\n    }\n\n    return true;\n}\n```\n\n### How it works\n\n1. **Absolute value** \u2013 Since negative numbers are not expected in the problem statement, we simply take the absolute value so that we can treat every digit identically.\n\n2. **Counting** \u2013 We iterate over the number digit by digit, updating a 10\u2011element array `freq`.  \n   `freq[0]` holds the count of zeroes, `freq[1]` the count of ones, \u2026 `freq[9]` the count of nines.\n\n3. **Validation** \u2013 For each digit `d` from 1 to 9 we check that `freq[d] \u2264 d`.  \n   The digit 0 is intentionally skipped: the only way to violate the rule with zero would be an infinite number of zeroes, so we treat it as \u201calways satisfied\u201d.\n\n4. **Result** \u2013 If all digits satisfy the rule, we return `true`; otherwise we immediately return `false`.\n\nFeel free to drop the function into any C++ file or adapt it to your test harness."]}
{"name": "mbpp_71_comb_sort", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to sort a vector of elements.\nstd::vector<long> comb_sort(std::vector<long> nums) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_71_comb_sort.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = comb_sort;\n    assert(candidate((std::vector<long>({(long)5, (long)15, (long)37, (long)25, (long)79}))) == (std::vector<long>({(long)5, (long)15, (long)25, (long)37, (long)79})));\n    assert(candidate((std::vector<long>({(long)41, (long)32, (long)15, (long)19, (long)22}))) == (std::vector<long>({(long)15, (long)19, (long)22, (long)32, (long)41})));\n    assert(candidate((std::vector<long>({(long)99, (long)15, (long)13, (long)47}))) == (std::vector<long>({(long)13, (long)15, (long)47, (long)99})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a minimal, self\u2011contained implementation of **Comb Sort** for a `std::vector<long>`.  \nThe function accepts a copy of the input vector and returns a sorted one (ascending order). No external library beyond the C++ Standard Library is required \u2013 `#include <bits/stdc++.h>` is kept only for illustrative purposes.\n\n```cpp\n//--------------------------------------------\n// Comb Sort \u2013 C++ implementation\n//--------------------------------------------\n#include <bits/stdc++.h>   // for vector, swap, etc.\nusing namespace std;\n\n/**\n * @brief Sorts a vector of long integers using the Comb Sort algorithm.\n *        The algorithm repeatedly compares elements that are a certain\n *        \"gap\" apart and reduces that gap until 1 (ordinary bubble\u2011swap).\n *\n * @param nums Input vector to be sorted.  The function works on a\n *             copy, so the original vector is left untouched.\n * @return std::vector<long>  The sorted vector.\n */\nstd::vector<long> comb_sort(std::vector<long> nums)\n{\n    const double shrink_factor = 1.3;   // Classic shrink factor\n    size_t gap = nums.size();           // Start with the whole vector as the gap\n    bool swapped = true;                // To keep the loop going until nothing changes\n\n    while (gap > 1 || swapped) {\n        // Shrink the gap for the next iteration\n        if (gap > 1)\n            gap = static_cast<size_t>(gap / shrink_factor);\n\n        swapped = false;               // No swaps yet this pass\n\n        // Compare and possibly swap each distant element pair\n        for (size_t i = 0; i + gap < nums.size(); ++i) {\n            if (nums[i] > nums[i + gap]) {\n                std::swap(nums[i], nums[i + gap]);\n                swapped = true;        // At least one swap occurred\n            }\n        }\n    }\n    return nums;\n}\n```\n\n### How it works\n1. **Gap shrinking** \u2013 Starts with the entire vector\u2019s length as the gap.  \n   Each pass reduces the gap by a shrink factor (`\u2248 1.3`), converging to 1.\n2. **Comparisons** \u2013 For every index `i`, compare `nums[i]` with\n   `nums[i + gap]`. If out of order, swap them.\n3. **Termination** \u2013 The loop stops when the gap becomes `1` and no\n   swaps occur in a full pass (i.e., the vector is sorted).\n\n### Complexity\n- Worst\u2011case time:\u202f\\(O(n^2)\\) (better than bubble sort in practice).\n- Best\u2011case time (already sorted):\u202f\\(O(n \\log_{\\alpha} n)\\), where `\u03b1` is the shrink factor (`\u22481.3`).\n- Extra space:\u202f\\(O(1)\\) (in\u2011place).\n\nFeel free to drop this function into your project and call it like:\n\n```cpp\nstd::vector<long> data = { 3, 1, 4, 1, 5, 9, 2 };\nauto sorted = comb_sort(data);\n// sorted now holds {1,1,2,3,4,5,9}\n```\n\nHappy sorting!", "Below is a complete, self\u2011contained implementation of a **Comb Sort** routine for any vector of numeric types (in this case `long`).  \nThe function works on a copy of the input vector \u2013 the caller retains the original data \u2013 and returns a sorted vector.  \nI also added a small test harness so you can see the function in action.\n\n```cpp\n#include <vector>\n#include <iostream>\n#include <cmath>      // for std::floor\n#include <cstdint>    // for std::int64_t\n\n// ------------------------------------------------------------\n// Comb\u2011Sort :  O(n^2) in the worst case, O(n log n) on average.\n// ------------------------------------------------------------\nstd::vector<long> comb_sort(const std::vector<long>& nums)\n{\n    // Make a modifiable copy of the input\n    std::vector<long> arr(nums);\n\n    // Shrink factor \u2013 the classic choice is 1.3\n    constexpr double shrink = 1.3;\n\n    std::size_t gap = arr.size();\n    bool swapped = true;          // to kick\u2011start the loop\n\n    while (gap > 1 || swapped) {\n        // Update the gap \u2013 avoid gap becoming 0\n        if (gap > 1) {\n            gap = static_cast<std::size_t>(std::floor(gap / shrink));\n            if (gap == 0) gap = 1;\n        }\n\n        swapped = false;\n\n        // Compare neighbouring elements that are 'gap' apart\n        for (std::size_t i = 0; i + gap < arr.size(); ++i) {\n            if (arr[i] > arr[i + gap]) {\n                std::swap(arr[i], arr[i + gap]);\n                swapped = true;\n            }\n        }\n    }\n\n    return arr;\n}\n\n// ------------------------------------------------------------\n// Optional: A tiny test harness\n// ------------------------------------------------------------\nint main()\n{\n    std::vector<long> unsorted = { 823, 31, 546, 204, 12, 89, 7, 314, 456, 23 };\n    std::cout << \"Original: \";\n    for (auto v : unsorted) std::cout << v << ' ';\n    std::cout << '\\n';\n\n    auto sorted = comb_sort(unsorted);\n\n    std::cout << \"Sorted  : \";\n    for (auto v : sorted) std::cout << v << ' ';\n    std::cout << '\\n';\n}\n```\n\n### How it works\n\n1. **Gap management**  \n   *Start with `gap = n`.*  \n   In each pass reduce `gap` by the shrink factor (\u2248 1.3).  \n   When the gap becomes `1` the algorithm is essentially the classic bubble\u2011sort pass;  \n   the loop terminates when no swaps occur after a pass with `gap == 1`.\n\n2. **Swapping**  \n   Elements whose indices differ by `gap` are compared, and swapped if out of order.  \n   Any swap resets the `swapped` flag, forcing another pass with the current gap.\n\n3. **Result**  \n   The function returns the element\u2011wise sorted vector; the original vector remains untouched.\n\nFeel free to plug this function into your project or adapt it to other numeric types by templating if needed.", "Here is a complete working implementation of `comb_sort` that takes a `std::vector<long>` (you can change the type if you want) and returns a sorted copy of it.  \nThe function uses the classic Comb sort algorithm, which is a simple generalisation of bubble\u2011sort that eliminates \u201cturtles\u201d (small elements that are far away from where they belong) by using a gap that decreases over time.\n\n```cpp\n#include <vector>\n#include <cmath>   // for std::ceil\n#include <cstddef> // for std::size_t\n\n// ---------------------------------------------------------------------------\n// Comb sort\n// ---------------------------------------------------------------------------\n// Parameter:    nums -- the vector to be sorted (unsorted copy is taken).\n//\n// Returns:      a new vector containing the sorted elements.\n// ----------------------------------------------------------------------------\nstd::vector<long> comb_sort(std::vector<long> nums)\n{\n    // The initial gap is the size of the vector.\n    std::size_t gap = nums.size();\n\n    // The shrink factor; 1.3 is the common choice.\n    const double shrink = 1.3;\n\n    // Keep looping until the gap has been reduced to 1 and no swap has\n    // occurred in the last pass.\n    bool swapped = true;\n\n    while (gap > 1 || swapped)\n    {\n        // Reduce the gap; we use ceil to avoid unfairly truncating the\n        // divisor (gap can become fractional).\n        gap = static_cast<std::size_t>(std::ceil(gap / shrink));\n        if (gap < 1) gap = 1;\n\n        swapped = false;\n\n        // Compare elements that are `gap` positions apart.\n        for (std::size_t i = 0; i + gap < nums.size(); ++i)\n        {\n            if (nums[i] > nums[i + gap])\n            {\n                std::swap(nums[i], nums[i + gap]);\n                swapped = true;\n            }\n        }\n    }\n\n    return nums;\n}\n```\n\n### How it works\n\n1. **Initial gap** \u2013 starts at the vector length.\n2. **Shrink factor** \u2013 after each pass the gap is divided by 1.3  \n   (the classic choice; you can experiment with other values, e.g. 1.2 or 1.7).\n3. **Pass** \u2013 in each pass we compare and potentially swap every pair of\n   elements that are exactly `gap` indices apart.\n4. **Termination** \u2013 when the gap reaches 1 and a full pass makes\n   no swaps, the vector is sorted.\n\n### Complexity\n\n*Average / worst case:* **O(n\u202flog\u202fn)**  \n*Best case:* **O(n)** (already sorted vector; only the 1\u2011gap pass is executed).\nThe algorithm is easy to understand and requires only a few lines, making it a nice choice for small projects or teaching purposes."]}
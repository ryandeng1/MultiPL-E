{"name": "HumanEval_79_decimal_to_binary", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_79_decimal_to_binary.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["```cpp\n#include <string>\n#include <algorithm>\n\nstd::string decimal_to_binary(long decimal) {\n    // Handle 0 as a special case\n    if (decimal == 0) {\n        return std::string(\"db0db\");\n    }\n\n    std::string bits;\n    while (decimal > 0) {\n        bits.push_back((decimal & 1) ? '1' : '0'); // take least significant bit\n        decimal >>= 1;\n    }\n    std::reverse(bits.begin(), bits.end());          // bits were collected LSB \u2192 MSB\n\n    return \"db\" + bits + \"db\";\n}\n```\n\n**Explanation**\n\n1. For `decimal == 0` we simply return `\"db0db\"`.\n2. While `decimal` is non\u2011zero we push the least significant bit (`decimal & 1`) to `bits` and shift `decimal` right.\n3. The bits are generated in reverse order (LSB first), so we reverse the string.\n4. Finally we prepend and append `\"db\"` to obtain `\"db<binary>db\"` as required.", "Here\u2019s a compact, self\u2011contained implementation that follows the specification:\n\n```cpp\n#include <string>\n\n/// Convert a non\u2011negative decimal number to the required \u201cdb\u2026db\u201d format.\n///\n/// For example:\n///   decimal_to_binary(15)  -->  \"db1111db\"\n///   decimal_to_binary(32)  -->  \"db100000db\"\n///\n/// The function assumes that `decimal` is non\u2011negative.  If a negative\n/// value is passed the behaviour is undefined (you could add an assertion\n/// or throw an exception if you prefer).\n///\nstd::string decimal_to_binary(long decimal) {\n    if (decimal < 0) {\n        // Uncomment the line below if you want defensive programming.\n        // throw std::invalid_argument(\"decimal_to_binary only accepts non\u2011negative values\");\n    }\n\n    // Special case for zero \u2013 the binary representation is just \u201c0\u201d.\n    if (decimal == 0)\n        return std::string(\"db0db\");\n\n    std::string bin;          // will hold the binary digits in reverse order\n    long n = decimal;\n\n    while (n > 0) {\n        bin.push_back(char('0' + (n & 1)));  // push least\u2011significant bit\n        n >>= 1;\n    }\n\n    // bin is reversed; reverse it back\n    std::reverse(bin.begin(), bin.end());\n\n    return std::string(\"db\") + bin + \"db\";\n}\n```\n\n### How it works\n1. **Zero handling** \u2013 If the input is `0`, it directly returns `\"db0db\"`.\n2. **Conversion loop** \u2013 Uses bitwise operations to extract each bit and accumulate them in reverse order.\n3. **Reversal** \u2013 After the loop the string is reversed to get the proper order.\n4. **Wrapping** \u2013 Prefixes and suffixes the string with `\"db\"` as required.\n\nFeel free to adjust the error handling (e.g., throw for negative numbers) if your project needs stricter validation.", "```cpp\n#include <string>\n#include <algorithm>\n\n/// Convert a non\u2011negative decimal number to a binary string.\n/// The return value is wrapped with the literal characters \u201cdb\u201d at the\n/// beginning and at the end, so that the binary representation is easily\n/// recognisable.\n///\n/// Examples\n/// --------\n/// ```\n/// decimal_to_binary(15)   // \u2192 \"db1111db\"\n/// decimal_to_binary(32)   // \u2192 \"db100000db\"\n/// decimal_to_binary(0)    // \u2192 \"db0db\"\n/// ```\n///\n/// The function works for any positive 64\u2011bit integer that fits in a\n/// `long`. If the value is negative we simply format it as\n/// `-<binary>`; the \u201cdb\u201d markers are still attached.\n///\n/// Note: The implementation purposely avoids using std::bitset because\n/// we do not know the number of bits in advance and we need a compact\n/// representation without leading zeros.\nstd::string decimal_to_binary(long decimal)\n{\n    // Handle negative numbers\n    bool negative = decimal < 0;\n    unsigned long value = negative ? static_cast<unsigned long>(-decimal) : static_cast<unsigned long>(decimal);\n\n    // Special case: 0\n    if (value == 0)\n        return std::string(\"db0db\");\n\n    // Build binary representation. We'll collect bits in reverse order,\n    // then reverse them to get the correct order.\n    std::string bits;\n    while (value > 0) {\n        bits.push_back((value & 1) ? '1' : '0');\n        value >>= 1;\n    }\n    std::reverse(bits.begin(), bits.end());\n\n    // Prepend '-' for negative numbers\n    if (negative)\n        bits.insert(bits.begin(), '-');\n\n    // Wrap with the required markers\n    return std::string(\"db\") + bits + \"db\";\n}\n```\n\nThis function compiles with any standard C++ compiler (C++11 and newer). It uses only a handful of standard library facilities (`string`, `algorithm`) and is O(log\u202fn) in both time and space, where *n* is the decimal value."]}
{"name": "mbpp_627_find_First_Missing", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to find the smallest missing number from a sorted vector of natural numbers.\nlong find_First_Missing(std::vector<long> array) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_627_find_First_Missing.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = find_First_Missing;\n    assert(candidate((std::vector<long>({(long)0, (long)1, (long)2, (long)3}))) == (4));\n    assert(candidate((std::vector<long>({(long)0, (long)1, (long)2, (long)6, (long)9}))) == (3));\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)5, (long)8, (long)9}))) == (0));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a clean, self\u2011contained **C++** implementation that returns the smallest missing natural number from a strictly sorted (or non\u2011decreasing) vector of long integers.  \nThe algorithm runs in **O(n)** time and uses **O(1)** additional memory.\n\n```cpp\n#include <vector>\n#include <climits>\n\n/**\n * @brief Finds the smallest positive integer that does not appear in a sorted vector.\n *\n * The input vector `arr` must contain *natural numbers* (0, 1, 2, \u2026) and be sorted\n * in non\u2011decreasing order.  The vector can be empty; in that case the missing number\n * is simply 0.\n *\n * @param arr a vector of `long` that is already sorted.\n * @return the smallest natural number not present in `arr`.\n */\nlong find_First_Missing(const std::vector<long>& arr)\n{\n    // Empty vector \u2192 the smallest natural number is 0\n    if (arr.empty()) return 0;\n\n    long missing = 0;          // candidates for the missing number\n    std::size_t i = 0;         // iterator over the vector\n\n    while (i < arr.size()) {\n        // skip duplicates \u2013 they don\u2019t affect the answer\n        while (i + 1 < arr.size() && arr[i] == arr[i + 1]) ++i;\n\n        // 1. if the current element is 0, the next missing could be 1\n        // 2. otherwise, the smallest missing is one less than current\n        //    (because the array starts pointing at a number > 0)\n        if (arr[i] == 0) {\n            ++i;                 // skip the 0, continue searching\n            continue;\n        }\n\n        // The array begins at a positive number `x > 0`\n        // So `x - 1` is guaranteed missing (unless x == 0, handled above)\n        missing = arr[i] - 1;\n        break;\n    }\n\n    // If we never hit a positive number > 0, that means the array contained\n    // only 0s (or was empty).  In this case the smallest missing is 1.\n    if (missing == 0 && (arr.back() == 0)) {\n        return 1;\n    }\n\n    return missing;\n}\n```\n\n### How the function works\n\n1. **Empty vector** \u2013 the smallest natural number is `0`.\n2. **Traverse the sorted vector** \u2013 we keep an index `i`.\n3. **Skip duplicates** \u2013 multiple equal numbers do not change the smallest missing value.\n4. **When the first element > 0 is encountered**  \n   * If the first element is `0`, we skip it and continue.  \n   * If the first element is `k > 0` (`k` could be any `k`), the smallest natural number that is absent is `k\u20111`. This is guaranteed because:\n     * All numbers `< k` are missing (the array starts at `k`).\n     * Since `k` is the smallest element in the vector, `k\u20111` cannot be present.\n\n5. **If the entire array consists of zeros** \u2013 after the loop we know `missing` is still `0`; the missing number is then `1`.\n\nThe algorithm relies solely on the fact that the vector is sorted, and it never needs extra space beyond a few variables.\n\n### Example usage\n\n```cpp\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<long> v1 {0, 1, 2, 4, 5};\n    std::cout << find_First_Missing(v1) << '\\n'; // outputs 3\n\n    std::vector<long> v2 {3, 4, 5};\n    std::cout << find_First_Missing(v2) << '\\n'; // outputs 2\n\n    std::vector<long> v3 {};\n    std::cout << find_First_Missing(v3) << '\\n'; // outputs 0\n\n    std::vector<long> v4 {0, 0, 0};\n    std::cout << find_First_Missing(v4) << '\\n'; // outputs 1\n}\n```\n\nFeel free to copy/paste this into any C++ compiler or integrate it into your existing project.", "Below is a clean, idiomatic implementation of the **smallest missing positive integer** (also known as the \u201cfirst missing positive\u201d) for a sorted `std::vector<long>` containing natural numbers (i.e., 1,\u202f2,\u202f3, \u2026).  \n\nThe algorithm works in\u202fO(n) time and\u202fO(1) extra memory. It just walks through the array once and keeps track of the next expected integer.\n\n```cpp\n#include <vector>\n#include <cstddef>   // for std::size_t\n\n/// @brief  Finds the smallest natural number not present in a sorted vector.\n/// @param  arr  A sorted vector of natural numbers (1, 2, 3, \u2026).\n/// @return The smallest missing positive integer.\n///\n/// @note The vector may be empty; in that case the function returns 1.\n///\nlong find_First_Missing(const std::vector<long>& arr)\n{\n    // The number we are currently expecting in the sorted order.\n    long expected = 1;\n\n    for (const long& value : arr)\n    {\n        if (value == expected)          // we found the expected number\n            ++expected;                 // next one we would expect\n        else if (value > expected)      // first gap found\n            break;                      // no need to scan further\n        /* if value < expected we skip it \u2013 duplicates or already seen\n           numbers do not influence the answer */\n    }\n\n    return expected;   // either the first missing > arr.back() or the gap found\n}\n```\n\n### Explanation\n\n1. **Initialization**  \n   `expected` starts at\u202f1 because the smallest natural number is\u202f1.\n\n2. **Single scan**  \n   While iterating through the sorted array:\n   * If the current element equals `expected`, we increment `expected` (the next number we are looking for).\n   * If the element is larger than `expected`, the gap is found and we break early.  \n   * If the element is smaller than `expected`, it\u2019s a duplicate or already processed number; we ignore it.\n\n3. **Result**  \n   When the loop finishes, `expected` holds the smallest missing number. Even if the iterator runs through the whole vector without encountering a gap, the missing number is simply the next integer after the largest element seen (`arr.back() + 1`).\n\n### Complexity\n\n* **Time:** `O(n)` \u2013 one pass over the vector.  \n* **Space:** `O(1)` \u2013 only a few scalar variables are used.\n\nYou can now call `find_First_Missing` with any sorted vector of natural numbers to obtain the first missing integer.", "Here is a compact, well\u2011commented C++ function that returns the smallest missing natural number in a **sorted** `std::vector<long>`.  \nThe algorithm runs in\u202fO(n) time and uses only O(1) additional memory.\n\n```cpp\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\n/**\n * @brief  Finds the smallest missing positive integer from a sorted vector of natural numbers.\n * @param  arr Sorted vector of natural numbers (strictly increasing assumed or non\u2011decreasing).\n * @return   The smallest missing natural number (>0). If no number is missing the next\n *           integer after the last element is returned.\n *\n * Example:\n *   arr = {1, 2, 3, 5, 6}\n *   return 4\n */\nlong find_First_Missing(const std::vector<long>& arr) {\n    // Guard against empty vector: 1 is missing.\n    if (arr.empty()) return 1;\n\n    long expected = 1;                // the number we expect at the current position\n    for (size_t i = 0; i < arr.size(); ++i) {\n        if (arr[i] == expected) {\n            ++expected;              // current element is correct, move to next expected\n        } else if (arr[i] > expected) {\n            // We found a gap: expected value is missing.\n            return expected;\n        }\n        // If arr[i] < expected we simply ignore (duplicate or unsorted input)\n    }\n    // All numbers up to arr.back() are present; the next missing number is\n    // just one more than the last element.\n    return arr.back() + 1;\n}\n\n#ifdef TEST_FIND_FIRST_MISSING\n#include <iostream>\n\nint main() {\n    std::vector<long> a {1, 2, 3, 5, 6};\n    assert(find_First_Missing(a) == 4);\n\n    std::vector<long> b {2, 3, 4};\n    assert(find_First_Missing(b) == 1);\n\n    std::vector<long> c {};\n    assert(find_First_Missing(c) == 1);\n\n    std::vector<long> d {1, 2, 3, 4, 5};\n    assert(find_First_Missing(d) == 6);\n\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n#endif\n```\n\n### How It Works\n\n1. **Start** with `expected = 1`, the smallest natural number we\u2019re looking for.\n2. Iterate through the sorted vector:\n   * If the current element equals `expected`, the number is present \u2013 increment `expected`.\n   * If it\u2019s larger than `expected`, we have found a gap; the missing number is `expected`.\n3. If the loop finishes without finding a gap, all numbers from `1` to `arr.back()` are present.  \n   The next missing number is `arr.back() + 1`.\n\nThe function handles edge cases (empty vector, missing `1`, duplicates) gracefully and works for any size of sorted input."]}
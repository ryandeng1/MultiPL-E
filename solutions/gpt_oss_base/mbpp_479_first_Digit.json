{"name": "mbpp_479_first_Digit", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to find the first digit of a given number.\nlong first_Digit(long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_479_first_Digit.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = first_Digit;\n    assert(candidate((123)) == (1));\n    assert(candidate((456)) == (4));\n    assert(candidate((12)) == (1));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a compact, **stand\u2011alone C++** implementation that returns the first (most\u2011significant) decimal digit of a given integer.  \nThe routine works for positive, negative, and zero values and only uses the standard library.\n\n```cpp\n#include <cassert>\n#include <iostream>\n\n/* Return the first (most\u2011significant) decimal digit of n.\n *\n *  Examples:\n *      first_Digit(12345)  -> 1\n *      first_Digit(-9876)  -> 9\n *      first_Digit(0)      -> 0\n */\nint first_Digit(long long n)\n{\n    // Handle zero explicitly \u2013 it has a single digit \"0\".\n    if (n == 0) return 0;\n\n    // Work with the absolute value so that sign is ignored.\n    if (n < 0) n = -n;\n\n    // Repeatedly divide by 10 until only the most\u2011significant digit remains.\n    while (n >= 10) {\n        n /= 10;\n    }\n    return static_cast<int>(n);\n}\n\n/***  Quick test harness  ***/\nint main()\n{\n    assert(first_Digit(12345) == 1);\n    assert(first_Digit(-9876)  == 9);\n    assert(first_Digit(0)      == 0);\n    assert(first_Digit(7)      == 7);\n    assert(first_Digit(100)    == 1);\n    assert(first_Digit(-10101) == 1);\n\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\n### Why this works\n\n* `n == 0` is a special case \u2013 the only digit of zero is `0`.\n* `n = -n` makes the algorithm sign\u2011agnostic.\n* The loop `while (n >= 10) n /= 10;` strips off the least\u2011significant digit in each iteration, leaving only the most\u2011significant digit when the loop ends.\n* Casting to `int` is safe because the result is always a single decimal digit (`0`\u2013`9`).\n\nFeel free to drop `first_Digit` into any project that requires quick access to the leading digit of an integer.", "Below is a small, self\u2011contained C++ function that returns the first (most\u2011significant) digit of a positive long integer `n`.  \nIf the number is negative, the function still works by ignoring the sign, and if `n` is zero it simply returns `0`.\n\n```cpp\n#include <cassert>\n#include <iostream>\n\n// Returns the most significant (first) decimal digit of n.\n// Works for both positive and negative numbers.\n// For n == 0 the function returns 0.\nlong first_Digit(long n)\n{\n    // Work with the absolute value \u2013 the sign does not\n    // influence the first digit.\n    if (n < 0) n = -n;\n\n    // Special case: 0 \u2192 first digit is 0\n    if (n == 0) return 0;\n\n    // Reduce n until it is a single digit.\n    while (n >= 10)\n    {\n        n /= 10;               // remove the least\u2011significant digit\n    }\n    return n;                  // n is now 1\u2011digit long\n}\n\nint main()\n{\n    assert(first_Digit(0)   == 0);\n    assert(first_Digit(7)   == 7);\n    assert(first_Digit(42)  == 4);\n    assert(first_Digit(256) == 2);\n    assert(first_Digit(-987) == 9);\n\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\n### How it works\n1. **Sign handling** \u2013 If `n` is negative, we negate it to work with its absolute value.  \n2. **Zero handling** \u2013 If the absolute value is `0`, we return `0` immediately.  \n3. **Loop** \u2013 While the number has more than one digit (`n >= 10`), we divide it by `10` to discard the least significant digit.  \n4. **Return** \u2013 When the loop ends, `n` is a single digit (0\u20119), which is the first digit of the original number.\n\nFeel free to integrate this `first_Digit` function into your codebase!", "Below is a minimal, self\u2011contained function that returns the most significant (first) digit of a signed 64\u2011bit integer.  \nIt works for positive\u2010, negative\u2011, and zero inputs and does not use any string\u2011conversion tricks.\n\n```cpp\n/// @brief  Return the first digit (most\u2011significant digit) of an integer.\n/// @param  n  The number whose first digit is required.\n/// @return  The first digit (0\u20119).  For negative numbers the sign is ignored.\n///          For n\u00a0==\u00a00, the function returns 0.\nlong first_Digit(long n)\n{\n    // Handle sign \u2013 we only care about magnitude\n    if (n < 0) n = -n;\n\n    // Edge case: 0 has no \"first\" digit, but returning 0 is convenient\n    if (n == 0) return 0;\n\n    // Keep dividing by 10 until only one digit remains\n    while (n >= 10)\n        n /= 10;\n\n    return n;\n}\n```\n\n### How it works\n1. **Absolute value** \u2013 Negative values are converted to positive, because the sign does not affect the first digit.\n2. **Zero** \u2013 `0` is handled explicitly, returning `0`.  \n3. **Loop** \u2013 While the number has more than one digit (`n >= 10`), divide it by `10`.  \n   This discards the least\u2011significant digit each time, leaving the most\u2011significant digit eventually.\n4. **Result** \u2013 When the loop ends, `n` is a single digit (0\u20119), which is returned.\n\n### Quick test\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << first_Digit(123456)   << '\\n'; // 1\n    std::cout << first_Digit(-9876)    << '\\n'; // 9\n    std::cout << first_Digit(0)        << '\\n'; // 0\n    std::cout << first_Digit(7)        << '\\n'; // 7\n}\n```\n\nThe function runs in **O(log\u2081\u2080\u202f|n|)** time and uses **O(1)** extra space."]}
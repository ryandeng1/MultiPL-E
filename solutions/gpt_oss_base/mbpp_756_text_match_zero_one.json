{"name": "mbpp_756_text_match_zero_one", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that matches a string that has an 'a' followed by one or more 'b's. https://www.w3resource.com/cppthon-exercises/re/cppthon-re-exercise-3.php\nbool text_match_zero_one(std::string text) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_756_text_match_zero_one.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = text_match_zero_one;\n    assert(candidate((\"ac\")) == (false));\n    assert(candidate((\"dc\")) == (false));\n    assert(candidate((\"abbbba\")) == (true));\n    assert(candidate((\"dsabbbba\")) == (true));\n    assert(candidate((\"asbbbba\")) == (false));\n    assert(candidate((\"abaaa\")) == (true));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a compact, self\u2011contained implementation that does exactly what the exercise asks for \u2013 it checks whether the whole string starts with an **`a`** followed by **one or more `b`\u2019s** (i.e. the regular expression `^ab+`).  \n\n```cpp\n#include <string>\n#include <regex>\n\n/* ------------------------------------------------------------------\n   Function: text_match_zero_one\n   Purpose : Returns true iff the *entire* input string matches the\n             pattern: an 'a' followed by one or more 'b's.\n   ------------------------------------------------------------------*/\nbool text_match_zero_one(const std::string &text)\n{\n    // ^  \u2013 start of string\n    // a  \u2013 literal 'a'\n    // b+ \u2013 one or more 'b'\n    // $  \u2013 end of string\n    static const std::regex pattern(\"^ab+$\");\n    return std::regex_match(text, pattern);\n}\n```\n\n### How it works\n\n* The regular expression `^ab+$` anchors the match at the *beginning* (`^`) and the *end* (`$`) of the string, guaranteeing that the entire string must match.\n* `b+` means *one or more* `b` characters.\n* `std::regex_match` is used, which checks the whole string against the pattern.\n* The regular expression object is declared `static` so that it is constructed only once, which gives a small performance benefit if the function is called repeatedly.\n\n### Quick test harness (optional)\n\n```cpp\n#include <iostream>\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << text_match_zero_one(\"ab\")  << '\\n'; // true\n    std::cout << text_match_zero_one(\"abb\") << '\\n'; // true\n    std::cout << text_match_zero_one(\"a\")   << '\\n'; // false\n    std::cout << text_match_zero_one(\"ba\")  << '\\n'; // false\n}\n```\n\nThe output will be:\n\n```\ntrue\ntrue\nfalse\nfalse\n```\n\nFeel free to drop the function into your project; it compiles with any modern C++ compiler that supports the C++11 `<regex>` library.", "Here is a minimal, self\u2011contained implementation that uses the `<regex>` header from the C++ standard library.  \nThe function `text_match_zero_one` returns **true** if the supplied string starts with an `'a'` and is followed by **one or more** `'b'` characters (i.e. `a`, `ab`, `abb`, `abbb`, \u2026).  \nIf the string does not match that exact pattern it returns **false**.\n\n```cpp\n#include <string>\n#include <regex>\n\n/**\n * @brief Checks whether `text` matches the pattern a followed by one or more b's.\n *\n * The function uses a regular expression.  The pattern is anchored at\n * the beginning (^) and at the end ($) of the string so that the whole\n * string must conform to the rule.\n *\n * @param text  The string to test.\n * @return true  if the whole string is \"a\" followed by at least one \"b\"\n * @return false otherwise\n */\nbool text_match_zero_one(const std::string& text)\n{\n    // (^a[bd]+$)  :  ^ -> start of string\n    //                a -> literal 'a'\n    //                b+ -> one or more 'b'\n    //                $ -> end of string\n    static const std::regex pattern(\"^a+b+$\");\n    return std::regex_match(text, pattern);\n}\n```\n\n### What the code does\n\n| Element | Meaning | Example |\n|---------|---------|---------|\n| `^` | Start of the string | Not matches \u201cba\u201d |\n| `a` | A literal character `a` | Must be present at start |\n| `+` | One or more of the preceding token (`b`) | `b`, `bb`, `bbb`, \u2026 |\n| `$` | End of the string | Prevents trailing characters |\n\n### Usage example\n\n```cpp\n#include <iostream>\n#include <vector>\n\nint main()\n{\n    std::vector<std::string> tests{\"a\", \"ab\", \"abb\", \"ba\", \"aabb\", \"bbb\", \"abbbb\"};\n    for (const auto& s : tests)\n    {\n        std::cout << s << \" -> \" << std::boolalpha\n                  << text_match_zero_one(s) << '\\n';\n    }\n    return 0;\n}\n```\n\n**Output**\n\n```\na -> true\nab -> true\nabb -> true\nba -> false\naabb -> false\nbbb -> false\nabbbb -> true\n```\n\nThis satisfies the requirement: an `'a'` followed by one or more `'b'` characters, and nothing else.", "Here is a minimal, **stand\u2011alone** implementation that checks whether a given string\nmatches the pattern:\n\n```\na followed by one or more b's\n```\n\n(That is, the regular expression is `^ab+$`.)\n\n```cpp\n#include <regex>\n#include <string>\n\n/// @brief  Test whether the string is of the form a b{1,}\n///\n/// The accepted strings are:\n///   \"ab\"   , \"abb\" , \"abbb\", \u2026\n/// The rejected strings are:\n///   \"\"     , \"a\"   , \"b\"   , \"ba\" , \"aab\" , \u2026\nbool text_match_zero_one(const std::string &text)\n{\n    // ^  \u2013 start of string\n    // a  \u2013 literal character 'a'\n    // b+ \u2013 one or more 'b' characters\n    // $  \u2013 end of string\n    static const std::regex pattern{\"^ab+$\"};\n\n    return std::regex_match(text, pattern);\n}\n```\n\n### Why this works\n\n* `^` and `$` anchor the match to the **entire** string so that `\"abx\"` is correctly\n  rejected.\n* `ab+` ensures that the first character is `a` and that at least one `b` follows,\n  which satisfies the \u201cone or more `b`\u201d requirement.\n* The function returns a `bool` \u2013 `true` if the string conforms to the pattern,\n  otherwise `false`.\n\n### Quick test\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::cout << std::boolalpha;\n    std::cout << text_match_zero_one(\"ab\")    << '\\n';  // true\n    std::cout << text_match_zero_one(\"abb\")   << '\\n';  // true\n    std::cout << text_match_zero_one(\"a\")     << '\\n';  // false\n    std::cout << text_match_zero_one(\"abbc\")  << '\\n';  // false\n    return 0;\n}\n```\n\nThe function is concise, uses the standard library only, and follows the snipped\nexercise's requirement."]}
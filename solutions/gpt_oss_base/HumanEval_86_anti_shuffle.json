{"name": "HumanEval_86_anti_shuffle", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_86_anti_shuffle.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = anti_shuffle;\n    assert(candidate((\"Hi\")) == (\"Hi\"));\n    assert(candidate((\"hello\")) == (\"ehllo\"));\n    assert(candidate((\"number\")) == (\"bemnru\"));\n    assert(candidate((\"abcd\")) == (\"abcd\"));\n    assert(candidate((\"Hello World!!!\")) == (\"Hello !!!Wdlor\"));\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"Hi. My name is Mister Robot. How are you?\")) == (\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a **C++\u201117** implementation of the requested `anti_shuffle` routine.  \nIt follows the rules you defined:\n\n* words are separated by a single space (`' '`), but any number of spaces is\n  preserved exactly.\n* every word is sorted by its ASCII values (so punctuation, capitals, etc.\n  are treated like any other character).\n* the order of words and the order of spaces are unchanged.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// @brief   Return an \"anti\u2011shuffle\" of the input string\n/// @details   Each word (delimited by a single space) is sorted in ascending\n///            ASCII order, but the relative order of words and blank spaces\n///            is preserved.\n///\n/// @param s   Input string\n/// @return    The anti\u2011shuffled string\nstring anti_shuffle(const string& s)\n{\n    string out;\n    out.reserve(s.size());            // avoid reallocations\n\n    string current_word;\n    for (char ch : s) {\n        if (ch == ' ') {                // word separator \u2013 flush word\n            sort(current_word.begin(), current_word.end());\n            out += current_word;\n            current_word.clear();\n\n            out += ' ';                // keep the space\n        } else {                        // part of a word\n            current_word.push_back(ch);\n        }\n    }\n\n    // flush the last word (if any)\n    if (!current_word.empty()) {\n        sort(current_word.begin(), current_word.end());\n        out += current_word;\n    }\n\n    return out;\n}\n\n/* ----------  quick self\u2011test  ---------- */\n#ifdef UNIT_TEST\nint main() {\n    cout << anti_shuffle(\"Hi\") << \"\\n\";               // Hi\n    cout << anti_shuffle(\"hello\") << \"\\n\";            // ehllo\n    cout << anti_shuffle(\"Hello World!!!\") << \"\\n\";   // Hello !!!Wdlor\n    cout << anti_shuffle(\"a  bc\") << \"\\n\";            // a  bc\n    return 0;\n}\n#endif\n```\n\n### How it works\n\n1. **Character by character scan**  \n   The function walks through the input string once, collecting characters\n   into `current_word` until it encounters a space.\n\n2. **Sorting a word**  \n   When a space is found (or the string ends), the accumulated word is sorted\n   using `std::sort`, which orders the characters by their byte (ASCII)\n   value.\n\n3. **Preserving spaces**  \n   Spaces are appended to the output exactly as they appear in the\n   input, so the positions and counts of blanks are unchanged.\n\n4. **Efficiency**  \n   * One pass through the string (`O(n)`).\n   * The sorting cost is `O(k log k)` per word, where `k` is the word\n     length.  This is optimal for the required functionality.\n\nCompile/run the code (with `-DUNIT_TEST` to enable the test harness)\nand you will see the expected outputs:\n\n```\nHi\nehllo\nHello !!!Wdlor\n```\n\nFeel free to integrate `anti_shuffle` into your larger codebase.\n", "Here is a self\u2011contained implementation that satisfies the specification:\n\n```cpp\n#include <string>\n#include <algorithm>\n\nstd::string anti_shuffle(std::string s)\n{\n    std::string  res;      // to collect the final string\n    std::string  curWord;  // buffer for the current word\n\n    for (char c : s) {\n        // If we hit a space we need to flush the current word (if any)\n        if (c == ' ') {\n            if (!curWord.empty()) {                     // finished a word\n                std::sort(curWord.begin(), curWord.end());\n                res += curWord;\n                curWord.clear();\n            }\n            res += c;                                   // keep the space\n            continue;\n        }\n\n        // otherwise accumulate characters belonging to the current word\n        curWord.push_back(c);\n    }\n\n    // Flush the last word (if any) after the loop\n    if (!curWord.empty()) {\n        std::sort(curWord.begin(), curWord.end());\n        res += curWord;\n    }\n\n    return res;\n}\n```\n\n### How it works\n1. **Iterate over each character** in the input string.\n2. **When a space is encountered**:\n   * If there is a pending word (`curWord`), sort its characters in ascending ASCII order (`std::sort`).\n   * Append the sorted word to the result string.\n   * Append the space itself to preserve the exact spacing.\n   * Clear the `curWord` buffer for the next word.\n3. **For non\u2011space characters** we simply add them to the `curWord` buffer.\n4. After finishing the loop, any remaining word in `curWord` is also sorted and appended.\n\nThis preserves *exactly* the spacing of the original string, while sorting each word independently.  \nThe algorithm runs in `O(n log m)` where `n` is the length of the string and `m` the maximum word length.", "Here is a compact C++ implementation that respects the original spacing while sorting the\ncharacters of each word in ascending ASCII order:\n\n```cpp\n#include <string>\n#include <algorithm>\n\nstd::string anti_shuffle(const std::string& s)\n{\n    std::string result;\n    std::string cur;                 // current word being built\n\n    for (char c : s) {\n        if (c == ' ') {              // word boundary\n            std::sort(cur.begin(), cur.end());\n            result += cur;           // append sorted word\n            result += ' ';           // keep the blank space\n            cur.clear();             // reset for next word\n        } else {\n            cur += c;                // collect letters\n        }\n    }\n\n    // handle the last word (if the string does not end with a space)\n    std::sort(cur.begin(), cur.end());\n    result += cur;\n\n    return result;\n}\n```\n\n### How it works\n\n1. **Iterate over each character **`c` **in the input string.**\n2. When a space is found, we **sort the currently gathered word** (`cur`) with  \n   `std::sort` (ascending ASCII order), append it to the result, add the space,\n   and clear `cur` for the next word.\n3. If the character isn\u2019t a space, we **append it to `cur`**.\n4. After the loop, we sort and append the *last* word (the string may\n   end without a trailing space).\n\nThis keeps *exactly* the original spaces while ensuring every word is\nordered individually. The implementation runs in `O(n log n)` time, where\n`n` is the length of the input string."]}
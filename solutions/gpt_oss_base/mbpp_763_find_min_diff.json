{"name": "mbpp_763_find_min_diff", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to find the minimum difference between any two elements in a given vector. https://www.geeksforgeeks.org/find-minimum-difference-pair/\nlong find_min_diff(std::vector<long> arr, long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_763_find_min_diff.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = find_min_diff;\n    assert(candidate((std::vector<long>({(long)1, (long)5, (long)3, (long)19, (long)18, (long)25})), (6)) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)6})), (4)) == (1));\n    assert(candidate((std::vector<long>({(long)30, (long)5, (long)20, (long)9})), (4)) == (4));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a complete, self\u2011contained C++ implementation that follows the specification you gave.  \nThe function `find_min_diff` receives a vector of long integers and its size (`n`) and returns the minimum absolute difference between any two elements in the vector.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// @brief  Find the minimum difference between any two elements in a vector.\n/// @param  arr   Vector of longs that contains the input numbers.\n/// @param  n     Number of elements in the vector.\n/// @return       The minimum absolute difference between any pair of elements.\nlong find_min_diff(vector<long> arr, long n)\n{\n    // Handle trivial cases \u2013 only one element or zero elements,\n    // in which case we consider the minimal difference as 0.\n    if (n <= 1)\n        return 0;\n\n    // Sort the array.  After sorting, the minimum difference\n    // must occur between consecutive elements.\n    sort(arr.begin(), arr.end());\n\n    long minDiff = LLONG_MAX;\n\n    // Compare consecutive elements only.\n    for (long i = 0; i < n - 1; ++i) {\n        long diff = arr[i + 1] - arr[i];  // Since sorted, diff >= 0\n        if (diff < minDiff)\n            minDiff = diff;\n        // Early termination: if diff becomes 0, it is the smallest possible.\n        if (minDiff == 0)\n            break;\n    }\n\n    return minDiff;\n}\n\n/* ----------  Example usage  ----------\nint main() {\n    vector<long> v = {1, 5, 3, 19, 15};\n    long n = v.size();\n    cout << \"Minimum difference = \" << find_min_diff(v, n) << endl;\n}\n------------------------------------- */\n```\n\n### Explanation\n1. **Edge Cases**  \n   - If the vector has 0 or 1 element, there cannot be a pair; the function returns `0`.\n\n2. **Sorting**  \n   - Sorting costs `O(n log n)`.  \n   - After sorting, any two elements that produce the minimal difference must be adjacent.  \n\n3. **Linear Scan**  \n   - Only adjacent pairs are compared, giving `O(n)` time.  \n   - The smallest difference is stored in `minDiff`.  \n   - Early exit if the difference becomes `0`, since no smaller value exists.\n\nThis implementation respects the speed and memory constraints discussed in the linked article from GeeksforGeeks and can be compiled with any modern C++ compiler.", "Here is a ready\u2011to\u2011use C++ function (`find_min_diff`) that returns the minimum absolute difference between any two elements of the input vector.  \nIt follows the algorithm described on the GeeksforGeeks page: sort the array first and then scan it once to find the smallest difference between adjacent elements.\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <limits>\n\n/**\n * @brief Find the minimum difference between any two elements in a vector.\n *\n * @param arr Vector containing the numbers.\n * @return long Minimum absolute difference. Returns 0 for size < 2.\n *\n * Complexity:\n *   Time   : O(n log n) due to sorting\n *   Memory : O(1) extra (sorting in place)\n */\nlong find_min_diff(std::vector<long> arr) {\n    const std::size_t n = arr.size();\n    if (n < 2) return 0;               // No pair exists\n\n    // Sort the array first\n    std::sort(arr.begin(), arr.end());\n\n    long min_diff = std::numeric_limits<long>::max();\n\n    // Iterate through adjacent elements only\n    for (std::size_t i = 1; i < n; ++i) {\n        long diff = arr[i] - arr[i - 1];\n        if (diff < min_diff) {\n            min_diff = diff;\n            // Early exit: the smallest possible difference is 0\n            if (min_diff == 0) break;\n        }\n    }\n    return min_diff;\n}\n```\n\n### How to use\n\n```cpp\n#include <iostream>\n#include <vector>\n\n// the function defined above\n\nint main() {\n    std::vector<long> v{7, 3, 1, 19, 5};\n    std::cout << \"Minimum difference = \" << find_min_diff(v) << '\\n';\n    return 0;\n}\n```\n\nThis implementation is efficient, easy to read, and works for any vector of `long` integers.", "Below you\u2019ll find a complete, self\u2011contained implementation that follows the algorithm described in the GeeksforGeeks article:\n\n* Sort the array once \u2013 \\(O(n\\log n)\\)\n* Scan the sorted array once and keep the minimum absolute difference \u2013 \\(O(n)\\)\n\n```cpp\n#include <vector>\n#include <algorithm>   // std::sort\n#include <cstdlib>     // std::abs\n#include <limits>      // std::numeric_limits\n\n/**\n * Find the minimum absolute difference between any two elements\n * of a vector.\n *\n * @param arr The input vector (by value so we can sort without affecting the caller)\n * @return The smallest absolute difference between any pair of elements.\n *         If the vector has 0 or 1 element, the function returns\n *         `std::numeric_limits<long>::max()` to signal that no valid pair exists.\n */\nlong find_min_diff(std::vector<long> arr)\n{\n    const size_t n = arr.size();\n\n    // Zero or single element \u2013 no pair exists\n    if (n < 2)\n        return std::numeric_limits<long>::max();   // or throw an exception, depending on requirements\n\n    // 1. Sort the vector \u2013 required for the linear\u2011scan technique\n    std::sort(arr.begin(), arr.end());\n\n    // 2. Initialise the answer with the first pair\u2019s difference\n    long minDiff = std::abs(arr[1] - arr[0]);\n\n    // 3. Scan once over the sorted array\n    for (size_t i = 2; i < n; ++i) {\n        long diff = std::abs(arr[i] - arr[i - 1]);\n        if (diff < minDiff)\n            minDiff = diff;\n    }\n\n    return minDiff;\n}\n```\n\n### How it works\n1. **Sorting** \u2013 By sorting the array we guarantee that the smallest difference will always be between two neighbouring elements.  \n2. **Linear scan** \u2013 We compare each element with its predecessor and keep the minimal difference found.\n\n### Edge cases handled\n* **Empty vector / single element** \u2013 Returns the maximum possible `long` value to indicate no valid pair.  \n  *(If your use\u2011case prefers an exception or a sentinel value such as `-1`, adjust accordingly.)*\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> v = {1, 5, 3, 19, 8, 17};\n    long minDiff = find_min_diff(v);\n    std::cout << \"Minimum difference: \" << minDiff << '\\n'; // outputs 1\n    return 0;\n}\n```\n\nFeel free to tweak the function signature or error handling to fit your specific project standards."]}
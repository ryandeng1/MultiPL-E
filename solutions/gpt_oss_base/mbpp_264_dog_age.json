{"name": "mbpp_264_dog_age", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to calculate a dog's age in dog's years.\nlong dog_age(long h_age) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_264_dog_age.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = dog_age;\n    assert(candidate((12)) == (61));\n    assert(candidate((15)) == (73));\n    assert(candidate((24)) == (109));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a simple implementation that follows the most widely\u2011used \u201cdog\u2011years\u201d conversion:\n\n```cpp\n#include <cassert>\n#include <iostream>\n\n/* \n * Convert a human age (in years) to the equivalent dog age.\n *\n * Commonly accepted rule:\n * \u2022 1st human year  \u2192  10.5 dog years\n * \u2022 2nd human year  \u2192  10.5 dog years\n * \u2022 Every subsequent year \u2192 4 dog years\n *\n * The function returns a *long* because the result can grow quickly for\n * very old dogs.  We assume the input `h_age` is non\u2011negative.\n */\nlong dog_age(long h_age)\n{\n    assert(h_age >= 0);   // optional runtime guard\n\n    if (h_age == 0) return 0; // newborn (no age yet)\n\n    // First two years\n    long dog_years = (h_age >= 1 ? 10 : 0) + (h_age >= 2 ? 10 : 0);\n\n    // Remaining years\n    if (h_age > 2)\n        dog_years += (h_age - 2) * 4;\n\n    return dog_years;\n}\n\n/* Simple test harness */\nint main()\n{\n    assert(dog_age(0) == 0);\n    assert(dog_age(1) == 10);\n    assert(dog_age(2) == 20);\n    assert(dog_age(3) == 24);\n    assert(dog_age(5) == 32);   // 20 + 12\n\n    std::cout << \"All tests passed!\\n\";\n    std::cout << \"Dog age for 4 human years: \" << dog_age(4) << \" dog years.\\n\";\n}\n```\n\n### Why this algorithm?\n\n- **Accuracy**: The first two human years are disproportionately \u201clong\u201d for a dog\u2019s development; therefore they are both counted as 10.5 years (rounded here to 10 for integer math).  \n- **Simplicity**: No floating point is needed; all calculations stay in `long`.  \n- **Extensibility**: If you later decide to adopt a different conversion table, just change the constants.\n\nFeel free to adjust the constants if your dog\u2011year convention differs (e.g., 7\u202f:\u202f1 ratio, or 12\u202f:\u202f1 for the first 10\u202fyears).", "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n *  Conventional \u201cdog years\u201d rule\n *\n *  \u2022 The first two human years are worth 10.5 dog years each\n *  \u2022 Every human year beyond that is worth 4 dog years\n *\n *  The function returns the total dog years as a `long`.\n */\nlong dog_age(long h_age)\n{\n    if (h_age <= 0)\n        return 0;                    // no negative ages \u2013 just in case\n\n    long dogYr = 0;\n\n    if (h_age >= 2) {\n        dogYr += 2 * 10;             // 2 * 10.5 rounded down \u2192 20\n        dogYr += (h_age - 2) * 4;    // remaining years\n    } else {\n        dogYr += h_age * 10;         // 1 year \u2192 10, 0 \u2192 0\n    }\n\n    return dogYr;\n}\n```", "Here\u2019s a straightforward implementation that follows the commonly\u2011used \u201c10.5 years for the first two human years and 4 years for every subsequent year\u201d rule.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Convert a human age (in years) to the equivalent dog age (also in years).\nlong dog_age(long h_age) {\n    assert(h_age >= 0);              // age must be non\u2011negative\n\n    // The first two human years each count as 10.5 dog years.\n    if (h_age <= 2) {\n        return static_cast<long>(h_age * 10.5L);   // cast to long\n    }\n\n    // After the first two years, each human year = 4 dog years.\n    return static_cast<long>(21.0L + (h_age - 2) * 4.0L);\n}\n```\n\n**Explanation**\n\n1. **Base case** \u2013 For the first two human years, each year corresponds to `10.5` dog years.  \n2. **General case** \u2013 After the first two years, every additional human year counts as `4` dog years.  \n3. The function returns a `long`, as requested.  \n4. An `assert` is added to catch any negative input (you can also handle it differently if you prefer)."]}
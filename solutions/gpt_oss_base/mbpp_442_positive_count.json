{"name": "mbpp_442_positive_count", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the ration of positive numbers in a vector of integers.\nfloat positive_count(std::vector<long> nums) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_442_positive_count.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = positive_count;\n    assert(candidate((std::vector<long>({(long)0, (long)1, (long)2, (long)-1, (long)-5, (long)6, (long)0, (long)-3, (long)-2, (long)3, (long)4, (long)6, (long)8}))) == (0.54f));\n    assert(candidate((std::vector<long>({(long)2, (long)1, (long)2, (long)-1, (long)-5, (long)6, (long)4, (long)-3, (long)-2, (long)3, (long)4, (long)6, (long)8}))) == (0.69f));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-6, (long)-9, (long)11, (long)-12, (long)14, (long)-5, (long)17}))) == (0.56f));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a clean, self\u2011contained implementation that does exactly what you asked for \u2013  \n**returns the ratio of positive numbers in a vector of integers**.  \nIf the vector is empty it simply returns 0.0 to avoid a division\u2011by\u2011zero crash.\n\n```cpp\n#include <vector>\n#include <cstddef>       // for std::size_t\n\n// ---------------------------------------------------------------------------\n// Computes the ratio of positive numbers in `nums`.\n// ---------------------------------------------------------------------------\n//   nums:   vector of signed integers (here long, but could be any signed type)\n//   return: ratio as a float, i.e. (#positive) / (total size)\n// ---------------------------------------------------------------------------\nfloat positive_count(const std::vector<long>& nums)\n{\n    const std::size_t n = nums.size();\n    if (n == 0)                           // guard against empty vector\n        return 0.0f;\n\n    std::size_t posCount = 0;\n    for (auto v : nums)\n        if (v > 0) ++posCount;\n\n    return static_cast<float>(posCount) / static_cast<float>(n);\n}\n```\n\n### Usage Example\n\n```cpp\n#include <iostream>\nint main()\n{\n    std::vector<long> data{ -3, 0, 5, 12, -1, 7 };\n    std::cout << \"Ratio of positives: \"\n              << positive_count(data) << '\\n';\n    return 0;\n}\n```\n\n**Output**\n\n```\nRatio of positives: 0.5\n```\n\n(The vector contains 3 positive numbers out of 6 total, so 3/6 = 0.5.)\n\nThis implementation runs in O(n) time, uses O(1) extra space, and is safe for both small and large vectors.", "Here is a straightforward implementation that counts how many values in the vector are strictly positive and then returns the ratio of that count to the total number of elements.\n\n```cpp\n#include <vector>\n\nfloat positive_count(std::vector<long> nums)\n{\n    if (nums.empty())\n        return 0.0f;          // avoid division by zero (0/0 \u2192 0)\n\n    long pos = 0;\n    for (const auto &x : nums)\n        if (x > 0)\n            ++pos;\n\n    return static_cast<float>(pos) / static_cast<float>(nums.size());\n}\n```\n\n**Explanation**\n\n1. **Empty vector check** \u2013 If the vector is empty we return `0.0f` to avoid dividing by zero.  \n2. **Counting positives** \u2013 Iterate through each element; increment a counter `pos` whenever the element is greater than zero.  \n3. **Ratio computation** \u2013 Convert both the count and the vector\u2019s size to `float` (or `double` if higher precision is desired) before dividing, ensuring a floating\u2011point result.  \n\nFeel free to adjust the handling of the empty vector case or precision as required for your application.", "Here\u2019s a small, self\u2011contained implementation of the function you described, along with a little test harness so you can see it in action.\n\n```cpp\n#include <vector>\n#include <cassert>\n#include <iostream>\n\n/*\n * Returns the ratio of positive numbers in the supplied vector.\n * If the vector is empty, the function returns 0.0 (you could\n * alternatively throw an exception \u2013 see the comment below).\n */\nfloat positive_count(const std::vector<long> &nums)\n{\n    // Guard against empty input \u2013 adjust behaviour if you prefer.\n    if (nums.empty())\n    {\n        // throw std::invalid_argument(\"Vector cannot be empty\");\n        return 0.0f;      // safe fallback\n    }\n\n    size_t positives = 0;\n    for (const auto &n : nums)\n        if (n > 0)\n            ++positives;\n\n    return static_cast<float>(positives) / static_cast<float>(nums.size());\n}\n\n/* main() below is for quick illustration and can be removed in\n   a larger codebase. */\n#ifdef DEMO_MAIN\nint main()\n{\n    std::vector<long> v{ -3, 0, 4, 7, -1, 2 };\n\n    float ratio = positive_count(v);\n    std::cout << \"Ratio of positives: \" << ratio << '\\n';   // 3/6 = 0.5\n\n    // Quick sanity checks\n    assert(positive_count({1, 2, 3}) == 1.0f);\n    assert(positive_count({-1, -2, 0}) == 0.0f);\n    assert(positive_count({}) == 0.0f);\n\n    return 0;\n}\n#endif\n```\n\n### What does this do?\n\n1. **Early return for an empty vector** \u2013 you can change the behaviour to throw an exception if you prefer strict error handling.\n2. **Counts positives** \u2013 iterates once over the vector, incrementing a counter when `n > 0`.\n3. **Computes ratio** \u2013 casts to `float` to avoid integer division.\n\nFeel free to drop the `DEMO_MAIN` block into a test file or to add unit tests with your preferred framework."]}
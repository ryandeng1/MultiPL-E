{"name": "mbpp_767_get_pairs_count", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to count the number of pairs whose sum is equal to \u2018sum\u2019. The funtion gets as input a vector of numbers and the sum,\nlong get_pairs_count(std::vector<long> arr, long sum) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_767_get_pairs_count.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = get_pairs_count;\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1})), (2)) == (6));\n    assert(candidate((std::vector<long>({(long)1, (long)5, (long)7, (long)-1, (long)5})), (6)) == (3));\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)3})), (1)) == (1));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)3})), (-3)) == (1));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a clean, self\u2011contained C++ implementation that meets the requirements:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/**\n * @brief Count the number of unordered pairs (i, j) 0 <= i < j < n\n *        such that arr[i] + arr[j] == sum.\n *\n * @param arr  Vector of integers (long).\n * @param sum  Target sum for the pairs.\n * @return long Number of pairs that sum to `sum`.\n *\n * The function uses a hash map (unordered_map) to keep track of how many\n * times each element has been seen while scanning the array once.  \n * For every element `x` we look for its complement `sum - x`.\n * At that point all pairs that can end with the current `x` are already\n * counted in the hash map.  \n *\n * Time Complexity        :  O(n)  (average case)\n * Extra Space Complexity :  O(n)  (for the hash map)\n */\nlong get_pairs_count(const vector<long> &arr, long sum)\n{\n    unordered_map<long, long> freq;   // element -> how many times we've seen it\n    long pairs = 0;\n\n    for (long x : arr)\n    {\n        long complement = sum - x;\n        auto it = freq.find(complement);\n        if (it != freq.end())\n            pairs += it->second;     // all previous occurrences of the complement\n        ++freq[x];                  // current element will be a complement for future items\n    }\n    return pairs;\n}\n```\n\n### Why this works\n\n1. **Single pass** \u2013 The array is iterated only once.\n2. **Unordered pairs** \u2013 Because we add the complement count *before* inserting the current\n   element, we never count a pair twice.  \n   Example: for array `[1,3,2,1]` and `sum=4`  \n   * 1st 1 \u2192 complement 3 not seen \u2192 pairs 0, map `{1:1}`  \n   * 3      \u2192 complement 1 seen once \u2192 pairs 1, map `{1:1,3:1}`  \n   * 2      \u2192 complement 2 not seen \u2192 pairs 1, map `{1:1,3:1,2:1}`  \n   * 2nd 1  \u2192 complement 3 seen once \u2192 pairs 2, map `{1:2,3:1,2:1}`  \n   Final answer = 2 pair(s): `(1,3)` and `(2,2)`.\n\n### Edge Cases\n\n- **Empty vector** \u2192 returns 0.  \n- **Large numbers** \u2192 `long` is used (typically 64\u202fbit on modern compilers).  \n- **Negative numbers** \u2192 handled naturally by the complement logic.\n\nFeel free to plug this function into your project and substitute the `#include <bits/stdc++.h>` with individual headers (`<vector>`, `<unordered_map>`, etc.) if you prefer a more portable code base.", "Below is a small, self\u2011contained function that counts how many unordered pairs in `arr` add up to the value `sum`.  \nThe function uses a hash table (`unordered_map`) to keep track of how many times each element has already been seen while iterating the vector once.  \nThe time complexity is **O(n)** and the extra memory is **O(n)** in the worst case.\n\n```cpp\n#include <vector>\n#include <unordered_map>\n\n/// \\brief Counts unordered pairs (i , j)   with i < j   such that\n///        arr[i] + arr[j] == sum.\n///\n/// \\param arr   input vector of numbers\n/// \\param sum   target sum of a pair\n/// \\return      number of qualifying pairs\nlong long get_pairs_count(const std::vector<long long>& arr, long long sum) {\n    long long count = 0;\n    std::unordered_map<long long, long long> freq;   // number -> occurrences seen so far\n\n    for (const auto& x : arr) {\n        long long complement = sum - x;\n\n        // If the complement has already appeared, each occurrence forms a new pair with x\n        auto it = freq.find(complement);\n        if (it != freq.end())\n            count += it->second;\n\n        // Record that x has now been seen\n        ++freq[x];\n    }\n    return count;\n}\n```\n\n### How it works\n1. **Initialisation** \u2013 `freq` keeps the count of each value that has already been processed.\n2. **Iteration** \u2013 For every element `x` in `arr`\n   * Compute `complement = sum - x`.\n   * If `complement` is already in `freq`, every occurrence of it can form a pair with the current `x`; add `freq[complement]` to `count`.\n   * Increment `freq[x]` to record that this `x` has now been seen.\n\nBecause we only add to `count` when the second element of the pair is known, every unordered pair is counted **exactly once**.\n\n### Example\n\n```cpp\nstd::vector<long long> v{1, 5, 7, 5, 2, 3};\nlong long target = 10;\nlong long pairs = get_pairs_count(v, target);   // pairs == 2\n```\n\nThe pairs are `(5,5)` and `(7,3)`.\n\nFeel free to copy\u2011paste the function into your code base and call it with the appropriate arguments. Happy coding!", "Below is a clean, self\u2011contained C++ implementation of the function you described.  \nIt takes a vector of integers (or any integral type) and a target sum and returns the\nnumber of unordered pairs `(arr[i], arr[j])` with `i < j` such that  \n`arr[i] + arr[j] == sum`.  \nThe algorithm runs in **O(n\u202flog\u202fn)** time and uses **O(n)** additional space.\n\n```cpp\n#include <vector>\n#include <unordered_map>\n#include <cstddef>   // for size_t\n#include <cassert>\n\n/// @brief   Count the number of unordered pairs with a given sum.\n/// @param   arr  Vector of numbers (long is enough for most cases).\n/// @param   sum  The desired pair sum.\n///\n/// @returns     Number of pairs (i < j) such that arr[i] + arr[j] == sum.\nlong long get_pairs_count(const std::vector<long long>& arr, long long sum)\n{\n    // Simple corner\u2011case: fewer than 2 elements cannot form a pair.\n    if (arr.size() < 2)\n        return 0;\n\n    // We will store how many times each value has appeared so far.\n    std::unordered_map<long long, long long> freq;\n    long long pair_cnt = 0;\n\n    for (const auto& val : arr)\n    {\n        long long complement = sum - val;\n        // All previously seen numbers that equal the complement form a\n        // pair with the current value.\n        if (freq.find(complement) != freq.end())\n            pair_cnt += freq[complement];\n\n        // Record that we have now seen one more instance of `val`.\n        ++freq[val];\n    }\n    return pair_cnt;\n}\n```\n\n### Why this implementation works\n\n1. **Linear traversal** \u2013 We iterate over the array once.  \n2. **Hash map lookup (O(1))** \u2013 For each element we check how many earlier\n   elements could pair with it to reach the target sum.  \n3. **Unordered pairs** \u2013 Because we only look back at elements that have\n   already been processed, each pair is counted exactly once.  \n\n### Example usage\n\n```cpp\nint main()\n{\n    std::vector<long long> v{1, 5, 7, -1, 5};\n    long long sum = 6;\n    assert(get_pairs_count(v, sum) == 3);  // pairs: (1,5), (7,-1), (1,5) second 5\n}\n```\n\nFeel free to drop this function into any project that uses the standard\nlibrary. If you prefer a `vector<int>` signature, simply replace\n`long long` with `int` (or `long` if your data range requires it)."]}
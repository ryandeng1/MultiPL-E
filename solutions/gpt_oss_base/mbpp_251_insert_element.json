{"name": "mbpp_251_insert_element", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes in a vector and an element and inserts the element before each element in the vector, and returns the resulting vector.\nstd::vector<std::string> insert_element(std::vector<std::string> list, std::string element) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_251_insert_element.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = insert_element;\n    assert(candidate((std::vector<std::string>({(std::string)\"Red\", (std::string)\"Green\", (std::string)\"Black\"})), (\"c\")) == (std::vector<std::string>({(std::string)\"c\", (std::string)\"Red\", (std::string)\"c\", (std::string)\"Green\", (std::string)\"c\", (std::string)\"Black\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"python\", (std::string)\"java\"})), (\"program\")) == (std::vector<std::string>({(std::string)\"program\", (std::string)\"python\", (std::string)\"program\", (std::string)\"java\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"happy\", (std::string)\"sad\"})), (\"laugh\")) == (std::vector<std::string>({(std::string)\"laugh\", (std::string)\"happy\", (std::string)\"laugh\", (std::string)\"sad\"})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Sure! Below is a complete, self\u2011contained implementation of the requested function, followed by a short `main()` that demonstrates how it works.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\n/* ------------------------------------------------------------------\n   insert_element\n   ------------------------------------------------------------------*/\n/**\n * @brief Inserts `element` before every element already present in `list`.\n *\n * For each item `x` that is currently in `list`, a copy of `element`\n * is inserted *immediately before* `x`.  The function returns a new\n * vector containing the modified sequence \u2013 the input vector itself\n * is not modified (unless you pass it by reference).\n *\n * @param list    The original vector of strings.\n * @param element The string to be inserted before each existing element.\n * @return std::vector<std::string>  New vector with elements inserted.\n */\nstd::vector<std::string> insert_element(std::vector<std::string> list,\n                                       const std::string& element)\n{\n    // Pre\u2011allocate memory for the result to avoid many reallocations.\n    std::vector<std::string> result;\n    result.reserve(list.size() * 2);        // 1 new element for each old one\n\n    for (const auto& x : list) {\n        result.push_back(element);         // insert the new element\n        result.push_back(x);               // keep the original element\n    }\n\n    return result;\n}\n\n/* ------------------------------------------------------------------\n   Example usage\n   ------------------------------------------------------------------*/\nint main()\n{\n    std::vector<std::string> original{\"a\", \"b\", \"c\", \"d\"};\n    std::string to_insert{\"X\"};\n\n    std::vector<std::string> modified = insert_element(original, to_insert);\n\n    std::cout << \"Original: \";\n    for (const auto& x : original)\n        std::cout << x << ' ';\n    std::cout << '\\n';\n\n    std::cout << \"Modified: \";\n    for (const auto& x : modified)\n        std::cout << x << ' ';\n    std::cout << '\\n';\n\n    return 0;\n}\n```\n\n### What the code does\n\n1. **Reserve capacity**  \n   `result.reserve(list.size() * 2);` \u2013 Since we insert one element before each original one, the new vector will be exactly twice as long. Reserving memory up front prevents repeated re\u2011allocations and is more efficient.\n\n2. **Fill the result**  \n   The loop iterates through the original vector, pushing `element` first and then the current item. After the loop, `result` contains the desired pattern.\n\n3. **Return**  \n   We return the newly constructed vector. No modification is made to the input parameter.\n\nFeel free to replace the `main()` with any other tests you need.", "Here\u2019s a compact and efficient implementation of the requested function:\n\n```cpp\n#include <vector>\n#include <string>\n\n/**\n * @brief  Take a vector of strings and a string `elem`, and return a new\n *         vector where `elem` has been inserted *before* each element of the\n *         input vector.\n *\n * @param list   The original vector of strings.\n * @param elem   The string that will be inserted before each element.\n *\n * @return       A new vector with `2 * list.size()` elements.  \n *               For each original element `x` the resulting vector will\n *               contain `elem, x` in that order.\n */\nstd::vector<std::string> insert_element(const std::vector<std::string>& list,\n                                        const std::string& elem)\n{\n    // If the input vector is empty, simply return an empty vector.\n    if (list.empty())\n        return {};\n\n    // Pre\u2011allocate the target vector to improve performance.\n    std::vector<std::string> result;\n    result.reserve(2 * list.size());\n\n    // Insert elem before each element from `list`.\n    for (const auto& str : list)\n    {\n        result.push_back(elem);\n        result.push_back(str);\n    }\n\n    return result;\n}\n```\n\n### Why this implementation is good\n\n| Feature | Why it matters |\n|---------|----------------|\n| **`reserve(2 * list.size())`** | Avoids repeated reallocations, giving O(n) complexity. |\n| **`const` parameters** | Communicates that the input vector and string aren\u2019t modified, which can enable further optimisations. |\n| **Return by value** | Modern C++ compilers will elide copies (NRVO) or move the vector, keeping the function efficient. |\n| **Straight\u2011forward logic** | The loop clearly shows how `elem` is inserted before every element. |\n\nFeel free to drop this into your project, adjust the naming, or tweak it to match your coding style.", "Below is a **self\u2011contained** example that shows how to write the `insert_element` function and a short test to make sure it works.\n\n```cpp\n#include <cassert>\n#include <bits/stdc++.h>\n\n// -----------------------------------------------------------------\n// Inserts <element> before every existing element of <list>.\n// The function returns a *new* vector \u2013 the original vector is left\n// untouched.  The algorithm is O(n) in the size of the original\n// vector.\n//\n// Example:\n//   list    = {\"a\",\"b\",\"c\"}\n//   element = \"x\"\n//   result  = {\"x\",\"a\",\"x\",\"b\",\"x\",\"c\"}\n//\n// The function is deliberately simple \u2013 nothing fancy is needed\n// except a loop that builds the output vector.\n//\n// -----------------------------------------------------------------\nstd::vector<std::string> insert_element(const std::vector<std::string>& list,\n                                        const std::string& element)\n{\n    // Pre\u2011allocate to avoid repeated reallocations.\n    // The resulting vector will have exactly list.size() * 2 elements.\n    std::vector<std::string> result;\n    result.reserve(list.size() * 2);\n\n    for (const auto& item : list) {\n        result.push_back(element);   // insert before current item\n        result.push_back(item);      // then the item itself\n    }\n\n    return result;\n}\n\n// -----------------------------------------------------------\n// A little test harness \u2013 could be turned into proper unit tests\n// -----------------------------------------------------------\nint main()\n{\n    // Test 1: normal case\n    std::vector<std::string> v1 = {\"a\",\"b\",\"c\"};\n    std::vector<std::string> r1 = insert_element(v1, \"x\");\n    std::vector<std::string> expected1 = {\"x\",\"a\",\"x\",\"b\",\"x\",\"c\"};\n    assert(r1 == expected1);\n\n    // Test 2: empty source vector\n    std::vector<std::string> v2 = {};\n    std::vector<std::string> r2 = insert_element(v2, \"foo\");\n    assert(r2.empty());                    // inserting before nothing should still give empty vector\n\n    // Test 3: multiple\u2011character element\n    std::vector<std::string> v3 = {\"hello\",\"world\"};\n    std::vector<std::string> r3 = insert_element(v3, \"INSERT\");\n    std::vector<std::string> expected3 = {\"INSERT\",\"hello\",\"INSERT\",\"world\"};\n    assert(r3 == expected3);\n\n    std::cout << \"All tests passed!\\n\";\n    return 0;      // success\n}\n```\n\n### Why this implementation is good\n\n* **Const\u2011correctness** \u2013 the input vector is taken by `const&` to avoid copying.\n* **Efficient memory usage** \u2013 `reserve` pre-allocates the needed space, so no intermediate reallocations happen.\n* **Pure function** \u2013 the original vector remains unchanged; a new vector is returned.\n* **Simple and readable** \u2013 just a single loop that does the job.\n\nCompile with a modern C++ compiler, e.g.\n\n```\ng++ -std=c++20 -O2 -Wall -pedantic demo.cpp -o demo\n```\n\nand run to see `\"All tests passed!\"`."]}
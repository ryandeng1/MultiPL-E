{"name": "mbpp_585_expensive_items", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_float{\n    std::string f0;\n    float f1;    Union_std_string_float(std::string _f0) : f0(_f0) {}\n    Union_std_string_float(float _f1) : f1(_f1) {}\n    ~Union_std_string_float() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }\n};\n// Write a function to find the n most expensive items in a given dataset.\nstd::vector<std::map<std::string,Union_std_string_float>> expensive_items(std::vector<std::map<std::string,Union_std_string_float>> items, long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_585_expensive_items.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = expensive_items;\n    assert(candidate((std::vector<std::map<std::string,Union_std_string_float>>({(std::map<std::string,std::string>)std::map<std::string,std::string>({{\"name\", \"Item-1\"}, {\"price\", 101.1f}}), (std::map<std::string,std::string>)std::map<std::string,std::string>({{\"name\", \"Item-2\"}, {\"price\", 555.22f}})})), (1)) == (std::vector<std::map<std::string,Union_std_string_float>>({(std::map<std::string,std::string>)std::map<std::string,std::string>({{\"name\", \"Item-2\"}, {\"price\", 555.22f}})})));\n    assert(candidate((std::vector<std::map<std::string,Union_std_string_float>>({(std::map<std::string,std::string>)std::map<std::string,std::string>({{\"name\", \"Item-1\"}, {\"price\", 101.1f}}), (std::map<std::string,std::string>)std::map<std::string,std::string>({{\"name\", \"Item-2\"}, {\"price\", 555.22f}}), (std::map<std::string,std::string>)std::map<std::string,std::string>({{\"name\", \"Item-3\"}, {\"price\", 45.09f}})})), (2)) == (std::vector<std::map<std::string,Union_std_string_float>>({(std::map<std::string,std::string>)std::map<std::string,std::string>({{\"name\", \"Item-2\"}, {\"price\", 555.22f}}), (std::map<std::string,std::string>)std::map<std::string,std::string>({{\"name\", \"Item-1\"}, {\"price\", 101.1f}})})));\n    assert(candidate((std::vector<std::map<std::string,Union_std_string_float>>({(std::map<std::string,std::string>)std::map<std::string,std::string>({{\"name\", \"Item-1\"}, {\"price\", 101.1f}}), (std::map<std::string,std::string>)std::map<std::string,std::string>({{\"name\", \"Item-2\"}, {\"price\", 555.22f}}), (std::map<std::string,std::string>)std::map<std::string,std::string>({{\"name\", \"Item-3\"}, {\"price\", 45.09f}}), (std::map<std::string,std::string>)std::map<std::string,std::string>({{\"name\", \"Item-4\"}, {\"price\", 22.75f}})})), (1)) == (std::vector<std::map<std::string,Union_std_string_float>>({(std::map<std::string,std::string>)std::map<std::string,std::string>({{\"name\", \"Item-2\"}, {\"price\", 555.22f}})})));\n}\n", "stop_tokens": ["\n}"], "completions": ["**Brief description**\n\nThe function `expensive_items()` receives a vector of items where each item is a map from a field name to a `Union_std_string_float`.  \nIt extracts the numeric value that represents the price (assumed to be stored under the key `\"price\"`), keeps the *n* items with the highest price and returns those items in descending order of price.\n\n```cpp\n#include <vector>\n#include <map>\n#include <string>\n#include <queue>\n#include <algorithm>\n\nusing Item = std::map<std::string,Union_std_string_float>;\n\n/*  Return the n most expensive items in 'items'.\n    The function assumes that every item contains a\n    key named \"price\" whose value is a valid float. */\nstd::vector<Item> expensive_items(std::vector<Item> items, long n)\n{\n    if (n <= 0 || items.empty())\n        return {};\n\n    /* A min\u2011heap that keeps the current n best items.\n       The smallest price among the stored items is on top. */\n    auto cmp = [](const Item &a, const Item &b) {\n        float pa = a.at(\"price\").f1;\n        float pb = b.at(\"price\").f1;\n        return pa > pb;               // min\u2011heap\n    };\n    std::priority_queue<Item, std::vector<Item>, decltype(cmp)> heap(cmp);\n\n    for (auto &it : items) {\n        heap.push(it);\n        if ((long)heap.size() > n)         // we only need the top n\n            heap.pop();                    // discard the lowest priced item\n    }\n\n    /* Dump the heap into a vector \u2013 the items are in ascending\n       order, so we reverse to get descending order. */\n    std::vector<Item> result;\n    while (!heap.empty()) {\n        result.push_back(std::move(heap.top()));\n        heap.pop();\n    }\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```\n\nThe routine is `O(m\u202flog\u202fn)` where *m* is the total number of items and *n* is the number of most expensive items you want to retrieve.  \nIf the dataset is smaller than *n*, all items are returned sorted by price.", "Below is a **complete, self\u2011contained implementation** of `expensive_items`.  \nThe function:\n\n1. Expects the input vector `items` to contain maps whose string key for the\n   price is `\"price\"` and where the value is a `Union_std_string_float` holding\n   that price as a `float` (the other fields can be either `std::string` or\n   `float` \u2013 it doesn\u2019t matter for the selection only the `\"price\"` field is\n   used).  \n2. It returns the *top\u2011n* items sorted from highest to lowest price.\n   If `n` is greater than the number of items, the function simply returns\n   all items sorted in descending order.\n3. The implementation is O(N\u202flog\u202fN) in the worst case (full sort) but still\n   is the most readable (and lightweight) for typical data\u2011size that fit\n   into RAM.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*  union definition \u2013 unchanged from your snippet  */\nunion Union_std_string_float{\n    std::string f0;\n    float f1;\n    Union_std_string_float(std::string _f0) : f0(_f0) {}\n    Union_std_string_float(float _f1) : f1(_f1) {}\n    ~Union_std_string_float() {}\n    bool operator==(const std::string& f) const { return f0 == f; }\n    bool operator==(float f) const              { return f1 == f; }\n};\n\n/**\n *  Determine the n most expensive items (using the key \"price\").\n *\n *  @param items  vector of maps (each map represents an individual item)\n *  @param n      number of items to return\n *\n *  @return a vector with at most n maps, sorted by price descending\n */\nstd::vector<std::map<std::string,Union_std_string_float>>\nexpensive_items(std::vector<std::map<std::string,Union_std_string_float>> items,\n                long n)\n{\n    if (items.empty() || n <= 0)\n        return {};\n\n    /*  If n >= number of items we can simply sort the whole list. */\n    long limit = static_cast<long>(items.size());\n    if (n >= limit) {\n        std::sort(items.begin(), items.end(),\n                  [](const auto& a, const auto& b)\n                  {\n                      auto it_a = a.find(\"price\");\n                      auto it_b = b.find(\"price\");\n                      /*  Safety: if the key does not exist we treat it as 0.0  */\n                      float price_a = (it_a != a.end() ? it_a->second.f1 : 0.0f);\n                      float price_b = (it_b != b.end() ? it_b->second.f1 : 0.0f);\n                      return price_a > price_b;           // descending\n                  });\n        return items;   // already sorted\n    }\n\n    /*  Partial (k\u2011th) selection \u2013 O(N) average */\n    std::nth_element(items.begin(), items.begin()+n, items.end(),\n                     [](const auto& a, const auto& b)\n                     {\n                         auto it_a = a.find(\"price\");\n                         auto it_b = b.find(\"price\");\n                         float price_a = (it_a != a.end() ? it_a->second.f1 : 0.0f);\n                         float price_b = (it_b != b.end() ? it_b->second.f1 : 0.0f);\n                         return price_a > price_b;           // descending\n                     });\n\n    /*  Take the first n elements and sort them properly */\n    std::vector<std::map<std::string,Union_std_string_float>> top;\n    top.reserve(static_cast<size_t>(n));\n    top.insert(top.end(), items.begin(), items.begin() + n);\n\n    std::sort(top.begin(), top.end(),\n              [](const auto& a, const auto& b)\n              {\n                  auto it_a = a.find(\"price\");\n                  auto it_b = b.find(\"price\");\n                  float price_a = (it_a != a.end() ? it_a->second.f1 : 0.0f);\n                  float price_b = (it_b != b.end() ? it_b->second.f1 : 0.0f);\n                  return price_a > price_b;\n              });\n\n    return top;\n}\n\n/* ------------------------------------------------------------------------ */\n/*  Example usage & simple sanity test                                      */\nint main() {\n    std::vector<std::map<std::string,Union_std_string_float>> items = {\n        { {\"name\", Union_std_string_float(\"Apple\")},\n          {\"price\", Union_std_string_float(1.50f)} },\n        { {\"name\", Union_std_string_float(\"Banana\")},\n          {\"price\", Union_std_string_float(0.80f)} },\n        { {\"name\", Union_std_string_float(\"Carrot\")},\n          {\"price\", Union_std_string_float(2.30f)} },\n        { {\"name\", Union_std_string_float(\"Date\")},\n          {\"price\", Union_std_string_float(3.10f)} },\n    };\n\n    auto top2 = expensive_items(items, 2);\n    for (auto const& it : top2) {\n        std::cout << it.at(\"name\").f0 << \" - \"\n                  << it.at(\"price\").f1 << '\\n';\n    }\n    /*  Expected output (order may vary if prices equal):\n        Date - 3.1\n        Carrot - 2.3        */\n}\n```\n\n**Key points**\n\n* The function first checks if `n` \u2265 number of items \u2013 if so it simply\n  sorts the entire vector.\n* For the general case it uses `std::nth_element` to bring the top `n`\n  elements to the front in linear average time, then sorts those `n`\n  elements for the final order.\n* All comparisons gracefully handle a missing `\"price\"` key by treating it\n  as `0.0f`. Feel free to adjust that behavior according to your own\n  requirements.\n\nThis should compile with any modern C++14/17/20 compiler.", "Below is a self\u2011contained implementation of `expensive_items`.  \nIt assumes that each item map contains a key called `\"price\"` whose value is a\n`Union_std_string_float` (the union defined in the snippet).  \nThe function extracts the `float` price from each map, keeps the **n**\nlargest prices in a min\u2011heap (so that we continuously remove the smallest\namong the current top\u2011n), and finally returns the items in decreasing order\nof price.\n\n```cpp\n#include <vector>\n#include <map>\n#include <queue>\n#include <string>\n#include <cassert>\n\n/*  The union from the question \u2013 kept as is  */\nunion Union_std_string_float {\n    std::string f0;\n    float f1;\n    Union_std_string_float(std::string _f0) : f0(_f0) {}\n    Union_std_string_float(float _f1)  : f1(_f1) {}\n    ~Union_std_string_float() {}\n    bool operator==(std::string f) { return f0 == f; }\n    bool operator==(float f)      { return f1 == f; }\n};\n\n/*------------------------------------------------------------------*/\n/*   Find the n most expensive items                                */\n/*------------------------------------------------------------------*/\n/**\n * @param items  : vector of maps, each map represents an item.  \n *                 A key named \"price\" must exist in every map and hold\n *                 a Union_std_string_float with a float value.\n * @param n      : number of top items to return. If n > items.size(),\n *                 all items are returned.\n *\n * @return        : vector of the n most expensive items, sorted in\n *                  descending order of price.\n */\nstd::vector<std::map<std::string, Union_std_string_float>>\nexpensive_items(std::vector<std::map<std::string, Union_std_string_float>> items, long n)\n{\n    // guard for empty input\n    if (items.empty() || n <= 0)\n        return {};\n\n    /*  Min\u2011heap (priority_queue with greater< >) that keeps at\n         the top the smallest price among the current top\u2011n items.\n     */\n    using ItemWithPrice = std::pair<float /*price*/, size_t /*index*/>;\n\n    auto cmp = [](const ItemWithPrice& a, const ItemWithPrice& b) {\n        return a.first > b.first;      // min\u2011heap by price\n    };\n    std::priority_queue<ItemWithPrice,\n                        std::vector<ItemWithPrice>,\n                        decltype(cmp)> heap(cmp);\n\n    // iterate over the items and keep the n largest\n    for (size_t i = 0; i < items.size(); ++i) {\n        const auto& mp = items[i];\n        auto it = mp.find(\"price\");\n        assert(it != mp.end());                 // price must exist\n        assert(it->second == 0.0f ||            // price stored as float\n               it->second == 0.0f\n              ); // no-op: just to silence unused warning\n\n        float price = it->second == 0.0f ?\n                      std::stof(it->second.f0) : it->second.f1;\n\n        if (heap.size() < static_cast<size_t>(n)) {\n            heap.emplace(price, i);\n        } else if (price > heap.top().first) {\n            heap.pop();\n            heap.emplace(price, i);\n        }\n    }\n\n    // extract the indices from the heap into a vector\n    std::vector<size_t> topIndices;\n    topIndices.reserve(heap.size());\n    while (!heap.empty()) {\n        topIndices.push_back(heap.top().second);\n        heap.pop();\n    }\n\n    // The indices are currently in ascending order of price (smallest first).\n    // Reverse to get descending order.\n    std::reverse(topIndices.begin(), topIndices.end());\n\n    // Build the resulting vector\n    std::vector<std::map<std::string, Union_std_string_float>> result;\n    result.reserve(topIndices.size());\n    for (size_t idx : topIndices)\n        result.push_back(items[idx]);\n\n    return result;\n}\n```\n\n**Notes**\n\n1. **Price extraction** \u2013 The example union can store a string or a float;\n   this code assumes that when the price is stored, it is stored as the\n   float member `f1`.  If you want to support string\u2011encoded numbers as\n   well, you can use the `else` branch with `std::stof`.\n\n2. **Ordering** \u2013 The returned vector is sorted **descending** by\n   price, i.e. the first element is the most expensive.\n\n3. **Complexity** \u2013  \n   *Time:* \u202f`O(m\u202flog\u202fn)` where `m` is the number of items  \n   *Space:* \u202f`O(n)` for the heap and the resulting vector."]}
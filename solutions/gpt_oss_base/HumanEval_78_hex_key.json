{"name": "HumanEval_78_hex_key", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_78_hex_key.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a clean, self\u2011contained implementation that counts how many hexadecimal digits in the input string are prime (2,\u202f3,\u202f5,\u202f7,\u202fB,\u202fD).\n\n```cpp\n#include <string>\n\n// Returns the number of hex\u2011digits in `num` that are prime.\n//  Prime hex\u2011digits: 2, 3, 5, 7, B (11), D (13)\nlong hex_key(std::string num)\n{\n    // Set of prime hex\u2011digits\n    static const std::string primes = \"2357BD\";\n\n    long count = 0;\n    for (char c : num) {\n        if (primes.find(c) != std::string::npos) {\n            ++count;\n        }\n    }\n    return count;\n}\n```\n\n### Explanation\n* The function iterates over every character of the input string.\n* `primes` is a string containing all hexadecimal characters that represent prime values.\n* `std::string::find` checks if the current character is among those primes.\n* `count` is incremented whenever a prime digit is found.\n* Finally, the total count is returned.\n\n#### Usage examples\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << hex_key(\"AB\") << '\\n';          // 1\n    std::cout << hex_key(\"1077E\") << '\\n';       // 2\n    std::cout << hex_key(\"ABED1A33\") << '\\n';    // 4\n    std::cout << hex_key(\"123456789ABCDEF0\") << '\\n'; // 6\n    std::cout << hex_key(\"2020\") << '\\n';        // 2\n}\n```\n\nThe function assumes the input string is well\u2011formed (only `0-9` and `A-F`), as per the problem statement.", "Here is a concise implementation that follows the specification:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong hex_key(const string& num) {\n    // set of hexadecimal digits that correspond to prime numbers\n    static const unordered_set<char> primeHex = {'2', '3', '5', '7', 'B', 'D'};\n    long count = 0;\n    for (char c : num)\n        if (primeHex.count(c))\n            ++count;\n    return count;\n}\n```\n\n### How it works\n1. **Prime set** \u2013 We pre\u2011define the set of hexadecimal digits that represent prime numbers: `2, 3, 5, 7, B(11), D(13)`.  \n2. **Counting** \u2013 We iterate over each character of the input string.  \n3. **Lookup** \u2013 By checking `primeHex.count(c)`, we determine whether the current digit is prime.  \n4. **Result** \u2013 We increment the counter and return its final value.\n\nThis solution is `O(n)` in time (where `n` is the length of the input string) and `O(1)` in additional space, meeting the requirements efficiently.", "```cpp\n#include <string>\n\n/*  Counts how many hexadecimal digits of the given string are prime numbers.\n    Prime hexadecimal digits are: 2, 3, 5, 7, B (11), D (13).\n    The function simply scans the string and increments a counter\n    whenever it encounters one of these characters.  An empty string\n    yields 0.  It is guaranteed that the string contains only valid\n    hexadecimal digits (0\u20119, A\u2011F) and that letters are uppercase.\n\n    Example:\n        hex_key(\"AB\")        --> 1\n        hex_key(\"1077E\")     --> 2\n        hex_key(\"ABED1A33\")  --> 4\n        hex_key(\"123456789ABCDEF0\") --> 6\n        hex_key(\"2020\")      --> 2\n*/\nint hex_key(const std::string& num) {\n    const std::string primes = \"2357BD\";   // list of prime hex digits\n    int count = 0;\n    for (char c : num) {\n        if (primes.find(c) != std::string::npos) {\n            ++count;\n        }\n    }\n    return count;\n}\n```"]}
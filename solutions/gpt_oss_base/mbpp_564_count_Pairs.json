{"name": "mbpp_564_count_Pairs", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function which takes a vector of integers and counts the number of possible unordered pairs where both elements are unequal.\nlong count_Pairs(std::vector<long> arr, long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_564_count_Pairs.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = count_Pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)1})), (3)) == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1})), (4)) == (0));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})), (5)) == (10));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a compact **C++** (the code you posted was C++) implementation that follows the logic you described:  \n\n```\nlong count_Pairs(const std::vector<long>& arr, long n)\n{\n    // total unordered pairs\n    long totalPairs = n * (n - 1) / 2;        // C(n,2)\n\n    // count equal\u2011element pairs\n    std::unordered_map<long, long> freq;\n    for (long x : arr) ++freq[x];\n\n    long equalPairs = 0;\n    for (const auto& p : freq)\n        equalPairs += p.second * (p.second - 1) / 2;   // C(freq,2)\n\n    // unequal pairs = total \u2013 equal\n    return totalPairs - equalPairs;\n}\n```\n\n---\n\n### Why this works\n\n* **Unordered pair** \u2013 The pair \\((i, j)\\) and \\((j, i)\\) are considered the same, so we simply use combination \\(C(n, 2)\\).  \n* **Unequal elements** \u2013 Remove from the total the number of pairs that *do* have equal values.  \n* **Frequency map** \u2013 `freq[x]` counts how many times value `x` appears. From each frequency we subtract \\(C(f, 2)\\) equal\u2011pair counts.\n\n---\n\n### Usage example\n\n```cpp\nint main() {\n    std::vector<long> v = {1, 2, 2, 3, 3, 3};\n    long n = v.size();\n    std::cout << count_Pairs(v, n) << '\\n';   // Output: 7\n}\n```\n\nThe function returns `7` because there are 7 unordered pairs with different elements in the vector.\n\nFeel free to adapt the function signature or integrate it into your existing codebase.", "Here\u2019s a compact, self\u2011contained C++ function that does exactly what you asked:\n\n```cpp\n#include <vector>\n#include <unordered_map>\n#include <cstddef>   // for std::size_t\n\n//-------------------------------------------------------------\n// Count unordered pairs of indices (i , j) with i < j\n// such that arr[i] != arr[j].\n//-------------------------------------------------------------\nstd::size_t count_Pairs(const std::vector<long>& arr)\n{\n    const std::size_t n = arr.size();\n\n    // Total number of unordered pairs = n*(n-1)/2\n    std::size_t total_pairs = n * (n - 1) / 2;\n\n    // Count how many pairs have equal elements\n    std::unordered_map<long, std::size_t> freq;\n    for (long x : arr) {\n        ++freq[x];\n    }\n\n    std::size_t equal_pairs = 0;\n    for (const auto& kv : freq) {\n        std::size_t f = kv.second;           // frequency of this value\n        if (f >= 2)                          // C(f,2) only when f>=2\n            equal_pairs += f * (f - 1) / 2;   // add number of pairs of equal elements\n    }\n\n    // Unordered unequal pairs = total pairs - equal pairs\n    return total_pairs - equal_pairs;\n}\n```\n\n### How it works\n\n- **Total pairs**: For `n` elements, there are `nC2 = n*(n-1)/2` unordered pairs.\n- **Equal pairs**: Any value that appears `f` times contributes `fC2` pairs where both elements are equal. We sum those over all distinct values.\n- **Unequal pairs**: Subtract the equal\u2011pairs count from the total.\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> vec = {1, 2, 2, 3, 3, 3};\n    std::cout << \"Pairs with unequal elements: \"\n              << count_Pairs(vec) << std::endl; // outputs 7\n    return 0;\n}\n```\n\nThe function runs in **O(n)** time with an **O(k)** auxiliary space, where `k` is the number of distinct values in the vector.", "Below is a compact, self\u2011contained **C++** implementation of the requested \u201ccppthon\u201d function.  \nThe routine receives a vector of `long` integers (`arr`) and the size `n` of that vector (the size can also be obtained by `arr.size()` if you prefer).  \nIt returns the number of **unordered** pairs `\\((i,j)\\)` with `i < j` such that `arr[i] != arr[j]`.\n\nThe algorithm operates in **O(n)** time and **O(k)** extra space, where *k* is the number of distinct values in the vector.  \nThe idea is straightforward:\n\n1. **Count frequencies** of each distinct number (using an `unordered_map`).\n2. The total number of unordered pairs is `n*(n-1)/2`.  \n3. Subtract the number of pairs that are **equal**, which can be summed as  \n   \\(\\displaystyle \\sum_{v} \\frac{cnt_v \\, (cnt_v-1)}{2}\\).\n\nThat gives the required count of unequal\u2011element pairs.\n\n```cpp\n#include <bits/stdc++.h>\n\n// Counts unordered pairs (i < j) with arr[i] != arr[j].\nlong long count_pairs(const std::vector<long long> &arr) {\n    long long n = arr.size();\n    if (n < 2) return 0;\n\n    // 1. Frequency map\n    std::unordered_map<long long, long long> freq;\n    freq.reserve(n * 2);                // avoid rehashing\n    for (const auto &x : arr) ++freq[x];\n\n    // 2. Total unordered pairs\n    long long totalPairs = n * (n - 1) / 2;\n\n    // 3. Subtract equal\u2011element pairs\n    long long equalPairs = 0;\n    for (const auto &p : freq) {\n        long long cnt = p.second;\n        equalPairs += cnt * (cnt - 1) / 2;\n    }\n\n    return totalPairs - equalPairs;\n}\n\n// Example usage:\nint main() {\n    std::vector<long long> v{1, 2, 3, 2, 1};\n    std::cout << \"Unequal pairs: \" << count_pairs(v) << '\\n'; // Output: 6\n    return 0;\n}\n```\n\n### Why this works  \n- **Unordered pairs**: Each unordered pair is counted exactly once in `n*(n-1)/2`.  \n- **Unequal elements**: For every distinct value `v` that occurs `cnt` times, the number of pairs where both elements equal `v` is `cnt*(cnt-1)/2`. Summing over all distinct values yields the total number of equal\u2011element pairs, which we subtract.  \n- The routine is fully `O(n)` with a small constant overhead due to the unordered map.\n\nFeel free to integrate this snippet into your project or adapt it to your naming conventions."]}
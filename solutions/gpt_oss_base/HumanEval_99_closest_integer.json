{"name": "HumanEval_99_closest_integer", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_99_closest_integer.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a clean, self\u2011contained implementation that follows the rules you described:\n\n```cpp\n#include <cmath>\n#include <string>\n\n// Return the integer that is closest to *value*.\n// If it\u2019s exactly halfway between two integers, round away from zero.\nlong closest_integer(const std::string &value)\n{\n    // Convert to a floating point number first\n    // (strtold works for long double; for very large numbers the standard\n    //  conversion still keeps the precision you need for rounding)\n    long double number = std::stold(value);\n\n    // The nearest integers are floor(number) and ceil(number)\n    long long lower = static_cast<long long>(std::floor(number));\n    long long upper = static_cast<long long>(std::ceil(number));\n\n    // If both are the same (the number itself is an integer) return it\n    if (lower == upper) {\n        return lower;\n    }\n\n    // Compute the signed distance to both candidates\n    long double distLower = number - lower;   // always >= 0\n    long double distUpper = upper - number;   // always >= 0\n\n    // 1. If the distances differ, pick the smaller one\n    if (distLower < distUpper) {\n        return lower;\n    } else if (distUpper < distLower) {\n        return upper;\n    }\n\n    // 2. They are equal \u2013 round away from zero\n    //    If the number is negative, prefer the *more* negative integer\n    //    If positive, prefer the larger integer\n    if (number >= 0.0L) {\n        return upper;          // e.g. 14.5 \u2192 15\n    } else {\n        return lower;          // e.g. -14.5 \u2192 -15\n    }\n}\n```\n\n### How it works\n\n1. **Parse** the input string into a `long double` (good precision for most cases).\n2. Compute the next lower and higher integers with `floor` and `ceil`.\n3. If the number already is an integer, return it.\n4. Compare the distances to the candidates.\n   * Pick the closer one if the distances differ.\n5. If the distances are identical (exact half\u2011way), choose the candidate\n   that is further from zero (i.e., \u201caway from zero\u201d rounding).\n\n### Example usage\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << closest_integer(\"10\")    << '\\n';   // 10\n    std::cout << closest_integer(\"15.3\")  << '\\n';   // 15\n    std::cout << closest_integer(\"14.5\")  << '\\n';   // 15\n    std::cout << closest_integer(\"-14.5\") << '\\n';   // -15\n}\n```\n\nThis satisfies all the requirements: it rounds normally, and in the tie case it rounds away from zero.", "Here is a concise implementation that respects the \u201cround away from zero\u201d rule:\n\n```cpp\n#include <string>\n#include <cmath>\n#include <limits>\n\nlong closest_integer(const std::string& value)\n{\n    // Convert the decimal string to a double.\n    // If the conversion fails we throw an exception \u2013 the\n    // behaviour is left to the caller.\n    double d = std::stod(value);\n\n    // The lower and upper integer bounds.\n    long lower = static_cast<long>(std::floor(d));\n    long upper = static_cast<long>(std::ceil(d));\n\n    /* When d is already an integer the two bounds are equal,\n     * so we can return any of them. */\n    if (lower == upper)\n        return lower;\n\n    // Distances from the two possible integers.\n    double distLow  = std::fabs(d - static_cast<double>(lower));\n    double distHigh = std::fabs(d - static_cast<double>(upper));\n\n    if (distLow < distHigh)          // closer to lower\n        return lower;\n    if (distHigh < distLow)          // closer to upper\n        return upper;\n\n    /* Distances are equal \u2013 we must round away from zero.\n     * The farthest from zero among the two options is simply the one\n     * with the larger absolute value.\n     */\n    if (std::abs(lower) > std::abs(upper))\n        return lower;\n    else\n        return upper;\n}\n```\n\n### Why this works\n\n* `std::stod` converts the string to a floating\u2011point value.\n* `floor` and `ceil` give the two integers between which the number lies.\n* The distances to both integers are compared.\n* If the distances are tied, the *sign* of the numbers decides:\n  * For a positive number the farther integer is the larger one (`upper`).\n  * For a negative number the farther integer is the smaller (more negative) one (`lower`).\n\nThis satisfies all the examples:\n\n```cpp\nclosest_integer(\"10\")    // 10\nclosest_integer(\"15.3\")  // 15\nclosest_integer(\"14.5\")  // 15\nclosest_integer(\"-14.5\") // -15\n```", "Below is a concise, self\u2011contained implementation that follows the specification:\n\n```cpp\n#include <string>\n#include <cmath>   // for std::floor, std::ceil, std::fabs\n#include <stdexcept>\n\nlong closest_integer(const std::string &value)\n{\n    // Convert the string to a floating point number.\n    // std::stod throws std::invalid_argument if the string is not\n    // a valid representation, mirroring the behaviour of the\n    // original problem statement.\n    double number = std::stod(value);\n\n    // Fast\u2011path for exact integers (no fractional part).\n    if (std::floor(number) == number) {\n        return static_cast<long>(number);\n    }\n\n    // Get the two adjacent integers.\n    long lower = static_cast<long>(std::floor(number));\n    long upper = static_cast<long>(std::ceil (number));\n\n    // Compute the distances to the input value.\n    double dist_low  = std::fabs(number - static_cast<double>(lower));\n    double dist_high = std::fabs(number - static_cast<double>(upper));\n\n    // Determine the closer one, handling ties by rounding\n    // away from zero (the number with the larger absolute value).\n    if (dist_low < dist_high) {\n        return lower;\n    }\n    if (dist_high < dist_low) {\n        return upper;\n    }\n\n    // The value is exactly half\u2011way between the two integers.\n    // Round away from zero:\n    return (number > 0) ? upper : lower;\n}\n```\n\n### Explanation\n\n1. **Conversion** \u2013 `std::stod` safely handles conversion; any invalid string will throw.\n2. **Exact integer check** \u2013 If the number is already an integer, we just return it.\n3. **Bounding integers** \u2013 `floor` and `ceil` give the two candidates.\n4. **Distance comparison** \u2013 We compare absolute differences.\n5. **Tie handling** \u2013 When the distances are equal, choose the candidate with a larger absolute value (`>= 0` for positive numbers, `<= 0` for negative numbers), which is precisely rounding *away* from zero.\n\n#### Usage\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << closest_integer(\"10\")     << '\\n'; // 10\n    std::cout << closest_integer(\"15.3\")   << '\\n'; // 15\n    std::cout << closest_integer(\"14.5\")   << '\\n'; // 15\n    std::cout << closest_integer(\"-14.5\")  << '\\n'; // -15\n}\n```\n\nThis function complies with the requested behaviour and is portable across any C++ standard that supports `std::stod`."]}
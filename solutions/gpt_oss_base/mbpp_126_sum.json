{"name": "mbpp_126_sum", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to find the sum of common divisors of two given numbers.\nlong sum(long a, long b) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_126_sum.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = sum;\n    assert(candidate((10), (15)) == (6));\n    assert(candidate((100), (150)) == (93));\n    assert(candidate((4), (6)) == (3));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a clean, self\u2011contained C++ implementation that follows the requirement \u2013 \u201cwrite a Py/Cpp function to find the sum of common divisors of two given numbers\u201d.  \nThe function **`sumCommonDivisors`** takes two `long long` integers (the same as `long` on most platforms) and returns the sum of all positive integers that divide both of them.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*  sumCommonDivisors(a,b)\n *  Computes the sum of all common divisors of a and b.\n *\n *  Example:\n *      a = 12, b = 18  \u2192  common divisors are 1, 2, 3, 6\n *      result = 1 + 2 + 3 + 6 = 12\n *\n *  Complexity: O( sqrt(g) )  where g = gcd(a,b)\n *  Reason:  Every common divisor of a and b is a divisor of g.\n */\nlong long sumCommonDivisors(long long a, long long b) {\n    if (a == 0 && b == 0)          // by convention: no positive divisors\n        return 0;\n    // ensure positive numbers\n    a = llabs(a);  b = llabs(b);\n\n    long long g = std::gcd(a, b);          // greatest common divisor\n    long long sum = 0;\n    for (long long d = 1; d * d <= g; ++d) {\n        if (g % d == 0) {\n            sum += d;                     // d is a divisor\n            long long other = g / d;       // paired divisor\n            if (other != d) sum += other; // avoid double\u2011count when d\u00b2=g\n        }\n    }\n    return sum;\n}\n\n/*  Simple test harness  */\n#ifdef LOCAL\nint main() {\n    assert(sumCommonDivisors(12, 18) == 12);\n    assert(sumCommonDivisors(15, 25) == 10);   // 1,5\n    assert(sumCommonDivisors(7, 13)  == 1 );    // only 1\n    assert(sumCommonDivisors(0, 5)  == 5 );    // divisors of 5\n    assert(sumCommonDivisors(0, 0)  == 0 );    // edge case\n    cout << \"All tests passed!\\n\";\n    return 0;\n}\n#endif\n```\n\n### How it works  \n1. **Normalization** \u2013 Convert both numbers to their absolute values to handle negatives.  \n2. **GCD** \u2013 The common divisors of `a` and `b` are exactly the divisors of `g = gcd(a,b)`.  \n3. **Enumerate divisors of g**  \n   * Loop `d` from `1` to `sqrt(g)`.  \n   * If `d` divides `g`, add it to `sum`.  \n   * If `d` and `g/d` are different, also add the paired divisor.  \n4. **Return** the accumulated `sum`.\n\nThe algorithm runs in `O(sqrt(g))` time and `O(1)` extra space, which is optimal for this problem.", "Here is a compact, well\u2011documented C++ implementation that returns the sum of all common divisors of two integers `a` and `b`.\n\n```cpp\n/**\n * @brief   Return the sum of all common divisors of a and b.\n * @param   a  First positive integer.\n * @param   b  Second positive integer.\n * @return  Sum of common divisors (the divisors of gcd(a,b)).\n *\n * The algorithm is simple:  \n *   1. Calculate g = gcd(a,b).  \n *   2. Enumerate all divisors of `g` up to \u221ag.  \n *   3. For each divisor `d` add it and `g/d` to the sum.  \n *   4. Handle the special case when `d*d == g` so that we don't double\u2011count.\n *\n * Complexity: O(\u221ag) time, O(1) additional space.\n */\nlong sum(long a, long b) {\n    if (a <= 0 || b <= 0)  // safety check \u2013 input must be positive\n        return 0;\n\n    // 1. Compute gcd\n    long g = std::gcd(a, b);     // C++17 <numeric> has std::gcd\n\n    // 2. Enumerate divisors of g\n    long long sum_common = 0;    // use long long to avoid overflow while summing\n    for (long long d = 1; d * d <= g; ++d) {\n        if (g % d == 0) {\n            sum_common += d;          // the divisor itself\n            if (d != g / d)           // avoid adding sqrt twice\n                sum_common += g / d;   // its complementary divisor\n        }\n    }\n\n    return static_cast<long>(sum_common);\n}\n```\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << sum(12, 30) << '\\n';  // 12 and 30 have gcd 6 \u2192 1+2+3+6 = 12\n    std::cout << sum(17, 29) << '\\n';  // gcd is 1 \u2192 sum = 1\n    return 0;\n}\n```\n\nThis function works for any positive integers up to `long` limits and employs only standard library facilities (`<numeric>` for `std::gcd`).", "Here is a concise and correct implementation of the requested function in C++.  \nThe idea is straightforward:\n\n1. Find the greatest common divisor (GCD) of the two numbers \u2013 only the divisors of the GCD can be common divisors.\n2. Enumerate all divisors of that GCD (by iterating up to the square root).\n3. Sum them up, making sure that when a divisor is `d` its complementary divisor `g/d` is added separately unless `d == g/d`.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Return the greatest common divisor of a and b.\nstatic inline long long gcd_ll(long long a, long long b) {\n    while (b) {\n        long long t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\n// Sum of all common divisors of a and b.\nlong long sum(long long a, long long b) {\n    if (a <= 0 || b <= 0) return 0;          // Nothing to do for non\u2011positive numbers\n\n    long long g = gcd_ll(a, b);              // Common divisor set = divisors of g\n    long long total = 0;\n\n    for (long long d = 1; d * d <= g; ++d) {\n        if (g % d == 0) {\n            total += d;                       // divisor d\n            long long q = g / d;\n            if (q != d) total += q;           // complementary divisor\n        }\n    }\n    return total;\n}\n\n/* Example usage\nint main() {\n    cout << sum(36, 48) << '\\n';   // 6 (1+2+3+6)\n}\n*/\n```\n\n**Key points**\n\n- We use the Euclidean algorithm (iterative) to compute the GCD efficiently.\n- The divisor enumeration runs in `O(\u221ag)` time, which is fast even for `g` up to `10^12` or more.\n- The function works for all positive integers; for non\u2011positive inputs it returns `0`."]}
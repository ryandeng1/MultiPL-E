{"name": "mbpp_245_max_sum", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector and finds the maximum sum of a bitonic subsequence for the given vector, where a sequence is bitonic if it is first increasing and then decreasing.\nlong max_sum(std::vector<long> arr) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_245_max_sum.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = max_sum;\n    assert(candidate((std::vector<long>({(long)1, (long)15, (long)51, (long)45, (long)33, (long)100, (long)12, (long)18, (long)9}))) == (194));\n    assert(candidate((std::vector<long>({(long)80, (long)60, (long)30, (long)40, (long)20, (long)10}))) == (210));\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)14, (long)16, (long)21, (long)23, (long)29, (long)30}))) == (138));\n}\n", "stop_tokens": ["\n}"], "completions": ["**Solution Explanation**\n\nFor every element `a[i]` we consider two parts\n\n* `inc[i]` \u2013 maximum sum of an *increasing* subsequence that ends at `i`  \n* `dec[i]` \u2013 maximum sum of a *decreasing* subsequence that starts at `i`\n\nIf we put `a[i]` in the middle of the bitonic subsequence, the total sum is\n\n```\ninc[i] + dec[i] \u2013 a[i]          (a[i] is counted twice)\n```\n\nThe answer is the maximum of this value over all positions `i`.\n\nBoth `inc` and `dec` can be computed in `O(n\u00b2)` time:\n\n```\ninc[i] = a[i] + max{ inc[j] | j < i and a[j] < a[i] }\ndec[i] = a[i] + max{ dec[j] | j > i and a[j] < a[i] }\n```\n\nFor convenience the second recurrence is processed from the right to the left.\n\nThe algorithm therefore runs in `O(n\u00b2)` time and `O(n)` memory, which is sufficient for the usual constraints of this problem.\n\n\n\n```cpp\n#include <bits/stdc++.h>\n\n// returns the maximum possible sum of a bitonic subsequence\nlong max_sum(std::vector<long> arr)\n{\n    int n = static_cast<int>(arr.size());\n    if (n == 0) return 0;\n\n    std::vector<long> inc(n, 0), dec(n, 0);\n\n    /* maximum sum of increasing subsequence that ends at i */\n    for (int i = 0; i < n; ++i) {\n        inc[i] = arr[i];                            // subsequence of length 1\n        for (int j = 0; j < i; ++j) {\n            if (arr[j] < arr[i] && inc[j] + arr[i] > inc[i])\n                inc[i] = inc[j] + arr[i];\n        }\n    }\n\n    /* maximum sum of decreasing subsequence that starts at i */\n    for (int i = n - 1; i >= 0; --i) {\n        dec[i] = arr[i];\n        for (int j = i + 1; j < n; ++j) {\n            if (arr[j] < arr[i] && dec[j] + arr[i] > dec[i])\n                dec[i] = dec[j] + arr[i];\n        }\n    }\n\n    /* combine the two parts and find the best */\n    long best = 0;\n    for (int i = 0; i < n; ++i) {\n        long total = inc[i] + dec[i] - arr[i];\n        if (total > best) best = total;\n    }\n    return best;\n}\n```\n\nThe function follows the idea described above and works in `O(n\u00b2)` time. It has no external dependencies and is ready to be used in any C++ project.", "**Solution Explanation**\n\nFor a vector `arr[0 \u2026 n\u20111]` we have to find a *bitonic* subsequence\n\n```\n   first strictly increasing  +  later strictly decreasing\n```\n\nwhose element values sum is maximum.\n\nThe classic way to solve this is a two\u2011pass DP:\n\n* **Forward DP** \u2013 greatest increasing\u2011subsequence sum that ends at every vertex.\n* **Backward DP** \u2013 greatest decreasing\u2011subsequence sum that starts at every vertex.\n\nOnce both tables are known, the maximum over all vertices of  \n`forward[i] + backward[i] \u2013 arr[i]` gives the answer  \n(the element `arr[i]` is part of both subsequences and therefore counted twice).\n\nThe subsequence may consist of a single element (purely increasing or purely\ndecreasing).  That case is handled automatically by the DP.\n\n--------------------------------------------------------------------\n\n#### Algorithm\n\n```\nmax_sum(arr):\n    n = arr.size()\n    if n == 0 return 0\n\n    inc[0 \u2026 n-1]   = 0   // best increasing sum ending at i\n    dec[0 \u2026 n-1]   = 0   // best decreasing sum starting at i\n\n    // forward pass : increasing sequences\n    for i from 0 to n-1:\n        inc[i] = arr[i]                     // at least the element itself\n        for j from 0 to i-1:\n            if arr[j] < arr[i]:             // strictly increasing\n                inc[i] = max(inc[i], inc[j] + arr[i])\n\n    // backward pass : decreasing sequences\n    for i from n-1 downto 0:\n        dec[i] = arr[i]                     // at least the element itself\n        for j from n-1 downto i+1:\n            if arr[j] < arr[i]:             // strictly decreasing (arr[i] > arr[j])\n                dec[i] = max(dec[i], dec[j] + arr[i])\n\n    // combine\n    best = 0\n    for i from 0 to n-1:\n        best = max(best, inc[i] + dec[i] - arr[i])\n    return best\n```\n\n--------------------------------------------------------------------\n\n#### Correctness Proof  \n\nWe prove that the algorithm returns the maximum possible bitonic\u2011subsequence sum.\n\n---\n\n##### Lemma 1  \nFor every index `i`, `inc[i]` equals the maximum sum of an increasing subsequence\nthat ends at position `i`.\n\n**Proof.**\n\n*Base:* when `i = 0`, the only increasing subsequence ending at 0 is `[arr[0]]`;  \n`inc[0] = arr[0]` \u2013 correct.\n\n*Induction step:* Assume the lemma holds for all indices `< i`.  \nDuring the forward pass, `inc[i]` is initially set to `arr[i]` (the subsequence consisting\nsolely of this element).  \nFor each `j < i` with `arr[j] < arr[i]`, `inc[j] + arr[i]` is the sum of\nan increasing subsequence ending at `j` (by induction hypothesis) extended by `arr[i]`.  \nTaking the maximum over all such `j` updates `inc[i]` to the best possible  \nincreasing subsequence sum ending at `i`. \u220e\n\n\n\n##### Lemma 2  \nFor every index `i`, `dec[i]` equals the maximum sum of a decreasing subsequence\nthat starts at position `i`.\n\n**Proof.**\n\nSymmetric to Lemma&nbsp;1, walking the array from right to left. \u220e\n\n\n\n##### Lemma 3  \nFor every index `i`, the value `inc[i] + dec[i] \u2013 arr[i]`\nequals the maximum sum of a bitonic subsequence that has its peak at `i`.\n\n**Proof.**\n\nAny bitonic subsequence whose peak is at `i` can be written as  \n`(increasing part ending at i) + (decreasing part starting at i)`  \nwith the value `arr[i]` counted twice.  \nBy Lemma&nbsp;1 and Lemma&nbsp;2 these two parts have maximum possible sums\n`inc[i]` and `dec[i]`.  \nSubtracting `arr[i]` removes the double count, giving the optimum sum for\npeak `i`. \u220e\n\n\n\n##### Theorem  \nThe algorithm returns the maximum sum over all bitonic subsequences of `arr`.\n\n**Proof.**\n\nBy Lemma&nbsp;3, for every index `i` the algorithm computes the optimum\nbitonic\u2011subsequence sum with peak at `i`.  \nTaking the maximum over all `i` therefore yields the optimum over *all* bitonic subsequences. \u220e\n\n\n\n--------------------------------------------------------------------\n\n#### Complexity Analysis\n\nLet `n` be the size of the input vector.\n\n*Both passes* iterate over all pairs `(i,j)` once, thus  \n`O(n\u00b2)` time, `O(n)` auxiliary memory.\n\n--------------------------------------------------------------------\n\n#### Reference Implementation  (C++17)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong max_sum(const vector<long>& arr) {\n    int n = (int)arr.size();\n    if (n == 0) return 0L;\n\n    vector<long> inc(n, 0), dec(n, 0);\n\n    /* forward DP \u2013 increasing subsequences ending at i */\n    for (int i = 0; i < n; ++i) {\n        inc[i] = arr[i];\n        for (int j = 0; j < i; ++j)\n            if (arr[j] < arr[i])\n                inc[i] = max(inc[i], inc[j] + arr[i]);\n    }\n\n    /* backward DP \u2013 decreasing subsequences starting at i */\n    for (int i = n - 1; i >= 0; --i) {\n        dec[i] = arr[i];\n        for (int j = n - 1; j > i; --j)\n            if (arr[j] < arr[i])   // arr[i] > arr[j]  \u2192 decreasing if we go left\n                dec[i] = max(dec[i], dec[j] + arr[i]);\n    }\n\n    /* combine */\n    long best = 0;\n    for (int i = 0; i < n; ++i)\n        best = max(best, inc[i] + dec[i] - arr[i]);\n\n    return best;\n}\n\n/* For quick manual testing */\nint main() {\n    vector<long> a = {1, 5, -1, 2, 3};\n    cout << max_sum(a) << '\\n';  // Expected: 10  (1 + 5 + 3 + 1?)\n    return 0;\n}\n```\n\nThe code follows exactly the algorithm proven correct above and\nconforms to the C++17 standard.", "Here\u2019s a complete implementation of `max_sum`.  \nIt follows the classic \u201cmaximum\u2011sum bitonic subsequence\u201d DP algorithm:\n\n* `inc[i]` \u2013 maximum sum that ends at index *i* (strictly increasing part).\n* `dec[i]` \u2013 maximum sum that starts at index *i* (strictly decreasing part).\n* The bitonic subsequence that peaks at *i* has total sum `inc[i] + dec[i] - arr[i]` (the peak is counted twice).  \nThe answer is the maximum of those sums over all indices.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n//-------------------------------------------------------------------------\n// max_sum: Returns the maximum sum of any bitonic subsequence of `arr`.\n// A bitonic subsequence first strictly increases and then strictly\n// decreases (the increasing or decreasing part may be empty).\n//-------------------------------------------------------------------------\nlong max_sum(const vector<long>& arr)\n{\n    int n = arr.size();\n    if (n == 0) return 0;\n\n    // inc[i] \u2013 maximum sum of an increasing subsequence that ends at i\n    vector<long> inc(n, 0);\n    for (int i = 0; i < n; ++i) {\n        inc[i] = arr[i];                     // subsequence consisting of arr[i] alone\n        for (int j = 0; j < i; ++j) {\n            if (arr[j] < arr[i]) {\n                inc[i] = max(inc[i], inc[j] + arr[i]);\n            }\n        }\n    }\n\n    // dec[i] \u2013 maximum sum of a decreasing subsequence that starts at i\n    vector<long> dec(n, 0);\n    for (int i = n - 1; i >= 0; --i) {\n        dec[i] = arr[i];\n        for (int j = i + 1; j < n; ++j) {\n            if (arr[j] < arr[i]) {\n                dec[i] = max(dec[i], dec[j] + arr[i]);\n            }\n        }\n    }\n\n    // Combine both halves at every possible peak index\n    long best = 0;\n    for (int i = 0; i < n; ++i) {\n        long total = inc[i] + dec[i] - arr[i];   // peak arr[i] counted twice\n        best = max(best, total);\n    }\n    return best;\n}\n\n// ---------------------------------------------------------------------\n// Example usage + simple tests (not part of library)\n// ---------------------------------------------------------------------\nint main() {\n    vector<long> a{1, 5, 2, 3, 4, 2, 1};\n    cout << \"Max sum of a bitonic subsequence: \" << max_sum(a) << endl; // expected 15 (1+5+2+3+4)\n\n    // Additional tests\n    vector<long> b{10, 20, 30, 40};\n    cout << \"Max sum: \" << max_sum(b) << endl; // 100 (10+20+30+40)\n\n    vector<long> c{40, 30, 20, 10};\n    cout << \"Max sum: \" << max_sum(c) << endl; // 100 (40+30+20+10)\n\n    return 0;\n}\n```\n\n### How it Works\n\n1. **Increasing part (`inc`)**  \n   For every element `arr[i]`, we look at all previous elements `arr[j]` that are smaller than `arr[i]`.  \n   If we can extend the best increasing subsequence that ends at `j` by adding `arr[i]`, we do so.  \n   Complexity: `O(n\u00b2)`.\n\n2. **Decreasing part (`dec`)**  \n   Similar to `inc`, but we walk from the end of the array toward the beginning.  \n   For each element `arr[i]` we consider all following elements smaller than it.\n\n3. **Combining**  \n   The bitonic subsequence that peaks at index `i` is formed by the best increasing subsequence up to `i` plus the best decreasing subsequence starting from `i`.  \n   The peak `arr[i]` is included in both sides, so we subtract it once.\n\n4. **Result**  \n   The maximum of these combined sums is the answer.\n\nThe algorithm runs in `O(n\u00b2)` time and `O(n)` auxiliary space, which is acceptable for typical problem sizes (up to a few thousand elements)."]}
{"name": "mbpp_91_find_substring", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to check if a string is present as a substring in a given vector of string values.\nbool find_substring(std::vector<std::string> str1, std::string sub_str) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_91_find_substring.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = find_substring;\n    assert(candidate((std::vector<std::string>({(std::string)\"red\", (std::string)\"black\", (std::string)\"white\", (std::string)\"green\", (std::string)\"orange\"})), (\"ack\")) == (true));\n    assert(candidate((std::vector<std::string>({(std::string)\"red\", (std::string)\"black\", (std::string)\"white\", (std::string)\"green\", (std::string)\"orange\"})), (\"abc\")) == (false));\n    assert(candidate((std::vector<std::string>({(std::string)\"red\", (std::string)\"black\", (std::string)\"white\", (std::string)\"green\", (std::string)\"orange\"})), (\"ange\")) == (true));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a simple, self\u2011contained implementation that does exactly what the comment asks for:  \n* Iterate over every string in the vector.  \n* Use `std::string::find` to see if `sub_str` appears as a substring of that string.  \n* Return `true` on the first hit and `false` if none of the strings contain the substring.\n\n```cpp\n#include <vector>\n#include <string>\n\n/**\n * @brief   Checks if a given string appears as a substring of any string\n *          within the provided vector.\n *\n * @param   vec   Vector of strings to search inside.\n * @param   query Substring we are looking for.\n * @return  true  if `query` appears in at least one element of `vec`;\n *          false otherwise.\n */\nbool find_substring(const std::vector<std::string>& vec, const std::string& query)\n{\n    // Quick guard for an empty query \u2013 by definition an empty string\n    // is a substring of any string (including an empty one).\n    if (query.empty()) return true;\n\n    for (const auto& s : vec)\n    {\n        if (s.find(query) != std::string::npos)\n            return true;          // Found it!\n    }\n    return false;                 // Nothing matched\n}\n```\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<std::string> words {\"apple\", \"banana\", \"cherry\"};\n\n    std::cout << std::boolalpha;\n    std::cout << \"contains \\\"nan\\\": \" << find_substring(words, \"nan\") << '\\n';   // true\n    std::cout << \"contains \\\"xyz\\\": \" << find_substring(words, \"xyz\") << '\\n';   // false\n}\n```\n\n**Why this works**\n- `std::string::find` returns the index of the first occurrence of `query` or `std::string::npos` if it\u2019s not present.\n- We stop as soon as we hit a match, keeping the algorithm\u2019s time complexity to `O(total_characters_in_vector)` in the worst case.", "Here is a complete, clean implementation of the requested function.  \nIt uses the standard library\u2019s `find` algorithm for the vector and the `std::string::find` member for the substring.  \nI\u2019ve also added a small test harness that demonstrates how to use the function.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\n/**\n * @brief   Checks if a given substring occurs in any element of a vector of strings.\n *\n * @param  vec   The vector of strings to search through.\n * @param  sub   The substring to look for.\n *\n * @return true  if at least one element of `vec` contains `sub`, otherwise false.\n */\nbool find_substring(const std::vector<std::string>& vec, const std::string& sub)\n{\n    // Iterate over the strings in the vector\n    for (const auto& s : vec)\n    {\n        // std::string::find returns string::npos when the substring is not found\n        if (s.find(sub) != std::string::npos)\n            return true;\n    }\n    return false;\n}\n\n/* ---------- Optional test harness ---------- */\nint main()\n{\n    std::vector<std::string> words = {\n        \"apple\",\n        \"banana\",\n        \"cherry\",\n        \"date\"\n    };\n\n    // Test cases\n    assert(find_substring(words, \"nan\") == true);   // found in \"banana\"\n    assert(find_substring(words, \"rry\") == true);   // found in \"cherry\"\n    assert(find_substring(words, \"grape\") == false); // not found\n\n    // If we reach this point, all tests passed\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\n### How it works\n\n1. **Parameter passing**  \n   - The vector is passed by **const reference** (`const std::vector<std::string>&`) to avoid copying and to guarantee it won\u2019t be modified.  \n   - The substring is also passed by reference for the same reason.\n\n2. **Loop over the vector**  \n   - For each string `s` in the vector we call `s.find(sub)`.  \n   - `std::string::find` returns the index of the first occurrence of `sub`.  \n   - If the substring isn\u2019t found, it returns `std::string::npos`.\n\n3. **Return**  \n   - As soon as we find a match, we return `true`.  \n   - If the loop finishes without a match, we return `false`.\n\nFeel free to drop this function into your codebase or adapt it for more sophisticated searching (e.g., case\u2011insensitive, regex, etc.).", "Below is a complete, self\u2011contained implementation of the requested function **`find_substring`**.  \nIt takes a vector of `std::string` (`str1`) and a substring (`sub_str`) and returns `true`\niff **any** of the strings in `str1` contains `sub_str` as a substring.\n\n```cpp\n#include <string>\n#include <vector>\n\n/**\n * @brief   Checks whether any string in `pool` contains `needle` as a substring.\n *\n * @param   pool   The vector of string values that will be searched.\n * @param   needle The substring that we want to find.\n *\n * @return  true  if at least one string in `pool` contains `needle`;\n *          false otherwise.\n */\nbool find_substring(const std::vector<std::string>& pool,\n                    const std::string& needle)\n{\n    // Quick exit: an empty needle is a substring of any string.\n    if (needle.empty()) return true;\n\n    for (const auto& s : pool)\n    {\n        // `std::string::find` returns std::string::npos if `needle` is not found.\n        if (s.find(needle) != std::string::npos)\n            return true;\n    }\n    return false;\n}\n```\n\n### How it works\n\n1. **Fast check for an empty substring** \u2013 by definition an empty string is a\n   substring of any string, so we return `true` immediately.\n\n2. **Iterate over the vector** \u2013 we use a range\u2011based `for` loop so the code is\n   easy to read. The vector is passed by const reference to avoid an expensive\n   copy.\n\n3. **Search each string** \u2013 `std::string::find` scans the current string for the\n   pattern `needle`.  \n   * If the search succeeds (`!= std::string::npos`), we return `true`.  \n   * If the loop finishes without a match, we return `false`.\n\n### Example usage\n\n```cpp\n#include <iostream>\n#include <vector>\n\nint main()\n{\n    std::vector<std::string> words = {\"hello\", \"world\", \"foobar\", \"test\"};\n    std::string sub = \"foo\";\n\n    if (find_substring(words, sub))\n        std::cout << \"Substring found!\\n\";\n    else\n        std::cout << \"Substring not found.\\n\";\n}\n```\n\nOutput:\n```\nSubstring found!\n```\n\n### Why this implementation is good\n\n| Aspect | Reason |\n|--------|--------|\n| `const std::vector<std::string>&` | Prevents unnecessary copying and guarantees the function does not modify the caller\u2019s data. |\n| `std::string::find` | Uses the highly optimised standard library routine for substring searching; it works correctly for all Unicode\u2011encoded UTF\u20118 strings as long as the byte representation is searched. |\n| Early exit on match | As soon as a match is found the loop stops, giving the best possible performance for the \u201cany\u2011match\u201d case. |\n| Handles empty needles | Adheres to the mathematical definition that an empty string is a substring of any string. |\n| Clear, documented API | The function signature, comments, and use of descriptive variable names help maintainability. |\n\nFeel free to plug this into your project or adapt it to your exact coding style!"]}
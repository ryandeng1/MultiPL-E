{"name": "mbpp_6_differ_At_One_Bit_Pos", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to check whether the two numbers differ at one bit position only or not.\nbool differ_At_One_Bit_Pos(long a, long b) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_6_differ_At_One_Bit_Pos.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = differ_At_One_Bit_Pos;\n    assert(candidate((13), (9)) == (true));\n    assert(candidate((15), (8)) == (false));\n    assert(candidate((2), (4)) == (false));\n    assert(candidate((2), (3)) == (true));\n    assert(candidate((5), (1)) == (true));\n    assert(candidate((1), (5)) == (true));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a minimal, self\u2011contained C++ implementation that checks whether two integral values differ in **exactly one bit position**.  \nThe key idea is simple:  \n\n* `a ^ b` yields a number whose 1\u2011bits mark positions where the two numbers differ.  \n* If this result is a power of two, there was exactly one differing bit.  \n* A power\u2011of\u2011two number has only one bit set, so the binary representation is of the form `100\u20260`.  \n  `x & (x\u20111)` is zero **iff** `x` has a single 1\u2011bit (and, of course, `x` must be non\u2011zero).\n\nBelow is a clean, compilable snippet that also contains a small test harness. Feel free to drop in the function alone if you only need it as a helper.\n\n```cpp\n#include <cstdint>   // for uint64_t\n#include <iostream>\n#include <cassert>\n\n/**\n * @brief   Checks if two numbers differ in exactly one bit position.\n *\n * @param   a   First integer.\n * @param   b   Second integer.\n *\n * @return  true  if the numbers differ in exactly one bit; false otherwise.\n *\n * @note    Works for signed/unsigned types that can be promoted to uint64_t.\n */\nbool differ_At_One_Bit_Pos(long long a, long long b)\n{\n    // XOR gives bits that are different.\n    uint64_t diff = static_cast<uint64_t>(a ^ b);\n\n    // Zero means identical numbers \u2013 not a single\u2011bit difference.\n    if (diff == 0) return false;\n\n    // diff is a power of two iff diff & (diff-1) is zero.\n    return (diff & (diff - 1)) == 0;\n}\n\n/* ---------- test harness (optional) ---------- */\nint main()\n{\n    // Some examples\n    assert(differ_At_One_Bit_Pos(7, 5) == true);   // 111 vs 101\n    assert(differ_At_One_Bit_Pos(15, 14) == true); // 1111 vs 1110\n    assert(differ_At_One_Bit_Pos(8, 8) == false);  // identical\n    assert(differ_At_One_Bit_Pos(0, 1) == true);   // 0 vs 1\n    assert(differ_At_One_Bit_Pos(-2, -3) == true); // Two\u2019s\u2011complement nuance\n\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\n### Why this works\n* **`a ^ b`** \u2013 XOR will set a bit to `1` exactly where the two operands differ.  \n* **`diff != 0`** \u2013 ensures that they are not identical.  \n* **`diff & (diff - 1)`** \u2013 for any binary number, subtracting one flips all lower\u2011order\n  bits after the least\u2011significant set bit. If only one bit was set, the result becomes zero.  \n  If more than one bit was set, at least one of those lower bits remains, so the\n  expression is non\u2011zero.\n\nThis approach is O(1) in time and uses only a handful of machine instructions, making it perfect for tight loops or embedded code.", "Here\u2019s a compact, fully\u2011portable C++ implementation that checks whether two integers differ in **exactly one bit position**.\n\n```cpp\n/*  Check whether a and b differ at one and only one bit position.\n    Returns true if |a ^ b| is a power of two, otherwise false. */\n\n#include <cstdint>   // for int types\n#include <limits>    // for numeric_limits\n#include <cassert>   // for assert\n\nbool differ_At_One_Bit_Pos(long a, long b)\n{\n    long xorVal = a ^ b;                // bits that differ\n    if (xorVal == 0)                    // no bit differs\n        return false;\n    /* xorVal is positive; a power of two has one single bit set.\n         For unsigned arithmetic we can check: (xorVal & (xorVal - 1)) == 0\n         For signed long, we cast to unsigned to avoid UB on negative values. */\n    return (static_cast<unsigned long>(xorVal) &\n            (static_cast<unsigned long>(xorVal) - 1)) == 0;\n}\n```\n\n### Why this works\n1. **Bitwise XOR** (`a ^ b`) gives a number whose bits are set only where `a` and `b` differ.  \n2. If no bits differ the result is `0`; we return `false`.  \n3. For a single differing bit the XOR value is a power of two: exactly one bit set.  \n   A number `x` is a power of two iff `x != 0` and `x & (x-1)` equals `0`.  \n   The cast to `unsigned long` guarantees defined right\u2011shifts even if `long` is signed.\n\n### Quick unit tests\n\n```cpp\nint main() {\n    assert(differ_At_One_Bit_Pos(5, 4));   // 0101 vs 0100 \u2192 one bit\n    assert(!differ_At_One_Bit_Pos(5, 0));  // 0101 vs 0000 \u2192 two bits\n    assert(!differ_At_One_Bit_Pos(7, 7));  // no bits\n    assert(differ_At_One_Bit_Pos(1, 0));   // 1 vs 0 \u2192 one bit\n    assert(differ_At_One_Bit_Pos(1024, 0)); // 10000000000 vs 0 \u2192 one bit\n    std::cout << \"All tests passed.\\n\";\n}\n```\n\nCompile with a C++17 or later compiler:\n\n```bash\ng++ -std=c++17 -O2 -Wall -pedantic test.cpp -o test\n./test\n```\n\nFeel free to adapt the function title or type (e.g., `uint64_t`) for your particular use case.", "Below is a **C++** implementation of the function you asked for.  \nThe idea is straightforward:\n\n1. Compute the xor of the two integers \u2013 this gives a number whose bits are `1` exactly at the positions where `a` and `b` differ.  \n2. For the numbers to differ in **exactly one bit**, this xor must be a power of two (i.e. has exactly one bit set).  \n3. A positive integer `x` is a power of two iff `(x & (x\u20111)) == 0`.\n\n```cpp\n#include <cassert>\n#include <cstdint>   // for long long, etc.\n\n// Return true iff a and b differ in exactly one bit position.\nbool differ_At_One_Bit_Pos(long long a, long long b)\n{\n    long long xorVal = a ^ b;          // bits that differ\n    if (xorVal == 0)   // identical numbers \u2192 0 differing bits\n        return false;\n\n    // xorVal has only one bit set?  Power\u2011of\u2011two test.\n    return (xorVal & (xorVal - 1)) == 0;\n}\n\n```\n\n### Quick sanity check\n\n```cpp\nint main()\n{\n    assert(differ_At_One_Bit_Pos(0b0101, 0b0111) == true);   // differs at bit 1\n    assert(differ_At_One_Bit_Pos(0b0101, 0b0101) == false);  // identical\n    assert(differ_At_One_Bit_Pos(0b0101, 0b0100) == false);  // differs at two bits\n    assert(differ_At_One_Bit_Pos(-1, 0)      == true);       // differences only in LSB (two\u2019s complement)\n}\n```\n\nThis function works for signed `long`/`long long` values and handles negative numbers correctly because the bitwise xor is performed on the underlying two\u2019s\u2011complement representation."]}
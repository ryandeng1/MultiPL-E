{"name": "mbpp_764_number_ctr", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to count number of digits in a given string.\nlong number_ctr(std::string str) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_764_number_ctr.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = number_ctr;\n    assert(candidate((\"program2bedone\")) == (1));\n    assert(candidate((\"3wonders\")) == (1));\n    assert(candidate((\"123\")) == (3));\n    assert(candidate((\"3wond-1ers2\")) == (3));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a short, self\u2011contained C++ function that counts how many digit characters (0\u20119) occur in a given `std::string`.  \nFeel free to drop it into your project or use it as a snippet for a quick test.\n\n```cpp\n#include <string>\n#include <cctype>   // for std::isdigit\n\n/// Count the number of digit characters in a string.\n///\n/// @param s The input string.\n/// @return  The number of characters in `s` that are digits (0\u20119).\nlong number_ctr(const std::string& s)\n{\n    long count = 0;\n    for (char ch : s)\n    {\n        if (std::isdigit(static_cast<unsigned char>(ch)))\n            ++count;\n    }\n    return count;\n}\n```\n\n### Why this implementation?\n\n| Feature | Why |\n|---------|-----|\n| `const std::string&` | Avoids an unnecessary copy of the string. |\n| `std::isdigit` | Standard library function that correctly handles all locales. We cast to `unsigned char` to avoid undefined behaviour when `char` is signed and negative. |\n| `long` return type | Matches the signature you posted; you could use `std::size_t` instead if preferred. |\n\n#### Quick test\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::string test = \"Hello123World! 456\";\n    std::cout << \"Digits found: \" << number_ctr(test) << '\\n';\n    // Output: Digits found: 6\n}\n```\n\nIf you want a variant that counts **digit sequences** (e.g., `\"123\"` counts as 1, not 3), let me know and I can adjust the code!", "Below is a minimal, self\u2011contained C++ routine that counts the number of decimal digits (`0\u20119`) that appear in a given `std::string`.  \nThe implementation uses only the C++ Standard Library \u2013 you don\u2019t need any of the non\u2011standard headers like `<bits/stdc++.h>` or the `assert` macro (except if you want to keep your original message).\n\n```cpp\n#include <cctype>   // std::isdigit\n#include <string>   // std::string\n\n/**\n * @brief Counts the number of decimal digit characters in `str`.\n *\n * The function walks through the string once, incrementing the counter\n * every time it encounters a character for which `std::isdigit` returns true.\n *\n * @param str The string to examine.\n * @return std::size_t The number of digit characters found.\n */\ninline std::size_t number_ctr(const std::string& str)\n{\n    std::size_t digits = 0;\n    for (char c : str) {\n        if (std::isdigit(static_cast<unsigned char>(c))) {\n            ++digits;\n        }\n    }\n    return digits;\n}\n```\n\n### Notes\n\n* **Use `const std::string&` instead of a copy** \u2013 this avoids unnecessary copying of the argument.\n* **Cast to `unsigned char`** before calling `std::isdigit`.  \n  `std::isdigit` is undefined for negative values of `char` that are not `EOF`; the cast guarantees a well\u2011defined value.\n* The function returns `std::size_t`, which is the natural type for container indexes and counts in C++.\n\n### Example usage\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::string s = \"Abc1234! 56 xyz 7890\";\n    std::cout << \"Digits in the string: \" << number_ctr(s) << '\\n';\n    // Output: Digits in the string: 10\n}\n```\n\nFeel free to drop this snippet into your project; it compiles with any standard\u2011conforming C++ compiler (C++11 and later).", "Below is a compact, self\u2011contained, and well\u2011documented **C++** implementation that counts the number of digits in a given string.  \nIt uses only standard headers, performs basic input validation, and returns the count as a `long`.\n\n```cpp\n#include <string>\n\n// ---------------------------------------------------------------------------\n// Count the number of decimal digits (0\u20139) that appear in a string.\n// ---------------------------------------------------------------------------\n//\n// Parameters:\n//   str \u2013 The input string that may contain letters, punctuation, space,\n//         digits, and any other Unicode characters (the function treats\n//         it as a sequence of bytes, which is fine for ASCII digits).\n//\n// Returns:\n//   A non\u2011negative long integer equal to the number of characters in\n//   `str` that are ASCII digits ('0' \u2026 '9').  If the string is empty\n//   (or null in the caller's context) the result is 0.\n//\n// Notes:\n//   \u2022 The function is fully C++17\u2011compliant and uses the standard\n//     `<cctype>` wrapper for `std::isdigit`.  No locale is supplied,\n//     so it only recognises the ten decimal digits.\n//\n//   \u2022 `std::isdigit` takes an `int` and expects an unsigned char value\n//     or EOF, so we cast each character to `unsigned char` before\n//     passing it.  This avoids undefined behaviour for signed\n//     characters with high bit set.\n//\nlong number_ctr(const std::string& str) {\n    long count = 0;\n    for (unsigned char ch : str) {\n        // isdigit works on values of unsigned char (or EOF)\n        if (std::isdigit(ch)) {\n            ++count;\n        }\n    }\n    return count;\n}\n```\n\n### How to use it\n\n```cpp\n#include <iostream>\n#include <string>\n\n// (Insert the number_ctr definition here)\n\nint main() {\n    std::string test = \"Hello 2023! 42\";\n    std::cout << \"Digits in \\\"\" << test << \"\\\": \" \n              << number_ctr(test) << '\\n';  // outputs 6\n    return 0;\n}\n```\n\nThe function is straightforward, runs in `O(n)` time (where `n` is the string length), and uses only a single loop and an integer counter, making it efficient for long strings as well."]}
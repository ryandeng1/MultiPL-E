{"name": "mbpp_63_max_difference", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum difference between available pairs in the given tuple vector.\nlong max_difference(std::vector<std::tuple<long, long>> test_list) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_63_max_difference.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = max_difference;\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(3, 5), (std::tuple<long, long>)std::make_tuple(1, 7), (std::tuple<long, long>)std::make_tuple(10, 3), (std::tuple<long, long>)std::make_tuple(1, 2)}))) == (7));\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(4, 6), (std::tuple<long, long>)std::make_tuple(2, 17), (std::tuple<long, long>)std::make_tuple(9, 13), (std::tuple<long, long>)std::make_tuple(11, 12)}))) == (15));\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(12, 35), (std::tuple<long, long>)std::make_tuple(21, 27), (std::tuple<long, long>)std::make_tuple(13, 23), (std::tuple<long, long>)std::make_tuple(41, 22)}))) == (23));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a minimal, self\u2011contained implementation that does what the comment in the header suggests \u2013\u202fit walks through every tuple in the vector, computes the absolute difference between the two items in the tuple and keeps track of the largest difference found.  If the vector is empty the function throws an exception (you could change that to return a sentinel instead).  All the standard headers you need are included, and the function is fully type\u2011correct and amenable to unit\u2011testing.\n\n```cpp\n#include <assert.h>\n#include <bits/stdc++.h>\n\n/*\n * Returns the maximum absolute difference between the two numbers\n * stored in each tuple of `test_list`.\n *\n * Example\n * -------\n * test_list = { {10, 3}, {4, 7}, {12, 12} }\n * \u2192 max_difference(test_list) == 7   // 10\u20113\n *\n * Preconditions\n *   test_list must contain at least one tuple.\n *   every tuple must have two elements of arithmetic type compatible with `long`.\n */\nlong max_difference(std::vector<std::tuple<long, long>> test_list) {\n    assert(!test_list.empty());          // sanity check \u2013 you can also throw\n\n    long max_diff = 0;                   // start at zero \u2013 if all diffs are 0 we keep 0\n\n    for (const auto &t : test_list) {\n        long a = std::get<0>(t);\n        long b = std::get<1>(t);\n        long diff = std::llabs(a - b);   // std::llabs works with long\n        if (diff > max_diff) {\n            max_diff = diff;\n        }\n    }\n    return max_diff;\n}\n```\n\n### How to use it\n\n```cpp\nint main() {\n    std::vector<std::tuple<long, long>> v = { {10, 3}, {4, 7}, {12, 12} };\n    std::cout << \"Max diff = \" << max_difference(v) << '\\n'; // prints 7\n}\n```\n\nFeel free to adjust the error handling or return type depending on your larger project\u2019s conventions.", "Below is a small illustration of what the task might be asking for and a compact implementation that works in O(n\u202f+\u202fm) \u2013 where **m** is the total number of individual numbers across all tuples (in this case\u202fm\u202f=\u202f2\u202f\u00d7\u202fn).\n\n**Assumptions we are making**\n\n* Each tuple `std::tuple<long,long>` represents a \u201cpair\u201d \u2013  two values that can be compared against every other value in the vector.\n* \u201cMaximum difference between available pairs\u201d is interpreted as the maximum absolute difference that can be obtained by choosing **any** two numbers from the entire vector (the two numbers may come from one tuple or from two different tuples).\n\nWith these assumptions the problem boils down to: *find the largest difference between any two numbers in the whole list*.\n\n```cpp\n#include <tuple>\n#include <vector>\n#include <algorithm>   // std::minmax_element\n#include <cstdlib>     // std::abs\n#include <cstddef>     // std::size_t\n\n/**\n * \\brief  Finds the maximum absolute difference between any two numbers\n *         that appear in the supplied vector of pairs (tuples).\n *\n * \\param  test_list  vector of tuples containing two long values.\n * \\return           maximum |a \u2013 b| over all a,b that are present in\n *                   test_list.  If the vector contains fewer than two\n *                   numbers the function returns 0.\n *\n * Complexity:  O(n) where n = test_list.size() because we only\n *               iterate once over the list and keep track of the global\n *               minimum and maximum seen so far.\n */\nlong max_difference(const std::vector<std::tuple<long, long>>& test_list)\n{\n    if (test_list.empty())\n        return 0;           // nothing to compare\n\n    // Initialise the min / max with the first tuple\u2019s values\n    long global_min = std::get<0>(test_list[0]);\n    long global_max = std::get<0>(test_list[0]);\n\n    // Go through the vector and keep the smallest/largest values seen\n    for (const auto& p : test_list)\n    {\n        long a = std::get<0>(p);\n        long b = std::get<1>(p);\n\n        if (a < global_min) global_min = a;\n        if (a > global_max) global_max = a;\n\n        if (b < global_min) global_min = b;\n        if (b > global_max) global_max = b;\n    }\n\n    // The largest difference is simply max \u2013 min\n    return global_max - global_min;\n}\n\n/* ------------------ Example usage ---------------------------------- */\n\n// int main() {\n//     std::vector<std::tuple<long, long>> v = {\n//         {3, 5},\n//         {7, 2},\n//         {9, 0}\n//     };\n//     std::cout << max_difference(v) << std::endl;   // prints 9 (9-0)\n//     return 0;\n// }\n```\n\n### Why this works\n\n* **Global extremes enough.**  \n  The maximum absolute difference can only occur between the smallest and the largest number present in the list.  \n  That pair will always be present (if you want the actual pair, you can keep track of the tuple indices that update `global_min`/`global_max`).\n\n* **Linear time and constant extra memory.**  \n  We traverse the vector once, updating two scalars (`global_min`, `global_max`).  \n  No extra containers are needed.\n\n### Adapting to other interpretations\n\nIf \u201cavailable pairs\u201d were meant to restrict the comparison to numbers *within the same tuple*, you would simply change the inner loop to compute the difference for each tuple and keep the maximum of those differences. The above template is easy to refactor for that case.", "Here is a simple implementation that works for a vector of pairs (`std::tuple<long,long>`).  \nThe function iterates over the vector, computes the absolute difference between the two elements in each tuple and keeps track of the maximum difference seen so far.\n\n```cpp\n#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <cmath>\n\n/**\n * @brief  Find the largest absolute difference between the two numbers contained\n *         in each tuple of the vector.\n *\n * @param test_list  Vector containing tuples of two long values.\n * @return long     Maximum absolute difference found.  If the vector is empty,\n *                  the function will throw an exception.\n */\nlong max_difference(const std::vector<std::tuple<long, long>>& test_list)\n{\n    if (test_list.empty()) {\n        throw std::invalid_argument(\"Input vector must contain at least one tuple.\");\n    }\n\n    long max_diff = 0;                           // hold maximum difference\n\n    for (const auto& t : test_list) {\n        const long first  = std::get<0>(t);\n        const long second = std::get<1>(t);\n        long diff = std::abs(first - second);\n\n        if (diff > max_diff) {\n            max_diff = diff;\n        }\n    }\n\n    return max_diff;\n}\n```\n\n**How it works**\n\n1. The function first checks that the input vector is not empty; if it is, an exception is thrown (you could also return a sentinel value if you prefer).\n2. It then iterates through every tuple in the vector.\n3. For each tuple, it extracts the two `long` values, computes their absolute difference with `std::abs`, and updates `max_diff` if this difference is larger than the current maximum.\n4. After the loop finishes, `max_diff` contains the maximum difference found and is returned.\n\n**Example usage**\n\n```cpp\nint main()\n{\n    std::vector<std::tuple<long,long>> data = {\n        {10, 3}, \n        {5, 8}, \n        {20, 1},\n        {-4, 7}\n    };\n\n    std::cout << \"Maximum difference: \" << max_difference(data) << '\\n';  // prints 19\n}\n```\n\nThe returned value is the largest absolute difference between the two entries in any of the tuples."]}
{"name": "HumanEval_22_filter_integers", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_22_filter_integers.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = filter_integers;\n    assert(candidate((std::vector<std::any>())) == (std::vector<long>()));\n    assert(candidate((std::vector<std::any>({4, std::map<long,long>(), std::vector<long>(), 23.2f, 9, \"adasd\"}))) == (std::vector<long>({(long)4, (long)9})));\n    assert(candidate((std::vector<std::any>({3, \"c\", 3, 3, \"a\", \"b\"}))) == (std::vector<long>({(long)3, (long)3, (long)3})));\n}\n", "stop_tokens": ["\n}"], "completions": ["```cpp\n#include <vector>\n#include <any>\n#include <type_traits>\n\n/**\n * @brief   Return a new vector containing only the integer\u2013typed elements\n *          found in the input `values` vector.  All numeric integral types\n *          (`int`, `long`, `long long`, `unsigned int`, \u2026) are converted to\n *          `long`.  All non\u2011integral types are discarded.\n *\n * @param values a vector containing any type (`std::any`).\n * @return      a vector of `long` with the integer elements from `values`.\n */\nstd::vector<long> filter_integers(const std::vector<std::any>& values)\n{\n    std::vector<long> result;\n    result.reserve(values.size());     // worst\u2011case reserve\n\n    // Helper lambda that tries to cast to a specific integral type.\n    auto try_cast_to_int = [&result](const std::any& a)\n    {\n        // Use `any_cast` with a type that we want to try to extract.\n        // If the cast fails it throws `std::bad_any_cast`,\n        // which we catch and ignore.\n        try\n        {\n            // Each cast returns the value already; we convert to long.\n            result.push_back(static_cast<long>(std::any_cast<decltype(a)>(a)));\n        }\n        catch (const std::bad_any_cast&) {}\n    };\n\n    // The C++20 rules state that `std::any` receives the *exact*\n    // type that was inserted.  For the typical integer types\n    // we write a small macro to try each variant.\n#define TRY_INT_TYPE(T)                     \\\n    if (a.type() == typeid(T))              \\\n    {                                       \\\n        try { result.push_back(static_cast<long>(std::any_cast<T>(a))); } \\\n        catch (const std::bad_any_cast&) {} \\\n    }\n\n    for (const auto& a : values)\n    {\n        // First test for the most common builtin integer types.\n        TRY_INT_TYPE(int);\n        TRY_INT_TYPE(long);\n        TRY_INT_TYPE(long long);\n        TRY_INT_TYPE(unsigned int);\n        TRY_INT_TYPE(unsigned long);\n        TRY_INT_TYPE(unsigned long long);\n        // If the program uses `char` or `short` we can add them as well.\n        TRY_INT_TYPE(char);\n        TRY_INT_TYPE(short);\n        TRY_INT_TYPE(unsigned char);\n        TRY_INT_TYPE(unsigned short);\n\n        // Anything else (e.g. floating point, strings, containers, etc.)\n        // is ignored automatically because the `typeid` check fails.\n    }\n\n    return result;\n}\n```\n\n**Explanation**\n\n* `std::any` stores the exact type that was inserted, so to select only integers we check the type ID relative to each integral type we care about.\n* Each successful `any_cast` is wrapped in a `try/catch` block; if the cast fails a `std::bad_any_cast` exception is thrown and simply swallowed (the element is discarded).\n* All successful casts are converted to `long` and appended to the result vector.\n* If you have custom integer wrappers you can extend the list with additional `TRY_INT_TYPE` lines.\n\nThis implementation matches the behaviour illustrated in the two examples: only the pure integer values survive the filtering.", "Here\u2019s a straightforward, type\u2011safe implementation.  \nIt goes through each `std::any` element, checks whether it holds an integral type (any `int`, `long`, `short`, `unsigned`, \u2026) and, if so, converts that value to `long` before pushing it into the resulting vector.  \nAll the other elements (strings, floating\u2011point numbers, containers, etc.) are simply ignored.\n\n```cpp\n#include <any>\n#include <vector>\n#include <cstdint>\n#include <type_traits>\n\n// helper to test whether a type is an integral type we want to keep\ntemplate <typename T>\nconstexpr bool is_allowed_integral()\n{\n    return std::is_same_v<T, int>   ||\n           std::is_same_v<T, long>  ||\n           std::is_same_v<T, long long>||\n           std::is_same_v<T, short> ||\n           std::is_same_v<T, unsigned int>  ||\n           std::is_same_v<T, unsigned long> ||\n           std::is_same_v<T, unsigned long long> ||\n           std::is_same_v<T, unsigned short>;\n}\n\nstd::vector<long> filter_integers(std::vector<std::any> values)\n{\n    std::vector<long> result;\n\n    for (const auto& v : values)\n    {\n        // enumerate the integral types we accept\n        if (v.type() == typeid(int))          { result.push_back(std::any_cast<int>(v));          }\n        else if (v.type() == typeid(long))    { result.push_back(std::any_cast<long>(v));         }\n        else if (v.type() == typeid(long long)){ result.push_back(std::any_cast<long long>(v));    }\n        else if (v.type() == typeid(short))   { result.push_back(std::any_cast<short>(v));        }\n        else if (v.type() == typeid(unsigned))        { result.push_back(static_cast<long>(std::any_cast<unsigned>(v))); }\n        else if (v.type() == typeid(unsigned long))  { result.push_back(static_cast<long>(std::any_cast<unsigned long>(v))); }\n        else if (v.type() == typeid(unsigned long long)) {\n            result.push_back(static_cast<long>(std::any_cast<unsigned long long>(v)));\n        }\n        else if (v.type() == typeid(unsigned short)) {\n            result.push_back(static_cast<long>(std::any_cast<unsigned short>(v)));\n        }\n        // if the element was an integral type that we did not list above\n        // (for instance a custom integral class) it will simply be skipped.\n    }\n\n    return result;\n}\n```\n\n**Usage**\n\n```cpp\nint main()\n{\n    std::vector<std::any> vec{\n        std::string(\"a\"),\n        3.14f,\n        5\n    };\n\n    auto res = filter_integers(vec);   // res == {5}\n}\n```\n\nThe function keeps the code simple and deterministic: it relies on exact type comparisons, so no hidden casts or unexpected behaviours appear. If you repeatedly need to filter different integral types, you can factor out the repeated checks into a template helper or a polymorphic visitor, but for the purpose described the code above is concise and maintainable.", "Here is a small, **stand\u2011alone** implementation that satisfies the behaviour you described.  \nThe function iterates over the supplied `std::vector<std::any>`, extracts every value that can be represented as an integer and stores it (converted to `long`) into the output vector.\n\n```cpp\n#include <any>\n#include <vector>\n#include <type_traits>\n\n/* -------------------------------------------------------------\n   filter_integers\n   -------------------------------------------------------------\n   Take a vector of std::any and return a vector containing\n   only those elements that represent integers (any integral\n   type). All extracted values are converted to long.\n   -------------------------------------------------------------\n   Example\n   ------------------------------------ \n   std::vector<std::any> v = {1, 2.5, std::string(\"x\"), 7};\n   std::vector<long> r = filter_integers(v);\n   // r == {1, 7}\n   -------------------------------------------------------------\n*/\nstd::vector<long> filter_integers(const std::vector<std::any>& values)\n{\n    std::vector<long> result;\n\n    for (const auto& item : values)\n    {\n        // Try each integral type that std::any can hold\n        if (item.type() == typeid(short))\n            result.push_back(std::any_cast<short>(item));\n        else if (item.type() == typeid(unsigned short))\n            result.push_back(std::any_cast<unsigned short>(item));\n        else if (item.type() == typeid(int))\n            result.push_back(std::any_cast<int>(item));\n        else if (item.type() == typeid(unsigned int))\n            result.push_back(std::any_cast<unsigned int>(item));\n        else if (item.type() == typeid(long))\n            result.push_back(std::any_cast<long>(item));\n        else if (item.type() == typeid(unsigned long))\n            result.push_back(std::any_cast<unsigned long>(item));\n        else if (item.type() == typeid(long long))\n            result.push_back(std::any_cast<long long>(item));\n        else if (item.type() == typeid(unsigned long long))\n            result.push_back(std::any_cast<unsigned long long>(item));\n    }\n\n    return result;\n}\n```\n\n### How it works\n\n1. **Type checking** \u2013 We use `std::any::type()` to compare the stored type with each integral type that might appear in the vector.  \n2. **Casting & conversion** \u2013 If the types match, the value is extracted with `std::any_cast` and implicitly converted to `long`, which is then pushed into the result vector.\n\n### Why not a generic `std::visit`?\n\nWhile one could write a generic visitor that checks `std::is_integral_v<T>` on the fly, `std::any` does not provide a `visit`\u2011style overload that gives you the contained type. Because the set of possible types is known to us, a simple series of `if/else` statements keeps the code short and clear.\n\n### Usage\n\n```cpp\n#include <any>\n#include <iostream>\n\nint main()\n{\n    std::vector<std::any> vec = {1, 2.5, std::string(\"abc\"), 3, std::map<int,int>{}, std::vector<int>{}};\n    auto ints = filter_integers(vec);\n\n    for (auto v : ints) std::cout << v << ' ';\n    // Output: 1 3\n}\n```\n\nThis implementation matches the examples you provided:\n\n```cpp\nstd::vector<std::any> a = {\"a\", 3.14f, 5};\nauto res = filter_integers(a);          // res == {5}\n```\n\nFeel free to adapt the list of integral types if your environment supports other non\u2011standard integral types."]}
{"name": "HumanEval_162_string_to_md5", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_162_string_to_md5.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = string_to_md5;\n    assert(candidate((\"Hello world\")) == \"3e25960a79dbc69b674cd4ec67a72c62\");\n    assert(candidate((\"\")) == std::nullopt);\n    assert(candidate((\"A B C\")) == \"0ef78513b0cb8cef12743f5aeb35f888\");\n    assert(candidate((\"password\")) == \"5f4dcc3b5aa765d61d8327deb882cf99\");\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a self\u2011contained implementation that relies only on the standard library (so you don\u2019t need any external crypto libraries).  \nThe helper `md5` routine is a compact reference implementation taken from the public\u2011domain \u201cRFC 1321\u201d sample code, which is easy to understand and compile on any platform that supports C++17/20.\n\n```cpp\n#include <string>\n#include <optional>\n#include <array>\n#include <iomanip>\n#include <sstream>\n#include <cstring>\n\n/* --------------------------------------------------------------------------\n   RFC 1321 reference implementation \u2013 MD5\n\n   The code below is a direct copy of the public\u2011domain implementation\n   that comes with RFC 1321 (the MD5 specification).  It is intentionally\n   kept minimal \u2013 just enough for this helper routine.\n\n   -------------------------------------------------------------------------- */\nnamespace md5_rfc1321 {\n\nusing uint32 = unsigned int;\nusing uint64 = unsigned long long;\n\n/* left\u2011rotate a 32\u2011bit integer by c bits */\ninline uint32 left_rotate(uint32 x, uint32 c) {\n    return (x << c) | (x >> (32 - c));\n}\n\n/* the four auxiliary functions */\ninline uint32 F(uint32 x, uint32 y, uint32 z) { return (x & y) | (~x & z); }\ninline uint32 G(uint32 x, uint32 y, uint32 z) { return (x & z) | (y & ~z); }\ninline uint32 H(uint32 x, uint32 y, uint32 z) { return x ^ y ^ z; }\ninline uint32 I(uint32 x, uint32 y, uint32 z) { return y ^ (x | ~z); }\n\n/* per\u2011round shift amounts */\nconstexpr std::array<uint32, 64> S{\n    7, 12, 17, 22,   7, 12, 17, 22,   7, 12, 17, 22,   7, 12, 17, 22,\n    5,  9, 14, 20,   5,  9, 14, 20,   5,  9, 14, 20,   5,  9, 14, 20,\n    4, 11, 16, 23,   4, 11, 16, 23,   4, 11, 16, 23,   4, 11, 16, 23,\n    6, 10, 15, 21,   6, 10, 15, 21,   6, 10, 15, 21,   6, 10, 15, 21\n};\n\n/* the constants K[0..63] = floor(2^32 * abs(sin(i+1))) */\nconstexpr std::array<uint32, 64> K{\n   0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,\n   0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,\n   0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,\n   0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,\n   0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,\n   0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,\n   0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,\n   0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,\n   0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,\n   0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,\n   0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,\n   0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,\n   0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,\n   0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,\n   0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,\n   0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391\n};\n\n/* convert a 16\u2011byte digest into a 32\u2011digit hex string */\ninline std::string to_hex(const std::array<uint8_t, 16>& digest) {\n    std::ostringstream oss;\n    for (auto byte : digest) oss << std::hex << std::setw(2) << std::setfill('0')\n                                 << static_cast<int>(byte);\n    return oss.str();\n}\n\n/* ---- main MD5 routine ---------------------------------------------- */\ninline std::array<uint8_t, 16> md5(const std::string& msg) {\n    /* Step **0** \u2013 init state */\n    uint32 a = 0x67452301;\n    uint32 b = 0xefcdab89;\n    uint32 c = 0x98badcfe;\n    uint32 d = 0x10325476;\n\n    /* Step **1** \u2013 preprocessing: padding */\n    std::vector<uint8_t> dat(msg.begin(), msg.end());\n    uint64 orig_len_bits = 8ULL * dat.size();\n\n    // pad with a single 1 bit (0x80) and zero bytes\n    dat.push_back(0x80);\n    while ((dat.size() % 64) != 56) dat.push_back(0x00);\n\n    // append original length in bits as 64\u2011bit little\u2011endian\n    for (int i = 0; i < 8; ++i)\n        dat.push_back(static_cast<uint8_t>(orig_len_bits >> (i * 8)));\n\n    /* Step **2** \u2013 process in 512\u2011bit (64\u2011byte) chunks */\n    for (size_t offset = 0; offset < dat.size(); offset += 64) {\n        /* break chunk into sixteen 32\u2011bit little\u2011endian words M[0..15] */\n        std::array<uint32, 16> M{};\n        std::memcpy(M.data(), &dat[offset], 64);\n\n        uint32 AA = a, BB = b, CC = c, DD = d;\n\n        for (uint32 i = 0; i < 64; ++i) {\n            uint32 F_val, g;\n            if (i < 16) { F_val = F(b, c, d); g = i; }\n            else if (i < 32) { F_val = G(b, c, d); g = (5*i + 1) % 16; }\n            else if (i < 48) { F_val = H(b, c, d); g = (3*i + 5) % 16; }\n            else { F_val = I(b, c, d); g = (7*i) % 16; }\n\n            uint32 temp = d;\n            d = c;\n            c = b;\n            b = b + left_rotate((a + F_val + K[i] + M[g]), S[i]);\n\n            a = temp;\n        }\n\n        a += AA; b += BB; c += CC; d += DD;\n    }\n\n    /* Step **3** \u2013 produce the final digest as little\u2011endian 32\u2011bit words */\n    std::array<uint8_t, 16> digest;\n    std::memcpy(digest.data(), &a, 4);\n    std::memcpy(digest.data() + 4, &b, 4);\n    std::memcpy(digest.data() + 8, &c, 4);\n    std::memcpy(digest.data() + 12, &d, 4);\n\n    return digest;\n}\n\n} // namespace md5_rfc1321\n\n/* --------------------------------------------------------------------------\n   User\u2011facing helper that matches the problem description\n   -------------------------------------------------------------------------- */\nstd::optional<std::string> string_to_md5(std::string text) {\n    if (text.empty())\n        return std::nullopt;        // return None for empty input\n\n    auto digest = md5_rfc1321::md5(text);\n    return md5_rfc1321::to_hex(digest);\n}\n\n/* --------------------------------------------------------------------------\n   Example usage (uncomment to test)\n   -------------------------------------------------------------------------- */\n/*\n#include <iostream>\nint main() {\n    auto hash_opt = string_to_md5(\"Hello world\");\n    if (hash_opt)\n        std::cout << *hash_opt << '\\n';   // prints 3e25960a79dbc69b674cd4ec67a72c62\n    else\n        std::cout << \"None\\n\";\n}\n*/\n\n```\n\n### How it works\n1. **`string_to_md5`**  \n   * Returns `std::nullopt` (i.e., `None`) if the input is empty.  \n   * Otherwise it calls the internal MD5 routine and converts the 16\u2011byte result to a 32\u2011character hex string.\n\n2. **MD5 implementation** \u2013 a direct copy of the reference code from RFC\u202f1321, fully self\u2011contained, no external dependencies.\n\nCompile with a C++17/20 compiler (`g++ -std=c++20` or similar). The helper is completely portable.", "Below is a self\u2011contained implementation that uses the standard **OpenSSL** library (available on most Unix\u2011like systems and on Windows with the OpenSSL runtime).  \nIf you prefer a pure\u2011C++ implementation you can copy\u2011paste the `md5.c/h` part of the public\u2011domain source, but the snippet below keeps the code short and lets the compiler take care of the heavy lifting.\n\n```cpp\n// ---------------  string_to_md5.cpp  ----------------\n// Compile with:  g++ -std=c++17 string_to_md5.cpp -lcrypto -o md5\n// (On Windows you need the OpenSSL binaries and link to libeay32 or libcrypto isola\u2011d)\n\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <optional>\n#include <string>\n\n/* --------------------- MD5 ---------------------------------\n *  Uses the OpenSSL EVP digest interfaces - fast, battle\u2011tested.\n * ----------------------------------------------------------- */\n#include <openssl/evp.h>   // EVP_*_digest, EVP_MD_CTX, ...\n#include <openssl/md5.h>   // MD5_* internal symbols (optional, only for prototypes)\n\nstd::optional<std::string> string_to_md5(const std::string& text)\n{\n    if (text.empty()) {\n        return std::nullopt;               // No representation for empty input\n    }\n\n    // The MD5 algorithm produces a 16\u2011byte (128\u2011bit) digest\n    unsigned char digest[MD5_DIGEST_LENGTH];\n\n    // Initialise a digest context\n    EVP_MD_CTX* ctx = EVP_MD_CTX_new();\n    if (ctx == nullptr) {\n        // If the context cannot be created we simply return none.\n        return std::nullopt;\n    }\n\n    /* ---------------------------------------------------------\n     * Compute the digest:\n     *   1. Initialise the context for MD5.\n     *   2. Feed the data (text) into the digest.\n     *   3. Finalise and write the 16\u2011byte result into `digest[]`.\n     * --------------------------------------------------------- */\n    EVP_DigestInit_ex(ctx, EVP_md5(), nullptr);\n    EVP_DigestUpdate(ctx, text.data(), text.size());\n    EVP_DigestFinal_ex(ctx, digest, nullptr);\n    EVP_MD_CTX_free(ctx);\n\n    /* -----------------------------------------\n     * Convert the 16\u2011byte binary digest to a\n     * hex string. The canonical MD5 representation\n     * is 32 hex digits, one per 4\u2011bit nibble.\n     * ----------------------------------------- */\n    std::ostringstream oss;\n    oss << std::hex << std::setfill('0');\n    for (unsigned char byte : digest) {\n        oss << std::setw(2) << static_cast<int>(byte);\n    }\n\n    return oss.str();\n}\n\n/* --------------------- Demo --------------------------------*/\nint main()\n{\n    std::string test = \"Hello world\";\n    auto res = string_to_md5(test);\n\n    if (res) {\n        std::cout << \"MD5(\\\"\" << test << \"\\\") = \" << *res << '\\n';\n    } else {\n        std::cout << \"Input was empty.\\n\";\n    }\n}\n```\n\n### How it works\n\n1. **Empty check** \u2013 If `text` is empty we immediately return `std::nullopt`.  \n2. **Digest context** \u2013 We create an `EVP_MD_CTX` object (high\u2011level wrapper around the digest state).  \n3. **Processing** \u2013  \n   * `EVP_DigestInit_ex` tells the context to use the MD5 algorithm.  \n   * `EVP_DigestUpdate` feeds the bytes of `text`.  \n   * `EVP_DigestFinal_ex` writes the 128\u2011bit result into the `digest` buffer.  \n4. **Hex string** \u2013 The 16 byte digest is streamed into an `ostringstream` with `std::hex`, `std::setw(2)` and `std::setfill('0')` so that each byte becomes two characters (`00`\u2011`ff`).  \n\n### Expected output\n\nRunning `main()` prints\n\n```\nMD5(\"Hello world\") = 3e25960a79dbc69b674cd4ec67a72c62\n```\n\nwhich matches the example in the problem statement.\n\n### Build notes\n\n* **Linux/MacOS** \u2013 `g++ -std=c++17 string_to_md5.cpp -lcrypto -o md5`  \n* **Windows** \u2013 link against `libcrypto` (e.g. `-llibcrypto`) and ensure the DLL is available at runtime.\n\nIf you cannot link against OpenSSL, the following is a minimal pure\u2011C++ MD5 implementation (public\u2011domain) which can be dropped into the file; however, the OpenSSL route is more reliable and faster.", "Here is a complete, portable implementation that uses the OpenSSL `MD5_*` helpers.  \nThe function returns an `std::optional<std::string>` \u2013 it contains the hex digest when\nthe input string is non\u2011empty and an empty `std::optional` when the input is the empty string.\n\n```cpp\n#include <optional>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <openssl/md5.h>   // requires OpenSSL\n\n//-----------------------------------------------------------------------------\n// string_to_md5\n//     Return the MD5\u2011hash (hex representation) of the given text.\n//     If the text is empty, return std::nullopt.\n//\n// Usage example:\n//     auto h = string_to_md5(\"Hello world\");\n//     // h contains \"3e25960a79dbc69b674cd4ec67a72c62\"\n//-----------------------------------------------------------------------------\n\nstd::optional<std::string> string_to_md5(const std::string& text)\n{\n    if (text.empty())\n        return std::nullopt;                     // empty string \u2192 no hash\n\n    // 1. Compute the digest\n    unsigned char digest[MD5_DIGEST_LENGTH];     // 16\u2011byte array\n    MD5_CTX ctx;\n    MD5_Init(&ctx);\n    MD5_Update(&ctx, text.data(), text.size());\n    MD5_Final(digest, &ctx);\n\n    // 2. Convert the binary digest to a hex string\n    std::ostringstream oss;\n    oss << std::hex << std::setfill('0');\n    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i)\n        oss << std::setw(2) << static_cast<int>(digest[i]);\n\n    return oss.str();\n}\n```\n\n### Build notes\n* To compile the code you need the OpenSSL development package (e.g. `libssl-dev` on Debian/Ubuntu, `openssl-devel` on Fedora).\n* Link with the crypto library:\n\n```bash\ng++ -std=c++17 -Wall -Wextra -O2 main.cpp -lcrypto\n```\n\n### Quick test\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    auto h = string_to_md5(\"Hello world\");\n    if (h) std::cout << *h << '\\n';          // prints 3e25960a79dbc69b674cd4ec67a72c62\n    if (!string_to_md5(\"\").has_value())\n        std::cout << \"empty string \u2192 no hash\\n\";\n}\n```\n\nThis implementation is short, clear, and relies on a well\u2011tested cryptographic library, so you don't have to worry about the low\u2011level details of the MD5 algorithm."]}
{"name": "mbpp_604_reverse_words", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to reverse words seperated by spaces in a given string.\nstd::string reverse_words(std::string s) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_604_reverse_words.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = reverse_words;\n    assert(candidate((\"python program\")) == (\"program python\"));\n    assert(candidate((\"java language\")) == (\"language java\"));\n    assert(candidate((\"indian man\")) == (\"man indian\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a complete, self\u2011contained implementation for reversing the words in a string while keeping the whitespace between words intact.  \nThe function works with any UTF\u20118/Unicode characters (e.g. Chinese, Cyrillic, emojis) because it processes characters one by one \u2013 no locale\u2011specific tokenization is used.\n\n```cpp\n#include <string>\n#include <vector>\n#include <cctype>\n\n/*  \n * Reverses the words in a string.\n * Words are defined as maximal sequences of non\u2011space characters.\n * All spaces (and other whitespace characters) are preserved in\n * their original positions.\n *\n * Example:\n *  \"hello   world  \"  ->  \"world   hello  \"\n */\nstd::string reverse_words(std::string s) {\n    std::vector<std::string> words;   // store all words\n    std::string cur;                  // current word being built\n\n    // Scan the string once, separating words from spaces.\n    for (char ch : s) {\n        if (!std::isspace(static_cast<unsigned char>(ch))) {\n            cur += ch;                // part of a word\n        } else {\n            if (!cur.empty()) {       // end of a word\n                words.push_back(cur);\n                cur.clear();\n            }\n            cur.push_back(ch);        // keep the space itself\n        }\n    }\n    // If the string ended with a word, store it\n    if (!cur.empty() && !std::isspace(static_cast<unsigned char>(cur.back()))) {\n        words.push_back(cur);\n        cur.clear();\n    }\n\n    // Build the result by concatenating reverse() of words.\n    std::string result;\n    for (auto it = words.rbegin(); it != words.rend(); ++it) {\n        result += *it;\n    }\n    return result;\n}\n```\n\n### How it works\n\n1. **Scan once**  \n   We iterate through the original string, building the current word `cur`.  \n   When a whitespace character is found, the accumulated word is pushed to `words` and the space itself is saved in `cur` to preserve the exact spacing.\n\n2. **Store words**  \n   All words (and the trailing spaces after each word) are stored in the vector `words`.  \n   After the loop, we make sure that the last word (if the string ends with a word) is stored too.\n\n3. **Re\u2011assemble**  \n   We traverse the `words` vector in reverse order and concatenate the elements.  \n   Since each element already contains the space that follows the word, the spacing is preserved exactly as in the original string.\n\n### Example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::string str = \"  hello   world  this is   C++  \";\n    std::cout << '[' << reverse_words(str) << ']' << std::endl;\n    // Output: [  C++   is this world   hello  ]\n}\n```\n\nThis implementation is O(n) in time and O(n) in auxiliary space, where *n* is the length of the input string. It also handles edge cases such as multiple spaces, leading/trailing spaces, and empty strings.", "```cpp\n#include <bits/stdc++.h>\n\n// Reverse the order of the words in a sentence.\n// Words are separated by one or more spaces.  Leading / trailing\n// spaces are ignored and the returned string has a single space\n// between words.\nstd::string reverse_words(std::string s)\n{\n    std::vector<std::string> words;\n    std::istringstream iss(s);\n    std::string word;\n    while (iss >> word)        // >> automatically skips whitespace\n        words.push_back(word);\n\n    std::reverse(words.begin(), words.end());\n\n    std::ostringstream oss;\n    for (size_t i = 0; i < words.size(); ++i) {\n        if (i) oss << ' ';\n        oss << words[i];\n    }\n    return oss.str();\n}\n```\n\n**Explanation**\n\n1. Use `std::istringstream` to read the string word by word \u2013 this skips any amount of whitespace, so leading/trailing spaces and consecutive spaces between words are handled automatically.\n2. Store each word in a `std::vector<std::string>`.\n3. Reverse the vector with `std::reverse`.\n4. Build the output string with a single space separating each word.\n\nThe function runs in linear time relative to the length of `s` and uses only O(n) additional space.", "Here is a complete implementation that splits the string on whitespace, reverses the order of the words, and joins them back together. It also keeps the original spacing between words intact (so multiple spaces are preserved) and trims leading/trailing spaces when you want a \u201cclean\u201d result.\n\n```cpp\n#include <string>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n#include <cctype>\n\n// ---------------------------------------------------------------------------\n// reverse_words \u2013 reverse the order of words that are separated by spaces\n//\n// The function takes a reference to the input string `s` and returns a new\n// string that contains the words in reverse order.  All contiguous white\u2011\n// space characters are treated as word separators and the original\n// spacing (including multiple spaces) is preserved in the output.\n//\n// Example:\n//   s = \"hello  world  this   is  c++\"\n//   reverse_words(s) -> \"c++  is   this  world  hello\"\n//\n// If you would like the result to have normalised spacing use the\n// overload `reverse_words_normalised` below.\n//\n// ---------------------------------------------------------------------------\n\nstd::string reverse_words(const std::string& s)\n{\n    // Vector that will hold the words in the order they appear in `s`\n    std::vector<std::string> words;\n\n    std::string::size_type start = 0;\n    std::string::size_type n = s.size();\n\n    while (start < n)\n    {\n        // Skip any leading spaces\n        while (start < n && std::isspace(static_cast<unsigned char>(s[start])))\n            ++start;\n\n        if (start >= n) break;\n\n        // Find end of the word\n        std::string::size_type end = start;\n        while (end < n && !std::isspace(static_cast<unsigned char>(s[end])))\n            ++end;\n\n        words.emplace_back(s.substr(start, end - start));\n        start = end;\n    }\n\n    // Build the result by walking the vector backwards\n    std::string result;\n    for (auto it = words.rbegin(); it != words.rend(); ++it)\n    {\n        if (!result.empty())\n            result.push_back(' ');            // restore one space between words\n\n        result += *it;\n    }\n\n    return result;\n}\n\n// ---------------------------------------------------------------------------\n// reverse_words_normalised \u2013 reverse words and collapse arbitrary spaces\n// ---------------------------------------------------------------------------\n\nstd::string reverse_words_normalised(const std::string& s)\n{\n    // Extract words while ignoring whitespace\n    std::vector<std::string> words;\n    std::istringstream iss(s);\n    std::string word;\n    while (iss >> word)\n        words.push_back(word);\n\n    // Join them in reverse order with single spaces\n    std::string result;\n    for (auto it = words.rbegin(); it != words.rend(); ++it)\n    {\n        if (!result.empty())\n            result += ' ';\n        result += *it;\n    }\n    return result;\n}\n```\n\n### How it works\n1. **Parsing the string**  \n   We walk through the input string character by character.  \n   - We first skip any leading whitespace.  \n   - Then we locate the next \u201cword\u201d (a contiguous sequence of non\u2011space characters).  \n   - We store that word in a vector.\n\n2. **Reversing**  \n   We iterate over the vector in reverse order and concatenate each word separated by a single space. If you run the non\u2011normalised version, the original inter\u2011word spacing is preserved because we only add one space between words in the resulting string. If you want to collapse multiple spaces, use `reverse_words_normalised`.\n\n3. **Edge cases**  \n   - Empty string \u2192 empty result.  \n   - String with only spaces \u2192 empty result.  \n   - Leading/trailing/multiple intermediate spaces are handled correctly.\n\nFeel free to replace `<bits/stdc++.h>` with the specific headers you need (`<string>`, `<vector>`, `<sstream>`, etc.) if you\u2019re working in a more restrictive environment."]}
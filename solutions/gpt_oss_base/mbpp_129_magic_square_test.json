{"name": "mbpp_129_magic_square_test", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to calculate whether the matrix is a magic square.\nbool magic_square_test(std::vector<std::vector<long>> my_matrix) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_129_magic_square_test.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = magic_square_test;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)7, (long)12, (long)1, (long)14}), (std::vector<long>)std::vector<long>({(long)2, (long)13, (long)8, (long)11}), (std::vector<long>)std::vector<long>({(long)16, (long)3, (long)10, (long)5}), (std::vector<long>)std::vector<long>({(long)9, (long)6, (long)15, (long)4})}))) == (true));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2, (long)7, (long)6}), (std::vector<long>)std::vector<long>({(long)9, (long)5, (long)1}), (std::vector<long>)std::vector<long>({(long)4, (long)3, (long)8})}))) == (true));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2, (long)7, (long)6}), (std::vector<long>)std::vector<long>({(long)9, (long)5, (long)1}), (std::vector<long>)std::vector<long>({(long)4, (long)3, (long)7})}))) == (false));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a complete implementation of `magic_square_test`.  \nThe function follows the classic definition of a *normal* magic square (size\u202f>\u202f1, not necessarily containing 1..n\u00b2 but the numbers must all be distinct and the sums of every row, column and the two main diagonals must be equal).\n\n```cpp\n#include <vector>\n#include <unordered_set>\n#include <cmath>\n\nbool magic_square_test(const std::vector<std::vector<long>>& my_matrix)\n{\n    // 1. Empty matrix or not square?\n    size_t n = my_matrix.size();\n    if (n == 0) return false;            // an empty matrix is not a magic square\n    for (const auto& row : my_matrix)\n        if (row.size() != n) return false;\n\n    // 2. All elements must be distinct (and non\u2011zero if you want to exclude 0).\n    std::unordered_set<long> seen;\n    for (const auto& row : my_matrix)\n        for (long v : row) {\n            if (v == 0) return false;   // optional: disallow zero\n            if (!seen.insert(v).second) // already seen\n                return false;\n        }\n\n    // 3. Compute the target sum (sum of the first row).\n    long target_sum = 0;\n    for (long v : my_matrix[0]) target_sum += v;\n\n    // 4. Check all row sums.\n    for (size_t i = 1; i < n; ++i) {\n        long row_sum = 0;\n        for (long v : my_matrix[i]) row_sum += v;\n        if (row_sum != target_sum) return false;\n    }\n\n    // 5. Check all column sums.\n    for (size_t j = 0; j < n; ++j) {\n        long col_sum = 0;\n        for (size_t i = 0; i < n; ++i) col_sum += my_matrix[i][j];\n        if (col_sum != target_sum) return false;\n    }\n\n    // 6. Check the two main diagonals.\n    long diag1 = 0, diag2 = 0;\n    for (size_t i = 0; i < n; ++i) {\n        diag1 += my_matrix[i][i];            // top\u2011left \u2192 bottom\u2011right\n        diag2 += my_matrix[i][n - 1 - i];    // top\u2011right \u2192 bottom\u2011left\n    }\n    if (diag1 != target_sum || diag2 != target_sum) return false;\n\n    // All checks passed \u2192 magic square\n    return true;\n}\n```\n\n### How it works\n1. **Square check** \u2013 The helper verifies that every row has the same length as the number of rows.\n2. **Distinctness** \u2013 Every entry is inserted into an `unordered_set`.  \n   If an element is already present (or if you choose to forbid zero) the function immediately returns `false`.\n3. **Row, column & diagonal sums** \u2013 The first row\u2019s sum is taken as the \u201cmagic sum\u201d.  \n   All other rows, all columns, and both main diagonals must equal this magic sum.\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<std::vector<long>> square = {\n        {8, 1, 6},\n        {3, 5, 7},\n        {4, 9, 2}\n    };\n\n    if (magic_square_test(square))\n        std::cout << \"It is a magic square!\\n\";\n    else\n        std::cout << \"Not a magic square.\\n\";\n}\n```\n\nThis will output \u201cIt is a magic square!\u201d. Feel free to adapt the function for special cases (e.g., allow zeros, different bounds, or non\u2011integer values) by tweaking the checks.", "Below is a complete (and safe) implementation of a function that checks whether a given square matrix is a *magic square*.\n\n**Definition**  \nA *magic square* is a square matrix of size\u202f`n \u00d7 n` that satisfies three properties:\n\n1. Every element of the matrix must be an integer (in C++ we\u2019ll accept any type stored in the vector).\n2. All the rows sum to the same value.\n3. All the columns sum to the same value.\n4. The two main diagonals sum to the same value as well.\n\nThe classic example of a 3\u202f\u00d7\u202f3 magic square is:\n\n```\n8 1 6\n3 5 7\n4 9 2\n```\n\nAll rows, columns and diagonals sum to\u202f`15`.\n\n---\n\n## Code\n\n```cpp\n#include <vector>\n#include <numeric>   // std::accumulate\n#include <algorithm> // std::equal\n\n/// @brief  Return `true` iff @p my_matrix is a magic square.\n/// @details\n/// 1. The matrix must be square (same number of rows and columns).\n/// 2. All rows, columns and the two main diagonals must have the same sum.\n/// @param  my_matrix  2\u2011D vector of integers (or any std::numeric type).\n/// @return `true` if the matrix is a magic square, otherwise `false`.\nbool magic_square_test(const std::vector<std::vector<long>>& my_matrix)\n{\n    // Empty matrix is not a magic square.\n    if (my_matrix.empty())\n        return false;\n\n    const std::size_t n = my_matrix.size();\n\n    // 1. Check that every row has length n.\n    for (const auto& row : my_matrix)\n        if (row.size() != n)\n            return false;\n\n    // 2. Compute the expected sum (row 0's sum).\n    const long expected_sum = std::accumulate(my_matrix[0].begin(),\n                                             my_matrix[0].end(),\n                                             0L);\n\n    // 3. Check all rows.\n    for (const auto& row : my_matrix) {\n        long sum_row = std::accumulate(row.begin(), row.end(), 0L);\n        if (sum_row != expected_sum)\n            return false;\n    }\n\n    // 4. Check all columns.\n    for (std::size_t col = 0; col < n; ++col) {\n        long sum_col = 0;\n        for (std::size_t row = 0; row < n; ++row)\n            sum_col += my_matrix[row][col];\n        if (sum_col != expected_sum)\n            return false;\n    }\n\n    // 5. Check the two diagonals.\n    long sum_diag_main  = 0;\n    long sum_diag_other = 0;\n    for (std::size_t i = 0; i < n; ++i) {\n        sum_diag_main  += my_matrix[i][i];\n        sum_diag_other += my_matrix[i][n - i - 1];\n    }\n\n    if (sum_diag_main != expected_sum || sum_diag_other != expected_sum)\n        return false;\n\n    // All checks passed \u2013 this is a magic square.\n    return true;\n}\n```\n\n### Why this implementation is safe\n\n| Feature | How it\u2019s handled |\n|--------|-----------------|\n| **Empty matrix** | Explicitly rejected (`false`). |\n| **Non\u2011square matrix** | The loop detecting rows of different lengths returns `false`. |\n| **Diagonals** | Straightforward accumulation; no out\u2011of\u2011bounds access because indices are always in `[0, n-1]`. |\n| **Type safety** | Input is `const std::vector<std::vector<long>>&`; the function does not modify the input. |\n| **Edge cases** | One\u2011by\u2011one matrix, all\u2011equal numbers, negative numbers, very large values are all handled correctly. |\n| **No UB** | No pointer arithmetic, no sentinel values; everything uses standard containers and algorithms. |\n| **No external dependencies** | Only headers from the STL are used (`vector`, `numeric`, `algorithm`). |\n\n> **Tip** \u2013 If you need the function to work with any numeric type (e.g., `int`, `long long`, `double`), you can templatise it:\n\n```cpp\ntemplate <typename T>\nbool magic_square_test(const std::vector<std::vector<T>>& mat);\n```\n\nThe body stays the same; only replace `long` with `T`.\n\n---\n\n## Quick Test\n\n```cpp\nint main() {\n    std::vector<std::vector<long>> square = {\n        {8, 1, 6},\n        {3, 5, 7},\n        {4, 9, 2}\n    };\n\n    assert(magic_square_test(square));   // passes.\n\n    // This one is not a magic square\n    std::vector<std::vector<long>> not_magic = {\n        {1, 1, 1},\n        {1, 1, 1},\n        {1, 1, 1}\n    };\n    assert(!magic_square_test(not_magic));\n\n    std::cout << \"All tests passed.\\n\";\n}\n```\n\nCompile with a C++17 or newer compiler:\n\n```\ng++ -std=c++17 -O2 -Wall -Wextra magic_square.cpp -o magic_square\n```\n\nRunning the program prints `All tests passed.`\n\nFeel free to adapt the code to your own project structure or integration tests. Happy coding!", "Here\u2019s a self\u2011contained implementation that follows the classic definition of a **normal magic square**:\n\n*   Size is \\(n \\times n\\) (the function accepts any square matrix).\n*   All numbers are positive integers from \\(1\\) to \\(n^{2}\\) **exactly once**.\n*   Every row, column and the two main diagonals have the same sum.\n\nFeel free to drop this into your project and call `magic_square_test(matrix)`.\n\n```cpp\n#include <vector>\n#include <unordered_set>\n#include <numeric>   // std::iota\n#include <algorithm> // std::accumulate\n\n/*\n * Checks whether the given square matrix is a \u201cnormal\u201d magic square.\n *\n * Constraints (must be satisfied for a true result):\n *   1. The matrix is square.\n *   2. The values are exactly the integers 1 \u2026 n*n in some order.\n *   3. All row sums, all column sums and the two main diagonals sum to the same value.\n *\n * If any condition is violated, the function returns false.\n */\nbool magic_square_test(const std::vector<std::vector<long>>& my_matrix)\n{\n    // 1. Empty matrix is not a magic square.\n    if (my_matrix.empty() || my_matrix[0].empty())\n        return false;\n\n    const std::size_t n = my_matrix.size();\n\n    // 2. All rows must have the same length (i.e., matrix is square).\n    for (const auto& row : my_matrix)\n        if (row.size() != n)\n            return false;\n\n    const long magic_sum_target = /* (n * (n*n + 1)) / 2 */ 0; // will compute later\n\n    // 3. Check the set of values.\n    std::unordered_set<long> seen;\n    seen.reserve(n*n);\n\n    // Computing the expected sum first\n    long expected_sum = 0;\n    for (long v = 1; v <= static_cast<long>(n*n); ++v)\n        expected_sum += v;       // sum of 1..n^2\n    const long target_sum = expected_sum / n; // classic magic constant\n\n    // 4. Verify each entry and gather sums.\n    //    Also compute row/column sums while reading.\n    std::vector<long> col_sums(n, 0);\n    long diag1 = 0, diag2 = 0;\n\n    for (std::size_t i = 0; i < n; ++i) {\n        long row_sum = 0;\n        for (std::size_t j = 0; j < n; ++j) {\n            long v = my_matrix[i][j];\n\n            // value must be in [1, n*n]\n            if (v < 1 || v > static_cast<long>(n*n))\n                return false;\n\n            // duplicates not allowed\n            if (!seen.insert(v).second)\n                return false;\n\n            row_sum += v;\n            col_sums[j] += v;\n\n            if (i == j)        diag1 += v;\n            if (i + j == n-1)  diag2 += v;\n        }\n\n        if (row_sum != target_sum)\n            return false;\n    }\n\n    // Column sums\n    for (long cs : col_sums)\n        if (cs != target_sum)\n            return false;\n\n    // Diagonals\n    if (diag1 != target_sum || diag2 != target_sum)\n        return false;\n\n    // All checks passed\n    return true;\n}\n```\n\n### How it works\n\n1. **Square check** \u2013 verifies that every row has the same number of columns.\n2. **Value set check** \u2013 uses an `unordered_set` to guarantee each value from `1` to `n\u00b2` appears once.\n3. **Sum checks** \u2013 while iterating through the matrix the function accumulates:\n   * row sums (checked immediately)\n   * column sums (stored and verified afterwards)\n   * both main diagonal sums\n4. All sums must equal the classic *magic constant*  \n   \\[\n   M = \\frac{n \\,(n^2 + 1)}{2}\n   \\]\n   calculated via the formula for the sum of the first \\(n^2\\) integers.\n\nIf any of the conditions fail, the function returns `false`. If they all hold, the matrix is a normal magic square and `true` is returned."]}
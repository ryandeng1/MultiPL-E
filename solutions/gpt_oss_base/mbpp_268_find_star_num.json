{"name": "mbpp_268_find_star_num", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the n'th star number.\nlong find_star_num(long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_268_find_star_num.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = find_star_num;\n    assert(candidate((3)) == (37));\n    assert(candidate((4)) == (73));\n    assert(candidate((5)) == (121));\n}\n", "stop_tokens": ["\n}"], "completions": ["```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/**\n *  Star numbers are the centered hexagonal numbers.\n *  They are generated by the formula\n *\n *          6 * n * (n - 1) + 1\n *\n *  with n = 1, 2, 3, ... giving the sequence\n *          1, 13, 33, 61, 97, ...\n *\n *  (See OEIS A003215, or the concept of \u201cstar numbers\u201d in\n *   the literature, which represents a 6\u2011pointed star\n *   in a hexagonal lattice.)\n *\n *  Parameters\n *  ----------\n *  n : long\n *      Position in the sequence (1\u2011based).  n must be > 0.\n *\n *  Returns\n *  -------\n *  long\n *      The n\u2011th star number.\n */\nlong find_star_num(long n)\n{\n    assert(n > 0);          // Sanity check \u2013 we only support positive indices\n    // Use 64\u2011bit arithmetic to avoid overflow for reasonably large n\n    long long result = 6LL * n * (n - 1) + 1;\n    return static_cast<long>(result);\n}\n```\n\n*Tip:* If you need to handle very large `n`, consider using an arbitrary\u2011precision integer (e.g., `boost::multiprecision::cpp_int`) because `6*n*(n-1)+1` grows quadratically and can overflow a 64\u2011bit integer when `n` exceeds roughly 10\u2079.", "**Solution Explanation**\n\nStar numbers are a known integer sequence (OEIS A003215).  \nThey are the *centered hexagonal numbers* and can be visualized as a\nhexagonal lattice with one central point and concentric \u201crings\u201d\naround it; the number of points in the *n\u2011th* ring (including the centre)\nis called the *n\u2011th star number*.\n\nThe closed form of the n\u2011th star number is\n\n\\[\nS_n = 6\\,n\\,(n-1) + 1 , \\qquad n\\ge 1 .\n\\]\n\nThe sequence starts\n\n```\nn = 1 \u2192 1\nn = 2 \u2192 13\nn = 3 \u2192 37\nn = 4 \u2192 73\n...\n```\n\nso the formula works for all integers \\(n\\)\u00a0\u2265\u00a01.\n\n--------------------------------------------------------------------\n\n#### Algorithm\n```\nfunction find_star_num(n):\n    return 6*n*(n-1) + 1\n```\nThe calculation is performed using 64\u2011bit integers (`long` in C/C++),\nwhich is safe up to n\u22484.6\u00d710^9 (since 6\u00b7n\u00b7(n\u20111) fits into 9.22\u00d710^18).\n\n--------------------------------------------------------------------\n\n#### Correctness Proof  \n\nWe prove that `find_star_num(n)` returns the correct n\u2011th star number.\n\n**Lemma 1**  \nFor any integer n\u202f\u2265\u202f1, the number of lattice points in the n\u2011th ring of\na centered hexagonal lattice is \\(6n(n-1)+1\\).\n\n*Proof.*  \nThe lattice is composed of a central point (1 point).  \nEach subsequent ring surrounds the previous one and consists of\nexactly 6\u00b7\\(k\\) points, where \\(k\\) is the ring index (k\u202f=\u202f1 for the first ring, etc.).\nHence the total number of points after spanning rings 1\u2026n\u22121 is\n\n\\[\n1 + \\sum_{k=1}^{n-1} 6k \n  = 1 + 6\\frac{(n-1)n}{2}\n  = 6n(n-1)+1 .\n\\qquad \\square\n\\]\n\n**Lemma 2**  \n`find_star_num(n)` returns that formula.\n\n*Proof.*  \nThe function performs the arithmetic `6*n*(n-1)+1`, which is exactly\nthe algebraic expression of Lemma\u202f1.  \nThus the value returned equals the number of points in ring n.  \n\\(\\square\\)\n\n**Theorem**  \n`find_star_num(n)` returns the n\u2011th star number for all integer n\u202f\u2265\u202f1.\n\n*Proof.*  \nBy Lemma\u202f1, the n\u2011th star number equals \\(6n(n-1)+1\\).  \nBy Lemma\u202f2, the function returns precisely this value.  \nTherefore the function returns the correct star number. \\(\\square\\)\n\n--------------------------------------------------------------------\n\n#### Complexity Analysis\n\nThe function performs a constant amount of arithmetic, so\n\n- **Time complexity**: \\(O(1)\\)\n- **Space complexity**: \\(O(1)\\)\n\n--------------------------------------------------------------------\n\n#### Reference Implementation (C++)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// @brief Returns the n-th star number.\n/// @param n Index n (1\u2011based). n should be >= 1.\n/// @return The star number S_n = 6*n*(n-1) + 1.\n/// @note Uses 64\u2011bit arithmetic; safe for n up to about 4.6e9.\nlong long find_star_num(long long n) {\n    if (n < 1) {\n        throw std::invalid_argument(\"n must be >= 1\");\n    }\n    return 6LL * n * (n - 1) + 1;\n}\n\n// Example usage and basic tests\nint main() {\n    assert(find_star_num(1) == 1);\n    assert(find_star_num(2) == 13);\n    assert(find_star_num(3) == 37);\n    assert(find_star_num(4) == 73);\n    cout << \"All tests passed.\\n\";\n    return 0;\n}\n```\n\nThis code follows the algorithm proven correct above and compiles\nwith any C++ compiler supporting C++11 or later.", "Here is a compact implementation that will compile with the standard C/C++ compiler (the header `<bits/stdc++.h>` is fine on most judges, but if you prefer a more portable version you can replace it with the individual headers you actually need).\n\n```cpp\n#include <cassert>\n#include <bits/stdc++.h>\n\n/*\n * The n\u2011th star (or hexagram) number is given by\n * S(n) = 6*n*(n-1) + 1 = 6n^2 - 6n + 1\n *\n * For n = 1 we get 1, for n = 2 we get 13, etc.\n */\nlong find_star_num(long n) {\n    assert(n >= 1);            // n must be a positive integer\n    // Compute using 128\u2011bit integer to avoid overflow for large n\n    __int128 t = (__int128)n;\n    __int128 res = 6 * t * (t - 1) + 1;\n    // `long` is at least 64 bits on every platform we care about\n    assert(res <= std::numeric_limits<long>::max());\n    return static_cast<long>(res);\n}\n```\n\n### Why this works\n* The mathematical formula for the star number is a quadratic polynomial, so the implementation is just a direct evaluation.\n* `__int128` (available in GCC/Clang) guarantees that the intermediate multiplication won\u2019t overflow when `n` is as large as the largest value that still fits in a `long`.  \n  After the computation we cast the result back to `long`.  \n* The `assert` checks ensure that the function is used correctly and that the result still fits in a `long`.\n* The function is `O(1)` time and uses `O(1)` memory."]}
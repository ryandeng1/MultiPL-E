{"name": "mbpp_643_text_match_wordz_middle", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that checks if a strings contains 'z', except at the start and end of the word.\nbool text_match_wordz_middle(std::string text) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_643_text_match_wordz_middle.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = text_match_wordz_middle;\n    assert(candidate((\"pythonzabc.\")) == (true));\n    assert(candidate((\"zxyabc.\")) == (false));\n    assert(candidate((\"  lang  .\")) == (false));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a concise, self\u2011contained implementation that follows the specification:\n\n```cpp\n#include <string>\n\n/**\n * @brief  Return true if the given string contains at least one 'z'\n *         (or 'Z') that is **not** in the first or the last\n *         position of the string.\n *\n * @note   The check is case\u2011insensitive \u2013 both lower\u2011case and\n *         upper\u2011case `z` are treated as the same.  If the string\n *         is shorter than three characters the function will\n *         return false because there is no \u201cmiddle\u201d to search\n *         through.\n *\n * @param  text  the string to be inspected\n * @return true  if a middle \u2018z\u2019/\u2018Z\u2019 exists, false otherwise\n */\nbool text_match_wordz_middle(const std::string& text)\n{\n    // No middle if the string length is less than 3\n    if (text.size() < 3) return false;\n\n    // Search from the second character to the second\u2011last\n    for (std::size_t i = 1; i + 1 < text.size(); ++i)\n    {\n        if (text[i] == 'z' || text[i] == 'Z')\n            return true;\n    }\n    return false;\n}\n```\n\n### How it works\n1. **Length check** \u2013 If the string is 0, 1, or 2 characters long, there is no middle position, so we return `false`.\n2. **Iterate over the middle** \u2013 The loop starts at index `1` (the second character) and stops at `size() - 2` (the second\u2011to\u2011last character). This guarantees that the first and last characters are never examined.\n3. **Case\u2011insensitive comparison** \u2013 Both `'z'` and `'Z'` are recognised as valid middle matches.\n4. **Return** \u2013 As soon as a middle `z` is found the function returns `true`. If the loop finishes without finding one, it returns `false`.\n\n### Usage Example\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::string s1 = \"zooZ\";\n    std::string s2 = \"hello\";\n    std::string s3 = \"z\";\n\n    std::cout << std::boolalpha\n              << text_match_wordz_middle(s1) << '\\n' ; // true  (middle 'z')\n    std::cout << text_match_wordz_middle(s2) << '\\n' ; // false\n    std::cout << text_match_wordz_middle(s3) << '\\n' ; // false (no middle)\n}\n```\n\nFeel free to tweak the case\u2011sensitivity or the definition of \u201cmiddle\u201d if your actual requirements differ.", "Below is a clean, self\u2011contained implementation of your `text_match_wordz_middle` function together with a short demo.  \nFeel free to drop the demo part (the `main` function) into your test harness \u2013 the core logic is just the function body.\n\n```cpp\n#include <string>\n#include <cstddef>          // for std::size_t\n#include <cctype>           // for std::isalpha\n#include <cassert>\n\n/*\n * Returns true if *any* word in `text` contains the character 'z'\n * **and** that \u2018z\u2019 is *not* the very first or very last character of that word.\n *\n * A \"word\" is any maximal sequence of alphabetic characters.\n * Punctuation, digits, spaces, and other non\u2011letters break words.\n *\n * Examples:\n *   \"The pizza is good.\"        -> true   // 'z' in \"pizza\" (index 1 of the word)\n *   \"Zebra is prime.\"           -> false  // 'Z' is first char of \"Zebra\"\n *   \"Amazing\"                   -> false  // 'z' is last char of \"Amazing\"\n *   \"No z here.\"                -> false\n */\nbool text_match_wordz_middle(const std::string& text)\n{\n    std::size_t i = 0;\n    const std::size_t n = text.size();\n\n    while (i < n) {\n        /* Skip non\u2011letters \u2013 they are word boundaries */\n        while (i < n && !std::isalpha(static_cast<unsigned char>(text[i]))) {\n            ++i;\n        }\n        if (i >= n) break;            // nothing left\n\n        /* We are at the first letter of a word */\n        std::size_t start = i;\n        while (i < n && std::isalpha(static_cast<unsigned char>(text[i]))) {\n            /* Detect 'z' or 'Z' that is neither first nor last\n             * of the current word.  We need to know if we're\n             * still in the middle, so we postpone the check until\n             * we know the word\u2019s length.  However, we can find out\n             * as soon as we detect a non\u2011letter that follows a 'z'. */\n            if ((text[i] == 'z' || text[i] == 'Z') &&\n                /* Not the first character of the word */\n                i > start &&\n                /* There will be at least one more letter after it */\n                (i + 1 < n && std::isalpha(static_cast<unsigned char>(text[i + 1])))) {\n                return true;\n            }\n            ++i;\n        }\n        /* `i` now points to the first character after the word */\n    }\n\n    return false;\n}\n\n/* -------------------- Demo / Test harness -------------------- */\n#ifdef UNIT_TEST\n#include <iostream>\n\nint main()\n{\n    struct TestCase {\n        std::string text;\n        bool expected;\n    } const tests[] = {\n        {\"The pizza is good.\",   true},\n        {\"Zebra is prime.\",     false},\n        {\"Amazing\",             false},\n        {\"No z here.\",          false},\n        {\"zoo\",                 false},\n        {\"pizza-z...\" ,         true},\n        {\"zag\",                 false},    // 'z' at start\n        {\"amazing.\",            false},    // 'z' at end\n        {\"azzeaba\",             true},     // 'z' in middle\n        {\"\",                    false},\n        {\"   \",                 false},\n        {\"aZb\",                 true},\n        {\"az\",                  false},\n        {\"za\",                  false},\n        {\"age bird z\",          false},\n        {\"This is bzzzz beany\", true},\n    };\n\n    for (auto& tc : tests) {\n        bool got = text_match_wordz_middle(tc.text);\n        std::cout << (got == tc.expected ? \"PASS\" : \"FAIL\")\n                  << \" : \\\"\" << tc.text << \"\\\" (expected \" << tc.expected\n                  << \", got \" << got << \")\\n\";\n        assert(got == tc.expected);\n    }\n\n    std::cout << \"All tests passed.\\n\";\n    return 0;\n}\n#endif\n```\n\n### Why this implementation works\n\n| Step | What it does | Why it matters |\n|------|--------------|----------------|\n| 1. Skip non\u2011alphabetic chars | Treats any non\u2011letter as a word separator. | Keeps the check confined to \"words\". |\n| 2. Mark the start of a word | `start = i`. | Enables knowledge of first\u2010letter offset. |\n| 3. Scan each letter inside the word | While `isalpha`. | Allows us to check each char against its neighbors. |\n| 4. Detect a \u2018z\u2019 that is **not** first and has another letter following it. | `i > start && i+1 < n && isalpha(...)`. | This precisely matches \u201cz\u201d in the middle of a word. |\n| 5. Return `true` on first hit |  | Early exit \u2013 no need to scan further. |\n| 6. If loop finishes, return `false`. |  | Indicates no qualifying \u2018z\u2019 was found. |\n\nThe demo (guarded by `#ifdef UNIT_TEST`) provides a quick sanity check.  \nCompile with `-DUNIT_TEST` to run it, e.g.:\n\n```\ng++ -std=c++17 -DUNIT_TEST your_file.cpp && ./a.out\n```\n\nHappy coding!", "Here is a compact, well\u2011documented implementation that does exactly what was requested:  \n\n* it scans each *word* of the input string,\n* it ignores the first and last character of the word,\n* it reports `true` as soon as any word contains a `'z'` somewhere in the middle, otherwise it returns `false`.\n\n```cpp\n#include <string>\n#include <cctype>\n\n/**\n * @brief   Checks if any word in a string contains the letter 'z'\n *          in the middle (excluding the first and last character).\n *\n * @param   text  The input string. Words are delimited by whitespace.\n * @return  true  if at least one word has a 'z'\n * @return  false otherwise\n *\n * @note    The check is case\u2011sensitive \u2013 only the exact character 'z'\n *          (ASCII 0x7A) is considered.  If you need a case\u2013insensitive\n *          version, convert the characters to lower\u2011case before the\n *          comparison.\n */\nbool text_match_wordz_middle(const std::string& text)\n{\n    const size_t n = text.size();\n    size_t i = 0;\n\n    while (i < n)\n    {\n        // Skip any leading whitespace\n        while (i < n && std::isspace(static_cast<unsigned char>(text[i])))\n            ++i;\n        if (i >= n) break;          // no more words\n\n        size_t word_start = i;\n\n        // Advance until we hit whitespace or the end of the string\n        while (i < n && !std::isspace(static_cast<unsigned char>(text[i])))\n            ++i;\n\n        size_t word_end = i;        // one past the last character of the word\n        size_t word_len = word_end - word_start;\n\n        // Only words of length 3 or more can have a middle character\n        if (word_len >= 3)\n        {\n            // Scan positions 1 \u2026 (len-2), i.e. exclude first and last\n            for (size_t pos = word_start + 1; pos < word_end - 1; ++pos)\n            {\n                if (text[pos] == 'z')\n                    return true;\n            }\n        }\n\n        // Continue with the next word\n    }\n\n    return false;   // no middle 'z' found in any word\n}\n```\n\n### How it works\n\n1. **Word separation** \u2013 The function iterates over the string, first skipping any leading whitespace to find the start of the first word and then advancing until the next whitespace to find the end of that word.  \n2. **Length check** \u2013 Only words of length \u2265\u202f3 can contain a middle character that is neither the first nor the last.  \n3. **Middle\u2011character scan** \u2013 For such words it scans positions `1 \u2026 len-2` (relative to the word), returning `true` immediately when a `'z'` is detected.  \n4. **Result** \u2013 If the loop finishes without finding a middle `'z'`, `false` is returned.\n\nFeel free to adapt the whitespace handling or add a case\u2011insensitive comparison if your use case differs."]}
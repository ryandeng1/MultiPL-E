{"name": "mbpp_92_is_undulating", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to check whether the given number is undulating or not.\nbool is_undulating(long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_92_is_undulating.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = is_undulating;\n    assert(candidate((1212121)) == (true));\n    assert(candidate((1991)) == (false));\n    assert(candidate((121)) == (true));\n}\n", "stop_tokens": ["\n}"], "completions": ["Sure!  \nBelow is a self\u2011contained C++ snippet that implements the `is_undulating` function.  \nAn *undulating* number (sometimes called \u201calternating\u201d or \u201czig\u2011zag\u201d) is one whose decimal\ndigits strictly alternate between increasing and decreasing.  \nExamples:  \n\n* `121212` \u2192 **true** (1<2>1<2>1<2)  \n* `12345`  \u2192 **false** (all increasing, no alternation)  \n* `3210`   \u2192 **true** (3>2<1>0)  \n\nEdge cases:  \n* Single\u2011digit numbers are considered undulating (there\u2019s nothing to compare).  \n* Numbers with repeated adjacent digits (e.g., `1221`) are *not* undulating because the\n  comparison isn\u2019t strictly `<` or `>`.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cassert>\n\n/* --------------  Helper -------------- */\n// Split an integer into its decimal digits (most\u2011significant first).\nstatic std::vector<int> digits(long n) {\n    if (n < 0) n = -n;                  // ignore sign\n    std::vector<int> d;\n    while (n > 0) {\n        d.push_back(n % 10);\n        n /= 10;\n    }\n    if (d.empty()) d.push_back(0);      // n was 0\n    std::reverse(d.begin(), d.end());   // MSB first\n    return d;\n}\n\n/* --------------  Main -------------- */\n// Return true iff n is undulating.\nbool is_undulating(long n) {\n    std::vector<int> d = digits(n);          // all decimal digits\n    size_t sz = d.size();\n\n    if (sz <= 1) return true;               // single digit counts\n\n    // The first comparison establishes the expected direction.\n    // If d[0] == d[1] => not undulating.\n    if (d[0] == d[1]) return false;\n    bool increasing = (d[0] < d[1]);         // true if first step up\n\n    for (size_t i = 1; i < sz - 1; ++i) {\n        if (d[i] == d[i+1]) return false;    // equal adjacent digits\n        bool nextUp = d[i] < d[i+1];\n        if (nextUp == increasing)            // we expected the opposite\n            return false;\n        increasing = !increasing;            // flip expectation\n    }\n    return true;\n}\n\n/* --------------  Unit Tests -------------- */\nstatic void run_tests() {\n    assert(is_undulating(0)   == true);\n    assert(is_undulating(7)   == true);\n    assert(is_undulating(12)  == true);\n    assert(is_undulating(123) == false);\n    assert(is_undulating(121) == true);\n    assert(is_undulating(1212) == true);\n    assert(is_undulating(12321) == false);\n    assert(is_undulating(1234321) == true);\n    assert(is_undulating(1221)   == false);\n    assert(is_undulating(111)    == false);\n    assert(is_undulating(210)    == true);\n    assert(is_undulating(-121)  == true);   // sign ignored\n    std::cout << \"All tests passed!\\n\";\n}\n\nint main() {\n    run_tests();\n    // Example\n    long num = 121212;\n    std::cout << num << \" is \" << (is_undulating(num) ? \"undulating\" : \"not undulating\") << '\\n';\n    return 0;\n}\n```\n\n### How it works\n\n1. **Digit extraction** \u2013 The helper `digits()` turns the integer into a vector of its decimal digits, preserving their order.\n2. **Single\u2011digit handling** \u2013 A single digit is trivially undulating.\n3. **Initial comparison** \u2013 The first two digits set the expected direction (`increasing` = true if the first step is up).\n4. **Iteration** \u2013 For each subsequent adjacent pair:\n   * Adjacent equal digits \u2192 not undulating.\n   * If the direction matches the current expectation \u2192 pattern broken \u2192 not undulating.\n   * Flip the expectation for the next comparison.\n\n5. **Return** \u2013 If the loop completes, all comparisons alternated correctly \u2192 *undulating*.\n\nFeel free to drop this snippet into any project or adapt it for other bases by changing the digit extraction routine. Happy coding!", "Below is a straightforward implementation of `is_undulating`.  \nThe function pulls the decimal digits of the number into a vector (in the correct order), then checks that each *intermediate* digit alternates between being greater than its neighbours and smaller than its neighbours.  \nIf the number has less than three digits we consider it undulating by definition.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Return true iff the decimal digits of |n| alternate between\n// increasing and decreasing. A number with fewer than 3 digits is\n// considered undulating.\nbool is_undulating(long n) {\n    n = llabs(n);                     // work with absolute value\n    string s = to_string(n);          // string representation of the digits\n\n    if (s.size() < 3) return true;    // one or two digits \u2013 trivially undulating\n\n    // We only need to check the inner digits (positions 1 \u2026 len-2).\n    for (size_t i = 1; i + 1 < s.size(); ++i) {\n        int a = s[i - 1] - '0';\n        int b = s[i]     - '0';\n        int c = s[i + 1] - '0';\n\n        // b must be either a > b < c  or  a < b > c\n        if (!((a < b && b > c) || (a > b && b < c))) {\n            return false;             // pattern broken\n        }\n    }\n    return true;\n}\n``` \n\n**Example usage**\n\n```cpp\nint main() {\n    long nums[] = {1, 12, 123, 121, 1234, 12321, 1323, 1213};\n    for (long x : nums)\n        cout << x << \" -> \" << (is_undulating(x) ? \"UNDULATING\" : \"NOT\") << '\\n';\n}\n```\n\nThe program prints whether each number is undulating according to the definition.", "Below is a compact, self\u2011contained implementation of the `is_undulating` function together with a short test harness.\n\n```cpp\n#include <cassert>\n#include <cmath>\n#include <iostream>\n\n/*\n  An integer is called **undulating** when its decimal digits\n  strictly alternate between being larger than the previous one\n  and smaller than the previous one.\n\n  Examples\n   - 101       => true   (1 > 0 < 1)\n  - 1234      => false   (1 < 2 < 3 < 4)\n  - 987654    => false   (9 > 8 > 7 > 6 > 5 > 4)\n  - 1312      => true   (1 < 3 > 1 < 2)\n*/\nbool is_undulating(long n)\n{\n    // Negative numbers are not considered in the specification\n    if (n < 0) return false;\n\n    // Numbers with less than 3 digits are trivially undulating\n    if (n < 100) return true;\n\n    // Extract the least significant two digits so we can\n    // compare the direction (up / down) of each step.\n    int prev = n % 10;                 // units\n    int curr = (n / 10) % 10;          // tens\n    bool increasing = curr > prev;     // direction between the first two digits\n\n    n /= 100;                          // shift out the two processed digits\n\n    while (n > 0) {\n        int next = n % 10;             // next digit on the left\n\n        // The direction from 'curr' to 'next' must be opposite\n        // of the previous direction\n        bool stillIncreasing = curr > next;\n        if (stillIncreasing == increasing) return false; // same direction \u2192 not undulating\n\n        // Update for next iteration\n        increasing = stillIncreasing;\n        curr = next;\n        n /= 10;\n    }\n    return true;\n}\n\n// ---------- Simple test harness ----------\nint main()\n{\n    struct TestCase {\n        long number;\n        bool expected;\n    };\n\n    TestCase tests[] = {\n        {101,     true},\n        {1234,    false},\n        {987654,  false},\n        {1312,    true},\n        {1,       true},\n        {12,      true},\n        {210,     false},\n        {159,     true},\n        {153,     true},\n        {142,     false}\n    };\n\n    for (auto const& tc : tests) {\n        bool got = is_undulating(tc.number);\n        assert(got == tc.expected);\n        std::cout << tc.number << \" -> \" << (got ? \"undulating\" : \"not\") << '\\n';\n    }\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\n### How it works\n\n1. **Edge cases** \u2013  \n   * Negative numbers are rejected.  \n   * Numbers with one or two digits are automatically undulating, because there are not enough digits to form a non\u2011alternating pattern.\n\n2. **Initial direction** \u2013  \n   The direction (`increasing`) between the first two operative digits (tens and units) is stored.\n\n3. **Iteration** \u2013  \n   For every remaining digit (moving from right to left) the new direction (`curr > next`) is compared with the previous one.  \n   If it is the same, the number is **not** undulating.\n\n4. **Result** \u2013  \n   If the loop finishes without violation, the number is undulating.\n\nThe code is fully compliant with the C++17 (and later) standard and does not depend on any non\u2011standard headers."]}
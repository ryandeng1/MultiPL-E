{"name": "mbpp_427_change_date_format", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.\nstd::string change_date_format(std::string dt) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_427_change_date_format.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = change_date_format;\n    assert(candidate((\"2026-01-02\")) == (\"02-01-2026\"));\n    assert(candidate((\"2020-11-13\")) == (\"13-11-2020\"));\n    assert(candidate((\"2021-04-26\")) == (\"26-04-2021\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["Sure!  \nBelow is a **stand\u2011alone, self\u2011contained C++17** program that contains the required helper\n`change_date_format` function.  \nIt:\n\n1.  Validates that the input is in the `yyyy\u2011mm\u2011dd` format.\n2.  Parses the three parts (year, month, day).\n3.  Checks that the month is between **01\u201112** and the day is valid for that month (including leap\u2011year logic).\n4.  Builds and returns the date in `dd\u2011mm\u2011yyyy` order.\n\nFeel free to drop just the function and its headers into your own project.\n\n```cpp\n#include <cassert>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <stdexcept>\n#include <iostream>\n\n/*  ----------------------------------------------------------\n *  Helper: determines whether a year is leap or not\n *  ---------------------------------------------------------- */\nconstexpr bool is_leap_year(int y)\n{\n    return (y % 4 == 0 && y % 100 != 0) || (y % 400 == 0);\n}\n\n/*  ----------------------------------------------------------\n *  Helper: return number of days in a month of given year\n *  ---------------------------------------------------------- */\nconstexpr int days_in_month(int month, int year)\n{\n    switch (month) {\n        case 1:  return 31;\n        case 2:  return is_leap_year(year) ? 29 : 28;\n        case 3:  return 31;\n        case 4:  return 30;\n        case 5:  return 31;\n        case 6:  return 30;\n        case 7:  return 31;\n        case 8:  return 31;\n        case 9:  return 30;\n        case 10: return 31;\n        case 11: return 30;\n        case 12: return 31;\n        default: return 0;          // will be caught later\n    }\n}\n\n/*  ----------------------------------------------------------\n *  Main conversion routine\n *  ---------------------------------------------------------- */\nstd::string change_date_format(const std::string& dt)\n{\n    /* --- sanity: 10 characters, 2 dashes in the right place --- */\n    if (dt.size() != 10 || dt[4] != '-' || dt[7] != '-')\n        throw std::invalid_argument(\"invalid date format, expected yyyy-mm-dd\");\n\n    /* --- dig into year, month, day --- */\n    int year  = std::stoi(dt.substr(0, 4));\n    int month = std::stoi(dt.substr(5, 2));\n    int day   = std::stoi(dt.substr(8, 2));\n\n    /* --- validation of month and day --- */\n    if (month < 1 || month > 12)\n        throw std::out_of_range(\"month out of range (1\u201112)\");\n    int dim = days_in_month(month, year);\n    if (day < 1 || day > dim)\n        throw std::out_of_range(\"day out of range for the given month & year\");\n\n    /* --- produce the new string in dd-mm-yyyy --- */\n    std::ostringstream oss;\n    oss << std::setw(2) << std::setfill('0') << day   << '-'\n        << std::setw(2) << std::setfill('0') << month << '-'\n        << std::setw(4) << std::setfill('0') << year;\n    return oss.str();\n}\n\n/*  ----------------------------------------------------------\n *  Example usage / simple test harness\n *  ---------------------------------------------------------- */\nint main()\n{\n    try {\n        std::string input = \"2024-02-29\";\n        std::string out   = change_date_format(input);\n        std::cout << \"Input : \" << input << '\\n'\n                  << \"Output: \" << out   << '\\n';\n    } catch (const std::exception& ex) {\n        std::cerr << \"Error: \" << ex.what() << '\\n';\n    }\n    return 0;\n}\n```\n\n### How it works\n\n1. **`is_leap_year`**  \n   Returns `true` for leap years using the Gregorian calendar rule.\n\n2. **`days_in_month`**  \n   Maps month numbers to the correct days, taking leap years into account for February.\n\n3. **`change_date_format`**  \n   * Checks format (`yyyy-mm-dd`).  \n   * Parses year, month, day with `std::stoi`.  \n   * Validates month (1\u201112) and day (1\u2011`days_in_month`).  \n   * Builds the new format with `std::ostringstream` using `setw` and `setfill` to keep leading zeroes.\n\nThe program is ready to compile with any modern C++ compiler (`-std=c++17` or later). You can remove the `main` and surrounding includes if you only want the helper function.", "Below is a minimal, self\u2011contained implementation that turns a date written as  \n`yyyy\u2011mm\u2011dd` into `dd\u2011mm\u2011yyyy`.  \nThe code checks the basic syntax, extracts the parts, re\u2011orders them, and returns the new string.\n\n```cpp\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <stdexcept>\n\n// helper to trim whitespace (if any)\nstatic inline std::string trim(const std::string &s) {\n    auto start = s.find_first_not_of(\" \\t\\r\\n\");\n    if (start == std::string::npos) return \"\";\n    auto end   = s.find_last_not_of( \" \\t\\r\\n\");\n    return s.substr(start, end - start + 1);\n}\n\n// convert yyyy-mm-dd  \u2192  dd-mm-yyyy\nstd::string change_date_format(const std::string& dt) {\n    std::string s = trim(dt);\n\n    // Basic format check\n    if (s.size() != 10 || s[4] != '-' || s[7] != '-')\n        throw std::invalid_argument(\"invalid date format\");\n\n    // Extract year, month, day\n    std::string year = s.substr(0, 4);\n    std::string mon  = s.substr(5, 2);\n    std::string day  = s.substr(8, 2);\n\n    // Very lightweight numeric validation\n    if (std::stoi(year) < 0)          // year non\u2011negative number\n        throw std::invalid_argument(\"invalid year\");\n    if (std::stoi(mon) < 1 || std::stoi(mon) > 12)\n        throw std::invalid_argument(\"invalid month\");\n    if (std::stoi(day) < 1 || std::stoi(day) > 31) // 31 is a safe upper bound\n        throw std::invalid_argument(\"invalid day\");\n\n    // Assemble the target format\n    return day + \"-\" + mon + \"-\" + year;\n}\n\n/* Example usage -----------------------------------------------*/\nint main() {\n    try {\n        std::string input  = \"2024-07-20\";\n        std::string output = change_date_format(input);\n        std::cout << \"Original: \" << input << \"\\n\";\n        std::cout << \"Reversed: \" << output << \"\\n\";\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << '\\n';\n    }\n}\n```\n\n### What the function does\n\n1. **Trim** \u2013 removes leading/trailing whitespace (optional but handy).  \n2. **Format validation** \u2013 checks the length and the dashes at positions 4 and 7.  \n3. **Split** \u2013 extracts the three components using `substr`.  \n4. **Simple numeric checks** \u2013 ensures month is 1\u201112, day is 1\u201131, year is non\u2011negative.  \n   (If you want stricter validation, you could use `std::tm` and `std::mktime`.)  \n5. **Reassemble** \u2013 concatenates `day + \"-\" + month + \"-\" + year` and returns it.\n\nFeel free to replace the tiny numeric checks with a more thorough calendar validation if needed.", "Here\u2019s a complete, self\u2011contained implementation of `change_date_format`.  \nIt parses a `yyyy\u2011mm\u2011dd` string and returns a `dd\u2011mm\u2011yyyy` string while doing some basic validation (you can extend the validation as needed).\n\n```cpp\n#include <string>            // std::string\n#include <sstream>           // std::istringstream\n#include <iomanip>           // std::setw, std::setfill\n#include <stdexcept>         // std::invalid_argument\n\n// Convert a date from \"yyyy-mm-dd\" to \"dd-mm-yyyy\".\nstd::string change_date_format(const std::string& dt)\n{\n    // ------------------------------------------------------------------\n    // Basic sanity checks\n    // ------------------------------------------------------------------\n    if (dt.size() != 10) {\n        throw std::invalid_argument(\"Date must be in format yyyy-mm-dd\");\n    }\n\n    // Verify hyphens are in the correct places\n    if (dt[4] != '-' || dt[7] != '-') {\n        throw std::invalid_argument(\"Date must be in format yyyy-mm-dd\");\n    }\n\n    // ------------------------------------------------------------------\n    // Parse the components into integers\n    // ------------------------------------------------------------------\n    int year   = std::stoi(dt.substr(0, 4));\n    int month  = std::stoi(dt.substr(5, 2));\n    int day    = std::stoi(dt.substr(8, 2));\n\n    // ------------------------------------------------------------------\n    // (Optional) Basic range validation \u2013 you can replace this with a\n    // full calendar check if you need stricter guarantees.\n    // ------------------------------------------------------------------\n    if (month < 1 || month > 12)\n        throw std::invalid_argument(\"Month must be between 01 and 12\");\n    if (day < 1 || day > 31)\n        throw std::invalid_argument(\"Day must be between 01 and 31\");\n\n    // ------------------------------------------------------------------\n    // Compose the target string in dd-mm-yyyy order\n    // ------------------------------------------------------------------\n    std::ostringstream oss;\n    oss << std::setw(2) << std::setfill('0') << day   << '-'\n        << std::setw(2) << std::setfill('0') << month << '-'\n        << std::setw(4) << std::setfill('0') << year;\n\n    return oss.str();\n}\n\n/* --------------------------------------------------------------------\n   Usage example (uncomment to test):\n\nint main() {\n    std::string input  = \"2024-01-27\";\n    std::string output = change_date_format(input);\n    std::cout << output << std::endl;   // prints \"27-01-2024\"\n}\n-------------------------------------------------------------------- */\n```\n\n### Why this implementation is convenient\n- **No external dependencies** \u2013 only the standard C++ library is used.\n- **Clear error handling** \u2013 throws `std::invalid_argument` if the input format is wrong; you can catch this or let it propagate.\n- **Formatting helpers** \u2013 uses `std::setw`/`std::setfill` to keep leading zeros for month/day.\n\nFeel free to adjust the validation part (e.g., a full leap\u2011year check) if your application needs stricter date correctness."]}
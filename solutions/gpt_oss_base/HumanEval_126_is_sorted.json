{"name": "HumanEval_126_is_sorted", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_126_is_sorted.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = is_sorted;\n    assert(candidate((std::vector<long>({(long)5}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n    assert(candidate((std::vector<long>({(long)1}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (true));\n}\n", "stop_tokens": ["\n}"], "completions": ["```cpp\n#include <vector>\n#include <algorithm>\n\n/// @brief   Check if a vector of non\u2011negative integers is sorted in ascending order\n/// @param   lst  The vector to test\n/// @note    * The vector is considered sorted if it is non\u2011decreasing.\n/// * If any value appears **more than twice** the function returns `false`\n///   \u2013 i.e. at most two identical elements are allowed.\n/// @return  `true` if `lst` is sorted and no number occurs more than twice,\n///          otherwise `false`.\n///\nbool is_sorted(const std::vector<long>& lst)\n{\n    // Empty or single element vector is trivially sorted\n    if (lst.size() <= 1)\n        return true;\n\n    // A simple one\u2013pass check for ascending order\n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < lst[i-1])    // Strictly lower value \u2013 not sorted\n            return false;\n    }\n\n    // Now we have to check the \u201cat most two duplicates\u201d rule.\n    // We can do this in the same pass, keeping a counter for the current\n    // run of equal values.\n    size_t run_len = 1;                 // length of the current equal\u2011value block\n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] == lst[i-1]) {\n            ++run_len;\n            if (run_len > 2)          // more than two duplicates\n                return false;\n        } else {\n            run_len = 1;              // reset for the new value\n        }\n    }\n\n    // All checks passed\n    return true;\n}\n```\n\n### How it works\n1. **Empty / single element** \u2013 already sorted, return `true`.\n2. **Ascending order** \u2013 a simple linear scan; any `lst[i] < lst[i-1]` means it\u2019s not sorted.\n3. **Duplicate rule** \u2013 while scanning, keep a counter for the current run of equal values.  \n   If the counter ever exceeds `2`, return `false`.\n\nThe function runs in `O(n)` time and uses `O(1)` extra space.", "Here\u2019s a compact, self\u2011contained implementation of `is_sorted` that satisfies all of the requirements:\n\n* The vector must be in non\u2011decreasing order (ascending, but duplicates are allowed).\n* If any number appears **more than twice** the function must return `false`.\n\n```cpp\n#include <vector>\n#include <unordered_map>\n\nbool is_sorted(const std::vector<long>& lst) {\n    if (lst.empty()) return true;                // Empty list is sorted\n\n    std::unordered_map<long, int> freq;          // Count occurrences\n\n    long prev = lst[0];\n    ++freq[prev];\n\n    for (size_t i = 1; i < lst.size(); ++i) {\n        const long curr = lst[i];\n\n        // 1. Check ascending order\n        if (curr < prev) return false;\n\n        // 2. Update frequency & check duplicates > 2\n        if (++freq[curr] > 2) return false;\n\n        prev = curr;\n    }\n\n    return true;\n}\n```\n\n### How it works\n\n1. **Ordering Check** \u2013 The loop keeps a copy of the previous element (`prev`).  \n   Whenever the current element is smaller than `prev`, the vector is not sorted.\n\n2. **Duplicate Count** \u2013 An `unordered_map` tracks how many times each integer has appeared  \n   so far. If the count for any element ever exceeds `2`, the function immediately returns `false`.\n\n3. The function returns `true` only when both conditions are satisfied for every element.\n\nThis implementation runs in linear time \\(O(n)\\) and uses linear auxiliary space for the counts. It also handles an empty or single\u2011element vector gracefully.", "Here\u2019s a straightforward implementation that checks both conditions:\n\n```cpp\n#include <vector>\n#include <unordered_map>\n\nbool is_sorted(const std::vector<long>& lst) {\n    // Early\u2011return for empty or single\u2011element vectors\n    if (lst.size() <= 1) return true;\n\n    std::unordered_map<long, int> freq;\n\n    // Keep track of the previous element\n    long prev = lst[0];\n\n    // Increment the count for the first element\n    freq[prev] = 1;\n\n    // Iterate over the vector starting from the second element\n    for (size_t i = 1; i < lst.size(); ++i) {\n        long cur = lst[i];\n\n        // Check ascending order\n        if (cur < prev) return false;\n\n        // Update the frequency map\n        ++freq[cur];\n\n        // More than one duplicate of the same number => false\n        if (freq[cur] > 2) return false;\n\n        prev = cur;\n    }\n\n    return true;\n}\n```\n\n### How it works\n\n1. **Ascending order check** \u2013 Each new element `cur` is compared with the previous one `prev`.  \n   If `cur < prev`, the vector is not sorted in ascending order and we return `false`.\n\n2. **Duplicate\u2011count check** \u2013 We keep a hash map `freq` that counts how many times each number appears.  \n   If any number reaches a count of **3** (meaning more than one duplicate), we return `false`.\n\n3. **Edge cases** \u2013 An empty vector or a single\u2011element vector is considered sorted.\n\nFeel free to drop this into your project and adjust the header includes if you\u2019re not already using `<unordered_map>`."]}
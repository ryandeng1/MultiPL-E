{"name": "HumanEval_158_find_max", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_158_find_max.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"}))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a complete, self\u2011contained implementation that satisfies the specification:\n\n```cpp\n#include <string>\n#include <vector>\n#include <unordered_set>\n#include <algorithm>\n#include <iterator>\n\nstd::string find_max(const std::vector<std::string>& words)\n{\n    // If the vector is empty, return an empty string.\n    if (words.empty())\n        return {};\n\n    // Helper to count unique characters in a string.\n    auto uniqueCount = [](const std::string& s) {\n        std::unordered_set<char> chars;\n        for (char c : s)\n            chars.insert(c);\n        return static_cast<int>(chars.size());\n    };\n\n    // Keep track of the best candidate.\n    std::string best = words.front();\n    int bestCount = uniqueCount(best);\n\n    for (size_t i = 1; i < words.size(); ++i)\n    {\n        const std::string& w = words[i];\n        int curCount = uniqueCount(w);\n\n        if (curCount > bestCount ||\n            (curCount == bestCount && w < best))\n        {\n            best = w;\n            bestCount = curCount;\n        }\n    }\n    return best;\n}\n```\n\n### Explanation\n\n1. **Handle Empty Input** \u2013 If `words` is empty, we return an empty string.\n2. **Unique\u2011character counter** \u2013 A lambda `uniqueCount` creates an `unordered_set` of characters in the string, then returns its size.\n3. **Iterate & Compare** \u2013 We initialise the best candidate with the first string and its unique\u2011character count.  \n   For each subsequent string we compute its count and update `best` when:\n   - It has *more* unique characters, **or**\n   - It has the *same* number but is lexicographically smaller (`w < best`).\n4. **Return the result** \u2013 After scanning all strings, `best` holds the desired word.\n\nThis implementation runs in **O(N\u202f\u00b7\u202fL)** time, where `N` is the number of strings and `L` is the average length of a string.", "Here is the complete implementation for the function described in the prompt.  \nThe logic is:\n\n1. For each word, compute the number of distinct characters (unordered set).  \n2. Keep track of the maximum count seen so far (`maxUniques`).  \n3. While iterating, maintain two state variables:\n   * `bestWord` \u2013 the word that currently satisfies the requirement of having the max number of unique characters and, in case of ties, being lexicographically smallest.\n   * `bestUniques` \u2013 the count of uniques corresponding to `bestWord`.\n\nAt the end, return `bestWord`.\n\nThe algorithm runs in `O(total number of characters)` time and uses `O(1)` extra space (apart from the temporary set for each word).\n\n```cpp\n#include <string>\n#include <vector>\n#include <unordered_set>\n#include <algorithm>\n\nstd::string find_max(const std::vector<std::string>& words) {\n    std::string bestWord;          // holds current best word\n    std::size_t bestUniques = 0;   // number of unique chars in bestWord\n\n    for (const std::string& word : words) {\n        // Count unique characters in the current word\n        std::unordered_set<char> chars;\n        for (char c : word) {\n            chars.insert(c);\n        }\n        std::size_t uniqCnt = chars.size();\n\n        // Decide whether to replace bestWord\n        if (uniqCnt > bestUniques) {\n            bestUniques = uniqCnt;\n            bestWord = word;\n        } else if (uniqCnt == bestUniques) {\n            // same number of uniques, choose lexicographically smaller\n            if (word < bestWord) {\n                bestWord = word;\n            }\n        }\n    }\n\n    return bestWord;\n}\n```\n\n### Explanation\n\n- **Counting unique characters**  \n  `unordered_set<char>` stores each character only once, giving the distinct count directly via `size()`.\n\n- **Updating the best candidate**  \n  - If a word has strictly more unique characters than the current best, it becomes the new best.  \n  - If it ties, we compare lexicographically (`operator<` on `std::string`). The `<` operator implements standard lexicographic ordering.\n\n- **Edge Cases**  \n  - An empty vector will return an empty string (the default `bestWord`).  \n  - If `words` contains only empty strings, `bestWord` will be the first empty string, which satisfies the lexicographic rule.\n\n### Complexity\n\n- **Time:**  \n  For each character in every string we do a constant\u2011time insert into the set.  \n  Let `N` be the total number of characters in all words.  \n  The overall time complexity is `O(N)`.\n\n- **Space:**  \n  The auxiliary set for a word contains at most 26 (or 256 if extended ASCII) distinct characters, which is `O(1)` relative to the input size.  \n  The function itself stores only a few variables, so the space complexity is `O(1)`.\n\nFeel free to integrate this function into your codebase or adjust the interface (e.g., passing the vector by const reference) as needed.", "Here is a complete, compilable implementation of `find_max`.  \nThe function loops over all words, counts the number of distinct characters in each one (using an array of 256 booleans for ASCII characters), and keeps track of the currently best word.\n\n```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cctype>\n\nstd::string find_max(const std::vector<std::string>& words)\n{\n    // Helper to count unique characters in a word\n    auto unique_cnt = [](const std::string& s) -> int {\n        bool seen[256] = { false };\n        int cnt = 0;\n        for (unsigned char c : s) {\n            if (!seen[c]) {\n                seen[c] = true;\n                ++cnt;\n            }\n        }\n        return cnt;\n    };\n\n    if (words.empty())\n        return \"\";\n\n    std::string best = words[0];\n    int best_cnt = unique_cnt(best);\n\n    for (size_t i = 1; i < words.size(); ++i) {\n        int cur_cnt = unique_cnt(words[i]);\n\n        if (cur_cnt > best_cnt) {\n            best = words[i];\n            best_cnt = cur_cnt;\n        } else if (cur_cnt == best_cnt && words[i] < best) {\n            // lexicographically smaller word takes precedence when counts equal\n            best = words[i];\n        }\n    }\n\n    return best;\n}\n```\n\n### Explanation\n1. **Counting unique characters**  \n   - We use an array `seen[256]` (sufficient for all ASCII characters) to flag which characters have appeared.  \n   - For each character `c` in the string, if it hasn\u2019t been seen yet, we mark it and increment the counter.\n\n2. **Choosing the best word**  \n   - Start with the first word as current best.  \n   - For each subsequent word:\n     * If it has a strictly larger unique\u2011character count, it becomes the new best.  \n     * If the count ties the current best, we pick the lexicographically smaller one (`operator<` on `std::string`).\n\n3. **Edge cases**  \n   - If the input vector is empty, an empty string is returned.  \n   - The function takes the arguments by const reference to avoid unnecessary copying.\n\nYou can test it with the examples from the prompt:\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << find_max({\"name\",\"of\",\"string\"}) << '\\n';   // string\n    std::cout << find_max({\"name\",\"enam\",\"game\"}) << '\\n';   // enam\n    std::cout << find_max({\"aaaaaaa\",\"bb\",\"cc\"}) << '\\n';    // aaaaaaa\n}\n```\n\nAll three outputs match the expected results."]}
{"name": "mbpp_802_count_rotation", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to count the number of rotations required to generate a sorted vector. https://www.geeksforgeeks.org/count-of-rotations-required-to-generate-a-sorted-vector/\nlong count_rotation(std::vector<long> arr) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_802_count_rotation.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = count_rotation;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)5, (long)1, (long)2, (long)3}))) == (2));\n    assert(candidate((std::vector<long>({(long)7, (long)8, (long)9, (long)1, (long)2, (long)3}))) == (3));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (0));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2}))) == (2));\n}\n", "stop_tokens": ["\n}"], "completions": ["**Solution Overview**\n\nFor a completely sorted array (ascending order) the number of cyclic rotations that have been performed equals the index of the minimum element.  \nThe array satisfies the property `arr[i] \u2264 arr[i+1]` for all positions *except* the point where the array was \u201ccut\u201d and the smallest element now lies.  \nBecause the array is still a **rotated sorted array**, the smallest element is the only element that is smaller than its previous element.  \nWe can locate it in `O(log\u202fn)` time with a binary\u2011search\u2011like algorithm:\n\n```\nlow  = 0\nhigh = n \u2013 1\n\nwhile low < high\n    mid = (low + high) / 2\n\n    if arr[mid] > arr[high]      // minimum must be in the right half\n        low = mid + 1\n    else                         // minimum is in the left half (or at mid)\n        high = mid\n\n// low == high == index of minimum\n```\n\nWhen the array is not rotated (already sorted) the above loop ends with `low == 0`, giving `0` rotations.\n\nEdge\u2011cases:\n* Empty array \u2192 `0` rotations.\n* Single\u2011element array \u2192 `0` rotations.\n\n---\n\n#### C++ implementation\n\n```cpp\n#include <vector>\n#include <cstddef>    // for size_t\n\n/// @brief Returns the number of cyclic rotations that have\n///        produced the given rotated sorted vector.\n/// @note The vector is assumed to be a rotated version of a sorted\n///       array (ascending order). If the vector is empty or\n///       has one element it returns 0.\n/// @param arr the input vector\n/// @return the rotation count\nsize_t count_rotation(const std::vector<long>& arr)\n{\n    const size_t n = arr.size();\n    if (n <= 1) return 0;          // no rotation possible\n\n    size_t low  = 0;\n    size_t high = n - 1;\n\n    // Binary\u2013search for the minimum element (pivot)\n    while (low < high) {\n        size_t mid = low + (high - low) / 2;\n\n        if (arr[mid] > arr[high])\n            low = mid + 1;         // pivot is to the right\n        else\n            high = mid;            // pivot is at mid or to the left\n    }\n\n    // 'low' (== 'high') is the index of the smallest element\n    return low;\n}\n```\n\n**Complexity Analysis**\n\n*Time* \u2013 `O(log\u202fn)`  \n*Space* \u2013 `O(1)` (only constant extra storage)\n\nThe function follows the algorithm described in the GeeksforGeeks article and uses only standard C++ libraries.", "Below is a **complete, self\u2011contained C++ implementation** that follows the logic described in the GeeksforGeeks article\n([Count of rotations required to generate a sorted vector](https://www.geeksforgeeks.org/count-of-rotations-required-to-generate-a-sorted-vector/)).  \nThe function `count_rotation` works for a **sorted, rotated** array where all elements are unique.  \nFor arrays that are not rotated (i.e., already sorted) the function returns `0`.\n\n```cpp\n#include <vector>\n#include <cstdlib>   // for size_t\n\n/**\n * @brief  Count the number of rotations applied to an ascending sorted array.\n *\n * The array is assumed to be a rotated version of a strictly increasing array.\n * For example:\n *      {15, 18, 2, 3, 6, 12}  -> 2 rotations (pivot index 2).\n *\n * @param  arr  Rotated sorted array (unique elements).\n * @return  Number of rotations (the index of the smallest element).\n *          Returns 0 if the array is empty or already sorted.\n */\nlong count_rotation(const std::vector<long>& arr) {\n    if (arr.empty())\n        return 0;\n\n    size_t n = arr.size();\n    size_t start = 0, end   = n - 1;\n    size_t mid;\n\n    // If the first element is smaller than the last, the array is not rotated.\n    if (arr[start] <= arr[end])\n        return 0;\n\n    while (start <= end) {\n        // Mid-point: (start + end) / 2.\n        mid = start + (end - start) / 2;\n\n        // Check if mid itself is the pivot.\n        if (mid < n - 1 && arr[mid] > arr[mid + 1])\n            return static_cast<long>(mid + 1);   // pivot index = mid + 1\n\n        // Check if mid-1 is the pivot.\n        if (mid > 0 && arr[mid - 1] > arr[mid])\n            return static_cast<long>(mid);       // pivot index = mid\n\n        /* If the mid element is greater than the first element,\n           the left part is sorted; pivot must be in right part. */\n        if (arr[mid] >= arr[start])\n            start = mid + 1;\n        else                    // pivot in left part\n            end = mid - 1;\n    }\n    return 0;   // Should never reach here for a valid rotated sorted array.\n}\n```\n\n### How It Works\n\n1. **Early exit**  \n   If the array is empty or already sorted (`arr[0] <= arr[last]`), the rotation count is `0`.\n\n2. **Binary search**  \n   We repeatedly bisect the array:\n   * If `arr[mid] > arr[mid+1]`, we found the pivot at `mid+1`.\n   * If `arr[mid-1] > arr[mid]`, the pivot is at `mid`.\n   * If `arr[mid] >= arr[start]`, the left half is sorted; search right.\n   * Otherwise, search left.\n\n3. **Return**  \n   The function returns the index of the smallest element, which equals the number of rotations applied to the original sorted array.\n\n### Example\n\n```cpp\nint main() {\n    std::vector<long> v = {15, 18, 2, 3, 6, 12};\n    std::cout << count_rotation(v) << std::endl;   // Outputs: 2\n}\n```\n\nThe implementation runs in `O(log n)` time and `O(1)` extra space, matching the optimal solution described in the reference article.", "Here is a clean, self\u2011contained C++ implementation of the algorithm described in the GeeksforGeeks article.  \nThe code follows the idea of finding the index of the minimum element in a rotated sorted array \u2013 that index is exactly the number of rotations performed.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// @brief   Count the number of left\u2011rotations that produce a sorted vector\n/// @param   arr  Rotated, sorted, distinct element vector (or empty)\n/// @return  0 if the vector is already sorted, otherwise the rotation count\n///\n/// The function runs in O(log n) time by binary searching for the minimum element.\n/// The element at the minimum position is the original first element of the sorted array.\n/// Its index (0\u2011based) is the number of rotations that have been applied.\nint countRotation(const vector<long> &arr)\n{\n    int n = static_cast<int>(arr.size());\n    if (n <= 1)            // Empty or single element \u2013 already sorted.\n        return 0;\n\n    // If the array is sorted and not rotated \u2013 first element is <= last element.\n    if (arr[0] <= arr[n - 1])\n        return 0;\n\n    // Binary search between low and high to locate the minimum.\n    int low  = 0;\n    int high = n - 1;\n\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n\n        /* If mid element is smaller than its previous element, it is the\n         * minimum element (pivot). */\n        if (mid > 0 && arr[mid] < arr[mid - 1])\n            return mid;\n\n        /* If mid element is greater than the last element, the pivot\n         * lies on the right half. */\n        if (arr[mid] > arr[high])\n            low = mid + 1;\n        else\n            high = mid - 1;\n    }\n\n    // The loop normally exits via the mid>0 && arr[mid] < arr[mid-1] check\n    // but we return 0 as a safe fallback.\n    return 0;\n}\n\n/************  Example usage & test harness  ************/\nint main()\n{\n    vector<long> a1 = {15, 18, 2, 3, 6, 12};\n    cout << \"Rotations in a1: \" << countRotation(a1) << endl;   // 2\n\n    vector<long> a2 = {7, 9, 11, 12, 5};\n    cout << \"Rotations in a2: \" << countRotation(a2) << endl;   // 4\n\n    vector<long> a3 = {1, 2, 3, 4, 5};\n    cout << \"Rotations in a3: \" << countRotation(a3) << endl;   // 0\n\n    vector<long> a4 = {};  // empty\n    cout << \"Rotations in a4: \" << countRotation(a4) << endl;   // 0\n\n    return 0;\n}\n```\n\n### How it works\n\n* If the array is already sorted, `arr[0] <= arr[n-1]`, no rotations were done \u2192 return `0`.\n* Otherwise we perform a binary search:\n  * If `arr[mid]` is smaller than its predecessor, `mid` is the index of the minimum \u2192 that index is the rotation count.\n  * If `arr[mid]` is larger than the last array element, the pivot lies to the right, so shift `low` to `mid+1`.\n  * Otherwise the pivot is to the left, so shift `high` to `mid-1`.\n\nThe algorithm runs in `O(log n)` time, `O(1)` auxiliary space, and works for arrays with distinct elements. If the elements might not be distinct, you will need to modify the comparison logic accordingly."]}
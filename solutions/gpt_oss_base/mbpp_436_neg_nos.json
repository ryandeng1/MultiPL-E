{"name": "mbpp_436_neg_nos", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to return the negative numbers in a vector.\nstd::vector<long> neg_nos(std::vector<long> list1) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_436_neg_nos.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = neg_nos;\n    assert(candidate((std::vector<long>({(long)-1, (long)4, (long)5, (long)-6}))) == (std::vector<long>({(long)-1, (long)-6})));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)3, (long)4}))) == (std::vector<long>({(long)-1, (long)-2})));\n    assert(candidate((std::vector<long>({(long)-7, (long)-6, (long)8, (long)9}))) == (std::vector<long>({(long)-7, (long)-6})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a complete, self\u2011contained C++ example that:\n\n1. Implements the requested function `neg_nos` that returns a vector of all negative values from the input vector.\n2. Demonstrates how to call the function and print the result.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\n/* -------------------------------------------------------------\n   Return a new vector containing only the negative numbers\n   from the input vector `v`.\n   ------------------------------------------------------------- */\nstd::vector<long> neg_nos(const std::vector<long>& v)\n{\n    // Use a vector to hold the result\n    std::vector<long> negatives;\n\n    // Reserve enough capacity to avoid reallocations (optional)\n    negatives.reserve(v.size());\n\n    // Copy every negative element to the result vector\n    std::copy_if(v.begin(), v.end(),\n                 std::back_inserter(negatives),\n                 [](long x){ return x < 0; });\n\n    return negatives;\n}\n\n/* -------------------------------------------------------------\n   Helper routine to print a vector of long integers\n   ------------------------------------------------------------- */\nvoid print_vec(const std::vector<long>& v, const std::string& name = \"vec\")\n{\n    std::cout << name << \" = [\";\n    for (size_t i = 0; i < v.size(); ++i)\n    {\n        std::cout << v[i];\n        if (i + 1 != v.size()) std::cout << \", \";\n    }\n    std::cout << \"]\\n\";\n}\n\nint main()\n{\n    // Example data \u2013 feel free to change it\n    std::vector<long> data = { 12, -7, 0, -13, 5, -1, 30 };\n\n    std::cout << \"Original data:\\n\";\n    print_vec(data);\n\n    // Call the function and obtain the negative numbers\n    std::vector<long> negatives = neg_nos(data);\n\n    std::cout << \"\\nNegative numbers extracted:\\n\";\n    print_vec(negatives);\n\n    return 0;\n}\n```\n\n### How it works\n- **`neg_nos`** takes the input vector *by constant reference* to avoid copying the whole vector.\n- It uses `std::copy_if` with a lambda that checks `x < 0`.  \n  All elements satisfying the predicate are appended to the `negatives` vector.\n- The function returns this new vector.\n\n### Compile & run\n\n```bash\ng++ -std=c++17 -O2 -Wall -Wextra -pedantic -o neg nos_example.cpp\n./neg\n```\n\nYou should see output similar to:\n\n```\nOriginal data:\nvec = [12, -7, 0, -13, 5, -1, 30]\n\nNegative numbers extracted:\nvec = [-7, -13, -1]\n```\n\nFeel free to replace the vector contents or integrate `neg_nos` into your own project.", "Here\u2019s a clean, self\u2011contained C++ function that extracts the negative numbers from a `std::vector<long>` and returns them in a new vector.  \nFeel free to drop this into your source file or adapt it for a larger project.\n\n```cpp\n#include <vector>\n\n/**\n * @brief Extracts all negative values from the input vector.\n *\n * @param list1 The vector of long integers to scan.\n * @return std::vector<long> A vector containing only the negative numbers,\n *         preserving their order from the original vector.\n */\nstd::vector<long> neg_nos(const std::vector<long>& list1)\n{\n    std::vector<long> negatives;\n    negatives.reserve(list1.size());  // reserve worst\u2011case capacity\n\n    for (long val : list1)\n    {\n        if (val < 0)\n            negatives.push_back(val);\n    }\n\n    return negatives;\n}\n```\n\n### Quick Notes\n\n| Feature | Comment |\n|---------|---------|\n| **Const\u2011reference** | The input vector is taken by const reference to avoid an unnecessary copy. |\n| **Reserve** | `reserve(list1.size())` limits reallocations; the final size is typically less than that but this is a small optimization. |\n| **Ordering** | The function preserves the original order of negative numbers. |\n| **Return by value** | Uses move semantics in modern C++ (C++11+) so no extra copy costs. |\n\n### Usage Example\n\n```cpp\nint main()\n{\n    std::vector<long> numbers { 12, -4, 0, -7, 9, -1 };\n    std::vector<long> neg = neg_nos(numbers);\n\n    for (long n : neg) {\n        std::cout << n << ' ';\n    }   // Output: -4 -7 -1\n}\n```\n\nHappy coding!", "Below is a tiny, self\u2011contained **Python** function that returns a list of the negative numbers found in the input sequence.  \nIt works with any iterable of numbers (lists, tuples, NumPy arrays, etc.), but the signature shown in the question uses a Python `list[:]`. The function keeps the original order of the elements, just filtering out everything that isn\u2019t negative.\n\n```python\nfrom typing import Iterable, List\n\ndef neg_nos(seq: Iterable[int | float]) -> List[int | float]:\n    \"\"\"\n    Return a list containing only the negative numbers from *seq*.\n\n    Parameters\n    ----------\n    seq : Iterable[int | float]\n        The input sequence.  Commonly a list, but any iterable\n        of integers or floats will work.\n\n    Returns\n    -------\n    List[int | float]\n        A new list that contains every element e from *seq* for which\n        e < 0, in the original order.\n\n    Example\n    -------\n    >>> neg_nos([1, -3, 0, -5, 7])\n    [-3, -5]\n\n    >>> neg_nos((-2, -4, 6))\n    [-2, -4]\n    \"\"\"\n    return [x for x in seq if x < 0]\n```\n\n### Why this code?\n\n1. **Simple list\u2011comprehension** \u2013 `x for x in seq if x < 0` scans the input once and keeps only the elements that satisfy the `< 0` condition.  \n2. **Preserves order** \u2013 The iteration is in the same order as the incoming iterable.  \n3. **Type\u2011agnostic** \u2013 It works with everything that implements the iterator protocol (`list`, `tuple`, `set`, generator, etc.).  \n4. **Pure Python** \u2013 No external dependencies or extra imports beyond the standard library (`typing` for optional static\u2011typing hints).\n\n### Tests\n\n```python\nimport unittest\n\nclass TestNegNos(unittest.TestCase):\n    def test_basic(self):\n        self.assertEqual(neg_nos([1, -2, 3, -4]), [-2, -4])\n\n    def test_all_negative(self):\n        self.assertEqual(neg_nos([-1, -2]), [-1, -2])\n\n    def test_none_negative(self):\n        self.assertEqual(neg_nos([0, 1, 2]), [])\n\n    def test_tuple_input(self):\n        self.assertEqual(neg_nos((-3, 4, -5)), [-3, -5])\n\n    def test_empty(self):\n        self.assertEqual(neg_nos([]), [])\n\nif __name__ == \"__main__\":\n    unittest.main()\n```\n\nHappy coding!"]}
{"name": "mbpp_606_radian_degree", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to convert degrees to radians.\nfloat radian_degree(long degree) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_606_radian_degree.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = radian_degree;\n    assert(candidate((90)) == (1.5707963267948966f));\n    assert(candidate((60)) == (1.0471975511965976f));\n    assert(candidate((120)) == (2.0943951023931953f));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a compact, standard\u2011conforming implementation.  \nIt uses `constexpr` for \u03c0 (so the conversion is done at compile\u2011time if the argument is a constant) and a `static_assert` to guarantee that the input is a valid integer type.  \n\n```cpp\n#include <cmath>      // for std::atan\n#include <type_traits>\n\n/**\n * @brief  Convert an angle in degrees to radians.\n * @param  degree  The angle in degrees (whole number).\n * @return The angle in radians as a `float`.\n *\n * The function works for any integral type (`int`, `long`,\n * `unsigned`, etc.).  The returned value is a `float` to stay\n * consistent with the original signature.\n */\nfloat radian_degree(long degree) {\n    // \u03c0 defined as constexpr so we can use it in noexcept and static contexts.\n    constexpr double pi = std::atan(1) * 4;          // 3.141592653589793\u2026\n    static_assert(std::is_integral_v<long>, \"Input must be an integral type\");\n\n    // Perform the conversion.\n    return static_cast<float>(degree * (pi / 180.0));\n}\n```\n\n### Why this implementation?\n\n| Reason | Details |\n|--------|---------|\n| **Accuracy** | `atan(1)*4` yields \u03c0 to the maximum precision of the double type. |\n| **Type Safety** | `static_assert` ensures the function is used with an integral type. |\n| **Return Type** | `float` matches the original prototype, trading a tiny precision loss for consistency. |\n| **Portable** | Only `<cmath>` and `<type_traits>` are required, no compiler\u2011specific macros like `M_PI`. |\n| **Efficiency** | The multiplication `degree * (pi / 180.0)` is performed in double and then cast to `float`, which is fast enough for typical use. |\n\nIf you prefer an even more lightweight version without `static_assert`, you can simply write:\n\n```cpp\nfloat radian_degree(long degree) {\n    constexpr double pi = std::atan(1) * 4;\n    return static_cast<float>(degree * (pi / 180.0));\n}\n```\n\nBoth versions correctly convert any integer degree value to its radian equivalent.", "```cpp\n#include <cmath>      // for M_PI or std::acos\n#include <limits>     // for std::numeric_limits\n\n// Convert degrees to radians.\n// The function checks that the input is a finite number\n// and that the conversion does not overflow.\nfloat radian_degree(long degree)\n{\n    // The conversion factor from degrees to radians is PI / 180.\n    constexpr float factor = static_cast<float>(M_PI) / 180.0f;\n\n    // Prevent overflow: a long with a very large absolute value may\n    // produce a float that exceeds the representable range.\n    if (std::abs(static_cast<long double>(degree)) > \n        std::numeric_limits<float>::max() / factor)\n    {\n        // Under a real\u2011world scenario we might throw an exception\n        // or return a special value. Here we simply clamp to the\n        // nearest representable float.\n        return (degree > 0) ? std::numeric_limits<float>::max()\n                            : -std::numeric_limits<float>::max();\n    }\n\n    // Perform the conversion.\n    return static_cast<float>(degree) * factor;\n}\n```\n\n### Why this implementation\n\n| Reason | What it does |\n|--------|--------------|\n| **Accuracy** | Uses `M_PI` from `<cmath>` for the most precise value of \u03c0 available at compile time. |\n| **Range safety** | Checks that `degree * factor` will fit into a `float`. If not, it returns the largest positive or negative representable float. |\n| **Portability** | Relies only on standard headers (`<cmath>`, `<limits>`), no non\u2011standard extensions. |\n| **Simplicity** | The function is single\u2011valued and free of side effects, making it trivial to unit\u2011test. |\n\nThis function is ready for use wherever you need a fast, safe conversion from degrees to radians. If you need full `double` accuracy, just replace all `float` typed entities with `double`.", "Here\u2019s a compact, self\u2011contained implementation:\n\n```cpp\n#include <cmath>        // for M_PI\n\n// Convert degrees \u2192 radians (floating\u2011point result)\ninline double radian_degree(double degree)\n{\n    // M_PI is \u03c0 (3.141592653589793...). Multiply and divide.\n    return degree * M_PI / 180.0;\n}\n```\n\n**Explanation**\n\n* `M_PI` (from `<cmath>`) holds \u03c0 with full `double` precision.\n* The function accepts a `double` (more general than `long`) and\n  returns a `double`.  \n* The conversion formula is  \n  \\[\n  \\text{radians} = \\text{degrees} \\times \\frac{\\pi}{180}\n  \\]\n* Declaring it `inline` allows the compiler to substitute the\n  expression directly, avoiding any function\u2011call overhead."]}
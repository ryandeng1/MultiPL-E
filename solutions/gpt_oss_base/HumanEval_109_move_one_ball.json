{"name": "HumanEval_109_move_one_ball", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_109_move_one_ball.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n", "stop_tokens": ["\n}"], "completions": ["**Answer \u2013 C++ implementation**\n\n```cpp\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball(std::vector<long> arr)\n{\n    const std::size_t n = arr.size();\n    if (n == 0 || n == 1) return true;            // empty or single element\n\n    // Find the index of the minimum element\n    std::size_t min_idx = 0;\n    for (std::size_t i = 1; i < n; ++i)\n        if (arr[i] < arr[min_idx]) min_idx = i;\n\n    // Build a rotated copy that starts with the minimum element\n    std::vector<long> rotated;\n    rotated.reserve(n);\n    for (std::size_t i = 0; i < n; ++i)\n        rotated.push_back(arr[(min_idx + i) % n]);\n\n    // Check that the rotated vector is non\u2011decreasing\n    for (std::size_t i = 1; i < n; ++i)\n        if (rotated[i] < rotated[i-1]) return false;\n\n    return true;\n}\n```\n\n**Explanation**\n\n*   Because all elements are unique, the sorted sequence is completely determined.\n*   A right shift is equivalent to a left shift by `n\u2011k`.  \n    Hence a vector can be sorted by some number of right shifts iff it is a *cyclic shift* of the sorted ascending vector.\n*   The smallest element must become the first element after a suitable rotation.  \n    We locate its index (`min_idx`) and rebuild the array starting from that point.\n*   If the rebuilt sequence is non\u2011decreasing, the original array can be sorted by the required right\u2011shift operations; otherwise it cannot.\n\nThe function runs in `O(N)` time and uses `O(N)` additional space for the rotated copy (the space can be removed by checking the condition with modular indices if desired).", "**Solution Explanation**\n\nFor an array `arr` we can perform a *right shift* any number of times.\nA right shift by `k` positions means\n\n```\nnew[i] = arr[(i - k + N) % N]        (0 \u2264 i < N)\n```\n\n(`N` \u2013 number of elements).  \n`k = 0` means no shift, `k = 1` is a single right shift, etc.\n\nThe goal is to know whether there exists a `k` such that after the shift\nthe resulting array is sorted in non\u2011decreasing order.\n\n--------------------------------------------------------------------\n\n#### Observations\n\n* All numbers are unique \u2013 this makes the checking easier.\n* If the array is sorted after a shift, then it is a **rotation** of the\n  perfectly sorted array.\n\nSo the task reduces to:  \n\u201cIs `arr` a rotation of its sorted version?\u201d\n\n--------------------------------------------------------------------\n\n#### Algorithm\n```\nif arr is empty:   return true\n\nsorted = copy of arr\nsort(sorted)                     // ascending order\n\nk = (N - idx_of(sorted[0] in arr)) % N\n\nfor i from 0 to N-1\n    if arr[(i - k + N) % N] != sorted[i]\n         return false\n\nreturn true\n```\n\n*`idx_of(sorted[0] in arr)`* \u2013 the position of the smallest element of\nthe sorted array inside the original array.  \nThe calculated `k` is the number of right shifts that would bring this\nsmallest element to index `0`, i.e. to its place in the sorted array.\n\nThe final loop verifies that all elements line up correctly after that\nshift.\n\n--------------------------------------------------------------------\n\n#### Correctness Proof  \n\nWe prove that the algorithm returns `true` iff the array can be sorted\nby right shifts.\n\n**Lemma 1**  \nLet `k` be calculated as above.  \nAfter shifting `arr` right by `k` positions the element at index `0`\nequals `sorted[0]`.\n\n*Proof.*  \n`idx0 = idx_of(sorted[0] in arr)`.  \nAfter shifting right by `k = (N - idx0) % N` we have\n\n```\nnew[0] = arr[(0 - k + N) % N] \n       = arr[(0 - (N-idx0) + N) % N] \n       = arr[ idx0 ] \n       = sorted[0]      (by definition of idx0)\n```\n\n\u220e\n\n**Lemma 2**  \nIf some right shift of `arr` equals `sorted`, then the algorithm\nreturns `true`.\n\n*Proof.*  \nAssume a shift `t` exists such that `arr` shifted right by `t` equals\n`sorted`.  \nBecause the smallest element of `sorted` is at position `0` after that\nshift, by Lemma&nbsp;1 the algorithm chooses the same shift `k = t`.  \nThe subsequent loop compares each position of the rotated array with the\ncorresponding element of `sorted`.  \nSince they are identical (by assumption), the loop never returns\n`false` and the algorithm finally returns `true`. \u220e\n\n**Lemma 3**  \nIf the algorithm returns `true`, then a right shift of `arr` equals\n`sorted`.\n\n*Proof.*  \nThe algorithm returns `true` only when the loop finishes without finding\na mismatch.  \nThus for all `i`\n\n```\narr[(i - k + N) % N] = sorted[i]\n```\n\nwhich is exactly the definition of \u201c`arr` shifted right by `k` equals\n`sorted`\u201d. \u220e\n\n**Theorem**  \nThe algorithm returns `true` iff the given array can be sorted by any\nnumber of right shift operations.\n\n*Proof.*  \n- If it can be sorted (statement A), lemma&nbsp;2 shows the algorithm\n  outputs `true`.\n- If the algorithm outputs `true` (statement B), lemma&nbsp;3 shows a\n  valid shifting exists.\n\nTherefore statements A and B are equivalent. \u220e\n\n--------------------------------------------------------------------\n\n#### Complexity Analysis\n\nLet `N` be the array length.\n\n* Sorting: `O(N log N)`\n* Finding index and the verification loop: `O(N)`\n\nOverall time complexity: **`O(N log N)`**  \nSpace usage: sorting in place plus a copy of the array \u2192 **`O(N)`**.\n\n--------------------------------------------------------------------\n\n#### Reference Implementation (C++17)\n\n```cpp\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball(std::vector<long> arr) {\n    const std::size_t N = arr.size();\n    if (N == 0) return true;          // empty array is already sorted\n\n    // copy and sort\n    std::vector<long> sorted = arr;\n    std::sort(sorted.begin(), sorted.end());   // ascending, unique elements\n\n    // find index of the smallest element in the original array\n    long first = sorted[0];\n    std::size_t idx0 = 0;\n    for (std::size_t i = 0; i < N; ++i)\n        if (arr[i] == first) { idx0 = i; break; }\n\n    // number of right shifts that would bring the smallest element to front\n    std::size_t k = (N - idx0) % N;\n\n    // verify that all elements align after that shift\n    for (std::size_t i = 0; i < N; ++i) {\n        std::size_t src = (i + N - k) % N;   // index in original array\n        if (arr[src] != sorted[i]) return false;\n    }\n    return true;\n}\n```\n\nThe code follows exactly the algorithm proven correct above and\nconforms to the C++17 standard.", "```cpp\n#include <vector>\n#include <algorithm>\n#include <cstddef>\n\n/*\n * Determine if the array can be sorted in non\u2011decreasing order\n * by performing an arbitrary number of right\u2011shift (circular rotation)\n * operations.\n *\n * For a circular array this is equivalent to checking whether there is a\n * single index i such that:\n *   arr[i] > arr[i+1]    (mod N)\n * and all other adjacent pairs are in increasing order.\n * If the array is empty or already sorted (i.e., no such inversion exists),\n * the answer is true.\n */\nbool move_one_ball(std::vector<long> arr)\n{\n    const std::size_t n = arr.size();\n    if (n <= 1)\n        return true;                     // empty or single element\n\n    std::size_t inversions = 0;\n    for (std::size_t i = 0; i < n; ++i) {\n        std::size_t j = (i + 1) % n;     // next index in circular fashion\n        if (arr[i] > arr[j])\n            ++inversions;\n        if (inversions > 1)              // early exit\n            return false;\n    }\n    return true;                         // 0 or 1 inversion \u2192 sortable\n}\n```\n\n### How it works\n* We scan the array once, counting how many times an element is larger than its\n  right neighbor when we view the array as a circle (the last element's\n  neighbor is the first element).\n* If the count of such \"inversions\" is more than one, the array cannot become\n  fully sorted by any rotation.\n* If the count is `0` (already sorted) or `1` (exactly one rotation point),\n  the array can indeed be sorted by rotating it enough times.\n\nThe algorithm runs in **O(n)** time and uses **O(1)** additional space."]}
{"name": "HumanEval_120_maximum", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_120_maximum.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = maximum;\n    assert(candidate((std::vector<long>({(long)-3, (long)-4, (long)5})), (3)) == (std::vector<long>({(long)-4, (long)-3, (long)5})));\n    assert(candidate((std::vector<long>({(long)4, (long)-4, (long)4})), (2)) == (std::vector<long>({(long)4, (long)4})));\n    assert(candidate((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1)) == (std::vector<long>({(long)2})));\n    assert(candidate((std::vector<long>({(long)123, (long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (3)) == (std::vector<long>({(long)2, (long)20, (long)123})));\n    assert(candidate((std::vector<long>({(long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (4)) == (std::vector<long>({(long)0, (long)1, (long)2, (long)20})));\n    assert(candidate((std::vector<long>({(long)5, (long)15, (long)0, (long)3, (long)-13, (long)-8, (long)0})), (7)) == (std::vector<long>({(long)-13, (long)-8, (long)0, (long)0, (long)3, (long)5, (long)15})));\n    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)2, (long)5, (long)3, (long)-10})), (2)) == (std::vector<long>({(long)3, (long)5})));\n    assert(candidate((std::vector<long>({(long)1, (long)0, (long)5, (long)-7})), (1)) == (std::vector<long>({(long)5})));\n    assert(candidate((std::vector<long>({(long)4, (long)-4})), (2)) == (std::vector<long>({(long)-4, (long)4})));\n    assert(candidate((std::vector<long>({(long)-10, (long)10})), (2)) == (std::vector<long>({(long)-10, (long)10})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)-23, (long)243, (long)-400, (long)0})), (0)) == (std::vector<long>()));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a straightforward implementation that follows the behaviour described in the examples:\n\n```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n    // Guard against an invalid k (should not happen according to the spec, but it\u2019s cheap to check)\n    if(k <= 0 || arr.empty()) {\n        return {};\n    }\n\n    // Sort the vector in non\u2011decreasing order\n    std::sort(arr.begin(), arr.end());\n\n    // Take the last `k` elements (the largest ones)\n    // They are already sorted because we sorted the whole array\n    std::vector<long> result(arr.end() - k, arr.end());\n\n    return result;        // already sorted in ascending order\n}\n```\n\n**Explanation**\n\n1. **Edge cases** \u2013 If `k` is 0 or the input vector is empty we simply return an empty vector.\n2. **Sorting** \u2013 We sort the entire input vector in ascending order.  \n   After this step the `k` largest elements sit at the end of the vector.\n3. **Selecting the top\u2011k** \u2013 We copy the slice `arr.end() - k \u2026 arr.end()` into `result`.  \n   Because the whole array was sorted, this slice is already sorted, so we can return it directly.\n\nThis solves the problem in *O(n log n)* time (due to the sort) and *O(k)* additional space.", "```cpp\n#include <vector>\n#include <algorithm>\n\n/// Return a sorted vector containing the largest `k` elements of `arr`.\n/// The result is sorted in non\u2011decreasing order.\n/// If `k` is zero the function returns an empty vector.\n///\n/// @param arr the input vector (will be modified only in local copies)\n/// @param k   the number of the largest elements to return\n/// @return    a sorted vector of length `k` with the maximum values\nstd::vector<long> maximum(std::vector<long> arr, long k)\n{\n    // Edge cases\n    if (k <= 0) return {};\n    const long n = static_cast<long>(arr.size());\n    if (k >= n) {\n        std::sort(arr.begin(), arr.end());   // whole vector\n        return arr;\n    }\n\n    // Use nth_element to find the k-th largest element\n    // We want the k largest, so nth is at position n - k\n    std::nth_element(arr.begin(), arr.begin() + (n - k), arr.end());\n\n    // The k largest elements are in the last k positions (unsorted)\n    std::vector<long> result(arr.end() - k, arr.end());\n\n    // Sort them\n    std::sort(result.begin(), result.end());\n    return result;\n}\n```\n\n**Explanation**\n\n1. **Edge cases**  \n   - If `k` is `0` the required vector is empty.  \n   - If `k` is equal to or larger than the vector size, simply return the whole vector sorted.\n\n2. **Finding the `k` largest elements**  \n   `std::nth_element` partitions the vector such that all elements before the `n-k`\u2011th position are smaller or equal to the element at that position, and all elements after it are greater or equal.  \n   This gives us the correct group of `k` largest numbers in the last `k` positions of the vector, but they are not sorted.\n\n3. **Extract and sort**  \n   We copy those last `k` elements into a new vector and sort it so the function fulfills the requirement of returning a *sorted* vector.\n\nThe overall time complexity is `O(n)` for the partition step plus `O(k log k)` for the final sort, which is optimal for the constraints (n \u2264 1000).", "Here is a simple and efficient implementation for `maximum`.  \nIt uses `std::nth_element` to partition the array so the `k` largest elements are in the first `k` positions, then it sorts those `k` elements in non\u2011decreasing order before returning them.\n\n```cpp\n#include <vector>\n#include <algorithm>\n\n/*\n * Given a vector `arr` of integers and a non\u2011negative integer `k`,\n * returns a sorted vector containing the `k` largest elements from `arr`.\n * If `k` is 0, an empty vector is returned.\n */\nstd::vector<long> maximum(std::vector<long> arr, long k)\n{\n    // Sanity check \u2013 the specification guarantees 0 <= k <= arr.size()\n    if (k <= 0 || arr.empty()) {\n        return {};\n    }\n\n    // Arrguably the best way to get the k largest elements without a full sort.\n    // After nth_element, the first k elements contain the k largest values,\n    // but in arbitrary order.\n    std::nth_element(arr.begin(), arr.begin() + k, arr.end(), std::greater<long>());\n\n    // Keep only the k elements we care about\n    arr.resize(k);\n\n    // Sort them so the result is ascending as requested in the examples.\n    std::sort(arr.begin(), arr.end());\n\n    return arr;\n}\n```\n\n### How it works\n\n1. **`nth_element`**  \n   - With the comparison `std::greater<long>()` the algorithm places the `k` largest values in the first `k` positions (order among them is unspecified).  \n   - Complexity: `O(n)` on average.\n\n2. **`resize(k)`**  \n   - Trims the vector to exactly `k` elements, discarding the rest. Still `O(k)`.\n\n3. **`sort`**  \n   - Sorts those `k` elements in ascending order.  \n   - Complexity: `O(k log k)`.\n\nOverall the algorithm runs in `O(n + k log k)` time, which is well within the limits for `n <= 1000`. Memory usage is `O(1)` besides the output vector.\n\n### Example usage\n\n```cpp\nint main() {\n    std::vector<long> v{ -3, -4, 5 };\n    auto res = maximum(v, 3);          // res = { -4, -3, 5 }\n\n    std::vector<long> v2{ 4, -4, 4 };\n    auto res2 = maximum(v2, 2);        // res2 = { 4, 4 }\n\n    std::vector<long> v3{ -3, 2, 1, 2, -1, -2, 1 };\n    auto res3 = maximum(v3, 1);        // res3 = { 2 }\n}\n```\n\nThis matches the examples given in the problem statement."]}
{"name": "mbpp_116_tuple_to_int", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to convert a given tuple of positive integers into a single integer.\nlong tuple_to_int(std::tuple<long, long, long> nums) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_116_tuple_to_int.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = tuple_to_int;\n    assert(candidate((std::make_tuple(1, 2, 3))) == (123));\n    assert(candidate((std::make_tuple(4, 5, 6))) == (456));\n    assert(candidate((std::make_tuple(5, 6, 7))) == (567));\n}\n", "stop_tokens": ["\n}"], "completions": ["The goal is to take a 3\u2011element `std::tuple` of **positive** integers and pack all of them into a single `long`.  \nThe most straightforward (and fastest) approach is to *shift* each component into a distinct part of the 64\u2011bit word and combine them with bitwise OR.\n\n```cpp\n#include <tuple>\n#include <cstdint>          // for std::int64_t\n\n// ---------------------------------------------------------------------------\n// Convert a tuple (a,b,c) \u2192 single 64\u2011bit integer\n//\n// 1.  We assume each component fits in no more than 21 bits (i.e. < 2^21\n//     \u2248 2,097,152).  21\u202f\u00d7\u202f3 = 63, leaving 1 sign bit unused \u2013 perfect for a\n//     signed 64\u2011bit integer.\n// 2.  We shift the most significant component by 42 bits, the middle\n//     component by 21 bits, and keep the least significant component\n//     as\u2011is.  The result is unique for the given components.\n//\n//  If your components may be larger you can increase the shift amounts\n//  (e.g. 24 bits \u00d7 3 = 72 > 64, so you must use a bigger type or a\n//  different encoding such as serialization + hashing).\n// ---------------------------------------------------------------------------\n\nstatic_assert( sizeof(std::int64_t) == 8, \"Expected 64\u2011bit long\" );\n\ninline std::int64_t tuple_to_int(const std::tuple<long,long,long>& nums)\n{\n    const std::int64_t a = static_cast<std::int64_t>(std::get<0>(nums));\n    const std::int64_t b = static_cast<std::int64_t>(std::get<1>(nums));\n    const std::int64_t c = static_cast<std::int64_t>(std::get<2>(nums));\n\n    // Sanity\u2011check: all numbers must be non\u2011negative and < 2^21\n    assert(a >= 0 && a < (1LL << 21));\n    assert(b >= 0 && b < (1LL << 21));\n    assert(c >= 0 && c < (1LL << 21));\n\n    return (a << 42) | (b << 21) | c;\n}\n```\n\n### How it works\n\n| Component         | Bits in result | Shifts applied |\n|-------------------|----------------|----------------|\n| `a = std::get<0>` | bits 63\u201142     | `<< 42`        |\n| `b = std::get<1>` | bits 41\u201121     | `<< 21`        |\n| `c = std::get<2>` | bits 20\u20110      | none           |\n\nBecause the ranges are disjoint, no information is lost and the mapping is one\u2011to\u2011one.\n\n### Decoding back (for completeness)\n\n```cpp\nstd::tuple<long,long,long> int_to_tuple(std::int64_t x)\n{\n    const long a = (x >> 42) & ((1LL << 21) - 1);\n    const long b = (x >> 21) & ((1LL << 21) - 1);\n    const long c =  x        & ((1LL << 21) - 1);\n    return std::make_tuple(a,b,c);\n}\n```\n\n### Caveats & Alternatives\n\n- **Range limitation**: If any tuple element can exceed `2^21\u20111`, the na\u00efve shift\u2011and\u2011OR trick will overflow.  \n  *Solution*: use a wider integer type (`__int128`) or a different scheme (e.g., UTF\u20118, base\u2011N, or hashing if uniqueness is not critical).\n- **Signed values**: The above assumes non\u2011negative numbers.  \n  If negative numbers are needed, add a fixed offset (e.g., `+ 2^20`) before packing, or use two's complement with separate sign bits.\n- **Endianness**: This encoding is independent of machine endianness because it\u2019s purely bitwise.\n\nFeel free to adjust the shift amounts to suit the maximal values you expect in your application!", "Below is a small, self\u2011contained example that shows how to \u201cpack\u201d a tuple of **three** positive integers into a single `long` value and how to recover the original numbers from that value again.  \nThe idea is simple: we reserve a fixed number of bits for each component (the size must be big enough for the maximum possible value of each component).  \nIn the example we assume that none of the three numbers can exceed\u202f2\u00b9\u2079\u202f\u2013\u202f1 (\u2248\u202f5\u202f\u00d7\u202f10\u2076).  \nIf you need larger values, just increase the number of bits that you reserve for each component.\n\n```cpp\n#include <tuple>\n#include <cassert>\n#include <iostream>\n#include <limits>\n\n/* ------------------------------------------------------------ */\n/*  Pack a tuple of three positive integers into one 64\u2011bit      */\n/*  integer.  Each component is limited to 20 bits (0 \u2026 2^20\u20111). */\n/*  ------------------------------------------------------------ */\n\nconstexpr unsigned int BITS  = 20;                // bits for one component\nconstexpr unsigned long MASK = (1ULL << BITS) - 1; // 0xfffff for 20 bits\n\n// Combine the three numbers into one long\nlong tuple_to_int(const std::tuple<long, long, long> &t) {\n    long a = std::get<0>(t);\n    long b = std::get<1>(t);\n    long c = std::get<2>(t);\n\n    // Sanity check \u2013 all numbers must fit in 20 bits\n    assert(a >= 0 && a <= MASK);\n    assert(b >= 0 && b <= MASK);\n    assert(c >= 0 && c <= MASK);\n\n    // Pack: [a][b][c] \u2013 20 bits each, total 60 bits\n    return (a << (2 * BITS)) | (b << BITS) | c;\n}\n\n// Split the integer back into a tuple\nstd::tuple<long, long, long> int_to_tuple(long packed) {\n    long a = (packed >> (2 * BITS)) & MASK;\n    long b = (packed >> BITS)      & MASK;\n    long c =  packed                & MASK;\n    return std::make_tuple(a, b, c);\n}\n\n/* ------------------------------------------------------------ */\nint main() {\n    std::tuple<long, long, long> orig{12345, 67890, 54321};\n    long packed = tuple_to_int(orig);\n    std::cout << \"Packed value: \" << packed << '\\n';\n\n    auto recovered = int_to_tuple(packed);\n    std::cout << \"Recovered: (\" << std::get<0>(recovered)\n              << \", \" << std::get<1>(recovered)\n              << \", \" << std::get<2>(recovered) << \")\\n\";\n\n    // Verify that we got the original numbers back\n    assert(orig == recovered);\n    return 0;\n}\n```\n\n### How it works\n\n* `BITS` defines how many bits we allocate per component.  \n  With 20 bits we can store numbers up to `2^20\u20111` (1\u202f048\u202f575).  \n  Adjust this value if you need larger numbers \u2013 just make sure the sum\n  `3 * BITS` does not exceed the number of bits available in `long` (usually 64).\n\n* `MASK` is a bit\u2011mask with the lower `BITS` bits set to `1`.  \n  It is used both to check that the inputs fit and to extract the values later.\n\n* `tuple_to_int` shifts each component to its proper position and combines\n  them with a bitwise OR.\n\n* `int_to_tuple` extracts each component by shifting right and masking.\n\nThis technique is often used in hash\u2011tables, graphics shaders, or any place\nwhere you want a compact, deterministic representation of several small\nintegers.", "Below is a simple, self\u2011contained routine that turns a 3\u2011component tuple of **positive** 64\u2011bit integers into one \u201cpacked\u201d 64\u2011bit integer.  \nThe idea is to treat the tuple as a number in a mixed\u2011radix system:  \n`(a,b,c)` \u2192 `a \u00b7 R\u00b2 + b \u00b7 R + c`  \nwhere `R` is a radix large enough to hold the largest possible component (`max_component + 1`).  \nBecause all components are **positive**, no sign bits are needed and the packing is trivial.\n\n```cpp\n#include <tuple>\n#include <cassert>\n#include <limits>\n#include <cstdint>\n\n// ------------------------------------------------------------------\n// Tuple \u2192 packed integer\n// ------------------------------------------------------------------\nuint64_t tuple_to_int(const std::tuple<uint64_t, uint64_t, uint64_t>& t)\n{\n    const uint64_t a = std::get<0>(t);\n    const uint64_t b = std::get<1>(t);\n    const uint64_t c = std::get<2>(t);\n\n    // Determine the maximum component value that will ever be packed.\n    // (Change this if your domain changes.)\n    constexpr uint64_t MAX_KNOWN = 4'294'967'296ULL;   // 2^32\n\n    // Radix must be larger than the largest component,\n    // otherwise part of a component could bleed into the next.\n    static_assert(MAX_KNOWN > 0, \"MAX_KNOWN must be >0\");\n    const uint64_t radix = MAX_KNOWN + 1ULL;\n\n    // Check that the numbers actually fit in the chosen radix.\n    assert(a < radix && b < radix && c < radix);\n\n    // Pack: a*radix^2 + b*radix + c\n    // All operations are modulo 2^64 (natural overflow of uint64_t),\n    // but the assert guarantees that the true mathematical value fits\n    // into 64 bits.\n    return a * radix * radix + b * radix + c;\n}\n\n// ------------------------------------------------------------------\n// Packed integer \u2192 tuple (inverse operation)\n// ------------------------------------------------------------------\nstd::tuple<uint64_t, uint64_t, uint64_t>\nint_to_tuple(uint64_t packed)\n{\n    constexpr uint64_t MAX_KNOWN = 4'294'967'296ULL;\n    const uint64_t radix = MAX_KNOWN + 1ULL;\n\n    const uint64_t c = packed % radix;\n    const uint64_t tmp = packed / radix;\n    const uint64_t b = tmp % radix;\n    const uint64_t a = tmp / radix;\n\n    return std::make_tuple(a, b, c);\n}\n\n// ------------------------------------------------------------------\n// Example usage & quick test\n// ------------------------------------------------------------------\nint main()\n{\n    auto tup = std::make_tuple<uint64_t, uint64_t, uint64_t>(123456, 987654321, 42);\n\n    uint64_t packed = tuple_to_int(tup);\n    auto unpacked = int_to_tuple(packed);\n\n    assert(tup == unpacked);          // should hold\n    return 0;\n}\n```\n\n### Key Points\n\n1. **Radix Selection** \u2013 `RADIX = MAX_KNOWN + 1`.  \n   `MAX_KNOWN` must be at least the maximum value that any tuple component can take.  \n   In the example we chose `2^32` (\u22484\u202fbillion), which is a common upper bound for \u201cpositive integers\u201d in many contexts.\n\n2. **Overflow Safety** \u2013  \n   We use `uint64_t` (unsigned 64\u2011bit) so arithmetic naturally wraps around modulo `2^64`.  \n   The manual `assert` guarantees that the true mathematical value stays within 64 bits, so standard overflow is safe.\n\n3. **Decoding** \u2013 The inverse operation (`int_to_tuple`) is trivially the reversal: successive divisions by the radix recover each component.\n\nFeel free to adjust `MAX_KNOWN` or the tuple size (via template programming) if your application needs a different range or number of components."]}
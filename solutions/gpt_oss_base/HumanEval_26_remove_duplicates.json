{"name": "HumanEval_26_remove_duplicates", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_26_remove_duplicates.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = remove_duplicates;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4, (long)3, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)5})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Sure! The idea is to walk through the input vector once, keep a set of the elements we\u2019ve already seen, and only push the element to the output if it hasn\u2019t appeared before.\n\n```cpp\n#include <vector>\n#include <unordered_set>\n\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n    std::vector<long> result;\n    std::unordered_set<long> seen;          // remembers what we\u2019ve already taken\n    for (long n : numbers) {\n        if (seen.find(n) == seen.end()) {   // first time we see this value\n            seen.insert(n);\n            result.push_back(n);\n        }\n        // otherwise, skip it \u2013 we already have this element in `result`\n    }\n    return result;\n}\n```\n\n### How it works\n1. `seen` is an *unordered_set* that lets us test quickly (average\u2011case O(1)) whether we have already encountered a number.\n2. We iterate over the original `numbers` vector.\n3. If the current number `n` hasn't been seen before, we insert it into `seen` **and** push it into `result`.\n4. If it has been seen, we just skip it.\n5. The resulting vector preserves the original order of the first occurrence of each element.\n\n### Example\n\n```cpp\nauto v = std::vector<long>{1, 2, 3, 2, 4};\nauto cleaned = remove_duplicates(v);\n// cleaned == {1, 2, 3, 4}\n```\n\nFeel free to tweak the implementation for different integer types or to use a different container if you need the function to work with template types.", "Here is a compact, self\u2011contained implementation that satisfies the specification:\n\n```cpp\n#include <vector>\n#include <unordered_map>\n\n/**\n * From a vector of integers, remove all elements that occur more than once.\n * The order of the remaining elements is preserved.\n *\n * Example\n * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\n * Input:  {1, 2, 3, 2, 4}\n * Output: {1, 3, 4}\n */\nstd::vector<long> remove_duplicates(std::vector<long> numbers)\n{\n    // 1\ufe0f\u20e3 Count the frequency of every element.\n    std::unordered_map<long, size_t> freq;\n    for (long v : numbers) ++freq[v];\n\n    // 2\ufe0f\u20e3 Build the result keeping only the elements whose frequency\n    //     is exactly one.\n    std::vector<long> result;\n    result.reserve(numbers.size());     // avoid reallocations\n\n    for (long v : numbers)\n        if (freq[v] == 1)\n            result.push_back(v);\n\n    return result;\n}\n```\n\n### Why this works\n\n1. **Frequency map** \u2013 We scan the input once and store how many times each value appears (`unordered_map` gives expected\u2011time O(1) insertions and look\u2011ups).  \n2. **Filtering** \u2013 During a second scan we keep an element only when its recorded frequency is `1`.  \n3. **Order preservation** \u2013 Elements are pushed to `result` in the same order they are encountered in the original vector, so the relative ordering of unique values is maintained.  \n4. **Complexity** \u2013  \n   - Time: `O(n)` (two linear passes).  \n   - Space: `O(n)` in the worst case for the frequency map.\n\nYou can test it with the example:\n\n```cpp\n#include <iostream>\n\nint main() {\n    auto v = remove_duplicates({1, 2, 3, 2, 4});\n    for (auto x : v) std::cout << x << ' ';\n    // prints: 1 3 4\n}\n```\n\nFeel free to tweak the implementation (e.g., using `std::map` if you need ordered keys) but the core idea remains the same.", "Here\u2019s a complete, self\u2011contained implementation of `remove_duplicates` that satisfies all the requirements:\n\n```cpp\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n    // 1. Count occurrences of every value.\n    std::unordered_map<long, std::size_t> freq;\n    for (auto x : numbers) {\n        ++freq[x];\n    }\n\n    // 2. Keep only elements that appear exactly once.\n    //    The original order is preserved because we iterate over the input vector\n    //    from left to right.\n    std::vector<long> result;\n    result.reserve(numbers.size());          // reserve to avoid reallocations\n    for (auto x : numbers) {\n        if (freq[x] == 1) {\n            result.push_back(x);\n        }\n    }\n\n    return result;\n}\n```\n\n### What the function does\n\n1. **Frequency counting**  \n   We first build a map (`freq`) that counts how many times each value occurs in `numbers`.  \n   `unordered_map` gives us average\u2011case O(1) insertions/access.\n\n2. **Filtering**  \n   A second pass over `numbers` appends only those elements whose frequency is *exactly\u202f1* to `result`.  \n   Because we iterate from beginning to end, the relative order of the retained elements is preserved.\n\n### Complexity\n\n- **Time:** \\(O(n)\\) \u2013 one pass to build the frequency map and another pass to collect the uniques.  \n- **Space:** \\(O(n)\\) \u2013 for the frequency map and the result vector (the map may be up to the size of the input in the worst case).\n\n### Example\n\n```cpp\nint main() {\n    std::vector<long> v = {1, 2, 3, 2, 4};\n    auto r = remove_duplicates(v);   // r == {1, 3, 4}\n}\n```\n\nThe function works for any integer type that is hashable (e.g., `int`, `long`, `long long`, etc.). If you need to keep the input unchanged, the parameter is passed by value, ensuring no side\u2011effects on the caller's vector."]}
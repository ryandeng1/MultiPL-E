{"name": "mbpp_389_find_lucas", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the n'th lucas number.\nlong find_lucas(long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_389_find_lucas.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = find_lucas;\n    assert(candidate((9)) == (76));\n    assert(candidate((4)) == (7));\n    assert(candidate((3)) == (4));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a compact, **iterative** routine that returns the *n\u2011th Lucas number*.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// \\brief  Return the n\u2011th Lucas number.\n/// \\param  n   non\u2011negative integer; 0 \u2192 2, 1 \u2192 1, \u2026\nlong long find_lucas(long long n)\n{\n    if (n == 0) return 2;          // L0\n    if (n == 1) return 1;          // L1\n\n    long long a = 2;   // L0\n    long long b = 1;   // L1\n    for (long long i = 2; i <= n; ++i) {\n        long long c = a + b;  // Li  = Li-1 + Li-2\n        a = b;\n        b = c;\n    }\n    return b;          // b holds Ln\n}\n```\n\n### Why this works\n\n* **Lucas sequence definition**  \n  \\(L_0 = 2,\\; L_1 = 1,\\)  \n  \\(L_n = L_{n-1} + L_{n-2}\\) for \\(n \\ge 2\\).\n\n* The loop keeps two variables:\n  * `a` \u2013 \\(L_{i-2}\\)\n  * `b` \u2013 \\(L_{i-1}\\)\n\n  It computes \\(L_i = a + b\\), then shifts the window (`a = b; b = c;`).\n\n* The routine is **O(n)** time, **O(1)** memory and works for any `n` that fits in a signed 64\u2011bit integer.\n\nYou can test it like this:\n\n```cpp\nint main() {\n    for (long long i = 0; i < 10; ++i)\n        cout << \"L\" << i << \" = \" << find_lucas(i) << '\\n';\n}\n```\n\nOutput:\n\n```\nL0 = 2\nL1 = 1\nL2 = 3\nL3 = 4\nL4 = 7\nL5 = 11\nL6 = 18\nL7 = 29\nL8 = 47\nL9 = 76\n```\n\nFeel free to integrate this function into your project.", "Below is a clean, reusable implementation of the *n\u2011th Lucas number*.  \nThe function is non\u2011recursive, runs in **O(n)** time and O(1) space, and it\nhandles 64\u2011bit signed integers safely (it will wrap around if the result\nexceeds `LLONG_MAX` \u2013 you can easily switch to `unsigned long long` or a\nbig integer library if you need bigger values).\n\n```cpp\n#include <cstdint>   // for int64_t\n#include <stdexcept> // for std::out_of_range\n\n/**\n * Returns the n\u2011th Lucas number.\n *\n * Lucas numbers are defined as:\n *   L0 = 2\n *   L1 = 1\n *   Ln = Ln-1 + Ln-2   for n >= 2\n *\n * @param n The index (must be non\u2013negative).\n * @return The n\u2011th Lucas number (int64_t).\n * @throws std::invalid_argument if n is negative.\n */\nint64_t find_lucas(int64_t n)\n{\n    if (n < 0) {\n        throw std::invalid_argument(\"n must be non\u2011negative\");\n    }\n\n    // Base cases\n    if (n == 0) return 2;\n    if (n == 1) return 1;\n\n    int64_t prev2 = 2; // L0\n    int64_t prev1 = 1; // L1\n    int64_t current = 0;\n\n    for (int64_t i = 2; i <= n; ++i) {\n        current = prev1 + prev2;\n        prev2 = prev1;\n        prev1 = current;\n    }\n    return current;\n}\n```\n\n### How it works\n\n1. **Input validation** \u2013 if `n` is negative we throw an exception.\n2. **Base cases** \u2013 return the known values for `n == 0` and `n == 1`.\n3. **Iterative loop** \u2013 starting from `i = 2`, compute `Ln = Ln-1 + Ln-2`,\n   keeping only the last two values. This keeps the memory usage constant.\n\n### Example\n\n```cpp\n#include <iostream>\n\nint main() {\n    for (int n = 0; n <= 10; ++n) {\n        std::cout << \"L(\" << n << \") = \" << find_lucas(n) << '\\n';\n    }\n    return 0;\n}\n```\n\nOutput\n\n```\nL(0) = 2\nL(1) = 1\nL(2) = 3\nL(3) = 4\nL(4) = 7\nL(5) = 11\nL(6) = 18\nL(7) = 29\nL(8) = 47\nL(9) = 76\nL(10) = 123\n```\n\nFeel free to adapt the return type or add a modulo argument if you want the\nLucas numbers modulo some `m`.", "**Solution Explanation**\n\nThe Lucas sequence is defined by\n\n```\nL0 = 2\nL1 = 1\nLn = Ln\u20111 + Ln\u20112     ( n \u2265 2 )\n```\n\nSo it is the same recurrence as the Fibonacci numbers, only the initial\nvalues are different.  \nThe task is to return `Ln` for an input `n` (0\u2011based index).\n\nBecause the input type in the skeleton is `long`, we will use a 64\u2011bit\ninteger (`long long`).  \nThe straightforward iterative method is fast enough for all values that\nfit into a 64\u2011bit integer (the sequence grows roughly as \u03c6\u207f, so `Ln`\noverflows around n \u2248 92).\n\n--------------------------------------------------------------------\n\n### Algorithm\n```\nfunction find_lucas(n):\n    if n == 0: return 2\n    if n == 1: return 1\n    a = 2          // L0\n    b = 1          // L1\n    for i from 2 to n:\n        c = a + b  // Ln = Ln-1 + Ln-2\n        a = b\n        b = c\n    return b\n```\n\n--------------------------------------------------------------------\n\n### Correctness Proof  \n\nWe prove by induction that after the loop finishes the variable `b`\ncontains `Ln`.\n\n*Base cases*  \n- `n = 0`: function returns 2, which equals `L0`.  \n- `n = 1`: function returns 1, which equals `L1`.\n\n*Induction step*  \nAssume after an iteration with index `i-1` (where `i \u2265 2`) the\nvariables satisfy  \n`a = L(i-2)` and `b = L(i-1)`.  \nThe loop computes  \n`c = a + b = L(i-2) + L(i-1) = Li`.  \nThen `a` is updated to the old `b` (`L(i-1)`) and `b` to `c` (`Li`).\nThus before the next iteration the invariant holds with `i` replaced by\n`i+1`.  \n\nBy induction the invariant holds for all iterations, and after the\nfinal iteration (i = n) `b = Ln`.  \nTherefore the function returns the correct Lucas number.\n\n--------------------------------------------------------------------\n\n### Complexity Analysis\n\nThe loop runs `n-1` times.\nEach iteration does O(1) work (one addition and two assignments).  \nSo:\n\n- Time complexity: **O(n)**\n- Memory usage: **O(1)**\n\n--------------------------------------------------------------------\n\n### Reference Implementation (GNU\u2011C++17)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Returns the n-th Lucas number (0\u2011based)\nlong long find_lucas(long long n) {\n    if (n == 0) return 2;\n    if (n == 1) return 1;\n\n    long long a = 2;   // L0\n    long long b = 1;   // L1\n\n    for (long long i = 2; i <= n; ++i) {\n        long long c = a + b;  // Ln = Ln-1 + Ln-2\n        a = b;\n        b = c;\n    }\n    return b;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    long long n;\n    if (!(cin >> n)) return 0;\n    cout << find_lucas(n) << '\\n';\n    return 0;\n}\n```\n\nThe program follows exactly the algorithm proven correct above and\nconforms to the GNU++17 compiler."]}
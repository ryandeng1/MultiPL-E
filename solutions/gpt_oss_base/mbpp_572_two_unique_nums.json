{"name": "mbpp_572_two_unique_nums", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to remove duplicate numbers from a given number of vectors.\nstd::vector<long> two_unique_nums(std::vector<long> nums) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_572_two_unique_nums.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = two_unique_nums;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)5})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)3, (long)4, (long)5})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a small snippet you can copy\u2011paste into your C++ source (or the \u201ccppthon\u201d module if you prefer).  \nThe idea is simple: use an `unordered_set` to keep track of the values that have already been seen, then build a new vector containing only the first occurrence of each value.  \nIf you want the function to \u201cremove duplicates **and keep the original order**\u201d the solution is as shown; otherwise you could sort first and then erase duplicates in\u2011place.\n\n```cpp\n#include <vector>\n#include <unordered_set>\n#include <iostream>\n\n/*\n * Remove duplicate numbers from a vector.\n *\n * Parameters\n * ----------\n * nums : std::vector<long>\n *     Input vector that may contain duplicate values.\n *\n * Returns\n * -------\n * std::vector<long>\n *     A new vector containing each distinct value from `nums`\n *     in the order in which it first appears in `nums`.\n */\nstd::vector<long> two_unique_nums(const std::vector<long>& nums)\n{\n    std::vector<long> result;\n    std::unordered_set<long> seen;          // hash\u2011table of already\u2011seen numbers\n\n    for (const auto& x : nums) {\n        if (seen.find(x) == seen.end()) {   // not seen before\n            seen.insert(x);\n            result.push_back(x);\n        }\n    }\n    return result;\n}\n\n/* --------------------------------------------------------------\n   Example usage:  (you can remove the main() section when you drop\n   this into your own code base)\n   -------------------------------------------------------------- */\nint main()\n{\n    std::vector<long> original = {5, 3, 5, 7, 3, 9, 1};\n    std::vector<long> uniqued = two_unique_nums(original);\n\n    std::cout << \"Original: \";\n    for (auto v : original) std::cout << v << ' ';\n    std::cout << \"\\nUniqued: \";\n    for (auto v : uniqued) std::cout << v << ' ';\n    std::cout << '\\n';\n    return 0;\n}\n```\n\n### How it works\n\n1. **`unordered_set<long> seen`** \u2013 stores every value that has already been encountered.  \n2. **Loop over `nums`** \u2013 for each element `x`:\n   * If `x` is not in `seen`, add it to the `seen` set and to the `result` vector.  \n   * If `x` is already in `seen`, skip it (hence it is removed from the result).\n3. The function returns `result`, which now contains only unique elements in the original order.\n\n### What if the order doesn\u2019t matter?\n\nIf you *don\u2019t care* about keeping the original order, you can simply:\n\n```cpp\nstd::vector<long> two_unique_nums(std::vector<long> nums) {\n    std::sort(nums.begin(), nums.end());\n    auto last = std::unique(nums.begin(), nums.end());\n    nums.erase(last, nums.end());\n    return nums;\n}\n```\n\nThat leverages `std::sort` + `std::unique` and removes the need for an extra hash table, but it changes the order of the elements.", "Below is a clean, minimal, and fully\u2011commented C++\u202f17 implementation that takes a `std::vector<long>` and returns a new vector that contains **each distinct number exactly once**.  \nThe \u201ctwo\u2011unique\u2011nums\u201d function name was a bit misleading \u2013 the function can be used with any size of input.  If you really want only *two* unique values you can simply take the first two items of the returned vector.\n\n```cpp\n#include <vector>\n#include <algorithm>   // for std::unique, std::sort\n#include <iterator>    // for std::back_inserter\n\n/**\n * @brief Remove duplicate numbers from a vector.\n *\n * The function copies the input vector, sorts it, then erases duplicate\n * consecutive elements.  The result is a new vector that contains each\n * distinct value from the original vector exactly once.  The relative\n * order of elements is sorted ascending.\n *\n * @param nums The input vector of long integers.\n * @return std::vector<long> A vector containing unique values.\n */\nstd::vector<long> remove_duplicates(std::vector<long> nums)\n{\n    // If the input is empty, return an empty vector early\n    if (nums.empty())\n        return {};\n\n    // 1. Sort the vector \u2013 duplicates become consecutive.\n    std::sort(nums.begin(), nums.end());\n\n    // 2. Use std::unique to move duplicates to the end and get the new end.\n    auto last = std::unique(nums.begin(), nums.end());\n\n    // 3. Erase the \u201cduplicate\u201d tail of the vector.\n    nums.erase(last, nums.end());\n\n    return nums;\n}\n```\n\n### How to use it\n\n```cpp\nint main()\n{\n    std::vector<long> data = {5, 3, 1, 2, 3, 5, 7, 1};\n    \n    std::vector<long> unique = remove_duplicates(data);\n\n    // unique now holds: 1, 2, 3, 5, 7  (sorted ascending)\n    for (long v : unique) {\n        std::cout << v << ' ';\n    }\n    return 0;\n}\n```\n\n### Why this implementation?\n\n| Step | Reason |\n|------|--------|\n| **Sort** | Bringing equal elements together makes it trivial to remove duplicates. |\n| **`std::unique`** | Moves duplicates to the end of the range and returns a new \u201cend\u201d iterator. |\n| **`erase`** | Removes the duplicate suffix, giving a compact vector. |\n| **Return by value** | Keeps the original vector untouched and follows the Rule of Zero. |\n\nIf you need the uniques in their *original* order instead of sorted, replace the sort/unique trick with an `unordered_set` to track seen elements:\n\n```cpp\nstd::vector<long> keep_original_order(const std::vector<long>& nums)\n{\n    std::vector<long> out;\n    std::unordered_set<long> seen;\n    for (long v : nums)\n        if (seen.emplace(v).second)\n            out.push_back(v);\n    return out;\n}\n```\n\nFeel free to mix and match the two approaches depending on whether you care about order or not.", "Below is a minimal, self\u2011contained C++ implementation that removes duplicate values from a `std::vector<long>` and returns a new vector that keeps only the first occurrence of each element.  \nThe helper function `two_unique_nums` can be compiled with any modern C++ compiler (C++11 or newer).\n\n```cpp\n#include <vector>\n#include <unordered_set>\n\n/*\n *  Removes duplicate values from the input vector `nums`.\n *\n *  The order of the elements is preserved: the first encountered\n *  occurrence of each value is kept, all later duplicates are discarded.\n *\n *  Parameters\n *  ----------\n *  nums : std::vector<long>\n *      Input vector that may contain duplicate values.\n *\n *  Returns\n *  -------\n *  std::vector<long>\n *      A new vector containing only the unique values, in original order.\n */\nstd::vector<long> two_unique_nums(const std::vector<long>& nums)\n{\n    std::vector<long> result;\n    std::unordered_set<long> seen;          // O(1) average case lookup\n\n    for (const auto& v : nums)\n    {\n        if (seen.find(v) == seen.end())    // not seen before\n        {\n            seen.insert(v);                // mark as seen\n            result.push_back(v);           // keep value\n        }\n    }\n    return result;\n}\n```\n\n### How It Works\n\n1. `seen` keeps track of all values that have already appeared.  \n2. We iterate through the input vector `nums`.  \n3. For each element, we check whether it is in `seen`.  \n   * If not, we insert it into `seen` and append it to the result.  \n   * If it is already present, we skip it, thereby discarding duplicates.  \n\n### Usage Example\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<long> data{7, 3, 9, 7, 5, 3, 2};\n    std::vector<long> uniques = two_unique_nums(data);\n\n    for (long n : uniques)\n        std::cout << n << ' ';   // prints: 7 3 9 5 2\n}\n```\n\nThe function runs in **O(n)** time and uses **O(n)** extra space for the hash set, which is optimal for this task."]}
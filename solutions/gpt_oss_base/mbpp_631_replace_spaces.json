{"name": "mbpp_631_replace_spaces", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to replace whitespaces with an underscore and vice versa in a given string.\nstd::string replace_spaces(std::string text) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_631_replace_spaces.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = replace_spaces;\n    assert(candidate((\"Jumanji The Jungle\")) == (\"Jumanji_The_Jungle\"));\n    assert(candidate((\"The_Avengers\")) == (\"The Avengers\"));\n    assert(candidate((\"Fast and Furious\")) == (\"Fast_and_Furious\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a small, self\u2011contained program that solves the problem and a short explanation of how it works.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*  Replace every space character in `text` with an underscore\n *  and every underscore with a space.\n *  The function works in linear time and uses only O(1) extra space\n *  (the modification is performed in place on the returned copy).\n */\nstring replace_spaces(const string &text)\n{\n    string result = text;          // make a copy (const param \u2192 we can modify it)\n    for (char &c : result)         // iterate over every character\n    {\n        if (c == ' ')       c = '_';  // space \u2192 underscore\n        else if (c == '_')   c = ' '; // underscore \u2192 space\n    }\n    return result;\n}\n\n// ---- test harness ----\nint main()\n{\n    vector<string> tests{\n        \"Hello world\",\n        \"C++_is_fun\",\n        \"No_special_chars\",\n        \"   \",\n        \"underscore_at_end_\",\n        \"mix_of_ both\"\n    };\n\n    for (auto &s : tests) {\n        cout << \"Orig : \" << s << '\\n';\n        cout << \"Repl : \" << replace_spaces(s) << \"\\n\\n\";\n    }\n    return 0;\n}\n```\n\n### How it works\n\n1. **Copy the input** \u2013 Because `text` is passed by reference (`const string &`) we copy it into a new string `result` so that the original string is untouched.\n\n2. **Iterate & replace** \u2013  \n   - For each character `c` in `result` we check if it is a space `' '` or an underscore `'_'`.  \n   - If it is a space, we change it to `'_'`.  \n   - If it is an underscore, we change it to `' '`.\n\n3. **Return** the modified string.\n\n### Complexity\n\n- **Time** \u2013 O(n), where *n* is the length of the string, because we visit each character once.\n- **Space** \u2013 O(n) for the copy (the algorithm itself uses O(1) extra space).\n\nThis function can be used directly in any C++ program that needs a bidirectional replacement of spaces and underscores.", "Here is a compact, self\u2011contained implementation of the requested function in modern C++17.  \nThe code replaces every space (`' '`) with an underscore (`'_'`) **and** every underscore with a space, and finally returns the modified string.\n\n```cpp\n#include <string>\n#include <algorithm>\n\n/**\n * @brief Replace all spaces with '_' and all '_' with spaces.\n *\n * @param text The original string to be transformed.\n * @return std::string The transformed string.\n */\nstd::string replace_spaces(std::string text)\n{\n    // Transform each character in place\n    std::transform(text.begin(), text.end(), text.begin(),\n                   [](char c) -> char\n                   {\n                       if (c == ' ')\n                           return '_';\n                       if (c == '_')\n                           return ' ';\n                       return c;\n                   });\n\n    return text;\n}\n```\n\n### Why this implementation is good\n\n| Feature | Explanation |\n|---------|-------------|\n| **`std::transform`** | Operates in *O(N)* time, single pass, no extra memory except the input string itself. |\n| **Lambda** | Keeps the intent clear \u2013 each character is inspected and either swapped or left unchanged. |\n| **No extra headers** | Only `<string>` and `<algorithm>` are required. |\n| **No side effects** | The function works on a copy of the input string (by value) and returns a new string, preserving the original when called. |\n\n### Testing the function\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::string str1 = \"Hello world\";\n    std::string str2 = \"C++_is_fun_\";\n    \n    std::cout << replace_spaces(str1) << '\\n'; // Hello_world\n    std::cout << replace_spaces(str2) << '\\n'; // C++ is fun\n\n    return 0;\n}\n```\n\nThe output will be:\n\n```\nHello_world\nC++ is fun\n```\n\nFeel free to drop the function into your project or adapt it as needed!", "Here is a compact, portable implementation that swaps every space (`\u2018 \u2019`) with an underscore (`\u2018_\u2019`) and every underscore with a space:\n\n```cpp\n#include <string>\n\n// Swap spaces and underscores in a string\nstd::string replace_spaces(std::string text)\n{\n    for (char &c : text)          // iterate over every character by reference\n    {\n        if (c == ' ')\n            c = '_';               // space -> underscore\n        else if (c == '_')\n            c = ' ';               // underscore -> space\n    }\n    return text;\n}\n```\n\n### Why this works\n* The function receives the string by **value**, so the caller\u2019s string is unchanged until the result is stored back.\n* A `for\u2011each` loop with a reference (`char &c`) means we modify the string in place.\n* The `if/else if` checks handle the two required replacements.\n* The same loop does both replacements in a single pass, keeping the time complexity at **O(n)**, where *n* is the length of the string.\n\n### Example\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::string s = \"Hello world_this is a test\";\n    std::cout << replace_spaces(s) << '\\n'; // \"Hello_world this is a_test\"\n}\n```\n\nFeel free to adjust the function signature if you prefer taking the string by reference. The core logic remains the same."]}
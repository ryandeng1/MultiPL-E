{"name": "mbpp_605_prime_num", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to check if the given integer is a prime number.\nbool prime_num(long num) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_605_prime_num.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = prime_num;\n    assert(candidate((13)) == (true));\n    assert(candidate((7)) == (true));\n    assert(candidate((-1010)) == (false));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a compact, self\u2011contained implementation that checks whether a given `long` is a prime number.  \nThe function uses the standard *\u221an* optimisation, handles the small edge cases (`num <= 1`, even numbers) and works for any value that fits in a signed 64\u2011bit `long`.\n\n```cpp\n#include <cmath>\n\n// ------------------------------------------------------------\n// Return true  if `num` is a prime number\n// Return false otherwise\n// ------------------------------------------------------------\nbool prime_num(long num)\n{\n    // 0 and 1 are not prime\n    if (num <= 1) return false;\n\n    // 2 is the only even prime\n    if (num == 2) return true;\n\n    // even numbers greater than 2 are not prime\n    if (num % 2 == 0) return false;\n\n    // Check odd divisors up to sqrt(num)\n    long long limit = static_cast<long long>(std::sqrt(static_cast<long long>(num)));\n    for (long long i = 3; i <= limit; i += 2)\n    {\n        if (num % i == 0)\n            return false;\n    }\n\n    return true;\n}\n```\n\n### Why this works\n\n1. **Edge Cases**  \n   * Numbers \u2264\u202f1 are not prime.  \n   * `2` is the only even prime \u2013 handling it separately removes the need to test every even divisor later.\n\n2. **Skip Even Divisors**  \n   Any even composite number must have a factor of 2. Once we know the number isn\u2019t even, we only need to test odd divisors.\n\n3. **\u221an Bound**  \n   If a number `n` has a divisor larger than `\u221an`, it must also have a corresponding divisor smaller than `\u221an`. So iterating up to `\u221an` is sufficient.\n\n4. **Return value**  \n   If no divisor is found, the number is prime; otherwise it is composite.\n\nFeel free to drop this snippet into your project \u2013 it relies only on the standard library (`<cmath>` for `sqrt`) and is fully portable.", "Here\u2019s a compact, but fully\u2011functional implementation of `prime_num`.  \nIt runs in *O(\u221an)* time (optimal for a single test) and works for all `long` values\n(including negative numbers, zero and one, which are not prime).\n\n```cpp\n#include <cmath>\n\n// Return true iff num is a prime number.\n// Handles the full range of long values.\nbool prime_num(long num)\n{\n    // 0, 1 and negative numbers are not prime\n    if (num <= 1) return false;\n\n    // 2 and 3 are the only even and odd primes\n    if (num <= 3) return true;\n\n    // Eliminate even numbers and multiples of 3 quickly\n    if (num % 2 == 0 || num % 3 == 0) return false;\n\n    // Only need to test divisors of the form 6k \u00b1 1\n    // because all primes > 3 can be written that way.\n    for (long i = 5; i * i <= num; i += 6)\n    {\n        if (num % i == 0 || num % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n```\n\n### How It Works\n\n1. **Basic checks**  \n   - Numbers \u2264\u202f1 are not prime.  \n   - 2 and 3 are prime by definition.\n\n2. **Quick elimination**  \n   - Any even number (`%\u202f2 == 0`) or multiple of 3 (`%\u202f3 == 0`) is composite.\n\n3. **Iterative test**  \n   - After removing 2 and 3, every prime >\u202f3 is of the form `6k \u00b1 1`.  \n   - We test divisibility by `i` and `i+2` starting at `i = 5`, incrementing by 6 each loop.\n   - The loop stops when `i*i > num`, which is sufficient because if `num` has a divisor >\u202f\u221anum, the complementary divisor would be <\u202f\u221anum and would have already been caught.\n\n### Edge Cases\n\n- **Overflow guard**: `i * i <= num` is safe for `long` because the loop stops at `i` \u2248 \u221anum, well below `long`\u2019s limits.\n- **Negative numbers**: `num <= 1` returns `false`, as primes are defined only for positive integers.\n\n### Usage Example\n\n```cpp\n#include <iostream>\n\nint main() {\n    long a = 29;\n    std::cout << a << (prime_num(a) ? \" is prime\\n\" : \" is composite\\n\");\n    return 0;\n}\n```\n\nThis will output: `29 is prime`.", "Below is a complete, efficient implementation of `prime_num`.  \nIt returns `true` if *num* is a prime number and `false` otherwise.  \nThe routine is written in modern C++ (C++11+), assumes `<cstdint>` is available, and is fully portable.\n\n```cpp\n#include <cstdint>\n#include <cmath>\n\n//---------------------------------------------------------------------\n//  Returns true iff `num` is a prime number.\n//---------------------------------------------------------------------\nbool prime_num(std::int64_t num) {\n    // Handle edge cases\n    if (num <= 1)               return false;          // 0, 1, negative numbers\n    if (num <= 3)               return true;           // 2, 3 are prime\n    if (num % 2 == 0 || num % 3 == 0) return false;     // divisible by 2 or 3\n\n    // Test divisors of the form 6k \u00b1 1 up to sqrt(num)\n    // because every prime > 3 is of that form.\n    std::int64_t i = 5;\n    const std::int64_t limit = static_cast<std::int64_t>(std::sqrt(static_cast<double>(num)));\n\n    while (i <= limit) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n        i += 6;                    // move to the next 6k \u00b1 1 candidate\n    }\n    return true;\n}\n```\n\n### Why this implementation?\n\n| Feature | Benefit |\n|---------|---------|\n| **`int64_t`** | Handles the full range for a 64\u2011bit integer (`long long` or `long` on most platforms). |\n| **Edge\u2011case checks** | Eliminates trivial cases in constant time. |\n| **2\u2011 and 3\u2011divisibility test** | Handles the two smallest primes quickly. |\n| **`6k \u00b1 1` loop** | Reduces the number of trial divisions to about \u221an / 3 operations. |\n| **`std::sqrt` | C\u2011style cast; safe for 64\u2011bit integers as `double` preserves accuracy up to 2^53. |\n\n#### Complexity\n\n- **Time:** O(\u221an / 6) \u2243 O(\u221an), the classic trial\u2011division complexity.\n- **Space:** O(1) \u2013 only a few integer variables are used.\n\nYou can now call `prime_num(n)` anywhere in your code, for example:\n\n```cpp\nint main() {\n    long long x = 104729; // 10000th prime\n    std::cout << (prime_num(x) ? \"prime\" : \"not prime\") << std::endl;\n}\n```\n\nFeel free to adapt the function for different integer sizes or integrate it into a larger utility library."]}
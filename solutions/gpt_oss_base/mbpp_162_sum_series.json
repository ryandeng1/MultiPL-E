{"name": "mbpp_162_sum_series", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to calculate the sum (n - 2*i) from i=0 to n // 2, for instance n + (n-2) + (n-4)... (until n-x =< 0).\nlong sum_series(long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_162_sum_series.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = sum_series;\n    assert(candidate((6)) == (12));\n    assert(candidate((10)) == (30));\n    assert(candidate((9)) == (25));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a compact and efficient implementation of the requested series:\n\n```cpp\n// Calculate: n + (n-2) + (n-4) + \u2026  until the term becomes <= 0\n// Example: 5 \u2192 5 + 3 + 1 = 9\nlong sum_series(long n)\n{\n    // Number of terms : floor(n/2)+1\n    long k = n / 2 + 1;           // integer division handles floor automatically\n\n    /* Sum of arithmetic sequence:\n       S = k*n - 2 * (0 + 1 + \u2026 + (k-1))\n          = k*n - 2 * (k-1)*k / 2\n          = k*n - (k-1)*k\n    */\n    return k * n - (k - 1) * k;\n}\n```\n\n**Explanation**\n\n1. The series contains all numbers from `n` down to the largest odd (or even) number not less than `0`.  \n2. The count of terms `k` is `floor(n/2) + 1` (integer division by 2 plus one).  \n3. The series is an arithmetic progression with common difference `-2`.  \n4. The sum of an arithmetic progression can be expressed in closed\u2011form, giving the simple `k*n - (k-1)*k` formula.\n\nThis function runs in constant time and uses only a few arithmetic operations, making it efficient for all values of `n` that fit in a `long`.", "Below is a compact, self\u2011contained implementation of `sum_series`.  \nIt uses the closed\u2011form formula for an arithmetic series instead of a loop, so it runs in **O(1)** time and is safe for very large inputs.\n\n```cpp\n#include <cstdint>     // for int64_t\n#include <iostream>\n\n// sum of n + (n-2) + (n-4) + \u2026  until the term becomes non\u2011positive\nlong long sum_series(long long n)\n{\n    if (n < 0) return 0;                // defined behaviour for negative n\n\n    /* See the reasoning below: \n       \u2022 The series is arithmetic with common difference -2.\n       \u2022 The number of terms = floor(n/2) + 1.\n       \u2022 The first term a0 = n.\n       \u2022 The last term a_last = n - 2 * floor(n/2)\n          (0 when n even, 1 when n odd).\n       \u2022 Sum = number_of_terms * (a0 + a_last) / 2.\n    */\n\n    long long k = n / 2;                 // floor(n/2)\n    long long count = k + 1;             // number of terms\n\n    long long a_last = n - 2 * k;        // last term (0 or 1)\n\n    // Use __int128 to avoid overflow when n is large\n    __int128 sum = (__int128)count * (n + a_last) / 2;\n    return static_cast<long long>(sum);\n}\n\nint main()\n{\n    for (long long n = 0; n <= 10; ++n)\n        std::cout << \"n = \" << n << \" -> sum = \" << sum_series(n) << '\\n';\n}\n```\n\n### Explanation\n\n```\nSeries:  n + (n-2) + (n-4) + \u2026 until \u2264 0\n```\n\n1. **Number of terms**  \n   The last non\u2011negative term is reached when  \n   `n - 2*i \u2264 0` \u2192 `i \u2264 n/2`.  \n   So `i` runs from `0` to `floor(n/2)`.  \n   Count `m = floor(n/2) + 1`.\n\n2. **First and last terms**  \n   - First term `a0 = n`.  \n   - Last term `a_last = n - 2*floor(n/2)`  \n     (0 if n even, 1 if n odd).\n\n3. **Arithmetic series sum**  \n   `S = m * (a0 + a_last) / 2`.\n\nUsing `__int128` guarantees correct results even when `n` is as large as 10^18, before converting back to `long long`. Adjust the return type if a larger type is required.", "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n * Returns the sum of the series\n *\n *      n   + (n-2) + (n-4) + ... + (n-2*k)\n *   where   n-2*k  > 0\n *\n * In other words we keep subtracting 2 from n while the result stays\n * strictly positive and we accumulate those values.\n */\nlong long sum_series(long long n)\n{\n    long long sum = 0;\n    long long current = n;\n\n    while (current > 0) {\n        sum += current;\n        current -= 2;\n    }\n\n    return sum;\n}\n\n/* ---------------------   Demo   --------------------- */\nint main()\n{\n    cout << sum_series(10) << '\\n';   // 10 + 8 + 6 + 4 + 2 = 30\n    cout << sum_series(7)  << '\\n';   // 7 + 5 + 3 + 1 = 16\n    cout << sum_series(0)  << '\\n';   // 0\n}\n```\n\n*Explanation*\n\n1. `current` holds the current term of the series.  \n2. While `current > 0` we add it to `sum` and then subtract 2 for the next term.  \n3. When `current` becomes 0 or negative the loop stops \u2013 that\u2019s exactly the stopping condition described in the problem (the last term is the largest positive one).  \n\nThe function uses `long long` so it works safely for large inputs."]}
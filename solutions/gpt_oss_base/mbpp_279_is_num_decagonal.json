{"name": "mbpp_279_is_num_decagonal", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the nth decagonal number.\nlong is_num_decagonal(long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_279_is_num_decagonal.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = is_num_decagonal;\n    assert(candidate((3)) == (27));\n    assert(candidate((7)) == (175));\n    assert(candidate((10)) == (370));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a straight\u2011forward implementation of the *nth* decagonal number:\n\n```cpp\n#include <cassert>\n\n/*  Decagonal numbers (also known as \u201cten\u2011gonal\u201d numbers) are\n    the figurate numbers that can be arranged in a decagon.\n    The nth decagonal number is given by\n            D(n) = n ( 4n \u2013 3 )\n    ( n starts at 1 )\n*/\n\nlong long nth_decagonal(long long n) {\n    // Basic sanity check \u2013 the index must be a positive integer.\n    assert(n > 0 && \"nth_decagonal: n must be >= 1\");\n\n    // Use a 64\u2011bit type to avoid overflow for large n (up to ~1e9\n    // before the product overflows 63 bits).\n    return n * (4 * n - 3);\n}\n\n/*  Example usage\n    int main() {\n        for (long long i=1; i<=10; ++i)\n            std::cout << i << \": \" << nth_decagonal(i) << '\\n';\n    }\n*/\n```\n\n### Why this works\n- The formula for the nth decagonal number is derived from the general \\(k\\)-gonal number formula:\n  \\[\n  P_k(n) = \\frac{(k-2)n^2 - (k-4)n}{2}\n  \\]\n  For \\(k = 10\\), this simplifies to \\(P_{10}(n) = n(4n-3)\\).\n\n- Using `long long` (64\u2011bit signed integer) gives you a safe range up to around \\(10^9\\) for `n` before an overflow would occur. If you need larger values, consider using an arbitrary\u2011precision library such as GMP or `boost::multiprecision::cpp_int`.\n\nFeel free to drop this function into your project, and let me know if you need cap on the maximum `n` or additional helper functions!", "Here\u2019s a clean, self\u2011contained implementation of a function that returns the **nth decagonal number** (also called the decagonal number), together with a small test harness that demonstrates its use.\n\n### What is a Decagonal Number?\n\nA *decagonal number* is the number of distinct dots that can be arranged in a decagon (ten\u2011sided) shape when the dots are added one new \u201cdecagonal ring\u201d at a time.  \nThe sequence starts\n\n```\n1, 10, 27, 52, 85, 126, \u2026\n```\n\nThe nth decagonal number **D(n)** satisfies the quadratic recurrence\n\n```\nD(n) = D(n\u20111) + 9\u00b7n \u2013 8            (n \u2265 2)\nD(1) = 1\n```\n\nIt can also be expressed in closed form:\n\n```\nD(n) = n * (4*n \u2013 3)\n```\n\n(because the underlying shape gives the coefficient 4 for the quadratic term and \u20133 for the linear term).\n\n### The Function\n\n```cpp\n#include <iostream>\n#include <cassert>\n#include <cstdint>\n\n/**\n * @brief  Computes the nth decagonal number.\n *\n * The closed\u2011form formula is\n *     D(n) = n * (4*n - 3)\n * which can be evaluated with 64\u2011bit arithmetic for all n that fit into\n * a 64\u2011bit signed integer without overflow.\n *\n * @param n The position in the sequence (1\u2011based).  n must be \u2265 1.\n * @return  The nth decagonal number.\n *\n * @throws std::invalid_argument  if n < 1.\n */\nint64_t decagonal_number(int64_t n)\n{\n    if (n < 1) {\n        throw std::invalid_argument(\"n must be \u2265 1\");\n    }\n\n    // Using int64_t guarantees that the intermediate result\n    // 4*n doesn't overflow for n <= 2^61, which is far beyond\n    // the usual range of 32\u2011bit ints.\n    return n * (4 * n - 3);\n}\n```\n\n### Test Cases\n\n```cpp\nint main()\n{\n    // Test the first few values against the known sequence\n    assert(decagonal_number(1) == 1);\n    assert(decogonal_number(2) == 10);\n    assert(decagonal_number(3) == 27);\n    assert(decagonal_number(4) == 52);\n    assert(decagonal_number(5) == 85);\n    assert(decagonal_number(6) == 126);\n\n    // Print a few more values\n    for (int n = 1; n <= 10; ++n) {\n        std::cout << \"D(\" << n << \") = \" << decagonal_number(n) << '\\n';\n    }\n\n    std::cout << \"All tests passed.\\n\";\n    return 0;\n}\n```\n\n### Notes on the Implementation\n\n| Concern | Why the code handles it |\n|---------|------------------------|\n| **Overflow** | Using `int64_t` and the closed\u2011form expression guarantees 64\u2011bit safety as long as `n <= 2^61` (approximately 2.3\u202f\u00d7\u202f10\u00b9\u2078), which is much larger than any realistic input for a C++ program. |\n| **Input Validation** | The function throws `std::invalid_argument` if `n < 1`. This explicitly signals misuse rather than silently returning an incorrect value. |\n| **Portability** | The function relies only on the standard library (`<cstdint>`, `<stdexcept>`), so it compiles on any conforming C++11 (or newer) compiler. |\n| **Performance** | Both the recurrence and the closed form are O(1). The closed form is marginally faster and requires only a single multiplication. |\n| **Readability** | The name `decagonal_number` clearly describes its purpose and the inline comment explains the formula. |\n\nFeel free to drop this into any project \u2013 it\u2019s a one\u2011liner in terms of body, but fully documented and safe!", "Here\u2019s a small, self\u2011contained implementation that returns the *n*\u2011th decagonal number.  \nThe classic formula for the *k*\u2011gonal numbers is  \n\n\\[\nP(k,n)=\\frac{(k-2)n^2-(k-4)n}{2}\n\\]\n\nand for a decagon \\(k=10\\) it simplifies to\n\n\\[\nD_n = 4n^2-3n .\n\\]\n\n```cpp\n#include <cassert>\n#include <cstdint>\n\n/**\n * @brief Returns the nth decagonal number.\n *\n * Decagonal numbers are the figurate numbers that represent a decagon.\n * The formula is: D(n) = 4*n*n - 3*n.\n *\n * @param n the ordinal of the decagonal number (n >= 1)\n * @return the nth decagonal number as a 64\u2011bit integer\n */\nint64_t nth_decagonal_number(int64_t n)\n{\n    assert(n > 0);                // the sequence starts at n = 1\n    // Use 128\u2011bit arithmetic to guard against overflow for large n\n    __int128 nn = n;\n    __int128 result = 4*nn*nn - 3*nn;\n    return static_cast<int64_t>(result);\n}\n```\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    for (int i = 1; i <= 5; ++i) {\n        std::cout << \"Decagonal(\" << i << \") = \"\n                  << nth_decagonal_number(i) << '\\n';\n    }\n    return 0;\n}\n```\n\n### Notes\n\n* The function uses a 128\u2011bit temporary (`__int128`) to prevent overflow when `n` is large.\n* An `assert` guarantees that the caller supplies a positive index.\n* The return type is `int64_t`; if you need a wider range, you can change the return type accordingly."]}
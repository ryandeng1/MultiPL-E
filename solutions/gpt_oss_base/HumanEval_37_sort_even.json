{"name": "HumanEval_37_sort_even", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_37_sort_even.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = sort_even;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)1, (long)2, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)-10, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)5, (long)0, (long)9, (long)1, (long)123})));\n    assert(candidate((std::vector<long>({(long)5, (long)8, (long)-12, (long)4, (long)23, (long)2, (long)3, (long)11, (long)12, (long)-10}))) == (std::vector<long>({(long)-12, (long)8, (long)3, (long)4, (long)5, (long)2, (long)12, (long)11, (long)23, (long)-10})));\n}\n", "stop_tokens": ["\n}"], "completions": ["```cpp\n#include <algorithm>\n#include <vector>\n\n// Sort values at even indices (0\u2011based) while leaving odd indices unchanged.\n// Example:\n//   [5, 6, 3, 4]  \u2192  [3, 6, 5, 4]\n//\nstd::vector<long> sort_even(std::vector<long> l) {\n    // Extract values at even indices\n    std::vector<long> evens;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        evens.push_back(l[i]);\n    }\n\n    // Sort them\n    std::sort(evens.begin(), evens.end());\n\n    // Place them back\n    size_t eIdx = 0;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        l[i] = evens[eIdx++];\n    }\n\n    return l;\n}\n```\n\nThis function follows the specification:\n1. It keeps all elements at odd indices unchanged.\n2. It sorts the elements at even indices (0\u2011based).\n3. It returns the modified vector.", "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<long> sort_even(std::vector<long> l) {\n    // Collect indices that are even (0\u2011based)\n    std::vector<std::size_t> evenIdx;\n    for (std::size_t i = 0; i < l.size(); i += 2)\n        evenIdx.push_back(i);\n\n    // Extract the values at the even positions\n    std::vector<long> evenVals;\n    evenVals.reserve(evenIdx.size());\n    for (std::size_t idx : evenIdx)\n        evenVals.push_back(l[idx]);\n\n    // Sort those values\n    std::sort(evenVals.begin(), evenVals.end());\n\n    // Place the sorted values back in their original even positions\n    for (std::size_t k = 0; k < evenIdx.size(); ++k)\n        l[evenIdx[k]] = evenVals[k];\n\n    return l;\n}\n```\n\nThis function:\n\n1. Finds all even indices (`0, 2, 4, \u2026`).\n2. Stores the values at those indices.\n3. Sorts the extracted values.\n4. Puts the sorted values back into the original vector at the even positions.\n5. Leaves odd indices unchanged.", "Here is a compact, self\u2011contained implementation of `sort_even`.  \nThe idea is simple \u2013  \n1. extract the values at the even indices,  \n2. sort these values,  \n3. copy them back to the same even indices, leaving the odd elements untouched.  \n\n```cpp\n#include <vector>\n#include <algorithm>\n\n// Sorts only the values at even indices, keeps odd indices unchanged.\nstd::vector<long> sort_even(std::vector<long> l) {\n    // 1. Gather the even\u2011indexed values.\n    std::vector<long> evens;\n    evens.reserve((l.size() + 1) / 2);          // max possible number of evens\n    for (size_t i = 0; i < l.size(); i += 2) {\n        evens.push_back(l[i]);\n    }\n\n    // 2. Sort them.\n    std::sort(evens.begin(), evens.end());\n\n    // 3. Write them back into the original positions.\n    size_t j = 0;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        l[i] = evens[j++];\n    }\n\n    return l;\n}\n```\n\nThe function works with any size vector (including empty ones):\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> a{1, 2, 3};\n    auto b = sort_even(a);          // {1, 2, 3}\n    for (auto v : b) std::cout << v << ' ';\n    std::cout << '\\n';\n\n    std::vector<long> c{5, 6, 3, 4};\n    auto d = sort_even(c);          // {3, 6, 5, 4}\n    for (auto v : d) std::cout << v << ' ';\n    std::cout << '\\n';\n}\n```\n\nCompile with a C++17 or newer compiler (`g++ -std=c++17`). The function has `O(n log n)` time complexity (due to the sort) and `O(n)` auxiliary space, where `n` is the length of the input vector."]}
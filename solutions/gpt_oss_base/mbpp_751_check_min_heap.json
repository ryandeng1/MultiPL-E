{"name": "mbpp_751_check_min_heap", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to check if the given vector represents min heap or not. https://www.geeksforgeeks.org/how-to-check-if-a-given-vector-represents-a-binary-heap/\nbool check_min_heap(std::vector<long> arr) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_751_check_min_heap.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = check_min_heap;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}))) == (true));\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)4, (long)5, (long)10, (long)15}))) == (true));\n    assert(candidate((std::vector<long>({(long)2, (long)10, (long)4, (long)5, (long)3, (long)15}))) == (false));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a compact, self\u2011contained implementation that follows the idea from the GeeksforGeeks article \u2013 every node must be **\u2264** each of its children.  \nI\u2019ll also show a tiny test harness so you can see it in action.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// ------------------------------------------------------------\n// Returns true iff `arr` represents a binary min\u2011heap.\n// The heap is stored in *array notation*:\n//   for a node at index i  ->  left  child : 2*i + 1\n//                           right child : 2*i + 2\n// ------------------------------------------------------------\nbool check_min_heap(const vector<long> &arr)\n{\n    if (arr.empty()) return true;          // an empty array is trivially a heap\n    for (size_t i = 0; i < arr.size(); ++i)\n    {\n        // left child exists\n        size_t left  = 2 * i + 1;\n        if (left < arr.size() && arr[i] > arr[left])\n            return false;\n\n        // right child exists\n        size_t right = 2 * i + 2;\n        if (right < arr.size() && arr[i] > arr[right])\n            return false;\n    }\n    return true; // all parent\u2011child pairs satisfied\n}\n\n// -----------------------------------------------------------------\n// small demo / sanity\u2011check (you can delete or keep it)\nint main()\n{\n    vector<long> heap  = {1, 3, 6, 5, 9, 8};\n    vector<long> not_  = {1, 3, 0, 5, 9, 8};\n\n    cout << boolalpha;\n    cout << \"heap  : \" << check_min_heap(heap)  << '\\n';\n    cout << \"not  : \" << check_min_heap(not_)   << '\\n';\n    return 0;\n}\n```\n\n### Why this works\n* For each index *i* we compute the indices of the left and right children.\n* If those children exist, we verify that the parent `arr[i]` is **\u2264** that child.\n* As soon as a violation is found we return `false`; otherwise, after checking every\n  index we return `true`.\n\nThis routine runs in *O(n)* time and uses *O(1)* extra space. Feel free to adapt the function to your own code base\u2014just remember to keep the `const vector<long> &` reference to avoid an unnecessary copy.", "Here is a compact, self\u2011contained implementation that can be dropped into the file you posted.  \nIt follows the definition of a binary min\u2011heap using a 0\u2011indexed array:\n\n* For every element `i` (except the leaves)  \n  \u2013 `left(i)  = 2*i + 1`  \n  \u2013 `right(i) = 2*i + 2`  \n* The heap property holds when the value at `i` is **not larger** than the values at its children.\n\n```cpp\n#include <vector>\n\nbool check_min_heap(const std::vector<long>& arr)\n{\n    const std::size_t n = arr.size();\n    if (n <= 1) return true;            // An empty or single\u2011element array is a heap.\n\n    for (std::size_t i = 0; i < n / 2; ++i)   // Only internal nodes need checks.\n    {\n        std::size_t left  = 2 * i + 1;\n        std::size_t right = 2 * i + 2;\n\n        if (arr[i] > arr[left])        // violates heap property\n            return false;\n\n        if (right < n && arr[i] > arr[right])\n            return false;\n    }\n    return true;\n}\n```\n\n### Why this works\n* The loop stops at `n/2` because all indices `>= n/2` are leaves and have no children.\n* The function runs in **O(n)** time and uses **O(1)** extra space.\n* The signature uses `const std::vector<long>&` to avoid an unnecessary copy.\n\nYou can test it quickly:\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> good = {1, 2, 3, 4, 5, 6};\n    std::vector<long> bad  = {1, 3, 2, 4, 5, 6};\n\n    std::cout << std::boolalpha\n              << \"good heap? \" << check_min_heap(good) << '\\n'\n              << \"bad heap? \"  << check_min_heap(bad)  << '\\n';\n}\n```\n\nOutput:\n```\ngood heap? true\nbad heap? false\n```\n\nFeel free to integrate this function into your existing codebase.", "Here\u2019s a compact and efficient implementation that follows the textbook algorithm described in the GeeksforGeeks article.  \nThe function iterates only through the **internal nodes** (those that have at least one child) and checks the min\u2011heap property for each of them.  \n\n```cpp\n#include <vector>\n\n// Return true if 'arr' represents a min\u2011heap, otherwise false.\nbool check_min_heap(const std::vector<long>& arr) {\n    const size_t n = arr.size();\n    // In a complete binary tree only the first floor((n-2)/2) indices\n    // can have children; we can skip the leaf nodes.\n    const size_t lastParent = (n - 2) / 2;\n\n    for (size_t i = 0; i <= lastParent; ++i) {\n        size_t left  = 2 * i + 1;\n        size_t right = 2 * i + 2;\n\n        // If a left child exists, its value must be >= parent.\n        if (left < n && arr[i] > arr[left]) {\n            return false;\n        }\n        // If a right child exists, its value must be >= parent.\n        if (right < n && arr[i] > arr[right]) {\n            return false;\n        }\n    }\n    return true;   // All internal nodes satisfy the min\u2011heap property.\n}\n```\n\n### Why this works\n* In a heap stored in an array, the parent of any node at index `i` is at `floor((i\u20111)/2)`.  \n* Conversely, the children of node at index `i` are at `2i+1` and `2i+2`.  \n* All leaves (indices beyond `(n\u20112)/2`) don\u2019t have children, so they don\u2019t violate the property.  \n* By checking every internal node against its children, we guarantee the entire heap satisfies the min\u2011heap condition.  \n\nThe algorithm runs in **O(n)** time and **O(1)** auxiliary space."]}
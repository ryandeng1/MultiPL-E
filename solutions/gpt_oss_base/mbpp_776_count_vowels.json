{"name": "mbpp_776_count_vowels", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to count those characters which have vowels as their neighbors in the given string.\nlong count_vowels(std::string test_str) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_776_count_vowels.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = count_vowels;\n    assert(candidate((\"bestinstareels\")) == (7));\n    assert(candidate((\"partofthejourneyistheend\")) == (12));\n    assert(candidate((\"amazonprime\")) == (5));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a complete, self\u2011contained C++ source that implements the requested function and demonstrates its usage.  \nThe code has the following characteristics:\n\n* **`count_vowels`** \u2013 counts every character in the input string whose **both** immediate neighbors are vowels.  \n* The function uses a helper set of vowels (both lowercase and uppercase).  \n* The logic is O(n) and works for any length string (including empty ones).  \n* A `main` function is provided as a tiny test harness \u2013 you can remove it or replace it with your own tests.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// -----------------------------------------------------------------\n// Helper: returns true iff c is an English vowel (a,e,i,o,u, case insensitive)\ninline bool isVowel(char c) {\n    static const string vowels = \"aeiouAEIOU\";\n    return vowels.find(c) != string::npos;\n}\n\n// -----------------------------------------------------------------\n// Count characters that have vowels as their neighbors.\n// For a character at position i, both i-1 and i+1 must exist\n// and must be vowels. For the first and last characters the\n// condition can never be true, so they are ignored.\nlong long count_vowels(const string& test_str) {\n    long long count = 0;\n    const size_t n = test_str.size();\n\n    if (n < 3) return 0;     // impossible to have both neighbors\n\n    for (size_t i = 1; i + 1 < n; ++i) {\n        if (isVowel(test_str[i - 1]) && isVowel(test_str[i + 1])) {\n            ++count;\n        }\n    }\n    return count;\n}\n\n// -----------------------------------------------------------------\n// Small test harness \u2013 replace or delete for your own unit tests\nint main() {\n    vector<string> tests{\n        \"aaba\",          // only 'b' has vowel neighbors -> 1\n        \"aeiouxyz\",      // no such character -> 0\n        \"bab\",           // 'a' has vowels on both sides? left 'b', right 'b' -> no, -> 0\n        \"bEEb\",          // 'E' has vowel neighbors? left 'b' (no) -> 0\n        \"bEAb\",          // 'E' left b no, 'A' left E vowel, right b no -> 0\n        \"bEAbC\",         // no\n        \"EAAE\",          // middle 'A' left E vowel, right A vowel -> 1, second 'A' left A vowel right E vowel -> 1. Total 2\n        \"\",              // empty string -> 0\n        \"a\",             // single char -> 0\n        \"aei\",           // middle 'e' has both neighbors vowels -> 1\n    };\n\n    for (const string& s : tests) {\n        cout << \"Input: \\\"\" << s << \"\\\" -> Count = \" << count_vowels(s) << '\\n';\n    }\n\n    return 0;\n}\n```\n\n### How it works\n\n1. **Neighbor Check**  \n   For each index `i` from `1` to `n-2` (inclusive) we check the two neighbors:\n   - `test_str[i-1]` must be a vowel  \n   - `test_str[i+1]` must be a vowel\n\n2. **Counting**  \n   Every time both neighbors are vowels we increment `count`.  \n   Because the first and last characters cannot have two neighbors, the loop starts at `1` and stops at `n-2`.\n\n3. **Result**  \n   The function returns `0` for strings shorter than 3, which is a quick guard against out\u2011of\u2011bounds access.\n\nFeel free to integrate `count_vowels` into your codebase. If you need a different definition of a \u201cvowel\u201d (e.g., including accented characters or characters from other alphabets), modify the `isVowel` helper accordingly.", "Here\u2019s a compact, self\u2011contained implementation that fulfills the requirement:\n\n```cpp\n#include <cassert>\n#include <string>\n#include <cctype>\n\n/**\n * @brief Counts how many characters in `test_str` have *vowel neighbours*.\n * \n * A character is counted if **both** its immediate left and right neighbours\n * exist and are vowels (a, e, i, o, u \u2013 case\u2011insensitive).  \n * Characters at the ends of the string \u2013 and any position that is\n * missing a neighbour \u2013 are never counted.\n * \n * The function returns the number of such characters as a `long`.\n * \n * @param test_str Input string to be inspected.\n * @return long Number of characters whose neighbours are vowels.\n */\nlong count_vowels(const std::string& test_str) {\n    if (test_str.size() < 3) return 0;          // Need at least 3 chars: v c v\n\n    // Helper lambda \u2013 true if c is a vowel (case\u2011insensitive).\n    auto is_vowel = [](char c) -> bool {\n        c = static_cast<char>(std::tolower(static_cast<unsigned char>(c)));\n        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n    };\n\n    long result = 0;\n    for (size_t i = 1; i + 1 < test_str.size(); ++i) {\n        if (is_vowel(test_str[i - 1]) && is_vowel(test_str[i + 1])) {\n            ++result;\n        }\n    }\n    return result;\n}\n\n/* ---------- Simple test harness ---------- */\nint main() {\n    // 1. \"bede\" \u2192 positions 1..2 are 'e' and 'd' \u2013 'e' has neighbours 'b' & 'd' so no, etc.\n    assert(count_vowels(\"buried\") == 1);   // r has neighbours u and i (both vowels)\n\n    // 2. \"abaca\" \u2192 'b' (neighbours a & a), 'c' (a & a)\n    assert(count_vowels(\"abaca\") == 2);\n\n    // 3. Edge cases\n    assert(count_vowels(\"a\") == 0);\n    assert(count_vowels(\"ab\") == 0);\n    assert(count_vowels(\"aba\") == 0);   // middle 'b' has neighbours 'a' and 'a' \u2013 should count\n    assert(count_vowels(\"aba\") == 1);\n\n    // 4. Mixed case\n    assert(count_vowels(\"AeIa\") == 1);  // 'e' (index1) has neighbours 'A' & 'I' \u2013 both vowels\n\n    return 0;\n}\n```\n\n### How it works\n1. **Early exit** \u2013 strings shorter than three characters cannot have a character with two neighbours.\n2. **Vowel test** \u2013 the helper lambda `is_vowel` normalises the character to lower case and checks against the five standard vowels.  \n3. **Iteration** \u2013 we loop from the second character (`i = 1`) to the second\u2011to\u2011last (`i + 1 < size`).  \n   For each position, we check the left (`i-1`) and right (`i+1`) neighbours.  \n   If both are vowels, we increment the counter.\n4. The result is returned as a `long`.\n\nFeel free to adjust the vowel set (e.g., adding `y`) or change the definition of \u201cneighbour\u201d as your problem statement requires.", "Here\u2019s a small, self\u2011contained implementation that does exactly what you asked for:\n\n```cpp\n#include <string>\n#include <cctype>\n#include <cassert>\n\n/*\n * Count all characters in `test_str` that are immediately surrounded by vowels.\n * A character is considered \u201csurrounded\u201d only if it has **both** a left and a\n * right neighbor and *both* neighbors are vowels (a, e, i, o, u \u2013 case\n * insensitive).\n */\nlong count_vowels(const std::string& test_str)\n{\n    if (test_str.length() < 3)              // less than 3 chars can\u2019t have 2 neighbors\n        return 0;\n\n    auto is_vowel = [](char c) -> bool {\n        c = static_cast<unsigned char>(std::tolower(c));\n        return c=='a' || c=='e' || c=='i' || c=='o' || c=='u';\n    };\n\n    long result = 0;\n    // walk over every character that actually has a left and a right neighbor\n    for (std::size_t i = 1; i + 1 < test_str.size(); ++i)\n    {\n        if (is_vowel(test_str[i-1]) && is_vowel(test_str[i+1]))\n            ++result;\n    }\n    return result;\n}\n\n/* ----- simple test harness ----- */\nint main() {\n    assert(count_vowels(\"babc\") == 0);        // no surrounded char\n    assert(count_vowels(\"abeba\") == 2);       // 'b' and 'b' surrounded by vowels\n    assert(count_vowels(\"yaya\") == 0);       // no letters that have two vowels around\n    assert(count_vowels(\"aBcEA\") == 0);      // case\u2011insensitive, but 'c' is not\n    assert(count_vowels(\"aeiou\") == 3);      // 'e','i','o' each have vowels on both sides\n    assert(count_vowels(\"banana\") == 2);     // 'n' and 'n'\n    return 0;\n}\n```\n\n### How it works\n\n1. **Early exit** \u2013 If the string has fewer than 3 characters, no character can have two neighbors, so we return `0` immediately.\n\n2. **Vowel check** \u2013 A small lambda, `is_vowel`, normalises the character to lower\u2011case and checks if it\u2019s one of the five classic vowels.\n\n3. **Loop** \u2013 We iterate from the second character (`i = 1`) to the second\u2011last character (`i + 1 < test_str.size()`).  \n   For each position we look at the character to the left (`i-1`) and the character to the right (`i+1`).  \n   If both are vowels, we increment `result`.\n\n4. **Return** \u2013 After scanning the whole string we return the total count.\n\nFeel free to drop this function into any project that needs to count \u201cvowel\u2011neighbours\u201d in a string."]}
{"name": "HumanEval_57_monotonic", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_57_monotonic.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = monotonic;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)20}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10}))) == (false));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)0, (long)-10}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)1, (long)0}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)5, (long)60}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)60}))) == (true));\n    assert(candidate((std::vector<long>({(long)9, (long)9, (long)9, (long)9}))) == (true));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a clean implementation that works for all legal inputs (an empty or a one\u2011element vector is considered trivially monotonous).  \nThe function first checks if the vector is sorted in non\u2011decreasing order; if that fails, it checks whether every neighbour pair is in non\u2011increasing order. If at least one of those two conditions is true, the vector is monotonic and the function returns `true`; otherwise it returns `false`.\n\n```cpp\n#include <vector>\n#include <algorithm>\n\n// Return true if vector elements are monotonically increasing or decreasing.\nbool monotonic(const std::vector<long>& l)\n{\n    if (l.size() <= 1)\n        return true;                  // An empty or single\u2011element vector is always monotonic.\n\n    // Check for non\u2011decreasing order.\n    bool increasing = true;\n    for (size_t i = 1; i < l.size(); ++i)\n        if (l[i] < l[i-1]) { increasing = false; break; }\n\n    if (increasing) return true;       // Increasing monotonicity satisfied.\n\n    // Check for non\u2011increasing order.\n    bool decreasing = true;\n    for (size_t i = 1; i < l.size(); ++i)\n        if (l[i] > l[i-1]) { decreasing = false; break; }\n\n    return decreasing;                 // true iff strictly decreasing.\n}\n```\n\n**Why this works**\n\n1. **Empty / single element** \u2013 trivial case: *True*.\n2. **Increasing check** \u2013 we walk through the vector once. If any element is smaller than its predecessor, the increasing property is violated.\n3. **Decreasing check** \u2013 analogous to the increasing test but in the opposite direction.\n4. **Return** \u2013 if the vector satisfies either property, it is monotonic.\n\nThe function runs in `O(n)` time and uses `O(1)` additional space.", "Here is a complete implementation of the `monotonic` function.  \nIt checks the sequence for two conditions:\n\n1. The sequence is **strictly increasing** \u2013 every element is larger than the previous one.  \n2. The sequence is **strictly decreasing** \u2013 every element is smaller than the previous one.\n\nIf either condition holds (or if the sequence is empty / has one element) `true` is returned; otherwise `false`.\n\n```cpp\n#include <vector>\n\n/*\n * Returns true if the elements of l are monotonically increasing or decreasing.\n * Monotonic means that all comparisons between consecutive elements are either\n * all non\u2011decreasing or all non\u2011increasing.  (If all elements are equal,\n * the function also returns true.)\n */\nbool monotonic(const std::vector<long>& l)\n{\n    if (l.size() <= 1)          // empty or single element \u2013 trivially monotonic\n        return true;\n\n    // Determine the initial direction ignoring equal elements\n    int direction = 0;          // 0 = undefined,  1 = increasing, -1 = decreasing\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i-1]) {\n            if (direction == -1)       // changed from decreasing to increasing\n                return false;\n            direction = 1;\n        } else if (l[i] < l[i-1]) {\n            if (direction == 1)        // changed from increasing to decreasing\n                return false;\n            direction = -1;\n        }\n        // if equal we just ignore it for direction determination\n    }\n\n    return true;   // either direction was never violated\n}\n```\n\n### Usage Examples\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << monotonic({1, 2, 4, 20}) << '\\n';   // true\n    std::cout << monotonic({1, 20, 4, 10}) << '\\n';  // false\n    std::cout << monotonic({4, 1, 0, -10}) << '\\n'; // true\n    std::cout << monotonic({5, 5, 5, 5}) << '\\n';    // true\n}\n```\n\nThis implementation is simple, runs in O(n) time, and handles all edge cases correctly.", "**Answer:**\n\nHere\u2019s a simple implementation that checks whether the input vector is monotonic (either non\u2011decreasing or non\u2011increasing).  \nYou only need to include this in your file; the rest of the code you posted can stay as is.\n\n```cpp\nbool monotonic(std::vector<long> l) {\n    if (l.size() <= 1) return true;          // A single element (or empty) is trivially monotonic\n\n    bool increasing  = true;\n    bool decreasing  = true;\n\n    for (size_t i = 0; i + 1 < l.size(); ++i) {\n        if (l[i] < l[i+1]) decreasing = false;   // element is larger \u2192 cannot be decreasing\n        if (l[i] > l[i+1]) increasing = false;   // element is smaller \u2192 cannot be increasing\n        if (!increasing && !decreasing) break;   // early exit: neither monotonic\n    }\n\n    return increasing || decreasing;\n}\n```\n\n**Explanation**\n\n1. **Base case** \u2013 A vector with 0 or 1 element is automatically monotonic.\n2. **Flags** \u2013 Two boolean flags keep track of whether the vector could still be\n   *non\u2011decreasing* (`increasing`) or *non\u2011increasing* (`decreasing`).\n3. **Scan** \u2013 As we traverse the vector:\n   * If a pair of adjacent elements violates the decreasing pattern, set\n     `decreasing = false`.\n   * If a pair violates the increasing pattern, set `increasing = false`.\n4. **Early exit** \u2013 If both flags turn `false`, we can quit the loop early.\n5. **Result** \u2013 The vector is monotonic if either flag remains `true`.\n\nFeel free to drop this function into your file and call it exactly as you demonstrated with the examples."]}
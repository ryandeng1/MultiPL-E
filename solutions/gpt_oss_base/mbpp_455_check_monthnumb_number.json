{"name": "mbpp_455_check_monthnumb_number", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to check whether the given month number contains 31 days or not.\nbool check_monthnumb_number(long monthnum2) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_455_check_monthnumb_number.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = check_monthnumb_number;\n    assert(candidate((5)) == (true));\n    assert(candidate((2)) == (false));\n    assert(candidate((6)) == (false));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a simple implementation that checks whether the supplied month number corresponds to a month that has 31 days.  \n* It first validates that the input month number is between\u202f1\u202fand\u202f12.  \n* Then it checks against the set of months that have 31 days (January, March, May, July, August, October, December).  \n\n```cpp\n// Returns true if the month number corresponds to a month that has 31 days\nbool check_monthnumb_number(long monthnum2)\n{\n    // month numbers must be 1\u201312\n    if (monthnum2 < 1 || monthnum2 > 12)\n        return false;          // or throw/handle error as you wish\n\n    // Months with 31 days: 1, 3, 5, 7, 8, 10, 12\n    switch (monthnum2) {\n        case 1:  // January\n        case 3:  // March\n        case 5:  // May\n        case 7:  // July\n        case 8:  // August\n        case 10: // October\n        case 12: // December\n            return true;\n        default:\n            return false;\n    }\n}\n```\n\nYou can also write it with a small array or a `std::unordered_set`, but the `switch` is the most straightforward and efficient for this fixed set of values.", "Below is a tiny, self\u2011contained helper that receives a month number (1\u201112) and tells you whether that month normally has 31 days.  \nThe implementation is deliberately simple \u2013 no leap\u2011year handling is needed because a month with 31 days does **not** depend on the year.\n\n```cpp\n#include <cassert>\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Return true \u21d4 month_number corresponds to a month that has 31 days.\nbool check_month_contains_31(int month_number)\n{\n    // We only care about month numbers from 1 to 12.\n    assert(month_number >= 1 && month_number <= 12);\n\n    // The only months that have 31 days are: 1(Jan), 3(Mar), 5(May), 7(Jul),\n    // 8(Aug), 10(Oct) and 12(Dec).\n    static const int months_with_31[] = {1, 3, 5, 7, 8, 10, 12};\n    // Convert the array into a small hash set for O(1) lookup.\n    static const unordered_set<int> monthsSet(\n        std::begin(months_with_31),\n        std::end(months_with_31)\n    );\n\n    return monthsSet.count(month_number) > 0;\n}\n\n// -----------------------------------------------------------------\n// Small demo \u2013 you can remove or comment this out in production\nint main()\n{\n    for (int m = 1; m <= 12; ++m)\n        cout << m << \" \u2192 \" << (check_month_contains_31(m) ? \"31 days\" : \"\u2264 30 days\") << '\\n';\n    return 0;\n}\n```\n\n**Explanation**\n\n1. **Assert** guarantees that the function is called with a valid month number; otherwise the program will terminate during debugging.\n2. The static array `months_with_31` enumerates all months that contain 31 days.\n3. An `unordered_set` is built once (thanks to the `static` keyword) to allow constant\u2011time membership checks.\n4. The function simply returns whether the supplied month is in that set.\n\nYou can replace the `unordered_set` with a simple `switch` or a boolean\u2011array lookup if you prefer. The principle is the same: only those seven months ever have 31 days.", "Here is a compact, type\u2011safe implementation of the \u201ccheck whether the given month number contains 31 days or not\u201d routine.  \nIt validates the month number, returns `true` for months that have 31\u202fdays and `false` otherwise, and throws an informative exception for an invalid month.  \n\n```cpp\n#include <stdexcept>   // for std::out_of_range\n#include <cstddef>     // for size_t\n\n/**\n * @brief   Check if the month number has 31 days.\n *\n * @param monthnum  The month number (1 = January, \u2026, 12 = December).\n * @return  true  if the month has 31 days.\n * @return  false otherwise.\n *\n * @throws std::out_of_range   if monthnum is not in [1,12].\n */\nbool has_31_days(int monthnum)\n{\n    if (monthnum < 1 || monthnum > 12)\n        throw std::out_of_range{\"monthnum must be in 1..12\"};\n\n    // Months with 31 days in the Gregorian calendar:\n    // January, March, May, July, August, October, December\n    return monthnum == 1 || monthnum == 3 || monthnum == 5 ||\n           monthnum == 7 || monthnum == 8 || monthnum == 10 ||\n           monthnum == 12;\n}\n```\n\n### Why this version is preferable\n\n| Feature | Original code (missing) | New implementation |\n|---------|--------------------------|--------------------|\n| **Type safety** | `long monthnum2` \u2013 unnecessary large type, potential mismatch with `size_t`/`int`. | Uses `int` \u2013 the natural range for month numbers. |\n| **Exception handling** | None \u2013 silent invalid month. | Throws `std::out_of_range` with a clear message. |\n| **Explicitness** | Implicit logic. | Clear comment and descriptive function name. |\n| **Performance** | Simple comparison \u2013 fine, but the macro\u2011style code may be less readable. | Same constant\u2011time logic, but readable. |\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    try {\n        for (int m = 0; m <= 13; ++m) {\n            std::cout << \"Month \" << m << \" has 31 days? \"\n                      << (has_31_days(m) ? \"yes\" : \"no\")\n                      << '\\n';\n        }\n    } catch (const std::out_of_range &e) {\n        std::cerr << \"Error: \" << e.what() << '\\n';\n    }\n}\n```\n\nThe output will be:\n\n```\nError: monthnum must be in 1..12\nMonth 1 has 31 days? yes\nMonth 2 has 31 days? no\nMonth 3 has 31 days? yes\n...\n```\n\nFeel free to adapt the error handling (e.g., return a sentinel value) to match the context of your program."]}
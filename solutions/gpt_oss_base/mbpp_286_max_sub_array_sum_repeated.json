{"name": "mbpp_286_max_sub_array_sum_repeated", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the largest sum of a contiguous vector in the modified vector which is formed by repeating the given vector k times.\nlong max_sub_array_sum_repeated(std::vector<long> a, long n, long k) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_286_max_sub_array_sum_repeated.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = max_sub_array_sum_repeated;\n    assert(candidate((std::vector<long>({(long)10, (long)20, (long)-30, (long)-1})), (4), (3)) == (30));\n    assert(candidate((std::vector<long>({(long)-1, (long)10, (long)20})), (3), (2)) == (59));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3})), (3), (3)) == (-1));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a complete, self\u2011contained implementation of the function you started.  \nIt follows the standard \u201cmaximum sub\u2011array sum on a repeated array\u201d algorithm:\n\n* For one copy of the array we run Kadane\u2019s algorithm to obtain  \n  \u2013 `max_once`  \u2013 the maximum sub\u2011array sum that ends anywhere in the *single* array.  \n  \u2013 `max_prefix` \u2013 maximum prefix sum of one copy.  \n  \u2013 `max_suffix` \u2013 maximum suffix sum of one copy.  \n  \u2013 `total_sum` \u2013 sum of all elements of the base array.\n* If `k == 1` the answer is simply `max_once`.\n* If `total_sum <= 0` then repeating the array won\u2019t help: the best sub\u2011array is still confined\n  to at most two copies, so the answer is `max(max_once, max_suffix + max_prefix)`.\n* If `total_sum > 0` the best sub\u2011array can embrace the whole middle part\n  (all copies except the first and the last ones).  \n  The value is then  \n  `max_suffix + total_sum * (k\u20112) + max_prefix`.\n\nAll edge\u2011cases are covered (empty array, single element, negative values, etc.).  \nThe code runs in *O(n)* time and *O(1)* extra memory.\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n/**\n * @brief Computes the largest sum of a contiguous sub\u2011array in a vector formed\n *        by repeating the given vector `k` times.\n *\n * @param a Input vector (will be modified during the algorithm; pass by value).\n * @param n Number of elements in `a`.  (For convenience \u2013 can be deduced from a.size())\n * @param k How many times the array is repeated.\n * @return The maximum contiguous sub\u2011array sum in the repeated structure.\n */\nlong max_sub_array_sum_repeated(std::vector<long> a, long n, long k)\n{\n    if (n == 0 || k == 0) return 0;               // empty array or no repetition\n\n    // ----- Kadane on single copy ---------------------------------------\n    long max_once = a[0];\n    long current   = a[0];\n    long total_sum = a[0];\n\n    for (long i = 1; i < n; ++i) {\n        current = std::max(a[i], current + a[i]);\n        max_once = std::max(max_once, current);\n        total_sum += a[i];\n    }\n\n    // ----- Prefix and Suffix sums ------------------------------------\n    long max_prefix = a[0], prefix = a[0];\n    for (long i = 1; i < n; ++i) {\n        prefix += a[i];\n        max_prefix = std::max(max_prefix, prefix);\n    }\n\n    long max_suffix = a[n - 1], suffix = a[n - 1];\n    for (long i = n - 2; i >= 0; --i) {\n        suffix += a[i];\n        max_suffix = std::max(max_suffix, suffix);\n    }\n\n    // ----- Result based on k ------------------------------------------\n    if (k == 1) return max_once;\n\n    // Two copies may be enough when total_sum <= 0\n    long ans = std::max(max_once, max_suffix + max_prefix);\n    if (total_sum > 0) {\n        ans = std::max(ans,\n                       max_suffix + total_sum * (k - 2) + max_prefix);\n    }\n\n    return ans;\n}\n\n/* ------------------  Example usage and basic tests ------------------ */\n#include <iostream>\nint main() {\n    std::vector<long> v = {-1, 2, 3, -5, 4};\n    std::cout << max_sub_array_sum_repeated(v, 5, 3) << '\\n';  // should output 10\n\n    // Basic sanity checks\n    assert(max_sub_array_sum_repeated({1, 2, 3}, 3, 1) == 6);\n    assert(max_sub_array_sum_repeated({-1, -2, -3}, 3, 5) == -1);\n    assert(max_sub_array_sum_repeated({-1, 2, -1}, 3, 2) == 3);\n    std::cout << \"All tests passed.\\n\";\n    return 0;\n}\n```\n\n**Explanation of the algorithm**\n\n1. **Kadane\u2019s algorithm** gives the maximum sub\u2011array for a single copy.  \n2. **Prefix / Suffix** are needed because the optimal sub\u2011array may start in one fragment\n   (suffix of the first copy) and finish in another (prefix of the last copy).  \n3. If the total sum of one copy is **non\u2011positive**, it is never useful to\n   include more than two copies; the best sub\u2011array is either fully inside a single copy\n   or spans at most the suffix of one copy and the prefix of the next.  \n4. If the total sum is **positive**, the best solution will take the *whole middle*\n   part of the repeated array, i.e., all the copies between the first and the last,\n   because adding a positive sum always increases the result.\n5. Complexity: O(n) time, O(1) extra space.\n\nFeel free to adapt the I/O part or remove the test harness as needed.", "Here\u2019s a complete, self\u2011contained implementation of the function.  \nIt uses Kadane\u2019s algorithm for the original vector, handles the special case when every\nelement is negative, and deals with the \u201crepeated\u201d part efficiently (O(n) time, O(1) extra\nmemory).\n\n```cpp\n#include <algorithm>\n#include <vector>\n#include <numeric>\n#include <cassert>\n\n/*\n * Return the maximum sub\u2011array sum obtainable from the vector a repeated k times.\n *\n * Parameters\n *  a \u2013 original vector (length n)\n *  n \u2013 the length of a (convenient for the caller \u2013 we also use a.size())\n *  k \u2013 number of times the vector is repeated\n *\n * The algorithm is O(n) time, O(1) extra space.  It follows the classic\n * \u201cmaximum sub\u2011array sum in a circular array\u201d technique but extended to\n * k repetitions.  It also correctly handles the all\u2011negative case.\n */\nlong max_sub_array_sum_repeated(const std::vector<long> &a, long n, long k)\n{\n    // Guard against empty input \u2013 undefined behaviour per the spec, but\n    // we return 0 to avoid crashes during debugging.\n    if (n <= 0 || a.empty() || k <= 0)\n        return 0;\n\n    // 1. Single\u2011pass Kadane on the original array: maximum sub\u2011array\n    //    sum assuming we start anywhere in first copy.\n    long current_max = 0;\n    long best_single   = std::numeric_limits<long>::min();\n    long total_sum = 0;                // sum of all elements (used later)\n\n    for (long val : a) {\n        current_max = std::max(val, current_max + val);\n        best_single = std::max(best_single, current_max);\n        total_sum += val;\n    }\n\n    // 2. If all numbers are negative, best_single is the correct answer.\n    if (best_single < 0)\n        return best_single;\n\n    // 3. Calculate the maximum sub\u2011array that *wraps* around the boundary of\n    //    consecutive copies.  For this we need the minimum sub\u2011array sum.\n    long current_min   = 0;\n    long best_min      = std::numeric_limits<long>::max();\n\n    for (long val : a) {\n        current_min = std::min(val, current_min + val);\n        best_min    = std::min(best_min, current_min);\n    }\n\n    // The best wrapping sum uses all elements except a minimal sub\u2011array in the *middle* copies\n    long wrap_sum = total_sum - best_min;\n\n    // The overall answer: pick the best non\u2011wrapping sum or the best wrapping sum.\n    long answer = std::max(best_single, wrap_sum);\n\n    // For k > 1, we get extra contribution from inner full copies.\n    // The extra sum is (k-2) * total_sum added to the best wrapping sum.\n    // Note: for k==1 this term is zero.\n    if (k > 1) {\n        answer = std::max(answer, wrap_sum + (k - 2) * total_sum);\n    }\n\n    return answer;\n}\n\n/* ----------  Simple test harness  ---------- */\nint main()\n{\n    // Example 1\n    std::vector<long> a = {1, -2, 3, -4, 5};\n    assert(max_sub_array_sum_repeated(a, a.size(), 3) == 11); // 3+5+1\n\n    // Example 2 \u2013 all negatives\n    std::vector<long> b = {-3, -2, -5};\n    assert(max_sub_array_sum_repeated(b, b.size(), 10) == -2);\n\n    // Example 3 \u2013 all positive\n    std::vector<long> c = {2, 3, 1};\n    assert(max_sub_array_sum_repeated(c, c.size(), 2) == 12); // 2+3+1+2+3\n\n    // Example 4 \u2013 k == 1\n    std::vector<long> d = {2, -1, 2};\n    assert(max_sub_array_sum_repeated(d, d.size(), 1) == 3);\n\n    // Example 5 \u2013 large k, mixed\n    std::vector<long> e = {4, -1, 2, 1};\n    assert(max_sub_array_sum_repeated(e, e.size(), 5) == 16); // 4+(-1)+2+1+4+(-1)+2+1+4+(-1)+2+1+4\n\n    return 0;\n}\n```\n\n### Explanation of the algorithm\n\n1. **Kadane on the original array**  \n   Computes the maximum sub\u2011array sum that does **not** cross the boundary between copies (`best_single`).  \n   It also accumulates the total sum of the array (`total_sum`).\n\n2. **All\u2011negative special case**  \n   If the best sum is negative, every element is negative and that is the answer.\n\n3. **Minimal sub\u2011array (Kadane on negated values)**  \n   Finding the minimal contiguous sum (`best_min`) lets us compute the sum of the best wrapping sub\u2011array:  \n   `wrap_sum = total_sum - best_min`.\n\n4. **Result for one repetition**  \n   `answer = max(best_single, wrap_sum)`.\n\n5. **Adding extra full copies for `k > 1`**  \n   The optimal wrapped sub\u2011array can use full copies between the two partial copies that give `wrap_sum`.  \n   Each full copy contributes `total_sum`.  \n   The maximum additional contribution therefore is `(k - 2) * total_sum`, which we add to `wrap_sum`.  \n   The final answer is the maximum among:\n   - `best_single` (no wrap),\n   - `wrap_sum` (wrap but use no inner full copies),\n   - `wrap_sum + (k-2) * total_sum` (wrap using inner copies).\n\nThe solution runs in linear time with respect to the length of `a` and uses only constant additional memory.", "Below is a compact, self\u2011contained implementation of the required routine.  \nThe idea is the same as in the \u201cMaximum sub\u2011array sum in a circular array\u201d problem, but we must\nconsider that the original array is repeated **k** times.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// Maximum sub\u2011array sum for a vector repeated k times.\nlong max_sub_array_sum_repeated(const vector<long> &a, long k)\n{\n    if (a.empty() || k <= 0) return 0;\n\n    /* 1\u2011pass Kadane: best sum in a single copy            */\n    long best = LLONG_MIN;\n    long cur  = 0;\n    for (long v : a) {\n        cur = max(v, cur + v);\n        best = max(best, cur);\n    }\n\n    /* 2\u2011pass Kadane to obtain total sum, max prefix, max suffix  */\n    long total   = 0;             // sum of one copy\n    long max_pref = LLONG_MIN;\n    long pref      = 0;\n    for (long v : a) {\n        total += v;\n        pref  += v;\n        max_pref = max(max_pref, pref);\n    }\n\n    long max_suf = LLONG_MIN;\n    long suf     = 0;\n    for (long it = a.size() - 1; it >= 0; --it) {\n        suf += a[it];\n        max_suf = max(max_suf, suf);\n    }\n\n    /* 3\u2011case handling                                               */\n    if (k == 1)                            // only one copy\n        return best;\n\n    if (total > 0) {                       // repeating is profitable\n        long middle = (k - 2) * total;     // middle part (k-2) copies\n        if (middle < 0) middle = 0;        // guard against overflow (unlikely)\n        long cand = max_pref + max_suf + middle;\n        return max(best, cand);\n    } else {                               // total <= 0 \u2013 use at most two copies\n        return max(best, max_pref + max_suf);\n    }\n}\n```\n\n### What the code does\n1. **Kadane on a single copy** \u2013 gives the best sub\u2011array that lies completely inside one repetition.\n2. **Prefix / suffix sums** \u2013 `max_pref` is the largest sum that can be obtained on a prefix of the array; `max_suf` similarly for suffixes.\n3. **Total sum of the array** \u2013 if it\u2019s positive, the optimal sub\u2011array can use *all* middle copies  \n   (`k\u20112` copies sandwiched between the best prefix and suffix).  \n   If the total sum is non\u2011positive, using *more than two* copies can only hurt, so we compute the best result using one or two copies only.\n\nThe function works in **O(n)** time and **O(1)** extra space, fully suitable for large `k` (the algorithm never builds the repeated array)."]}
{"name": "HumanEval_47_median", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_47_median.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = median;\n    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (float(3)));\n    assert(candidate((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20}))) == (8.0f));\n    assert(candidate((std::vector<long>({(long)5}))) == (float(5)));\n    assert(candidate((std::vector<long>({(long)6, (long)5}))) == (5.5f));\n    assert(candidate((std::vector<long>({(long)8, (long)1, (long)3, (long)9, (long)9, (long)2, (long)7}))) == (float(7)));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a complete, self\u2011contained implementation of the `median` function that satisfies the examples you showed.  \nThe function sorts the input, then returns the middle element (or the average of the two middle elements in the case of an even size) as a `float`.  It also includes a simple **unit\u2011test harness** that demonstrates the expected behaviour.\n\n```cpp\n#include <bits/stdc++.h>\n#include <cassert>\n\n/**\n * @brief Compute the median of a vector of integers.\n *\n * The function accepts a vector of `long` integers, makes a copy,\n * sorts it, and then calculates the median.  If the size of the vector\n * is odd, the middle element is returned.  If it is even, the average\n * of the two middle elements is returned as a `float`.\n *\n * @param l Vector of long integers.\n * @return float Median value.\n *\n * @throws std::invalid_argument if the input vector is empty.\n */\nfloat median(std::vector<long> l) {\n    if (l.empty()) {\n        throw std::invalid_argument(\"median() requires non\u2011empty vector\");\n    }\n\n    std::sort(l.begin(), l.end());\n\n    size_t n = l.size();\n\n    if (n % 2 == 1) {                 // odd number of elements\n        return static_cast<float>(l[n / 2]);\n    } else {                          // even number of elements\n        long a = l[n / 2 - 1];\n        long b = l[n / 2];\n        return static_cast<float>(a + b) / 2.0f;\n    }\n}\n\n/* -----------------  Demo / Unit\u2011Test  ----------------- */\n\nint main() {\n    // test cases from the original example\n    std::vector<long> v1 = {3, 1, 2, 4, 5};\n    assert(std::abs(median(v1) - 3.0f) < 1e-6);\n\n    std::vector<long> v2 = {-10, 4, 6, 1000, 10, 20};\n    assert(std::abs(median(v2) - 15.0f) < 1e-6);\n\n    // some more checks\n    assert(std::abs(median(std::vector<long>{1})    - 1.0f) < 1e-6);\n    assert(std::abs(median(std::vector<long>{1, 2})  - 1.5f) < 1e-6);\n    assert(std::abs(median(std::vector<long>{-5, 0, 5}) - 0.0f) < 1e-6);\n    assert(std::abs(median(std::vector<long>{-5, 0, 5, 10}) - 2.5f) < 1e-6);\n\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\n### What this code does\n\n1. **Parameter validation** \u2013 Throws an exception if the input vector is empty (you can change this behaviour if you prefer a different error handling strategy).\n2. **Sorting** \u2013 Uses `std::sort` to order the elements.\n3. **Median calculation** \u2013  \n   * If the vector length is odd, returns the middle element.  \n   * If the length is even, averages the two central numbers.\n4. **Unit tests** \u2013 The `main` function demonstrates the two examples you gave plus a few additional tests to ensure correctness.\n\nYou can drop this snippet into any C++17/20/23 project that includes `<bits/stdc++.h>` (or replace it with the appropriate standard headers for a more portable build).", "Here\u2019s a clean, self\u2011contained implementation of `median` that follows the standard algorithm:\n\n```cpp\n#include <vector>\n#include <algorithm>   // for std::sort\n#include <cstddef>     // for std::size_t\n\n// Return the median of the elements in the vector `l`.\n// For an odd number of elements it returns the middle value,\n// for an even number it returns the average of the two central values.\nfloat median(std::vector<long> l)\n{\n    if (l.empty())\n    {\n        throw std::invalid_argument(\"median() input vector is empty\");\n    }\n\n    // Sort the data; this is O(n log n), which is fine for a one\u2011time median calc.\n    std::sort(l.begin(), l.end());\n\n    const std::size_t n = l.size();\n\n    if (n % 2 == 1)          // odd number of elements\n    {\n        return static_cast<float>(l[n / 2]);\n    }\n    else                     // even number of elements\n    {\n        long a = l[n / 2 - 1];\n        long b = l[n / 2];\n        return (static_cast<float>(a) + static_cast<float>(b)) / 2.0f;\n    }\n}\n```\n\n### Why this is correct\n\n* **Sorting** guarantees the numbers are in non\u2011decreasing order so the middle indices are well defined.  \n* The `if (n%2==1)` branch extracts the exact middle element for odd sized lists.  \n* The `else` branch averages the two middle elements (`l[n/2-1]` and `l[n/2]`) and casts to `float` to preserve the expected floating\u2011point result.  \n* The function checks for an empty vector and throws an informative exception, preventing undefined behaviour.  \n\nFeel free to adapt the error handling or optimize further if you know your data meets specific constraints.", "Here\u2019s a concise implementation that does exactly that:\n\n```cpp\n#include <algorithm>\n#include <vector>\n\nfloat median(std::vector<long> l)\n{\n    if (l.empty())\n        throw std::invalid_argument(\"Cannot compute median of an empty vector.\");\n\n    /* Sort the vector to get the elements in order.  */\n    std::sort(l.begin(), l.end());\n\n    const size_t n = l.size();\n    const size_t mid = n / 2;                // Index of the middle element\n\n    if (n % 2 == 1)                          // odd number of elements\n    {\n        return static_cast<float>(l[mid]);    // middle element (0\u2011based)\n    }\n    else                                      // even number of elements\n    {\n        /* average the two middle values */\n        return (static_cast<float>(l[mid - 1]) + static_cast<float>(l[mid])) / 2.0f;\n    }\n}\n```\n\n### How it works\n\n| Step | Description |\n|------|-------------|\n| 1 | Sort the vector in ascending order with `std::sort`. |\n| 2 | Compute `mid = n/2`. |\n| 3 | If `n` is odd, return the middle value as `float`. |\n| 4 | If `n` is even, average the two middle values and return the result. |\n\n#### Examples\n\n```cpp\nstd::vector<long> a{3,1,2,4,5};\nstd::cout << median(a) << '\\n';   // prints 3\n\nstd::vector<long> b{-10,4,6,1000,10,20};\nstd::cout << median(b) << '\\n';   // prints 15\n```\n\nThe function throws an exception if the input vector is empty, which matches the common expectation that a median is undefined for an empty set. Feel free to adjust the error handling to suit your specific needs."]}
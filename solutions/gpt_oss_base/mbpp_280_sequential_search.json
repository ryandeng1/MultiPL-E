{"name": "mbpp_280_sequential_search", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes in a vector and element and returns a tuple containing a boolean that indicates if the element is in the vector and the index position of the element (or -1 if the element is not found).\nstd::tuple<bool, long> sequential_search(std::vector<long> dlist, long item) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_280_sequential_search.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = sequential_search;\n    assert(candidate((std::vector<long>({(long)11, (long)23, (long)58, (long)31, (long)56, (long)77, (long)43, (long)12, (long)65, (long)19})), (31)) == (std::make_tuple(true, 3)));\n    assert(candidate((std::vector<long>({(long)12, (long)32, (long)45, (long)62, (long)35, (long)47, (long)44, (long)61})), (61)) == (std::make_tuple(true, 7)));\n    assert(candidate((std::vector<long>({(long)9, (long)10, (long)17, (long)19, (long)22, (long)39, (long)48, (long)56})), (48)) == (std::make_tuple(true, 6)));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a complete, idiomatic implementation of the requested function.  \nFeel free to copy\u2011paste it into your file \u2013 it compiles with any C++17 (or newer) compiler.\n\n```cpp\n#include <vector>\n#include <tuple>\n#include <cstddef>   // for std::size_t\n#include <cassert>   // optional, for a simple test\n\n/**\n * @brief Sequentially searches a vector for a given element.\n *\n * @param dlist  The vector to search.  The function takes the vector by\n *               const reference to avoid an unnecessary copy.\n * @param item   The element to find.\n *\n * @return A std::tuple containing:\n *          - a bool that is true if the element is found\n *          - a std::size_t index of the first occurrence, or\n *            static_cast<std::size_t>(-1) if the element is not found.\n */\nstd::tuple<bool, std::size_t>\nsequential_search(const std::vector<long>& dlist, long item)\n{\n    for (std::size_t i = 0; i < dlist.size(); ++i)\n    {\n        if (dlist[i] == item)\n        {\n            return {true, i};          // element found\n        }\n    }\n    return {false, static_cast<std::size_t>(-1)};  // not found\n}\n\n/* ---------- Optional simple test ---------- */\n/*\nint main()\n{\n    std::vector<long> v = {3, 7, 1, 9, 4};\n    auto [found, idx] = sequential_search(v, 9);\n    assert(found && idx == 3);\n\n    auto [found2, idx2] = sequential_search(v, 5);\n    assert(!found2 && idx2 == static_cast<std::size_t>(-1));\n\n    return 0;\n}\n*/\n```\n\n### Why this implementation?\n* **Pass by reference:** `const std::vector<long>&` prevents the vector from being copied, which is especially important for large data sets.\n* **Index type:** `std::size_t` is the natural type for indexing containers; it automatically matches the return type of `vector::size()`.\n* **Return value:** The second tuple element is `-1` cast to `std::size_t`. This is the conventional way to indicate \u201cnot found\u201d while keeping the type unsigned.  \n  Users can compare it with `static_cast<std::size_t>(-1)` or test the boolean flag first.\n* **Simplicity & readability:** A single loop with an `if` check and a straightforward return statement makes the function easy to read and maintain.\n\nDrop the optional test into your `main()` if you want a quick sanity check.", "Here is a minimal, self\u2011contained, correct implementation of the `sequential_search` function that follows the specification you gave:\n\n```cpp\n#include <vector>\n#include <tuple>\n\n/*\n * sequential_search\n *\n *   dlist : vector to search\n *   item  : element we are looking for\n *\n * Returns a std::tuple of\n *   - bool  : true if `item` is present\n *   - long  : index of the first occurrence of `item`\n *             ( -1  if the item is not part of the vector )\n */\nstd::tuple<bool,long> sequential_search(const std::vector<long>& dlist, long item)\n{\n    for (size_t i = 0; i < dlist.size(); ++i) {\n        if (dlist[i] == item)          // element found\n            return {true, static_cast<long>(i)};\n    }\n    // element never found\n    return {false, -1};\n}\n```\n\n### Why this version works\n\n| Requirement | How it is met |\n|-------------|---------------|\n| **Return type** | The function returns `std::tuple<bool, long>` as requested. |\n| **Element presence flag** | The `bool` is set to `true` only when the comparison `dlist[i] == item` succeeds. |\n| **Index value** | The index is returned as an `long`.  We cast the `size_t` (the native type of the vector index) to `long` to match the signature.  If the element is not found the function returns `-1`. |\n| **Linear search** | A simple `for` loop scans the vector from the beginning to the end \u2013 exactly a *sequential* (or linear) search. |\n| **Const correctness** | The input vector is taken as a `const&` to avoid an unnecessary copy and to signal that the function does not modify the vector. |\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> nums{ 10, 20, 30, 40, 50 };\n\n    auto [found, idx] = sequential_search(nums, 30);\n    std::cout << \"Found? \" << std::boolalpha << found\n              << \", Index: \" << idx << '\\n';\n\n    auto [notfound, idx2] = sequential_search(nums, 25);\n    std::cout << \"Found? \" << notfound\n              << \", Index: \" << idx2 << '\\n';\n}\n```\n\n**Output**\n\n```\nFound? true, Index: 2\nFound? false, Index: -1\n```\n\nFeel free to drop this function into your own code base; it is completely header\u2011only and independent of any other library beyond the standard library.", "Below is a minimal, self\u2011contained implementation of the requested function:\n\n```cpp\n#include <tuple>\n#include <vector>\n\n/*\n * Sequential (linear) search over a vector.\n *\n * @param dlist  The vector to search.\n * @param item   The element we're looking for.\n *\n * @return a std::tuple containing:\n *        - a bool   : true if `item` is found, otherwise false.\n *        - a long   : the index of the first occurrence of `item`\n *                     (0\u2011based). If not found the value is -1.\n */\nstd::tuple<bool, long> sequential_search(const std::vector<long>& dlist,\n                                         long item)\n{\n    for (size_t i = 0; i < dlist.size(); ++i) {\n        if (dlist[i] == item) {\n            return {true, static_cast<long>(i)};\n        }\n    }\n    return {false, -1};\n}\n```\n\n### Why this version?\n\n* **Pass-by\u2011const\u2011reference** \u2013 we don\u2019t need to copy the vector; the function simply reads it.\n* **`size_t` for the loop index** \u2013 safe for large containers; we cast to `long` only when returning to match the requested type.\n* **Early exit** \u2013 the `return` in the loop stops searching as soon as the element is found.\n* **Straight\u2011forward return value** \u2013 a `std::tuple<bool, long>` that can be unpacked with `auto` or `std::tie`.\n\nYou can test it like this:\n\n```cpp\n#include <iostream>\n#include <tuple>\n\nint main() {\n    std::vector<long> v{10, 20, 30, 40, 50};\n\n    auto [found, idx] = sequential_search(v, 30);\n    std::cout << std::boolalpha;\n    std::cout << \"found: \" << found << \", index: \" << idx << '\\n'; // prints: found: true, index: 2\n\n    auto [found2, idx2] = sequential_search(v, 60);\n    std::cout << \"found: \" << found2 << \", index: \" << idx2 << '\\n'; // prints: found: false, index: -1\n}\n```\n\nFeel free to adapt the signature or return type if you need a different style (e.g., `std::optional<long>` instead of a tuple)."]}
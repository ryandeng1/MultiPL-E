{"name": "mbpp_87_merge_dictionaries_three", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to merge three dictionaries into a single map.\nstd::map<std::string,std::string> merge_dictionaries_three(std::map<std::string,std::string> dict1, std::map<std::string,std::string> dict2, std::map<std::string,std::string> dict3) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_87_merge_dictionaries_three.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = merge_dictionaries_three;\n    assert(candidate((std::map<std::string,std::string>({{\"R\", \"Red\"}, {\"B\", \"Black\"}, {\"P\", \"Pink\"}})), (std::map<std::string,std::string>({{\"G\", \"Green\"}, {\"W\", \"White\"}})), (std::map<std::string,std::string>({{\"O\", \"Orange\"}, {\"W\", \"White\"}, {\"B\", \"Black\"}}))) == (std::map<std::string,std::string>({{\"B\", \"Black\"}, {\"R\", \"Red\"}, {\"P\", \"Pink\"}, {\"G\", \"Green\"}, {\"W\", \"White\"}, {\"O\", \"Orange\"}})));\n    assert(candidate((std::map<std::string,std::string>({{\"R\", \"Red\"}, {\"B\", \"Black\"}, {\"P\", \"Pink\"}})), (std::map<std::string,std::string>({{\"G\", \"Green\"}, {\"W\", \"White\"}})), (std::map<std::string,std::string>({{\"L\", \"lavender\"}, {\"B\", \"Blue\"}}))) == (std::map<std::string,std::string>({{\"W\", \"White\"}, {\"P\", \"Pink\"}, {\"B\", \"Black\"}, {\"R\", \"Red\"}, {\"G\", \"Green\"}, {\"L\", \"lavender\"}})));\n    assert(candidate((std::map<std::string,std::string>({{\"R\", \"Red\"}, {\"B\", \"Black\"}, {\"P\", \"Pink\"}})), (std::map<std::string,std::string>({{\"L\", \"lavender\"}, {\"B\", \"Blue\"}})), (std::map<std::string,std::string>({{\"G\", \"Green\"}, {\"W\", \"White\"}}))) == (std::map<std::string,std::string>({{\"B\", \"Black\"}, {\"P\", \"Pink\"}, {\"R\", \"Red\"}, {\"G\", \"Green\"}, {\"L\", \"lavender\"}, {\"W\", \"White\"}})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a concise, well\u2011documented implementation of a helper function that merges **three** `std::map<std::string, std::string>` objects into a single one.  \nThe function follows the usual \u201clast\u2011write\u2011wins\u201d rule for duplicate keys: values from `dict3` overwrite those from `dict2`, which overwrite those from `dict1`.  \nFeel free to change that behaviour if you prefer something else (e.g., throw on duplicate, keep the first, etc.).\n\n```cpp\n#include <map>\n#include <string>\n#include <iostream>\n\n/**\n * @brief Merges three string maps into one.\n *\n * The merge follows a \u201clast\u2011write\u2011wins\u201d strategy:\n *  - Entries are first inserted from dict1.\n *  - Entries from dict2 overwrite any keys already present.\n *  - Entries from dict3 overwrite any keys already present.\n *\n * @param dict1 First dictionary.\n * @param dict2 Second dictionary.\n * @param dict3 Third dictionary.\n * @return std::map<std::string, std::string> the merged dictionary.\n */\nstd::map<std::string, std::string>\nmerge_dictionaries_three(std::map<std::string, std::string> dict1,\n                         std::map<std::string, std::string> dict2,\n                         std::map<std::string, std::string> dict3) {\n    // Start with a copy of dict1 (so we don\u2019t modify the caller\u2019s map)\n    std::map<std::string, std::string> result{std::move(dict1)};\n\n    // Helper lambda that inserts/overwrites a map into `result`\n    auto insert_or_update = [&result](const std::map<std::string, std::string>& src) {\n        for (const auto& [k, v] : src) {\n            result[k] = v;           // operator[] will insert or replace\n        }\n    };\n\n    insert_or_update(dict2);\n    insert_or_update(dict3);\n\n    return result;\n}\n\n/* ------------------------------------------------------------------ */\n/*                     Optional demo / unit\u2011test section               */\n/* ------------------------------------------------------------------ */\n#ifdef DEMO_MERGE\nint main() {\n    std::map<std::string, std::string> a{{\"apple\", \"red\"}, {\"banana\", \"yellow\"}};\n    std::map<std::string, std::string> b{{\"banana\", \"green\"}, {\"cherry\", \"red\"}};\n    std::map<std::string, std::string> c{{\"date\", \"brown\"}, {\"apple\", \"green\"}};\n\n    auto merged = merge_dictionaries_three(a, b, c);\n\n    for (const auto& [k, v] : merged) {\n        std::cout << k << \" : \" << v << '\\n';\n    }\n    /* Expected output (order may differ due to map ordering):\n     * apple : green   (c overrides a)\n     * banana : green  (b overrides a)\n     * cherry : red\n     * date : brown\n     */\n    return 0;\n}\n#endif\n```\n\n### How It Works\n\n1. **Copy `dict1`** \u2013 We start with a new map that holds all entries of `dict1`. This keeps the original `dict1` unchanged.\n2. **Insert / overwrite** \u2013 The lambda `insert_or_update` walks through each source map (`dict2`, then `dict3`) and assigns `result[key] = value`. In a `std::map` the `operator[]` will:\n   * insert a new key if it doesn\u2019t exist,\n   * *overwrite* the existing value otherwise.\n3. **Return the merged result** \u2013 The final combined map is returned by value.\n\n### Customise If Needed\n\n* **First\u2011write\u2011wins** \u2013 Replace `result[k] = v;` with a check:\n  ```cpp\n  if (!result.count(k)) result[k] = v;\n  ```\n* **Error on duplicate** \u2013 Throw an exception when `k` already exists:\n  ```cpp\n  if (result.count(k)) throw std::runtime_error(\"Duplicate key: \" + k);\n  ```\n\nFeel free to copy this snippet into your code base and adjust the duplicate\u2011key policy to match your requirements!", "Here\u2019s a compact, idiomatic implementation that merges the three maps in order, with later maps overriding earlier ones in case of key collisions:\n\n```cpp\n#include <map>\n#include <string>\n\n/* \n * Merge three dictionaries into a single map.\n *\n * The order of merging is important: values from `dict2` will override\n * any matching keys from `dict1`, and values from `dict3` will override\n * any matching keys from `dict2` (and consequently also from `dict1`).\n */\nstd::map<std::string,std::string> merge_dictionaries_three(\n        std::map<std::string,std::string> dict1,\n        std::map<std::string,std::string> dict2,\n        std::map<std::string,std::string> dict3)\n{\n    // Start with the first dictionary\n    std::map<std::string,std::string> result = std::move(dict1);\n\n    // Insert all pairs from dict2; `operator[]` or `emplace` will\n    // overwrite keys that already exist.\n    for (const auto &p : dict2) {\n        result[p.first] = p.second;   // or result.insert(p); if you want to keep existing values intact\n    }\n\n    // Finally insert dict3, overriding anything that was present before.\n    for (const auto &p : dict3) {\n        result[p.first] = p.second;\n    }\n\n    return result;\n}\n```\n\n### How it works\n\n1. **Move `dict1` into `result`** \u2013 this avoids an unnecessary copy of the first map's contents.\n2. **Insert/overwrite from `dict2`** \u2013 the loop assigns each key\u2011value pair to `result`. If a key is already present it gets replaced.\n3. **Insert/overwrite from `dict3`** \u2013 the same logic applies; `dict3` has the highest priority.\n4. **Return the merged map**.\n\nFeel free to adjust the logic if you want a different precedence (e.g., earlier maps overriding later ones) or if you prefer to keep the original maps unchanged (the current implementation does not modify the input arguments).", "Below is a compact, self\u2011contained implementation of `merge_dictionaries_three`.  \nIt merges the three `std::map<std::string, std::string>` arguments into a new map.  \nIf the same key appears in more than one dictionary, the value from the **last** dictionary that contains that key wins (i.e. `dict3` overrides `dict2`, which overrides `dict1`).  The function does **not** modify the input maps.\n\n```cpp\n#include <map>\n#include <string>\n\n/*\n * Merge three dictionaries (maps) into one.\n *   dict1, dict2, dict3 are the input maps.\n * Returns a new map that contains all key/value pairs from the three\n *   input maps.  If a key is present in multiple maps,\n *   the value from the later argument takes precedence.\n */\nstd::map<std::string, std::string>\nmerge_dictionaries_three(const std::map<std::string, std::string>& dict1,\n                         const std::map<std::string, std::string>& dict2,\n                         const std::map<std::string, std::string>& dict3)\n{\n    std::map<std::string, std::string> result;\n\n    // Insert all entries from the first dictionary\n    result.insert(dict1.begin(), dict1.end());\n    // Insert/override with entries from the second dictionary\n    for (const auto& kv : dict2)\n        result[kv.first] = kv.second;\n    // Insert/override with entries from the third dictionary\n    for (const auto& kv : dict3)\n        result[kv.first] = kv.second;\n\n    return result;\n}\n```\n\n### Remarks\n* The function uses range\u2011based `for` loops to keep the code short and clear.  \n* `result[kv.first] = kv.second;` automatically inserts a new key if it isn\u2019t present or replaces the existing value if it is, providing the desired \u201clast\u2011write\u2011wins\u201d semantics.  \n* `const` references are used for the input maps to avoid unnecessary copies.  \n* This implementation compiles with a modern C++ compiler (\u2265C++11)."]}
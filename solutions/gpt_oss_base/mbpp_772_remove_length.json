{"name": "mbpp_772_remove_length", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to remove all the words with k length in the given string.\nstd::string remove_length(std::string test_str, long K) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_772_remove_length.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = remove_length;\n    assert(candidate((\"The person is most value tet\"), (3)) == (\"person is most value\"));\n    assert(candidate((\"If you told me about this ok\"), (4)) == (\"If you me about ok\"));\n    assert(candidate((\"Forces of darkeness is come into the play\"), (4)) == (\"Forces of darkeness is the\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a ready\u2011to\u2011copy implementation that works for both ASCII and UTF\u20118 (wide) strings.  \nIt builds a working string, tokenises on whitespace, and removes every token whose\nlength equals the given `K`.  For Unicode aware behaviour you can switch to the\n`wstring` version and be careful with grapheme clusters \u2013 ASCII works out of the box.\n\n```cpp\n#include <cassert>\n#include <bits/stdc++.h>\n\n/**\n * @brief Remove all words of exactly length `K` from a string.\n *\n * \"word\"  \u2013 a maximal sequence of non\u2011whitespace characters.\n * The original whitespace (spaces, tabs, newlines) is preserved.\n *\n * @param test_str  Input string (modified in place).\n * @param K         Length of words to remove; if K <= 0 no words are removed.\n * @return           String with all K\u2011length words removed.\n */\nstd::string remove_length(std::string test_str, long K)\n{\n    // No work necessary when K <= 0\n    if (K <= 0) return test_str;\n\n    std::istringstream  iss(test_str);\n    std::ostringstream  oss;\n    std::string word;\n    bool first = true;\n\n    while (iss >> word)                 // get next word (skipping whitespace)\n    {\n        if (static_cast<long>(word.size()) != K)   // keep words of other lengths\n        {\n            if (!first) oss << ' ';        // preserve a single space between kept words\n            oss << word;\n            first = false;\n        }\n    }\n\n    return oss.str();\n}\n\n/* ------------------------------------------------------------\n   Example usage\n   ------------------------------------------------------------ */\nint main()\n{\n    std::string s1 = \"Hello world this is a test\";\n    std::cout << remove_length(s1, 4) << '\\n';   // removes \"this\" (4 letters)\n\n    /* Edge cases */\n    std::string s2 = \"   quick   brown   fox    \";\n    std::cout << '\"' << remove_length(s2, 5) << \"\\\"\\n\"; // removes \"quick\" and \"brown\"\n\n    std::string s3 = \"abc abc\";\n    assert(remove_length(s3, 3).empty());\n    assert(remove_length(s3, 2) == s3);\n\n    return 0;\n}\n```\n\n### How it works\n1. **Input validation** \u2013 If `K <= 0`, the string is returned unchanged.\n2. **Tokenisation** \u2013 An `istringstream` reads tokens separated by any whitespace.\n3. **Filtering** \u2013 Each token\u2019s length is compared to `K`.  \n   If the length is different, the token is written to the `ostringstream`.\n4. **Spacing** \u2013 A single space is inserted between kept tokens, preserving\n   the relative order. Leading/trailing whitespace is omitted; if you need\n   to preserve it exactly, a more elaborate parsing routine is required.\n\nFeel free to modify the whitespace handling (tabs, newlines, multiple spaces)\nor replace `std::string` with `std::wstring` for wide\u2011character support.", "Below is a complete, minimal\u2011but\u2011fully\u2011functional implementation that removes every word\nwhose length equals `K` from the given `test_str`.  \nThe function splits the string into \u201cwords\u201d by whitespace, rebuilds the output without\nthe unwanted words, and preserves the original spacing (i.e. it keeps the spaces that\nseparate the kept words).\n\n```cpp\n#include <string>\n#include <sstream>\n#include <cctype>\n\n/*\n * Remove all words that have length exactly K from the supplied string.\n * A \u201cword\u201d is defined as a maximal sequence of non\u2011whitespace characters.\n * The relative order of the remaining words is preserved, and the separator\n * between words is a single space.\n *\n * Example:\n *   test_str = \"Hello world this is a test\"\n *   K       = 4\n *   returns  \"Hello this is test\"\n */\nstd::string remove_length(const std::string &test_str, long K) {\n    std::istringstream iss(test_str);\n    std::ostringstream oss;\n    std::string word;\n    bool first = true;\n\n    while (iss >> word) {\n        if (static_cast<long>(word.size()) == K) {\n            continue;           // skip words of length K\n        }\n        if (!first) oss << ' ';\n        oss << word;\n        first = false;\n    }\n    return oss.str();\n}\n```\n\n### How it works\n1. **Tokenisation** \u2013 `std::istringstream` reads words separated by any whitespace.\n2. **Filtering** \u2013 For each word, its size is compared to `K`.  \n   If it equals `K`, the word is ignored.\n3. **Re\u2011assembly** \u2013 Kept words are inserted into an output stream with a single\n   space between them.  \n   Leading/trailing spaces from the original input are omitted, which is standard\n   behaviour for the requirement \u201cremove all words of length K\u201d.\n\nFeel free to drop this function into your project and which should compile with any\nC++ compiler that supports the standard library (C++11 or newer).", "Here is a complete, self\u2011contained implementation that\n\n* splits the input string into words (separated by whitespace),\n* removes every word whose length equals **K**, and\n* rejoins the remaining words into a single string.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// Remove all words of length K from the given string.\n///\n/// @param test_str  The original string.\n/// @param K         Length of the words to be removed.\n/// @return          The string with the K\u2011length words stripped out.\nstring remove_length(const string& test_str, long K)\n{\n    // Fast return if K is negative (no word can have negative length)\n    if (K < 0) return test_str;\n\n    vector<string> kept;            // words that will stay\n    string current_word;            // builder for a word\n    for (char ch : test_str) {\n        if (isspace(static_cast<unsigned char>(ch))) {\n            if (!current_word.empty()) {\n                if (static_cast<long>(current_word.size()) != K)\n                    kept.push_back(current_word);\n                current_word.clear();\n            }\n        } else {\n            current_word += ch;      // build the current word\n        }\n    }\n\n    // Process the last word (if string did not end with whitespace)\n    if (!current_word.empty() &&\n        static_cast<long>(current_word.size()) != K) {\n        kept.push_back(current_word);\n    }\n\n    // Re\u2011assemble the string\n    string result;\n    for (size_t i = 0; i < kept.size(); ++i) {\n        if (i) result += ' ';              // separate with a single space\n        result += kept[i];\n    }\n    return result;\n}\n\n/* ---------- Below is a simple test harness ---------- */\nint main() {\n    vector<pair<string,long>> tests = {\n        {\"one two three four five\", 3},\n        {\"hello   world\", 5},\n        {\"a b c d e f\", 1},\n        {\"\", 2},\n        {\"   leading and trailing   \", 0}\n    };\n\n    for (auto& [s, k] : tests) {\n        cout << \"Original: \\\"\" << s << \"\\\", K=\" << k << \"\\n\";\n        cout << \"Result  : \\\"\" << remove_length(s, k) << \"\\\"\\n\\n\";\n    }\n    return 0;\n}\n```\n\n### How it works\n\n1. **Scanning** \u2013 We walk character by character.  \n   *If a whitespace is encountered,* we finish the current word and decide whether to keep it.  \n   \u2022 If its length is **not** equal to `K`, we push it into `kept`.  \n   If it is equal to `K`, we simply discard it.  \n   *If the character is not a whitespace,* we append it to `current_word`.\n\n2. **End of string** \u2013 After the loop we process the last word, if any, because the string may not end with a space.\n\n3. **Re\u2011assembly** \u2013 All words stored in `kept` are joined with a single space to produce the final string.\n\nThe algorithm runs in **O(n)** time where *n* is the length of the input string, and uses **O(n)** additional space for the resulting words. It also gracefully handles edge cases such as empty strings, multiple consecutive spaces, and negative `K`."]}
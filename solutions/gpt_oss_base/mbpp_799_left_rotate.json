{"name": "mbpp_799_left_rotate", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to that rotate left bits by d bits a given number. We assume that the number is 32 bit.\nlong left_rotate(long n, long d) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_799_left_rotate.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = left_rotate;\n    assert(candidate((16), (2)) == (64));\n    assert(candidate((10), (2)) == (40));\n    assert(candidate((99), (3)) == (792));\n    assert(candidate((99), (3)) == (792));\n    assert(candidate((1), (3)) == (8));\n    assert(candidate((5), (3)) == (40));\n    assert(candidate((29), (3)) == (232));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a complete, self\u2011contained implementation of a 32\u202fbit left\u2011rotation helper.  \nThe implementation is intentionally *simple* and portable \u2013 it works on any ISO\u2011C99/ISO\u2011C++11\u2011compatible compiler:\n\n```cpp\n#include <cstdint>   // std::uint32_t, std::uint64_t\n#include <cassert>\n\n/**\n * @brief  Rotates the 32\u2011bit unsigned integer `n` left by `d` bits.\n *\n * @param n  The 32\u2011bit value to rotate (treated as unsigned).\n * @param d  The number of bits to rotate left.  Only the lower 5 bits\n *           of `d` influence the rotation, because a 32\u2011bit word\n *           has 32 positions (2\u2075 = 32).  A larger shift amount\n *           is normalised by `d & 31`.\n *\n * @return The rotated value as a 32\u2011bit unsigned integer.\n *\n * @note  The function returns a `std::uint32_t`.  If you need a signed\n *        type you can cast it in the caller.  Using unsigned arithmetic\n *        guarantees that the behaviour is well\u2011defined (no UB on\n *        overflow).\n *\n * @example\n *   std::uint32_t x = 0x12345678;\n *   auto r = left_rotate(x, 8);      // r == 0x34567812\n */\nstatic inline std::uint32_t left_rotate(std::uint32_t n, std::size_t d)\n{\n    // Normalise the shift count: only the low 5 bits matter.\n    d &= 31u;                // 32 = 2^5\n    if (d == 0) return n;    // nothing to do\n\n    // Perform the rotation.  The cast to uint64_t is only to avoid\n    // the \u201cmodulo 2^n\u201d behaviour of shifts on signed types that\n    // might compile down to an overflow \u2013 it also makes the intent\n    // crystal\u2011clear: we want a *logical* shift, not a *arithmetic*\n    // shift.  On all mainstream targets the compiler will produce\n    // the same efficient instructions regardless.\n    return static_cast<std::uint32_t>( (n << d) | (n >> (32 - d)) );\n}\n```\n\n### Why the above is safe\n\n1. **Unsigned arithmetic** \u2013 `std::uint32_t` guarantees that all shifts are *logical* and that there is no signed\u2011overflow UB.\n2. **Shift amount normalisation** \u2013 C/C++ only guarantees safe behaviour when the shift width is *strictly less* than the width of the promoted type.  \n   With `d &= 31u` we force `0\u202f\u2264\u202fd\u202f<\u202f32`, so `(n >> (32\u2011d))` is always well\u2011defined.\n3. **No extra casts or volatile** \u2013 The function is `inline` and \u201cconstexpr\u2011friendly\u201d, so the compiler can replace calls with constants at compile time.\n\n### Usage\n\n```cpp\nint main() {\n    std::uint32_t v = 0x12345678;\n    std::uint32_t r = left_rotate(v, 8);   // r == 0x34567812\n    assert(r == 0x34567812);\n}\n```\n\nThe function works correctly for any `d` (even larger than 31) because we mask `d` with `31u`.  \nFor signed types you can wrap the result:\n\n```cpp\nint32_t signed_v = static_cast<int32_t>(left_rotate(static_cast<uint32_t>(signed_v), d));\n```\n\nFeel free to drop the `assert` and the `static inline` if you want the function in a header\u2011only library.", "Below is a minimal, self\u2011contained implementation of a 32\u2011bit left rotate.  \nIt takes a `long` (which you can safely assume to be at least 32\u2011bits on every mainstream compiler) and an unsigned rotation amount.  \nBecause only the low 32 bits of the input are relevant, we mask the shift count with `31` (or `0x1F`) \u2013 this keeps the behaviour well\u2011defined even when the caller passes a value larger than 31.\n\n```cpp\n#include <cstdint>\n#include <iostream>\n#include <cassert>\n\n// Rotate a 32\u2011bit value to the left by `d` bits.\n// d may be larger than 31 \u2013 it is taken modulo 32.\ninline uint32_t left_rotate(uint32_t n, unsigned d)\n{\n    const unsigned shift = d & 0x1F;          // d % 32\n    return (n << shift) | (n >> (32 - shift));\n}\n\n// One\u2011liner wrapper that accepts a signed long (as requested in the\n// original stub).  The result is a 32\u2011bit value stored back in a long.\nlong left_rotate(long n, long d)\n{\n    // Truncate to 32 bits first, because rotating a wider value would\n    // produce a different result.\n    uint32_t val = static_cast<uint32_t>(n);\n    uint32_t rotated = left_rotate(val, static_cast<unsigned>(d));\n    return static_cast<long>(rotated);\n}\n\nint main()\n{\n    // Test vectors\n    assert(left_rotate(0x01234567L, 4)  == 0x23456701L);\n    assert(left_rotate(0x80000000L, 1)  == 0x00000001L);\n    assert(left_rotate(0xFFFFFFFFL, 16) == 0xFFFFFFFFL);\n    assert(left_rotate(0x12345678L, 0)  == 0x12345678L);\n    assert(left_rotate(0x12345678L, 32) == 0x12345678L); // same as 0 shift\n    assert(left_rotate(0x12345678L, 33) == 0x2468ACF0L); // 33 == 1\n\n    std::cout << \"All tests passed!\\n\";\n}\n```\n\n### Why this works\n\n* `shift = d & 0x1F` guarantees that the shift amount is in `[0,31]`.  \n  Shifting by 32 or more would be undefined in C/C++.\n* The expression `(n << shift) | (n >> (32 - shift))` performs the logical\n  left\u2011rotation on a 32\u2011bit word.\n* We mask the input to 32 bits at the beginning of the 32\u2011bit overload, so\n  any higher\u2011order bits in `long` are ignored, matching the assumption that\n  we operate only on the low 32 bits.\n\nFeel free to drop the `main` function into your test harness; it demonstrates a few edge\u2011cases and validates the implementation.", "Here is a complete, portable implementation of a 32\u2011bit left rotate:\n\n```cpp\n#include <cstdint>   // for uint32_t\n#include <cassert>   // for assert\n\n/**\n * @brief  Rotate the 32\u2011bit value `n` left by `d` bits.\n *\n * @param n  32\u2011bit unsigned integer to rotate.\n * @param d  Number of bits to rotate left.  It is masked with 0x1F\n *           (i.e. `d & 31`) so that rotating by any value larger\n *           than 31 behaves the same as rotating by the equivalent\n *           amount within the 0\u201131 range.\n *\n * @return  The rotated value.\n */\nuint32_t left_rotate(uint32_t n, unsigned int d)\n{\n    const unsigned int shift = d & 0x1F;          // keep only the low 5 bits\n    return (n << shift) | (n >> (32 - shift));\n}\n\n/* ---- Example / sanity check ---- */\nvoid test_left_rotate()\n{\n    assert(left_rotate(0x12345678ULL, 0)   == 0x12345678ULL);\n    assert(left_rotate(0x12345678ULL, 4)   == 0x23456781ULL);\n    assert(left_rotate(0x80000000ULL, 1)   == 0x00000001ULL);\n    assert(left_rotate(0xFFFFFFFFULL, 16)  == 0xFFFFFFFFULL);\n    assert(left_rotate(0x00000001ULL, 31)  == 0x80000000ULL);\n}\n\nint main()\n{\n    test_left_rotate();          // runs silently if all assertions pass\n    return 0;\n}\n```\n\n### Why it works\n\n1. **32\u2011bit precision** \u2013 `uint32_t` guarantees exactly 32 bits across all platforms.\n2. **Safe shift amount** \u2013 `d & 0x1F` ensures the shift count is in the range `[0,31]`. In C++ shifting by \u2265 width of the type is undefined, so masking is essential.\n3. **Combining both parts** \u2013 The left shift `(n << shift)` keeps the top bits discarded; the right shift `(n >> (32 - shift))` brings those discarded bits to the low\u2011order side. The bitwise OR fuses them into the final rotated result.\n\nFeel free to drop the test function into your codebase; it throws an assertion failure if any corner case is mishandled."]}
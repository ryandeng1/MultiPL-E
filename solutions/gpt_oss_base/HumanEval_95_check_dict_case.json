{"name": "HumanEval_95_check_dict_case", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_95_check_dict_case.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"}, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>())) == (false));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a complete implementation of `check_dict_case`.  \nThe function  \n\n- returns `false` if the map is empty,  \n- returns `false` if any key contains a character that is not an English alphabet letter,  \n- otherwise checks whether **all** keys are either all\u2011lowercase or all\u2011uppercase and returns the corresponding boolean.\n\n```cpp\n#include <cctype>\n#include <string>\n#include <map>\n\n// Helper that decides if a string is all lower\u2011case alphabetic characters.\nstatic bool is_all_lower(const std::string& s) {\n    for (char c : s) {\n        if (!std::isalpha(static_cast<unsigned char>(c)))   // non\u2011letter\n            return false;\n        if (!std::islower(static_cast<unsigned char>(c)))   // lower\u2011case?\n            return false;\n    }\n    return true;\n}\n\n// Helper that decides if a string is all upper\u2011case alphabetic characters.\nstatic bool is_all_upper(const std::string& s) {\n    for (char c : s) {\n        if (!std::isalpha(static_cast<unsigned char>(c)))   // non\u2011letter\n            return false;\n        if (!std::isupper(static_cast<unsigned char>(c)))   // upper\u2011case?\n            return false;\n    }\n    return true;\n}\n\nbool check_dict_case(const std::map<std::string,std::string>& dict) {\n    if (dict.empty())                     // requirement: non\u2011empty\n        return false;\n\n    // Determine the case wanted by examining the first key.\n    bool want_lower = is_all_lower(dict.begin()->first);\n    bool want_upper = is_all_upper(dict.begin()->first);\n\n    // If the first key is neither all lower nor all upper, fail.\n    if (!want_lower && !want_upper)\n        return false;\n\n    // Verify that every key follows the same case.\n    for (const auto& kv : dict) {\n        if (want_lower && !is_all_lower(kv.first))\n            return false;\n        if (want_upper && !is_all_upper(kv.first))\n            return false;\n    }\n    return true;\n}\n```\n\n### How it works\n\n1. **Empty map \u2192** immediately return `false`.\n2. **Case determination** \u2013 Look at the first key.  \n   * If it\u2019s all\u2011lower, we now require all keys to be all\u2011lower.  \n   * If it\u2019s all\u2011upper, we now require all keys to be all\u2011upper.  \n   * Anything else (mixed case or containing non\u2011letters) \u2192 `false`.\n3. **Iterate** over every key and confirm it matches the required case.  \n   If any key breaks the rule, return `false`.\n4. **Success** \u2013 all keys match the same case \u2192 return `true`.\n\nThis matches all the examples in the prompt.", "Below is a complete, self\u2011contained implementation of `check_dict_case`.  \nIt follows the rules you described:\n\n1. **Empty map \u2192 `false`.**  \n2. **All keys lower case or all keys upper case \u2192 `true`.**  \n3. **Anything else \u2192 `false`.**\n\n```cpp\n#include <map>\n#include <string>\n#include <cctype>\n\n// Helper: true if every character in `s` satisfies `pred`\ntemplate <typename Predicate>\nbool all_of(const std::string& s, Predicate pred)\n{\n    for (char c : s)\n        if (!pred(c))\n            return false;\n    return !s.empty();           // empty string doesn't count\n}\n\n// Checks whether the character is a letter\nbool is_letter(char c)\n{\n    return std::isalpha(static_cast<unsigned char>(c));\n}\n\n// The function requested\nbool check_dict_case(const std::map<std::string, std::string>& dict)\n{\n    if (dict.empty())\n        return false;                 // rule #1\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& kv : dict)\n    {\n        const std::string& key = kv.first;\n\n        // If the key contains any non\u2011alphabetic character,\n        // it cannot be purely lower\u2011 or upper\u2011case.\n        if (!all_of(key, is_letter))\n        {\n            all_lower = false;\n            all_upper = false;\n            break;   // no need to inspect more keys\n        }\n\n        // Update flags\n        all_lower &= all_of(key, [](char c){ return std::islower(c); });\n        all_upper &= all_of(key, [](char c){ return std::isupper(c); });\n\n        // Early exit: both flags cannot be true simultaneously\n        if (!all_lower && !all_upper)\n            break;\n    }\n\n    return all_lower || all_upper;\n}\n```\n\n### How it works\n\n* `all_of` is a small utility that checks whether every character in a string satisfies a given predicate.\n* For each key we make sure it only contains alphabetic characters; otherwise the map cannot satisfy the requirement.\n* While iterating we keep two flags (`all_lower`, `all_upper`).  \n  If at any point both flags become `false`, we break out of the loop early because the condition can never be met.\n* Finally, we return `true` when either `all_lower` or `all_upper` is still `true` after the scan.\n\nThis solution is O(n\u202f\u00b7\u202fm) where *n* is the number of keys and *m* is the average key length, which is optimal for a straightforward scan.", "Below is a minimal, self\u2011contained implementation of the requested function.  \nIt follows the specification:\n\n* The map must contain at least one entry \u2013 otherwise the function returns `false`.\n* All keys must be either all\u2011lowercase **or** all\u2011uppercase.  \n  Mixed case or any other character (e.g. numeric padded characters) causes a `false`.\n\nThe code uses only the C++ standard library (no external dependencies).\n\n```cpp\n#include <cctype>\n#include <map>\n#include <string>\n\n/*\n * Checks the \u201ccase\u2011consistency\u201d of the keys in the supplied map.\n *\n * Returns true  if every key is all\u2011lowercase OR if every key is all\u2011uppercase.\n * Returns false if the map is empty, or if there is a mixture of cases,\n * or if any key contains non\u2011alphabetic characters.\n */\nbool check_dict_case(const std::map<std::string, std::string>& dict)\n{\n    if (dict.empty())\n        return false;          // empty map \u21d2 false\n\n    bool has_lower = false;\n    bool has_upper = false;\n\n    for (const auto& [key, _] : dict) {\n        for (char c : key) {\n            if (!std::isalpha(static_cast<unsigned char>(c))) {\n                // a key contains a non\u2011letter \u2013 treat it as mixed / invalid\n                return false;\n            }\n            if (std::islower(static_cast<unsigned char>(c)))\n                has_lower = true;\n            else if (std::isupper(static_cast<unsigned char>(c)))\n                has_upper = true;\n        }\n\n        // early break as soon as we know the set is mixed\n        if (has_lower && has_upper)\n            return false;\n    }\n\n    // we reached here \u2192 all keys are either all\u2011lower or all\u2011uppercase\n    return true;\n}\n```\n\n### Quick test harness\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::map<std::string, std::string> m1{{\"a\", \"apple\"}, {\"b\", \"banana\"}};\n    std::map<std::string, std::string> m2{{\"a\", \"apple\"}, {\"A\", \"banana\"}};\n    std::map<std::string, std::string> m3{{\"Name\", \"John\"}, {\"Age\", \"36\"}};\n    std::map<std::string, std::string> m4{{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}};\n\n    std::cout << std::boolalpha;\n    std::cout << \"m1 -> \" << check_dict_case(m1) << '\\n'; // true\n    std::cout << \"m2 -> \" << check_dict_case(m2) << '\\n'; // false\n    std::cout << \"m3 -> \" << check_dict_case(m3) << '\\n'; // false\n    std::cout << \"m4 -> \" << check_dict_case(m4) << '\\n'; // true\n}\n```\n\nCompile with a C++17 (or newer) compiler:\n\n```bash\ng++ -std=c++17 -Wall -Wextra -pedantic -o check_case check_case.cpp\n```\n\nThe function should satisfy all the examples you listed."]}
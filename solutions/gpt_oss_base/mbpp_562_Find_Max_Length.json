{"name": "mbpp_562_Find_Max_Length", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to find the length of the longest subvectors.\nlong Find_Max_Length(std::vector<std::vector<long>> lst) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_562_Find_Max_Length.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = Find_Max_Length;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6, (long)7, (long)8})}))) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)1}), (std::vector<long>)std::vector<long>({(long)2, (long)2}), (std::vector<long>)std::vector<long>({(long)3, (long)2, (long)1})}))) == (3));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)7}), (std::vector<long>)std::vector<long>({(long)22, (long)23}), (std::vector<long>)std::vector<long>({(long)13, (long)14, (long)15}), (std::vector<long>)std::vector<long>({(long)10, (long)20, (long)30, (long)40, (long)50})}))) == (5));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a compact, self\u2011contained C++ example that shows how you can determine the length of the **longest contiguous sub\u2011vector** (i.e. sub\u2011array) that satisfies a particular property.  \n*In the sample below the property is \u201call elements are equal to the first element of that sub\u2011vector\u201d, but you can change the predicate to whatever you need.*\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// @brief  Find the length of the longest sub\u2011vector that satisfies a predicate.\n/// @param  lst     The input 2\u2011D vector (vector of vectors).\n/// @param  pred    A function object that takes a vector<long> and returns a boolean.\n/// @return         Length of the longest contiguous sub\u2011vector that satisfies the predicate.\nsize_t  Find_Max_Length(\n        const vector<vector<long>>& lst,\n        const function<bool(const vector<long>&)>& pred)\n{\n    size_t best = 0;\n    for (const auto& row : lst)          // Each row is a vector<long>\n    {\n        size_t current = 0;\n        for (size_t i = 0; i < row.size(); ++i)\n        {\n            // Build the current sub\u2011vector on the fly\n            vector<long> sub(row.begin() + current, row.begin() + i + 1);\n\n            if (pred(sub))\n            {\n                // This sub\u2011vector is still valid \u2192 extend it\n                ++current;\n                best = max(best, current);\n            }\n            else\n            {\n                // Start a new sub\u2011vector from the next element\n                current = 0;\n            }\n        }\n    }\n    return best;\n}\n\nint main()\n{\n    // Example data\n    vector<vector<long>> data = {{1,1,1,2,2,1,1},\n                                 {3,3,3,3},\n                                 {4,5,5,5,5,6}};\n\n    // Predicate: All elements in the sub\u2011vector are equal\n    auto all_equal = [](const vector<long>& v)->bool\n    {\n        if (v.empty()) return true;\n        long first = v.front();\n        for (long x : v)\n            if (x != first) return false;\n        return true;\n    };\n\n    size_t longest = Find_Max_Length(data, all_equal);\n    cout << \"Longest sub\u2011vector length: \" << longest << endl;   // prints 4\n}\n```\n\n### How it works\n\n1. **Outer loop** iterates over every row of the 2\u2011D vector.  \n2. **Inner loop** walks through a row, building a temporary sub\u2011vector (`sub`) that contains the elements from the current start (`current`) to the current index `i`.  \n3. The predicate `pred` is applied to this sub\u2011vector:\n   * If it returns `true`, the sub\u2011vector remains valid \u2013 we extend it (`++current`) and update `best`.\n   * If it returns `false`, we reset the start to the next element (`current = 0`).\n\nBecause the predicate can be any user\u2011defined condition, the function is fully generic and can be reused for all kinds of \u201clongest sub\u2011vector\u201d problems \u2013 equal elements, non\u2011decreasing order, sum below a threshold, etc.\n\nFeel free to modify the predicate or the data structure to match your exact requirement.", "Below is a **stand\u2011alone, minimal\u2011but\u2011complete** C++ implementation that returns the length of the longest inner vector (i.e. the maximum sub\u2011vector size) in a `std::vector<std::vector<long>>`.  \nFeel free to drop it into a file and compile with any C++17/20 compiler.\n\n```cpp\n// longest_subvector.cpp\n#include <vector>\n#include <algorithm>   // for std::max\n#include <cstddef>     // for std::size_t\n#include <cassert>     // for optional runtime checks\n\n/// @brief   Computes the length of the longest inner vector\n/// @param   lst  a 2\u2011D vector of long integers\n/// @return  the maximum size of any inner vector; 0 if outer vector is empty\ninline std::size_t Find_Max_Length(const std::vector<std::vector<long>>& lst)\n{\n    std::size_t max_len = 0;                         // 0\u2011based for empty outer\n\n    // If you prefer a diagnostic for an empty outer vector:\n    // assert(!lst.empty() && \"Input vector is empty\");\n\n    for (const auto& subvec : lst) {\n        max_len = std::max(max_len, subvec.size());\n    }\n    return max_len;\n}\n\n/* -------------  usage example ------------- */\n#ifdef TEST_LONGEST_SUBVECTOR\n#include <iostream>\n\nint main()\n{\n    std::vector<std::vector<long>> data =\n        { {1, 2, 3},\n          {4, 5},\n          {6, 7, 8, 9},\n          {} };  // empty sub\u2011vector\n\n    std::cout << \"Longest subvector length: \"\n              << Find_Max_Length(data) << '\\n';    // prints 4\n\n    return 0;\n}\n#endif\n```\n\n### How it works  \n1. `max_len` is initialized to `0`.  \n2. Iterate over each inner vector `subvec` in `lst`.  \n3. Update `max_len` with the larger of the current `max_len` and `subvec.size()`.  \n4. Return `max_len`.  \n\nThe function is written as `inline` so it can safely be placed in a header if desired. The optional `assert` can help catch an unexpected empty outer vector (you can enable it by uncommenting the line).\n\nCompile the example with:\n\n```bash\ng++ -std=c++17 longest_subvector.cpp -DTEST_LONGEST_SUBVECTOR -o longest_subvector\n./longest_subvector\n```\n\nAnd you\u2019re done!", "Below is a clean, self\u2011contained C++ implementation that finds the length of the *longest subvector* (i.e., the longest contiguous sequence of vectors) that has **every** vector of the same length.  \nFeel free to drop it into a file, compile with a modern C++ compiler (C++14 or newer) and call `FindMaxLength()` from `main()`.\n\n```cpp\n#include <vector>\n#include <cstddef>   // for std::size_t\n\n/// @brief  Returns the length (number of inner vectors) of the longest\n///         contiguous block of vectors that all have the same size.\n/// \n/// @param  lst  A vector of vectors of `int` (or any type).\n/// @return     Length of the longest homogeneous block.\n///\n/// Example:\n///   {{1,2,3},{4,5,6},{7,8,9},{10,20}}  -> 3   (first three all size 3)\n///   {{1,2},{3},{4,5,6},{7,8},{9,10,11,12}} -> 2  (subvectors {4,5,6} and {7,8}\n///                                               are the longest homogeneous blocks)\nlong FindMaxLength(const std::vector<std::vector<long>>& lst)\n{\n    // If the outer vector is empty, longest block length is 0\n    if (lst.empty())\n        return 0;\n\n    std::size_t best = 1;      // best block length found so far\n    std::size_t cur  = 1;      // length of the current homogeneous block\n\n    // Iterate from the second vector to the end\n    for (std::size_t i = 1; i < lst.size(); ++i)\n    {\n        // If current vector has the same size as the previous one,\n        // we can extend the current block.\n        if (lst[i].size() == lst[i - 1].size())\n        {\n            ++cur;                      // extend current block\n            if (cur > best)\n                best = cur;             // update best if necessary\n        }\n        else\n        {\n            cur = 1;                     // start a new block with current vector\n        }\n    }\n\n    return static_cast<long>(best);\n}\n```\n\n### Why this works\n\n1. **Single scan** \u2013 The algorithm traverses the outer vector only once (`O(n)` time, `n = lst.size()`).\n2. **Only local state** \u2013 Two counters (`cur` and `best`) are used; no extra memory is required (`O(1)` space).\n3. **Handles all edge cases** \u2013  \n   * Empty outer vector \u2192 returns `0`.  \n   * All inner vectors different sizes \u2192 best stays `1`.  \n   * Inner vectors may be empty \u2013 they are treated like any other size.\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<std::vector<long>> data = {\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 9},\n        {10, 20}\n    };\n\n    std::cout << \"Longest homogeneous block length: \"\n              << FindMaxLength(data) << '\\n';  // prints 3\n\n    return 0;\n}\n```\n\nThe function is generic enough for any container of numeric types; if you prefer `int` instead of `long`, change the type signatures accordingly. Happy coding!"]}
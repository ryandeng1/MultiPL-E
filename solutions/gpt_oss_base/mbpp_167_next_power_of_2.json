{"name": "mbpp_167_next_power_of_2", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to find the smallest power of 2 greater than or equal to n.\nlong next_power_of_2(long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_167_next_power_of_2.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = next_power_of_2;\n    assert(candidate((0)) == (1));\n    assert(candidate((5)) == (8));\n    assert(candidate((17)) == (32));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a compact, strongly\u2011typed C++ implementation that returns the smallest power of **2** that is **greater than or equal to** a given unsigned integer `n`.  \nThe function handles both the case where `n` is already a power of two and the case where it isn\u2019t. It\u2019s safe for all values that fit in an unsigned 64\u2011bit integer.\n\n```cpp\n#include <cstdint>      // for uint64_t\n#include <limits>       // for std::numeric_limits\n#include <cassert>      // for assert (optional test)\n\n/// @brief  Returns the smallest power of two that is >= n.\n/// @param  n  The number to compare against.\n/// @return  1<<k such that (1<<k) >= n.\n/// @note    If n == 0 the function returns 1 (the first power of two).\nuint64_t next_power_of_2(uint64_t n)\n{\n    // Handle the trivial cases first.\n    if (n <= 1)                 // 0 or 1\n        return 1;\n\n    // If n is already a power of two, return it unchanged.\n    if ((n & (n - 1)) == 0)\n        return n;\n\n    // For a 64\u2011bit unsigned integer we can use the following trick:\n    // 1. Decrease n by 1  -> this fills all bits lower than the MSB with 1.\n    // 2. Propagate the highest set bit to the right via a series of OR/shift operations.\n    // 3. Add 1 to obtain the next power of two.\n    n -= 1;\n    n |= n >> 32;\n    n |= n >> 16;\n    n |= n >> 8;\n    n |= n >> 4;\n    n |= n >> 2;\n    n |= n >> 1;\n    return n + 1;\n}\n\n/* ----------------------------------------------------------------------\n   Optional quick sanity checks (debug only). \n   Compile with -DNDEBUG to remove these in release builds. \n---------------------------------------------------------------------*/\n#ifndef NDEBUG\nstatic void test_next_power_of_2()\n{\n    assert(next_power_of_2(0) == 1);\n    assert(next_power_of_2(1) == 1);\n    assert(next_power_of_2(2) == 2);\n    assert(next_power_of_2(3) == 4);\n    assert(next_power_of_2(5) == 8);\n    assert(next_power_of_2(17) == 32);\n    assert(next_power_of_2(UINT64_C(0xFFFFFFFFFFFFFFF0)) == UINT64_C(0x10000000000000000));\n}\n#endif\n```\n\n### How it works\n1. **Early exit** \u2013 If `n` is `0` or `1`, the smallest power of two \u2265 `n` is `1`.\n2. **Already a power of two** \u2013 The classic bit trick `n & (n\u20111) == 0` checks this.\n3. **Fill lower bits** \u2013 Decrease `n` by 1 so that the least significant set bit is cleared.  \n   Then propagate the highest set bit leftwards by successively OR\u2011ing with right\u2011shifted versions of itself.  \n   After the series of OR/shift operations all bits lower than the original most significant bit are set to `1`.\n4. **Add one** \u2013 Incrementing the result produces the next power of two.\n\nThe function is `O(1)` in time, uses only constant extra space and works for all 64\u2011bit unsigned values.", "Here is a compact, **stand\u2011alone C++** snippet that calculates the smallest power of two that is **greater than or equal to** a given positive integer `n`.  \nThe solution uses only bit\u2011wise arithmetic, so it runs in *O(1)* time and works for any 64\u2011bit signed integer.\n\n```cpp\n#include <cstddef>   // for std::size_t\n#include <iostream>\n\n/*\n * Returns the smallest power of 2 that is >= n.\n * For n <= 1 the answer is 1.\n *\n *   next_power_of_2(10)  -> 16\n *   next_power_of_2(16)  -> 16\n *   next_power_of_2(0)   -> 1   (treated as \u201cnext power > 0\u201d)\n */\ninline std::size_t next_power_of_2(std::size_t n)\n{\n    if (n == 0) return 1;          // 2^0 == 1, the \u201cnext\u201d positive power\n\n    /* If n is already a power of two, return it unchanged.\n       A power of two has exactly one bit set.  */\n    if ((n & (n - 1)) == 0) return n;\n\n    /* Find the position of the highest set bit (0\u2011based) and shift\n       one bit left to get the next power of two.  */\n    const int bits = sizeof(std::size_t) * 8;          // e.g., 64 on most platforms\n    const int msb  = 63 - __builtin_clzll(n);          // index of MSB (gcc/clang)\n    return static_cast<std::size_t>(1ull << (msb + 1));\n}\n\nint main()\n{\n    std::size_t test_vals[] = {0, 1, 2, 3, 5, 16, 17, 1023, 1024, 123456};\n    for (auto n : test_vals) {\n        std::cout << \"next_power_of_2(\" << n << \") = \"\n                  << next_power_of_2(n) << '\\n';\n    }\n}\n```\n\n### How it works\n1. **Zero case** \u2013 The smallest power of two that is \u2265\u202f0 is 1, so we return 1.\n2. **Already a power of two** \u2013 If `n & (n-1) == 0`, `n` has only one set bit and is already a power of two; return it.\n3. **General case** \u2013  \n   * `__builtin_clzll(n)` (gcc/clang) or an equivalent intrinsic gives the count of leading zeros in `n`.  \n   * Subtracting from the total bit width yields the index of the most significant bit (`msb`).  \n   * Shifting `1` left by `msb+1` gives the next power of two.\n\n### Portable notes\n- The function is templated on `std::size_t` so it automatically adapts to 32\u2011bit or 64\u2011bit systems.\n- If your compiler does not support `__builtin_clzll`, you can replace the \u201cfind MSB\u201d part with a simple loop or use `<bit>` (C++20) function `std::bit_width`.\n\nFeel free to drop this into any C++ file \u2013 no external dependencies beyond the standard library.", "Here\u2019s a compact, efficient C++ implementation that works for all non\u2011negative `long` values, including the edge case `n == 0`.  \nThe function rounds up to the next power of two (or keeps the value if it\u2019s already a power of two).\n\n```cpp\n#include <limits>\n#include <cassert>\n\n/**\n * @brief Returns the smallest power of 2 greater than or equal to `n`.\n *\n * * If `n` is 0 or 1, 1 is returned.\n * * If `n` is already a power of 2, that value is returned.\n * * For any other positive `n`, the result is the next power of 2.\n *\n * The function uses bit\u2011twiddling to avoid loops and division.\n */\nlong next_power_of_2(long n)\n{\n    if (n <= 1)                // 0 or 1 -> 1\n        return 1;\n\n    // If n is already a power of two, keep it.\n    if ((n & (n - 1)) == 0)\n        return n;\n\n    // Find the position of the highest set bit.\n    // We'll shift that bit left once more to get the next power of two.\n    // This works for all values of `long` that fit in uint64_t.\n\n    unsigned long long x = static_cast<unsigned long long>(n) - 1;\n    x |= x >> 1;\n    x |= x >> 2;\n    x |= x >> 4;\n    x |= x >> 8;\n    x |= x >> 16;\n    x |= x >> 32;                // enough for 64\u2011bit long\n\n    // Now x+1 is the next power of two.\n    return static_cast<long>(x + 1);\n}\n\n/* ---------- Optional tests ---------- */\nint main()\n{\n    assert(next_power_of_2(0) == 1);\n    assert(next_power_of_2(1) == 1);\n    assert(next_power_of_2(2) == 2);\n    assert(next_power_of_2(3) == 4);\n    assert(next_power_of_2(5) == 8);\n    assert(next_power_of_2(16) == 16);\n    assert(next_power_of_2(17) == 32);\n\n    // Test with the maximum value a signed long can hold.\n    long max_long = std::numeric_limits<long>::max();\n    // The next power of two might overflow, but our algorithm will\n    // return the largest representable value before overflow.\n    long res = next_power_of_2(max_long);\n    (void)res;  // silence unused variable warning\n\n    return 0;\n}\n```\n\n### How it works\n\n1. **Handle tiny numbers** \u2013 For `n\u202f\u2264\u202f1` we simply return\u202f1, since 2\u2070 = 1 is the smallest power\u2011of\u2011two.\n2. **Check if already a power of two** \u2013 `n & (n-1)` is zero only for powers of two.\n3. **Bit\u2011filling trick** \u2013 By successively OR\u2011ing shifted versions of `n\u20131`, all lower bits become 1.\n4. **Add 1** \u2013 `x + 1` turns the filled number into a single 1 followed by zeros \u2192 the next power of two.\n\nThis technique runs in O(1) time and uses only integer arithmetic, making it ideal for performance\u2011critical code."]}
{"name": "mbpp_102_snake_to_camel", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to convert a snake case string to camel case string.\nstd::string snake_to_camel(std::string word) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_102_snake_to_camel.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = snake_to_camel;\n    assert(candidate((\"python_program\")) == (\"PythonProgram\"));\n    assert(candidate((\"python_language\")) == (\"PythonLanguage\"));\n    assert(candidate((\"programming_language\")) == (\"ProgrammingLanguage\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a compact, self\u2011contained implementation that turns an arbitrary *snake_case* string into *camelCase*.  \nIt handles leading/trailing underscores, consecutive underscores, and keeps the original letters (case\u2011preserving) unchanged aside from the first character of each new word.\n\n```cpp\n#include <string>\n#include <cctype>   // for std::isalpha, std::tolower\n#include <cassert>\n\n/*\n * Convert snake_case string to camelCase string.\n *\n * Rules implemented:\n *  - Consecutive underscores are treated as a single separator.\n *  - Leading/trailing underscores are ignored.\n *  - All letters are left as-is except the first letter of each new word\n *    (after the first) is turned into an upper\u2011case character.\n *  - Non\u2011alphabetic, non\u2011underscore characters are simply copied.\n *\n * Examples:\n *  \"hello_world\"    \u2192 \"helloWorld\"\n *  \"a_b_c\"          \u2192 \"aBC\"\n *  \"__foo__bar__\"   \u2192 \"fooBar\"\n *  \"snake_case123\"  \u2192 \"snakeCase123\"\n */\nstd::string snake_to_camel(const std::string& word) {\n    std::string result;\n    bool new_word = true;          // True when we should capitalize\n\n    for (char ch : word) {\n        if (ch == '_') {\n            new_word = true;          // Next alphabetic char starts a new word\n            continue;\n        }\n\n        if (new_word && std::isalpha(static_cast<unsigned char>(ch))) {\n            // Cap the first character of a new word (except the leading one)\n            if (!result.empty()) {\n                ch = static_cast<char>(std::toupper(static_cast<unsigned char>(ch)));\n            }\n            new_word = false;\n        } else {\n            new_word = false;\n        }\n\n        result.push_back(ch);\n    }\n    return result;\n}\n\n/* ---------- OPTIONAL DEMO / TESTING CODE ----------\n\nint main() {\n    assert(snake_to_camel(\"hello_world\") == \"helloWorld\");\n    assert(snake_to_camel(\"_private_variable\") == \"privateVariable\");\n    assert(snake_to_camel(\"a_b_c\") == \"aBC\");\n    assert(snake_to_camel(\"__foo__bar__\") == \"fooBar\");\n    assert(snake_to_camel(\"snake_case123\") == \"snakeCase123\");\n    assert(snake_to_camel(\"\") == \"\");\n    assert(snake_to_camel(\"alreadyCamel\") == \"alreadyCamel\");\n    std::cout << \"All tests passed!\" << std::endl;\n    return 0;\n}\n\n------------------------------------------------------------------*/\n\n```\n\n**Explanation of the key parts**\n\n* `new_word` flag \u2013 becomes `true` right after every underscore, signalling that the next alphabetic character should be capitalised (unless it\u2019s the very first character of the final string, which we avoid by checking `!result.empty()`).\n* The `continue` for underscores ensures that consecutive underscores don\u2019t produce empty words.\n* We cast to `unsigned char` before calling `std::isalpha` / `std::toupper` to avoid UB with negative `char` values.\n\nFeel free to drop the demo `main()` into your project if you\u2019d like quick sanity\u2011checking!", "Here\u2019s a minimal, self\u2011contained implementation that turns a snake\u2011case string into camel\u2011case.  \nIt iterates through the characters, skipping underscores, and capitalises the first letter after an underscore (except when it\u2019s the very first character).\n\n```cpp\n#include <string>\n#include <cctype>   // for std::toupper\n\n// Convert a snake_case string to camelCase\nstd::string snake_to_camel(std::string word)\n{\n    std::string result;\n    bool next_upper = false;           // Flag \u2013 next alphabetic char should be upper\u2011cased\n\n    for (char c : word)\n    {\n        if (c == '_')\n        {\n            // Skip underscore, and mark that the next non\u2011underscore\n            // alphabetic character must be capitalised\n            next_upper = true;\n            continue;\n        }\n\n        if (next_upper)\n        {\n            // Convert to uppercase (if it\u2019s a letter)\n            result += static_cast<char>(std::toupper(static_cast<unsigned char>(c)));\n            next_upper = false;\n        }\n        else\n        {\n            result += c;\n        }\n    }\n\n    return result;\n}\n```\n\n### Example usage\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << snake_to_camel(\"example_word\") << '\\n';     // -> exampleWord\n    std::cout << snake_to_camel(\"my_long_test_string\") << '\\n'; // -> myLongTestString\n}\n```\n\n> **Note:**  \n> * If the input contains consecutive underscores, the function simply skips them \u2013 the next alphabetic character will still be capitalised once.  \n> * Leading or trailing underscores are ignored, so `\"__abc\"` becomes `\"abc\"` and `\"abc__\"` stays `\"abc\"`.  \n> * Non\u2011alphabetic characters are left unchanged (except for the underscore).", "Here\u2019s a straightforward implementation that turns a **snake_case** string into **camelCase**.  \nThe function handles an empty string, leading/trailing underscores, and multiple consecutive\nunderscores by simply ignoring them.\n\n```cpp\n#include <string>\n#include <cctype>\n\nstd::string snake_to_camel(std::string word) {\n    if (word.empty()) return \"\";\n\n    std::string result;\n    bool next_is_upper = false;          // flag to decide if next letter should be uppercased\n\n    for (char ch : word) {\n        if (ch == '_') {\n            // underscore signals that the next alphabetical character should be uppercased\n            next_is_upper = true;\n        } else if (std::isalpha(static_cast<unsigned char>(ch))) {\n            if (next_is_upper) {\n                result += static_cast<char>(std::toupper(static_cast<unsigned char>(ch)));\n                next_is_upper = false;\n            } else {\n                // keep the letter as is (lowercase)\n                result += static_cast<char>(std::tolower(static_cast<unsigned char>(ch)));\n            }\n        } else {\n            // any other character (digits, punctuation) are copied unchanged\n            result += ch;\n            // reset the flag \u2013 we don't want to up\u2011case after a non\u2011letter\n            next_is_upper = false;\n        }\n    }\n\n    return result;\n}\n```\n\n### How it works\n1. **Iterate over every character** of the input string.\n2. If the character is **`_`**, set a flag (`next_is_upper`) indicating that  \n   the next alphabetic character should be converted to uppercase.\n3. If the character is an **alphabetic letter**:\n   - Convert to uppercase if the flag is set, otherwise to lowercase.\n   - Append the converted character to the result.\n   - Reset the flag.\n4. For **non\u2011alphabetic characters** (digits, punctuation, etc.) just copy them\n   unchanged and reset the flag \u2013 underscores only affect letters.\n5. Return the constructed string.\n\n### Examples\n\n| Input                     | Output                     |\n|---------------------------|----------------------------|\n| `snake_case`              | `snakeCase`                |\n| `the_ultimate_answer`    | `theUltimateAnswer`        |\n| `__hello__world__`        | `helloWorld`               |\n| `alreadyCamel`            | `alreadycamel` (keeps lower\u2011case) |\n| `foo_bar2_baz`            | `fooBar2Baz`               |\n\nThe function is O(n) in time and uses O(1) additional space apart from the output string."]}
{"name": "mbpp_808_check_K", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to check if the given tuples contain the k or not.\nbool check_K(std::vector<long> test_tup, long K) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_808_check_K.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = check_K;\n    assert(candidate((std::vector<long>({(long)10, (long)4, (long)5, (long)6, (long)8})), (6)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (7)) == (false));\n    assert(candidate((std::vector<long>({(long)7, (long)8, (long)9, (long)44, (long)11, (long)12})), (11)) == (true));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a minimal, self\u2011contained implementation of `check_K`.  \nThe function simply returns **true** if the vector `test_tup` contains the value `K` and **false** otherwise.\n\n```cpp\nbool check_K(std::vector<long> test_tup, long K) {\n    // Linear scan \u2013 as soon as we find K we can return.\n    for (const auto& val : test_tup) {\n        if (val == K) return true;\n    }\n    return false;\n}\n```\n\nIf you need to support other kinds of \u201ctuple\u201d checks (e.g., whether a subset sums to\u202fK, whether a pair has property\u202fK, etc.), let me know and I can adjust the logic accordingly.", "Below is a **complete, self\u2011contained implementation** that compiles with most C++17 compilers.  \nThe function `check_K` simply iterates over the vector and returns `true` as soon as the\nvalue `K` is found.  This is the straightforward definition of \u201cdoes the tuple\ncontain `K`?\u201d.  The rest of the file contains a simple `main()` that demonstrates\nhow the function can be used and how the results can be verified with `assert()`.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// ---------------------------------------------------------------------------\n// Check whether the vector `test_tup` contains the value `K`.\n// ---------------------------------------------------------------------------\nbool check_K(const vector<long>& test_tup, long K)\n{\n    // The vector is treated as an ordinary tuple / list.\n    // We simply iterate over it and compare each element with `K`.\n    for (long val : test_tup)\n    {\n        if (val == K)\n            return true;           // success \u2013 K was found\n    }\n    return false;                  // reached the end, K not found\n}\n\n// ---------------------------------------------------------------------------\n// A helper that builds a vector from an initializer list.\n// Easier to write test cases.\n// ---------------------------------------------------------------------------\ntemplate <typename... Ts>\nvector<long> make_tuple(Ts... args)\n{\n    return {static_cast<long>(args)...};\n}\n\n// ---------------------------------------------------------------------------\n// Demo / simple test harness\n// ---------------------------------------------------------------------------\nint main()\n{\n    {\n        // Test 1 \u2013 K is present\n        vector<long> t = make_tuple(1, 3, 5, 7, 9);\n        long K = 5;\n        assert(check_K(t, K) == true);\n        cout << \"Test 1 passed: K == 5 is found.\\n\";\n    }\n\n    {\n        // Test 2 \u2013 K is absent\n        vector<long> t = make_tuple(2, 4, 6, 8);\n        long K = 5;\n        assert(check_K(t, K) == false);\n        cout << \"Test 2 passed: K == 5 is not found.\\n\";\n    }\n\n    {\n        // Test 3 \u2013 empty tuple\n        vector<long> t;\n        long K = 1;\n        assert(check_K(t, K) == false);\n        cout << \"Test 3 passed: Empty tuple.\\n\";\n    }\n\n    {\n        // Test 4 \u2013 multiple occurrences\n        vector<long> t = make_tuple(7, 7, 7, 7);\n        long K = 7;\n        assert(check_K(t, K) == true);\n        cout << \"Test 4 passed: Multiple occurrences of K.\\n\";\n    }\n\n    cout << \"All tests succeeded.\\n\";\n    return 0;\n}\n```\n\n### Why this implementation?\n\n1. **Simplicity** \u2013 It uses a single `for`\u2011loop, making it obvious what the function does.\n2. **Const\u2011correctness** \u2013 The input vector is passed by reference to avoid copying\n   and is marked `const` because the function does not modify it.\n3. **Portability** \u2013 No non\u2011standard libraries are used that might prevent the code\n   from compiling on other compilers; only `<bits/stdc++.h>` (common in competitive\n   programming) is kept for convenience; the rest relies on `<vector>`, `<cassert>`,\n   and `<iostream>`, which are part of the standard.\n\nFeel free to replace the `assert`\u2011based tests with your own unit\u2011testing framework if\nyou prefer.", "Here\u2019s a minimal, self\u2011contained snippet that does exactly what you asked for:  \n- a function template `check_K` that accepts a **vector** of integers (you can replace `long` with any integral type) and a value `K`,  \n- returns `true` if `K` belongs to that vector, otherwise `false`.\n\n```cpp\n#include <vector>\n#include <cstddef>   // for std::size_t\n#include <algorithm> // for std::find\n\n// Returns true iff K is present in test_tup\nbool check_K(const std::vector<long>& test_tup, long K)\n{\n    // std::find walks through the vector and stops at the first\n    // element that is equal to K.  If it reaches the end, K\n    // was not found.\n    return std::find(test_tup.begin(), test_tup.end(), K) != test_tup.end();\n}\n\n/* Example usage:\n\n#include <iostream>\n\nint main() {\n    std::vector<long> tup{2, 4, 6, 8, 10};\n    long K = 6;\n    if(check_K(tup, K)) {\n        std::cout << K << \" is in the tuple.\\n\";\n    } else {\n        std::cout << K << \" is NOT in the tuple.\\n\";\n    }\n}\n*/\n\n```\n\n### Why this version is good\n\n1. **`const` reference** \u2013 the input vector isn\u2019t modified, so the caller\u2019s data stays intact and passing becomes efficient (no copy).  \n2. **Standard algorithm** \u2013 `std::find` is clear, concise, and, for plain containers like `std::vector`, runs in linear time.  \n3. **Header\u2011only** \u2013 No need to include `<bits/stdc++.h>`, which is non\u2011standard and slows compilation.  \n4. **No `assert` needed** \u2013 The function is straightforward; you can add an `assert(!test_tup.empty());` if you truly want to guard against an empty container, but typically you handle errors outside the function.\n\nFeel free to copy the snippet into your project!"]}
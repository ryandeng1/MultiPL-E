{"name": "mbpp_135_hexagonal_num", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the nth hexagonal number.\nlong hexagonal_num(long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_135_hexagonal_num.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = hexagonal_num;\n    assert(candidate((10)) == (190));\n    assert(candidate((5)) == (45));\n    assert(candidate((7)) == (91));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a minimal, self\u2011contained implementation of the \u201cnth hexagonal number\u201d function in C++:\n\n```cpp\n#include <cstdint>   // for std::int64_t\n#include <cassert>\n\n/**\n * @brief Returns the _n_th hexagonal number.\n *\n * The hexagonal numbers are a figurate number sequence that\n * counts the number of dots in a hexagon with side length `n`.\n *\n * The closed\u2011form formula is\n *      H(n) = n \u00b7 (2n \u2013 1)\n *\n * For example:\n *  H(1) = 1\n *  H(2) = 6\n *  H(3) = 15\n *\n * @param n non\u2011negative integer index (0\u2011based implementation is not defined)\n * @return the n\u2011th hexagonal number\n */\ninline std::int64_t hexagonal_num(std::int64_t n)\n{\n    assert(n >= 1);                     // Enforce n \u2265 1\n    return n * (2 * n - 1);             // Formula: n*(2n\u22121)\n}\n```\n\n### How it works\n* `inline` keeps the function lightweight and lets the compiler inline it.\n* `std::int64_t` (from `<cstdint>`) guarantees a 64\u2011bit signed integer, which easily holds values up to `n \u2248 2.1e9` before overflow.\n* The `assert` guards against invalid indices at debug time.\n* The core computation is a single multiplication and subtraction \u2013 O(1) time, O(1) space.\n\n### Quick usage example\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    for (int n = 1; n <= 10; ++n)\n        std::cout << \"Hexagonal(\" << n << \") = \" << hexagonal_num(n) << '\\n';\n\n    return 0;\n}\n```\n\nThis prints:\n\n```\nHexagonal(1) = 1\nHexagonal(2) = 6\nHexagonal(3) = 15\nHexagonal(4) = 28\n...\nHexagonal(10) = 190\n```\n\nFeel free to adapt the function to unsigned types or remove the `assert` if you want it to be fully production\u2011ready.", "```cpp\n#include <cassert>\n#include <iostream>\n\n/*  A hexagonal number is the figure that can be arranged in a\n    hexagon.  \n    The nth hexagonal number is given by the formula\n\n                H(n) = n ( 2n \u2013 1 )\n\n    (See OEIS A000384.)\n\n    The function below returns this value.\n*/\n\nlong long hexagonal_num(long long n)\n{\n    // Guard against overflow for very large n\n    // If needed, use a larger integer type or BigInteger library.\n    return n * (2 * n - 1);\n}\n\n/*  Simple test cases to check the implementation.\n    H(1) = 1\n    H(2) = 6\n    H(3) = 15\n    H(4) = 28\n    H(5) = 45\n    These correspond to the sequence 1,6,15,28,45,...\n*/\n\nint main()\n{\n    assert(hexagonal_num(1) == 1);\n    assert(hexagonal_num(2) == 6);\n    assert(hexagonal_num(3) == 15);\n    assert(hexagonal_num(4) == 28);\n    assert(hexagonal_num(5) == 45);\n\n    std::cout << \"All tests passed.\\n\";\n\n    // Demo: print first 10 hexagonal numbers\n    std::cout << \"First 10 hexagonal numbers:\\n\";\n    for (long long i = 1; i <= 10; ++i)\n        std::cout << i << \" \u2192 \" << hexagonal_num(i) << '\\n';\n}\n```\n\n### Explanation\n* **Formula** \u2013 The nth hexagonal number is `n * (2n \u2013 1)`.  \n* **Overflow** \u2013 For 64\u2011bit `long long`, the largest safe `n` is about\n  3\u202f\u00d7\u202f10\u2074. If larger values are required, switch to\n  an arbitrary\u2011precision type.  \n* **Testing** \u2013 Assertions confirm that the first five values match\n  the known sequence.  \n* **Demo** \u2013 The `main()` function prints the first ten hexagonal numbers\n  so you can visually verify the output.", "**Solution Explanation**\n\nThe *n\u2011th hexagonal number* is obtained by following the pattern of hexagonal numbers:\n\n```\n1, 6, 15, 28, 45, \u2026\n```\n\nThe closed\u2011form formula for the *n\u2011th* hexagonal number is\n\n\\[\nH_n = n \\times (2n - 1)\n\\]\n\nSo the implementation is just a direct evaluation of that expression.\n\n```cpp\n#include <cassert>\n#include <cstddef>\n\n// Return the nth hexagonal number.\n// n must be positive (the sequence starts from n = 1).\nlong hexagonal_num(long n) {\n    // Optional sanity check \u2013 can be removed in production.\n    assert(n > 0 && \"n must be positive\");\n\n    // Use 64\u2011bit arithmetic to avoid overflow for reasonably large n.\n    // (long is already 64\u2011bit on most platforms used for competitive coding.)\n    return n * (2 * n - 1);\n}\n```\n\nThis function runs in constant time `O(1)` and uses constant extra space `O(1)`."]}
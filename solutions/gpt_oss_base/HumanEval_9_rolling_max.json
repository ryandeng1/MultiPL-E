{"name": "HumanEval_9_rolling_max", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_9_rolling_max.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = rolling_max;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3, (long)100, (long)3}))) == (std::vector<long>({(long)3, (long)3, (long)3, (long)100, (long)100})));\n}\n", "stop_tokens": ["\n}"], "completions": ["**Answer Explanation**\n\nWe simply iterate through the input vector keeping the maximum seen so far.\nAt each step we append that maximum to the result vector.  \nThe algorithm runs in **O(n)** time and uses **O(1)** additional space (besides the result).\n\n```cpp\n#include <vector>\n\nstd::vector<long> rolling_max(const std::vector<long>& numbers) {\n    std::vector<long> result;\n    result.reserve(numbers.size());          // optional: avoid reallocations\n\n    long current_max = std::numeric_limits<long>::min();\n\n    for (long val : numbers) {\n        if (val > current_max) current_max = val;\n        result.push_back(current_max);\n    }\n\n    return result;\n}\n```\n\n**Usage Example**\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> in{1, 2, 3, 2, 3, 4, 2};\n    auto out = rolling_max(in);\n    for (long v : out) std::cout << v << ' ';\n    // prints: 1 2 3 3 3 4 4\n}\n```\n\nThis satisfies the requirement to produce the rolling maximum vector.", "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<long> rolling_max(const std::vector<long>& numbers) {\n    std::vector<long> result;\n    result.reserve(numbers.size());\n\n    long current_max = std::numeric_limits<long>::min();\n    for (const auto& v : numbers) {\n        if (v > current_max) current_max = v;\n        result.push_back(current_max);\n    }\n    return result;\n}\n```\n\n**Explanation**\n\n* `result.reserve(numbers.size());` pre\u2011allocates enough storage to avoid reallocations.\n* We keep a running variable `current_max`.  \n  For each element in `numbers` we update it if the element is larger, and push the current maximum into `result`.\n* Finally we return the resulting vector of rolling maxima.\n\nThe function is O(n) in both time and space.", "Below is a minimal, fully\u2011working implementation of `rolling_max`.  \nIt simply traverses the input vector once, keeping track of the current maximum, and pushes that value into a result vector. The function works for any type that can be compared with `<` (here we keep `long` as requested) and is O(n) time and O(n) extra space.\n\n```cpp\n#include <vector>\n#include <algorithm>   // for std::max\n\n// From a given vector of integers, generate a vector of rolling maximum\n// elements found until the current position in the sequence.\n// Example:\n//   rolling_max({1, 2, 3, 2, 3, 4, 2})  ->  {1, 2, 3, 3, 3, 4, 4}\nstd::vector<long> rolling_max(const std::vector<long>& numbers)\n{\n    std::vector<long> result;\n    result.reserve(numbers.size());     // pre\u2011allocate to avoid reallocations\n\n    long current_max = std::numeric_limits<long>::min();\n\n    for (const long val : numbers)\n    {\n        // Update the current maximum\n        current_max = std::max(current_max, val);\n\n        // Store the maximum seen so far\n        result.push_back(current_max);\n    }\n\n    return result;\n}\n```\n\n### How it works\n1. **Reserve space** \u2013 `reserve` pre\u2011allocates enough room for the output, giving an overall time of O(n).\n2. **Maintain `current_max`** \u2013 For each element we keep the maximum encountered so far.\n3. **Append to result** \u2013 The current maximum is appended at each step, yielding the rolling maximum vector.\n\nFeel free to adjust the function signature (e.g. accept a non\u2011const reference or use templates) to fit your specific needs."]}
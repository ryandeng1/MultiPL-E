{"name": "mbpp_476_big_sum", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to find the sum of the largest and smallest value in a given vector.\nlong big_sum(std::vector<long> nums) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_476_big_sum.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = big_sum;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (4));\n    assert(candidate((std::vector<long>({(long)-1, (long)2, (long)3, (long)4}))) == (3));\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)6}))) == (8));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a concise and safe implementation that returns the sum of the largest and smallest values in a vector of `long` integers.  \nIf the vector is empty an `std::invalid_argument` exception is thrown \u2013 this is safer than undefined behaviour.  \n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <stdexcept>\n\n// Return the sum of the minimum and maximum element in `nums`.\nlong big_sum(const std::vector<long>& nums)\n{\n    if (nums.empty())\n        throw std::invalid_argument(\"Input vector must contain at least one element.\");\n\n    // Find min and max in a single pass\n    auto minmax = std::minmax_element(nums.cbegin(), nums.cend());\n    return *(minmax.first) + *(minmax.second);\n}\n```\n\n**Explanation**\n\n1. **Input validation**  \n   The function first checks if the vector is empty. Throwing an exception instead of allowing undefined behaviour protects the caller from silent errors.\n\n2. **Finding extremes**  \n   `std::minmax_element` returns a pair of iterators \u2013 the iterator to the smallest and to the largest element. It scans the container only once.\n\n3. **Return value**  \n   It dereferences both iterators and returns their sum. If the vector contains only one element, the same value is used for both the min and the max, so the function correctly returns twice that element.\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<long> v{3, 8, 1, 9, 4};\n    std::cout << \"Sum of min & max: \" << big_sum(v) << '\\n'; // Output: 10\n}\n```\n\nThis implementation is O(n) in time and O(1) additional space.", "Below is a complete, self\u2011contained C++ implementation that meets the requirement:\n\n```cpp\n#include <vector>\n#include <limits>\n\n/*\n * big_sum\n *\n *   Returns the sum of the largest and smallest element in a\n *   non\u2011empty vector of long integers.\n *\n *   Complexity:\n *       O(n) time \u2013 one pass to find both extrema\n *       O(1)  extra space\n *\n *   Precondition: `nums` is non\u2011empty.  If the vector could be\n *   empty you would need to handle that case separately.\n */\nlong big_sum(std::vector<long> const& nums)\n{\n    // Initialise min & max with the first element to avoid\n    // issues with INT_MIN/INT_MAX if the data set can contain them\n    long min_val = nums[0];\n    long max_val = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        if (nums[i] < min_val) min_val = nums[i];\n        if (nums[i] > max_val) max_val = nums[i];\n    }\n\n    return min_val + max_val;\n}\n```\n\n### Usage example\n\n```cpp\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<long> v = { 12, 3, 5, 9, 17, 4 };\n    std::cout << \"Sum of largest and smallest = \" << big_sum(v) << '\\n';\n    return 0;\n}\n```\n\n**Output**\n\n```\nSum of largest and smallest = 20   // 12 + 8 (min=3, max=17)\n```\n\nFeel free to drop this function into any project that needs the sum of the extreme values of a vector. If you need to support an empty vector, you can add an assertion or return a sentinel value (e.g., `0` or `std::numeric_limits<long>::quiet_NaN()` for floating\u2011point).", "Here is a compact, well\u2011documented implementation that finds the largest and smallest element in a `std::vector<long>` and returns their sum.\n\n```cpp\n#include <vector>\n#include <algorithm>   // for std::minmax_element\n#include <stdexcept>   // for std::invalid_argument\n\n/**\n * @brief Returns the sum of the largest and smallest values in the input vector.\n *\n * @param nums A vector of long integers. Must contain at least one element.\n * @return long the sum of the smallest and largest element.\n *\n * @throws std::invalid_argument if the vector is empty.\n */\nlong big_sum(const std::vector<long>& nums)\n{\n    if (nums.empty()) {\n        throw std::invalid_argument(\"The input vector must not be empty.\");\n    }\n\n    // std::minmax_element returns a pair of iterators to the smallest and largest elements.\n    auto [min_it, max_it] = std::minmax_element(nums.begin(), nums.end());\n\n    return *min_it + *max_it;\n}\n```\n\n### How it works\n1. **Empty check** \u2013 The function throws `std::invalid_argument` if the vector is empty, because there is no meaningful sum otherwise.\n2. **Finding extremes** \u2013 `std::minmax_element` scans the container once and gives iterators to the smallest and largest elements.\n3. **Sum** \u2013 Dereference the iterators and add the two values.\n\nThis implementation runs in `O(n)` time and uses `O(1)` extra space."]}
{"name": "mbpp_771_check_expression", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to check if the given expression is balanced or not. https://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/\nbool check_expression(std::string exp) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_771_check_expression.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = check_expression;\n    assert(candidate((\"{()}[{}]\")) == (true));\n    assert(candidate((\"{()}[{]\")) == (false));\n    assert(candidate((\"{()}[{}][]({})\")) == (true));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a **complete, self\u2011contained** implementation of the function `check_expression` that determines whether a given arithmetic expression has all of its parentheses (including `()`, `{}`, and `[]`) correctly matched and nested.  \nThe implementation uses the classic *stack* approach described in the linked GeeksforGeeks article.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// @brief   Checks if an expression has balanced parentheses\n/// @param   exp  The string containing the expression\n/// @return  true  \u2013 if every opening parenthesis has a corresponding\n///         closing one in the correct order; false otherwise.\n///\n/// The function supports the three common types of brackets:\n///      (  )     {  }     [  ]\n/// All other characters are ignored.  This makes it suitable for\n/// arithmetic expressions, code snippets, etc.\n///\n/// Complexity\n///  ---------\n///  Time : O(n)   (one pass over the string)\n///  Space: O(n)   (worst\u2011case stack grows with the number of open brackets)\nbool check_expression(const string& exp) {\n    // Stack that will store opening brackets.\n    std::stack<char> st;\n\n    for (char ch : exp) {\n        // 1. Push every opening bracket onto the stack.\n        if (ch == '(' || ch == '{' || ch == '[') {\n            st.push(ch);\n            continue;\n        }\n\n        // 2. For a closing bracket, we must have a matching opening one.\n        if (ch == ')' || ch == '}' || ch == ']') {\n            if (st.empty())          // no open bracket to match\n                return false;\n\n            // The top must be the *matching* opening bracket.\n            char open = st.top();\n            st.pop();\n\n            if ((ch == ')' && open != '(') ||\n                (ch == '}' && open != '{') ||\n                (ch == ']' && open != '['))\n                return false;\n        }\n        // 3. All other characters are ignored.\n    }\n\n    // 4. If stack is empty, all opens were matched; otherwise not.\n    return st.empty();\n}\n\n/* ---------------------------------------------------------- */\n/* Example / Test harness \u2013 compile & run to sanity\u2011check     */\n/* ---------------------------------------------------------- */\n#ifdef UNIT_TEST\nint main() {\n    vector<string> tests = {\n        \"((a+b)*[c/d])\",     // Balanced\n        \"((a+b)*[c/d))\",     // Not balanced\n        \"([{}])\",            // Balanced\n        \"[{()}]\",            // Balanced\n        \"[(])\",              // Not balanced\n        \"((a+b)[c*d])\",      // Balanced\n        \"((a+b)[c*d)\",       // Not balanced\n        \"a+b+c\",             // Balanced (no brackets)\n        \"\",                  // Balanced (empty)\n        \"}{\",                // Not balanced\n    };\n\n    for (auto& exp : tests) {\n        cout << '\"' << exp << \"\\\" : \"\n             << (check_expression(exp) ? \"Balanced\" : \"Not balanced\") << '\\n';\n    }\n    return 0;\n}\n#endif\n```\n\n### How it works\n\n1. **Push** every opening bracket onto a stack.\n2. When a closing bracket is encountered:\n   * The stack must not be empty.\n   * The top of the stack must be the *matching* opening bracket.\n3. Ignore all other characters (digits, operators, identifiers, spaces).\n4. After processing the whole string, the stack must be empty for the expression to be balanced.\n\n### Edge\u2011cases captured\n\n| Expression | Expected | Reason                                      |\n|------------|----------|---------------------------------------------|\n| `()[]{}()` | Balanced | All opens have matching closes in order.    |\n| `([)]`     | Not      | Closing `)` doesn't match the last open `[`. |\n| `([]{}`    | Not      | Unmatched `{` left on the stack.            |\n| `a+b+c`    | Balanced | No brackets \u2192 trivially balanced.           |\n\nCompile with the optional `UNIT_TEST` flag to run the built\u2011in examples:\n\n```bash\ng++ -DUNIT_TEST -std=c++20 main.cpp && ./a.out\n```\n\nFeel free to integrate `check_expression` wherever you need bracket\u2011balance checking in your C++ projects.", "You can solve the problem by using a simple stack.  \nFor every opening bracket (`(`, `{`, `[`) push it onto the stack.  \nFor every closing bracket, pop the top of the stack (if any) and make sure its type matches the opening one; if it does not match or the stack is empty, the expression is not balanced.\n\nBelow is a minimal C++ implementation that follows your skeleton and can be compiled with a modern compiler that supports C++17.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Return true iff |exp| is a balanced expression.\n// Only the four pairs of parentheses are considered.\nbool check_expression(const string& exp)\n{\n    stack<char> st;                       // hold opening brackets\n\n    // helper to check pair\n    auto is_match = [](char open, char close) -> bool {\n        return (open=='(' && close==')') ||\n               (open=='[' && close==']') ||\n               (open=='{' && close=='}');\n    };\n\n    for (char ch : exp) {\n        if (ch=='(' || ch=='[' || ch=='{')\n            st.push(ch);                  // opening bracket\n        else if (ch==')' || ch==']' || ch=='}') {\n            if (st.empty() || !is_match(st.top(), ch))\n                return false;             // either mismatch or nothing to match\n            st.pop();                     // matched pair found\n        }\n        // Any other characters are ignored (as per the G4G example)\n    }\n\n    return st.empty();                    // true only if no unmatched openings remain\n}\n\n/* -----------------  Demo / tests ----------------- */\n#ifdef DEMO\nint main()\n{\n    vector<string> tests = {\n        \"((()))\",              // true\n        \"(((())\",              // false\n        \"({[()]})\",            // true\n        \"({[([)])})\",          // false\n        \"a+b*c-(x/y)+z\",       // true (ignoring other chars)\n        \"(((a+b)*c)+d)\",       // true\n        \")(\",                 // false\n    };\n\n    for (const auto& s : tests) {\n        cout << s << \" => \" << (check_expression(s) ? \"Balanced\" : \"Unbalanced\") << '\\n';\n    }\n    return 0;\n}\n#endif\n```\n\n### How it works\n1. **Stack approach** \u2013 LIFO guarantees that each closing bracket is matched with the most recent unmatched opening bracket.\n2. **Helper lambda `is_match`** \u2013 Keeps the pair\u2011checking logic isolated and readable.\n3. **Return value** \u2013 `true` only if all brackets were correctly matched and none were left unmatched in the stack.\n\nCompile with:\n\n```bash\ng++ -std=c++17 -Wall -Wextra -DDEMO your_file.cpp\n```\n\nThe `DEMO` section (guarded by `#ifdef DEMO`) is optional; remove it or undefine `DEMO` if you only need the function in a bigger codebase.", "Here\u2019s a minimal, self\u2011contained implementation that checks for balanced parentheses, brackets and braces in a C++ expression.  \nIt works for `()`, `[]` and `{}` \u2013 you can easily extend it to other kinds of delimiters if you wish.\n\n```cpp\n#include <string>\n#include <stack>\n#include <unordered_map>\n#include <cassert>\n\n// Return true iff every opening symbol has a matching closing symbol\n// and the order is correct.\nbool check_expression(const std::string& exp)\n{\n    std::stack<char> st;\n    // map of opening \u2192 closing\n    const std::unordered_map<char,char> matching{\n        {'(', ')'},\n        {'[', ']'},\n        {'{', '}'}\n    };\n\n    // Set of opening symbols for quick lookup\n    std::unordered_map<char,char> openings;\n    for (const auto &p : matching)\n        openings[p.first] = p.second;\n\n    for (char c : exp) {\n        // If we see an opening bracket, push it on stack\n        if (openings.count(c)) {\n            st.push(c);\n        }\n        // If we see a closing bracket, stack must be non\u2011empty\n        // and the top must match the current closing.\n        else if (!st.empty() && st.top() == matching.at(c)) {\n            st.pop();\n        }\n        else if (!random) { // this simple check handles non\u2011bracket chars\n            // ignore everything else (digits, operators, spaces, etc.)\n        }\n    }\n\n    // If stack is empty \u2192 all opens matched\n    return st.empty();\n}\n\n/* ---------- Quick test harness ---------- */\nint main()\n{\n    assert(check_expression(\"()\") == true);\n    assert(check_expression(\"(())\") == true);\n    assert(check_expression(\"([{}])\") == true);\n    assert(check_expression(\"(]\") == false);\n    assert(check_expression(\"([)]\") == false);\n    assert(check_expression(\"((())\") == false);\n    assert(check_expression(\"\") == true);\n\n    // More elaborate examples\n    std::string code1 = \"int main(){ std::cout << \\\"hi\\\"; }\";\n    std::string code2 = \"if (x > 0){ y = z[1]; } else { y = w; }\";\n    std::string bad = \"if (x > 0){ y = z[1]; } else { y = w;\";\n\n    assert(check_expression(code1) == true);\n    assert(check_expression(code2) == true);\n    assert(check_expression(bad) == false);\n\n    std::cout << \"All tests passed.\\n\";\n}\n```\n\n### How it works\n1. **`matching` map** \u2013 tells you what the corresponding closing symbol is for each opening one.\n2. **`openings` set** \u2013 quickly tells you if a character is an opening brace.\n3. **Stack** \u2013 when you encounter an opening symbol, push it. When you encounter a closing symbol, check that the stack isn\u2019t empty and that the top opening corresponds to this closing one. If it does, pop it.\n4. After the loop, the stack must be empty \u2013 all openings found matching closings.\n\nYou can drop the test harness (`main`) into your own code or run the compilation to make sure everything works correctly."]}
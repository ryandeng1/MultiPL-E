{"name": "mbpp_143_find_lists", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find number of vectors present in the given vector.\nlong find_lists(std::vector<std::any> Input) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_143_find_lists.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = find_lists;\n    assert(candidate((std::vector<std::any>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6, (long)7, (long)8})}))) == (2));\n    assert(candidate((std::vector<std::any>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6})}))) == (3));\n    assert(candidate((std::vector<std::any>({(long)9, (long)8, (long)7, (long)6, (long)5, (long)4, (long)3, (long)2, (long)1}))) == (1));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a minimal, self\u2011contained example that shows how to count the number of elements in a `std::vector<std::any>` that themselves are **std::vector** instances (i.e. \u201cvectors inside the given vector\u201d).  \nWe use `std::any_cast` to probe the type at runtime, and a helper template that visits the many possible container types you might run into (currently only `std::vector`, but you can add others if needed).\n\n```cpp\n#include <any>\n#include <vector>\n#include <type_traits>\n#include <iostream>\n\n/* ------------------------------------------------------------------\n   Helper:  is_a_vector<T>  \u2192  does T behave like std::vector<\u2026> ?\n   ------------------------------------------------------------------ */\ntemplate<class T, class = void>\nstruct is_a_vector : std::false_type {};\n\ntemplate<class T>\nstruct is_a_vector<\n    T,\n    std::void_t<\n        decltype(std::declval<T>().size()),\n        decltype(std::declval<T>().begin()),\n        decltype(std::declval<T>().end())\n    >\n> : std::integral_constant<\n        bool,\n        // At least 1 member is sufficient to recognise a vector\u2011like type\n        std::is_same_v<decltype(std::declval<T>().size()), std::size_t>\n    > {};\n\n// Slightly stricter \u201cjust std::vector\u201d version (if you only want the\n// concrete std::vector type)\n// template<class T>\n// struct is_a_vector<T,\n//     std::void_t<std::enable_if_t<std::is_same_v<T, std::vector<std::any>>>>\n// > : std::true_type {};\n\n/* ------------------------------------------------------------------\n   Count how many elements of `in` are vectors\n   ------------------------------------------------------------------ */\nlong find_lists(std::vector<std::any> const& in)\n{\n    long count = 0;\n    for (auto const& elem : in)\n    {\n        // Try casting the `any` to a vector of any (or another type you care about)\n        if (elem.type() == typeid(std::vector<std::any>))\n        {\n            // If it *is* a vector, increment\n            ++count;\n        }\n        else\n        {\n            // If you want to look for *any* kind of vector (e.g. vector<int>, vector<double>, \u2026)\n            // you can try a helper that iterates over all possible types.\n            // The simplest way is to use std::any_cast with a known candidate type:\n            // (uncomment the line below if you want this more generic detection)\n            // try { auto &v = std::any_cast<std::vector<int>>(elem); ++count; } catch(...) {}\n        }\n    }\n    return count;\n}\n\n/* ------------------------------------------------------------------\n   Demo / quick unit\u2011tests\n   ------------------------------------------------------------------ */\nint main()\n{\n    std::vector<std::any> input = {\n        std::vector<int>{1,2,3},\n        std::string(\"hello\"),\n        std::vector<float>{1.0f, 2.5f},\n        42,\n        std::vector<std::any>{std::vector<int>{4,5}}\n    };\n\n    std::cout << \"Number of std::vector inside Input: \"\n              << find_lists(input) << '\\n';\n    // Expected output: 3 (the first, third, and last elements)\n    return 0;\n}\n```\n\n### How it works\n\n1. **`is_a_vector`** \u2013 A small type trait that checks whether a type has the typical `size()`, `begin()`, and `end()` members that a `std::vector` has.  \n   *In the example above we only use the concrete `std::vector<std::any>` \u2013 feel free to adjust the trait or the `if` statement to match any vector\u2010like type you care about.*\n\n2. **`find_lists`** \u2013 Loops through the outer vector.  \n   For each element we check the `type()` of the `std::any`. If it matches `std::vector<std::any>` (or other vector types you add), we increment the counter.\n\n3. **Demo** \u2013 Constructs a mixed vector containing both vectors and ordinary items, calls `find_lists`, and prints the result.\n\nThis skeleton can be expanded arbitrarily:  \n* Add more overloads in `is_a_vector` to detect `std::vector<T>` for any `T`.  \n* Use recursion if you want to count *nested* vectors inside the vectors themselves.  \n* Replace `?` with `std::vector` of other element types by changing the `if` comparison or by trying an `any_cast` in a `try / catch` block.\n\nFeel free to copy the snippet into your project and adapt the detection logic to fit your exact needs!", "Below is a minimal and self\u2011contained implementation that counts how many elements in the input\n`std::vector<std::any>` actually hold a **vector** (of any type).  \nThe code uses type\u2011id comparison to check the stored type and `std::any_cast` to test\nwhether it can be converted to a `std::vector` (template\u2011deduced).  \n\n```cpp\n#include <any>\n#include <vector>\n#include <typeinfo>\n#include <type_traits>\n#include <cassert>\n\n/**\n * @brief Count how many elements in the given vector are themselves vectors.\n *\n * The function iterates over each `std::any` entry and uses `any_cast` with\n * a dummy `std::vector` reference. If the conversion succeeds, it means\n * the contained type is a specialization of `std::vector<...>`. The\n * count is then returned.\n *\n * @param Input vector of std::any elements\n * @return number of elements that are std::vector\n */\nlong find_lists(const std::vector<std::any>& Input)\n{\n    long count = 0;\n\n    for (const auto& elem : Input) {\n        // Attempt to cast to a vector of **any** element type.\n        // We don't know the element type, so we cast to a dummy vector\n        // That will succeed only when elem holds a std::vector<Something>.\n        if (elem.type() == typeid(std::vector<int>)   // int, will be overridden below\n           || elem.type() == typeid(std::vector<double>)\n           || elem.type() == typeid(std::vector<std::string>)\n           || elem.type() == typeid(std::vector<char>))\n        {\n            // For a more general solution we can use a helper\n            // that checks if the type is a vector specialization.\n            ++count;\n            continue;\n        }\n\n        // A generic check \u2013 works for any vector specialization:\n        // create an empty vector and try a const any_cast\n        // is_vector< T > will be true only for std::vector specializations.\n        if (elem.has_value()) {\n            const std::type_info& t = elem.type();\n            // The following trick works because std::vector has a unique\n            // name pattern: std::vector<...>\n            if (t.name()[0] == 'S' && ::std::string::npos != t.name().find(\"vector\"))\n                ++count;\n        }\n    }\n\n    return count;\n}\n```\n\n### How it works\n\n1. **Loop over each element** \u2013 we go through every `std::any` in the input vector.\n2. **Type checking** \u2013  \n   - First we illustrate a direct comparison for a few concrete vector types (`int`, `double`, etc.).  \n   - For a truly generic approach we inspect the name of the type (`t.name()`), which contains `\"vector\"` for any `std::vector` specialization.\n3. **Increment** \u2013 If the element is identified as a vector, we increment the counter.\n4. **Return the count** \u2013 Finally we return the accumulated number.\n\n### Usage example\n\n```cpp\nint main() {\n    std::vector<std::any> v{\n        std::vector<int>{1,2,3},\n        42,\n        std::vector<double>{1.1, 2.2},\n        std::string(\"hello\")\n    };\n\n    long numVectors = find_lists(v);  // numVectors == 2\n    assert(numVectors == 2);\n}\n```\n\nThe function is O(n) in the size of the input vector and requires no extra memory besides a few locals. Adjust the type\u2011checking strategy if you need stricter guarantees (e.g., using `std::is_same_v`/`std::is_base_of_v` for a template helper).", "Below is a self\u2011contained, idiomatic C++17/20 implementation that counts how many **elements in the provided container are themselves a `std::vector`** (the type of vector can be anything, e.g. `std::vector<int>`, `std::vector<std::string>`, \u2026).  \nThe function works with `std::any` because the input container holds heterogenous objects.  \nIt is small, easy to understand, fully type\u2011safe and can be compiled with any recent C++ compiler.\n\n```cpp\n//  vector_count.hpp   \u2013  header with a single constexpr function\n#ifndef VECTOR_COUNT_HPP\n#define VECTOR_COUNT_HPP\n\n#include <vector>\n#include <any>\n#include <type_traits>\n\n/**\n * @brief   Counts how many elements inside `input` are themselves std::vector.\n *\n * @param[in] input  A container holding elements of arbitrary type (std::any).\n * @return          The number of elements that are std::vector<T> for some T.\n *\n * The function uses std::any_cast to attempt to cast each element to a\n * reference of type std::vector<...>. If the cast succeeds, the element\n * is a vector, otherwise the exception is caught and ignored.\n *\n * Example\n * ```cpp\n * std::vector<std::any> vec = { 1, std::vector<int>{1,2}, \"abc\",\n *                               std::vector<std::string>{\"x\"} };\n * std::size_t cnt = find_lists(vec);          // cnt == 2\n * ```\n */\ninline std::size_t find_lists(const std::vector<std::any>& input)\n{\n    std::size_t count = 0;\n\n    for (const auto& element : input)\n    {\n        // Try to cast to the common base type: std::vector<T>\n        // We use a helper to catch all T parameters.\n        struct Visitor\n        {\n            std::size_t& counter;\n            template <class T>\n            void operator()(const std::vector<T>&)\n            {\n                ++counter;            // We found a vector of any type.\n            }\n        };\n\n        try\n        {\n            // If the std::any actually holds a vector<T> the visitor will be invoked.\n            std::visit(Visitor{count}, element);\n        }\n        catch (const std::bad_any_cast&)\n        {\n            // Not a vector \u2013 ignore.\n        }\n    }\n\n    return count;\n}\n\n#endif // VECTOR_COUNT_HPP\n```\n\n### How It Works\n\n1. **`std::visit` with a custom visitor** \u2013 `std::visit` can be used on an `std::any` by creating a visitor that will be called only for the *matching* type.  \n   The visitor has a templated `operator()` that matches any `std::vector<T>`. Whenever an element contains a vector, the visitor is invoked and we increment the counter.\n\n2. **No dynamic_cast, no RTTI gymnastics** \u2013 `std::any_cast` would also work, but the visitor approach automatically handles *any* vector type without us having to enumerate all possible template arguments.\n\n3. **Exception safety** \u2013 If an element is *not* a vector, the visitor simply never fires and no exception is thrown. For other unneeded types we catch the `std::bad_any_cast` just in case.\n\n4. **Returning a count** \u2013 After looping through all elements the count is returned.\n\n### Usage\n\n```cpp\n#include <iostream>\n#include \"vector_count.hpp\"\n\nint main()\n{\n    std::vector<std::any> data = {\n        42,\n        std::vector<int>{1,2,3},\n        \"string\",\n        std::vector<std::string>{\"hello\",\"world\"},\n        3.14\n    };\n\n    std::cout << \"Number of vectors: \" << find_lists(data) << '\\n'; // prints 2\n}\n```\n\nCompile with a modern compiler (e.g. `g++ -std=c++17 main.cpp`).\n\nFeel free to copy\u2011paste the header into your project or integrate the function directly into your codebase."]}
{"name": "HumanEval_85_add", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_85_add.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = add;\n    assert(candidate((std::vector<long>({(long)4, (long)88}))) == (88));\n    assert(candidate((std::vector<long>({(long)4, (long)5, (long)6, (long)7, (long)2, (long)122}))) == (122));\n    assert(candidate((std::vector<long>({(long)4, (long)0, (long)6, (long)7}))) == (0));\n    assert(candidate((std::vector<long>({(long)4, (long)4, (long)6, (long)8}))) == (12));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a minimal, self\u2011contained implementation that follows the specification:\n\n```cpp\n#include <vector>\n\n/// Adds the elements that are even **and** located at an odd index.\n///\n///  * The vector is non\u2011empty.\n///  * Indexing follows the common C/C++ convention: the first element has index 0.\n///  * \u201cOdd indices\u201d mean 1, 3, 5, \u2026\n///  * An element is \u201ceven\u201d if it is divisible by 2.\n///\n/// @param lst the list of integers.\n/// @return the sum of the qualifying elements.\nlong add(const std::vector<long>& lst) {\n    long sum = 0;\n\n    // iterate only over odd indices\n    for (std::size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```\n\n### How it works\n\n1. We start with `sum = 0`.\n2. Loop over the vector using `i = 1; i < lst.size(); i += 2` \u2013 this guarantees that only odd indices (1, 3, 5, \u2026) are inspected.\n3. For each such element, test `lst[i] % 2 == 0`; if it is even, add it to `sum`.\n4. Return the accumulated sum.\n\n### Example\n\n```cpp\nint main() {\n    std::vector<long> v = {4, 2, 6, 7};\n    std::cout << add(v) << '\\n';  // prints 2\n    return 0;\n}\n```\n\n- Index\u202f1 \u2192 value\u202f2 (even) \u2192 added\n- Index\u202f3 \u2192 value\u202f7 (odd) \u2192 ignored  \n  Result = 2.", "```cpp\n#include <vector>\n\n/*  Sum all elements that satisfy two conditions:\n *   1. The element is even   (value % 2 == 0)\n *   2. The index of the element is odd   (index % 2 == 1)\n *\n *  Example:\n *      std::vector<long> v = {4, 2, 6, 7};\n *      add(v);   // returns 2  (only 2 is even and sits at index 1)\n */\nlong add(const std::vector<long>& lst)\n{\n    long sum = 0;\n\n    // iterate over all indices\n    for (std::size_t i = 0; i < lst.size(); ++i)\n    {\n        // check for odd index and even value\n        if ( (i & 1) && (lst[i] % 2 == 0) )\n            sum += lst[i];\n    }\n\n    return sum;\n}\n```\n\nThis implementation:\n* uses a single loop (`O(n)` time).\n* accumulates the sum only when both conditions hold.\n* returns the result as `long`, matching the function signature.", "Here is a complete, compact implementation that follows the specification:\n\n```cpp\n#include <vector>\n\n/*  add:\n *  Given a non\u2011empty vector of integers, return the sum of all\n *  even elements that are positioned at odd indices (0\u2011based).\n * \n *  Example:\n *      add({4, 2, 6, 7})   ->  2   (only 2 meets the criteria)\n */\nlong add(const std::vector<long>& lst) {\n    long sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {   // iterate over odd indices\n        if (lst[i] % 2 == 0) {                     // check if the element is even\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```\n\n**Explanation**\n\n* We iterate over indices `i = 1, 3, 5, \u2026` (odd indices) using `size_t` to avoid signed/unsigned mix\u2011ups.\n* For each such element, we test `lst[i] % 2 == 0` to see if it is even.\n* Qualified elements are added to `sum`, which is returned at the end.\n\nThe function works for any non\u2011empty `std::vector<long>`. If you want to handle an empty vector safely, just return `0` in that case (the loop will naturally do nothing)."]}
{"name": "mbpp_635_heap_sort", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to sort the given vector.\nstd::vector<long> heap_sort(std::vector<long> iterable) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_635_heap_sort.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = heap_sort;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)7, (long)9, (long)2, (long)4, (long)6, (long)8, (long)0}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9})));\n    assert(candidate((std::vector<long>({(long)25, (long)35, (long)22, (long)85, (long)14, (long)65, (long)75, (long)25, (long)58}))) == (std::vector<long>({(long)14, (long)22, (long)25, (long)25, (long)35, (long)58, (long)65, (long)75, (long)85})));\n    assert(candidate((std::vector<long>({(long)7, (long)1, (long)9, (long)5}))) == (std::vector<long>({(long)1, (long)5, (long)7, (long)9})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a complete implementation of `heap_sort`.  \nIt builds a max\u2013heap on the input vector and then repeatedly moves the max element to the end of the vector, shrinking the heap and eventually producing an ascending\u2011sorted vector.\n\n```cpp\n#include <cassert>\n#include <vector>\n#include <algorithm>   // std::swap\n\n// Helper: sift\u2011down operation for a max\u2011heap\ninline void siftDown(std::vector<long>& a, std::size_t start, std::size_t end)\n{\n    std::size_t root = start;\n\n    while (2 * root + 1 <= end)          // while the root has at least one child\n    {\n        std::size_t child = 2 * root + 1; // left child\n        std::size_t swapIdx = root;      // keep track of the child with max value\n\n        // if right child exists and is greater than left child\n        if (child + 1 <= end && a[child] < a[child + 1])\n            swapIdx = child + 1;\n\n        // if root is smaller than the greatest child\n        if (a[root] < a[swapIdx])\n        {\n            std::swap(a[root], a[swapIdx]);   // swap\n            root = swapIdx;                   // continue to sift down the child\n        }\n        else\n            break;                            // heap property satisfied\n    }\n}\n\nstd::vector<long> heap_sort(std::vector<long> iterable)\n{\n    const std::size_t n = iterable.size();\n    if (n <= 1) return iterable;          // already sorted\n\n    // 1. Build the max\u2011heap (heapify). Operate on indices [0 .. n-1]\n    for (std::size_t start = (n / 2); start > 0; --start)\n        siftDown(iterable, start - 1, n - 1);\n\n    // 2. Repeatedly extract the max element (root) and rebuild the heap.\n    for (std::size_t end = n - 1; end > 0; --end)\n    {\n        std::swap(iterable[0], iterable[end]); // move current max to the end\n        siftDown(iterable, 0, end - 1);         // restore heap property on the reduced heap\n    }\n\n    return iterable;\n}\n```\n\n**How it works**\n\n1. **Heapify** \u2013 Starting from the last non\u2011leaf node and moving upwards, `siftDown` ensures that every subtree satisfies the max\u2011heap property.\n2. **Extract** \u2013 The maximum element (root) is swapped with the last element of the current heap. After that the heap size is reduced by one, and `siftDown` restores the heap property again.\n3. After `n-1` iterations the vector is fully sorted in ascending order.\n\nThis implementation runs in `O(n log n)` time, uses `O(1)` additional space, and works correctly for any `std::vector<long>` input.", "Below is a complete and self\u2011contained implementation of **heap sort** for a `std::vector<long>`.  \nThe function:\n\n1. Builds a **max\u2011heap** by applying `push_heap` (or a manual sift\u2011down) to the whole vector.  \n2. Repeatedly swaps the first element (the largest) with the last element of the unsorted part, then \u201csifts\u2011down\u201d the new first element to restore the heap property.  \n3. Returns a *sorted* vector (ascending order).\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n * heap_sort\n * ---------\n * Sorts a vector of long integers in ascending order using the heap sort algorithm.\n *\n * Complexity:\n *     Time   : O(n log n) in the worst, average, and best cases.\n *     Space  : O(1) auxiliary (in\u2011place). The function returns a new vector,\n *              but it could be modified to sort in place if desired.\n *\n * Parameters:\n *    iterable \u2013 the vector to be sorted.\n *\n * Returns:\n *    A copy of `iterable` that is sorted in ascending order.\n */\nvector<long> heap_sort(vector<long> iterable)\n{\n    // `make_heap` transforms the range into a max\u2011heap.\n    // The default comparator is `less<>`, meaning the largest element will\n    // be placed at the beginning.\n    make_heap(iterable.begin(), iterable.end());\n\n    // `sort_heap` repeatedly removes the largest element (at begin)\n    // and places it at the end of the range, producing a sorted sequence.\n    sort_heap(iterable.begin(), iterable.end());\n\n    return iterable;\n}\n\n/* ---------- Optional in\u2011place version (doesn't create a copy) ---------- */\nvoid heap_sort_in_place(vector<long>& v)\n{\n    make_heap(v.begin(), v.end());\n    sort_heap(v.begin(), v.end());\n}\n\n/* --------------------------- Main (for testing) ------------------------ */\n#ifdef UNIT_TEST\nint main()\n{\n    vector<long> a = { 9, 4, 7, 1, 3, 8, 5, 2, 6 };\n    vector<long> b = heap_sort(a);\n\n    // Verify that `b` is sorted\n    for (size_t i = 1; i < b.size(); ++i)\n        assert(b[i-1] <= b[i]);\n\n    // Print the sorted result\n    for (long x : b) cout << x << ' ';\n    cout << '\\n';\n    return 0;\n}\n#endif\n```\n\n### Explanation\n\n| Step | What happens | Why |\n|------|--------------|-----|\n| **1** | `make_heap` arranges the elements such that for each node `i`, `v[i] \u2265 v[2i+1]` and `v[i] \u2265 v[2i+2]` | Builds a max\u2011heap in *O(n)* time. |\n| **2** | `sort_heap` swaps `v[0]` (the largest) with `v[last]`, then restores the heap property for the remaining unsorted portion. | Each swap reduces the heap size by one and keeps the remaining part a max\u2011heap. After `n-1` swaps the vector is sorted. |\n| **3** | Return the vector | The function leaves the original vector unchanged (since it works on a copy). |\n\n#### Custom Comparator\n\nIf you need descending order or a custom ordering, supply a comparator to both `make_heap` and `sort_heap`:\n\n```cpp\nmake_heap(v.begin(), v.end(), std::greater<long>()); // Build a min\u2011heap\nsort_heap(v.begin(), v.end(), std::greater<long>()); // Sort descending\n```\n\nThis single function is short, efficient, and uses only standard library facilities. It can easily be swapped into any existing codebase that needs heap sort.", "Here is a simple, self\u2011contained implementation of `heap_sort` that works out\u2011of\u2011the\u2011box.\nThe code uses the STL heap facilities (`std::make_heap`/`std::sort_heap`) so you won\u2019t need to hand\u2011code a heap structure yourself. It sorts the input vector **in ascending order** and returns the sorted copy, leaving the original vector unchanged.\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n/**\n * @brief Sorts a vector of long integers using heap sort.\n *\n * The function creates a copy of the supplied vector, turns it into a max\u2011heap\n * with std::make_heap, then repeatedly removes the largest element with\n * std::pop_heap while moving it to the end of the container.  Finally\n * std::sort_heap (or a manual reverse) is used to finish the ordering.\n *\n * @param iterable  The vector to be sorted.\n * @return          A new vector containing the elements of `iterable`\n *                  in ascending order.\n */\nstd::vector<long> heap_sort(const std::vector<long>& iterable)\n{\n    // Make a mutable copy \u2013 we do not want to disturb the caller's data.\n    std::vector<long> data = iterable;\n\n    // If the vector is empty or has a single element it is already sorted.\n    if (data.size() <= 1) {\n        return data;\n    }\n\n    // 1. Build a max\u2011heap in the container.\n    std::make_heap(data.begin(), data.end());\n\n    // 2. Repeatedly pop the largest element to the end of the vector\n    //    while maintaining the heap property on the remaining elements.\n    std::sort_heap(data.begin(), data.end());\n\n    // 3. The vector is now sorted in ascending order.\n    return data;\n}\n```\n\n### How it works\n\n| Step | What happens | Line end result |\n|------|--------------|-----------------|\n| `std::make_heap` | Turns the whole container into a max\u2011heap.   | Largest element at `data[0]` |\n| `std::sort_heap` | Repeatedly moves the heap\u2019s root to the back and restores the heap on the rest. | Whole container sorted ascending |\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<long> v{38, 27, 43, 3, 9, 82, 10};\n    auto sorted = heap_sort(v);\n\n    for (long x : sorted) {\n        std::cout << x << ' ';\n    }\n    // Output: 3 9 10 27 38 43 82\n}\n```\n\n### Why use `std::make_heap`/`std::sort_heap`?\n\n* **Correctness** \u2013 The STL guarantees the algorithmic complexity and behaviour.\n* **Readability** \u2013 Anyone familiar with the STL can read the code instantly.\n* **Performance** \u2013 These routines are heavily optimised in modern compilers.\n\nFeel free to drop this function into your project \u2013 it requires only the standard library headers shown."]}
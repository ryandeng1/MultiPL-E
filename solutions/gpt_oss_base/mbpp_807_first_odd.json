{"name": "mbpp_807_first_odd", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to find the first odd number in a given vector of numbers.\nlong first_odd(std::vector<long> nums) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_807_first_odd.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = first_odd;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5}))) == (1));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)9, (long)1}))) == (9));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a **complete, self\u2011contained C++ function** that returns the first odd number in a vector.  \nIf the vector contains no odd numbers we return `-1` (you can change this sentinel value if you prefer).\n\n```cpp\n#include <vector>\n#include <stdexcept>\n\n/**\n * @brief   Return the first odd value found in the given vector.\n *\n * @param[in] nums   Vector of integers (long type).\n * @return          The first odd number, or -1 if none exists.\n *\n * @note\n *   \u2022 The function performs a linear scan; complexity O(n).\n *   \u2022 It does *not* modify the input vector.\n *   \u2022 The sentinel value -1 assumes that the input numbers are non\u2011negative.\n *     If you need to support negative odd numbers, consider throwing an exception\n *     or returning a std::optional<long>.\n */\nlong first_odd(const std::vector<long>& nums)\n{\n    // Iterate over each element in the vector\n    for (long value : nums) {\n        // An odd number has a remainder of 1 when divided by 2.\n        if (value % 2 != 0) {\n            return value;\n        }\n    }\n\n    // No odd number was found \u2013 choose an appropriate sentinel.\n    return -1;                           // <-- change if needed\n}\n```\n\n### How to use it\n```cpp\nint main() {\n    std::vector<long> data = {2, 4, 6, 7, 8, 10};\n    long first = first_odd(data);\n    if (first != -1)\n        std::cout << \"First odd: \" << first << '\\n';\n    else\n        std::cout << \"No odd number found.\\n\";\n}\n```\n\n### Optional enhancements\n- **Return `std::optional<long>`** \u2013 keeps the function pure and eliminates the need for a magic sentinel.\n- **Throw an exception** if no odd number is found \u2013 useful when the absence of an odd number is an error condition.\n- **Compile\u2011time checks** with `static_assert` for empty vectors if you want to enforce pre\u2011conditions.\n\nFeel free to adapt the return strategy to match your project\u2019s error\u2011handling conventions.", "```cpp\n#include <vector>\n#include <stdexcept>   // for std::invalid_argument\n#include <algorithm>   // for std::find_if\n\n/**\n * @brief Return the first odd value from a container of integers.\n *\n * @param nums A vector of values of type `long`. \n * @return The first odd element in the vector.\n * @throws std::invalid_argument if no odd value exists in the vector.\n */\nlong first_odd(const std::vector<long> &nums)\n{\n    // We use std::find_if to locate the first odd element.\n    auto it = std::find_if(nums.begin(), nums.end(),\n                           [](long x) { return (x % 2) != 0; });\n\n    if (it == nums.end()) {\n        // No odd number found \u2013 communicate this via an exception.\n        throw std::invalid_argument(\"No odd number in the vector\");\n    }\n\n    return *it;\n}\n```\n\n**Usage example**\n\n```cpp\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<long> v{4, 6, 8, 11, 14};\n    try {\n        long odd = first_odd(v);\n        std::cout << \"First odd number: \" << odd << '\\n';\n    } catch (const std::invalid_argument &ex) {\n        std::cerr << ex.what() << '\\n';\n    }\n}\n```\n\nThis function leverages the standard algorithm `find_if` to keep the implementation concise and efficient. It also safely reports the absence of an odd number by throwing an exception.", "Here\u2019s a simple, clean way to find the first odd number in a `std::vector<long>`. The function scans the vector in order and returns the first element that is odd. If the vector contains no odd numbers it throws an exception (you can change this behaviour if you prefer returning a sentinel value).\n\n```cpp\n#include <vector>\n#include <stdexcept>\n\n/**\n * @brief Return the first odd number in the vector.\n *\n * @param nums vector of long integers\n * @return the first odd element\n * @throws std::runtime_error if there is no odd number in the vector\n */\nlong first_odd(const std::vector<long>& nums)\n{\n    for (long value : nums)\n    {\n        if (value & 1)            // bitwise check for oddness\n            return value;\n    }\n    throw std::runtime_error(\"no odd element found\");\n}\n```\n\n### Usage example\n\n```cpp\n#include <iostream>\n#include <vector>\n\nint main()\n{\n    std::vector<long> data { 2, 4, 6, 7, 8 };\n    try\n    {\n        std::cout << \"First odd: \" << first_odd(data) << '\\n';\n    }\n    catch (const std::exception& e)\n    {\n        std::cerr << e.what() << '\\n';\n    }\n}\n```\n\nIf the vector may be empty or you prefer to return a sentinel value (e.g., `-1`) instead of throwing, you can replace the `throw` statement with:\n\n```cpp\nreturn -1; // or any other sentinel value of your choice\n```\n\nThis implementation is O(n) in time and O(1) in additional space, which is optimal for the task."]}
{"name": "mbpp_130_max_occurrences", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the item with maximum frequency in a given vector.\nlong max_occurrences(std::vector<long> nums) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_130_max_occurrences.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = max_occurrences;\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)8, (long)4, (long)7, (long)9, (long)8, (long)2, (long)6, (long)5, (long)1, (long)6, (long)1, (long)2, (long)3, (long)2, (long)4, (long)6, (long)9, (long)1, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)8, (long)4, (long)7, (long)9, (long)8, (long)7, (long)9, (long)15, (long)14, (long)10, (long)12, (long)13, (long)16, (long)18}))) == (8));\n    assert(candidate((std::vector<long>({(long)10, (long)20, (long)20, (long)30, (long)40, (long)90, (long)80, (long)50, (long)30, (long)20, (long)50, (long)10}))) == (20));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a compact yet clear implementation of `max_occurrences`.  \nIt uses an `unordered_map` to count each value, then scans the map to find the key with the largest count.  \nIn case of a tie we pick the first key that reaches the maximum frequency.  \n(If you prefer a different tie\u2011breaking rule \u2013 e.g. the smallest element \u2013 just tweak the comparison.)\n\n```cpp\n#include <vector>\n#include <unordered_map>\n#include <stdexcept>   // for std::invalid_argument\n\n// ------------------------------------------------------------\n// Returns the element that occurs most frequently in `nums`.\n// Throws std::invalid_argument if the input vector is empty.\n// ------------------------------------------------------------\nlong max_occurrences(const std::vector<long>& nums)\n{\n    if (nums.empty())\n        throw std::invalid_argument(\"input vector must not be empty\");\n\n    // 1. Count the occurrences\n    std::unordered_map<long, int> freq;\n    for (long v : nums) ++freq[v];\n\n    // 2. Find the element with the highest count\n    long best    = nums[0];   // initial candidate\n    int  bestCnt = freq[best];\n\n    for (const auto& p : freq)\n    {\n        if (p.second > bestCnt)          // strict > ensures the first element wins ties\n        {\n            best    = p.first;\n            bestCnt = p.second;\n        }\n    }\n\n    return best;\n}\n```\n\n### Usage example\n\n```cpp\nint main()\n{\n    std::vector<long> a{1, 3, 3, 7, 1, 1, 1};\n    std::cout << max_occurrences(a);   // prints 1\n}\n```\n\nFeel free to adjust the tie\u2011breaking logic or return both the value and its frequency if you need more information.", "Below is a complete, ready\u2011to\u2011compile implementation that satisfies the requirement:\n\n```cpp\n#include <vector>\n#include <unordered_map>\n#include <stdexcept>\n\n/**\n * @brief  Return the element that appears the most times in `nums`.\n * \n * If the input vector is empty an exception is thrown.\n * For a tie, the element that is first encountered in the vector\n * is returned (this can be changed if another tie\u2011breaking rule\n * is desired).\n * \n * @param nums Vector of integers whose most frequent element is required\n * @return The element with the maximum frequency\n */\nlong max_occurrences(const std::vector<long>& nums)\n{\n    if (nums.empty())\n        throw std::invalid_argument(\"Input vector is empty\");\n\n    std::unordered_map<long, long> freq;   // value -> count\n    long best_value = nums.front();\n    long best_count = 0;\n\n    for (const long& x : nums)\n    {\n        ++freq[x];\n        if (freq[x] > best_count) {\n            best_count = freq[x];\n            best_value = x;\n        }\n    }\n    return best_value;\n}\n```\n\n### How it works\n\n1. **Input validation.**  \n   An exception is thrown if the vector is empty \u2013 this guards against undefined behaviour.\n\n2. **Counting frequencies.**  \n   An `unordered_map` keeps a running count of how many times each number has been seen.\n\n3. **Tracking the maximum.**  \n   While iterating we keep the current best value and its count.  \n   Whenever a new count exceeds the previous best, we update the best value.\n\n4. **Return value.**  \n   After the loop the `best_value` holds the most frequent element.\n\n### Example usage\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> data = {1, 3, 5, 3, 3, 7, 5, 1, 5, 5};\n    std::cout << \"Most frequent element: \"\n              << max_occurrences(data) << '\\n';  // prints 5\n}\n```\n\nThe algorithm runs in **O(n)** time and uses **O(k)** additional memory, where `n` is the size of the vector and `k` is the number of distinct elements.", "Here is a simple, efficient implementation that uses an unordered map to count frequencies.  \nThe function returns the element that appears the most times. If more than one element shares the maximum frequency, the one that appears first in `nums` is returned (you can change the tie\u2011breaking rule if you wish).\n\n```cpp\n#include <unordered_map>\n#include <vector>\n\nlong max_occurrences(const std::vector<long>& nums)\n{\n    std::unordered_map<long, int> freq;\n    int   max_cnt = 0;\n    long  best_val = 0;\n\n    for (const auto& x : nums) {\n        int cnt = ++freq[x];               // increment count for x\n        if (cnt > max_cnt) {               // new maximum found\n            max_cnt = cnt;\n            best_val = x;\n        }\n    }\n    return best_val;\n}\n```\n\n**Explanation**\n\n1. `freq` keeps track of how many times each value appears.  \n2. While iterating through `nums` we increment the count of each element.  \n3. Whenever a count exceeds the current maximum (`max_cnt`), we update `max_cnt` and record the element as `best_val`.  \n4. At the end `best_val` contains the element with the highest frequency.\n\nThe function runs in `O(n)` time and `O(k)` extra space, where `k` is the number of distinct values in `nums`."]}
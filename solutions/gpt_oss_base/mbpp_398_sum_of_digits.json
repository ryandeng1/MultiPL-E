{"name": "mbpp_398_sum_of_digits", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to compute the sum of digits of each number of a given vector.\nlong sum_of_digits(std::vector<std::any> nums) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_398_sum_of_digits.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = sum_of_digits;\n    assert(candidate((std::vector<std::any>({(long)10, (long)2, (long)56}))) == (14));\n    assert(candidate((std::vector<std::any>({(std::vector<long>)std::vector<std::any>({10, 20, 4, 5, \"b\", 70, \"a\"})}))) == (19));\n    assert(candidate((std::vector<std::any>({(long)10, (long)20, (long)-4, (long)5, (long)-70}))) == (19));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a complete, self\u2011contained implementation that works with a vector of `std::any`.  \nThe function will:\n\n* Accept any numeric type (`int`, `long`, `float`, `double`, etc.) that can be converted to an integer value.\n* Convert each `any` to an integer (`long long`) so we can easily extract digits.\n* Handle negative numbers and zero correctly.\n* Return the total sum of all digits across the whole vector.\n\n```cpp\n#include <vector>\n#include <any>\n#include <typeinfo>\n#include <cmath>\n#include <stdexcept>\n\n/// @brief Convert a std::any value to a long long (integral) if possible.\n/// @throws std::bad_any_cast if the stored value cannot be cast to a supported arithmetic type.\n/// @return The integer representation of the value.\ninline long long any_to_int(const std::any& a)\n{\n    // The following checks cover the most common arithmetic types.\n    if (a.type() == typeid(int))        return std::any_cast<int>(a);\n    if (a.type() == typeid(long))       return std::any_cast<long>(a);\n    if (a.type() == typeid(long long))  return std::any_cast<long long>(a);\n    if (a.type() == typeid(short))      return std::any_cast<short>(a);\n    if (a.type() == typeid(unsigned int))      return std::any_cast<unsigned int>(a);\n    if (a.type() == typeid(unsigned long))     return std::any_cast<unsigned long>(a);\n    if (a.type() == typeid(unsigned long long))return std::any_cast<unsigned long long>(a);\n    if (a.type() == typeid(unsigned short))    return std::any_cast<unsigned short>(a);\n\n    // For floating\u2011point numbers we simply cast to long long (truncates decimal part).\n    if (a.type() == typeid(float))    return static_cast<long long>(std::any_cast<float>(a));\n    if (a.type() == typeid(double))   return static_cast<long long>(std::any_cast<double>(a));\n    if (a.type() == typeid(long double)) return static_cast<long long>(std::any_cast<long double>(a));\n\n    throw std::bad_any_cast(); // unsupported type\n}\n\n/// @brief Compute the sum of digits of all numbers in a vector of std::any.\n/// @note Non\u2011numeric types cause a std::bad_any_cast exception.\n/// @param nums The vector containing values that can be converted to an integer.\n/// @return Sum of all decimal digits of all elements.\nlong sum_of_digits(const std::vector<std::any>& nums)\n{\n    long total = 0;\n\n    for (const auto& item : nums) {\n        long long val = any_to_int(item);      // value represented as an integer\n        long long abs_val = std::llabs(val);   // work with absolute value\n\n        if (abs_val == 0) {                    // zero contributes 0\n            continue;\n        }\n\n        // Sum the digits of abs_val\n        while (abs_val > 0) {\n            total += abs_val % 10;             // last digit\n            abs_val /= 10;                     // remove last digit\n        }\n    }\n\n    return total;\n}\n```\n\n### How it works\n\n1. **`any_to_int`**  \n   - Checks the embedded type in `std::any` and casts it to the appropriate integer type.  \n   - Floating\u2011point values are truncated to `long long`.  \n   - If the stored type is unsupported, a `std::bad_any_cast` is thrown.\n\n2. **`sum_of_digits`**  \n   - Iterates over each element, converts it to an integer, and takes its absolute value.  \n   - Extracts each decimal digit with `% 10` and adds it to the running total.  \n   - Handles the special case of zero (no digits to add).  \n\nThis implementation is type\u2011safe, throws clear exceptions for unsupported types, and gives a straightforward `long` result.", "Here\u2019s a straightforward implementation that\n\n1.  Loops through each element of the vector.  \n2.  Tries to extract an integral value (`int`, `long`, `long long`, etc.).  \n3.  Computes the digit\u2011sum of that value.  \n4.  Adds it to a running total and returns the final sum.  \n\nThe function is intentionally permissive: if an element cannot be converted to an integral type it is simply ignored (you could easily throw an error instead).  It also works with zero\u2011based and negative numbers (the sign is ignored when summing digits).\n\n```cpp\n#include <vector>\n#include <any>\n#include <cctype>\n#include <stdexcept>\n\nlong sum_of_digits(const std::vector<std::any>& nums)\n{\n    long total = 0;              // the accumulated sum\n\n    for (const auto& elem : nums)\n    {\n        // Try to pull out a few common integral types.\n        // You can add more as needed (short, int64_t, etc.).\n        long long value = 0;     // use the widest we want to support\n        bool got_value = false;\n\n        try { value = std::any_cast<int>(elem);      got_value = true; } catch(...) {}\n        try { if (!got_value) value = std::any_cast<long>(elem);       got_value = true; } catch(...) {}\n        try { if (!got_value) value = std::any_cast<long long>(elem); got_value = true; } catch(...) {}\n\n        if (!got_value) {\n            // element wasn't a supported integral type \u2013 skip it\n            continue;\n        }\n\n        // Sum the digits of |value| (sign is ignored)\n        long long v = std::llabs(value);   // absolute value\n\n        if (v == 0) {   // special case: 0 has a digit sum of 0\n            // no change\n        } else {\n            while (v > 0) {\n                total += v % 10;  // add least\u2011significant digit\n                v /= 10;          // drop that digit\n            }\n        }\n    }\n\n    return total;\n}\n```\n\n### How It Works\n\n| Step | Detail |\n|------|--------|\n| **Extraction** | The `try\u2026catch` blocks attempt to cast the `std::any` element to several integral types. If none match, the element is ignored. |\n| **Absolute value** | Digit\u2011summing is indifferent to the sign, so `std::llabs` gives us a non\u2011negative value. |\n| **Digit\u2011sum loop** | We repeatedly take `v % 10` to obtain the last digit, add it to `total`, then divide `v` by 10 to process the next digit. |\n| **Return** | The final accumulated `total` is returned as a `long`. |\n\nFeel free to adapt the function if you need stricter type checking, support for floating\u2011point numbers, or a different return type.", "Below is a compact, self\u2011contained implementation of the requested function.  \nIt:\n\n* Accepts a `std::vector<std::any>` that may contain any of the integral or\n  floating\u2011point types the C++ standard library knows about.\n* Extracts the underlying numeric value with `std::any_cast` (and falls back to\n  throw\u2011catch if the type is not a number).\n* Computes the sum of the digits of each element and keeps a running total.\n* Uses `std::abs` to ignore the sign of negative numbers.\n* Throws a `std::invalid_argument` if an element is not a numeric type.\n\n```cpp\n#include <any>\n#include <vector>\n#include <stdexcept>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n\n/*\n * Helper: convert any numeric std::any to a long long (big enough for all\n * built\u2011in integer/floating types).  The conversion uses std::any_cast\n * for each supported type.  If the type of the value is not recognised,\n * an exception is thrown.\n */\nlong long any_to_long_long(const std::any& a)\n{\n    if (a.type() == typeid(int))          return std::any_cast<int>(a);\n    if (a.type() == typeid(unsigned int)) return std::any_cast<unsigned int>(a);\n    if (a.type() == typeid(long))         return std::any_cast<long>(a);\n    if (a.type() == typeid(unsigned long))    return std::any_cast<unsigned long>(a);\n    if (a.type() == typeid(long long))     return std::any_cast<long long>(a);\n    if (a.type() == typeid(unsigned long long)) return std::any_cast<unsigned long long>(a);\n    if (a.type() == typeid(float))         return static_cast<long long>(std::any_cast<float>(a));\n    if (a.type() == typeid(double))        return static_cast<long long>(std::any_cast<double>(a));\n    if (a.type() == typeid(long double))   return static_cast<long long>(std::any_cast<long double>(a));\n\n    throw std::invalid_argument(\"non\u2011numeric value in vector\");\n}\n\n/*\n * Convert a (possibly signed) integer to the sum of its decimal digits.\n */\nlong long digit_sum(long long n)\n{\n    n = std::llabs(n);                // ignore sign\n    long long sum = 0;\n    do {\n        sum += n % 10;\n        n /= 10;\n    } while (n > 0);\n    return sum;\n}\n\n/*\n * Compute the sum of digits of each number in a vector of std::any.\n */\nlong long sum_of_digits(const std::vector<std::any>& nums)\n{\n    long long total = 0;\n    for (const auto& v : nums) {\n        long long val = any_to_long_long(v);\n        total += digit_sum(val);\n    }\n    return total;\n}\n\n/* -------------------------------------------------------------------------- */\n/* ----------------------------  example usage  ---------------------------- */\n/* -------------------------------------------------------------------------- */\n\nint main()\n{\n    std::vector<std::any> v = {123, -45, 6.78, long(910)};\n    std::cout << \"sum of digits = \" << sum_of_digits(v) << '\\n';   // 1+2+3 + 4+5 + 6 + 9+1+0 = 31\n    assert( sum_of_digits(v) == 31 );\n    return 0;\n}\n```\n\n### What the code does\n\n| Step | Code |\n|------|------|\n| Convert a `std::any` value to an integer | `any_to_long_long` |\n| Compute digits\u2032 sum of a non\u2011negative integer | `digit_sum` |\n| Iterate over the vector, convert each element and add its digit sum | `sum_of_digits` |\n\n### Why this design\n\n* `std::any` can hold *any* type, but we only want numbers.  \n  A series of `if (a.type() == typeid(...))` checks guarantees that only\n  known numeric types are accepted.  \n  It also provides a clear place to add support for any other new numeric type\n  if needed.\n\n* Converting the element to `long long` ensures we have a single\n  representation that covers all integral types.  \n  For floating point numbers we simply truncate toward zero \u2013 this is\n  consistent with the notion \u201csum of the digits of a number\u2019s integer part\u201d.\n\n* `std::llabs` (or `std::abs` with a `long long` argument) removes the sign\n  so that `-123` counts the same as `123`.\n\nThe whole snippet compiles with any modern C++17/20 compiler (the code uses only\nheader\u2011only standard library facilities, so no extra libraries are required)."]}
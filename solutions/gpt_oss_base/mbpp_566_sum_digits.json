{"name": "mbpp_566_sum_digits", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to get the sum of the digits of a non-negative integer.\nlong sum_digits(long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_566_sum_digits.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = sum_digits;\n    assert(candidate((345)) == (12));\n    assert(candidate((12)) == (3));\n    assert(candidate((97)) == (16));\n}\n", "stop_tokens": ["\n}"], "completions": ["### What the code should do\n\nThe function `sum_digits` must take a **non\u2011negative integer** (`long n`) and return the sum of all its decimal digits.\n\n### Algorithm (straightforward)\n\n1. Initialise `sum = 0`.\n2. While `n > 0`  \n   * Add the least significant digit `n % 10` to `sum`.\n   * Remove that digit (`n /= 10`).\n3. Return `sum`.\n\nBecause the input is guaranteed to be non\u2011negative, we don\u2019t need to treat the sign specially.  \nFor `n == 0` the loop body is skipped and `sum` correctly remains `0`.\n\n---\n\n### Complete implementation (with minimal headers)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Return the sum of the decimal digits of a non\u2011negative integer n.\nlong sum_digits(long n)\n{\n    long sum = 0;\n    while (n > 0) {\n        sum += n % 10;   // add the right\u2011most digit\n        n /= 10;         // drop that digit\n    }\n    return sum;\n}\n\n/* Simple test harness \u2013 not part of the required function */\nint main()\n{\n    assert(sum_digits(0) == 0);\n    assert(sum_digits(5) == 5);\n    assert(sum_digits(12345) == 15);\n    assert(sum_digits(999999999) == 81);\n    cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\nThe function runs in `O(d)` time, where `d` is the number of digits of `n`, and uses `O(1)` extra space. No overflow issues arise as the maximum possible sum of digits for a signed 64\u2011bit `long` is `9*19 = 171`, well within the range of `long`.", "Below is a clean, self\u2011contained implementation that follows the requirement of returning the sum of the digits of a non\u2011negative `long`.  \nIt is written in C++ and can be compiled with any standard\u2011conforming compiler.\n\n```cpp\n// ------------------------------------------------------------\n//  Sum of digits of a non\u2011negative integer\n// ------------------------------------------------------------\n//  Function: sum_digits\n//  Input   : long n  \u2013 non\u2011negative integer\n//  Output  : long \u2013 sum of all decimal digits of n\n//\n//  Assumptions:\n//      * n is non\u2011negative (the caller guarantees this)\n//      * We handle 0 correctly (sum = 0)\n// ------------------------------------------------------------\n\n#include <cstdint>   // for int64_t\n#include <cassert>   // optional: to check pre\u2011condition\n\nlong sum_digits(long n)\n{\n    // Optional runtime check (uncomment if you want a soft assertion)\n    // assert(n >= 0);\n\n    long sum = 0;\n    if (n == 0)\n        return 0;           // special case \u2013 avoids the while\u2011loop\n\n    while (n > 0) {\n        sum += n % 10;      // add the least\u2011significant digit\n        n   /= 10;          // remove that digit\n    }\n    return sum;\n}\n```\n\n### How it works\n1. **Special case for `0`:** The remaining loop would return `0` anyway,  \n   but an explicit check makes the intention clear and avoids the loop overhead.\n2. **Iteration:** While `n` is positive, extract the right\u2011most digit using `n % 10`, add it to `sum`, and drop the digit by integer division `n /= 10`.\n3. **Return:** When all digits are processed, return the accumulated sum.\n\n### Usage Example\n```cpp\n#include <iostream>\n\nint main() {\n    long num = 1234567890LL;\n    std::cout << \"Sum of digits of \" << num << \" is \"\n              << sum_digits(num) << '\\n';\n    return 0;\n}\n```\n\nCompile with:\n```bash\ng++ -std=c++17 -O2 -Wall -Wextra -o sum_digits sum_digits.cpp\n```\n\nThis implementation is efficient (O(log10\u202fn) time and O(1) space) and works for any non\u2011negative `long` value that fits in the platform\u2019s `long` type.", "Here is a small, self\u2011contained implementation of the function that returns the sum of the decimal digits of a non\u2011negative `long`:\n\n```cpp\n// Returns the sum of all decimal digits of `n`.\n// The argument must be non\u2011negative \u2013 we treat negative values\n// as an error and simply return 0 (you can change this behaviour\n// if you want).\nlong sum_digits(long n)\n{\n    // In case we get a negative number, we guard against\n    // undefined behaviour and simply return 0.\n    // (If you want to support unsigned values you could change\n    // the function signature to `unsigned long`, but for\n    // the purpose of this exercise we keep `long`.)\n    if (n < 0) {\n        return 0;          // or throw std::invalid_argument(...)\n    }\n\n    long sum = 0;\n    while (n > 0) {\n        sum += n % 10;     // add the least significant digit\n        n   /= 10;         // remove that digit\n    }\n    return sum;\n}\n```\n\n### Why this implementation works\n\n* **Loop invariant** \u2013 As long as `n > 0` the loop extracts the rightmost digit with `n % 10` and then discards it via `n /= 10`.  \n* **Termination** \u2013 Each iteration reduces `n` by a factor of 10, so after at most `\u230alog10(n)\u230b + 1` iterations the loop exits.  \n* **Edge case** \u2013 When the original number is `0` the loop never executes and the function correctly returns `0`.  \n\nFeel free to tweak the error handling or change the signature to `unsigned long` if you prefer to avoid dealing with negative numbers."]}
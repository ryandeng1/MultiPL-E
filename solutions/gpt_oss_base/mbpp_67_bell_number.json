{"name": "mbpp_67_bell_number", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the number of ways to partition a set of Bell numbers.\nlong bell_number(long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_67_bell_number.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = bell_number;\n    assert(candidate((2)) == (2));\n    assert(candidate((10)) == (115975));\n    assert(candidate((56)) == (6775685320645824322581483068371419745979053216268760300));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a complete, self\u2011contained routine that returns the *n*\u2011th Bell number (the number of partitions of a set with *n* elements).  \nThe implementation uses the **Bell triangle** (also called Aitken\u2019s array) \u2013 a simple \\(O(n^2)\\) algorithm that works comfortably for the usual ranges used in programming\u2011contest style problems.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// ---------------------------------------------------------------------\n// Computes the n\u2011th Bell number, B(n), i.e. the number of ways to\n// partition a set of size n.\n//\n//   Bell numbers start:  B(0)=1, B(1)=1, B(2)=2, B(3)=5,\n//   B(4)=15, B(5)=52, ...\n//\n// The routine uses a classic \"Bell triangle\" construction:\n//   * first row is a single 1\n//   * each new row starts with the last element of the previous row\n//   * subsequent elements are sums of the element to the left and the\n//     element above\u2011left\n//\n// The first element of the n\u2011th row (row index==n) is B(n).\n//\n// Complexity:\n//   Time   : O(n^2)\n//   Memory : O(n)   (we keep only the current row)\n//\n// ---------------------------------------------------------------------\nlong long bell_number(long long n)\n{\n    if (n < 0) {                     // undefined for negative n\n        throw std::invalid_argument(\"n must be non\u2011negative\");\n    }\n    if (n == 0) return 1;            // B(0) = 1 by convention\n\n    // vector: current row of the Bell triangle\n    vector<long long> row(1, 1);     // row[0] = 1  -> first row (B(0))\n\n    // Build rows 1 \u2026 n\n    for (long long i = 1; i <= n; ++i)   // i is the current row index\n    {\n        row.resize(static_cast<size_t>(i + 1));     // new row length = i+1\n        row[0] = row.back();                      // first element = last of prev row\n\n        for (size_t j = 1; j < row.size(); ++j)    // compute rest of the row\n        {\n            long long left   = row[j - 1];          // element to the left\n            long long upper  = (j == row.size() - 1) ? 0\n                            : row[j];              // element above\u2011left (or 0 if none)\n            row[j] = left + upper;\n        }\n        // After finishing, row[0] holds B(i). Next iteration will use this\n    }\n\n    return row[0];      // after loop i==n, row[0] == B(n)\n}\n\n// ---------------------------------------------------------------------\n// Example usage and quick sanity check\n// ---------------------------------------------------------------------\nint main()\n{\n    vector<int> test = {0, 1, 2, 3, 4, 5, 6, 7, 8};\n    for (int n : test) {\n        cout << \"B(\" << n << \") = \" << bell_number(n) << '\\n';\n    }\n\n    // Basic assertion: B(5) == 52\n    assert(bell_number(5) == 52);\n\n    return 0;\n}\n```\n\n### How the Bell triangle works\n\n| n | Bell triangle rows (partial) | B(n) |\n|---|------------------------------|------|\n| 0 | `1`                           | 1    |\n| 1 | `1`<br>`1 1`                   | 1    |\n| 2 | `1`<br>`1 1`<br>`1 2 2`         | 2    |\n| 3 | `1`<br>`1 1`<br>`1 2 2`<br>`1 3 5 5` | 5 |\n| ... | ... | ... |\n\nRow\u202f*i* has *i+1* entries.  \nEach new entry is the sum of the element to the left (same row) and the element diagonally above\u2011left (previous row).  \nThe first entry of row\u202f*i* is always the Bell number *B(i)*.\n\n### Notes\n\n* The routine uses `long long` (`int64_t`) to hold the answer.  \n  Bell numbers grow extremely fast: \n  B(25) \u2248 4.1\u202f\u00d7\u202f10\u00b9\u2079, already exceeding 32\u2011bit range, so `long long` is the smallest built\u2011in type that works for moderate *n*.  \n  For larger *n*, you would need arbitrary\u2011precision arithmetic (e.g. `boost::multiprecision::cpp_int`).\n\n* If you only need the Bell number modulo some prime `MOD`, you can modify the addition steps to take `mod` at every iteration, keeping the algorithm identical in spirit but with far smaller values.\n\nThis implementation is compact, easy to understand, and fast enough for most contest problems.", "Below is a small, self\u2011contained C++17 program that\n\n1.   Computes the *Bell number* \\(B_n\\) \u2013 the number of ways to partition a set of *n* distinct elements \u2013 using the well\u2011known recurrence\n2.   Demonstrates the function with a few test cases (and `assert` checks).\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cassert>\n\n/*\n *  Bell number B(n) = number of partitions of an n\u2011element set\n *  Recurrence:\n *     B(0) = 1\n *     B(n+1) = \u03a3_{k=0}^{n} C(n , k) * B(k)\n *\n *  The command\u2011line code below uses 128\u2011bit arithmetic for safety\n *  but can be adapted to arbitrary precision if desired.\n */\nunsigned long long bell_number(unsigned int n)\n{\n    // dp[i] will hold B(i)\n    std::vector<unsigned long long> dp(n + 1, 0);\n    dp[0] = 1;                         // B0 = 1\n\n    // Pre\u2011compute binomial coefficients C(n, k) row by row\n    // to avoid built\u2011in overflow (but use 128\u2011bit internally)\n    std::vector<unsigned long long> comb(n + 1, 0);\n    for (unsigned int i = 1; i <= n; ++i) {\n        comb[0] = 1;                   // C(i,0)=1\n        unsigned __int128 tmp;         // use 128\u2011bit for intermediate\n        for (unsigned int k = 1; k <= i; ++k) {\n            // C(i,k) = C(i-1,k-1) + C(i-1,k)\n            tmp  = (unsigned __int128)comb[k-1] + comb[k];\n            comb[k] = (unsigned long long)tmp;   // fits in 64 bits for i<=60\n        }\n\n        // Compute B(i) using the recurrence\n        unsigned __int128 sum = 0;\n        for (unsigned int k = 0; k <= i-1; ++k) {\n            sum += (unsigned __int128)comb[i-1-k] * dp[k];\n        }\n        dp[i] = (unsigned long long)sum;\n    }\n    return dp[n];\n}\n\n/* quick tests \u2013 known Bell numbers for n = 0..6 */\nint main()\n{\n    const unsigned long long expected[] = {\n        1,       // B0\n        1,       // B1\n        2,       // B2\n        5,       // B3\n        15,      // B4\n        52,      // B5\n        203      // B6\n    };\n\n    for (unsigned int n = 0; n <= 6; ++n) {\n        unsigned long long got = bell_number(n);\n        std::cout << \"Bell(\" << n << \") = \" << got << '\\n';\n        assert(got == expected[n]);\n    }\n\n    std::cout << \"All checked \u2013 Bell numbers are correct!\\n\";\n    return 0;\n}\n```\n\n### How it works\n\n* **Dynamic programming** \u2013 we build the Bell numbers from `B0` up to `Bn`.\n* **Binomial coefficients** \u2013 to evaluate the recurrence we need all `C(i,k)`.  \n  They are generated on the fly and stored in a small array that is reused for each `i`; this keeps the memory usage to *O(n)*.\n* **128\u2011bit intermediate** \u2013 the product of a binomial coefficient and an intermediate Bell number can exceed 64 bits, so we cast to `__int128` before summing; the final result fits in an unsigned 64\u2011bit integer for the ranges covered by the test (and for many more).\n* **Testing** \u2013 the program prints the first seven Bell numbers and checks them against the known sequence.\n\nFeel free to adjust the `unsigned long long` to a larger type (e.g., `__int128`, `boost::multiprecision::cpp_int` or a custom big\u2011integer library) if you need to handle larger `n`.", "**Answer**\n\nBelow is a complete implementation of a function that returns the *n\u2011th Bell number*.  \nBecause Bell numbers grow extremely fast (for \\(n=50\\) it already needs 77\u202fbits), the routine uses the\n`boost::multiprecision::cpp_int` type so that it can handle arbitrarily large arguments without\noverflow.\n\n```cpp\n#include <bits/stdc++.h>\n#include <boost/multiprecision/cpp_int.hpp>\n\nusing namespace std;\nusing boost::multiprecision::cpp_int;\n\n/*  Bell number B(n)\n *  B(0) = 1\n *  B(n+1) = \u03a3_{k=0}^{n} C(n, k) * B(k)\n *\n *  The implementation uses dynamic programming to store all previously computed\n *  values, as well as a table of binomial coefficients.  All arithmetic is\n *  performed with cpp_int so that the function works for arbitrarily large n.\n */\ncpp_int bell_number(long n)\n{\n    if (n < 0) throw std::invalid_argument(\"negative n\");\n    if (n == 0) return 1;                 // B0 = 1\n\n    // Store B0 \u2026 Bn\n    vector<cpp_int> bell(n + 1);\n    bell[0] = 1;\n\n    // Pre\u2011compute binomial coefficients C(i , j) up to i = n - 1\n    vector<vector<cpp_int>> C(n, vector<cpp_int>(n, 0));\n    for (long i = 0; i < n; ++i) {\n        C[i][0] = C[i][i] = 1;\n        for (long j = 1; j < i; ++j)\n            C[i][j] = C[i-1][j-1] + C[i-1][j];\n    }\n\n    for (long i = 1; i <= n; ++i) {          // compute B(i)\n        cpp_int s = 0;\n        for (long k = 0; k <= i-1; ++k) {    // use recurrence\n            s += C[i-1][k] * bell[k];\n        }\n        bell[i] = s;\n    }\n    return bell[n];\n}\n\n/*  Simple test harness  */\nint main()\n{\n    for (int n = 0; n <= 20; ++n) {\n        cout << \"B(\" << n << \") = \" << bell_number(n) << '\\n';\n    }\n    return 0;\n}\n```\n\n### How it works\n\n1. **Dynamic programming**  \n   We store every Bell number from `B0` up to the requested `Bn` in a vector.  \n   The recurrence\n\n   \\[\n   B_{n+1}=\\sum_{k=0}^{n}\\binom{n}{k} B_k\n   \\]\n\n   allows us to compute each new value from the previously computed ones.\n\n2. **Binomial coefficients**  \n   A small Pascal triangle is built once and reused for all iterations.  \n   This keeps the overall time complexity to \\(O(n^2)\\) and the memory usage to\n   \\(O(n^2)\\) for the coefficients, which is fine for values up to several\n   thousands.\n\n3. **Big integers**  \n   `boost::multiprecision::cpp_int` handles integers of arbitrary size, so the\n   function works for all reasonable `n` (in practice up to few thousands\n   within seconds). No overflow can occur.\n\nFeel free to adapt the code to your own style or constraints."]}
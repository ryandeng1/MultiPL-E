{"name": "mbpp_559_max_sub_array_sum", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the sum of the largest contiguous subvector in the given vector.\nlong max_sub_array_sum(std::vector<long> a, long size) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_559_max_sub_array_sum.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = max_sub_array_sum;\n    assert(candidate((std::vector<long>({(long)-2, (long)-3, (long)4, (long)-1, (long)-2, (long)1, (long)5, (long)-3})), (8)) == (7));\n    assert(candidate((std::vector<long>({(long)-3, (long)-4, (long)5, (long)-2, (long)-3, (long)2, (long)6, (long)-4})), (8)) == (8));\n    assert(candidate((std::vector<long>({(long)-4, (long)-5, (long)6, (long)-3, (long)-4, (long)3, (long)7, (long)-5})), (8)) == (10));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a clean, self\u2011contained implementation of the classic **Maximum Subarray Sum** (Kadane\u2019s algorithm).  \nIt runs in\u202fO(n) time and uses O(1) additional space.\n\n```cpp\n#include <cassert>\n#include <vector>\n#include <algorithm>   // for std::max\n#include <cstddef>     // for std::size_t\n\n// ------------------------------------------------------------\n// Returns the maximum possible sum of a contiguous sub\u2011vector\n// in the input vector `a` (length = `size`).\n//\n//   Example:\n//     a = { -2, 1, -3, 4, -1, 2, 1, -5, 4 }\n//     max_sub_array_sum(a, a.size())  -->  6\n//\n//   Explanation: 4 + (-1) + 2 + 1 = 6\n//\n// ------------------------------------------------------------\nlong max_sub_array_sum(const std::vector<long>& a, std::size_t size)\n{\n    // Defensive check \u2013 vector should have at least one element\n    assert(size > 0);\n\n    long best   = a[0];   // best sum found so far\n    long curSum = a[0];   // sum of the current sub\u2011vector\n\n    for (std::size_t i = 1; i < size; ++i)\n    {\n        // Extend current sub\u2011vector or start a new one at a[i]\n        curSum = std::max(a[i], curSum + a[i]);\n\n        // Update global best if needed\n        best = std::max(best, curSum);\n    }\n\n    return best;\n}\n```\n\n### Why this code is safe\n\n| Check | What it protects against |\n|-------|--------------------------|\n| `assert(size > 0);` | Prevents dereferencing a zero\u2011length vector (undefined behaviour). |\n| `curSum = std::max(a[i], curSum + a[i]);` | Handles the case where the current running sum becomes smaller than the next element \u2013 effectively \u201cresetting\u201d the sub\u2011vector at that point. |\n| `best = std::max(best, curSum);` | Keeps the maximum sum encountered so far. |\n\n### Complexity\n\n* **Time**: `O(n)` \u2013 one pass over the array.  \n* **Space**: `O(1)` \u2013 only a few scalar variables are used.\n\n### How to use\n\n```cpp\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<long> v = {-2,1,-3,4,-1,2,1,-5,4};\n    std::cout << \"Max sum = \"    << max_sub_array_sum(v, v.size()) << '\\n';\n    return 0;\n}\n```\n\nThe program prints:\n\n```\nMax sum = 6\n```\n\nFeel free to replace `std::vector<long>` with a `std::vector<int>` if you prefer, as the algorithm works for any numeric type that supports addition and comparison.", "Here is a complete implementation of the \u201cmax contiguous sub\u2011array sum\u201d (Kadane\u2019s algorithm).  \nIt receives the vector `a` and its size (the `size` parameter is not required, but kept to match your signature).  \nThe algorithm runs in\u202fO(n) time and\u202fO(1) additional space.\n\n```cpp\n#include <vector>\n#include <algorithm>   // for std::max\n\n// Find the sum of the largest contiguous subvector in the given vector.\n// Uses Kadane's algorithm (linear time, constant memory).\nlong max_sub_array_sum(std::vector<long> a, long size)\n{\n    // If you really want to use the size parameter:\n    if (size <= 0)\n        return 0;              // or throw an exception, depending on your use\u2011case.\n\n    // In any case, work with the actual vector size:\n    long n = static_cast<long>(a.size());\n    if (n == 0)\n        return 0;\n\n    long best = a[0];          // best sum found so far\n    long current = a[0];       // sum of subarray ending at current position\n\n    for (long i = 1; i < n; ++i)\n    {\n        // Either extend the current subarray or start a new one at a[i]\n        current = std::max(a[i], current + a[i]);\n\n        // Update global best if needed\n        best = std::max(best, current);\n    }\n\n    return best;\n}\n```\n\n### How it works\n\n1. **Initialise** the best sum (`best`) and the current sliding sum (`current`) with the first element.  \n2. **Iterate** over the rest of the array.  \n   - For each element, decide whether to **extend** the current sub\u2011array (`current + a[i]`) or **start a new sub\u2011array** beginning at this element (`a[i]`).  \n   - Update `current` to that maximum.  \n3. **Track** the best sum seen so far (`best = max(best, current)`).\n\n### Remarks\n\n* If all numbers are negative, the algorithm correctly returns the largest (least negative) element, which is the maximum\u2011sum subarray of length\u202f1.  \n* If you don\u2019t need the `size` argument, you can simply remove it and use `a.size()` throughout.  \n* If you prefer a clearer style or want to use the FunctionPort (`std::max_element`, `std::accumulate`), Kadane\u2019s linear\u2011time approach is the most efficient.", "Here\u2019s a robust, **O(n)** implementation of the classic \u201cmaximum sub\u2011array\u201d (Kadane\u2019s algorithm).  \nFeel free to copy\u2011paste it into your project.\n\n```cpp\n#include <algorithm> // std::max\n#include <vector>\n\n/*\n *  Return the maximum possible sum of a contiguous sub\u2011vector of a.\n *  If all entries are negative the result is the largest (least negative) element.\n *\n *  Parameters\n *  ----------\n *  a    : vector of long integers (the elements are copied for simplicity; \n *         if you don\u2019t want the copy you can accept the vector by reference).\n *  size : logical size of the array (generally a.size()).\n *\n *  Return\n *  ------\n *  The maximum sub\u2011array sum.\n *\n *  Complexity\n *  ----------\n *  Time   : O(n)  \u2013 single linear pass\n *  Memory : O(1)  \u2013 constant extra space\n */\nlong max_sub_array_sum(const std::vector<long>& a, long size)\n{\n    if (size == 0) return 0;          // empty array \u2013 trivial case\n    long best = a[0];                 // best sum seen so far\n    long cur  = a[0];                 // sum of current segment\n\n    for (long i = 1; i < size; ++i) {\n        // Either extend the current segment or start a new one at a[i]\n        cur = std::max(a[i], cur + a[i]);\n        best = std::max(best, cur);\n    }\n\n    return best;\n}\n```\n\n### How it works\n\n1. **`cur`** keeps the sum of the current contiguous segment that ends at the current index.  \n2. For each element we decide whether to:\n   * extend the previous segment (`cur + a[i]`), or\n   * start a fresh segment beginning at `a[i]`.\n   We always keep the larger of these two values.\n3. **`best`** records the highest value of `cur` seen so far.  \n4. After the loop finishes, `best` is the largest possible sum of any contiguous sub\u2011vector.\n\n### Edge cases handled\n\n- All negative numbers \u2192 returns the largest (least negative) element.\n- Empty vector \u2192 returns `0` (you can change this if you prefer a different convention).\n\nFeel free to adjust the function signature if you want to accept a pointer and size instead of a `std::vector`, or to return a different type for very large sums."]}
{"name": "HumanEval_1_separate_paren_groups", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_1_separate_paren_groups.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"(()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n", "stop_tokens": ["\n}"], "completions": ["```cpp\n#include <string>\n#include <vector>\n\n/**\n * @brief Split a string that contains several independent groups of nested\n *        parentheses into a vector of the groups.\n *\n * The groups are separated by whitespace or by the fact that the first\n * parenthesis group finishes before the next group starts.\n *\n * For example:\n *   \"( ) (( )) (( )( ))\"\n * becomes\n *   {\"()\", \"(())\", \"(()())\"}\n *\n * @param paren_string Input string that may contain spaces and several\n *                     independent parenthesis groups.\n *\n * @return std::vector<std::string> Vector containing each group without\n *         spaces. Empty groups are ignored.\n */\nstd::vector<std::string> separate_paren_groups(const std::string& paren_string)\n{\n    std::vector<std::string> groups;\n    std::string current;      // buffer for the currently scanned group\n    int depth{0};             // current nesting depth\n\n    for (char c : paren_string)\n    {\n        if (c == ' ' || c == '\\t' || c == '\\n' || c == '\\r')\n            continue;         // ignore all whitespace\n\n        if (c == '(') {\n            // When entering a new group (depth was 0) we clear the buffer\n            if (depth == 0)\n                current.clear();\n\n            current.push_back(c);\n            ++depth;\n        }\n        else if (c == ')') {\n            if (depth <= 0) {\n                // Unbalanced ) \u2013 ignore it or you can assert/throw\n                continue;\n            }\n            current.push_back(c);\n            --depth;\n\n            if (depth == 0) {\n                // A complete group finished\n                if (!current.empty())\n                    groups.push_back(current);\n            }\n        }\n        else {\n            // If any other character appears we simply ignore it\n            // (or you could decide to handle it differently).\n            continue;\n        }\n    }\n\n    return groups;\n}\n```", "```cpp\n#include <vector>\n#include <string>\n#include <cctype>\n\n/*\n * Input:  a string containing several groups of nested parentheses.\n * Output: a vector holding each balanced group as a separate string.\n *\n * The algorithm simply walks through the string while keeping a counter.\n * Whenever the counter goes from 0 to 1 we start a new group.\n * Whenever the counter falls back to 0 we have finished a group and can\n * push it onto the result vector.\n *\n * Spaces are ignored, everything else is assumed to be a '(' or ')'.\n */\n\nstd::vector<std::string> separate_paren_groups(const std::string& paren_string)\n{\n    std::vector<std::string> res;\n    std::string current;          // holds the currently-being-built group\n    int balance = 0;              // current depth\n\n    for (char ch : paren_string) {\n        if (std::isspace(static_cast<unsigned char>(ch)))\n            continue;           // skip whitespace\n\n        if (ch == '(') {\n            if (balance == 0)          // start of a new group\n                current.clear();\n            current.push_back(ch);\n            ++balance;\n        } else if (ch == ')') {\n            current.push_back(ch);\n            --balance;\n            if (balance == 0)          // end of a group\n                res.push_back(current);\n        } else {\n            // unexpected character \u2013 for robustness we could throw or ignore\n            continue;\n        }\n    }\n\n    return res;\n}\n```\n\nThis implementation matches the behaviour shown in the example:\n\n```cpp\nauto v = separate_paren_groups(\"( ) (( )) (( )( ))\");\n```\n\nNow `v` contains `{\"()\", \"(())\", \"(()())\"}`.", "Below is a compact yet fully\u2011documented implementation of  \n`separate_paren_groups` that follows the specification you described.\n\n```cpp\n#include <vector>\n#include <string>\n#include <cctype>   // std::isspace\n#include <cassert>\n\n/**\n * @brief  Split a string that contains several groups of nested parentheses into\n *         individual, balanced parenthesis strings.\n *\n * @param paren_string String that may contain '(' , ')' and arbitrary whitespace.\n *                     Consecutive groups are separated by any amount of whitespace.\n *\n * @return std::vector<std::string> List of balanced parenthesis strings in the order they appear.\n *\n * Notes:\n *   * The function ignores all whitespace characters.\n *   * It assumes the input is syntactically correct (every '(' has a matching ')').\n *   * If the input contains no groups, an empty vector is returned.\n *\n * Example:\n *   separate_paren_groups(\"( ) (( )) (( )( ))\")\n *   \u2192 { \"()\", \"(())\", \"(()())\" }\n */\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    // 1. Strip whitespace to simplify the parsing logic.\n    std::string cleaned;\n    cleaned.reserve(paren_string.size());\n    for (char c : paren_string)\n        if (!std::isspace(static_cast<unsigned char>(c)))\n            cleaned.push_back(c);\n\n    std::vector<std::string> result;\n    std::string current;\n    int depth = 0;                       // current nesting depth\n\n    for (char c : cleaned) {\n        if (c == '(') {\n            if (depth == 0) {\n                // Starting a new group; make sure previous string is stored.\n                if (!current.empty()) {\n                    result.push_back(current);\n                    current.clear();\n                }\n            }\n            current.push_back(c);\n            ++depth;\n        } else if (c == ')') {\n            current.push_back(c);\n            --depth;\n            if (depth == 0) {\n                // Group finished.\n                result.push_back(current);\n                current.clear();\n            } else if (depth < 0) {\n                // Shouldn't happen with valid input.\n                assert(false && \"Unbalanced parentheses detected\");\n            }\n        } else {\n            // Allow other characters inside groups if you wish.\n            current.push_back(c);\n        }\n    }\n\n    // In case the input ended without closing a group (invalid input).\n    if (depth != 0) {\n        assert(false && \"Unbalanced parentheses at end of input\");\n    }\n\n    return result;\n}\n\n/* ------------------------------------------------------------ */\n/* --------------  Example usage & simple unit test  ---------- */\n/* ------------------------------------------------------------ */\n\n#ifdef UNIT_TEST\n#include <iostream>\n#include <sstream>\n#include <set>\n\nvoid test(const std::string& input,\n          const std::vector<std::string>& expected) {\n    std::vector<std::string> got = separate_paren_groups(input);\n    assert(got == expected);\n    std::cout << \"Passed test for: \\\"\" << input << \"\\\"\\n\";\n}\n\nint main() {\n    test(\"( ) (( )) (( )( ))\",\n         {\"()\", \"(())\", \"(()())\"});\n\n    test(\"((1)(2))   ((3))\",               // Example with numbers\n         {\"((1)(2))\", \"((3))\"});\n\n    test(\"()\", {\"()\"});\n    test(\"(())\", {\"(())\"});\n    test(\"  (  (  )   )   \", {\"(( ))\"});\n\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n#endif\n```\n\n### How it works\n1. **Whitespace removal** \u2013 A first pass strips every whitespace character so that the algorithm only deals with `'('` and `')'`.\n2. **Depth counter** \u2013 While iterating the cleaned string we keep a counter (`depth`) that reflects the current nesting level.\n3. **Group boundaries** \u2013  \n   * When `depth` goes from `0` to `1`, we are starting a new group.  \n   * When `depth` drops back to `0`, the current group is complete and is pushed into the result vector.\n4. **Assertions** \u2013 The function includes simple runtime checks that the input is balanced; they can be removed in a production build.\n\nCompile with `-DUNIT_TEST` to run the embedded unit tests. This gives you a quick sanity check that the function behaves as expected."]}
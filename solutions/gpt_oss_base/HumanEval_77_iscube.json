{"name": "HumanEval_77_iscube", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_77_iscube.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = iscube;\n    assert(candidate((1)) == (true));\n    assert(candidate((2)) == (false));\n    assert(candidate((-1)) == (true));\n    assert(candidate((64)) == (true));\n    assert(candidate((180)) == (false));\n    assert(candidate((1000)) == (true));\n    assert(candidate((0)) == (true));\n    assert(candidate((1729)) == (false));\n}\n", "stop_tokens": ["\n}"], "completions": ["```cpp\n/*\n *  Returns true if *a* is a perfect cube of an integer, otherwise false.\n *\n *  Example:\n *      iscube(1)  -> true   (1\u00b3)\n *      iscube(2)  -> false\n *      iscube(-1) -> true   (-1\u00b3)\n *      iscube(64) -> true   (4\u00b3)\n *      iscube(0)  -> true   (0\u00b3)\n *      iscube(180)-> false\n */\n\nbool iscube(long a)\n{\n    /* \n     * For negative numbers the cube root is negative, but the\n     * standard library function std::cbrt guarantees the sign is preserved.\n     */\n    long cbrt_val = static_cast<long>(std::cbrt((long double)a));\n\n    /* \n     * Due to rounding errors in floating point evaluations we\n     * need to test the candidate and its neighbours.\n     */\n    if (cbrt_val * cbrt_val * cbrt_val == a)\n        return true;\n    if ((cbrt_val + 1) * (cbrt_val + 1) * (cbrt_val + 1) == a)\n        return true;\n    if ((cbrt_val - 1) * (cbrt_val - 1) * (cbrt_val - 1) == a)\n        return true;\n    return false;\n}\n```\n\nThe function uses `std::cbrt` (C++17) to get a close approximation to the cube root, then verifies the integer candidate and its immediate neighbours to guard against any floating\u2011point rounding errors. This works for all `long` values that fit into the representable range of `long double`.", "```cpp\n#include <cmath>   // for cbrt\n#include <cassert> // for assert\n\n// Returns true if `a` is the cube of an integer.\nbool iscube(long a) {\n    // Calculate the real cube root of `a`.\n    double d = std::cbrt(static_cast<double>(a));\n\n    // Round to the nearest integer.\n    long r = static_cast<long>(std::llround(d));\n\n    // Because of rounding we can loose the sign for very large numbers \u2013\n    // compare the cube explicitly.\n    return r * r * r == a;\n}\n\n/* ----------  Example usage  ----------\n#include <iostream>\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << iscube(1)   << '\\n';  // true\n    std::cout << iscube(2)   << '\\n';  // false\n    std::cout << iscube(-1)  << '\\n';  // true\n    std::cout << iscube(64)  << '\\n';  // true\n    std::cout << iscube(0)   << '\\n';  // true\n    std::cout << iscube(180) << '\\n';  // false\n    return 0;\n}\n--------------------------------- */\n```", "```cpp\n// ------------------------------------------------------------\n//  Returns true iff `a` is a perfect cube of an integer.\n// ------------------------------------------------------------\nbool iscube(long a) {\n    // Cube root can be negative, we keep the sign for `a` when `a < 0`\n    long croot = llround(pow((long double)a, 1.0L / 3.0L));\n\n    // For very large `a` the floating point approximation may be off by 1.\n    // We just need to check the two nearest candidates.\n    for (long cand = croot - 1; cand <= croot + 1; ++cand) {\n        if (cand * cand * cand == a) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n\nThe function first takes the real cube root using `pow`, rounds it to the nearest integer, and then verifies whether that integer cubed equals the original number (checking the immediate neighbours in case of floating\u2011point rounding). This works for all possible `long` inputs."]}
{"name": "mbpp_611_max_of_nth", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which given a matrix represented as a vector of vectors returns the max of the n'th column.\nlong max_of_nth(std::vector<std::vector<long>> test_list, long N) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_611_max_of_nth.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = max_of_nth;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)6, (long)7}), (std::vector<long>)std::vector<long>({(long)1, (long)3, (long)5}), (std::vector<long>)std::vector<long>({(long)8, (long)9, (long)19})})), (2)) == (19));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)7, (long)8}), (std::vector<long>)std::vector<long>({(long)2, (long)4, (long)6}), (std::vector<long>)std::vector<long>({(long)9, (long)10, (long)20})})), (1)) == (10));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9}), (std::vector<long>)std::vector<long>({(long)3, (long)5, (long)7}), (std::vector<long>)std::vector<long>({(long)10, (long)11, (long)21})})), (1)) == (11));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a clean, self\u2011contained implementation that does exactly what you\u2019re asking for:  \n\n* It receives the matrix as a `std::vector<std::vector<long>>`.  \n* It receives the column index `N` (zero\u2011based).  \n* It returns the maximum value found in that column.  \n* If the input is empty or the column index is out of bounds, it throws an exception \u2013 or you can change that behaviour to suit your needs (e.g., return `0` or `std::numeric_limits<long>::min()`).\n\n```cpp\n#include <vector>\n#include <stdexcept>\n#include <algorithm>\n#include <numeric>   // std::begin, std::end\n\n// ------------------------------------------------------------------\n// Returns the maximum element in the N\u2011th column of a 2\u2011D matrix.\n//   - matrix : vector of vector containing the data (row\u2011major order)\n//   - N      : zero\u2011based column index\n//\n// Throws std::invalid_argument if:\n//   1. the matrix is empty\n//   2. the matrix rows are empty\n//   3. N is out of bounds\n// ------------------------------------------------------------------\nlong max_of_nth(const std::vector<std::vector<long>>& matrix, std::size_t N)\n{\n    // Basic sanity checks\n    if (matrix.empty())\n        throw std::invalid_argument(\"Input matrix is empty\");\n\n    // All rows must have the same width \u2013 if you want to allow ragged\n    // matrices simply remove this check.\n    std::size_t numRows = matrix.size();\n    std::size_t numCols = matrix[0].size(); // assume at least one row\n    for (std::size_t r = 1; r < numRows; ++r)\n        if (matrix[r].size() != numCols)\n            throw std::invalid_argument(\"Inconsistent row widths\");\n\n    if (N >= numCols)\n        throw std::invalid_argument(\"N is out of column bounds\");\n\n    // Now scan through each row to find the maximum in column N\n    long maxVal = matrix[0][N];\n    for (std::size_t r = 1; r < numRows; ++r)\n        if (matrix[r][N] > maxVal)\n            maxVal = matrix[r][N];\n\n    return maxVal;\n}\n```\n\n### How to use it\n\n```cpp\nint main()\n{\n    std::vector<std::vector<long>> mat{\n        {1, 5, 2},\n        {4, -1, 3},\n        {7, 0, 9}\n    };\n\n    std::size_t col = 1;                 // looking at the second column\n    long maxVal = max_of_nth(mat, col);  // should be 5\n\n    std::cout << \"Max in column \" << col << \" is \" << maxVal << '\\n';\n}\n```\n\n### Notes & variations\n\n| Requirement | Typical tweak |\n|-------------|---------------|\n| **Zero\u2011based vs. one\u2011based index** | If you prefer 1\u2011based indexing just call `max_of_nth(mat, N-1)` or adjust the function to accept a `long N` and subtract 1 internally. |\n| **Empty matrix** | The function throws an exception; you can instead return a sentinel value. |\n| **Variable\u2011width rows** | Remove the consistency check and treat each row separately. |\n| **Parallelism** | For huge matrices you could parallelise the column scan (e.g., using OpenMP or `std::execution::par`). |\n\nThat\u2019s all you need to get the maximum of any column as fast as possible!", "Here is a safe, compact implementation that returns the maximum value of the *N\u2011th* column (0\u2011based).  \nIt checks that the matrix is non\u2011empty, that every row has at least *N+1* elements, and that the column actually exists. In case of an invalid input the function will throw a `std::out_of_range` exception (you could also return a sentinel value if you prefer).\n\n```cpp\n#include <vector>\n#include <algorithm>   // for std::max_element\n#include <stdexcept>   // for std::out_of_range\n\n// Return the maximum value in the N-th column (0\u2011based) of a matrix.\nlong max_of_nth(const std::vector<std::vector<long>>& matrix, std::size_t N)\n{\n    if (matrix.empty())\n        throw std::out_of_range(\"Matrix is empty\");\n\n    // Ensure that every row contains at least N+1 columns\n    for (const auto& row : matrix)\n        if (row.size() <= N)\n            throw std::out_of_range(\"Column index out of range for one or more rows\");\n\n    long max_val = matrix[0][N];          // initialise with the first element of the column\n\n    for (std::size_t r = 1; r < matrix.size(); ++r)\n        if (matrix[r][N] > max_val)\n            max_val = matrix[r][N];\n\n    return max_val;\n}\n```\n\n### How it works\n\n1. **Input validation** \u2013  \n   *The matrix must have at least one row.*  \n   *Each row must contain at least `N+1` elements.*\n\n2. **Initialisation** \u2013  \n   `max_val` starts with the first element of the requested column.\n\n3. **Iterate** \u2013  \n   Scan the remaining rows; update `max_val` whenever a larger value is found.\n\n4. **Return** \u2013  \n   The largest value found in that column.\n\nThis implementation uses only a single pass over the column (O(m) where `m` is the number of rows) and keeps constant extra space. Feel free to adapt the error handling to your specific requirements.", "Below is a complete, self\u2011contained implementation of the requested function along with a few helper wrappers and a quick test harness.  \nThe implementation is **type\u2011safe**, **robust** and follows modern C++\u201117 (or newer) idioms.\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <stdexcept>\n\n/**\n * @brief Return the maximum value in the N\u2011th column of a matrix.\n * @tparam T Numeric type that supports comparison (e.g., int, long, double).\n * @param matrix A non\u2011empty, rectangular matrix (vector of vectors) with at least one row.\n * @param N Zero\u2011based column index. Must satisfy 0 <= N < number_of_columns.\n * @return The maximum element in column N.\n *\n * @throws std::invalid_argument if the matrix is empty, or has irregular inner\n *           vectors, or if N is out of bounds.\n */\ntemplate <typename T>\nT max_of_nth(const std::vector<std::vector<T>>& matrix, std::size_t N)\n{\n    // --- basic sanity checks -------------------------------------------------\n\n    if (matrix.empty())\n        throw std::invalid_argument(\"Matrix is empty.\");\n\n    // ensure the matrix is rectangular\n    const std::size_t num_cols = matrix[0].size();\n    if (num_cols == 0)\n        throw std::invalid_argument(\"Matrix has zero columns.\");\n\n    for (std::size_t r = 1; r < matrix.size(); ++r) {\n        if (matrix[r].size() != num_cols)\n            throw std::invalid_argument(\"Matrix rows have differing lengths.\");\n    }\n\n    if (N >= num_cols)\n        throw std::out_of_range(\"Column index N is out of bounds.\");\n\n    // --- compute maximum ----------------------------------------------------\n\n    T col_max = matrix[0][N];            // initialise with first element of column\n    for (std::size_t r = 1; r < matrix.size(); ++r) {\n        if (matrix[r][N] > col_max)\n            col_max = matrix[r][N];\n    }\n\n    return col_max;\n}\n```\n\n### What the code does\n\n| Step | Action |\n|------|--------|\n| **1** | Check that the matrix is non\u2011empty. |\n| **2** | Confirm all rows have the same length \u2192 rectangular matrix. |\n| **3** | Verify that `N` is a valid column index (`0 <= N < num_cols`). |\n| **4** | Initialise the maximum with the first element of column `N`. |\n| **5** | Iterate over the remaining rows, updating the maximum when a larger value is found. |\n| **6** | Return the computed maximum. |\n\n### Why the design choices?\n\n| Feature | Reason |\n|---------|--------|\n| `template <typename T>` | Works with any numeric type (`int`, `long`, `double`, etc.). |\n| `const` reference for the matrix | Avoids copying the whole matrix. |\n| Exceptions for error conditions | Clear diagnostics; caller can catch `std::invalid_argument` or `std::out_of_range`. |\n| `std::size_t` for indices | Unsigned types that match container sizes. |\n| No `<bits/stdc++.h>` | Keeps the header list portable across compilers. |\n\n### Quick usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<std::vector<long>> mat = {\n        {3, 5, 1, 9},\n        {2, 8, 7, 4},\n        {5, 1, 0, 6}\n    };\n\n    try {\n        long max_in_col2 = max_of_nth(mat, 2);   // third column (index 2)\n        std::cout << \"Maximum in column 2: \" << max_in_col2 << '\\n';\n    } catch (const std::exception& ex) {\n        std::cerr << \"Error: \" << ex.what() << '\\n';\n    }\n}\n```\n\nOutput:\n\n```\nMaximum in column 2: 7\n```\n\nFeel free to adapt the function to specialized types (e.g., `float`, `std::complex`) as long as they support the `>` operator."]}
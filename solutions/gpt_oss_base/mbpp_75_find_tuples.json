{"name": "mbpp_75_find_tuples", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find tuples which have all elements divisible by k from the given vector of tuples.\nstd::vector<std::tuple<long, long, long>> find_tuples(std::vector<std::tuple<long, long, long>> test_list, long K) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_75_find_tuples.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = find_tuples;\n    assert(candidate((std::vector<std::tuple<long, long, long>>({(std::tuple<long, long, long>)std::make_tuple(6, 24, 12), (std::tuple<long, long, long>)std::make_tuple(7, 9, 6), (std::tuple<long, long, long>)std::make_tuple(12, 18, 21)})), (6)) == (std::vector<std::tuple<long, long, long>>({(std::tuple<long, long, long>)std::make_tuple(6, 24, 12)})));\n    assert(candidate((std::vector<std::tuple<long, long, long>>({(std::tuple<long, long, long>)std::make_tuple(5, 25, 30), (std::tuple<long, long, long>)std::make_tuple(4, 2, 3), (std::tuple<long, long, long>)std::make_tuple(7, 8, 9)})), (5)) == (std::vector<std::tuple<long, long, long>>({(std::tuple<long, long, long>)std::make_tuple(5, 25, 30)})));\n    assert(candidate((std::vector<std::tuple<long, long, long>>({(std::tuple<long, long, long>)std::make_tuple(7, 9, 16), (std::tuple<long, long, long>)std::make_tuple(8, 16, 4), (std::tuple<long, long, long>)std::make_tuple(19, 17, 18)})), (4)) == (std::vector<std::tuple<long, long, long>>({(std::tuple<long, long, long>)std::make_tuple(8, 16, 4)})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a **complete, ready\u2011to\u2011run** snippet that demonstrates an efficient implementation of `find_tuples`.  \nThe function iterates once through the input vector, checks whether each element of a tuple is divisible by `K`, and pushes the qualifying tuples into a result vector.  \nAll standard library features are used \u2013 no external dependencies beyond `<tuple>`, `<vector>` and `<algorithm>`.\n\n```cpp\n#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <cassert>\n\n/**\n * @brief Returns a vector containing all tuples from *test_list*\n *        whose three elements are all divisible by *K*.\n *\n * @param test_list  Input vector of tuples (long, long, long).\n * @param K          Divisor to check against.\n * @return std::vector<std::tuple<long, long, long>>  The filtered tuples.\n *\n * Complexity:  O(n) where n = test_list.size()\n *              Each tuple is examined only once.\n *              The algorithm is linear in the input size.\n *\n * Edge cases:\n * - Empty input \u2192 empty result.\n * - K == 0 throws an exception (division by zero).\n * - Negative numbers are handled normally because the remainder\n *   operation in C++ yields zero for exact divisibility.\n */\nstd::vector<std::tuple<long, long, long>>\nfind_tuples(const std::vector<std::tuple<long, long, long>>& test_list,\n            long K)\n{\n    if (K == 0) {\n        throw std::invalid_argument(\"K must be non\u2011zero\");\n    }\n\n    std::vector<std::tuple<long, long, long>> res;\n    res.reserve(test_list.size());   // avoid reallocations\n\n    for (const auto& t : test_list) {\n        long a = std::get<0>(t);\n        long b = std::get<1>(t);\n        long c = std::get<2>(t);\n\n        if (a % K == 0 && b % K == 0 && c % K == 0) {\n            res.push_back(t);\n        }\n    }\n    return res;\n}\n\n/* =======  Tests (you can run this with any C++20 compiler) ======= */\n#include <iostream>\n\nint main() {\n    std::vector<std::tuple<long, long, long>> data{\n        {6, 12, 18},\n        {5, 10, 15},\n        {14, 28, 42},\n        {7, 21, 35},\n        {8, 16, 24}\n    };\n\n    long k = 7;\n    auto result = find_tuples(data, k);\n\n    std::cout << \"Tuples divisible by \" << k << \":\\n\";\n    for (const auto& t : result) {\n        std::cout << \"(\"\n                  << std::get<0>(t) << \", \"\n                  << std::get<1>(t) << \", \"\n                  << std::get<2>(t) << \")\\n\";\n    }\n\n    // Expected output: (14, 28, 42) and (7, 21, 35)\n    assert(result.size() == 2);\n    assert(std::get<0>(result[0]) == 14 && std::get<1>(result[0]) == 28 && std::get<2>(result[0]) == 42);\n    assert(std::get<0>(result[1]) == 7  && std::get<1>(result[1]) == 21 && std::get<2>(result[1]) == 35);\n\n    std::cout << \"All tests passed.\\n\";\n    return 0;\n}\n```\n\n### How it works\n1. **Input safety**  \n   - `K` must be non\u2011zero; otherwise, division by zero would occur.\n2. **Iteration**  \n   - The function walks through each tuple once (`O(n)`).\n3. **Divisibility check**  \n   - `a % K == 0 && b % K == 0 && c % K == 0` guarantees all three elements are divisible.\n4. **Result collection**  \n   - Qualified tuples are appended to `res`; the vector is pre\u2011allocated to match the input size, preventing unnecessary reallocations.\n\nFeel free to drop this into your project or adapt it as needed!", "Here\u2019s a small, self\u2011contained snippet that implements the requested function and demonstrates how to use it.  \nThe code iterates over the input vector, keeps only those tuples where **every** component is divisible by `K`, and returns a new vector with the selected tuples.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cassert>\n\n// ------------------------------------------------------------------\n//  find_tuples\n//\n//  Input:  test_list \u2013 vector of std::tuple<long, long, long>\n//          K          \u2013 divisor\n//\n//  Output: A new vector containing only the tuples whose all three\n//          components are divisible by K.\n//\n//  Complexity:  O(n),   n = test_list.size()\n//  Memory:      O(n)    (worst case, when all tuples satisfy the condition)\n// ------------------------------------------------------------------\nstd::vector<std::tuple<long, long, long>>\nfind_tuples(const std::vector<std::tuple<long, long, long>>& test_list,\n            long K)\n{\n    std::vector<std::tuple<long, long, long>> result;\n\n    // Guard against division by zero \u2013 though callers may ensure K != 0\n    assert(K != 0 && \"Divisor K must not be zero.\");\n\n    for (const auto& t : test_list) {\n        long a, b, c;\n        std::tie(a, b, c) = t;          // unpack the tuple\n\n        if (a % K == 0 && b % K == 0 && c % K == 0) {\n            result.push_back(t);       // keep the tuple\n        }\n    }\n    return result;\n}\n\n// ------------------------------------------------------------------\n//  Helper: print a vector of tuples \u2013 for testing purposes\n// ------------------------------------------------------------------\nvoid print_tuples(const std::vector<std::tuple<long,long,long>>& vec)\n{\n    for (const auto &t : vec) {\n        std::cout << \"(\" << std::get<0>(t) << \", \"\n                               << std::get<1>(t) << \", \"\n                               << std::get<2>(t) << \")\\n\";\n    }\n}\n\nint main()\n{\n    // Example data\n    std::vector<std::tuple<long,long,long>> mylist {\n        {6, 12, 18},\n        {5, 10, 15},\n        {9, 3, 27},\n        {4, 8, 12}\n    };\n\n    long divisor = 3;\n\n    std::vector<std::tuple<long,long,long>> filtered =\n        find_tuples(mylist, divisor);\n\n    std::cout << \"Tuples divisible by \" << divisor << \":\\n\";\n    print_tuples(filtered);\n\n    return 0;\n}\n```\n\n### How it Works\n1. **Iteration** \u2013 We loop once over `test_list` (linear time).\n2. **Unpack** \u2013 `std::tie(a,b,c)` pulls the three numbers from the tuple.\n3. **Check divisibility** \u2013 Every component must satisfy `value % K == 0`.\n4. **Keep it** \u2013 If the condition holds, the tuple is copied into the result vector.\n\n### Test Output (with the example above)\n```\nTuples divisible by 3:\n(6, 12, 18)\n(9, 3, 27)\n```\n\nFeel free to drop this function into any of your projects. If you need it to handle other tuple sizes or types, the logic stays the same \u2013 just adjust the unpacking and the condition checks.", "Below is a **complete and easy\u2011to\u2011understand implementation** that does exactly what the prompt asks for:\n\n```cpp\n#include <tuple>\n#include <vector>\n\n/**\n * @brief  Find all 3\u2011element tuples whose every element is divisible by K.\n *\n * @param test_list  Input container \u2013 a vector of 3\u2011tuples.\n * @param K          The divisor.  It must be non\u2011zero.\n *\n * @return           A new vector that contains only those tuples from\n *                   `test_list` where each of the three elements is\n *                   an integer multiple of `K`.\n *\n * Complexity: O(n)  \u2013 we make a single pass over the input vector.\n *\n * Example\n * --------\n * std::vector<std::tuple<long,long,long>> v{\n *     {6, 12, 18},\n *     {5, 10, 15},\n *     {7, 14, 21}\n * };\n * auto r = find_tuples(v, 3);\n * // r will contain { {6,12,18} } \u2013 only the first tuple is fully divisible by 3.\n */\nstd::vector<std::tuple<long, long, long>>\nfind_tuples(const std::vector<std::tuple<long, long, long>>& test_list,\n            long K)\n{\n    // Guard against division by zero \u2013 the function can either\n    // return an empty vector or throw an exception.  Here we choose\n    // to throw, which makes bugs obvious at runtime.\n    if (K == 0) {\n        throw std::invalid_argument(\"K must be non\u2011zero\");\n    }\n\n    std::vector<std::tuple<long, long, long>> result;\n    result.reserve(test_list.size());       // pre\u2011allocate for speed\n\n    for (const auto& t : test_list) {\n        const auto [a, b, c] = t;           // unpack the tuple\n\n        if (a % K == 0 && b % K == 0 && c % K == 0) {\n            result.push_back(t);\n        }\n    }\n\n    return result;\n}\n```\n\n### How it works\n\n1. **Guard clause** \u2013 the function immediately throws if `K` is zero because modulo by zero is undefined.\n2. **Early reservation** \u2013 `reserve` avoids repeated reallocations when the output vector grows.\n3. **Standard loop** \u2013 each tuple is unpacked using structured binding, then each component is checked against `K`.\n4. **Result** \u2013 only tuples that satisfy the divisibility condition are added to `result`.\n\nFeel free to drop this function into your existing codebase. If you need any additional features (e.g., handling `K<0` or accepting a custom predicate), let me know!"]}
{"name": "HumanEval_136_largest_smallest_integers", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_136_largest_smallest_integers.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = largest_smallest_integers;\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7, (long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)-2}))) == std::make_tuple(-2, 1));\n    assert(candidate((std::vector<long>({(long)4, (long)5, (long)3, (long)6, (long)2, (long)7, (long)-7}))) == std::make_tuple(-7, 2));\n    assert(candidate((std::vector<long>({(long)7, (long)3, (long)8, (long)4, (long)9, (long)2, (long)5, (long)-9}))) == std::make_tuple(-9, 2));\n    assert(candidate((std::vector<long>())) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6, (long)0}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)1}))) == std::make_tuple(-3, 1));\n    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)-100, (long)1}))) == std::make_tuple(-3, 1));\n}\n", "stop_tokens": ["\n}"], "completions": ["```cpp\n#include <tuple>\n#include <optional>\n#include <vector>\n#include <limits>\n\nstd::tuple<std::optional<long>, std::optional<long>>\nlargest_smallest_integers(std::vector<long> lst)\n{\n    // For the largest negative number\n    long max_neg = std::numeric_limits<long>::min();\n    bool found_neg = false;\n\n    // For the smallest positive number\n    long min_pos = std::numeric_limits<long>::max();\n    bool found_pos = false;\n\n    for (const auto &x : lst) {\n        if (x < 0) {\n            if (!found_neg || x > max_neg) {\n                max_neg = x;\n                found_neg = true;\n            }\n        } else if (x > 0) {\n            if (!found_pos || x < min_pos) {\n                min_pos = x;\n                found_pos = true;\n            }\n        }\n        // 0 is ignored (neither negative nor positive)\n    }\n\n    std::optional<long> opt_neg = found_neg ? std::optional<long>(max_neg) : std::nullopt;\n    std::optional<long> opt_pos = found_pos ? std::optional<long>(min_pos) : std::nullopt;\n\n    return std::make_tuple(opt_neg, opt_pos);\n}\n```", "Here is a concise and fully\u2011compatible implementation that follows the specification:\n\n```cpp\n#include <vector>\n#include <optional>\n#include <tuple>\n#include <algorithm>\n#include <limits>\n\n/*\n *  largest_smallest_integers\n *\n *  Given a vector of long integers, this function returns a tuple\n *  containing:\n *      - The largest (closest to zero) negative integer, wrapped in\n *        std::optional<long>.  If the vector contains no negative\n *        values, the optional is std::nullopt.\n *      - The smallest positive integer, wrapped in std::optional<long>.\n *        If the vector contains no positive values, this optional is\n *        std::nullopt.\n *\n *  Zero, or any numbers that are neither negative nor positive,\n *  are ignored.\n */\nstd::tuple<std::optional<long>, std::optional<long>>\nlargest_smallest_integers(const std::vector<long>& lst)\n{\n    std::optional<long> largest_neg;   // largest negative\n    std::optional<long> smallest_pos;  // smallest positive\n\n    for (long v : lst) {\n        if (v < 0) {\n            if (!largest_neg || v > *largest_neg) {   // closer to zero\n                largest_neg = v;\n            }\n        } else if (v > 0) {\n            if (!smallest_pos || v < *smallest_pos) {\n                smallest_pos = v;\n            }\n        }\n        // zeros are ignored\n    }\n\n    return std::make_tuple(largest_neg, smallest_pos);\n}\n```\n\n### Usage examples\n\n```cpp\n#include <iostream>\n\nint main() {\n    auto t1 = largest_smallest_integers({2,4,1,3,5,7});\n    std::cout << (t1.first.has_value() ? std::to_string(*t1.first) : \"None\")\n              << \" , \"\n              << (t1.second.has_value() ? std::to_string(*t1.second) : \"None\")\n              << '\\n';   // outputs \"None , 1\"\n\n    auto t2 = largest_smallest_integers({});\n    std::cout << (t2.first.has_value() ? std::to_string(*t2.first) : \"None\")\n              << \" , \"\n              << (t2.second.has_value() ? std::to_string(*t2.second) : \"None\")\n              << '\\n';   // outputs \"None , None\"\n\n    auto t3 = largest_smallest_integers({0});\n    std::cout << (t3.first.has_value() ? std::to_string(*t3.first) : \"None\")\n              << \" , \"\n              << (t3.second.has_value() ? std::to_string(*t3.second) : \"None\")\n              << '\\n';   // outputs \"None , None\"\n}\n```\n\nThe implementation is O(n) in time, uses only standard library facilities, and respects the requirement to return `std::nullopt` when an appropriate value does not exist.", "Sure! Below is a complete and idiomatic C++ implementation of the `largest_smallest_integers` function that follows the specification you described. It returns a `std::tuple<std::optional<long>, std::optional<long>>` where the first element is the **largest negative integer** found in the vector (or `std::nullopt` if none exists) and the second element is the **smallest positive integer** (or `std::nullopt` if none exists).\n\n```cpp\n#include <tuple>\n#include <optional>\n#include <vector>\n#include <limits>\n#include <algorithm>\n\n/**\n * @brief Find the largest negative integer and the smallest positive integer\n * from a vector of long integers.\n *\n * @param lst Vector of long integers.\n * @return std::tuple<std::optional<long>, std::optional<long>>\n *         - first element: largest negative integer (or std::nullopt if none)\n *         - second element: smallest positive integer (or std::nullopt if none)\n */\nstd::tuple<std::optional<long>, std::optional<long>>\nlargest_smallest_integers(const std::vector<long>& lst)\n{\n    // Initialize containers for the required values.\n    std::optional<long> largest_neg;\n    std::optional<long> smallest_pos;\n\n    // Sentinel values that cannot be encountered in the input.\n    long neg_inf  = std::numeric_limits<long>::min();\n    long pos_inf  = std::numeric_limits<long>::max();\n\n    long current_neg = neg_inf;   // Will hold the largest negative seen so far\n    long current_pos = pos_inf;   // Will hold the smallest positive seen so far\n\n    for (const long val : lst)\n    {\n        if (val < 0) {\n            // Update the largest negative if needed.\n            if (val > current_neg) {\n                current_neg = val;\n            }\n        } else if (val > 0) {\n            // Update the smallest positive if needed.\n            if (val < current_pos) {\n                current_pos = val;\n            }\n        }\n        // Zero is ignored for both categories as per the spec.\n    }\n\n    // Wrap results in std::optional only if a valid value was found.\n    if (current_neg != neg_inf) {\n        largest_neg = current_neg;\n    }\n    if (current_pos != pos_inf) {\n        smallest_pos = current_pos;\n    }\n\n    return std::make_tuple(largest_neg, smallest_pos);\n}\n```\n\n### How It Works\n\n1. **Initialization**  \n   - `largest_neg` and `smallest_pos` are `std::optional<long>` values that will eventually contain the result or remain empty (`std::nullopt`).\n   - Sentinel values `neg_inf` and `pos_inf` are used to detect whether we saw any negative or positive numbers.\n\n2. **Iteration**  \n   - For each element in the vector:\n     - If it\u2019s negative (`val < 0`), update `current_neg` if it's larger than the current stored negative.\n     - If it\u2019s positive (`val > 0`), update `current_pos` if it's smaller than the current stored positive.\n     - Zero is ignored because it is neither negative nor positive.\n\n3. **Result Construction**  \n   - After the loop, compare the sentinel values.  \n     - If `current_neg` changed, assign it to `largest_neg`.  \n     - If `current_pos` changed, assign it to `smallest_pos`.  \n   - Return the tuple `std::make_tuple(largest_neg, smallest_pos)`.\n\n### Usage Example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> v = {2, 4, 1, 3, 5, 7};\n    auto [largest_neg, smallest_pos] = largest_smallest_integers(v);\n\n    if (largest_neg) {\n        std::cout << \"Largest negative: \" << *largest_neg << '\\n';\n    } else {\n        std::cout << \"No negative numbers.\\n\";\n    }\n\n    if (smallest_pos) {\n        std::cout << \"Smallest positive: \" << *smallest_pos << '\\n';\n    } else {\n        std::cout << \"No positive numbers.\\n\";\n    }\n\n    return 0;\n}\n```\n\nRunning this program would output:\n\n```\nNo negative numbers.\nSmallest positive: 1\n```\n\nFeel free to adapt the code to your specific project or style guidelines!"]}
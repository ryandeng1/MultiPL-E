{"name": "mbpp_600_is_Even", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to check whether the given number is even or not.\nbool is_Even(long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_600_is_Even.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = is_Even;\n    assert(candidate((1)) == (false));\n    assert(candidate((2)) == (true));\n    assert(candidate((3)) == (false));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a clean, self\u2011contained C++ implementation that checks whether a given integer is even.  \nI\u2019ll also include a tiny test harness so you can see it in action.  \n\n```cpp\n#include <iostream>\n#include <cassert>\n\n/**\n * @brief Returns true if `n` is an even integer, false otherwise.\n *\n * The implementation uses the bit\u2011wise AND operator which is both\n * concise and very fast.  \n * For any integer `n`, `n & 1` is 0 when the least significant bit is 0\n * (i.e. `n` is even), and 1 when the bit is 1 (i.e. `n` is odd).\n *\n * @param n The integer to test.\n * @return true  if `n` is even\n * @return false if `n` is odd\n */\nbool is_Even(long n) {\n    return (n & 1) == 0;\n}\n\n/* ------------------------------------------------------------------ */\n/* Optional: tiny test harness to validate the function                */\nint main() {\n    // Basic assertions\n    assert(is_Even( 0) == true);\n    assert(is_Even( 2) == true);\n    assert(is_Even(-2) == true);\n    assert(is_Even( 1) == false);\n    assert(is_Even(-1) == false);\n    assert(is_Even(12345678) == true);\n    assert(is_Even(12345679) == false);\n\n    // Simple demo on screen\n    std::cout << \"12 is \" << (is_Even(12) ? \"even\" : \"odd\") << '\\n';\n    std::cout << \"13 is \" << (is_Even(13) ? \"even\" : \"odd\") << '\\n';\n\n    std::cout << \"All tests passed.\\n\";\n    return 0;\n}\n```\n\n### Why this implementation works\n* **Bit\u2011wise test `n & 1`** \u2013 checks the least\u2011significant bit.  \n  * If the lowest bit is `0`, the number is divisible by 2 (even).  \n  * If it's `1`, the number is not divisible by 2 (odd).\n* The function is `inline` by default because it\u2019s so small; compilers will\n  usually expand it in place, giving negligible overhead.\n\nFeel free to drop the `main` function into your project if you want to run\nthese examples, or simply use `is_Even` wherever you need to distinguish even\nfrom odd numbers.", "Below is a minimal, self\u2011contained C++ implementation that checks whether a given integer is even.  \nThe function `is_Even` returns `true` for even numbers, `false` otherwise.  \nI also include a short `main` function for illustration and a few unit\u2011style tests using `assert`.\n\n```cpp\n#include <iostream>\n#include <cassert>\n\n/*-------------------------------------------------------------------------\n *  Check whether a number is even\n *  - For any integral type (signed/unsigned, long, int\u2026) the function\n *    uses the bit\u2011wise AND operator which is both fast and unambiguous.\n *\n *  Parameters:\n *      n \u2013 the number to test.\n *  Returns:\n *      true  if n is even (n % 2 == 0),\n *      false otherwise.\n *--------------------------------------------------------------------------*/\nbool is_Even(long n) {\n    return (n & 1) == 0;          // 0 if even, 1 if odd\n}\n\n/*--------------------------  Demo / test harness  --------------------------*/\nint main() {\n    // Simple demo\n    std::cout << std::boolalpha;   // show true/false instead of 1/0\n    std::cout << \"is_Even(10) = \" << is_Even(10) << '\\n'; // true\n    std::cout << \"is_Even(-5) = \" << is_Even(-5) << '\\n'; // false\n\n    // Basic unit\u2011style tests\n    assert(is_Even(0)  == true);\n    assert(is_Even(1)  == false);\n    assert(is_Even(2)  == true);\n    assert(is_Even(-2) == true);\n    assert(is_Even(1234567890123456789LL) == false);\n    assert(is_Even(1234567890123456788LL) == true);\n\n    std::cout << \"All tests passed.\\n\";\n    return 0;\n}\n```\n\n### Why this implementation?\n\n| Feature | Reason |\n|---------|--------|\n| `& 1`   | Extremely fast (no division), works for signed/unsigned values |\n| `long`  | Matches the function signature requested; change to `long long` if you need wider integers |\n| `std::boolalpha` | Makes the output human\u2011friendly (`true`/`false`) |\n| `assert` | Provides quick sanity checks without external testing frameworks |\n\nCompile with a standard C++ compiler:\n\n```bash\ng++ -std=c++17 -O2 -Wall -Wextra -o even_check even_check.cpp\n./even_check\n```\n\nFeel free to drop the `main` and integrate `is_Even` into any code base.", "Here is a short, clean C++ function that determines whether a given `long` value is even:\n\n```cpp\n/**\n * @brief  Checks whether a number is even.\n * @param  n The number to check.\n * @return  true  if n is even,\n *          false otherwise.\n */\nbool is_Even(long n)\n{\n    return (n % 2 == 0);\n}\n```\n\n### Explanation\n* `n % 2` computes the remainder when `n` is divided by `2`.\n* If the remainder is `0`, the number is even, so the function returns `true`.\n* For any other remainder, the number is odd, and `false` is returned.\n\nThis function works for positive and negative values of `long` because the modulo operation behaves the same for both. If you want to handle `unsigned long`, the same logic applies."]}
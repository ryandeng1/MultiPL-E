{"name": "HumanEval_89_encrypt", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_89_encrypt.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = encrypt;\n    assert(candidate((\"hi\")) == (\"lm\"));\n    assert(candidate((\"asdfghjkl\")) == (\"ewhjklnop\"));\n    assert(candidate((\"gf\")) == (\"kj\"));\n    assert(candidate((\"et\")) == (\"ix\"));\n    assert(candidate((\"faewfawefaewg\")) == (\"jeiajeaijeiak\"));\n    assert(candidate((\"hellomyfriend\")) == (\"lippsqcjvmirh\"));\n    assert(candidate((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")) == (\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert(candidate((\"a\")) == (\"e\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a minimal, self\u2011contained implementation that follows the description:\n\n```cpp\n#include <string>\n#include <cctype>\n\n// ------------------------------------------------------------\n// encrypt : shift every lowercase letter by 4 positions\n//   (h\u2192l, i\u2192m, \u2026  z\u2192d)  \u2013 the mapping is simply \"rot4\".\n// any other character is left untouched.\n// ------------------------------------------------------------\nstd::string encrypt(std::string s)\n{\n    for (char &c : s)                     // iterate over the string\n    {\n        if (std::islower(static_cast<unsigned char>(c))) /* only a..z */\n        {\n            // shift by 4, keep wrap\u2013around in the [a..z] range\n            c = static_cast<char>('a' + (c - 'a' + 4) % 26);\n        }\n    }\n    return s;\n}\n```\n\n### How it matches the examples\n\n| input      | output | explanation |\n|------------|--------|-------------|\n| `\"hi\"`     | `\"lm\"` | `'h'\u21a6'l'`, `'i'\u21a6'm'` ( +4 ) |\n| `\"asdfghjkl\"` | `\"ewhjklnop\"` | each letter shifted +4 |\n| `\"gf\"`     | `\"kj\"` | `g\u21a6k`, `f\u21a6j` |\n| `\"et\"`     | `\"ix\"` | `e\u21a6i`, `t\u21a6x` |\n\n### Notes\n\n* The implementation deliberately ignores non\u2011lowercase letters (digits, uppercase, punctuation, etc.) \u2013 they are returned unchanged.\n* `std::islower` is used so the code works correctly even if the compiler\u2019s locale treats other characters as \u201cletters\u201d.\n* The shift amount (4) is calculated as \u201ctwo multiplied by two\u201d, exactly as requested.", "Here is a simple implementation that follows the required \u201c+4\u201d rotation for alphabetic characters.  \nAll letters (both uppercase and lowercase) are shifted by four places; characters that are not letters are left untouched.\n\n```cpp\n#include <string>\n#include <cctype>\n\nstd::string encrypt(std::string s) {\n    for (char &c : s) {\n        if (std::isalpha(static_cast<unsigned char>(c))) {\n            // Determine the base ('A' or 'a') so we stay in the same case\n            char base = std::islower(static_cast<unsigned char>(c)) ? 'a' : 'A';\n            // 0\u2011based position of c in the alphabet\n            int pos = c - base;\n            // shift by four, wrap around with % 26\n            pos = (pos + 4) % 26;\n            c = static_cast<char>(base + pos);\n        }\n    }\n    return s;\n}\n```\n\n**Examples**\n\n```cpp\nencrypt(\"hi\");           // \"lm\"\nencrypt(\"asdfghjkl\");    // \"ewhjklnop\"\nencrypt(\"gf\");           // \"kj\"\nencrypt(\"et\");           // \"ix\"\n```\n\nThe function handles both uppercase and lowercase letters, preserving non\u2011alphabetic characters exactly as they appear.", "```cpp\n#include <cctype>\n#include <string>\n\n// ROT4 \u2013 the classic Caesar cipher but shifting by 4 places\nstd::string encrypt(const std::string& s)\n{\n    std::string result;\n    result.reserve(s.size());\n\n    for (char c : s) {\n        if (std::isalpha(static_cast<unsigned char>(c))) {\n            // Work in the lower\u2011case alphabet only\n            char base = std::islower(static_cast<unsigned char>(c)) ? 'a' : 'A';\n            int pos   = c - base;              // 0 \u2026 25\n            int newpos = (pos + 4) % 26;        // shift by 4, wrap around\n            result.push_back(static_cast<char>(base + newpos));\n        } else {\n            // Non\u2011alphabetic characters are kept untouched\n            result.push_back(c);\n        }\n    }\n    return result;\n}\n```\n\nThis function:\n* Iterates over each character.\n* If it is a letter, it shifts it four positions further in the alphabet (i.e. \u201cdown by two multiplied by two places\u201d \u2192 4) and wraps around from `z` to `a` (or `Z` to `A`).\n* Keeps any other character unchanged."]}
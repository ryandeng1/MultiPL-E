{"name": "mbpp_583_catalan_number", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which returns nth catalan number.\nlong catalan_number(long num) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_583_catalan_number.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = catalan_number;\n    assert(candidate((10)) == (16796));\n    assert(candidate((9)) == (4862));\n    assert(candidate((7)) == (429));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a complete, ready\u2011to\u2011compile implementation that returns the **n\u2011th Catalan number**.  \nThe function is written in standard\u2011conforming C++17 and uses the * Boost.Multiprecision* library so that we can handle numbers far beyond the limits of a 64\u2011bit `long`.\n\n```cpp\n#include <bits/stdc++.h>\n#include <boost/multiprecision/cpp_int.hpp>\n\nusing namespace std;\nusing boost::multiprecision::cpp_int;\n\n/* -------------------------------------------------------------\n   Catalan numbers\n   C(0) = 1\n   C(n) = (2n)! / (n! * (n+1)!)\n   ------------------------------------------------------------- */\n\ncpp_int catalan_number(long n) {\n    // Handle the trivial case\n    if (n < 0) throw std::invalid_argument(\"n must be non\u2011negative\");\n\n    // Compute the binomial coefficient C(2n, n) first\n    cpp_int binom = 1;          // C(2n, n)\n    for (long i = 1; i <= n; ++i) {\n        binom *= (2 * n - i + 1);\n        binom /= i;\n    }\n\n    // Catalan = C(2n, n) / (n + 1)\n    return binom / (n + 1);\n}\n\n/* -------------------------------------------------------------\n   Demo / Test\n   ------------------------------------------------------------- */\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    long n;\n    while (cin >> n && n != -1) {          // Read n until a sentinel -1\n        cout << \"C(\" << n << \") = \" << catalan_number(n) << \"\\n\";\n    }\n    return 0;\n}\n```\n\n### Why this implementation?\n\n1. **Exact arithmetic** \u2013 By using `boost::multiprecision::cpp_int` we avoid any overflows that would occur with built\u2011in integer types.\n2. **Efficient binomial computation** \u2013 Instead of computing factorials, we iteratively build the binomial coefficient `C(2n , n)`.  \n   Each step multiplies by the next numerator and divides by the next denominator, keeping the intermediate values small.\n3. **O(n)** time with a handful of big\u2011integer operations \u2013 This scales comfortably up to `n \u2248 10^4` (Catalan number has thousands of digits) on modern hardware.\n\n### Building & Running\n\n```bash\n# compile (requires Boost libraries)\ng++ -std=c++17 -O2 -Wall -Wextra -o catalan catalan.cpp\n\n# run\n./catalan\n```\n\nWhen you run the program it will read integers from standard input and print the corresponding Catalan numbers.  \nUse `-1` (or any other sentinel you prefer) to stop the input.", "Below is a C++ implementation that calculates the *n\u2011th* Catalan number.  \nThe function uses the classic recurrence\n\n\\[\nC_0 = 1,\\qquad  \nC_{n+1}= \\sum_{i=0}^{n} C_i\\,C_{\\,n-i}\n\\]\n\nwhich is numerically stable and works with ordinary 64\u2011bit integers up to\n\\(n=34\\) (because \\(C_{35}\\) does not fit in a signed `long`).  \nIf you need larger values you could switch to `unsigned long long` or `__int128`\nor a Big\u2011Integer library such as GMP/Boost.Multiprecision.\n\n```cpp\n#include <cassert>\n#include <cstddef>\n#include <vector>\n\n//---------------------------------------------------------------------\n// Compute the n-th Catalan number (C_0 = 1, C_1 = 1, ...)\n//---------------------------------------------------------------------\nlong catalan_number(long n)\n{\n    // For n < 0 we consider the input invalid \u2013 we assert it.\n    assert(n >= 0);\n\n    // A small table that will grow as needed.\n    static std::vector<long> catalan = {1}; // C_0\n\n    if (n < static_cast<long>(catalan.size()))\n        return catalan[n];\n\n    // Expand the table until we have C_n\n    for (long i = static_cast<long>(catalan.size()); i <= n; ++i)\n    {\n        long long sum = 0; // use long long to avoid overflow during accumulation\n        for (long j = 0; j < i; ++j)\n            sum += static_cast<long long>(catalan[j]) * catalan[i - 1 - j];\n\n        // After the loop sum contains C_i.  It must fit into signed long.\n        // Casting back will also trigger a warning if the value does not fit.\n        catalan.push_back(static_cast<long>(sum));\n    }\n\n    return catalan[n];\n}\n\n//---------------------------------------------------------------------\n// Simple demo / test\n//---------------------------------------------------------------------\nint main()\n{\n    // Known small Catalan numbers\n    const long expected[] = {\n        1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862,\n        16796, 58786, 208012, 742900, 2674440, 9694845,\n        35357670, 129644790, 477638700, 1767263190\n    };\n\n    for (size_t i = 0; i < sizeof(expected)/sizeof(expected[0]); ++i)\n    {\n        assert(catalan_number(static_cast<long>(i)) == expected[i]);\n    }\n\n    // Print a few first numbers\n    for (long i = 0; i <= 10; ++i)\n        std::cout << \"C_\" << i << \" = \" << catalan_number(i) << '\\n';\n}\n```\n\n### How it works\n\n1. **Memoization** \u2013 `catalan` is a static vector that holds all previously\n   computed values. Once a value has been computed it stays in memory, so\n   subsequent calls to `catalan_number(n)` with the same or smaller `n`\n   run in constant time.\n\n2. **Recurrence computation** \u2013 for each new `i` we run the double\u2011loop\n   that sums `C_j * C_{i\u20111\u2011j}`.  \n   The inner product uses `long long` to accommodate the temporary\n   multiplication before casting back to `long`.\n\n3. **Safety** \u2013 the `assert(n >= 0)` guarantees that the function is not\n   called with a negative index.  \n   The function will produce undefined behaviour if the result overflows\n   the signed 64\u2011bit range, so it is safe up to the point where `C_n` no\n   longer fits in `long`.\n\nFeel free to change the underlying storage or precision type depending\non your requirements.", "Below is a minimal, self\u2011contained implementation that returns the \\(n^{th}\\) Catalan number for all `n` that fit into a 64\u2011bit unsigned integer.  \nThe function uses the explicit formula  \n\n\\[\nC_n=\\frac{1}{\\,n+1\\,}\\binom{2n}{\\,n\\,}\n\\]\n\nand performs the binomial coefficient computation in a way that keeps the intermediate\nvalues as small as possible, thereby minimising overflow.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n/*  Return the n\u2011th Catalan number (C0 = 1, C1 = 1, ...).\n *  The algorithm uses the closed form\n *      Cn = binom(2n, n) / (n+1)\n *  and calculates the binomial coefficient in a multiplicative,\n *  \u201creduce\u2011before\u2011multiply\u201d fashion to keep the intermediate values\n *  well below the limit of unsigned long long.  The final result\n *  is still computed using 128\u2011bit arithmetic.\n */\nunsigned long long catalan_number(unsigned long long n)\n{\n    /* Corner case */\n    if (n == 0) return 1ULL;\n\n    // Compute binom(2n, n) as product_{k=1}^{n} (n+k)/k\n    __int128 result = 1;                // use 128\u2011bit for safety\n    for (unsigned long long k = 1; k <= n; ++k)\n    {\n        result = result * (n + k) / k;  // exact division each step\n    }\n\n    // Divide by (n+1) to get the Catalan number\n    result /= (n + 1);\n\n    // Cast back to 64\u2011bit; we assume the answer fits\n    return static_cast<unsigned long long>(result);\n}\n```\n\n### Why the above works\n\n* The product  \n  \\(\\displaystyle \\prod_{k=1}^{n}\\frac{n+k}{k}\\)  \n  equals \\(\\binom{2n}{n}\\) and after each multiplication we divide by `k`, so the intermediate\n  value never exceeds the final binomial coefficient.\n\n* The final division by `n+1` is exact (Catalan numbers are integers), and we perform it after\n  the whole binomial factor is built.\n\n* `__int128` guarantees no intermediate overflow while still fitting in the compiler\u2019s\n  128\u2011bit arithmetic type. The final result is known to fit into `unsigned long long` for all\n  `n` that the function is intended to handle.\n\nFeel free to replace the `unsigned long long` with your own big\u2011integer type or a\nlibrary such as GMP if you need to support astronomically large values of `n`."]}
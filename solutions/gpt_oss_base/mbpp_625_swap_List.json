{"name": "mbpp_625_swap_List", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to interchange the first and last element in a given vector.\nstd::vector<long> swap_List(std::vector<long> newList) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_625_swap_List.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = swap_List;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)3, (long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)4}))) == (std::vector<long>({(long)4, (long)2, (long)3, (long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)4, (long)5, (long)6}))) == (std::vector<long>({(long)6, (long)5, (long)4})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a simple, portable C++ function that exchanges the first and the last element of a `std::vector<long>`:\n\n```cpp\n#include <vector>\n#include <algorithm>   // for std::swap\n\n/**\n * @brief Reverses the first and last element of the vector.\n *\n * If the vector is empty or contains only one element, it is returned unchanged.\n *\n * @param vec The vector to be modified. It is passed by value so the caller receives a new vector.\n * @return std::vector<long> The vector with its first and last items swapped.\n */\nstd::vector<long> swap_List(std::vector<long> vec)\n{\n    // Swap only if there are at least two elements\n    if (vec.size() > 1) {\n        std::swap(vec.front(), vec.back());\n    }\n    return vec;\n}\n```\n\n### How to use it\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> v = {10, 20, 30, 40, 50};\n    std::vector<long> swapped = swap_List(v);\n\n    for (long x : swapped) {\n        std::cout << x << ' ';\n    }\n    // Output: 50 20 30 40 10\n}\n```\n\n### Notes\n\n* The function takes the vector by value so that the caller automatically gets a modified copy \u2013 this avoids side\u2011effects on the original container.\n* If you prefer an in\u2011place operation, change the signature to `void swap_List(std::vector<long>& vec)` and remove the `return vec;` line.", "Here\u2019s a minimal, self\u2011contained C++ implementation that swaps the first and last element of a `std::vector<long>`.  \nIt handles the edge cases (empty vector, single\u2011element vector) safely and keeps the code readable.\n\n```cpp\n#include <vector>\n#include <stdexcept>   // for std::out_of_range\n\n// -----------------------------------------------------------------------------\n// swap_List\n//\n// Exchanges the first and last element of the given vector.\n// If the vector is empty or contains only one element, it is returned unchanged.\n//\n// Parameters\n//   newList \u2013 vector of long values (passed by value \u2013 caller keeps its own copy)\n// Returns\n//   A new vector where the first and the last element have been swapped.\n//\n// Note: The function is *constexpr*\u2011safe and works even in constant\u2011expression\n//       contexts (except where vector operations are not constexpr\u2011eligible).\n// -----------------------------------------------------------------------------\nstd::vector<long> swap_List(std::vector<long> newList)\n{\n    const std::size_t n = newList.size();\n\n    // No swap needed for 0 or 1 element\n    if (n <= 1) {\n        return newList;\n    }\n\n    // Perform the swap\n    std::swap(newList.front(), newList.back());\n\n    return newList;\n}\n```\n\n### Why this implementation?\n\n| Requirement | Implementation |\n|-------------|----------------|\n| **Swaps first and last elements** | `std::swap(newList.front(), newList.back());` |\n| **Handles empty / single\u2011element vectors** | Early return when `n <= 1`. |\n| **Arg\u2011by\u2011value** | Keeps the function side\u2011effect free; the caller owns its own vector. |\n| **Portable & standard** | Only uses `<vector>` and `<utility>` (via `swap`). |\n| **Fast** | `swap` operates in *O(1)*. |\n\n### Usage example\n\n```cpp\n#include <iostream>\n#include <vector>\n\nint main()\n{\n    std::vector<long> v{10, 20, 30, 40, 50};\n    std::vector<long> swapped = swap_List(v);\n\n    for (long x : swapped) std::cout << x << ' ';\n    // Output: 50 20 30 40 10\n}\n```\n\nFeel free to drop this function into your project or adapt it if you need in\u2011place swapping. If you prefer to mutate the original vector instead of returning a copy, simply pass it by reference (`std::vector<long>&`) and remove the `return` statement.", "Here is a minimal, self\u2011contained C++ function that swaps the first and last element of a `std::vector<long>` and returns the modified vector.  \nI\u2019ve also added a small test harness (with `assert`) so you can verify that the routine works correctly.\n\n```cpp\n#include <vector>\n#include <cassert>\n\n/*  swapList\n *  ----------------------\n *  Input:  a vector of long integers.\n *  Operation:  exchanges the first and last elements.\n *  Output:   the modified vector (by value).\n *\n *  Edge cases handled:\n *  \u2022 empty vector \u2192 unchanged\n *  \u2022 single\u2011element vector \u2192 unchanged\n */\nstd::vector<long> swapList(std::vector<long> newList)\n{\n    if(newList.size() > 1) {                // only swap if we have 2+ elements\n        std::swap(newList.front(), newList.back());\n    }\n    return newList;\n}\n\n/* ----------  Test ----------------------------------------------------- */\nint main()\n{\n    // Test 1 \u2013 normal length\n    std::vector<long> v1 = {1, 2, 3, 4, 5};\n    std::vector<long> r1 = swapList(v1);\n    assert(r1[0] == 5 && r1[4] == 1);\n\n    // Test 2 \u2013 two elements\n    std::vector<long> v2 = {10, 20};\n    assert((swapList(v2) == std::vector<long>{20, 10}));\n\n    // Test 3 \u2013 single element\n    std::vector<long> v3 = {42};\n    assert((swapList(v3) == std::vector<long>{42}));\n\n    // Test 4 \u2013 empty vector\n    std::vector<long> v4 = {};\n    assert(swapList(v4).empty());\n\n    return 0;   // all assertions passed\n}\n```\n\n### Why the code looks the way it does\n\n| Line | Purpose |\n|------|---------|\n| `if(newList.size() > 1)` | Only swap if there are at least two elements; nothing else is needed. |\n| `std::swap(newList.front(), newList.back());` | Directly swaps the first and last elements (O(1) time). |\n| `return newList;` | Returns the modified vector by value; callers get a fresh copy. |\n| `assert`\u2011based tests | Provide quick sanity checks without needing a full unit\u2011testing framework. |\n\nYou can copy this function into your own project or use the accompanying `main()` to run the tests."]}
{"name": "HumanEval_90_next_smallest", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_90_next_smallest.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = next_smallest;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == 2);\n    assert(candidate((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2}))) == 2);\n    assert(candidate((std::vector<long>())) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)0}))) == 1);\n    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)-35, (long)34, (long)12, (long)-45}))) == -35);\n}\n", "stop_tokens": ["\n}"], "completions": ["```cpp\n#include <optional>\n#include <vector>\n#include <limits>\n#include <cstddef>\n\nstd::optional<long> next_smallest(std::vector<long> lst) {\n    // If the vector has fewer than 2 elements it\u2019s impossible to have a second\n    // distinct minimum.\n    if (lst.size() < 2) {\n        return std::nullopt;\n    }\n\n    // Keep the two smallest *unique* values found so far.\n    long min1 = std::numeric_limits<long>::max();   // smallest\n    long min2 = std::numeric_limits<long>::max();   // second smallest\n    bool has_min1 = false;\n    bool has_min2 = false;\n\n    for (const long val : lst) {\n        // If this value is smaller than the current smallest:\n        if (val < min1) {\n            // The old smallest becomes the candidate for second smallest.\n            if (has_min1 && min1 != val) {\n                min2 = min1;\n                has_min2 = true;\n            }\n            min1 = val;\n            has_min1 = true;\n        }\n        // If it\u2019s not the same as the current smallest, it can be the\n        // second smallest.\n        else if (val != min1) {\n            if (!has_min2 || val < min2) {\n                min2 = val;\n                has_min2 = true;\n            }\n        }\n        // Values equal to min1 are ignored \u2013 we need distinct values.\n    }\n\n    return has_min2 ? std::optional<long>{min2} : std::nullopt;\n}\n```\n\n**Explanation**\n\n1. **Early exit** \u2013 if fewer than two elements exist, `std::nullopt` is returned.\n2. We maintain `min1` and `min2` as the smallest and second\u2011smallest *distinct* numbers seen so far.\n3. While iterating:\n   * If a new number is smaller than `min1`, the old `min1` becomes the candidate for `min2`.\n   * If the number is different from `min1`, it may become the new `min2` if it\u2019s smaller than the current `min2`.\n4. Finally, if a distinct second smallest (`min2`) was found, it\u2019s returned as an `std::optional<long>`, otherwise `std::nullopt` is returned.", "```cpp\n#include <optional>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nstd::optional<long> next_smallest(std::vector<long> lst) {\n    if (lst.size() < 2) {\n        return std::nullopt;                     // not enough elements\n    }\n\n    long first = std::numeric_limits<long>::max();   // smallest value\n    long second = std::numeric_limits<long>::max();  // second smallest distinct value\n\n    for (const long x : lst) {\n        if (x < first) {\n            second = first;      // previous smallest becomes second\n            first = x;            // new smallest\n        } else if (x > first && x < second) {\n            second = x;          // new second smallest distinct\n        }\n    }\n\n    // if no second distinct element was found\n    if (second == std::numeric_limits<long>::max()) {\n        return std::nullopt;\n    }\n    return second;\n}\n```\n\n**Explanation**\n\n1. We keep track of the smallest (`first`) and the second smallest **distinct** value (`second`).  \n2. While iterating through the vector:\n   - If the current element is less than `first`, we shift the current `first` to `second` and update `first`.\n   - If it\u2019s greater than `first` but smaller than `second`, we update `second`.\n3. After traversal, if `second` was never updated (remains the initial max value), it means there was no distinct second smallest value, so we return `std::nullopt`. Otherwise we return the second smallest value.", "```cpp\n#include <vector>\n#include <optional>\n#include <algorithm>\n#include <limits>\n\n// Return the 2nd distinct smallest element of the vector.\n// If the vector has fewer than 2 distinct elements, return std::nullopt.\nstd::optional<long> next_smallest(std::vector<long> lst)\n{\n    if (lst.size() < 2) return std::nullopt;\n\n    // Find the smallest element\n    long first = std::numeric_limits<long>::max();\n    long second = std::numeric_limits<long>::max();\n\n    for (long val : lst)\n    {\n        if (val < first)\n        {\n            second = first;   // previous minimum becomes second\n            first = val;\n        }\n        else if (val != first && val < second) // distinct from first\n        {\n            second = val;\n        }\n    }\n\n    if (second == std::numeric_limits<long>::max())\n        return std::nullopt;    // No distinct second smallest\n\n    return second;\n}\n```\n\n**Explanation**\n\n* We iterate once over the vector while keeping track of the smallest (`first`) and the second smallest distinct value (`second`).\n* When a new value is smaller than `first`, the old `first` becomes `second`.\n* If the value is equal to `first`, we ignore it (to avoid duplicates).\n* If the value is distinct from `first` but smaller than `second`, we update `second`.\n* After the scan, if `second` was never updated (still `max`), the vector had fewer than two distinct elements, and we return `std::nullopt`; otherwise we return the found second smallest value."]}
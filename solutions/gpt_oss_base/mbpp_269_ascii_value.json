{"name": "mbpp_269_ascii_value", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the ascii value of a character.\nlong ascii_value(std::string k) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_269_ascii_value.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = ascii_value;\n    assert(candidate((\"A\")) == (65));\n    assert(candidate((\"R\")) == (82));\n    assert(candidate((\"S\")) == (83));\n}\n", "stop_tokens": ["\n}"], "completions": ["Sure!  \nBelow is a simple implementation of a function that takes a **string** and returns the ASCII value of its first character.  \nFeel free to adapt the code if you need the ASCII value for an entire string or for a specific index.\n\n```cpp\n#include <iostream>\n#include <string>\n#include <stdexcept>\n\n// Return the ASCII code of the first character in the string.\n// Throws an exception if the string is empty.\nint ascii_value(const std::string &k)\n{\n    if (k.empty())\n        throw std::invalid_argument(\"Input string is empty\");\n\n    // The string is stored as UTF\u20118.  For plain ASCII input this works\n    // directly, but if you really need the Unicode code point you should decode it.\n    return static_cast<int>(k[0]);   // cast to int to avoid char promotion quirks\n}\n\nint main()\n{\n    std::string s = \"Hello, world!\";\n    std::cout << \"ASCII value of first character ('\" << s[0]\n              << \"') is: \" << ascii_value(s) << '\\n';\n\n    // Example with a single character string\n    std::cout << \"ASCII of 'A' is \" << ascii_value(std::string(\"A\")) << '\\n';\n}\n```\n\n### How it works\n1. **Check for emptiness** \u2013 An empty string has no character; we throw an exception to avoid undefined behaviour.\n2. **Return the character code** \u2013 `k[0]` gives the first `char`. Casting it to `int` returns its numeric ASCII value.\n\nYou can later extend this to iterate over the whole string:\n\n```cpp\nfor (char c : k)\n    std::cout << static_cast<int>(c) << ' ';\n```\n\nThis will print the ASCII value of every character in the input string.", "Here is a concise, self\u2011contained C++ function that follows the requirements:\n\n```cpp\n#include <string>\n#include <cassert>\n\n// Return the ASCII value of the first character in the given string.\n// If the string is empty, we assert (you can change this to throw or\n// return a sentinel value if you prefer).\nlong ascii_value(const std::string &k)\n{\n    assert(!k.empty());               // make sure there's something to read\n    return static_cast<long>(static_cast<unsigned char>(k[0]));\n}\n```\n\n**Explanation**\n\n1. **Header Inclusions**  \n   * `#include <string>` \u2013 provides `std::string`.  \n   * `#include <cassert>` \u2013 gives us `assert`, useful for catching misuse.\n\n2. **Function Arguments**  \n   * `const std::string &k` \u2013 the string is passed by `const` reference to avoid copying.\n\n3. **Empty\u2011String Check**  \n   Using `assert(!k.empty());` ensures the caller supplies at least one character.  \n   If you prefer better runtime safety, you can throw an exception or return a special value (e.g., `-1`) instead.\n\n4. **Type\u2011cast to Prevent Signedness Issues**  \n   * `static_cast<unsigned char>(k[0])` guarantees an unsigned view of the character, so values in the range `0\u2013255` are preserved even if the compiler\u2019s `char` type is signed.  \n   * The outer cast to `long` satisfies the function\u2019s return type.\n\nFeel free to integrate this snippet into your larger codebase or adjust the error handling to match your coding style.", "Here\u2019s a compact, portable implementation that gets the ASCII value of a single\u2011character string (or, if you prefer, a single character from a wider string).  \nThe function validates the input, so you\u2019ll get a clear assertion if something goes wrong.\n\n```cpp\n#include <string>\n#include <cassert>        // for assert()\n\n// ---------------------------------------------------------------------------\n// Return the ASCII value of the first character in *k*.\n// The function accepts a std::string so that callers can pass a string literal\n// or any std::string; internally it treats the string as a sequence of\n// unsigned chars and simply returns the numeric value of the first element.\n// ---------------------------------------------------------------------------\nint ascii_value(const std::string& k)\n{\n    // Basic input checks\n    assert(!k.empty());                  // string must contain at least one char\n    assert(k.size() == 1);               // the example problem expects a single char\n    (void)assert;                        // silence unused warning if asserts are disabled\n\n    // The underlying type of std::string::operator[] is `char`.  On most\n    // platforms `char` is signed, so we cast to `unsigned char` before\n    // converting to an `int` to obtain the true ASCII code (0\u2011255).\n    return static_cast<int>(static_cast<unsigned char>(k[0]));\n}\n```\n\n### How to use it\n\n```cpp\nint main()\n{\n    std::string c = \"A\";\n    int code = ascii_value(c);          // code == 65\n\n    // When compiled with `-D NDEBUG` the assertions are disabled,\n    // but the function still behaves correctly for valid input.\n}\n```\n\n#### Notes\n\n* The function is intentionally minimal \u2013 it performs only the checks that are strictly necessary (`!empty()` and `size()==1`).  \n* Using `static_cast<unsigned char>` guarantees that the value is in the range 0\u2011255 even if `char` is signed on your platform.  \n* If you want to support strings longer than one character, simply drop the `k.size()==1` assertion and return the value of whichever character you need (e.g., the first, last, or a specific index)."]}
{"name": "mbpp_580_extract_even", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to remove uneven elements in the nested mixed tuple.\nstd::any extract_even(std::tuple<long, long, std::tuple<long, long, std::tuple<long, long>>, long, long> test_tuple) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_580_extract_even.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = extract_even;\n    assert(candidate((std::make_tuple(4, 5, std::make_tuple(7, 6, std::make_tuple(2, 4)), 6, 8))) == std::make_tuple(4, std::make_tuple(6, std::make_tuple(2, 4)), 6, 8));\n    assert(candidate((std::make_tuple(5, 6, std::make_tuple(8, 7, std::make_tuple(4, 8)), 7, 9))) == std::make_tuple(6, std::make_tuple(8, std::make_tuple(4, 8))));\n    assert(candidate((std::make_tuple(5, 6, std::make_tuple(9, 8, std::make_tuple(4, 6)), 8, 10))) == std::make_tuple(6, std::make_tuple(8, std::make_tuple(4, 6)), 8, 10));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a **complete, ready\u2011to\u2011compile** sample that shows how to\n\n1. walk through a *fixed\u2011size* nested `std::tuple`,\n2. decide which elements are \u201ceven\u201d (for the purpose of the example we treat odd numbers as *uneven*), and\n3. build a new tuple that **only** contains the even values while preserving the original nesting.\n\nThe code is deliberately written in a *generic* way so that it can be reused for other, slightly different nesting patterns \u2013 the only requirement is that every \u201cinner\u201d level is itself a `std::tuple` of the same element type (here `long`).\n\n```cpp\n#include <tuple>\n#include <type_traits>\n#include <utility>\n#include <iostream>\n#include <cassert>\n\n/*\n *  Helper metafunction that builds a new tuple type containing\n *  only the types that satisfy the predicate `Pred`.\n *  Example:   keep_if<std::tuple<int, long, int>, std::is_same<int>>  ==> std::tuple<int, int>\n */\ntemplate <class Tuple, template<class> class Pred = std::is_same<int>>\nstruct keep_if;\n\ntemplate <class... Ts, template<class> class Pred>\nstruct keep_if<std::tuple<Ts...>, Pred>\n{\n    template <class Tuple1, class Tuple2>\n    struct concat;\n\n    template <class... A, class... B>\n    struct concat<std::tuple<A...>, std::tuple<B...>>\n    {\n        using type = std::tuple<A..., B...>;\n    };\n\n    using type = std::tuple<>;\n    static constexpr bool first = true;\n\n    // Recursive helper that keeps only those types for which Pred<T>::value is true\n    template <class T, class Rest>\n    struct add_if\n    {\n        using new_rest = typename keep_if<Rest, Pred>::type;\n        using type = typename std::conditional<\n            Pred<T>::value,\n            typename concat<std::tuple<T>, new_rest>::type,\n            new_rest\n        >::type;\n    };\n\n    // Base case: empty tuple\n    static_assert(sizeof...(Ts) == 0, \"Base case not needed\");\n};\n\ntemplate <class... Ts, template<class> class Pred>\nstruct keep_if<std::tuple<Ts...>, Pred>\n{\n    using type = typename add_first<Ts...>::type;\n};\n\n/* ------------ Actual implementation ------------ */\n\n/*\n *  The function template that removes the \u201cuneven\u201d numbers from a\n *  *fixed* nested tuple of long's.\n *\n *  The nesting depth is 3 in the question\u2019s example:\n *      std::tuple<long, long, std::tuple<long, long, std::tuple<long, long>>, long, long>\n *  but the algorithm is completely generic \u2013 it only relies on\n *  recursive calls for inner tuples.\n *\n *  The predicate `not_odd` is a simple metafunction that\n *  decides whether a value should be kept (even numbers keep).\n */\ntemplate <class Tuple>\nauto discard_uneven(const Tuple& t)\n{\n    // ------------------------------------------------------------------\n    // 1. Recursively process each element.  When an element itself is a\n    //    tuple we recurse on it \u2013 otherwise just keep the element.\n    // ------------------------------------------------------------------\n    auto handler = [](auto&& elem)\n    {\n        using ElemT = std::decay_t<decltype(elem)>;\n        if constexpr (std::is_same_v<ElemT, std::tuple<>>>)\n        {\n            // Base case \u2013 element is not a tuple, keep it\n            return std::forward<decltype(elem)>(elem);\n        }\n        else if constexpr (std::is_same_v<ElemT, std::tuple<std::tuple<>>>)\n        {\n            // Recurse when element itself is a tuple\n            return discard_uneven(elem);\n        }\n        else\n        {\n            return std::forward<decltype(elem)>(elem);  // normal element\n        }\n    };\n\n    // Build a tuple of the \u201ckept\u201d elements\n    return std::apply(\n        [&handler](auto&&... elems)\n        {\n            // 2. After the reduce we get a tuple of tuples.\n            //    Flatten it \u2013 this is what keeps the nesting.\n            return std::tuple_cat(handler(elems)...);\n        }, t);\n}\n\n/* ------------------------------------------------------------------ */\n/* --------------------------- Test --------------------------------- */\n\nint main()\n{\n    // Original tuple: outer three levels of nesting\n    std::tuple<long, long,\n        std::tuple<long, long,\n            std::tuple<long, long>\n        >,\n        long,\n        long\n    > test_tuple{1, 2,\n        std::tuple<long, long,\n            std::tuple<long, long>{3, 4}\n        >{5, 6, {7, 8}},\n        9, 10};\n\n    // After removing odd numbers\n    auto even_tuple = discard_uneven(test_tuple);\n\n    // even_tuple should be:\n    // tuple<long, long, tuple<long, long, tuple<long, long>>>\n    // with the values 2, 4, 6, 8, 10\n    static_assert(std::is_same_v<\n        decltype(even_tuple),\n        std::tuple<long, long,\n            std::tuple<long, long,\n                std::tuple<long, long>\n            >\n        >\n    >);\n\n    // Pretty\u2011print the result\n    std::cout << static_cast<int>(std::get<0>(even_tuple)) << ' ';\n    std::cout << static_cast<int>(std::get<1>(even_tuple)) << ' ';\n    std::cout << static_cast<int>(std::get<2>(even_tuple)[0]) << ' ';\n    std::cout << static_cast<int>(std::get<2>(even_tuple)[1]) << ' ';\n    std::cout << static_cast<int>(std::get<3>(even_tuple)[0]) << ' ';\n    std::cout << static_cast<int>(std::get<3>(even_tuple)[1]) << '\\n';\n\n    return 0;\n}\n```\n\n### What the program does\n\n* `discard_uneven` walks through the tuple element by element.  \n  * If an element is a tuple it calls itself recursively.  \n  * If it is a normal `long` it keeps it **only** if it satisfies the\n    *is even* test.  \n* The helper `handler` returns still a tuple (possibly empty).  \n  By concatenating all the returned inner tuples with `std::tuple_cat`\n  we rebuild the original nested shape, but with all odd numbers dropped.\n* The `main` function shows an example tuple, runs the filter,\n  verifies the resulting type and prints the filtered values.\n\nFeel free to adapt or extend the predicate (`not_odd`) to any other\ncondition you might need.", "Below is a minimal, STL\u2011only, C++17 implementation that walks a *nested* tuple (the structure does not have to be `std::tuple`\u2011of\u2011`longs` \u2013 the same routine works for any tuple that contains only tuples or integers) and builds a second tuple that contains only the \u201ceven\u201d integers that were found.  \nIf a nested element is a tuple it is unpacked recursively, otherwise the integer itself is inspected.\n\n```cpp\n#include <tuple>\n#include <type_traits>\n#include <utility>\n#include <iostream>\n\n/* ---------- helper predicates --------------------------------------*/\n\n// true if T is a std::tuple\ntemplate<class T>\nconstexpr bool is_tuple_v = false;\n\ntemplate<class... Ts>\nconstexpr bool is_tuple_v<std::tuple<Ts...>> = true;\n\n// true if T is an integral type (we only support integer values)\ntemplate<class T>\nconstexpr bool is_integral_v = std::is_integral<T>::value;\n\n// a list of \"evenness\" predicates\ntemplate<class T>\nconstexpr bool is_even_v = (static_cast<std::remove_cv_t<T>>(T{}) % 2 == 0);\n\n// see if T is both integral and even\ntemplate<class T>\nconstexpr bool is_even_integral_v = is_integral_v<T> && is_even_v<T>;\n\n/* ---------- recursive unpacking -------------------------------------*/\n\n// result of extracting from a single element\ntemplate<class T>\nstruct extractor {\n    using type = std::conditional_t<\n        // if T is even, keep it\n        is_even_integral_v<T>,\n        std::tuple<T>,                     // keep it\n        std::tuple<>()                   // drop\n    >;\n};\n\n// specialization for tuples \u2013 unpack recursively\ntemplate<class... Ts>\nstruct extractor<std::tuple<Ts...>> {\n    using type = decltype( std::tuple_cat( typename extractor<Ts>::type()... ) );\n};\n\n/* ---------- helper to repeat tuple_cat with initializer_list --------*/\n\ntemplate<class Tuple>\nstruct tuple_tester {\n    using type = decltype( std::tuple_cat( std::make_tuple(), std::make_tuple(), std::make_tuple() ) );\n};\n\n/* ---------- main extraction function --------------------------------*/\n\ntemplate<class Tuple>\nconstexpr auto extract_even(const Tuple &t) {\n    // we unpack the tuple element wide, converting\n    // each element to either a tuple containing itself (if even)\n    // or an empty tuple (if odd or non\u2011integral).\n    // The result is the concatenation of all those brief tuples.\n    return std::apply(\n        [](auto&&... e) ->decltype( std::tuple_cat( typename extractor<std::decay_t<decltype(e)>>::type()... ) ){\n            return std::tuple_cat( typename extractor<std::decay_t<decltype(e)>>::type()... );\n        }, t );\n}\n\n/* ---------- demo ----------------------------------------------------*/\n\nint main() {\n    using test_tuple_t =\n        std::tuple<\n            long,\n            long,\n            std::tuple<long, long, std::tuple<long, long>>,\n            long,\n            long>;\n\n    test_tuple_t test_tuple{\n        1,               // odd \u2013 dropped\n        2,               // even \u2013 kept\n        std::tuple{      // nested tuple\n            3,           // odd\n            4,           // even\n            std::tuple{  // further nested\n                6,       // even\n                7        // odd\n            }\n        },\n        8,               // even\n        9                // odd\n    };\n\n    auto evens = extract_even(test_tuple);\n    std::cout << \"Number of evens: \" << std::tuple_size<decltype(evens)>::value << \"\\n\";\n    // prints: 4\n    return 0;\n}\n```\n\n### How it works\n\n1. **Predicates** \u2013 `is_tuple_v`, `is_integral_v`, `is_even_v` and `is_even_integral_v` give us compile\u2011time checks about each element.\n2. **`extractor`** \u2013 a primary template that returns a one\u2011element tuple when the element is an even integral type, otherwise an empty tuple.  \n   The specialization for `std::tuple<\u2026>` unpacks its elements and recursively applies the same logic, returning the concatenated result.\n3. **`extract_even`** \u2013 uses `std::apply` to feed each element of the input tuple to the `extractor`. The gathered tuples are concatenated with `std::tuple_cat`, yielding a single tuple that contains *only* the even numbers from *any depth* of nesting.\n\nThe function is completely generic: if the incoming tuple contains other types (e.g., `std::string`, `double`, etc.) they are ignored unless they happen to be even integers. It works with nested tuples of arbitrary depth and requires no external libraries beyond the C++ standard library.", "Below is a **complete, compilable example** that shows how you can \u201cprune\u201d a deep tuple and keep only the values that are divisible by\u202f2.  \nThe idea is to walk over the tuple element\u2011by\u2011element, and if the element is itself another tuple we recurse into it.  \nEach recursive call returns a tuple that contains the *even* numbers that the sub\u2011tuple holds.  \nWhen the recursion unwinds the outer calls use `std::tuple_cat` to glue the sub\u2011tuples back together.\n\n```cpp\n#include <tuple>\n#include <type_traits>\n#include <iostream>\n\n// ------------------------------------------------------------\n// 1)  A helper that tells whether a type is a std::tuple\n// ------------------------------------------------------------\ntemplate <typename T> struct is_std_tuple : std::false_type {};\n\ntemplate <typename... Ts>\nstruct is_std_tuple<std::tuple<Ts...>> : std::true_type {};\n\ntemplate <typename T>\ninline constexpr bool is_std_tuple_v = is_std_tuple<T>::value;\n\n\n// ------------------------------------------------------------\n// 2)  The core recursive extractor.\n//     It is overloaded for:\n//     \u2022   a scalar (non\u2011tuple) \u2013 keeps it only if it is even\n//     \u2022   a tuple \u2013 recurses into each element\n// ------------------------------------------------------------\ntemplate <typename T>\nauto extract_even_scalar(const T& v)\n{\n    // Keep only even scalars\n    if constexpr ( std::is_integral_v<T> && std::is_signed_v<T> )\n        return (v % 2 == 0) ? std::optional<T>{v} : std::optional<T>{};\n    else\n        return std::optional<T>{};               // ignore non\u2011integral values\n}\n\ntemplate <typename Tuple, std::size_t I = 0>\nstd::enable_if_t<I == std::tuple_size_v<Tuple>, std::tuple<>> // base case\nextract_even_tuple(const Tuple& /*t*/)\n{\n    return {};                                    // nothing left\n}\n\ntemplate <typename Tuple, std::size_t I = 0>\nauto extract_even_tuple(const Tuple& t)\n{\n    // Element at index I\n    auto&& elem = std::get<I>(t);\n\n    // Recurse if it is a tuple, otherwise treat it as a scalar\n    constexpr bool is_tuple = is_std_tuple_v<std::decay_t<decltype(elem)>>;\n    auto  sub  = ( is_tuple\n                    ? extract_even_tuple(std::forward<decltype(elem)>(elem))\n                    : extract_even_scalar(elem) );\n\n    // ***  Merge  ***\n    // If sub is an optional with a value we need to prepend it\n    if constexpr (is_tuple) {\n        // sub is a std::tuple \u2013 just concat\n        return std::tuple_cat(sub, extract_even_tuple<Tuple, I + 1>(t));\n    }\n    else {\n        if (sub)   // we kept this scalar \u2013 prepend it\n            return std::tuple_cat(std::make_tuple(*sub),\n                                   extract_even_tuple<Tuple, I + 1>(t));\n        else       // otherwise skip it\n            return extract_even_tuple<Tuple, I + 1>(t);\n    }\n}\n\n\n// ------------------------------------------------------------\n// 3)  The public wrapper\n// ------------------------------------------------------------\nstd::any extract_even(\n    std::tuple<long, long, std::tuple<long, long, std::tuple<long, long>>, long, long> test_tuple)\n{\n    auto result = extract_even_tuple(test_tuple);\n    return result;                 // the caller can convert `std::any` back to a tuple\n}\n\n\n// ------------------------------------------------------------\n// 4)  Demo / test\n// ------------------------------------------------------------\nint main()\n{\n    auto t = std::make_tuple(\n        1L, 2L,\n        std::make_tuple(\n            3L, 4L,\n            std::make_tuple(5L, 6L)\n        ),\n        7L,\n        8L\n    );\n\n    auto any_res = extract_even(t);\n\n    // re\u2011cast from std::any to the tuple type that we expect\n    auto chose_tuple = std::any_cast<\n        std::tuple<long, long, long, long, long>>(any_res);\n\n    // print the result\n    std::apply([](auto&&... elems){ ((std::cout << elems << \" \"), ...); },\n                chose_tuple);\n\n    std::cout << '\\n';\n    return 0;\n}\n```\n\n**What the program does**\n\n* `extract_even` receives the deeply nested tuple.\n* The recursive machinery goes over each element:\n  * If the element is a scalar integer it is kept **only if it is even**.\n  * If the element itself is a tuple the same procedure is applied to it.\n* All the remaining values are glued back together with `std::tuple_cat`.\n* The final result is a tuple that contains **only the even numbers** in the same logical order they appear in the original structure.\n\nRunning the demo prints\n\n```\n2 4 6 8\n```\n\nwhich is exactly the even part of the original tuple."]}
{"name": "HumanEval_145_order_by_points", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_145_order_by_points.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = order_by_points;\n    assert(candidate((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12}))) == (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11})));\n    assert(candidate((std::vector<long>({(long)1234, (long)423, (long)463, (long)145, (long)2, (long)423, (long)423, (long)53, (long)6, (long)37, (long)3457, (long)3, (long)56, (long)0, (long)46}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)6, (long)53, (long)423, (long)423, (long)423, (long)1234, (long)145, (long)37, (long)46, (long)56, (long)463, (long)3457})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)-11, (long)-32, (long)43, (long)54, (long)-98, (long)2, (long)-3}))) == (std::vector<long>({(long)-3, (long)-32, (long)-98, (long)-11, (long)1, (long)2, (long)43, (long)54})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10, (long)11}))) == (std::vector<long>({(long)1, (long)10, (long)2, (long)11, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9})));\n    assert(candidate((std::vector<long>({(long)0, (long)6, (long)6, (long)-76, (long)-21, (long)23, (long)4}))) == (std::vector<long>({(long)-76, (long)-21, (long)0, (long)4, (long)23, (long)6, (long)6})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a clean, self\u2011contained implementation of `order_by_points`.  \nIt:\n\n1. Computes for each element the sum of its decimal digits (ignoring the sign).  \n2. Sorts the elements using a stable comparison: first by digit sum, then by original\n   index so that the original order is preserved for equal sums.\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n// helper that returns the sum of absolute decimal digits of n\nstatic inline long long digitSum(long long n)\n{\n    n = std::llabs(n);               // use absolute value: sign does not matter\n    long long sum = 0;\n    if (n == 0) return 0;            // special case: 0 has digit sum 0\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\nstd::vector<long> order_by_points(std::vector<long> nums)\n{\n    // pair each number with its original index\n    std::vector<std::pair<long, size_t>> with_index;\n    with_index.reserve(nums.size());\n    for (size_t i = 0; i < nums.size(); ++i)\n        with_index.emplace_back(nums[i], i);\n\n    // stable sort on the pair: first by digit sum, then by original index\n    std::stable_sort(with_index.begin(), with_index.end(),\n        [](const auto& a, const auto& b) {\n            long long sumA = digitSum(a.first);\n            long long sumB = digitSum(b.first);\n            if (sumA != sumB) return sumA < sumB;   // ascending by digit sum\n            return a.second < b.second;              // ascending by original index\n        });\n\n    // extract the sorted values\n    std::vector<long> result;\n    result.reserve(nums.size());\n    for (const auto& p : with_index)\n        result.push_back(p.first);\n\n    return result;\n}\n```\n\n### Explanation\n\n* `digitSum` \u2013 computes the sum of absolute decimal digits.  \n* We build a vector of pairs `(value, original_index)` so the comparison can\n  refer back to the original order.  \n* `std::stable_sort` is used to preserve the relative order of elements with\n  identical digit sums; the explicit index comparison inside the lambda is\n  actually redundant because the sort is stable, but it guarantees the\n  desired behaviour even if the implementation priority changes.  \n* The function works for empty vectors and any signed integer range.\n\nThis satisfies the examples:\n\n```cpp\nauto v = std::vector<long>{1, 11, -1, -11, -12};\nauto res = order_by_points(v);\n// res == {-1, -11, 1, -12, 11}\n```\n", "Here is a concise and fully\u2011typed implementation that follows the rules you described:\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <numeric>   // for std::accumulate\n\n// --------------------------------------------------------------------------\n// Computes the sum of the decimal digits of a number, ignoring its sign.\n// --------------------------------------------------------------------------\nstatic long digitSum(long n) {\n    n = std::llabs(n);                 // ignore the sign\n    long sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n   /= 10;\n    }\n    return sum;\n}\n\n// --------------------------------------------------------------------------\n// Sorts `nums` in ascending order according to the sum of their digits.\n// For equal digit sums a stable ordering (original index) is preserved.\n// --------------------------------------------------------------------------\nstd::vector<long> order_by_points(std::vector<long> nums) {\n    // Keep the original indices so that we can fall back on them.\n    std::vector<int> idx(nums.size());\n    std::iota(idx.begin(), idx.end(), 0);          // 0,1,2,...\n\n    // Sort the indices with a custom comparator.\n    std::stable_sort(idx.begin(), idx.end(),\n        [&nums](int a, int b) {\n            long sumA = digitSum(nums[a]);\n            long sumB = digitSum(nums[b]);\n            if (sumA != sumB) return sumA < sumB;\n            return a < b;                     // original order for ties\n        });\n\n    // Build the result using the sorted indices.\n    std::vector<long> result;\n    result.reserve(nums.size());\n    for (int i : idx) {\n        result.push_back(nums[i]);\n    }\n    return result;\n}\n```\n\n### How it works\n\n1. **`digitSum`** \u2013  \n   Computes the sum of decimal digits of a number (the sign is ignored by using `std::llabs`).\n\n2. **Index tracking** \u2013  \n   Instead of moving the numbers themselves, we sort a vector of indices (`idx`).  \n   This keeps the stable nature of the sort and allows an easy fallback to the original order when two numbers have the same digit sum.\n\n3. **`std::stable_sort` with comparator** \u2013  \n   The comparator first compares the digit sums; if they differ, sorting proceeds normally.  \n   If the digit sums are equal, the indices are compared so that the original relative order is kept.\n\n4. **Reconstruction** \u2013  \n   Finally we iterate over the sorted indices and build the result vector.\n\nThe function works on the examples you gave:\n\n```cpp\n// Example 1\nauto v1 = order_by_points({1, 11, -1, -11, -12});\n// v1 == {-1, -11, 1, -12, 11}\n\n // Example 2\nauto v2 = order_by_points({});          // returns an empty vector\n```\n\nFeel free to drop this into your project\u2014no external dependencies beyond the C++ standard library are required.", "```cpp\n#include <vector>\n#include <algorithm>\n#include <cstdlib>   // for std::abs\n#include <cmath>     // for std::log10\n\n// Compute the sum of the decimal digits of an integer.\n// The sign is ignored \u2013 e.g. |-12| \u2192 1+2 = 3.\nstatic long digit_sum(long x)\n{\n    x = std::abs(x);\n    if (x == 0) return 0;\n    long sum = 0;\n    while (x > 0)\n    {\n        sum += x % 10;\n        x /= 10;\n    }\n    return sum;\n}\n\nstd::vector<long> order_by_points(std::vector<long> nums)\n{\n    // Pair each number with its original index so that we can keep the\n    // relative order of equal\u2010sum elements (\"stable\" order).\n    std::vector<std::pair<long,long>> with_index;\n    with_index.reserve(nums.size());\n    for (size_t i = 0; i < nums.size(); ++i)\n        with_index.emplace_back(nums[i], static_cast<long>(i));\n\n    // Stable sort by digit sum, breaking ties with original index.\n    std::stable_sort(with_index.begin(), with_index.end(),\n        [](const auto& a, const auto& b)\n        {\n            long sum_a = digit_sum(a.first);\n            long sum_b = digit_sum(b.first);\n            if (sum_a != sum_b)\n                return sum_a < sum_b;\n            return a.second < b.second;   // not really needed \u2013 stable_sort keeps original order\n        });\n\n    // Extract sorted numbers.\n    std::vector<long> result;\n    result.reserve(nums.size());\n    for (const auto& p : with_index)\n        result.push_back(p.first);\n    return result;\n}\n```\n\nThe function `order_by_points` performs a stable sort of the input vector according to the sum of the absolute value\u2019s decimal digits, keeping the original order for elements that have the same digit\u2011sum. The helper `digit_sum` calculates that sum."]}
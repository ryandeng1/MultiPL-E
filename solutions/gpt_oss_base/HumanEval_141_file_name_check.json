{"name": "HumanEval_141_file_name_check", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_141_file_name_check.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) == (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n    assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"_f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a clean C++ implementation that follows the rules described:\n\n```cpp\n#include <string>\n#include <cctype>\n\nstd::string file_name_check(const std::string& file_name) {\n    // 1. Exactly one dot\n    size_t first_dot = file_name.find('.');\n    if (first_dot == std::string::npos) return \"No\";          // no dot\n    if (file_name.find('.', first_dot + 1) != std::string::npos) return \"No\"; // more than one dot\n\n    // 2. Prefix (before the dot) must be non\u2011empty and start with a letter\n    if (first_dot == 0) return \"No\";                         // empty prefix\n    if (!std::isalpha(static_cast<unsigned char>(file_name[0]))) return \"No\";\n\n    // 3. Suffix (after the dot) must be one of {txt, exe, dll}\n    std::string suffix = file_name.substr(first_dot + 1);\n    if (suffix != \"txt\" && suffix != \"exe\" && suffix != \"dll\") return \"No\";\n\n    // 4. Count digits \u2013 must be <= 3\n    int digit_count = 0;\n    for (char c : file_name) {\n        if (std::isdigit(static_cast<unsigned char>(c))) {\n            ++digit_count;\n            if (digit_count > 3) return \"No\";\n        }\n    }\n\n    return \"Yes\";\n}\n```\n\n### How it works\n\n| Rule | Implementation detail |\n|------|-----------------------|\n| **Exactly one dot** | Find the first dot and verify there is no second one. |\n| **Non\u2011empty prefix that starts with a letter** | The first character must be alphabetic (`isalpha`). |\n| **Suffix must be `txt`, `exe`, or `dll`** | Extract the substring after the dot and compare. |\n| **No more than three digits** | Iterate over all characters, counting digits, stop early if the count exceeds 3. |\n\nThe function returns `\"Yes\"` when all conditions are satisfied, otherwise `\"No\"`. This solution is `O(n)` in the length of the file name and uses only the standard library.", "```cpp\n// file_name_check.cpp\n#include <string>\n#include <cctype>\n\nstd::string file_name_check(std::string file_name) {\n    // 1. There must be exactly one dot\n    size_t dot_pos = file_name.find('.');\n    if (dot_pos == std::string::npos || dot_pos != file_name.rfind('.'))\n        return \"No\";\n\n    // 2. Substring before dot must not be empty and start with a latin letter\n    if (dot_pos == 0)\n        return \"No\";\n    if (!std::isalpha(static_cast<unsigned char>(file_name[0])))\n        return \"No\";\n\n    // 3. Substring after dot must be one of [\"txt\", \"exe\", \"dll\"]\n    std::string extension = file_name.substr(dot_pos + 1);\n    if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n\n    // 4. At most three digits in the whole string\n    int digit_count = 0;\n    for (char c : file_name) {\n        if (std::isdigit(static_cast<unsigned char>(c)))\n            ++digit_count;\n    }\n    if (digit_count > 3)\n        return \"No\";\n\n    return \"Yes\";\n}\n\n/* Example usage:\n#include <iostream>\nint main() {\n    std::cout << file_name_check(\"example.txt\") << std::endl;   // Yes\n    std::cout << file_name_check(\"1example.dll\") << std::endl;   // No\n}\n*/\n```", "Here\u2019s a compact, self\u2011contained implementation that follows all the rules you listed:\n\n```cpp\n#include <cctype>   // for ::isdigit, ::isalpha\n#include <string>\n#include <unordered_set>\n\nstd::string file_name_check(const std::string& file_name) {\n    // 1\ufe0f\u20e3  Must contain exactly one dot\n    size_t dot = file_name.find('.');\n    if (dot == std::string::npos || dot != file_name.rfind('.'))\n        return \"No\";\n\n    // 2\ufe0f\u20e3  Substring before the dot\n    const std::string name = file_name.substr(0, dot);\n    if (name.empty() || !std::isalpha(static_cast<unsigned char>(name[0])))\n        return \"No\";\n\n    // 3\ufe0f\u20e3  Substring after the dot\n    const std::string ext = file_name.substr(dot + 1);\n    static const std::unordered_set<std::string> allowed = {\"txt\",\"exe\",\"dll\"};\n    if (!allowed.count(ext))\n        return \"No\";\n\n    // 4\ufe0f\u20e3  Counting digits \u2013 should not exceed 3\n    int digit_count = 0;\n    for (char c : file_name) {\n        if (std::isdigit(static_cast<unsigned char>(c))) {\n            ++digit_count;\n            if (digit_count > 3)\n                return \"No\";\n        }\n    }\n\n    // All checks passed\n    return \"Yes\";\n}\n```\n\n#### How the function works\n1. **Find the dot** \u2013 we need exactly one dot; `find()` and `rfind()` make sure it\u2019s the only one.\n2. **Validate the prefix** \u2013 it must be non\u2011empty and start with an alphabetic character.\n3. **Validate the extension** \u2013 must be one of `txt`, `exe`, or `dll`.\n4. **Count digits** \u2013 stop and return \u201cNo\u201d as soon as more than three digits are found.\n\nYou can now call `file_name_check(\"example.txt\")` and it will return `\"Yes\"`; likewise `file_name_check(\"1example.dll\")` returns `\"No\"`."]}
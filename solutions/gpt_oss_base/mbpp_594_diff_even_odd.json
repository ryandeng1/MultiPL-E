{"name": "mbpp_594_diff_even_odd", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the difference of the first even and first odd number of a given vector.\nlong diff_even_odd(std::vector<long> list1) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_594_diff_even_odd.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = diff_even_odd;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)7, (long)4, (long)1, (long)6, (long)8}))) == (3));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)5, (long)7, (long)9, (long)10}))) == (9));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a clean, self\u2011contained implementation that finds the **first even** and **first odd** number in a `std::vector<long>` and returns the difference (even \u2013 odd).  \nIf the vector does not contain an even or an odd number, the function throws an exception \u2013 this keeps the contract explicit and avoids returning \u201cmagic\u201d values.\n\n```cpp\n#include <vector>\n#include <stdexcept>   // std::runtime_error\n#include <limits>      // std::numeric_limits\n\n/// Return the difference (first_even - first_odd) of the first\n/// even number and the first odd number in *list1*.\n/// \n/// @param list1 Vector of long integers.\n/// @returns long difference.\n/// @throws std::runtime_error if no even or no odd number is found.\nlong diff_even_odd(const std::vector<long>& list1)\n{\n    // placeholders for the first even / odd values\n    long first_even   = std::numeric_limits<long>::max();\n    long first_odd    = std::numeric_limits<long>::max();\n    bool have_even = false;\n    bool have_odd  = false;\n\n    for (const long &x : list1) {\n        if (!have_even && (x % 2 == 0)) {          // first even\n            first_even = x;\n            have_even = true;\n        }\n        if (!have_odd  && (x % 2 != 0)) {          // first odd\n            first_odd = x;\n            have_odd  = true;\n        }\n        // Stop as soon as both have been found\n        if (have_even && have_odd)\n            break;\n    }\n\n    if (!have_even)\n        throw std::runtime_error(\"No even number in vector\");\n    if (!have_odd)\n        throw std::runtime_error(\"No odd number in vector\");\n\n    return first_even - first_odd;\n}\n\n// ---------- Example usage ----------\n#include <iostream>\n\nint main()\n{\n    std::vector<long> v1{3, 7, 4, 9, 2};\n    std::vector<long> v2{2, 4, 6, 8};\n    std::vector<long> v3{1, 3, 5};\n\n    try {\n        std::cout << \"diff(v1) = \" << diff_even_odd(v1) << '\\n'; // 4 - 3 = 1\n        std::cout << \"diff(v2) = \" << diff_even_odd(v2) << '\\n'; // throws\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << '\\n';\n    }\n\n    try {\n        std::cout << \"diff(v3) = \" << diff_even_odd(v3) << '\\n'; // throws\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << '\\n';\n    }\n}\n```\n\n**Explanation of the key points**\n\n1. **First\u2011even / first\u2011odd detection**  \n   The loop stops reading once both required numbers are found (`break`).  \n   This keeps the time complexity O(n) but can end early.\n\n2. **Error handling**  \n   Throwing a `std::runtime_error` is preferred over returning a sentinel value, because it forces the caller to handle the case where the vector lacks an even or an odd element.\n\n3. **`const std::vector<long>&`**  \n   Passing by const reference avoids a copy and guarantees that the input vector is not modified.\n\nFeel free to adapt the exception logic (e.g. return `0` or `std::optional<long>`) if you prefer a different error\u2011handling strategy.", "Below is a minimal, but fully functional implementation of the \u201cfirst\u2011even \u2013 first\u2011odd\u201d difference function, along with a short test harness that demonstrates its behaviour.  \nThe function is intentionally straightforward \u2013 it scans the vector once, remembers the first even number it finds, and the first odd number it finds, then computes the difference. If the vector does not contain an even or an odd number, the function returns `0` (you can change this to throw an exception or return an optional value if you prefer).\n\n```cpp\n#include <vector>\n#include <cassert>\n\n/*\n * Compute the difference between the first even number and the\n * first odd number found in *list1*.  If the vector contains\n * no even or no odd element the function returns 0.\n *\n *   diff_even_odd([2, 5, 4])   -> 2 - 5 = -3\n *   diff_even_odd([3, 2, 7])   -> 2 - 3 = -1\n */\nlong diff_even_odd(const std::vector<long>& list1)\n{\n    const long* first_even = nullptr;\n    const long* first_odd  = nullptr;\n\n    for (const auto& val : list1) {\n        if ((val & 1LL) == 0) {          // even\n            if (!first_even) first_even = &val;\n        } else {                         // odd\n            if (!first_odd) first_odd = &val;\n        }\n\n        /* We can break as soon as we have both */\n        if (first_even && first_odd) break;\n    }\n\n    if (!first_even || !first_odd) return 0; // or throw std::invalid_argument{};\n\n    return (*first_even) - (*first_odd);\n}\n\n/* ---------- Example usage & sanity checks ---------- */\n#ifndef UNIT_TEST\nint main()\n{\n    assert(diff_even_odd({2, 3, 4, 5}) == 2 - 3);\n    assert(diff_even_odd({5, 6, 7})   == 6 - 5);\n    assert(diff_even_odd({8, 9, 10})  == 8 - 9);\n    assert(diff_even_odd({})          == 0);\n    assert(diff_even_odd({1, 3, 5})   == 0); // no even\n    assert(diff_even_odd({2, 4, 6})   == 0); // no odd\n\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n#endif\n```\n\n### How the function works\n\n1. **Linear Scan** \u2013 We traverse the vector once (`O(n)` time complexity).  \n2. **Bit\u2011wise Test** \u2013 `(val & 1LL)` checks parity faster than `val % 2`.  \n3. **Lazy Return** \u2013 If the vector lacks an even or an odd number, we return `0`.  \n   You can replace this with an exception or an `std::optional<long>` if you want stricter error handling.  \n\nFeel free to drop the test harness into your project or adjust the error policy as per your needs.", "Below is a **complete, compilable** C++ program that answers the question:\n\n```cpp\n/*********************************************************************\n *  File:   diff_even_odd.cpp                                          *\n *  Author: ChatGPT                                                  *\n *  Purpose: Show how to get the difference between the first even    *\n *           and first odd number in a vector of longs.              *\n *  Compile:  g++ -std=c++17 -O2 -Wall diff_even_odd.cpp -o diff_even_odd   *\n *********************************************************************/\n\n#include <iostream>\n#include <vector>\n#include <optional>\n#include <cassert>\n\n/*------------------------------------------------------------------*/\n/*  Function: diff_even_odd                                         */\n/*  Description:   Finds the difference between the first even and  */\n/*                 the first odd element in the provided vector.    */\n/*  Parameters:    list1 \u2013 a vector of long integers.                */\n/*  Return Value:  long \u2013 the difference (firstOdd - firstEven).    */\n/*  Preconditions: The vector must contain at least one even and   */\n/*                 one odd number.                                  */\n/*------------------------------------------------------------------*/\nlong diff_even_odd(const std::vector<long>& list1)\n{\n    /* Search for the first even element */\n    std::optional<long> firstEven;\n    /* Search for the first odd element   */\n    std::optional<long> firstOdd;\n\n    for (const auto& value : list1) {\n        if (!firstEven && (value % 2 == 0))\n            firstEven = value;\n\n        if (!firstOdd && (value % 2 != 0))\n            firstOdd = value;\n\n        /* If we already found both we can stop scanning    */\n        if (firstEven && firstOdd)\n            break;\n    }\n\n    /* Defensive programming: ensure both were found */\n    assert(firstEven && firstOdd && \"Vector must contain both even and odd numbers\");\n\n    /* Return the difference between the first odd and first even  */\n    return static_cast<long>(firstOdd.value() - firstEven.value());\n}\n\n/*------------------------------------------------------------------*/\n/*  Main: Test the function with a handful of vectors               */\n/*------------------------------------------------------------------*/\nint main()\n{\n    /* Test cases ---------------------------------------------------*/\n    std::vector<std::vector<long>> tests = {\n        {10, 3, 6, 7, 8},      // first even=10, first odd=3  \u2192 3-10 = -7\n        {1, 4, 7, 2, 9},      // first even=4,  first odd=1  \u2192 1-4  = -3\n        {2, 4, 6, 8, 5, 1},   // first even=2,  first odd=5  \u2192 5-2  =  3\n        {9, 3, 5, 2, 8, 7}    // first even=2,  first odd=9  \u2192 9-2  =  7\n    };\n\n    for (size_t i = 0; i < tests.size(); ++i) {\n        long result = diff_even_odd(tests[i]);\n        std::cout << \"Test \" << i+1 << \": \"\n                  << \"First even = \" << tests[i][0] << \" (but may not be even) \"\n                  << \"\u2192 Difference = \" << result << \"\\n\";\n    }\n\n    return 0;\n}\n```\n\n### How it works\n\n1. **Scanning the vector**  \n   - We iterate once over the vector.  \n   - Two optional variables hold the first even (`firstEven`) and first odd (`firstOdd`) values found.  \n   - As soon as both are found, we break early \u2013 we don\u2019t need to look at the remaining elements.\n\n2. **Safety checks**  \n   - `assert` guarantees that the input vector really contains both an even and an odd number.  \n   - In production code you might want to throw an exception or return a sentinel value instead.\n\n3. **Return value**  \n   - The function returns `firstOdd - firstEven`.  \n   - If you want the absolute difference, replace the return statement with  \n     `return std::abs(firstOdd.value() - firstEven.value());`\n\n4. **Testing in `main`**  \n   - Several example vectors are processed, and the differences are printed.\n\nFeel free to drop this function into your own code base or adapt it for other numeric types!"]}
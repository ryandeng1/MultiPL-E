{"name": "mbpp_160_find_solution", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.\nstd::optional<std::tuple<long, long>> find_solution(long a, long b, long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_160_find_solution.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = find_solution;\n    assert(candidate((2), (3), (7)) == std::make_tuple(2, 1));\n    assert(candidate((4), (2), (7)) == std::nullopt);\n    assert(candidate((1), (13), (17)) == std::make_tuple(4, 1));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a complete, self\u2011contained implementation of `find_solution`.  \nIt uses the extended Euclidean algorithm to obtain a particular solution of\n`ax + by = g` where `g = gcd(a,b)` and then scales that solution to achieve\n`ax + by = n` (provided that `n` is a multiple of `g`).\n\n```cpp\n#include <tuple>\n#include <optional>\n\n/*  Extended Euclidean algorithm.\n    Returns (x, y, g) such that a*x + b*y = g = gcd(a,b)\n    (g is always non\u2011negative)                                                     */\nstatic std::tuple<long, long, long> extended_gcd(long a, long b)\n{\n    if (b == 0) {\n        return {1, 0, a};\n    }\n    long x1, y1;\n    long g = std::get<2>(extended_gcd(b, a % b)); // recursion\n    std::tie(x1, y1, std::ignore) = extended_gcd(b, a % b);\n    // after recursion: b*x1 + (a%b)*y1 = g\n    long x = y1;\n    long y = x1 - (a / b) * y1;\n    return {x, y, g};\n}\n\n/*  Find integers x and y that satisfy a*x + b*y = n.\n    If no such integers exist, return std::nullopt.                                  */\nstd::optional<std::tuple<long, long>> find_solution(long a, long b, long n)\n{\n    long x0, y0, g;\n    std::tie(x0, y0, g) = extended_gcd(a, b);\n\n    // n must be a multiple of g\n    if (n % g != 0) {\n        return std::nullopt;\n    }\n\n    long k = n / g;                 // scale the primitive solution\n    x0 *= k;\n    y0 *= k;\n\n    return std::make_tuple(x0, y0);\n}\n```\n\n### How it works\n\n1. `extended_gcd` recursively computes the coefficients `x` and `y`\n   for the equation `a*x + b*y = gcd(a,b)`.  \n2. In `find_solution` we first obtain the gcd (`g`) of `a` and `b`.  \n3. If `n` is not divisible by `g`, the linear Diophantine equation has no\n   integer solutions\u2014return `std::nullopt`.  \n4. Otherwise scale the primitive solution `(x0, y0)` by `k = n/g`\n   to obtain a particular solution for `ax + by = n`.  \n5. Return the solution as `std::optional<std::tuple<long, long>>`.\n\nThe function works for any signed 64\u2011bit integers and correctly handles\nnegative coefficients.\n", "Here is a full, self\u2011contained implementation of `find_solution`.  \nIt uses the extended Euclidean algorithm to compute a particular solution of  \n`a\u00b7x + b\u00b7y = g` where `g = gcd(a,b)`.  \nIf `n` is not a multiple of `g` there is no integer solution.  \nOtherwise we scale the solution by `n/g` and return it.  \n\n```cpp\n#include <bits/stdc++.h>\n#include <optional>\n#include <tuple>\n\n/* ------------------------------------------------------------------ */\n/*  Extended Euclidean algorithm:  returns g = gcd(a,b) and finds\n    integers x, y so that a*x + b*y = g                                */\nstatic long long extended_gcd(long long a, long long b, long long &x, long long &y)\n{\n    if (b == 0) {                     // Base case\n        x = 1;\n        y = 0;\n        return a;\n    }\n\n    long long x1, y1;                 // Recursive call\n    long long g = extended_gcd(b, a % b, x1, y1);\n\n    // Back substitution\n    x = y1;\n    y = x1 - (a / b) * y1;\n    return g;\n}\n/* ------------------------------------------------------------------ */\n\n/* Return a pair (x,y) such that a*x + b*y = n.\n   If no integer solution exists, return std::nullopt                 */\nstd::optional<std::tuple<long long,long long>> find_solution(long long a,\n                                                             long long b,\n                                                             long long n)\n{\n    if (a == 0 && b == 0) {\n        return (n == 0) ? std::make_optional(std::make_tuple(0,0))\n                         : std::nullopt;\n    }\n\n    long long x0, y0;\n    long long g = extended_gcd(std::abs(a), std::abs(b), x0, y0);\n\n    /* scale the solution by n/g ----------------------------------- */\n    if (n % g != 0)           // no solution exists\n        return std::nullopt;\n\n    // compute the sign corrections\n    long long mult = n / g;\n    long long x = x0 * mult;\n    long long y = y0 * mult;\n\n    if (a < 0) x = -x;\n    if (b < 0) y = -y;\n\n    return std::make_optional(std::make_tuple(x, y));\n}\n\n/* ------------------------------------------------------------------ */\n/* Example usage ----------------------------------------------------- */\n#ifdef RUN_TEST\nint main()\n{\n    auto sol = find_solution(6, 15, 9);   // 6x + 15y = 9\n    if (sol) {\n        long long x, y;\n        std::tie(x, y) = *sol;\n        std::cout << \"x = \" << x << \" , y = \" << y << '\\n';\n    } else {\n        std::cout << \"No solution exists.\\n\";\n    }\n}\n#endif\n```\n\n**Explanation**\n\n1. `extended_gcd` implements the classic recursive extended Euclidean algorithm.  \n   It returns `g = gcd(a,b)` and simultaneously sets `x` and `y` such that  \n   `a*x + b*y = g`.  We pass the absolute values of `a` and `b` to keep the\n   recursion clean.\n\n2. `find_solution` first checks the trivial case `a = b = 0`.  \n   Then it calls `extended_gcd` on `|a|` and `|b|`.  \n   If `n` is not divisible by the gcd, the Diophantine equation has no\n   integer solution (`std::nullopt`).  \n   Otherwise we multiply the base solution by `n/g`.  Because the\n   Euclidean algorithm was run on the absolute values, we adjust the signs\n   of `x` and `y` according to the original signs of `a` and `b`.\n\n3. The function returns a `std::optional<std::tuple<long long,long long>>`,\n   allowing the caller to check whether a solution exists.  \n\nThis implementation runs in `O(log min(a,b))` time and uses only\nconstant additional space.", "Below is a complete, ready\u2011to\u2011paste implementation in **C++17** that follows the brief you gave.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// Calculates extended GCD of a and b.\n/// Returns (g, x, y) such that  a\u00b7x + b\u00b7y = g = gcd(a,b).\nstatic tuple<long long,long long,long long>\next_gcd(long long a, long long b)\n{\n    if (b == 0)\n        return {std::abs(a), a < 0 ? -1 : 1, 0};\n\n    auto [g, x1, y1] = ext_gcd(b, a % b);\n    long long x = y1;\n    long long y = x1 - (a / b) * y1;\n    return {g, x, y};\n}\n\n/// Tries to find integers x and y such that a\u00b7x + b\u00b7y = n.\n///   \u2022 If a solution exists, returns std::optional containing the pair (x,y).\n///   \u2022 If n is not a multiple of gcd(a,b), no solution exists \u2192 returns std::nullopt.\n///\nstatic optional<pair<long long,long long>>\nfind_solution(long long a, long long b, long long n)\n{\n    if (a == 0 && b == 0) {\n        return (n == 0) ? optional<pair<long long,long long>>{ {0,0} } \n                        : nullopt;\n    }\n\n    auto [g, x0, y0] = ext_gcd(a, b);\n\n    /*  If n is not a multiple of g, there is no solution  */\n    if (n % g != 0)\n        return nullopt;\n\n    /*  Scale the particular solution by n/g  */\n    long long k = n / g;\n    long long x = x0 * k;\n    long long y = y0 * k;\n\n    return optional<pair<long long,long long>>{ {x, y} };\n}\n\n/* ----------  Below is a small test harness  ---------- */\nint main()\n{\n    vector<tuple<long long,long long,long long>> tests = {\n        {4, 6, 14},      // 4*1 + 6*1 = 10   => no solution (14 not multiple of 2? actually 14%2==0, plenty)\n        {4, 6, 14},\n        {12, 15, 9},\n        {0, 0, 0},\n        {0, 5, 10},\n        {0, 5, 3},\n        {7, 5, 1}\n    };\n\n    for (auto [a,b,n] : tests) {\n        auto sol = find_solution(a,b,n);\n        if (sol) {\n            auto [x,y] = *sol;\n            cout << \"Solution for a=\"<<a<<\",b=\"<<b<<\",n=\"<<n\n                 << \" : x=\"<<x<<\", y=\"<<y<<\"  -> \";\n            cout << a<<'*'<<x<<\" + \"<<b<<'*'<<y<<\" = \"<<a*x+b*y<<\"\\n\";\n        } else {\n            cout << \"No solution for a=\"<<a<<\", b=\"<<b<<\", n=\"<<n<<\"\\n\";\n        }\n    }\n    return 0;\n}\n```\n\n### How the algorithm works\n\n1. **Extended Euclid**  \n   `ext_gcd` returns integers `(g,x,y)` such that  \n   `a\u00b7x + b\u00b7y = g = gcd(a,b)`.  \n   This works also for negative numbers and with `a` or `b` being `0`.\n\n2. **Existence condition**  \n   A linear Diophantine equation `a\u00b7x + b\u00b7y = n` has a solution iff  \n   `gcd(a,b)` divides `n`.  \n   Therefore after we get `(g,x\u2080,y\u2080)` we check `n % g == 0`.\n\n3. **Scaling the particular solution**  \n   If the condition holds, multiply the particular solution by `k = n/g`:  \n   `x = x\u2080 \u00b7 k`, `y = y\u2080 \u00b7 k`.  \n   These satisfy the equation.\n\n4. **Edge cases**  \n   *Both a and b zero*: only `n==0` has the trivial solution `(0,0)`.  \n   *One of them zero*: the equation reduces to a trivial single\u2011variable problem  \n   (handled automatically by the extended GCD logic).\n\nThis satisfies the requirement: it returns a tuple `(x,y)` when a solution exists, otherwise it returns `std::nullopt`."]}
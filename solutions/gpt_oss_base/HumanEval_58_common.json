{"name": "HumanEval_58_common", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_58_common.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = common;\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121}))) == (std::vector<long>({(long)1, (long)5, (long)653})));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2}))) == (std::vector<long>({(long)2, (long)3})));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2, (long)4}))) == (std::vector<long>({(long)2, (long)3, (long)4})));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>())) == (std::vector<long>()));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a concise, fully\u2011working implementation of the `common` function that:\n\n1. Finds the intersection of the two input vectors.\n2. Returns the result in **sorted order**.\n3. Eliminates duplicates.\n\n```cpp\n#include <vector>\n#include <unordered_set>\n#include <algorithm>\n\n// Return sorted unique common elements for two vectors.\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n    // Use an unordered_set for O(1) look\u2011ups of the first vector\n    std::unordered_set<long> set1(l1.begin(), l1.end());\n\n    // Store intersection elements in a second set to keep uniqueness\n    std::unordered_set<long> intersection;\n    for (const auto& val : l2) {\n        if (set1.find(val) != set1.end())\n            intersection.insert(val);\n    }\n\n    // Move the set into a vector\n    std::vector<long> result(intersection.begin(), intersection.end());\n\n    // Sort the result before returning\n    std::sort(result.begin(), result.end());\n    return result;\n}\n```\n\n### Explanation of the steps\n\n1. **Convert `l1` to an `unordered_set`** \u2013 this gives constant\u2011time membership checks.\n2. **Traverse `l2`** and insert a value into the `intersection` set only if it is present in `set1`.  \n   Using a `set` automatically removes duplicates.\n3. **Copy the set into a vector** and sort it to satisfy the \u201csorted\u201d requirement.\n\n#### Sample usage & output\n\n```cpp\n#include <iostream>\n\nint main() {\n    auto v1 = std::vector<long>({1, 4, 3, 34, 653, 2, 5});\n    auto v2 = std::vector<long>({5, 7, 1, 5, 9, 653, 121});\n    auto result = common(v1, v2);\n    for (auto x : result) std::cout << x << ' ';\n    // Output: 1 5 653\n}\n```\n\nThis implementation works for any size of input vectors, handles negative numbers, and guarantees an empty vector if there is no intersection.", "Here is a compact, efficient implementation that follows the specification:\n\n```cpp\n#include <vector>\n#include <unordered_set>\n#include <algorithm>\n\n// Return sorted unique common elements for two vectors.\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n    // Store the elements of the first vector in a hash set\n    std::unordered_set<long> s1(l1.begin(), l1.end());\n\n    // Collect the elements of the second vector that are present in s1\n    std::vector<long> res;\n    res.reserve(std::min(l1.size(), l2.size()));\n    for (const auto& v : l2) {\n        if (s1.find(v) != s1.end()) {\n            res.push_back(v);\n            s1.erase(v); // remove to keep uniqueness\n        }\n    }\n\n    // Sort the resulting vector\n    std::sort(res.begin(), res.end());\n    return res;\n}\n```\n\n**Explanation**\n\n1. `s1` holds all values of `l1` in a hash set for \\(O(1)\\) lookup.\n2. While iterating over `l2`, we add an element to `res` only if it appears in `s1`.  \n   `erase` guarantees that duplicates are not added again, maintaining uniqueness.\n3. Finally, we sort the result to satisfy the \u201csorted\u201d requirement.\n\nThis solution works in linear time relative to the total number of elements, with only modest extra memory overhead.", "Below is a complete, self\u2011contained implementation of the `common`\u202ffunction that follows the specification given in the comment block at the top:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\n//\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2)\n{\n    // Use a hash set to group unique elements from l1\n    unordered_set<long> set1(l1.begin(), l1.end());\n\n    // Result set: store elements that appear in both vectors\n    unordered_set<long> res_set;\n    for (long x : l2)    // may contain duplicates \u2013 the set handles that\n        if (set1.count(x))\n            res_set.insert(x);\n\n    // Transfer to a vector and sort it\n    std::vector<long> result(res_set.begin(), res_set.end());\n    std::sort(result.begin(), result.end());\n    return result;\n}\n```\n\n### How It Works\n\n1. **Uniqueness of `l1`** \u2013 By constructing `set1` from `l1` we eliminate duplicates, which keeps the algorithm simple and efficient.\n2. **Intersection** \u2013 As we iterate over `l2`, any value already present in `set1` is inserted into `res_set`. Trying to insert into an `unordered_set` automatically ignores duplicates.\n3. **Sorting** \u2013 The specification asks for *sorted* output, so finally we transfer the contents of `res_set` to a vector and sort it with `std::sort`.\n\n> **Complexity**  \n> Let `n = l1.size()`, `m = l2.size()`.  \n> *Building `set1`* \u2013 O(n) average.  \n> *Finding intersection* \u2013 O(m) average.  \n> *Sorting the result* \u2013 O(k log k), where *k* is the number of distinct common elements (k \u2264 min(n,\u202fm)).  \n> Overall average\u2011case time complexity: **O(n + m + k\u202flog\u202fk)**; space complexity: **O(n + k)**.\n\nYou can copy\u2011paste this function into your project and it will behave exactly as described in the doctest examples."]}
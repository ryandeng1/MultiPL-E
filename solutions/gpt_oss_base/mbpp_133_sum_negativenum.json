{"name": "mbpp_133_sum_negativenum", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to calculate the sum of the negative numbers of a given vector of numbers.\nlong sum_negativenum(std::vector<long> nums) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_133_sum_negativenum.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = sum_negativenum;\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-6, (long)-9, (long)11, (long)-12, (long)14, (long)-5, (long)17}))) == (-32));\n    assert(candidate((std::vector<long>({(long)10, (long)15, (long)-14, (long)13, (long)-18, (long)12, (long)-20}))) == (-52));\n    assert(candidate((std::vector<long>({(long)19, (long)-65, (long)57, (long)39, (long)152, (long)-639, (long)121, (long)44, (long)90, (long)-190}))) == (-894));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a minimal, self\u2011contained implementation that follows the specification:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// ---------------------------------------------------------------\n// Calculates the sum of all negative values in a vector of long\n// If there are no negative numbers, the result is 0.\n// ---------------------------------------------------------------\nlong sum_negativenum(const vector<long>& nums)\n{\n    long sum = 0;\n    for (long v : nums)\n        if (v < 0)\n            sum += v;\n    return sum;\n}\n```\n\n### Explanation\n\n| Step | What it does | Why |\n|------|--------------|-----|\n| **1** | `long sum = 0;` | Initialise accumulator to zero so that an empty vector returns 0. |\n| **2** | `for (long v : nums)` | Iterate over each element in the vector. |\n| **3** | `if (v < 0)` | Only consider negative numbers. |\n| **4** | `sum += v;` | Add the negative value to the accumulator. |\n| **5** | `return sum;` | Return the final sum. |\n\n### Usage example\n\n```cpp\nint main() {\n    vector<long> data = { 5, -3, 7, -2, 0, -10 };\n    cout << \"Sum of negative numbers: \" << sum_negativenum(data) << '\\n'; // prints -15\n}\n```\n\nThis function has `O(n)` time complexity (one pass through the vector) and `O(1)` auxiliary space.", "Below is a clean, self\u2011contained implementation that follows the C++14/17 idiom and includes comments so you can copy it straight into your project.\n\n```cpp\n#include <vector>\n#include <numeric>   // std::accumulate\n\n/**\n * @brief Return the sum of all negative numbers in @p nums.\n *\n * The function does **not** modify the input vector.  It runs in linear\n * time, O(n), and uses constant extra space.\n *\n * @param nums A vector of signed long values.\n * @return long The sum of all elements that are < 0.  If there are no\n * negatives the function returns 0.\n */\nlong sum_negativenum(const std::vector<long>& nums)\n{\n    // std::accumulate takes a starting value and a binary operation.\n    // Here the operation adds the element to the running total only\n    // when the element is negative.\n    return std::accumulate(nums.begin(), nums.end(), 0L,\n                           [](long acc, long x) { return acc + (x < 0 ? x : 0); });\n}\n```\n\n### Why this implementation?\n\n| Requirement | How it is satisfied |\n|-------------|---------------------|\n| **Linear time** | `std::accumulate` scans the vector once. |\n| **Constant extra space** | The algorithm keeps a single `long` accumulator. |\n| **No side\u2011effects** | The argument is passed by reference\u2011const; the vector is never altered. |\n| **Modern C++** | Uses `<numeric>` and a lambda; works with C++11 and later. |\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<long> v = { 5, -3, 12, -7, 0, -1 };\n    std::cout << \"Sum of negatives: \" << sum_negativenum(v) << '\\n';  // prints -11\n}\n```\n\nFeel free to adapt the function name or type aliases (e.g., `using ll = long;`) to match your project's conventions.", "Here is a clean and idiomatic implementation for the function that returns the sum of all **negative** values in a `std::vector<long>`:\n\n```cpp\n#include <vector>\n#include <numeric>   // for std::accumulate\n\n// ---------------------------------------------------------------------------\n// sum_negativenum\n//\n// Parameters:\n//   nums \u2013 any vector of long integers\n//\n// Return value:\n//   The sum of all values in `nums` that are strictly less than zero.\n//\n// Notes:\n//   * The function does *not* modify its argument.\n//   * The implementation uses an accumulator with a short\u2011lived lambda\n//     that filters the negative numbers out.\n// ---------------------------------------------------------------------------\nlong sum_negativenum(const std::vector<long>& nums)\n{\n    // Use std::accumulate to build up the sum.\n    // The lambda checks if the current element is negative\n    // and conditionally adds it to the running sum.\n    return std::accumulate(nums.begin(), nums.end(), 0L,\n        [](long acc, long val) { return acc + (val < 0 ? val : 0L); });\n}\n```\n\n### Why this version?\n\n| Feature | Why it matters |\n|---------|----------------|\n| **`const` reference parameter** | Avoids copying the vector; guarantees that the original slice is unchanged. |\n| **`0L` initial value** | Explicitly sets the integer type, preventing accidental sign promotion or overflow. |\n| **Inline lambda** | Keeps the filtering logic local, readable and efficient. |\n| **No external dependencies** | Only `<vector>` and `<numeric>` are required. |\n\nYou can test it quickly:\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> a{5, -2, 7, -3, 0, -1};\n    std::cout << sum_negativenum(a) << '\\n';   // prints -6 (\u22122\u22123\u22121)\n}\n```\n\nFeel free to drop the implementation into your project or ask for further refinements!"]}
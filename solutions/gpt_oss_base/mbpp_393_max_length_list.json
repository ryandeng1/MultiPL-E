{"name": "mbpp_393_max_length_list", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the vector with maximum length.\nstd::tuple<long, std::vector<long>> max_length_list(std::vector<std::vector<long>> input_list) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_393_max_length_list.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = max_length_list;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)3}), (std::vector<long>)std::vector<long>({(long)5, (long)7}), (std::vector<long>)std::vector<long>({(long)9, (long)11}), (std::vector<long>)std::vector<long>({(long)13, (long)15, (long)17})}))) == (std::make_tuple(3, std::vector<long>({(long)13, (long)15, (long)17}))));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1})}))) == (std::make_tuple(5, std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)3, (long)4, (long)5}), (std::vector<long>)std::vector<long>({(long)6, (long)7, (long)8, (long)9}), (std::vector<long>)std::vector<long>({(long)10, (long)11, (long)12})}))) == (std::make_tuple(4, std::vector<long>({(long)6, (long)7, (long)8, (long)9}))));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a small, self\u2011contained implementation that does exactly what you described:\n\n```cpp\n#include <tuple>\n#include <vector>\n#include <algorithm>   // for std::max_element\n#include <cstddef>     // for std::size_t\n\n// Find the sub\u2011vector that has the maximum length and return\n//   ( length , the sub\u2011vector )\n//\n// The function works for any type of *compatible* containers that expose\n// a `size()` member.  In this case we restrict the input to\n// std::vector<std::vector<long>> as requested.\n//\n// If the input list is empty the function throws `std::invalid_argument`.\n// In case several sub\u2011vectors share the same maximum size, the first one\n// encountered is returned (this matches the behaviour of std::max_element\n// with the default comparator).\nstd::tuple<long, std::vector<long>> max_length_list(\n    const std::vector<std::vector<long>>& input_list)\n{\n    if (input_list.empty())\n        throw std::invalid_argument{\"input_list must contain at least one vector\"};\n\n    // Use max_element to find the sub\u2011vector with the largest size\n    auto it = std::max_element(\n        input_list.begin(),\n        input_list.end(),\n        [](const std::vector<long>& a, const std::vector<long>& b)\n        {\n            return a.size() < b.size();\n        });\n\n    const std::vector<long>& best_vec = *it;\n    return std::make_tuple(static_cast<long>(best_vec.size()), best_vec);\n}\n```\n\n### A quick test\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<std::vector<long>> a{\n        {1,2,3},\n        {4,5},\n        {6,7,8,9},\n        {10}\n    };\n\n    auto [len, vec] = max_length_list(a);\n    std::cout << \"Longest length = \" << len << '\\n';\n    std::cout << \"Vector: \";\n    for (auto x : vec) std::cout << x << ' ';\n    std::cout << '\\n';\n}\n```\n\nOutput:\n\n```\nLongest length = 4\nVector: 6 7 8 9 \n```\n\nThe code is concise, uses standard library facilities, and throws a meaningful exception if the input list is empty. Happy coding!", "Here is a small, self\u2011contained implementation that does exactly what you\u2019re asking for:\n\n```cpp\n#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <numeric>\n\n/// @brief   Find the sub\u2011vector with the greatest length\n/// @param   input_list  A list of vectors of `long`\n/// @return  A tuple containing\n///          * the length of the longest sub\u2011vector\n///          * a copy of that sub\u2011vector\n/// @throws  std::invalid_argument if input_list is empty\nstd::tuple<std::size_t, std::vector<long>>\nmax_length_list(const std::vector<std::vector<long>>& input_list)\n{\n    if (input_list.empty())\n        throw std::invalid_argument(\"input_list must not be empty\");\n\n    // initialise with the first element\n    std::size_t best_len = input_list[0].size();\n    std::vector<long> best_vec = input_list[0];\n\n    for (const auto& v : input_list) {\n        if (v.size() > best_len) {\n            best_len = v.size();\n            best_vec = v;\n        }\n    }\n\n    return std::make_tuple(best_len, best_vec);\n}\n```\n\n### What it does\n\n* It walks through all vectors in `input_list` once (`O(n)` time, where *n* is the number of sub\u2011vectors).\n* It keeps track of the maximum length seen so far and the associated vector.\n* If more than one vector shares the same maximum length, the *first* one encountered is returned (you can change the logic if you prefer a different tie\u2011breaking rule).\n* It throws if the input is empty so callers can catch that error explicitly.\n\n### Usage example\n\n```cpp\nint main() {\n    std::vector<std::vector<long>> data = {{1,2,3},\n                                           {4,5},\n                                           {6,7,8,9},\n                                           {10}};\n\n    auto [len, vec] = max_length_list(data);\n    std::cout << \"Maximum length: \" << len << '\\n';\n    std::cout << \"Vector: \";\n    for (auto x : vec) std::cout << x << ' ';\n    std::cout << '\\n';\n}\n```\n\nOutput:\n\n```\nMaximum length: 4\nVector: 6 7 8 9 \n```\n\nFeel free to adjust the signature or exception handling to match the rest of your codebase.", "**Solution Explanation**\n\nWe need a helper that scans a list of vectors and returns\n\n* the length of the longest sub\u2011vector, and\n* the sub\u2011vector itself.\n\nThe function signature is already given:\n\n```cpp\nstd::tuple<long, std::vector<long>> max_length_list(\n        std::vector<std::vector<long>> input_list);\n```\n\nThe algorithm is simple:\n\n1. Keep two variables:  \n   * `max_len` \u2013 the current maximum length seen (initially `0`)  \n   * `max_vec` \u2013 the vector that attained that length (initially empty)\n2. Iterate over `input_list`.  \n   * For each `v`, compute `v.size()`.  \n   * If it is greater than `max_len`: update `max_len` and set `max_vec = v`.\n3. Return the tuple `(max_len, max_vec)`.\n\nWe use the standard library only, no special edge\u2011case handling is required beyond an empty\n`input_list` (which yields length `0` and an empty vector). The time complexity is `O(n)` where `n`\nis the total number of elements in all sub\u2011vectors.\n\n```cpp\n#include <tuple>\n#include <vector>\n\nstd::tuple<long, std::vector<long>> max_length_list(\n    std::vector<std::vector<long>> input_list)\n{\n    long     max_len = 0;\n    std::vector<long> max_vec;\n\n    for (const auto& v : input_list) {\n        const long sz = static_cast<long>(v.size());\n        if (sz > max_len) {\n            max_len = sz;\n            max_vec = v;\n        }\n    }\n\n    return {max_len, max_vec};\n}\n```\n\n**Testing**\n\n```cpp\n#include <iostream>\nint main() {\n    std::vector<std::vector<long>> data = {\n        {1, 2, 3},\n        {4, 5},\n        {6, 7, 8, 9},\n        {}\n    };\n\n    auto [len, vec] = max_length_list(data);\n    std::cout << \"Max length: \" << len << '\\n'; // 4\n    std::cout << \"Vector: \";\n    for (auto x : vec) std::cout << x << ' ';\n    std::cout << '\\n';\n}\n```\n\nOutput:\n\n```\nMax length: 4\nVector: 6 7 8 9 \n```\n\nThe function correctly identifies the longest sub\u2011vector and returns its length."]}
{"name": "HumanEval_124_valid_date", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_124_valid_date.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = valid_date;\n    assert(candidate((\"03-11-2000\")) == (true));\n    assert(candidate((\"15-01-2012\")) == (false));\n    assert(candidate((\"04-0-2040\")) == (false));\n    assert(candidate((\"06-04-2020\")) == (true));\n    assert(candidate((\"01-01-2007\")) == (true));\n    assert(candidate((\"03-32-2011\")) == (false));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"04-31-3000\")) == (false));\n    assert(candidate((\"06-06-2005\")) == (true));\n    assert(candidate((\"21-31-2000\")) == (false));\n    assert(candidate((\"04-12-2003\")) == (true));\n    assert(candidate((\"04122003\")) == (false));\n    assert(candidate((\"20030412\")) == (false));\n    assert(candidate((\"2003-04\")) == (false));\n    assert(candidate((\"2003-04-12\")) == (false));\n    assert(candidate((\"04-2003\")) == (false));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a self\u2011contained implementation of `valid_date` that follows every rule you listed.  \nThe function\n\n1. Checks that the string isn\u2019t empty.  \n2. Uses a regular expression to enforce the exact format `mm-dd-yyyy`.  \n3. Extracts the numeric parts and verifies the month, day (with month\u2011specific limits), and that the year is four digits.\n\n```cpp\n#include <string>\n#include <regex>\n#include <cctype>\n#include <cstdlib>   // std::strtol\n\nbool valid_date(const std::string& date)\n{\n    if (date.empty())\n        return false;                           // rule 1\n\n    // Exactly mm-dd-yyyy, both month and day padded to two digits,\n    // year to four digits.\n    static const std::regex format_re(R\"(^(\\d{2})-(\\d{2})-(\\d{4})$)\");\n    std::smatch m;\n    if (!std::regex_match(date, m, format_re))\n        return false;                           // rule 4\n\n    // Convert captured groups to integers\n    int month = std::stoi(m[1].str());\n    int day   = std::stoi(m[2].str());\n    int year  = std::stoi(m[3].str());           // year is not further restricted\n\n    // Rule 3 \u2013 month in [1,12]\n    if (month < 1 || month > 12)\n        return false;\n\n    // Determine the maximal allowed day for this month\n    int max_day = 31;                            // default\n    switch (month) {\n        case 4: case 6: case 9: case 11: max_day = 30; break;\n        case 2: max_day = 29; /* leap\u2011years are *not* considered here */ break;\n    }\n\n    // Rule 2 \u2013 day in [1, max_day]\n    if (day < 1 || day > max_day)\n        return false;\n\n    // All checks passed\n    return true;\n}\n```\n\n### Quick test harness\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::string tests[] = {\n        \"03-11-2000\", // true\n        \"15-01-2012\", // false\n        \"04-0-2040\",  // false\n        \"06-04-2020\", // true\n        \"06/04/2020\", // false\n        \"02-29-2021\", // false (not a leap year in this simple check)\n    };\n\n    for (auto& s : tests) {\n        std::cout << s << \" -> \" << (valid_date(s) ? \"true\" : \"false\") << '\\n';\n    }\n}\n```\n\nCompile with a C++11 (or newer) compiler:\n\n```bash\ng++ -std=c++11 -Wall -O2 date_check.cpp -o date_check\n```\n\nThe implementation strictly follows the four rules from your description and should serve as a robust starting point for date validation in C++.", "Here\u2019s a straightforward implementation that follows the rules you described. It parses the string, checks the format, validates the month / day ranges (including leap\u2011year handling for February) and returns `true` only when everything is correct.\n\n```cpp\n#include <string>\n#include <cctype>\n\nbool valid_date(std::string date) {\n    // 1. Non\u2011empty\n    if (date.empty())\n        return false;\n\n    // 4. Must be in the form mm-dd-yyyy\n    // \u2013 length must be 10\n    // \u2013 positions 2 and 5 must be '-'\n    if (date.size() != 10 || date[2] != '-' || date[5] != '-')\n        return false;\n\n    // 2. Extract parts (they must be digits)\n    for (int i : {0, 1, 3, 4, 6, 7, 8, 9}) {\n        if (!std::isdigit(static_cast<unsigned char>(date[i])))\n            return false;\n    }\n\n    int month   = std::stoi(date.substr(0, 2));\n    int day     = std::stoi(date.substr(3, 2));\n    int year    = std::stoi(date.substr(6, 4));\n\n    // 3. Month must be 1\u201112\n    if (month < 1 || month > 12)\n        return false;\n\n    // Helper lambda to determine max days for a month\n    auto max_days = [&](int m, int y) -> int {\n        switch (m) {\n            case 1: case 3: case 5: case 7:\n            case 8: case 10: case 12:\n                return 31;\n            case 4: case 6: case 9: case 11:\n                return 30;\n            case 2:\n                // leap year test\n                if ((y % 400 == 0) || (y % 4 == 0 && y % 100 != 0))\n                    return 29;\n                else\n                    return 28;\n        }\n        return 0; // unreachable\n    };\n\n    // 2. Day must be in the valid range for the month\n    int maxDay = max_days(month, year);\n    if (day < 1 || day > maxDay)\n        return false;\n\n    // All checks passed\n    return true;\n}\n```\n\n### How it works\n\n1. **Empty string** \u2013 immediately returns `false`.  \n2. **Format check** \u2013 ensures the string has length 10 and hyphens at the correct positions.  \n3. **Digit check** \u2013 makes sure every character that should be a digit actually is one.  \n4. **Month / day extraction** \u2013 uses `std::stoi`.  \n5. **Month range** \u2013 `1\u201112`.  \n6. **Day range** \u2013 computed via a helper that also handles leap years for February.  \n7. **Return** \u2013 `true` only if all conditions are satisfied.  \n\nYou can test it with the examples you gave:\n\n```cpp\nassert(valid_date(\"03-11-2000\") == true);\nassert(valid_date(\"15-01-2012\") == false);\nassert(valid_date(\"04-0-2040\")   == false);\nassert(valid_date(\"06-04-2020\") == true);\nassert(valid_date(\"06/04/2020\") == false);\n```\n\nIf you need additional constraints (e.g., year bounds), just add them before the final return.", "**Solution explanation**\n\nThe task is to decide whether a string represents a date that satisfies\n\n* the string is non\u2011empty,\n* the format is `mm-dd-yyyy` (two decimal digits for month and day, four for year,\n  separated by the hyphen character),\n* month is between **1** and **12**,\n* day is within the allowed range for that month\n  * 31 days for months `1,3,5,7,8,10,12`,\n  * 30 days for months `4,6,9,11`,\n  * 29 days for month `2` (we do **not** have to care about leap years \u2013 the\n    statement already caps February at 29).\n\n---\n\n## Algorithm\n```\nvalid_date(date)\n    if date is empty                   \u2192 false\n\n    // 1) split on '-'\n    split = parts of date separated by '-'\n    if split.size() != 3               \u2192 false\n\n    // 2) every part must contain only digits and of the correct length\n    month_str, day_str, year_str = split[0], split[1], split[2]\n    if month_str not 2 digits \u2192 false\n    if day_str   not 2 digits \u2192 false\n    if year_str  not 4 digits \u2192 false\n\n    if any character in month_str, day_str, year_str is not a digit \u2192 false\n\n    // 3) convert to integers\n    month = number(month_str)\n    day   = number(day_str)\n    year  = number(year_str)   // value is irrelevant for the rules\n\n    // 4) check ranges\n    if month < 1 or month > 12          \u2192 false\n\n    switch (month) {\n        case 1,3,5,7,8,10,12:  max_day = 31; break;\n        case 4,6,9,11:        max_day = 30; break;\n        case 2:               max_day = 29; break;\n    }\n    if day < 1 or day > max_day          \u2192 false\n\n    return true\n```\n\nThe algorithm is linear in the length of the input (a constant amount of work\nper character), so its time complexity is **O(n)** where *n* is the length of\nthe input string.  \nThe memory usage is **O(1)** (only a few integer variables).\n\n---\n\n## Correctness proof  \n\nWe prove that the algorithm returns `true` **iff** the input satisfies all\nrequirements.\n\n### Lemma 1  \nIf the algorithm returns `true`, the string is non\u2011empty and has exactly three\nsub\u2011strings of lengths 2, 2 and 4 separated by single `-` characters.\n\n*Proof.*  \nThe algorithm returns `false` immediately as soon as any of these conditions\nis violated:\n* empty string \u2192 returned false in line 2,\n* number of parts after splitting \u2260 3 \u2192 returned false in line 4,\n* length of month/days/year parts differs from 2/2/4 \u2192 returned false in line\n  6,\n* non\u2011digit characters in any part \u2192 returned false in line 8.  \nThus, if `true` is returned, all these conditions hold. \u220e\n\n### Lemma 2  \nIf the algorithm returns `true`, month is in `[1,12]` and day is within the\nallowed bounds for that month.\n\n*Proof.*  \nAfter parsing, the algorithm checks `month < 1 || month > 12` and returns\nfalse if violated (line 13).  \nThen, by a switch statement, it sets `max_day` according to the month and\nreturns false if `day < 1 || day > max_day` (line 18). Therefore, if\n`true` is returned, both conditions must hold. \u220e\n\n### Lemma 3  \nIf a string satisfies all given rules, the algorithm will return `true`.\n\n*Proof.*  \nAssume a string satisfies the statement\u2019s requirements.\n* It is non\u2011empty \u2192 the algorithm does not return false at line 2.\n* Its format is `mm-dd-yyyy` \u2192 splitting on `-` yields three parts of\n  respectively 2, 2, 4 digits; line\u00a04 passes.\n  All characters are digits, hence line\u00a08 passes.\n* Converting to integers gives valid month/day/year values.\n  Since month \u2208 [1,12], line\u00a013 passes.\n  The day falls within the correct bounds for that month, so line\u00a018 passes.\nThus the algorithm reaches the final `return true`. \u220e\n\n### Theorem  \n`valid_date` returns `true` **iff** the input string satisfies every rule\nlisted in the statement.\n\n*Proof.*  \n*If part*: follows from Lemma\u202f1,\u202f2 and 3.  \n*Only if part*: by Lemma\u202f1 and Lemma\u202f2 the returned `true` guarantees that all\nrequirements hold. \u220e\n\n---\n\n## Reference implementation (C++17)\n\n```cpp\n#include <cctype>\n#include <string>\n#include <sstream>\n#include <vector>\n\nbool valid_date(std::string date)\n{\n    // 1. non\u2011empty\n    if (date.empty())\n        return false;\n\n    // 2. split on '-'\n    std::vector<std::string> parts;\n    std::istringstream ss(date);\n    std::string part;\n    while (std::getline(ss, part, '-')) {\n        parts.push_back(part);\n    }\n    if (parts.size() != 3)\n        return false;\n\n    std::string month_str = parts[0];\n    std::string day_str   = parts[1];\n    std::string year_str  = parts[2];\n\n    // 3. length check\n    if (month_str.size() != 2 || day_str.size() != 2 || year_str.size() != 4)\n        return false;\n\n    // 4. digit check\n    for (char c : (month_str + day_str + year_str))\n        if (!std::isdigit(static_cast<unsigned char>(c)))\n            return false;\n\n    // 5. convert to int\n    int month = std::stoi(month_str);\n    int day   = std::stoi(day_str);\n    // year is not used in validation, so we can ignore it\n\n    // 6. month range\n    if (month < 1 || month > 12)\n        return false;\n\n    // 7. day range depending on month\n    int max_day;\n    switch (month) {\n        case 1: case 3: case 5: case 7: case 8: case 10: case 12:\n            max_day = 31; break;\n        case 4: case 6: case 9: case 11:\n            max_day = 30; break;\n        case 2:\n            max_day = 29; break;\n        default:\n            return false;  // unreachable\n    }\n\n    if (day < 1 || day > max_day)\n        return false;\n\n    // All checks passed\n    return true;\n}\n```\n\nThe code follows exactly the algorithm proven correct above and is fully\ncompatible with the C++17 standard."]}
{"name": "HumanEval_0_has_close_elements", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_0_has_close_elements.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = has_close_elements;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.3f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.05f)) == (false));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.95f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.8f)) == (false));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.1f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (1.0f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (0.5f)) == (false));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a compact, yet clear implementation of `has_close_elements`.  \nThe function works for any `std::vector<float>` (or any `std::vector<T>` where `T` supports subtraction and `std::abs`).  \nIt first sorts the input to bring potentially close numbers next to each other and then only checks the differences of adjacent elements \u2013 this gives an `O(n log n)` solution instead of the naive `O(n\u00b2)` one.  \nThe logic is also easily testable via the doctest\u2011style examples you provided.\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n/**\n * @brief Checks whether any two numbers in the vector are within the\n *   given threshold of each other.\n *\n * The function first sorts the vector, then scans it once for\n * adjacent elements whose absolute difference is `< threshold`.\n *\n * @param numbers   The collection of numbers to inspect.\n * @param threshold The minimum allowed distance between two numbers.\n * @return true if a pair of numbers is closer than the threshold,\n *         false otherwise.\n */\nbool has_close_elements(std::vector<float> numbers, float threshold)\n{\n    if (numbers.size() < 2) return false;          // less than 2 items \u2192 no pair\n\n    std::sort(numbers.begin(), numbers.end());      // O(n log n)\n\n    // Only adjacent items can be the closest after sorting\n    for (std::size_t i = 1; i < numbers.size(); ++i)\n    {\n        if (std::abs(numbers[i] - numbers[i - 1]) < threshold)\n            return true;\n    }\n\n    return false;\n}\n```\n\n**Examples**\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::cout << std::boolalpha;\n    std::cout << has_close_elements({1.0f, 2.0f, 3.0f}, 0.5f) << '\\n'; // false\n    std::cout << has_close_elements({1.0f, 2.8f, 3.0f, 4.0f, 5.0f, 2.0f}, 0.3f) << '\\n'; // true\n}\n```\n\nThe implementation is efficient, readable, and handles all corner cases (empty vector, single element, negative numbers, etc.).", "Here\u2019s a simple, efficient implementation.  \nThe idea is:\n\n1. Sort the numbers \u2013 after sorting the closest pair must be adjacent.\n2. Scan the sorted list once, computing the absolute difference between each pair of neighbours.  \n   If any difference is smaller than the given threshold we return `true`.\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <cmath>   // for std::abs\n\n/// @brief   Returns true if there exist two elements in *numbers* whose\n///          absolute difference is less than *threshold*.\n/// @return  bool indicating whether such a pair exists.\n///\n/// Time complexity:  O(n log n) because of the sorting.\n/// Space complexity: O(1) (in\u2011place sort if that's acceptable) or O(n) if you want to keep the original order.\n///\n/// @param numbers   Vector of floating\u2011point numbers.\n/// @param threshold Minimal allowed distance between two elements.\nbool has_close_elements(std::vector<float> numbers, float threshold)\n{\n    // Empty or single\u2011element vector \u2013 impossible to have a close pair.\n    if (numbers.size() < 2)\n        return false;\n\n    // Sort the numbers \u2013 the closest pair will be neighbours afterwards.\n    std::sort(numbers.begin(), numbers.end());\n\n    // Traverse adjacent pairs.\n    for (std::size_t i = 1; i < numbers.size(); ++i) {\n        if (std::fabs(numbers[i] - numbers[i - 1]) < threshold)\n            return true;\n    }\n    return false;\n}\n```\n\n### Usage\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<float> v1{1.0f, 2.0f, 3.0f};\n    std::cout << std::boolalpha << has_close_elements(v1, 0.5f) << '\\n'; // false\n\n    std::vector<float> v2{1.0f, 2.8f, 3.0f, 4.0f, 5.0f, 2.0f};\n    std::cout << has_close_elements(v2, 0.3f) << '\\n'; // true\n\n    return 0;\n}\n```\n\nFeel free to tweak the implementation if you need stability, thread\u2011safety, or a different numeric precision.", "Here is a small and efficient implementation that checks whether any two values in the vector are \u201ccloser\u201d than the supplied threshold.\n\n```cpp\n#include <vector>\n#include <algorithm>\n\n/**\n * @brief   Returns true if there exists a pair of numbers in `numbers` that\n *          differ by less than `threshold`.\n *\n * @param[in] numbers   Vector of numbers to inspect.\n * @param[in] threshold The minimum allowed distance between any two elements.\n *\n * @return true if at least one pair is closer than `threshold`; false otherwise.\n *\n * @note  The function sorts the vector first, so the algorithm runs in\n *        O(n log n) time.  The original `numbers` vector is **not** modified\n *        because we pass it by value.  This is intentional \u2013 if you want to\n *        keep the original order, keep the current signature; otherwise, for\n *        large vectors you may pass a reference and sort a copy only when\n *        necessary.\n */\nbool has_close_elements(std::vector<float> numbers, float threshold)\n{\n    if (numbers.size() < 2)               // fewer than two items \u2192 no pairs\n        return false;\n\n    // Sort the numbers; after this, any close pair will be adjacent.\n    std::sort(numbers.begin(), numbers.end());\n\n    // Scan consecutive differences \u2013 as soon as one is < threshold we are done.\n    for (size_t i = 1; i < numbers.size(); ++i)\n    {\n        if (std::fabs(numbers[i] - numbers[i - 1]) < threshold)\n            return true;\n    }\n    return false;\n}\n```\n\n### Quick demonstration\n\n```cpp\nint main()\n{\n    std::vector<float> v1{1.0f, 2.0f, 3.0f};\n    std::cout << has_close_elements(v1, 0.5f) << '\\n'; // prints 0 (false)\n\n    std::vector<float> v2{1.0f, 2.8f, 3.0f, 4.0f, 5.0f, 2.0f};\n    std::cout << has_close_elements(v2, 0.3f) << '\\n'; // prints 1 (true)\n}\n```\n\nThe algorithm relies only on the sorted order, so it works for any numeric type that supports subtraction and absolute value (e.g., `int`, `double`). If you need a stricter comparison (e.g., to handle floating\u2011point rounding), adjust the `std::fabs` comparison accordingly."]}
{"name": "HumanEval_87_get_row", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_87_get_row.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = get_row;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})})), (2)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 1), (std::tuple<long, long>)std::make_tuple(1, 1), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(3, 1), (std::tuple<long, long>)std::make_tuple(4, 1), (std::tuple<long, long>)std::make_tuple(5, 1)})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)1, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)1, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(2, 0), (std::tuple<long, long>)std::make_tuple(3, 2), (std::tuple<long, long>)std::make_tuple(3, 0), (std::tuple<long, long>)std::make_tuple(4, 3), (std::tuple<long, long>)std::make_tuple(4, 0), (std::tuple<long, long>)std::make_tuple(5, 4), (std::tuple<long, long>)std::make_tuple(5, 0), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(6, 0)})));\n    assert(candidate((std::vector<std::vector<long>>()), (1)) == (std::vector<std::tuple<long, long>>()));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1})})), (2)) == (std::vector<std::tuple<long, long>>()));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a concise implementation that follows the specification:\n\n```cpp\n#include <vector>\n#include <tuple>\n#include <algorithm>\n\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n    // Container for the found coordinates\n    std::vector<std::tuple<long, long>> res;\n\n    // Traverse the jagged matrix\n    for (long r = 0; r < static_cast<long>(lst.size()); ++r) {\n        const auto& row = lst[r];\n        for (long c = 0; c < static_cast<long>(row.size()); ++c) {\n            if (row[c] == x) {\n                res.emplace_back(r, c);\n            }\n        }\n    }\n\n    // Sort first by row (ascending), then by column (descending)\n    std::sort(res.begin(), res.end(),\n              [](const std::tuple<long,long>& a,\n                 const std::tuple<long,long>& b) {\n                  if (std::get<0>(a) != std::get<0>(b))\n                      return std::get<0>(a) < std::get<0>(b); // row ascending\n                  return std::get<1>(a) > std::get<1>(b);     // column descending\n              });\n\n    return res;\n}\n```\n\n**Explanation**\n\n1. **Collect coordinates** \u2013 Iterate over each row and each column. Whenever an element equals `x`, push its row\u2011column pair into `res`.\n\n2. **Sorting** \u2013  \n   * First key: row index (`std::get<0>`) \u2013 ascending.  \n   * Second key: column index (`std::get<1>`) \u2013 descending.  \n   The lambda supplied to `std::sort` implements this comparison.\n\n3. **Return** \u2013 The sorted vector of `std::tuple<long, long>` is returned.\n\nThis implementation works for empty matrices, rows with varying lengths, or when no matches are found.", "Below is a full, self\u2011contained implementation of the requested `get_row` function together with a tiny main routine that demonstrates the examples from the prompt.  \nThe function:\n\n* walks through every row (starting at row\u202f0)  \n* records the column indices where the value equals `x`  \n* after collecting all coordinates, it sorts  \n  * first by row (ascending) \u2013 this is already the natural traversal order,  \n  * then \u2013 for each row \u2013 by column **descending**.  \n  The sorting is done with a single standard sort call that uses a custom comparator.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n * Return all *(row, column)* coordinates where `lst[row][col] == x`.\n * Rows are sorted increasingly; columns within the same row are sorted\n * in decreasing order.\n */\nvector<tuple<long, long>> get_row(vector<vector<long>> lst, long x) {\n    vector<tuple<long, long>> coords;\n\n    for (long r = 0; r < static_cast<long>(lst.size()); ++r) {\n        const auto& row = lst[r];\n        for (long c = 0; c < static_cast<long>(row.size()); ++c) {\n            if (row[c] == x) {\n                coords.emplace_back(r, c);\n            }\n        }\n    }\n\n    // sort by row ascending, then by column descending\n    sort(coords.begin(), coords.end(),\n        [](const auto& a, const auto& b) {\n            if (get<0>(a) != get<0>(b))\n                return get<0>(a) < get<0>(b);          // row ascending\n            return get<1>(a) > get<1>(b);              // col descending\n        });\n\n    return coords;\n}\n\n/* ------------------------   Demo / Tests  ------------------------ */\n\nint main() {\n    // Example 1\n    vector<vector<long>> lst1 = {\n        {1,2,3,4,5,6},\n        {1,2,3,4,1,6},\n        {1,2,3,4,5,1}\n    };\n    auto res1 = get_row(lst1, 1);\n    for (auto [r, c] : res1) cout << \"(\" << r << \",\" << c << \") \";\n    cout << \"\\n\";\n\n    // Example 2\n    vector<vector<long>> lst2 = {}; \n    auto res2 = get_row(lst2, 1);\n    cout << \"Size: \" << res2.size() << \"\\n\";\n\n    // Example 3\n    vector<vector<long>> lst3 = {\n        {},\n        {1},\n        {1,2,3}\n    };\n    auto res3 = get_row(lst3, 3);\n    for (auto [r, c] : res3) cout << \"(\" << r << \",\" << c << \") \";\n    cout << \"\\n\";\n\n    return 0;\n}\n```\n\n### How it works\n\n1. **Collecting the coordinates** \u2013 We traverse every row and column of `lst`.  \n   Whenever the element equals `x`, we push a `tuple<long,long>` containing the\n   current row and column indices into the `coords` vector.\n\n2. **Sorting** \u2013  \n   * Rows are already visited in ascending order, but to obey the problem statement\n     we still sort the full collection.  \n   * The comparator first compares the row indices (`get<0>`).  \n   * If the rows are equal it compares the column indices in *reverse* order so\n     that larger column indices appear before smaller ones \u2013 exactly what\n     \u201ccolumns in descending order\u201d demands.\n\n3. **Return** \u2013 The sorted vector of tuples is returned.\n\nThe demo prints the coordinates from each provided example; the output matches the\nexpected return values shown in the prompt.", "Here\u2019s a clean, idiomatic C++17 implementation that follows the specification:\n\n```cpp\n#include <vector>\n#include <tuple>\n#include <algorithm>\n\n/// Return all coordinates (row, col) where lst[row][col] == x.\n///   \u2022 Row indices are sorted in ascending order.\n///   \u2022 Within each row, column indices are sorted in **descending** order.\nstd::vector<std::tuple<long,long>>\nget_row(const std::vector<std::vector<long>>& lst, long x)\n{\n    std::vector<std::tuple<long,long>> res;\n    res.reserve(64);                // a small hint; will grow automatically\n\n    for (long row = 0; row < static_cast<long>(lst.size()); ++row) {\n        const auto& r = lst[row];\n        for (long col = 0; col < static_cast<long>(r.size()); ++col) {\n            if (r[col] == x)\n                res.emplace_back(row, col);\n        }\n    }\n\n    // The default construction order is already row\u2011ascending,\n    // but we must enforce column\u2011descending **per row**.\n    // We can sort the whole vector with a custom comparator that\n    // sorts by row asc, col desc.\n\n    std::sort(res.begin(), res.end(),\n        [](const std::tuple<long,long>& a,\n           const std::tuple<long,long>& b) {\n            if (std::get<0>(a) != std::get<0>(b))\n                return std::get<0>(a) < std::get<0>(b);   // row asc\n            return std::get<1>(a) > std::get<1>(b);       // col desc\n        });\n\n    return res;\n}\n```\n\n### Explanation\n1. **Iterate** over each row and its columns, collecting every `(row, col)` pair where the value equals `x`.\n2. Because we scan rows in increasing order and columns left\u2011to\u2011right, the resulting vector is already **row\u2011sorted ascending**.\n3. To satisfy the requirement of **descending columns per row**, we perform a single stable sort with a comparator that:\n   * Orders by row ascending.\n   * When rows match, orders by column descending.\n4. The function is fully const\u2011correct (`lst` is a `const &`) and uses only standard library facilities.\n\n### Edge Cases\n- Empty `lst` \u2192 returns an empty vector.\n- Rows with no matching element \u2192 simply skip.\n- Rows of varying lengths are naturally handled because we iterate based on each row\u2019s size.\n\nThis implementation is O(n) to collect the coordinates plus O(k\u202flog\u202fk) to sort them, where `n` is total number of elements in `lst` and `k` is the number of matches. It works for large inputs and follows the required sorting rules."]}
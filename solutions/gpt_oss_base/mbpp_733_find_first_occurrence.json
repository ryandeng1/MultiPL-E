{"name": "mbpp_733_find_first_occurrence", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the index of the first occurrence of a given number in a sorted vector.\nlong find_first_occurrence(std::vector<long> A, long x) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_733_find_first_occurrence.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = find_first_occurrence;\n    assert(candidate((std::vector<long>({(long)2, (long)5, (long)5, (long)5, (long)6, (long)6, (long)8, (long)9, (long)9, (long)9})), (5)) == (1));\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)5, (long)5, (long)6, (long)6, (long)8, (long)9, (long)9, (long)9})), (5)) == (2));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)5, (long)6, (long)6, (long)8, (long)9, (long)9, (long)9})), (6)) == (4));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a **ready\u2011to\u2011compile** implementation that finds the index of the first occurrence of a number `x` in a sorted vector `A`.  \nThe routine uses binary search which runs in `O(log\u202fn)` time and uses `O(1)` extra memory.\n\n```cpp\n#include <vector>\n#include <cstddef>   // for std::size_t\n\n/*--------------------------------------------------------------------\n   find_first_occurrence\n   --------------------\n   Parameters\n     - A : sorted vector of long (may contain duplicates)\n     - x : value to search for\n   Returns\n     Index (0\u2011based) of the first occurrence of x in A.\n     If x is not present, -1 is returned.\n--------------------------------------------------------------------*/\nlong find_first_occurrence(const std::vector<long>& A, long x)\n{\n    long left   = 0;\n    long right  = static_cast<long>(A.size()) - 1;\n    long result = -1;                       // not found by default\n\n    while (left <= right)\n    {\n        long mid = left + (right - left) / 2;\n\n        if (A[mid] == x)\n        {\n            result = mid;                   // possible candidate\n            right  = mid - 1;                // search left side for an earlier one\n        }\n        else if (A[mid] < x)\n        {\n            left = mid + 1;                  // go right\n        }\n        else    // A[mid] > x\n        {\n            right = mid - 1;                 // go left\n        }\n    }\n\n    return result;\n}\n```\n\n### How it works\n1. **Binary Search** \u2013 The usual binary search is used to locate an occurrence of `x`.  \n2. **Keep the Leftmost** \u2013 Once an occurrence is found, `right` is moved to `mid\u20111` so we continue searching the left half. This guarantees that the first (smallest index) occurrence is recorded in `result`.  \n3. **Return Value** \u2013 If no occurrence was found during the search, `result` stays `-1`.\n\n### Example\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<long> v = {1, 2, 2, 2, 4, 5, 5, 7};\n    long idx = find_first_occurrence(v, 2);   // idx == 1\n    std::cout << \"First occurrence of 2 is at index: \" << idx << \"\\n\";\n\n    idx = find_first_occurrence(v, 5);        // idx == 5\n    std::cout << \"First occurrence of 5 is at index: \" << idx << \"\\n\";\n\n    idx = find_first_occurrence(v, 3);        // idx == -1\n    std::cout << \"First occurrence of 3 is at index: \" << idx << \"\\n\";\n}\n```\n\nCompile with:\n\n```bash\ng++ -std=c++17 -O2 -Wall -Wextra -pedantic main.cpp\n```\n\nThis function assumes the input vector is already sorted in non\u2011decreasing order. If the vector may not be sorted, sort it first or use a linear scan.", "Here\u2019s a complete, self\u2011contained implementation of `find_first_occurrence`.  \nIt follows the classic binary\u2011search strategy, returning the index of the first `x` in the sorted vector `A` (or `-1` if `x` isn\u2019t present).\n\n```cpp\n#include <vector>\n#include <cassert>\n\n/* Return the index of the first occurrence of x in a sorted vector A.\n * If x is not found, return -1.  The function runs in O(log n) time. */\nlong find_first_occurrence(const std::vector<long>& A, long x) {\n    long lo = 0;\n    long hi = static_cast<long>(A.size()) - 1;\n    long result = -1;                      // default value if not found\n\n    while (lo <= hi) {\n        long mid = lo + (hi - lo) / 2;     // avoid overflow\n\n        if (A[mid] == x) {\n            result = mid;                  // potential first occurrence\n            hi = mid - 1;                   // search left half to find earlier\n        } else if (A[mid] < x) {\n            lo = mid + 1;                   // search right half\n        } else {                            // A[mid] > x\n            hi = mid - 1;                   // search left half\n        }\n    }\n    return result;\n}\n```\n\n### How it works\n\n1. **Binary Search Loop**  \n   We use the classic `lo \u2026 hi` loop while maintaining `mid = lo + (hi-lo)/2`.\n\n2. **When `A[mid] == x`**  \n   - We store `mid` in `result` because we have found an occurrence.\n   - To ensure it\u2019s the *first* one, we continue searching left by setting `hi = mid - 1`.\n\n3. **When `A[mid] < x`**  \n   - All elements at or before `mid` are too small, so we set `lo = mid + 1`.\n\n4. **When `A[mid] > x`**  \n   - All elements at or after `mid` are too big, so we set `hi = mid - 1`.\n\n5. **Termination**  \n   The loop ends when `lo > hi`.  \n   If `result` was never updated, `x` was not in the vector, so we return `-1`.  \n   Otherwise `result` holds the earliest index where `x` appears.\n\n---\n\n#### Quick test harness\n\n```cpp\nint main() {\n    std::vector<long> v = {1,2,2,2,3,4,5};\n\n    assert(find_first_occurrence(v, 2) == 1);\n    assert(find_first_occurrence(v, 3) == 4);\n    assert(find_first_occurrence(v, 6) == -1);\n\n    std::cout << \"All tests passed.\\n\";\n}\n```\n\nFeel free to adjust the function signature if you need to pass the vector by reference (`const std::vector<long>&`) for efficiency, as shown above.", "Here is a complete, self\u2011contained C++ implementation that follows the contract you described:\n\n```cpp\n#include <vector>\n\n/*  Find the index (0\u2011based) of the first occurrence of `x` in a\n    non\u2011decreasing sorted vector `A`.  \n    If `x` does not appear in the vector, the function returns -1.\n*/\nlong find_first_occurrence(const std::vector<long>& A, long x) {\n    long left  = 0;\n    long right = static_cast<long>(A.size()) - 1;\n    long result = -1;                     // store candidate index\n\n    while (left <= right) {\n        long mid = left + (right - left) / 2;\n\n        if (A[mid] == x) {\n            result = mid;                 // candidate found\n            right  = mid - 1;              // keep searching left half\n        } else if (A[mid] < x) {\n            left = mid + 1;                // search right half\n        } else {\n            right = mid - 1;               // search left half\n        }\n    }\n    return result;\n}\n```\n\n### How it works\n* The algorithm uses **binary search** on the sorted vector.\n* When an element equal to `x` is found, its index is stored in `result`.\n* The search continues on the **left side** (`right = mid - 1`) to see if an earlier occurrence exists.\n* If no element equal to `x` is found, `result` remains `-1`.\n\n### Complexity\n* **Time:** `O(log n)` where `n` is `A.size()`.\n* **Space:** `O(1)` \u2013 only a few local variables are used.\n\n### Example usage\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> v = {1, 2, 2, 2, 3, 4, 5};\n    long index = find_first_occurrence(v, 2);   // index == 1\n    std::cout << \"First occurrence of 2 at index: \" << index << '\\n';\n}\n```\n\nFeel free to copy / paste this snippet into your project; the function is fully compliant with the requirements you specified."]}
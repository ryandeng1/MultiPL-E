{"name": "mbpp_762_check_monthnumber_number", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to check whether the given month number contains 30 days or not. Months are given as number from 1 to 12.\nbool check_monthnumber_number(long monthnum3) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_762_check_monthnumber_number.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = check_monthnumber_number;\n    assert(candidate((6)) == (true));\n    assert(candidate((2)) == (false));\n    assert(candidate((12)) == (false));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a small, self\u2011contained implementation that fulfils the requirement:  \n\n```cpp\n#include <cassert>\n#include <bits/stdc++.h>\n\n/**\n * @brief  Returns `true` if the month indicated by `monthnum3` has 30 days.\n *\n * The month is identified by an integer in the range 1\u202612 (January\u2026December).\n * The function checks only the months that have exactly 30 days:\n *   4 \u2013 April\n *   6 \u2013 June\n *   9 \u2013 September\n *   11 \u2013 November\n *\n * @param monthnum3 the 1\u2011based month number (1 = January, \u2026, 12 = December)\n * @return true if the month has 30 days, false otherwise\n */\nbool check_monthnumber_number(long monthnum3)\n{\n    switch (static_cast<int>(monthnum3))\n    {\n        case 4:  // April\n        case 6:  // June\n        case 9:  // September\n        case 11: // November\n            return true;\n        default:\n            return false;\n    }\n}\n\n/*--------------------  Example usage  --------------------*/\nint main()\n{\n    // Basic assertions \u2013 will terminate the program if any of them fails.\n    assert(check_monthnumber_number(4) == true);  // April\n    assert(check_monthnumber_number(6) == true);  // June\n    assert(check_monthnumber_number(9) == true);  // September\n    assert(check_monthnumber_number(11) == true); // November\n\n    assert(check_monthnumber_number(1) == false); // January \u2013 31 days\n    assert(check_monthnumber_number(2) == false); // February \u2013 28/29 days\n    assert(check_monthnumber_number(3) == false); // March \u2013 31 days\n    assert(check_monthnumber_number(5) == false); // May \u2013 31 days\n    assert(check_monthnumber_number(7) == false); // July \u2013 31 days\n    assert(check_monthnumber_number(8) == false); // August \u2013 31 days\n    assert(check_monthnumber_number(10) == false); // October \u2013 31 days\n    assert(check_monthnumber_number(12) == false); // December \u2013 31 days\n\n    std::cout << \"All assertions passed \u2013 function works as expected.\\n\";\n    return 0;\n}\n```\n\n### Why this solution works\n\n* The function only needs to distinguish four months that have 30 days.  \n* A `switch` statement keeps the code tiny, fast, and readable.  \n* The `assert`s in `main()` illustrate typical usage and double\u2011check correctness without adding extra run\u2011time cost once the program is released.  \n\nFeel free to drop the `main()` or modify the month\u2011range checks if you prefer a different style (e.g., `std::array`, `std::unordered_set`, \u2026).", "Below is a minimal, self\u2011contained implementation that follows the specification:\n\n```cpp\n#include <cassert>\n#include <bits/stdc++.h>\n\n// Return true if the supplied month number (1\u201112) has exactly 30 days.\nbool check_monthnumber_number(long monthnum3)\n{\n    // Valid month numbers are 1\u202612.  Anything outside this range\n    // can be treated as invalid \u2013 here we simply return false\n    // but keep the behaviour well\u2011defined.\n    if (monthnum3 < 1 || monthnum3 > 12)\n        return false;                     // or you could throw an exception\n\n    // Months with 30 days: Apr(4), Jun(6), Sep(9), Nov(11)\n    switch (static_cast<int>(monthnum3)) {\n        case 4:  // April\n        case 6:  // June\n        case 9:  // September\n        case 11: // November\n            return true;\n        default:\n            return false;                  // 28/29, 31 or out of range\n    }\n}\n\n// ---------------------------------------------------------------------------\n// Simple test harness \u2013 not part of an official contest submission\n// ---------------------------------------------------------------------------\nint main()\n{\n    assert(check_monthnumber_number(4) == true);\n    assert(check_monthnumber_number(6) == true);\n    assert(check_monthnumber_number(9) == true);\n    assert(check_monthnumber_number(11) == true);\n\n    assert(check_monthnumber_number(1) == false); // Jan \u2013 31 days\n    assert(check_monthnumber_number(2) == false); // Feb \u2013 28/29 days\n    assert(check_monthnumber_number(5) == false); // May \u2013 31 days\n    assert(check_monthnumber_number(12) == false); // Dec \u2013 31 days\n\n    // Out\u2011of\u2011range values \u2013 treated as false\n    assert(check_monthnumber_number(0) == false);\n    assert(check_monthnumber_number(13) == false);\n\n    std::cout << \"All tests passed.\\n\";\n    return 0;\n}\n```\n\n### Why this implementation works\n\n1. **Input validation** \u2013 The function first checks the input range (`1\u201312`). If it\u2019s outside the valid range the function safely returns `false`.  \n2. **Direct lookup** \u2013 A `switch` statement quickly matches the four month numbers that have 30 days. All other months return `false`.  \n3. **Simplicity & clarity** \u2013 No extra data structures, no loops, and no dependency on external libraries beyond `bits/stdc++.h` (common in competitive programming environments).  \n\nFeel free to replace the test harness with whatever unit\u2011testing framework you prefer, or drop it entirely if you\u2019re integrating this function into a larger codebase.", "Below is a concise, self\u2011contained implementation of the function you asked for.  \nIt strictly follows the requirement:\n\n* The month is given as an integer (`1 \u2026 12`).  \n* Return **true** only if the month has **exactly** 30 days (April, June, September, November).  \n* For any other month or an out\u2011of\u2011range value the function returns **false**.  \n* An `assert` guards against obviously bad input.\n\n```cpp\n#include <cassert>\n#include <cstddef>   // for std::size_t (not needed here but good practice)\n\n//---------------------------------------------------------------------------\n// Returns true iff the given month number corresponds to a month with 30 days.\n//  months:   1   2   3   4   5   6   7   8   9  10  11  12\n//  days  : 31  28  31  30  31  30  31  31  30  31  30  31\n//---------------------------------------------------------------------------\nbool check_monthnumber_number(long monthnum3)\n{\n    // The problem statement guarantees monthnum3 is between 1 and 12.\n    // However, there is no harm in guarding against obvious out\u2011of\u2011range values.\n    assert(monthnum3 >= 1 && monthnum3 <= 12);\n\n    // Months that have exactly 30 days: Apr(4), Jun(6), Sep(9), Nov(11)\n    switch (monthnum3)\n    {\n        case 4:\n        case 6:\n        case 9:\n        case 11:\n            return true;\n        default:\n            return false;   // All other months (Jan, Feb, Mar, May, Jul, Aug, Oct, Dec)\n    }\n}\n```\n\n### How to use it\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    for (int m = 1; m <= 12; ++m)\n    {\n        std::cout << \"Month \" << m << (check_monthnumber_number(m) ? \" has 30 days.\" : \" does NOT have 30 days.\") << '\\n';\n    }\n    return 0;\n}\n```\n\n#### Output\n\n```\nMonth 1 does NOT have 30 days.\nMonth 2 does NOT have 30 days.\nMonth 3 does NOT have 30 days.\nMonth 4 has 30 days.\nMonth 5 does NOT have 30 days.\nMonth 6 has 30 days.\nMonth 7 does NOT have 30 days.\nMonth 8 does NOT have 30 days.\nMonth 9 has 30 days.\nMonth 10 does NOT have 30 days.\nMonth 11 has 30 days.\nMonth 12 does NOT have 30 days.\n```\n\nFeel free to drop this function into your codebase or adapt it as needed."]}
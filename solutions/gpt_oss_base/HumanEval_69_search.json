{"name": "HumanEval_69_search", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_69_search.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3, (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2, (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6, (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4, (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6, (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3, (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6, (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8, (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10, (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6, (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5, (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5, (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10, (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8, (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1, (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9, (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10}))) == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10, (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4, (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7, (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1, (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4, (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6, (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2, (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9, (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8, (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1}))) == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3, (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10, (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8}))) == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2, (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10, (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8}))) == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9, (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1, (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7, (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10, (long)10, (long)9, (long)2}))) == (-1));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a concise implementation that follows the description:\n\n```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nlong search(std::vector<long> lst) {\n    // Count the frequencies of each number\n    std::unordered_map<long, long> freq;\n    for (const long& x : lst) {\n        ++freq[x];\n    }\n\n    long best = -1;                 // Initialise with the \u201cno\u2011suitable\u2011value\u201d sentinel\n    for (const auto& p : freq) {    // iterate over each distinct value\n        long val   = p.first;\n        long count = p.second;\n\n        if (count >= val && val > best) {   // satisfies the condition & is greater than the current best\n            best = val;\n        }\n    }\n    return best;   // returns -1 if no value met the requirement\n}\n```\n\n**Explanation**\n\n1. We build a frequency map (`freq`) that records how often each integer appears.\n2. Initialize `best` to `-1` (the value to return when no element satisfies the condition).\n3. Iterate through the map:\n   * If the frequency of `val` is at least `val` itself, then `val` is a candidate.\n   * Keep the largest such candidate in `best`.\n4. Return `best`.\n\nThis meets the specification and works with the examples given.", "Here is a straightforward implementation that follows the specification:\n\n```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\n/*\n * Given a non\u2011empty vector of positive integers, return the greatest integer\n * that is greater than zero and whose frequency in the vector is at least\n * equal to the integer itself.  If no such integer exists, return -1.\n *\n * Examples:\n *   search({4, 1, 2, 2, 3, 1}) \u2192 2\n *   search({1, 2, 2, 3, 3, 3, 4, 4, 4}) \u2192 3\n *   search({5, 5, 4, 4, 4}) \u2192 -1\n */\nlong search(std::vector<long> lst) {\n    // Count the frequency of each number\n    std::unordered_map<long, long> freq;\n    for (long x : lst) {\n        ++freq[x];\n    }\n\n    // Extract all distinct values\n    std::vector<long> keys;\n    keys.reserve(freq.size());\n    for (const auto &p : freq) {\n        keys.push_back(p.first);\n    }\n\n    // Sort descending to search for the largest candidate first\n    std::sort(keys.begin(), keys.end(), std::greater<long>());\n\n    // Find the first value that satisfies freq >= value\n    for (long val : keys) {\n        if (freq[val] >= val && val > 0) {\n            return val;\n        }\n    }\n\n    // No such value found\n    return -1;\n}\n```\n\n### Why this solution works\n\n1. **Counting** \u2013 an unordered map gives `O(1)` average\u2011time updates, so building the frequency table is `O(n)`.\n2. **Candidate selection** \u2013 we only need to check each distinct value once.\n3. **Descending order** \u2013 by sorting keys in descending order we guarantee that the first qualifying number is the greatest one that satisfies the condition.\n4. **Complexity** \u2013  \n   * Time: `O(n + m log m)` where `m` is the number of distinct numbers (usually `m \u2264 n`).  \n   * Space: `O(m)` for the frequency map and keys vector.\n\nFeel free to integrate this function into your codebase. If you have any further requirements or edge\u2011case questions, let me know!", "Here is a clean and efficient implementation that follows the specification:\n\n```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\n/**\n * @brief Find the greatest positive integer `x` in `lst` such that\n *        its frequency in the vector is at least `x`.\n *\n * If no such integer exists, return -1.\n *\n * @param lst Non\u2011empty vector of positive integers\n * @return The greatest integer satisfying the condition, or -1\n */\nlong search(std::vector<long> lst) {\n    // Count frequencies of each number\n    std::unordered_map<long, long> freq;\n    for (long v : lst) {\n        ++freq[v];\n    }\n\n    long answer = -1;\n    for (const auto &p : freq) {\n        long value = p.first;\n        long count = p.second;\n        if (value > 0 && count >= value) {\n            answer = std::max(answer, value);\n        }\n    }\n    return answer;\n}\n```\n\n### Explanation\n1. **Frequency counting** \u2013 We build an `unordered_map` where the key is the integer and the value is its count in `lst`.\n2. **Condition check** \u2013 For each distinct integer `value`, we check whether its frequency `count` is at least `value` (and the value itself is positive).\n3. **Track maximum** \u2013 Keep the maximum `value` that satisfies the condition.\n4. **Return** \u2013 If no integer satisfied the condition, `answer` remains `-1`.\n\nThis solution runs in \\(O(n)\\) time with \\(O(m)\\) additional memory, where \\(n\\) is the size of the vector and \\(m\\) is the number of distinct integers."]}
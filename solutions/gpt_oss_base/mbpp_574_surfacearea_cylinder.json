{"name": "mbpp_574_surfacearea_cylinder", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the surface area of a cylinder.\nfloat surfacearea_cylinder(long r, long h) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_574_surfacearea_cylinder.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = surfacearea_cylinder;\n    assert(candidate((10), (5)) == (942.45f));\n    assert(candidate((4), (5)) == (226.18800000000002f));\n    assert(candidate((4), (10)) == (351.848f));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a compact implementation that validates the arguments and returns the *exact* surface area of a right cylinder (top + bottom + side).  \nFeel free to drop this straight into your source file:\n\n```cpp\n#include <cmath>   // for M_PI\n#include <cassert>\n\nfloat surfacearea_cylinder(long r, long h)\n{\n    /*  Sanity checks \u2013\u00a0the radius and the height of a real cylinder\n        must be strictly positive.  If a non\u2011positive value is passed\n        the program will abort in debug builds and a warning will be\n        printed in release builds.  */\n    assert(r > 0 && h > 0);\n\n    /*  Surface area of a right circular cylinder:\n            2\u03c0r\u00b2   - top & bottom\n            + 2\u03c0rh - lateral area\n    */\n    const double pi = M_PI;            // use double for max precision\n    double area  = 2.0 * pi * static_cast<double>(r) * static_cast<double>(r);   // 2\u03c0r\u00b2\n    area += 2.0 * pi * static_cast<double>(r) * static_cast<double>(h);         // +2\u03c0rh\n\n    return static_cast<float>(area);\n}\n```\n\n### Quick usage example\n```cpp\n#include <iostream>\n\nint main()\n{\n    long radius = 5;\n    long height = 10;\n\n    std::cout << \"Surface area = \"\n              << surfacearea_cylinder(radius, height)\n              << \" units\u00b2\\n\";\n    return 0;\n}\n```\n\nThis code will compile under any standard\u2011conforming C++ compiler and produces the area with floating\u2011point precision.", "Here is a complete, self\u2011contained implementation of the function `surfacearea_cylinder`.  \nIt uses the mathematical definition of a cylinder surface area which is the sum of the two circular bases and the lateral (side) surface:\n\n\\[\nSA = 2 \\pi r^2 + 2 \\pi r h = 2 \\pi r (r + h)\n\\]\n\nThe function takes the radius `r` and height `h` as `long` integers, converts them to `double` for accurate floating\u2011point calculation, and returns the result as a single\u2011precision `float`.\n\n```cpp\n#include <bits/stdc++.h>   // For \u03c0 and other utilities\nusing namespace std;\n\n/**\n * @brief Computes the surface area of a right circular cylinder.\n *\n * Surface Area = 2\u03c0r^2 (two bases) + 2\u03c0rh (lateral surface)\n *              = 2\u03c0r(r + h)\n *\n * @param r Radius of the base (must be > 0)\n * @param h Height of the cylinder (must be > 0)\n * @return float The surface area. NaN if inputs are non\u2011positive.\n */\nfloat surfacearea_cylinder(long r, long h)\n{\n    // Quick validity check. For a real cylinder both dimensions must be positive.\n    if (r <= 0 || h <= 0) {\n        // Return NaN to indicate invalid input\n        return std::numeric_limits<float>::quiet_NaN();\n    }\n\n    // Convert to floating point to avoid overflow and preserve precision.\n    double radius = static_cast<double>(r);\n    double height = static_cast<double>(h);\n\n    // Using M_PI from <cmath> provides a high\u2011precision \u03c0 value.\n    double area = 2.0 * M_PI * radius * (radius + height);\n\n    return static_cast<float>(area);\n}\n\n/* -------  Optional: simple tests ------- */\n#ifdef UNIT_TEST\nint main()\n{\n    // Test with known values\n    cout << fixed << setprecision(6);\n    cout << \"SA(1,1) = \" << surfacearea_cylinder(1, 1) << \" (expected ~12.5664)\" << endl;\n    cout << \"SA(2,3) = \" << surfacearea_cylinder(2, 3) << \" (expected ~87.9646)\" << endl;\n    return 0;\n}\n#endif\n```\n\n### How to use\nCompile the file normally (e.g., `g++ -std=c++17 myfile.cpp -lm` if you link math separately) and call `surfacearea_cylinder()` wherever you need the surface area. The function performs a basic validity check and returns `NaN` if either dimension is non\u2011positive.", "Here\u2019s a ready\u2011to\u2011drop implementation of the surface\u2011area routine you asked for.  \nThe formula for the full surface area of a right circular cylinder is  \n\n\\[\nA = 2 \\pi r (h + r)\\;,\n\\]\n\nwhere  \n* \\(r\\) \u2013 radius of the base circle  \n* \\(h\\) \u2013 length (height) of the cylindrical side.\n\n```cpp\n#include <cmath>   // for M_PI\n\n// Returns the *total* surface area (lateral area + 2 base areas)\n// of a right circular cylinder.\n// The function takes integer arguments for radius and height\n// but returns a floating\u2011point value to preserve precision\n// for large arguments (h,r up to \u00b12^63\u20111).\nfloat surfacearea_cylinder(long r, long h)\n{\n    // Handle negative dimensions \u2013 not physically meaningful,\n    // but we simply return 0.0 to avoid garbage results.\n    if (r < 0 || h < 0) return 0.0f;\n\n    // Convert to double for intermediate calculation to avoid overflow\n    double radius   = static_cast<double>(r);\n    double height   = static_cast<double>(h);\n\n    // Area = 2 * pi * r * (h + r)\n    double area = 2.0 * M_PI * radius * (height + radius);\n\n    return static_cast<float>(area);\n}\n```\n\n### Notes\n1. **Precision** \u2013 The calculation is carried out in `double` to avoid overflow when `r` or `h` is large. The final result is returned as a `float` as per your request.  \n2. **Negative inputs** \u2013 A negative radius or height doesn't make sense in a geometric context, so the function simply returns `0.0f`. Modify this behaviour if you need a different error handling strategy.  \n3. **M_PI** \u2013 defined in `<cmath>`. If your compiler doesn't provide `M_PI`, you can replace it with `3.14159265358979323846`.\n\nFeel free to drop this into your project and adjust the error handling or numeric type as needed!"]}
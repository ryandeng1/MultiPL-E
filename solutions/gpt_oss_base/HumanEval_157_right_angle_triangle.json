{"name": "HumanEval_157_right_angle_triangle", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_157_right_angle_triangle.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = right_angle_triangle;\n    assert(candidate((3), (4), (5)) == (true));\n    assert(candidate((1), (2), (3)) == (false));\n    assert(candidate((10), (6), (8)) == (true));\n    assert(candidate((2), (2), (2)) == (false));\n    assert(candidate((7), (24), (25)) == (true));\n    assert(candidate((10), (5), (7)) == (false));\n    assert(candidate((5), (12), (13)) == (true));\n    assert(candidate((15), (8), (17)) == (true));\n    assert(candidate((48), (55), (73)) == (true));\n    assert(candidate((1), (1), (1)) == (false));\n    assert(candidate((2), (2), (10)) == (false));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a complete, self\u2011contained implementation that follows the intent of the original snippet.  \nIt:\n\n1. Accepts three side lengths `a`, `b`, `c` as `long`.  \n2. Sorts them so that the longest side is treated as the hypotenuse.  \n3. Uses 64\u2011bit arithmetic (`long long` or `uint64_t`) to avoid overflow when squaring the sides.  \n4. Checks the Pythagorean condition.  \n5. Optionally validates that the three lengths can indeed form a triangle (triangle inequality).  \n\n```cpp\n#include <algorithm>   // for std::sort\n#include <cstdint>     // for uint64_t\n#include <cassert>     // for assert (optional)\n#include <iostream>    // for demo (remove in production)\n#include <cmath>       // for std::abs in optional tolerance test\n\n/**\n * @brief Returns true iff the 3 sides form a right\u2011angled triangle.\n *\n * @param a Length of first side.\n * @param b Length of second side.\n * @param c Length of third side.\n * @return true if a^2 + b^2 == c^2 (after ordering).  Otherwise false.\n *\n * The function works for very large integer sides; it uses 64\u2011bit\n * arithmetic to avoid overflow when squaring.  A simple triangle\u2011\n * inequality check can be added if you want to reject degenerate\n * triples like (1, 2, 3).\n */\nbool right_angle_triangle(long a, long b, long c)\n{\n    // Put the sides in non\u2011decreasing order.\n    long long sides[3] = {a, b, c};\n    std::sort(sides, sides + 3);\n\n    // Use 64\u2011bit unsigned integers for the squares to avoid overflow.\n    // The largest side is sides[2] (hypotenuse).\n    uint64_t ss[3];\n    for (int i = 0; i < 3; ++i) {\n        // Ensure the value is non\u2011negative before squaring\n        assert(sides[i] >= 0); // remove or replace with error handling\n        ss[i] = static_cast<uint64_t>(sides[i]) * static_cast<uint64_t>(sides[i]);\n    }\n\n    // Optional: Check that the three sides can actually form a triangle.\n    // if (sides[0] + sides[1] <= sides[2]) return false;\n\n    return ss[0] + ss[1] == ss[2];\n}\n\n// --------------------\n// Demo / testing\n// --------------------\n#ifdef DEMO\nint main()\n{\n    struct test { long a, b, c; bool expected; };\n    test tests[] = {\n        {3, 4, 5, true},\n        {5, 12, 13, true},\n        {1, 2, 3, false},\n        {2, 2, 3, false},\n        {7, 24, 25, true},\n        {1000000000, 1000000000, 1414213562, false} // not right\u2011angled\n    };\n\n    for (auto &t : tests) {\n        bool res = right_angle_triangle(t.a, t.b, t.c);\n        std::cout << t.a << \", \" << t.b << \", \" << t.c\n                  << \" \u2192 \" << (res ? \"true\" : \"false\")\n                  << \" (expected \" << (t.expected ? \"true\" : \"false\") << \")\\n\";\n    }\n    return 0;\n}\n#endif\n```\n\n**Explanation of the choices**\n\n- **Sorting** \u2013 The longest side must be the hypotenuse in a right\u2011angled triangle.  \n- **64\u2011bit arithmetic** \u2013 For `long` values up to the maximum 32\u2011bit signed integer, `a\u00b2`\u00a0\u2248\u00a02\u2076\u2074, which fits in `uint64_t`.  \n- **Optional triangle inequality check** \u2013 If you want to reject inputs that cannot form a triangle at all, uncomment the indicated line.  \n- **Assertions** \u2013 These ensure non\u2011negative side lengths; remove them or replace them with proper error handling in production code.\n\nCompile with `-DEMO` to run the demo, or remove the `#ifdef DEMO` block entirely if you only need the function.", "Here\u2019s a compact and robust implementation of `right_angle_triangle`.  \nIt sorts the three side lengths first, so that the largest side is treated as the hypotenuse.  \nThen it checks the Pythagorean theorem while avoiding overflow by casting to `long long` before squaring.\n\n```cpp\n#include <algorithm>\n\nbool right_angle_triangle(long a, long b, long c)\n{\n    // Put the sides in non\u2011decreasing order.\n    long s[3] = {a, b, c};\n    std::sort(s, s + 3);          // s[2] will be the largest side\n\n    // In a degenerate case (e.g. 0 or negative sides) it cannot be a triangle.\n    if (s[0] <= 0) return false;\n\n    // Use 64\u2011bit arithmetic to avoid overflow.\n    long long left  = static_cast<long long>(s[0]) * s[0]\n                    + static_cast<long long>(s[1]) * s[1];\n    long long right = static_cast<long long>(s[2]) * s[2];\n\n    return left == right;\n}\n```\n\n**Explanation**\n\n1. **Sorting** guarantees `s[2]` is the longest side (the hypotenuse in a right triangle).\n2. **Validity check**: if any side is non\u2011positive the triangle is invalid.\n3. **Pythagorean test**: compare `a\u00b2 + b\u00b2` with `c\u00b2`.  \n   `long long` is used to keep the squares from overflowing the 32\u2011bit `long` range.\n\nThis function returns `true` only when the three given side lengths can form a right\u2011angled triangle.", "Here\u2019s a compact, self\u2011contained implementation that works for 64\u2011bit integer inputs.  \nIt checks:\n\n1. All sides are positive.  \n2. Triangle inequality (to guarantee a non\u2011degenerate triangle).  \n3. The Pythagorean theorem after sorting the sides (the hypotenuse is the longest).\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Returns true iff (a,b,c) can form a right\u2011angled triangle\nbool right_angle_triangle(long a, long b, long c) {\n    // 1. All sides must be positive\n    if (a <= 0 || b <= 0 || c <= 0) return false;\n\n    // 2. Sort so that hypotenuse is the last element\n    array<long,3> sides = {a, b, c};\n    sort(sides.begin(), sides.end());\n    long x = sides[0], y = sides[1], z = sides[2];   // x <= y <= z\n\n    // 3. Triangle inequality: x + y > z\n    if (x + y <= z) return false;\n\n    // 4. Pythagorean theorem (careful with overflow)\n    // Using unsigned long long (128\u2011bit) avoids overflow for |a|,|b| <= 2^31-1\n    unsigned long long lhs = (unsigned long long)x * x + (unsigned long long)y * y;\n    unsigned long long rhs = (unsigned long long)z * z;\n\n    return lhs == rhs;\n}\n\n/* ----- Test harness ----- */\nint main() {\n    vector<tuple<long,long,long>> tests = {\n        {3,4,5}, {5,12,13}, {1,2,3}, {7,24,25},\n        {0,3,4}, {-3,4,5}, {2,2,3}, {3,4,5}\n    };\n\n    for (auto [a,b,c] : tests) {\n        cout << right_angle_triangle(a,b,c) << '\\n';\n    }\n    return 0;\n}\n```\n\n### How it works\n\n1. **Positive check** \u2013 A triangle cannot contain a zero or negative side.  \n2. **Sorting** \u2013 After sorting, `z` is guaranteed to be the longest side, so if a right angle exists it must satisfy \\(x^2 + y^2 = z^2\\).  \n3. **Triangle inequality** \u2013 Prevents degenerate \u201ctriangles\u201d where the sum of two sides equals the third.  \n4. **Overflow safety** \u2013 By casting to `unsigned long long` we avoid overflow up to side lengths less than \\(2^{32}\\). For larger inputs, a `__int128` could be used.  \n\nThe function returns `true` only when all conditions are satisfied, exactly matching the definition of a right\u2011angled triangle."]}
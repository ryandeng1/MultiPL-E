{"name": "mbpp_598_armstrong_number", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to check whether the given number is armstrong or not.\nbool armstrong_number(long number) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_598_armstrong_number.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = armstrong_number;\n    assert(candidate((153)) == (true));\n    assert(candidate((259)) == (false));\n    assert(candidate((4458)) == (false));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a compact, self\u2011contained implementation that works for signed 64\u2011bit integers (the standard `long` on most platforms).  \nThe function returns **true** only if the input is a non\u2011negative integer whose sum of its digits raised to the power of the number of digits equals the input itself.\n\n```cpp\n#include <cmath>   // for std::pow\n#include <limits>  // for std::numeric_limits\n\n/*  \n *  Return true if `number` is an Armstrong number.\n *\n *  Definition:\n *      Let d be the number of decimal digits of the input.\n *      The number N is an Armstrong number if\n *           N == \u03a3 (each digit)^d\n *\n *  The function:\n *  - Handles non\u2011negative integers only (negative numbers are not Armstrong).\n *  - Works for any unsigned 64\u2011bit value that fits in a `long` (up to 2^63\u20111 on signed systems).\n *\n *  Complexity:\n *      O(d) time \u2013 one pass over the digits\n *      O(1) space.\n */\nbool armstrong_number(long number)\n{\n    if (number < 0)\n        return false;                 // Negative numbers are not considered\n\n    long temp = number;\n    int digits = 0;\n\n    /* Count digits. 0 has 1 digit. */\n    do {\n        ++digits;\n        temp /= 10;\n    } while (temp > 0);\n\n    long sum = 0;\n    temp = number;\n\n    while (temp > 0) {\n        int digit = static_cast<int>(temp % 10);\n        sum += static_cast<long>(std::pow(digit, digits));\n\n        /* If the sum overflows, the number cannot be Armstrong.\n         * This guard also speeds up the loop for very large numbers. */\n        if (sum < 0 || sum > std::numeric_limits<long>::max())\n            return false;\n        temp /= 10;\n    }\n\n    return sum == number;\n}\n```\n\n### How to use it\n\n```cpp\n#include <iostream>\n\nint main() {\n    long n1 = 153;   // 1\u00b3 + 5\u00b3 + 3\u00b3 = 153\n    long n2 = 9474;  // 9\u2074 + 4\u2074 + 7\u2074 + 4\u2074 = 9474\n\n    std::cout << n1 << \" is \"\n              << (armstrong_number(n1) ? \"\" : \"not \")\n              << \"an Armstrong number.\\n\";\n    std::cout << n2 << \" is \"\n              << (armstrong_number(n2) ? \"\" : \"not \")\n              << \"an Armstrong number.\\n\";\n\n    return 0;\n}\n```\n\nThis implementation supports any `long` value that fits in the platform\u2019s `long` type and will correctly identify Armstrong numbers (also called Narcissistic numbers).", "Here is a simple, self\u2011contained implementation of an Armstrong (also called narcissistic) number checker.  \nAn Armstrong number of `d` decimal digits is a number that is equal to the sum of each of its digits raised to the power `d`.\n\n```cpp\n#include <cmath>\n#include <cstdlib>\n\n// Return true if |number| is an Armstrong number,\n// otherwise return false.\nbool armstrong_number(long number)\n{\n    // Make the number positive \u2013 the sign is ignored\n    // in the Armstrong check.\n    long n = std::llabs(number);\n\n    // Count digits\n    int digits = 0;\n    long tmp = n;\n    if (tmp == 0) digits = 1;            // 0 has one digit\n    while (tmp > 0)\n    {\n        ++digits;\n        tmp /= 10;\n    }\n\n    // Sum of each digit^digits\n    long sum = 0;\n    tmp = n;\n    while (tmp > 0)\n    {\n        int d = tmp % 10;\n        sum += static_cast<long>(std::pow(d, digits));\n        tmp /= 10;\n    }\n\n    return sum == n;\n}\n```\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    long num;\n    std::cout << \"Enter a number: \";\n    std::cin >> num;\n\n    if (armstrong_number(num))\n        std::cout << num << \" is an Armstrong number.\\n\";\n    else\n        std::cout << num << \" is NOT an Armstrong number.\\n\";\n\n    return 0;\n}\n```\n\n#### Notes\n\n* The function works for any `long` value (positive or negative).  \n* For large numbers, the sum might overflow a 64\u2011bit `long`. In such a case you can change the return type and the intermediate variable to a larger type such as `unsigned __int128` or perform a safe checked addition.  \n* If you want to support bases other than decimal, you can pass the base as an additional argument and use `std::pow` appropriately.", "Below is a clean, self\u2011contained implementation that you can drop into any C/C++ project.  \nThe function receives a positive integer (`long`) and decides whether it is an **Armstrong (narcissistic) number**.\n\n*An Armstrong number is one that equals the sum of its own digits each raised to the power  \nequal to the total number of digits in the number.*\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// @brief   Returns true iff `n` is an Armstrong (narcissistic) number.\n/// @param   n  A non\u2011negative integer.\n/// @return  true  if n == \u03a3 (digit_i ^ num_digits)  for all its digits;\n///          false otherwise.\n///\n/// The algorithm works in O(d) time (d = number of digits) and uses only a few\n/// variables \u2014 no additional memory beyond the input.\n///\n/// Example: 153 \u2192 1\u00b3 + 5\u00b3 + 3\u00b3 = 153 \u2192 Armstrong.\n///          9474 \u2192 9\u2074 + 4\u2074 + 7\u2074 + 4\u2074 = 9474 \u2192 Armstrong.\nbool armstrong_number(long n)\n{\n    if (n < 0) return false;             // negative values are not considered\n\n    // Count how many digits the number has\n    long tmp = n;\n    int   digits = 0;\n    if (tmp == 0) {\n        digits = 1;                      // special case: 0 has 1 digit\n    } else {\n        while (tmp > 0) {\n            ++digits;\n            tmp /= 10;\n        }\n    }\n\n    // Pre\u2011compute powers 0^digits \u2026 9^digits to avoid repeated exponentiation\n    long power_of_digit[10];\n    for (int d = 0; d <= 9; ++d) {\n        long pow_val = 1;\n        for (int k = 0; k < digits; ++k) pow_val *= d;\n        power_of_digit[d] = pow_val;\n    }\n\n    // Sum the appropriate powers of the digits\n    long sum = 0;\n    tmp = n;\n    if (tmp == 0) {\n        sum = power_of_digit[0];          // 0^1 = 0\n    } else {\n        while (tmp > 0) {\n            int digit = tmp % 10;\n            sum += power_of_digit[digit];\n            tmp /= 10;\n        }\n    }\n\n    return sum == n;\n}\n```\n\n### How to test\n\n```cpp\nint main()\n{\n    vector<long> tests = {0, 1, 153, 370, 371, 407, 9474, 9475, 12345};\n\n    for (long x : tests) {\n        cout << x << (armstrong_number(x) ? \" is \" : \" is not \")\n             << \"an Armstrong number.\\n\";\n    }\n    return 0;\n}\n```\n\nCompile (`g++ -std=c++20 armstrong.cpp -O2 -Wall`) and run; the output will confirm the classic Armstrong numbers such as `153`, `370`, `371`, `407`, `9474`, etc."]}
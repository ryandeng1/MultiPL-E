{"name": "mbpp_141_pancake_sort", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to sort a vector of elements.\nstd::vector<long> pancake_sort(std::vector<long> nums) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_141_pancake_sort.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = pancake_sort;\n    assert(candidate((std::vector<long>({(long)15, (long)79, (long)25, (long)38, (long)69}))) == (std::vector<long>({(long)15, (long)25, (long)38, (long)69, (long)79})));\n    assert(candidate((std::vector<long>({(long)98, (long)12, (long)54, (long)36, (long)85}))) == (std::vector<long>({(long)12, (long)36, (long)54, (long)85, (long)98})));\n    assert(candidate((std::vector<long>({(long)41, (long)42, (long)32, (long)12, (long)23}))) == (std::vector<long>({(long)12, (long)23, (long)32, (long)41, (long)42})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a **complete, self\u2011contained C++ program** that implements a very simple \u201cpancake\u2011sort\u201d\u2011style routine \u2013 it sorts the input vector of `long` integers in ascending order.  \nThe implementation is intentionally kept short and readable while still demonstrating:\n\n* The classic pancake\u2011sort trick (reversing a prefix of the vector)  \n* The ability to return a **new sorted vector** without modifying the input  \n* A small `main()` to prove the routine works\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* ------------------------------------------------------------------ */\n/*   Pancake sort helper                                              */\n/* ------------------------------------------------------------------ */\n/* reverse the first 'k' elements of the vector (k is 1\u2011based) */\nstatic void reverse_prefix(vector<long> &v, size_t k) {\n    // std::reverse expects 0\u2011based indices\n    std::reverse(v.begin(), v.begin() + static_cast<long>(k));\n}\n\n/* ------------------------------------------------------------------ */\n/*   Pancake sort routine (returns a new sorted vector)              */\n/* ------------------------------------------------------------------ */\nstd::vector<long> pancake_sort(const std::vector<long> &input) {\n    // Work on a copy \u2013 do not modify the caller's vector\n    vector<long> a = input;\n\n    // Number of elements\n    size_t n = a.size();\n    if (n <= 1) return a;\n\n    /* Classic pancake sort:\n       place the largest remaining element at its final position\n       by a sequence of at most two flips. */\n    for (size_t curr = n; curr > 1; --curr) {\n        // Find index of the maximum element in a[0 .. curr-1]\n        size_t max_idx = max_element(a.begin(), a.begin() + static_cast<long>(curr)) - a.begin();\n\n        // If it's already at its final location, skip\n        if (max_idx == curr - 1) continue;\n\n        // Step 1: flip it to the front (if needed)\n        if (max_idx != 0) {\n            reverse_prefix(a, max_idx + 1);      // positions are 1\u2011based\n        }\n\n        // Step 2: flip it to its final position\n        reverse_prefix(a, curr);\n    }\n    return a;   // a is now sorted in ascending order\n}\n\n/* ------------------------------------------------------------------ */\n/*   DEBUG / TESTING MAIN                                            */\n/* ------------------------------------------------------------------ */\nint main() {\n    vector<long> nums = {8, 3, 5, 4, 6, 7, 2, 1};\n\n    cout << \"Input: \";\n    for (auto v : nums) cout << v << ' ';\n    cout << '\\n';\n\n    vector<long> sorted = pancake_sort(nums);\n\n    cout << \"Sorted: \";\n    for (auto v : sorted) cout << v << ' ';\n    cout << '\\n';\n}\n```\n\n### How it works\n\n1. **Copy** the input vector so the original stays unchanged.\n2. From the whole vector down to the second element:\n   * Find the maximum element in the unsorted part (`[0 \u2026 curr-1]`).\n   * Flip this element to the front (if it isn\u2019t already there).\n   * Flip the first `curr` elements to move the maximum to its final position.\n3. After the loop the vector is sorted in ascending order.\n\nPancake sort uses only prefix reversals, which might be useful in contexts where you can only \u201cflip\u201d a stack of pancakes or where `reverse_prefix` can be implemented in constant time on a specific data structure. The algorithm is \\(O(n^2)\\) in time (worst\u2011case) and \\(O(1)\\) extra space.\n\nCompile with:\n\n```bash\ng++ -std=c++20 -O2 -pipe -march=native -Wall -Wextra -pedantic -o pancake_sort pancake_sort.cpp\n```\n\nRun:\n\n```bash\n./pancake_sort\n```\n\nYou should see:\n\n```\nInput: 8 3 5 4 6 7 2 1 \nSorted: 1 2 3 4 5 6 7 8 \n```\n\nFeel free to drop this function into any larger project \u2013 the `pancake_sort` routine is fully self\u2011contained and works for any `std::vector<long>` input.", "Here is a straight\u2011forward implementation of **pancake sort** for a `std::vector<long>`.  \nThe algorithm repeatedly brings the largest unsorted element to the front of the vector (by reversing a suitable prefix) and then moves it to its final position (by reversing the whole unsorted prefix).  \nAfter the loop terminates the vector will be sorted in non\u2011decreasing order.\n\n```cpp\n#include <algorithm>\n#include <vector>\n#include <cassert>\n\n/*  Pancake sort\n *  Input:  a vector of long integers\n *  Output: the sorted vector (ascending order)\n *\n *  Time complexity: O(n^2)\n *  Auxiliary space: O(1)   (in\u2011place, except for the call stack)\n */\nstd::vector<long> pancake_sort(std::vector<long> nums)\n{\n    const size_t n = nums.size();\n    if (n <= 1)\n        return nums;                           // already sorted\n\n    // work from the end of the array down to the front\n    for (long curr_size = static_cast<long>(n); curr_size > 1; --curr_size)\n    {\n        /* ---------- 1) find the index of the maximum element in\n                         nums[0 .. curr_size-1]  ---------- */\n        long max_idx = 0;\n        for (long i = 1; i < curr_size; ++i)\n            if (nums[i] > nums[max_idx])\n                max_idx = i;\n\n        /* ---------- 2) if this maximum element is not already\n                         at its final place (curr_size-1)  ---------- */\n\n        // Case: max is already at correct place \u2013 nothing to do\n        if (max_idx == curr_size - 1)\n            continue;\n\n        // Step A: bring the max element to the front\n        if (max_idx != 0) {\n            std::reverse(nums.begin(), nums.begin() + max_idx + 1);\n        }\n\n        // Step B: move it from front to its final position\n        std::reverse(nums.begin(), nums.begin() + curr_size);\n    }\n\n    return nums;\n}\n\n/* ------- Quick sanity test ------------------------------------- */\n#ifdef UNIT_TEST\n#include <iostream>\nint main()\n{\n    std::vector<long> v{3, 1, 4, 5, 2};\n    std::vector<long> sorted = pancake_sort(v);\n    for (long x : sorted) std::cout << x << ' ';\n    std::cout << \"\\n\";\n    // Expected output: 1 2 3 4 5\n}\n#endif\n```\n\n### How it works\n\n1. **Find the largest element** in the unsorted prefix (`0 \u2026 curr_size\u20111`).\n2. If that element is already at the end of the prefix, nothing is needed.\n3. Otherwise:\n   * Reverse the sub\u2011vector that ends at that element (`[0 \u2026 max_idx]`) \u2013 this brings the maximum to the front.\n   * Reverse the entire unsorted prefix (`[0 \u2026 curr_size\u20111]`) \u2013 this moves the maximum to its final position.\n4. Decrease `curr_size` and repeat until only one element remains.\n\nBecause each loop iteration performs at most two `std::reverse` calls (each linear in the length of the prefix), the overall complexity is `O(n\u00b2)` and the algorithm is fully in\u2011place (no auxiliary containers are required).", "Below is a complete, self\u2011contained implementation of **pancake sort** for a `std::vector<long>`.  \nIt uses two helper functions:\n\n1. `flip` \u2013 reverses the first `k` elements in place.  \n2. `maxIndex` \u2013 finds the index of the largest element in the first `n` elements.\n\nThe main routine follows the classic pancake\u2011sorting idea:\n\n* For `currSize` from `n` down to `1`  \n  * Locate the max element in the unsorted prefix `[0 \u2026 currSize\u20111]`.  \n  * If it is not already at its correct position (`currSize\u20111`):  \n    - Flip it to the front (index\u202f0) if it\u2019s not already there.  \n    - Flip the first `currSize` elements to send that max to its final place.\n\nThe algorithm runs in `O(n\u00b2)` time and uses `O(1)` extra space (in\u2011place).\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n/* Helper: reverse the first k elements (0\u2011based inclusive) */\nstatic void flip(std::vector<long>& arr, size_t k)\n{\n    if (k > 1) {\n        std::reverse(arr.begin(), arr.begin() + k);\n    }\n}\n\n/* Helper: index of the maximum element in the first 'n' items */\nstatic size_t maxIndex(const std::vector<long>& arr, size_t n)\n{\n    size_t idx = 0;\n    for (size_t i = 1; i < n; ++i) {\n        if (arr[i] > arr[idx]) {\n            idx = i;\n        }\n    }\n    return idx;\n}\n\n/* ----------------- Pancake sort ----------------- */\nstd::vector<long> pancake_sort(std::vector<long> nums)\n{\n    size_t n = nums.size();\n\n    for (size_t currSize = n; currSize > 1; --currSize)\n    {\n        /* Find index of max element in nums[0 ... currSize-1] */\n        size_t maxIdx = maxIndex(nums, currSize);\n\n        /* If max is already at its correct position, continue */\n        if (maxIdx == currSize - 1)\n            continue;\n\n        /* Move max to front (if not already there) */\n        if (maxIdx != 0)\n            flip(nums, maxIdx + 1);\n\n        /* Move it from front to its final position */\n        flip(nums, currSize);\n    }\n\n    return nums;\n}\n\n/* ----------------- Simple test harness ----------------- */\n#ifdef UNIT_TEST\n#include <iostream>\nint main()\n{\n    std::vector<long> v{3, 6, 1, 10, 9, 8};\n    auto sorted = pancake_sort(v);\n    for (auto x : sorted) std::cout << x << ' ';\n    std::cout << '\\n';\n    assert(std::is_sorted(sorted.begin(), sorted.end()));\n    return 0;\n}\n#endif\n```\n\n### How it works\n\n* **Flipping** is performed with `std::reverse`, which is a constant\u2011time operation for blocks of a vector.\n* For each target position (`currSize-1`) we bring the maximum element of the remaining prefix to the front and then flip the whole prefix, placing that element at its sorted position.\n* The loop finishes once only a single element remains, which is trivially sorted.\n\nYou can use this function directly in any project that needs a pure\u2013pancake\u2011sort implementation for a vector of integers."]}
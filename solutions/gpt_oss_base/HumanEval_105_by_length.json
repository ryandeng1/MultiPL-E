{"name": "HumanEval_105_by_length", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_105_by_length.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = by_length;\n    assert(candidate((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3}))) == (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"})));\n    assert(candidate((std::vector<long>())) == (std::vector<std::string>()));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)55}))) == (std::vector<std::string>({(std::string)\"One\"})));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)3, (long)2}))) == (std::vector<std::string>({(std::string)\"Three\", (std::string)\"Two\", (std::string)\"One\"})));\n    assert(candidate((std::vector<long>({(long)9, (long)4, (long)8}))) == (std::vector<std::string>({(std::string)\"Nine\", (std::string)\"Eight\", (std::string)\"Four\"})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a complete and compact implementation of `by_length` that follows the requirements exactly:\n\n```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\n// -----------------------------------------------------------------------------\n// Convert a vector of integers to the desired vector of digit names.\n//\n//   1.   Keep only values that are in the inclusive range [1,9].\n//   2.   Sort those values in ascending order.\n//   3.   Reverse the sorted order (so it becomes descending).\n//   4.   Map each number to its English name (One \u2026 Nine).\n//\n// If the input vector is empty the function returns an empty vector.\n// -----------------------------------------------------------------------------\nstd::vector<std::string> by_length(std::vector<long> arr)\n{\n    // Mapping from integer 1\u20119 to the string name.\n    static const std::string names[9] =\n        {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n\n    // Keep only valid digits.\n    std::vector<int> digits;\n    digits.reserve(arr.size());\n    for (long v : arr)\n        if (1 <= v && v <= 9)            // ignore everything else\n            digits.push_back(static_cast<int>(v));\n\n    if (digits.empty())\n        return {};                      // nothing to output\n\n    // Sort ascending, then reverse for descending.\n    std::sort(digits.begin(), digits.end());   // ascending\n    std::reverse(digits.begin(), digits.end());   // descending\n\n    // Transform numbers into their string representations.\n    std::vector<std::string> result;\n    result.reserve(digits.size());\n    for (int d : digits)\n        result.push_back(names[d - 1]);          // d == 1 \u2192 names[0]\n\n    return result;\n}\n```\n\n### Explanation of key steps\n\n1. **Filtering**  \n   We iterate over the input vector once, adding only values between 1 and 9 inclusive to a temporary `digits` vector. Values outside this range (including negative numbers or numbers larger than 9) are ignored as required.\n\n2. **Sorting & Reversing**  \n   `std::sort` arranges the kept digits in ascending order.  \n   `std::reverse` then flips the order, yielding a decreasing sequence (the \u201creverse of the sorted vector\u201d).\n\n3. **Mapping to names**  \n   A static array of strings is used for the 9 possible names.  \n   Since the array is 0\u2011indexed, we access `names[d-1]` for each digit `d`.\n\n4. **Edge cases**  \n   If no digits survive the filtering step, an empty vector is returned right away.\n\nThe function runs in linear time for filtering plus `O(n log n)` for sorting, which is optimal for this task. It also fulfils all the examples given in the prompt.", "Below is a complete, ready\u2011to\u2011paste implementation of the function described in the problem statement.  \nIt follows the exact specification:\n\n1. **Filter** the input vector keeping only the integers from `1` to `9`.  \n2. **Sort** those integers in ascending order.  \n3. **Reverse** the sorted vector.  \n4. **Map** each digit to its English name (`\"One\"`\u2026`\"Nine\"`).  \n\nIf the input vector is empty or contains no valid digits, the function simply returns an empty vector.  \nThe implementation uses only standard library facilities; no external dependencies are required.\n\n```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <unordered_map>\n\n// Maps a digit [1..9] to its name\nstatic const std::unordered_map<int, std::string> digit_names = {\n    {1, \"One\"},   {2, \"Two\"},   {3, \"Three\"}, {4, \"Four\"},\n    {5, \"Five\"},  {6, \"Six\"},   {7, \"Seven\"}, {8, \"Eight\"},\n    {9, \"Nine\"}\n};\n\nstd::vector<std::string> by_length(std::vector<long> arr) {\n    // 1. Keep only numbers in [1,9]\n    std::vector<int> filtered;\n    for (long v : arr) {\n        if (1 <= v && v <= 9) {\n            filtered.push_back(static_cast<int>(v));\n        }\n    }\n\n    if (filtered.empty()) {\n        return {};   // no valid digits \u2192 empty result\n    }\n\n    // 2. Sort the integers\n    std::sort(filtered.begin(), filtered.end());\n\n    // 3. Reverse the sorted vector\n    std::reverse(filtered.begin(), filtered.end());\n\n    // 4. Convert each digit to its English name\n    std::vector<std::string> result;\n    result.reserve(filtered.size());\n    for (int d : filtered) {\n        // All elements are guaranteed to be in [1,9], so the lookup always succeeds\n        result.push_back(digit_names.at(d));\n    }\n\n    return result;\n}\n```\n\n**Explanation of the code**\n\n* `digit_names` is a static lookup table that maps each digit to its string representation.  \n* The loop filters the input and stores only valid digits as `int`s.  \n* `std::sort` orders them in ascending order, after which `std::reverse` produces the required descending order.  \n* Finally, we build the output vector by translating each digit using the lookup table.  \n\nThe implementation runs in \\(O(n \\log n)\\) time due to the sorting step and uses \\(O(n)\\) extra space. Feel free to drop this function into your project and call it as illustrated in the examples.", "Below is a **complete, self\u2011contained implementation** of the requested function together with a short `main` that demonstrates its expected behaviour.  \nFeel free to drop the `main` section if you only need the `by_length` function for a library.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/**\n * @brief  Convert a vector of integers into a vector of digit names.\n *\n * The function performs the following steps:\n * 1. Keep only the values that are integers in the inclusive range [1, 9].\n * 2. Sort the remaining values in ascending order.\n * 3. Reverse that sorted list.\n * 4. Replace each remaining digit d by the corresponding English word\n *    (\"One\" \u2026 \"Nine\") and return the resulting vector.\n *\n * @param arr input vector of long integers\n * @return vector<string> containing the digit names after sorting/reversing\n */\nvector<string> by_length(vector<long> arr)\n{\n    // Mapping from digit to word. Index 0 is unused.\n    static const string names[10] = {\n        \"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\",\n        \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    };\n\n    // 1. filter\n    vector<int> digits;\n    digits.reserve(arr.size());\n    for (long x : arr) {\n        if (1 <= x && x <= 9) {\n            digits.push_back(static_cast<int>(x));\n        }\n    }\n\n    // 2. sort ascending\n    sort(digits.begin(), digits.end());\n\n    // 3. reverse\n    reverse(digits.begin(), digits.end());\n\n    // 4. map to names\n    vector<string> result;\n    result.reserve(digits.size());\n    for (int d : digits) {\n        result.emplace_back(names[d]);\n    }\n\n    return result;\n}\n\n/* ------------------------------------------------------------------ */\n/* Example usage & very small test harness (optional)                 */\n#ifdef DEMO_BY_LENGTH\nint main() {\n    // Test case 1\n    vector<long> v1 = {2,1,1,4,5,8,2,3};\n    auto r1 = by_length(v1);\n    for (auto &s : r1) cout << s << ' ';\n    cout << '\\n'; // Eight Five Four Three Two Two One One\n\n    // Test case 2\n    vector<long> v2;\n    auto r2 = by_length(v2);\n    cout << \"Size: \" << r2.size() << '\\n'; // 0\n\n    // Test case 3\n    vector<long> v3 = {1,-1,55};\n    auto r3 = by_length(v3);\n    for (auto &s : r3) cout << s << ' ';\n    cout << '\\n'; // One\n\n    return 0;\n}\n#endif\n```\n\n### How it works\n1. **Filtering** \u2013 We iterate through `arr` and push only those numbers between 1 and 9 into a temporary `digits` vector.\n2. **Sorting** \u2013 Standard `std::sort` arranges them in ascending order.\n3. **Reversing** \u2013 `std::reverse` turns the ascending list into descending order.\n4. **Mapping to words** \u2013 A small static array (`names`) maps the integers to their English names.\n5. **Return** \u2013 The resulting vector of strings is returned.\n\nFeel free to compile and run with the `DEMO_BY_LENGTH` macro defined to see the function in action."]}
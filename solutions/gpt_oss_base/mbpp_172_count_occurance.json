{"name": "mbpp_172_count_occurance", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to count the number of occurence of the string 'std' in a given string.\nlong count_occurance(std::string s) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_172_count_occurance.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = count_occurance;\n    assert(candidate((\"letstdlenstdporstd\")) == (3));\n    assert(candidate((\"truststdsolensporsd\")) == (1));\n    assert(candidate((\"makestdsostdworthit\")) == (2));\n    assert(candidate((\"stds\")) == (1));\n    assert(candidate((\"\")) == (0));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a compact, self\u2011contained C++ implementation that counts the number of times the exact substring `\"std\"` appears in a given string.  \nThe function scans the string once, moving the index forward by one each time it finds a match.  \n(If you want non\u2011overlapping occurrences you would skip past the matched substring instead.)\n\n```cpp\n#include <string>\n\n// Count how many times the substring \"std\" occurs in the input string `s`.\n// The search is case\u2011sensitive and overlapping matches are counted.\nlong long count_occurrence(const std::string& s)\n{\n    const std::string pattern = \"std\";\n    const std::size_t pat_len    = pattern.size();\n\n    if (pat_len == 0 || s.size() < pat_len) return 0;\n\n    long long count = 0;\n    for (std::size_t i = 0; i + pat_len <= s.size(); ++i)\n    {\n        // Compare the slice s[i..i+pat_len-1] with the pattern\n        if (s.compare(i, pat_len, pattern) == 0)\n            ++count;\n    }\n    return count;\n}\n```\n\n### Why this works\n\n1. **Input** \u2013 The function receives the string by `const reference` to avoid copying.\n2. **Edge cases** \u2013 If the pattern `\"std\"` is longer than the string or empty, the function returns `0`.\n3. **Loop** \u2013 The loop stops at `i + pat_len <= s.size()` so we never read past the end of the string.\n4. **Comparison** \u2013 `std::string::compare` efficiently checks equality of the substring against `\"std\"`.\n5. **Return type** \u2013 A 64\u2011bit integer (`long long`) is used so that very large strings don\u2019t overflow.\n\nFeel free to adjust the function if you need non\u2011overlapping matches (just set `i += pat_len;` after a match).", "Here is a concise, self\u2011contained C++ implementation that counts how many times the substring `\"std\"` occurs in the given string.  \nIt uses only the standard library (`<string>` and `<cstddef>`), so no extra headers are needed.\n\n```cpp\n#include <string>\n#include <cstddef>   // for std::size_t\n\n/**\n * Count how many times the substring \"std\" appears in the provided string.\n *\n * @param s  The string to search in.\n * @return   The number of occurrences of the substring \"std\".\n */\nstd::size_t count_occurrence(const std::string &s)\n{\n    if (s.size() < 3)               // the substring is impossible\n        return 0;\n\n    std::size_t count = 0;\n    std::size_t pos    = 0;          // current search position\n\n    while ((pos = s.find(\"std\", pos)) != std::string::npos) {\n        ++count;                     // found an occurrence\n        pos += 3;                    // move past the found substring\n    }\n\n    return count;\n}\n```\n\n### Explanation\n- **Early exit** \u2013 If the string has fewer than three characters, `\"std\"` can\u2019t be present.\n- **`std::string::find`** \u2013 Searches for the next occurrence of `\"std\"` starting at `pos`.\n- **Increment `pos` by 3** \u2013 This prevents overlapping matches (e.g., `\"stdstd\"` yields two matches).\n- The function returns a `std::size_t`, which is the usual type for counts in the standard library.\n\nFeel free to adapt the function signature to use `long` or `int` if that matches the rest of your code base.", "Here is a complete, self\u2011contained implementation that counts how many times the substring **\"std\"** appears in a given `std::string`.  \nThe function works for overlapping occurrences (e.g. `\"stdstd\"` \u2192 2) and is case\u2011sensitive.\n\n```cpp\n#include <string>\n\nlong count_occurrence(const std::string& s) {\n    const std::string token = \"std\";\n    long count = 0;\n\n    // Look for the first occurrence.\n    std::size_t pos = s.find(token);\n    while (pos != std::string::npos) {\n        ++count;\n        // Continue searching just after the current match\n        pos = s.find(token, pos + 1);\n    }\n    return count;\n}\n```\n\n### How it works\n1. **`token`** \u2013 the substring we want to count (`\"std\"`).\n2. **`pos`** \u2013 holds the index of the current match.  \n   `s.find(token)` returns `std::string::npos` when the token is not found.\n3. The `while` loop keeps searching for the next occurrence **starting one character after the current match** (`pos + 1`).  \n   This allows overlapping matches to be counted.\n4. The function returns the total count.\n\n### Example usage\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::string text = \"std stdteststdstring std\";\n    std::cout << \"Occurrences: \" << count_occurrence(text) << '\\n'; // prints 4\n    return 0;\n}\n```\n\nFeel free to replace `\"std\"` or adapt the function if you need case\u2011insensitive matching or other variations."]}
{"name": "mbpp_237_check_occurences", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes in a vector of tuples and returns a map mapping each unique tuple to the number of times it occurs in the vector.\nstd::map<std::tuple<long, long>,long> check_occurences(std::vector<std::tuple<long, long>> test_list) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_237_check_occurences.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = check_occurences;\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(3, 1), (std::tuple<long, long>)std::make_tuple(1, 3), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(5, 2), (std::tuple<long, long>)std::make_tuple(6, 3)}))) == (std::map<std::tuple<long, long>,long>({{std::make_tuple(1, 3), 2}, {std::make_tuple(2, 5), 2}, {std::make_tuple(3, 6), 1}})));\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(4, 2), (std::tuple<long, long>)std::make_tuple(2, 4), (std::tuple<long, long>)std::make_tuple(3, 6), (std::tuple<long, long>)std::make_tuple(6, 3), (std::tuple<long, long>)std::make_tuple(7, 4)}))) == (std::map<std::tuple<long, long>,long>({{std::make_tuple(2, 4), 2}, {std::make_tuple(3, 6), 2}, {std::make_tuple(4, 7), 1}})));\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(13, 2), (std::tuple<long, long>)std::make_tuple(11, 23), (std::tuple<long, long>)std::make_tuple(12, 25), (std::tuple<long, long>)std::make_tuple(25, 12), (std::tuple<long, long>)std::make_tuple(16, 23)}))) == (std::map<std::tuple<long, long>,long>({{std::make_tuple(2, 13), 1}, {std::make_tuple(11, 23), 1}, {std::make_tuple(12, 25), 2}, {std::make_tuple(16, 23), 1}})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a minimal, complete and **self\u2011contained** implementation of the requested function.  \nIt counts every unique tuple that occurs in the input vector and returns a `std::map` whose\nkeys are the tuples and whose values are the occurrence counts.\n\n```cpp\n#include <vector>\n#include <tuple>\n#include <map>\n\n/// @brief Count the number of times each distinct (long, long) tuple appears\n///        in @p test_list.\n/// @param test_list A vector of tuples.\n///\n/// @return A std::map whose key is the tuple and value is the number of\n///         times that tuple appeared in @p test_list.\nstd::map<std::tuple<long, long>, long>\ncheck_occurences(const std::vector<std::tuple<long, long>>& test_list)\n{\n    std::map<std::tuple<long, long>, long> freq;\n\n    for (const auto& t : test_list) {\n        ++freq[t];            // map::operator[] creates the key if missing\n    }\n    return freq;\n}\n```\n\n### How it works\n\n1. **Iterate over the vector**  \n   We loop over each `std::tuple<long,long>` inside `test_list`.\n\n2. **Increment the counter**  \n   `freq[t]` uses the map\u2019s `operator[]` which:\n   * If `t` is not already a key, inserts it with a default value of `0`.\n   * Returns a reference to the mapped value, which we then increment.\n\n3. **Return the populated map**  \n   After the loop, `freq` contains every distinct tuple as a key and its count as the value.\n\n### Example usage\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<std::tuple<long,long>> v{\n        {1,2}, {3,4}, {1,2}, {5,6}, {3,4}, {3,4}\n    };\n\n    auto counts = check_occurences(v);\n\n    for (const auto& [tpl, n] : counts) {\n        std::cout << \"(\" << std::get<0>(tpl) << \",\" << std::get<1>(tpl)\n                  << \"): \" << n << '\\n';\n    }\n}\n```\n\nOutput:\n\n```\n(1,2): 2\n(3,4): 3\n(5,6): 1\n```\n\nThis function is generic, efficient (single pass over the input), and fully compliant with the C++ standard library.", "Below is a small, self\u2011contained program that illustrates the function you asked for.  \nThe `check_occurences` function receives a `std::vector<std::tuple<long,long>>` and returns a\n`std::map<std::tuple<long,long>, long>` where the key is the tuple itself and the value\nis the number of times that tuple appears in the vector.\n\n```cpp\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <tuple>\n#include <map>\n#include <cassert>\n\n// ---------------------------------------------------------------------------\n// Count how many times each tuple occurs.\n// ---------------------------------------------------------------------------\nstd::map<std::tuple<long, long>, long>\ncheck_occurences(const std::vector<std::tuple<long, long>>& test_list)\n{\n    std::map<std::tuple<long, long>, long> occ;\n\n    for (const auto& t : test_list) {\n        ++occ[t];            // ++ works on the value (long) of the map entry\n    }\n\n    return occ;\n}\n\n// ---------------------------------------------------------------------------\n// Helper to pretty\u2011print a map of tuples.\n// ---------------------------------------------------------------------------\nvoid print_map(const std::map<std::tuple<long, long>, long>& m)\n{\n    for (const auto& [key, val] : m) {\n        std::cout << \"(\" << std::get<0>(key) << \", \" << std::get<1>(key)\n                  << \") -> \" << val << '\\n';\n    }\n}\n\nint main()\n{\n    // Example data\n    std::vector<std::tuple<long, long>> vec = {\n        {1, 2}, {3, 4}, {1, 2},\n        {5, 6}, {3, 4}, {3, 4}\n    };\n\n    auto occ_map = check_occurences(vec);\n\n    // sanity check\n    assert(occ_map[{1, 2}] == 2);\n    assert(occ_map[{3, 4}] == 3);\n    assert(occ_map[{5, 6}] == 1);\n\n    std::cout << \"Occurrences:\\n\";\n    print_map(occ_map);\n\n    return 0;\n}\n```\n\n**Explanation**\n\n1. **Iteration** \u2013 We simply loop over every tuple in the input vector.\n2. **Map update** \u2013 `occ[t]` automatically creates an entry with value `0` if the\n   tuple isn\u2019t present yet; `++occ[t]` then increments the count.\n3. **Return** \u2013 The filled map is returned.\n\nThe helper `print_map` and test in `main()` are there only to demonstrate\nthe function and to provide a sanity\u2011check with `assert`.  \nFeel free to drop the helper / `main()` from your project if you only need the\n`check_occurences` function.", "Here\u2019s a complete, self\u2011contained implementation of the function you described.  \nIt uses only the C++ Standard Library (no `bits/stdc++.h` is required) and takes a `std::vector` of `std::tuple<long,long>` and returns a `std::map` that maps each distinct tuple to the number of times it occurs:\n\n```cpp\n#include <tuple>\n#include <vector>\n#include <map>\n\n/// @brief Counts how many times each unique tuple appears in @p test_list.\n///\n/// @param test_list A vector of tuples of two `long` values.\n/// @return A map where the key is a tuple and the value is the number of\n///         occurrences of that tuple in the input vector.\n///\n/// Example\n/// -------\n/// std::vector<std::tuple<long,long>> v{\n///     {1, 2},\n///     {3, 4},\n///     {1, 2},\n///     {5, 6},\n///     {3, 4},\n///     {3, 4}\n/// };\n/// auto m = check_occurrences(v);\n/// // m contains { {1,2}=2, {3,4}=3, {5,6}=1 }\n///\nstd::map<std::tuple<long, long>, long>\ncheck_occurrences(const std::vector<std::tuple<long, long>>& test_list)\n{\n    std::map<std::tuple<long, long>, long> result;\n    for (const auto &t : test_list) {\n        ++result[t];              // `operator++` defaults to 0 when key absent\n    }\n    return result;\n}\n```\n\n### How it works\n* `std::map` gives us an ordered container with O(log\u202fn) insertion/lookup.\n* `{}` on an iterator that does not exist creates the key with the\n  default\u2011constructed value (0 for `long`), so `++result[t]` automatically\n  handles both first\u2011time and repeated tuples.\n\n### Usage\n\n```cpp\nint main() {\n    std::vector<std::tuple<long,long>> data{\n        {1,2},{3,4},{1,2},{5,6},{3,4},{3,4}\n    };\n\n    auto counts = check_occurrences(data);\n\n    for (const auto& [key, cnt] : counts) {\n        std::cout << '(' << std::get<0>(key)\n                  << ',' << std::get<1>(key)\n                  << \"): \" << cnt << '\\n';\n    }\n}\n```\n\nThis will output:\n\n```\n(1,2): 2\n(3,4): 3\n(5,6): 1\n```\n\nFeel free to adapt the types (`long` can be replaced by any other integral type) or the container (`unordered_map` for faster average\u2011case performance) to match your needs."]}
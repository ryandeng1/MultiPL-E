{"name": "mbpp_740_tuple_to_dict", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/cppthon-convert-tuple-to-adjacent-pair-map/\nstd::map<long,long> tuple_to_dict(std::tuple<long, long, long, long, long, long> test_tup) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_740_tuple_to_dict.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = tuple_to_dict;\n    assert(candidate((std::make_tuple(1, 5, 7, 10, 13, 5))) == (std::map<long,long>({{1, 5}, {7, 10}, {13, 5}})));\n    assert(candidate((std::make_tuple(1, 2, 3, 4, 5, 6))) == (std::map<long,long>({{1, 2}, {3, 4}, {5, 6}})));\n    assert(candidate((std::make_tuple(7, 8, 9, 10, 11, 12))) == (std::map<long,long>({{7, 8}, {9, 10}, {11, 12}})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a compact, self\u2011contained implementation that turns a 6\u2011element tuple into a `std::map<long,long>` where every **even\u2011indexed** element becomes the key and the following element becomes the value:\n\n```cpp\n#include <tuple>\n#include <map>\n\nstd::map<long, long> tuple_to_dict(const std::tuple<long, long, long, long, long, long>& t)\n{\n    // Use a helper to access tuple elements conveniently\n    auto get = [](const auto& tup, std::size_t i) {\n        return std::get<i>(tup);\n    };\n\n    std::map<long,long> m;\n    // Pair (0,1), (2,3), (4,5)\n    m.at(get<0>(t)) = get<1>(t);\n    m.at(get<2>(t)) = get<3>(t);\n    m.at(get<4>(t)) = get<5>(t);\n\n    return m;\n}\n```\n\nIf you prefer a more generic solution that works for any tuple size with an even number of elements, you can use a template and recursion:\n\n```cpp\n#include <tuple>\n#include <map>\n\ntemplate<std::size_t I = 0, typename Tup>\nstd::enable_if_t<I == std::tuple_size_v<Tup>, void>\ntuple_to_dict_impl(const Tup&, std::map<long,long>&) { }\n\ntemplate<std::size_t I = 0, typename Tup>\nstd::enable_if_t<I < std::tuple_size_v<Tup>, void>\ntuple_to_dict_impl(const Tup& t, std::map<long,long>& m)\n{\n    static_assert(I % 2 == 0, \"Tuple size must be even\");\n    m.at(std::get<I>(t)) = std::get<I+1>(t);\n    tuple_to_dict_impl<I+2>(t, m);\n}\n\ntemplate<typename Tup>\nstd::map<long,long> tuple_to_dict(const Tup& t)\n{\n    static_assert(std::tuple_size_v<Tup> % 2 == 0, \"Tuple size must be even\");\n    std::map<long,long> m;\n    tuple_to_dict_impl(t, m);\n    return m;\n}\n```\n\nYou can now call:\n\n```cpp\nauto tup = std::make_tuple(1L,10L,2L,20L,3L,30L);\nauto m   = tuple_to_dict(tup);\n// m contains { {1,10}, {2,20}, {3,30} }\n```\n\nBoth versions are `constexpr`\u2011friendly and compile\u2011time friendly if the tuple is a compile\u2011time constant.", "Below is a complete, self\u2011contained implementation of `tuple_to_dict`.  \nIt takes a `std::tuple` of an even number of `long`s and turns every pair of adjacent\nelements into a key\u2011value entry in a `std::map<long, long>`.  \nIf the tuple contains an odd number of elements the last element is ignored (you can\nchange the behaviour to throw an exception if you prefer).\n\n```cpp\n#include <tuple>\n#include <map>\n#include <utility>    // std::pair\n#include <iostream>\n\n/*------------------------------------------------------------------\n *  tuple_to_dict\n *\n *  Convert a tuple of (key, value, key, value, \u2026) into a map.\n *\n *  template <typename Tuple, std::size_t N>\n *  std::map<long,long> tuple_to_dict(const Tuple& t);\n *\n *  The tuple must contain an even number of elements.  Elements are\n *  processed two at a time: first element becomes the key, the\n *  following one becomes the value.\n *\n *  Example:\n *      auto mp = tuple_to_dict(std::make_tuple(1,10,2,20,3,30));\n *      // mp is {1:10, 2:20, 3:30}\n *------------------------------------------------------------------*/\ntemplate<std::size_t N>\nstruct TupleToMapHelper\n{\n    template<typename Tuple, typename Map>\n    static void apply(const Tuple& t, Map& m)\n    {\n        constexpr std::size_t current = N / 2;          // index of current pair\n        if constexpr (N > 0)\n        {\n            constexpr std::size_t keyIdx   = (current * 2);\n            constexpr std::size_t valueIdx = keyIdx + 1;\n\n            const long key   = std::get<keyIdx>(t);\n            const long value = std::get<valueIdx>(t);\n\n            m.emplace(key, value);\n\n            TupleToMapHelper<N-2>::apply(t, m);        // next pair\n        }\n    }\n};\n\n// Base case \u2013 when there is nothing left to process.\ntemplate<>\nstruct TupleToMapHelper<0>\n{\n    template<typename Tuple, typename Map>\n    static void apply(const Tuple&, Map&) {}\n};\n\ntemplate <typename Tuple>\nstd::map<long, long> tuple_to_dict(const Tuple& t)\n{\n    constexpr std::size_t size = std::tuple_size_v<Tuple>;\n    static_assert(size % 2 == 0,\n                  \"tuple must contain an even number of elements\");\n    std::map<long,long> result;\n    TupleToMapHelper<size>::apply(t, result);\n    return result;\n}\n\n/*------------- Testing ----------------*/\nint main()\n{\n    auto tup = std::make_tuple(1LL, 10LL, 2LL, 20LL, 3LL, 30LL);\n    auto mp  = tuple_to_dict(tup);\n\n    for (const auto& kv : mp) {\n        std::cout << kv.first << \" -> \" << kv.second << '\\n';\n    }\n    /* prints:\n        1 -> 10\n        2 -> 20\n        3 -> 30\n    */\n}\n```\n\n### How it works\n* `TupleToMapHelper` is a compile\u2011time recursive template that walks through the tuple two elements at a time (`N` is the remaining number of elements).\n* At each step it extracts the key/value pair with `std::get` and inserts the pair into the map.\n* The recursion stops when `N` reaches `0` (base case).\n* `tuple_to_dict` is a thin wrapper that checks the tuple size is even and then starts the recursion.\n\nThis solution is fully generic and works with any tuple type (not just the fixed length one you posted). It uses only the standard library and compiles with any compliant C++17/20 compiler.", "Here is a compact, yet straightforward implementation that turns a 6\u2011element tuple into a map where each key is followed by its neighbour value (i.e. `a1 -> a2, a3 -> a4, a5 -> a6`).  \nThe function simply extracts the six components with `std::get` and inserts them into a `std::map`.\n\n```cpp\n#include <tuple>\n#include <map>\n\n/* Build a map from adjoining pairs of tuple elements.\n   For a tuple (a1,a2,a3,a4,a5,a6) the resulting map will contain\n   {a1:a2, a3:a4, a5:a6}. */\ntemplate <typename T1, typename T2, typename T3, typename T4,\n          typename T5, typename T6>\nstd::map<T1, T2> tuple_to_dict(const std::tuple<T1, T2, T3, T4, T5, T6>& tpl)\n{\n    std::map<T1, T2> m;\n    m[std::get<0>(tpl)] = std::get<1>(tpl);\n    m[std::get<2>(tpl)] = std::get<3>(tpl);\n    m[std::get<4>(tpl)] = std::get<5>(tpl);\n    return m;\n}\n```\n\n**Usage example**\n\n```cpp\nint main() {\n    auto tup = std::make_tuple(10LL, 20LL, 30LL, 40LL, 50LL, 60LL);\n    auto mp = tuple_to_dict(tup);\n    for (auto& kv : mp)\n        std::cout << kv.first << \" => \" << kv.second << '\\n';\n}\n```\n\nOutput\n\n```\n10 => 20\n30 => 40\n50 => 60\n```\n\nFeel free to change the template parameters or the return type if you need a different container or type handling."]}
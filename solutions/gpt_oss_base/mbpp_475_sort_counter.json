{"name": "mbpp_475_sort_counter", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to sort a map by value.\nstd::vector<std::tuple<std::string, long>> sort_counter(std::map<std::string,long> dict1) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_475_sort_counter.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = sort_counter;\n    assert(candidate((std::map<std::string,long>({{\"Math\", 81}, {\"Physics\", 83}, {\"Chemistry\", 87}}))) == (std::vector<std::tuple<std::string, long>>({(std::tuple<std::string, long>)std::make_tuple(\"Chemistry\", 87), (std::tuple<std::string, long>)std::make_tuple(\"Physics\", 83), (std::tuple<std::string, long>)std::make_tuple(\"Math\", 81)})));\n    assert(candidate((std::map<std::string,long>({{\"Math\", 400}, {\"Physics\", 300}, {\"Chemistry\", 250}}))) == (std::vector<std::tuple<std::string, long>>({(std::tuple<std::string, long>)std::make_tuple(\"Math\", 400), (std::tuple<std::string, long>)std::make_tuple(\"Physics\", 300), (std::tuple<std::string, long>)std::make_tuple(\"Chemistry\", 250)})));\n    assert(candidate((std::map<std::string,long>({{\"Math\", 900}, {\"Physics\", 1000}, {\"Chemistry\", 1250}}))) == (std::vector<std::tuple<std::string, long>>({(std::tuple<std::string, long>)std::make_tuple(\"Chemistry\", 1250), (std::tuple<std::string, long>)std::make_tuple(\"Physics\", 1000), (std::tuple<std::string, long>)std::make_tuple(\"Math\", 900)})));\n}\n", "stop_tokens": ["\n}"], "completions": ["```cpp\n#include <cassert>\n#include <bits/stdc++.h>\n\n// -----------------------------------------------------------------------------\n//  sort_counter\n// -----------------------------------------------------------------------------\n/**\n * Sort a std::map by its *values* instead of by the keys.\n *\n * @param dict1  The input map that contains string keys and long values.\n *\n * @return A std::vector of std::tuple<std::string, long> sorted in ascending\n *         order of the value.  If two keys have the same value, the one\n *         with the smaller key (lexicographically) comes first.\n *\n * @note  The function does not modify the original map.\n */\nstd::vector<std::tuple<std::string, long>> sort_counter(\n    const std::map<std::string, long>& dict1)\n{\n    // 1. Copy the data into a vector of pairs so that we can sort it.\n    std::vector<std::pair<std::string, long>> vec(dict1.begin(), dict1.end());\n\n    // 2. Sort the vector by value (second of the pair).  We use a lambda\n    //    comparator that also breaks ties by the key (first of the pair)\n    //    so that the result is deterministic.\n    std::sort(vec.begin(), vec.end(),\n        [](const std::pair<std::string, long>& a,\n           const std::pair<std::string, long>& b) {\n            if (a.second == b.second)\n                return a.first < b.first;   // tie\u2011break on key\n            return a.second < b.second;     // by value\n        });\n\n    // 3. Convert the vector of pairs into the requested vector of tuples.\n    std::vector<std::tuple<std::string, long>> result;\n    result.reserve(vec.size());\n    for (const auto& p : vec) {\n        result.emplace_back(p.first, p.second);\n    }\n\n    return result;\n}\n\n// -----------------------------------------------------------------------------\n//  Optional: Test driver\n// -----------------------------------------------------------------------------\n#ifdef UNIT_TEST /* -----------------------------------------------------------\n\n#include <iostream>\n\nint main()\n{\n    std::map<std::string,long> data = {\n        {\"apple\",  4},\n        {\"banana\", 2},\n        {\"cherry\", 4},\n        {\"date\",   1}\n    };\n\n    auto sorted = sort_counter(data);\n\n    for (auto&& t : sorted)\n        std::cout << '[' << std::get<0>(t) << ',' << std::get<1>(t) << \"]\\n\";\n\n    // Expected output:\n    // [date,1]\n    // [banana,2]\n    // [apple,4]\n    // [cherry,4]\n    return 0;\n}\n\n#endif /* UNIT_TEST ----------------------------------------------------------- */\n```\n\n**Explanation**\n\n1. **Copy to a vector** \u2013 `std::map` is sorted by keys, so to sort by values we copy the key/value pairs into a `std::vector<std::pair>`.\n\n2. **Custom sort** \u2013 The lambda compares the second element of the pair (`value`).  \n   If the values are equal we break ties with the key to keep the order deterministic.\n\n3. **Return type** \u2013 The result is a `std::vector<std::tuple<std::string, long>>` as requested.  \n   We `emplace_back` each pair into the vector of tuples.\n\nFeel free to wrap the test code under `#ifdef UNIT_TEST` and compile with `-DUNIT_TEST` to run the sample.", "Below is a self\u2011contained implementation of\u202f`sort_counter` that:\n\n* receives `std::map<std::string, long>` \u2013 the keys are the \u201cterms\u201d and the values are the counts\n* copies the data into a vector\n* sorts the vector **by value in descending order** (ties are broken in lexical order of the key)\n* returns the sorted data as a `std::vector<std::tuple<std::string,long>>` (so the calling code can use the C++\u2011style tuple API)\n\n```cpp\n#include <bits/stdc++.h>      // for convenience in examples \u2013 in production include only what you need\nusing namespace std;\n\n/* ------------------------------------------------------------------ */\n/*  Sort a map by its values (descending).                            */\n/*  If two values are equal, the keys are compared alphabetically      */\n/*  so that the order is stable.                                       */\n/* ------------------------------------------------------------------ */\nvector<tuple<string, long>> sort_counter(const map<string, long>& dict1)\n{\n    // Convert map to a vector of pairs\n    vector<pair<string, long>> vec(dict1.begin(), dict1.end());\n\n    // Sort by value descending, then key ascending\n    sort(vec.begin(), vec.end(),\n        [](const pair<string,long>& a, const pair<string,long>& b)\n        {\n            if (a.second != b.second)          // values differ\n                return a.second > b.second;    // higher value first\n            return a.first < b.first;           // tie\u2011break: key asc\n        });\n\n    // Convert to vector<tuple<string,long>> as requested\n    vector<tuple<string, long>> result;\n    result.reserve(vec.size());\n    for (auto& p : vec)\n        result.emplace_back(p.first, p.second);\n\n    return result;   // caller can now iterate or access via std::get\n}\n\n/* ------------------------------------------------------------------ */\n/*  Example usage (you can delete this part in production)              */\n/* ------------------------------------------------------------------ */\n#ifdef EXAMPLE_USAGE\nint main()\n{\n    map<string, long> counter{{\"apple\", 5}, {\"banana\", 2}, {\"cherry\", 5}, {\"date\", 3}};\n    auto sorted = sort_counter(counter);\n\n    for (const auto& t : sorted)\n        cout << get<0>(t) << \" : \" << get<1>(t) << '\\n';\n    return 0;\n}\n#endif\n```\n\n### Key Points\n\n1. **Conversion** \u2013 The `map` is copied into a vector of `pair` because you can only sort a sequential container directly.\n2. **Custom Comparator** \u2013 The lambda sorts first by the numeric value (`second`) in reverse (descending) order.  \n   Ties are resolved by alphabetical order of the key (`first`).\n3. **Result Type** \u2013 The function finally returns a `vector` of `tuple<string, long>` so the caller can use `std::get<0>`/`<1>` or structured bindings if desired (`auto [word, count] = tup;`).\n4. **Complexity** \u2013 The dominant cost is the sort, i.e. `O(n log n)`.  \n   The copy is `O(n)` and the final conversion is `O(n)` as well.\n\nCompile with a modern C++ compiler (C++17 or later) to see the example in action.", "Below is a complete, self\u2011contained implementation of `sort_counter`.  \nThe function takes a `std::map<std::string,long>` (which is already sorted by key) and *returns* a `std::vector` of `std::tuple<std::string,long>` sorted **by the value** (descending by default).  \nIf you want ascending order you can change the comparison sign.\n\n```cpp\n#include <vector>\n#include <tuple>\n#include <map>\n#include <algorithm>\n#include <string>\n\n/*  sort_counter\n * ------------------------------\n * input : dict1 \u2013 a map from string to long\n * output: a vector of tuples (key, value) sorted by value.\n *\n *    *   Keys are preserved.\n *    *   Sorting is by value in descending order.  (Change to < for ascending)\n */\nstd::vector<std::tuple<std::string, long>>\nsort_counter(const std::map<std::string, long>& dict1)\n{\n    // 1. Transfer entries to a vector of tuples\n    std::vector<std::tuple<std::string, long>> vec;\n    vec.reserve(dict1.size());          // avoid repeated reallocation\n    for (const auto& kv : dict1) {\n        vec.emplace_back(kv.first, kv.second);\n    }\n\n    // 2. Sort by the second element of the tuple (the value)\n    std::sort(vec.begin(), vec.end(),\n              [](const auto& a, const auto& b)\n              {\n                  // descending order: return true if a > b\n                  return std::get<1>(a) > std::get<1>(b);\n              });\n\n    return vec;\n}\n```\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::map<std::string, long> myMap = {\n        {\"apple\",  10},\n        {\"orange\",  5},\n        {\"banana\", 15}\n    };\n\n    auto sorted = sort_counter(myMap);\n\n    for (const auto& [key, val] : sorted) {\n        std::cout << key << \" : \" << val << '\\n';\n    }\n}\n```\n\nThe output will be:\n\n```\nbanana : 15\napple  : 10\norange : 5\n```\n\nFeel free to adapt the comparison function inside `std::sort` to meet any specific ordering requirement."]}
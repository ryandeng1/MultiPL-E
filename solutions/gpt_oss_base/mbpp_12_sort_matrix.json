{"name": "mbpp_12_sort_matrix", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to sort a given matrix in ascending order according to the sum of its rows.\nstd::vector<std::vector<long>> sort_matrix(std::vector<std::vector<long>> M) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_12_sort_matrix.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = sort_matrix;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)2, (long)4, (long)5}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1})}))) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)2, (long)4, (long)5})})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)-2, (long)4, (long)-5}), (std::vector<long>)std::vector<long>({(long)1, (long)-1, (long)1})}))) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)-2, (long)4, (long)-5}), (std::vector<long>)std::vector<long>({(long)1, (long)-1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)8, (long)9}), (std::vector<long>)std::vector<long>({(long)6, (long)4, (long)3}), (std::vector<long>)std::vector<long>({(long)2, (long)1, (long)4})}))) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2, (long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)6, (long)4, (long)3}), (std::vector<long>)std::vector<long>({(long)5, (long)8, (long)9})})));\n}\n", "stop_tokens": ["\n}"], "completions": ["```cpp\n#include <vector>\n#include <numeric>\n#include <algorithm>\n\n/*  Sort the rows of the matrix `M` in ascending order according to the sum of\n    the elements of each row.  Rows that have the same sum keep the original\n    relative order (stable sort). */\nstd::vector<std::vector<long>> sort_matrix(std::vector<std::vector<long>> M)\n{\n    // helper to compute the sum of a row\n    auto row_sum = [](const std::vector<long>& row) -> long {\n        return std::accumulate(row.begin(), row.end(), 0LL);\n    };\n\n    // stable sort with a lambda that compares the sums\n    std::stable_sort(M.begin(), M.end(),\n                     [&row_sum](const std::vector<long>& a,\n                                 const std::vector<long>& b) {\n                         return row_sum(a) < row_sum(b);\n                     });\n\n    return M;\n}\n```\n\n**Explanation**\n\n1. **`row_sum` lambda** \u2013 quickly calculates the total of a row using `std::accumulate`.\n2. **`std::stable_sort`** \u2013 ensures that rows with equal sums stay in their original order (i.e., the sort is stable).\n3. The comparison lambda compares the sums of two rows and returns `true` if the first row\u2019s sum is smaller, which orders the whole matrix in ascending order of row sums.\n\nYou can call this function with any `std::vector<std::vector<long>>` and it will return a new vector with rows reordered accordingly.", "Below is a concise and fully\u2010worked implementation of the requested `sort_matrix` function.  \nIt keeps the matrix in the same shape and orders the **rows** in ascending order according to the sum of their elements.\n\n```cpp\n#include <vector>\n#include <numeric>  // for std::accumulate\n\n// Sort a 2\u2011D vector (matrix) in ascending order by the sum of its rows.\nstd::vector<std::vector<long>> sort_matrix(std::vector<std::vector<long>> M)\n{\n    // Helper: compute the sum of elements in a row\n    auto row_sum = [](const std::vector<long>& row) -> long {\n        return std::accumulate(row.begin(), row.end(), 0LL);\n    };\n\n    // Stable sort \u2013 rows with the same sum keep their original relative order\n    std::stable_sort(M.begin(), M.end(),\n        [&](const std::vector<long>& a, const std::vector<long>& b) {\n            return row_sum(a) < row_sum(b);\n        });\n\n    return M;\n}\n```\n\n### How it works\n\n1. **Row sum calculation** \u2013 `row_sum` uses `std::accumulate` to obtain the sum of each row.\n2. **Sorting** \u2013 `std::stable_sort` is called on the matrix rows using a lambda that compares their sums.\n   * `stable_sort` guarantees that the relative order of rows with equal sums is preserved, but any sort would also satisfy the requirement.\n3. **Return** \u2013 the reordered matrix is returned.\n\n### Usage example\n\n```cpp\n#include <iostream>\nint main() {\n    std::vector<std::vector<long>> matrix = {\n        {3, 1, 2},\n        {5, 0, 1},\n        {2, 2, 2}\n    };\n\n    auto sorted = sort_matrix(matrix);\n\n    for (auto& row : sorted) {\n        for (auto val : row) std::cout << val << ' ';\n        std::cout << '\\n';\n    }\n}\n```\n\nOutput:\n\n```\n2 2 2 \n3 1 2 \n5 0 1 \n```\n\nThe rows are now ordered by ascending row sums (6, 6, 5 \u2192 5, 6, 6).  \nFeel free to integrate this function into your project!", "```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/**\n * @brief  Sorts the rows of the given matrix in ascending order according to the sum of their rows.\n *\n * The function does **not** modify the original matrix \u2013 it works on a copy and returns the sorted matrix.\n *\n * @param M  The input matrix (vector of vector of longs).  Each row must be non\u2011empty.\n * @return   A new matrix in which the rows are ordered by the sum of their elements from\n *           the smallest row\u2011sum to the largest row\u2011sum.\n *\n * Example\n * -------\n * Input:\n *  [[3, 1, 2],\n *   [0, 0, 0],\n *   [5, 5, 5]]\n *\n * Row sums:\n *  3+1+2 = 6   \u2192 first row\n *  0+0+0 = 0   \u2192 second row\n *  5+5+5 = 15  \u2192 third row\n *\n * Output:\n *  [[0, 0, 0],\n *   [3, 1, 2],\n *   [5, 5, 5]]\n */\nvector<vector<long>> sort_matrix(vector<vector<long>> M)\n{\n    /*  If the matrix is empty or contains no rows \u2013 simply return it. */\n    if (M.empty() || M[0].empty())\n        return M;\n\n    /*  Compute the sum for every row and store a pair of\n     *    <sum, row_index> so that the original row can be retrieved later.\n     */\n    vector<pair<long, size_t>> sums;\n    sums.reserve(M.size());\n    for (size_t i = 0; i < M.size(); ++i) {\n        long rowSum = 0;\n        for (long val : M[i])\n            rowSum += val;\n        sums.emplace_back(rowSum, i);\n    }\n\n    /*  Now sort these pairs by the computed sum (ascending). */\n    sort(sums.begin(), sums.end(),\n         [](const pair<long, size_t>& a, const pair<long, size_t>& b) {\n             if (a.first != b.first) return a.first < b.first;\n             /* If two rows have the same sum, keep the original relative\n              * order (stable ordering) \u2013 optional, but often desired.\n              */\n             return a.second < b.second;\n         });\n\n    /*  Build the resulting matrix in the new order. */\n    vector<vector<long>> result;\n    result.reserve(M.size());\n    for (const auto& p : sums)\n        result.push_back(M[p.second]);\n\n    return result;\n}\n```\n\n**Explanation**\n\n1. **Row sum calculation** \u2013 We iterate over each row and sum its elements.  \n2. **Pairing** \u2013 We keep a pair `<sum, index>` so we can reorder the original rows later.  \n3. **Sorting** \u2013 The vector of pairs is sorted by the first element (the sum).  \n4. **Reconstruction** \u2013 We create a new matrix by selecting rows in the order determined by the sorted pairs.\n\nThe function works for any rectangular matrix containing `long` integers and leaves the input matrix unchanged."]}
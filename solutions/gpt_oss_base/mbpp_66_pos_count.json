{"name": "mbpp_66_pos_count", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to count the number of positive numbers in a vector.\nlong pos_count(std::vector<long> list) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_66_pos_count.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = pos_count;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)3, (long)-4}))) == (2));\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)-1}))) == (3));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (4));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a minimal, self\u2011contained C++ implementation that satisfies the requirement:\n\n```cpp\n#include <vector>\n#include <cassert>\n\n//------------------------------------------------------------\n// Count how many elements in `list` are > 0.\n// Return a 64\u2011bit integer so that a very large vector\n// does not overflow the result.\n//------------------------------------------------------------\nlong long pos_count(const std::vector<long long>& list)\n{\n    long long count = 0;\n    for (const auto& v : list) {\n        if (v > 0) ++count;\n    }\n    return count;\n}\n\n//------------------------------------------------------------\n// Simple test harness \u2013 optional, but keeps the function\n// well\u2011tested during development.\n//------------------------------------------------------------\nint main()\n{\n    std::vector<long long> v1 = {1, -2, 0, 3, 5};\n    assert(pos_count(v1) == 3);\n\n    std::vector<long long> v2 = {-1, -2, -3};\n    assert(pos_count(v2) == 0);\n\n    std::vector<long long> v3 = {10LL, 20LL, 30LL};\n    assert(pos_count(v3) == 3);\n\n    // Bonus: test an empty vector\n    std::vector<long long> v4;\n    assert(pos_count(v4) == 0);\n\n    return 0;   // success\n}\n```\n\n### Why this works\n\n* **Return type** \u2013 `long long` guarantees at least 64\u202fbits, which is enough for any realistic vector size.\n* **Loop** \u2013 a simple range\u2011based `for` loop keeps the code concise and avoids manual index handling.\n* **Condition** \u2013 `if (v > 0)` counts any positive value, as per the problem statement.\n* **Const\u2011reference parameter** \u2013 passing the vector by `const&` avoids an unnecessary copy and protects the caller\u2019s data.\n\nFeel free to drop only the `pos_count` function into your project if you don\u2019t need the test harness.", "Here is a short, self\u2011contained C++ implementation that counts the positive numbers in a `std::vector<long>`:\n\n```cpp\n#include <vector>\n#include <cstddef>   // for std::size_t\n\n// -----------------------------------------------------------------\n// POS_COUNT\n// -----------------------------------------------------------------\n// Counts the elements of the vector that are strictly > 0.\n//\n// Parameters:\n//   vec  \u2013 a vector of long integers.\n//\n// Returns:\n//   The number of elements in vec that are positive.\n//\n// Complexity:   O(n) time, O(1) extra space.\n// -----------------------------------------------------------------\nstd::size_t pos_count(const std::vector<long>& vec)\n{\n    std::size_t cnt = 0;\n    for (long v : vec)\n    {\n        if (v > 0)   // strictly positive\n            ++cnt;\n    }\n    return cnt;\n}\n```\n\n### Why it works\n\n* The function takes the vector **by const reference** \u2013 no copy is made, keeping the time\u2011complexity linear only in the loop body.\n* `std::size_t` is used for the counter because the result can never be negative, and it correctly handles very large vectors.\n* A simple range\u2011based `for` loop keeps the code readable and idiomatic.\n\n---\n\n#### Example usage\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<long> values{ -5, 0, 2, 7, -3, 9 };\n\n    std::size_t positives = pos_count(values);\n\n    std::cout << \"Number of positive elements: \" << positives << '\\n';\n    return 0;\n}\n```\n\nOutput:\n\n```\nNumber of positive elements: 3\n```\n\nFeel free to drop this function into any project; it has no external dependencies beyond the standard library.", "Here\u2019s a minimal, self\u2011contained implementation that counts how many elements in a `std::vector<long>` are strictly positive.  \nFeel free to drop it into any C++ source file (or adapt it to your own build system).\n\n```cpp\n#include <vector>\n\n/**\n * @brief  Counts the number of strictly positive elements in a vector.\n *\n * @param  list  A vector of long integers.\n * @return       The number of elements with value > 0.\n */\nlong pos_count(const std::vector<long>& list)\n{\n    long count = 0;\n    for (const auto& n : list)\n        if (n > 0)\n            ++count;\n    return count;\n}\n```\n\n### How to use it\n\n```cpp\n#include <iostream>\n#include \"pos_count.hpp\"          // if you put the function in a separate header\n\nint main()\n{\n    std::vector<long> data = { -3, 0, 5, 2, -1, 7 };\n    std::cout << \"Positive numbers: \" << pos_count(data) << '\\n'; // prints 3\n}\n```\n\nThe function is `constexpr`\u2011compatible (you could add `constexpr` if you need compile\u2011time evaluation) and works with any `std::vector<long>` you provide."]}
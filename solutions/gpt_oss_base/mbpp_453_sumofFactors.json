{"name": "mbpp_453_sumofFactors", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to find the sum of even factors of a number.\nlong sumofFactors(long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_453_sumofFactors.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = sumofFactors;\n    assert(candidate((18)) == (26));\n    assert(candidate((30)) == (48));\n    assert(candidate((6)) == (8));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a **stand\u2011alone C++ implementation** that computes the sum of **all even divisors** of a positive integer `n`.  \nThe routine is written in a style that compiles with any modern C++ compiler (C++11/14/17/20) and contains brief comments to explain the key steps.\n\n```cpp\n//  sum_of_even_factors.cpp\n//  ------------------------\n//  Computes the sum of all even divisors of a given positive integer.\n//\n//  Author\u00a0: <Your Name>\n//  License: MIT (or whatever you wish)\n//  ------------------------------------------------------------\n\n#include <cassert>\n#include <cstdint>      // for std::int64_t\n#include <iostream>\n#include <cmath>        // for std::sqrt, std::floor\n\n/**\n * @brief  Sum of even factors (divisors) of `n`.\n *\n * The algorithm iterates over all divisors up to \u221an.\n * For each divisor `d`, its complementary divisor `n/d` is also considered.\n * Only even divisors are added to the running total.\n *\n * @param n  Positive integer whose even divisors are to be summed.\n * @return Sum of all even divisors of `n`. If `n` is odd, the result is 0.\n */\nint64_t sumOfEvenFactors(int64_t n)\n{\n    assert(n > 0);                 // The function is defined for positive n.\n\n    if (n % 2 == 1)                 // Odd numbers have no even divisors.\n        return 0;\n\n    int64_t sum = 0;\n    const int64_t limit = static_cast<int64_t>(std::sqrt(static_cast<long double>(n)));\n\n    for (int64_t d = 1; d <= limit; ++d) {\n        if (n % d == 0) {           // d is a divisor\n            int64_t other = n / d; // complementary divisor\n\n            // add d if it is even\n            if ((d & 1) == 0)\n                sum += d;\n\n            // add other if it is a different number and even\n            if (other != d && (other & 1) == 0)\n                sum += other;\n        }\n    }\n\n    return sum;\n}\n\n// --------------------------\n// Example usage & tests\n// --------------------------\nint main()\n{\n    // Simple manual test cases\n    std::cout << \"sumOfEvenFactors(12) = \" << sumOfEvenFactors(12) << '\\n';   // 2 + 4 + 6 + 12 = 24\n    std::cout << \"sumOfEvenFactors(15) = \" << sumOfEvenFactors(15) << '\\n';   // 0 (15 is odd)\n    std::cout << \"sumOfEvenFactors(28) = \" << sumOfEvenFactors(28) << '\\n';   // 2 + 4 + 6 + 14 + 28 = 54\n\n    // Optional automated checks\n    assert(sumOfEvenFactors(1) == 0);\n    assert(sumOfEvenFactors(2) == 2);\n    assert(sumOfEvenFactors(6) == 2 + 6);   // 8\n\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\n### How the routine works\n\n1. **Edge case** \u2013 If `n` is odd (`n % 2 == 1`) it cannot have an even factor, so the result is `0`.\n\n2. **Loop up to \u221an** \u2013 Every divisor `d` of `n` has a partner `other = n / d`.  \n   By iterating only up to `\u221an`, we consider both members of each divisor pair exactly once.\n\n3. **Evenness check** \u2013 We use bitwise AND with `1` (`d & 1`) rather than `% 2` for a tiny performance boost.\n\n4. **Sum** \u2013 Add each even divisor to `sum`, ensuring that when `d == other` we don't double\u2011count.\n\nThe function runs in **O(\u221an)** time and uses **O(1)** additional space. It is suitable for `n` up to the limits of a 64\u2011bit integer (\u22489\u00b710\u00b9\u2078).", "Here\u2019s a compact yet clear C++ implementation that returns the sum of all **even** divisors of a positive integer\u202f`n`.  \nThe routine runs in `O(\u221an)` time \u2013 only the factors up to the square root are investigated, and each factor is counted once.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*  Sum of even factors of a positive integer n\n    Complexity:  O(\u221an)\n    If n is 0 or negative the result is 0.         */\nlong long sumOfEvenFactors(long long n)\n{\n    if (n <= 0) return 0;                // no positive factors otherwise\n\n    long long sum = 0;\n    for (long long i = 1; i * i <= n; ++i)\n    {\n        if (n % i == 0)            // i is a divisor\n        {\n            long long d1 = i;       // first divisor\n            long long d2 = n / i;   // paired divisor\n\n            if (d1 % 2 == 0) sum += d1;   // add only if even\n            if (d2 != d1 && d2 % 2 == 0) sum += d2; // avoid duplication\n        }\n    }\n    return sum;\n}\n\n/* Example usage & simple test harness */\nint main()\n{\n    vector<long long> tests{12, 27, 34, 1, 0, -5, 1000};\n    for (auto n : tests)\n    {\n        cout << \"Sum of even factors of \" << n << \" = \"\n             << sumOfEvenFactors(n) << '\\n';\n    }\n    return 0;\n}\n```\n\n### What the code does\n\n1. **Early exit** \u2013 For non\u2011positive inputs the function returns `0`.\n2. **Loop over divisors** \u2013 Iterate `i` from `1` to `\u221an`.  \n   When `i` divides `n`, both `i` and `n/i` are divisors.\n3. **Even check** \u2013 Only add those divisors that are divisible by `2`.  \n   The paired divisor is added only if it's distinct from `i` to avoid double\u2011counting the square root when `i*i == n`.\n4. **Result** \u2013 Return the accumulated sum.\n\nFeel free to drop the `main` function into your project or adjust the test cases as needed.", "Below is a compact, ready\u2011to\u2011paste C++11/14 implementation that\n\n* iterates only up to `\u221an`,\n* collects both divisors of each pair,\n* keeps only the even ones, and afterwards returns their sum.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// @brief  Returns the sum of all even divisors of n.\n/// @param  n  The number whose even divisors are to be summed.\n/// @return The sum of all even divisors of n.\n///\n/// Complexity:  O(\u221an) time, O(1) extra memory.\n/// Edge cases:  if n <= 1, the sum is 0 (no positive even divisor).\nlong long sumEvenFactors(long long n)\n{\n    if (n <= 1)                 // 1 has no positive even divisor\n        return 0;\n\n    long long sum = 0;\n    for (long long d = 1; d * d <= n; ++d)\n    {\n        if (n % d == 0)\n        {\n            long long e = n / d;          // complementary divisor\n            if (d % 2 == 0)   sum += d;   // d is even\n            if (e != d && e % 2 == 0)     // avoid double\u2011counting perfect square\n                sum += e;\n        }\n    }\n    return sum;\n}\n\n// ---------------------\n// Example usage + test:\n// ---------------------\n\n#ifdef UNIT_TEST\nint main()\n{\n    vector<pair<long long,long long>> tests = {\n        {1, 0}, {2, 2}, {12, 12}, {15, 0}, {36, 48}\n    };\n\n    for (auto [num, expected] : tests) {\n        long long result = sumEvenFactors(num);\n        assert(result == expected);\n        cout << \"n = \" << num << \" \u2192 sumEvenFactors = \" << result << '\\n';\n    }\n    cout << \"All tests passed!\\n\";\n    return 0;\n}\n#endif\n```\n\n### Why this works\n\n1. **Loop up to \u221an** \u2013 Every divisor `d` (\u2264\u221an) has a counterpart `n/d`.  \n   Checking only up to \u221an guarantees we examine every pair exactly once.\n\n2. **Even check** \u2013 A divisor is added to `sum` only if `d % 2 == 0` (or its partner `e`).\n\n3. **No double\u2011counting** \u2013 When `n` is a perfect square, `d == e`; we add it only once.\n\n4. **Edge cases** \u2013 For `n = 1` or any odd `n`, the loop finds no even divisor, so the function returns 0.\n\nFeel free to drop the `#ifdef UNIT_TEST` section into a test harness or compile the file with `-DUNIT_TEST` to run the self\u2011contained checks."]}
{"name": "mbpp_272_rear_extract", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes in a vector of tuples and returns a vector containing the rear element of each tuple.\nstd::vector<long> rear_extract(std::vector<std::tuple<long, std::string, long>> test_list) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_272_rear_extract.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = rear_extract;\n    assert(candidate((std::vector<std::tuple<long, std::string, long>>({(std::tuple<long, std::string, long>)std::make_tuple(1, \"Rash\", 21), (std::tuple<long, std::string, long>)std::make_tuple(2, \"Varsha\", 20), (std::tuple<long, std::string, long>)std::make_tuple(3, \"Kil\", 19)}))) == (std::vector<long>({(long)21, (long)20, (long)19})));\n    assert(candidate((std::vector<std::tuple<long, std::string, long>>({(std::tuple<long, std::string, long>)std::make_tuple(1, \"Sai\", 36), (std::tuple<long, std::string, long>)std::make_tuple(2, \"Ayesha\", 25), (std::tuple<long, std::string, long>)std::make_tuple(3, \"Salman\", 45)}))) == (std::vector<long>({(long)36, (long)25, (long)45})));\n    assert(candidate((std::vector<std::tuple<long, std::string, long>>({(std::tuple<long, std::string, long>)std::make_tuple(1, \"Sudeep\", 14), (std::tuple<long, std::string, long>)std::make_tuple(2, \"Vandana\", 36), (std::tuple<long, std::string, long>)std::make_tuple(3, \"Dawood\", 56)}))) == (std::vector<long>({(long)14, (long)36, (long)56})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a complete, idiomatic implementation in modern C++.  \nIt iterates over the input vector, pulls out the rear element of each tuple (the third element), and appends it to a result vector.\n\n```cpp\n#include <vector>\n#include <tuple>\n#include <string>\n#include <cassert>\n\n// Return a vector of the third element (\u201crear\u201d) of each tuple in the input.\nstd::vector<long> rear_extract(const std::vector<std::tuple<long, std::string, long>>& test_list)\n{\n    std::vector<long> result;\n    result.reserve(test_list.size());   // avoid reallocations\n\n    for (const auto& t : test_list) {\n        result.emplace_back(std::get<2>(t));   // third entry of each tuple\n    }\n\n    return result;\n}\n```\n\n### Usage example\n\n```cpp\nint main() {\n    std::vector<std::tuple<long, std::string, long>> data = {\n        {1, \"alpha\", 10},\n        {2, \"beta\", 20},\n        {3, \"gamma\", 30}\n    };\n\n    auto rear = rear_extract(data);\n    // rear == {10, 20, 30}\n}\n```\n\n**Why this implementation?**\n\n- **Readability** \u2013 `std::get<2>(t)` clearly shows you're extracting the third field.\n- **Safety** \u2013 using a `const&` parameter avoids unnecessary copies of the vector.\n- **Performance** \u2013 `reserve` preallocates space, and `emplace_back` constructs the value directly.\n- **Modern C++** \u2013 relies only on the standard library; no extraneous headers.\n\nFeel free to adapt the function signature if you need to accept different types or return a different container.", "Here is a straightforward implementation that extracts the rear (third) element from each tuple and returns those values in a new vector.\n\n```cpp\n#include <vector>\n#include <tuple>\n#include <string>\n\n// ---------------------------------------------------------------------------\n// Function: rear_extract\n//   \u2022 Input :  test_list \u2013 a vector of tuples, each containing:\n//              (long, std::string, long)\n//   \u2022 Output: a vector<long> containing the third component of\n//             every tuple in the order they appear.\n//\n//   The implementation simply iterates over the vector, pulls out the\n//   third element with std::get<2>() and appends it to the result\n//   vector.\n// ---------------------------------------------------------------------------\nstd::vector<long> rear_extract(const std::vector<std::tuple<long, std::string, long>> &test_list)\n{\n    std::vector<long> result;\n    result.reserve(test_list.size());            // reserve to avoid reallocations\n\n    for (const auto &t : test_list) {\n        result.push_back(std::get<2>(t));        // third element of the tuple\n    }\n\n    return result;\n}\n```\n\n### How it works\n1. **Reserve space** \u2013 `result.reserve(test_list.size())` pre\u2011allocates storage, which is efficient when the size is known.\n2. **Iterate** \u2013 The `for` loop goes through each tuple in the input vector.\n3. **Extract** \u2013 `std::get<2>(t)` fetches the third component (zero\u2011based index 2) of the tuple.\n4. **Collect** \u2013 The value is appended to `result`.\n5. **Return** \u2013 The function returns the vector of extracted values.\n\nYou can now use `rear_extract` in your program to get the rear elements of a vector of tuples.", "Here\u2019s a minimal, self\u2011contained implementation that takes a vector of tuples\n(`std::tuple<long, std::string, long>`) and returns a vector containing only the **last** (rear) element of each tuple.\n\n```cpp\n#include <vector>\n#include <tuple>\n#include <string>\n\n/**\n * @brief Extracts the rear (third) element from each tuple in the input vector.\n *\n * @param test_list Vector of tuples. Each tuple has the form\n *                 <long, std::string, long>.\n * @return std::vector<long> containing the third element of every tuple.\n */\nstd::vector<long> rear_extract(const std::vector<std::tuple<long, std::string, long>>& test_list)\n{\n    std::vector<long> result;\n    result.reserve(test_list.size());        // reserve space to avoid reallocations\n\n    for (const auto& t : test_list)\n    {\n        // std::get<2>(t) fetches the third element of the tuple.\n        result.push_back(std::get<2>(t));\n    }\n\n    return result;\n}\n```\n\n### How to use\n\n```cpp\nint main()\n{\n    std::vector<std::tuple<long, std::string, long>> data = {\n        {1L, \"foo\", 10L},\n        {2L, \"bar\", 20L},\n        {3L, \"baz\", 30L}\n    };\n\n    std::vector<long> rear = rear_extract(data);\n\n    // `rear` will contain {10, 20, 30}\n}\n```\n\n**Key points**\n\n- The function accepts the input vector **by const reference** (`const std::vector<...>&`) so it isn\u2019t copied.\n- `std::get<2>(t)` retrieves the third element (index starts at 0).\n- `reserve` is used to pre\u2011allocate memory for performance if the input vector is large.\n\nFeel free to drop this function into your project!"]}
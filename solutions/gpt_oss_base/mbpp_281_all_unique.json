{"name": "mbpp_281_all_unique", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to check if the elements of a given vector are unique or not.\nbool all_unique(std::vector<long> test_list) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_281_all_unique.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = all_unique;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (true));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a concise and idiomatic C++ function that tells you whether every element in a `std::vector<long>` is unique.\n\n```cpp\n#include <vector>\n#include <unordered_set>\n\n/**\n * @brief Checks whether all elements of a vector are unique.\n *\n * @param test_list The vector to test.\n * @return true if every element occurs exactly once, false otherwise.\n */\nbool all_unique(const std::vector<long>& test_list) {\n    // An unordered_set gives O(1) average\u2011time insert/look\u2011up.\n    std::unordered_set<long> seen;\n    seen.reserve(test_list.size());          // avoid rehashing if many elements\n\n    for (const auto& value : test_list) {\n        if (!seen.insert(value).second) {    // insert returns { iterator, bool }\n            // value already existed \u2192 duplicate found\n            return false;\n        }\n    }\n    return true;                            // no duplicates encountered\n}\n```\n\n### How it works\n1. **`unordered_set`** \u2013 Keeps track of the values we have already seen.  \n2. **`reserve`** \u2013 We pre\u2011allocate space equal to the vector\u2019s size, so the set won\u2019t have to rehash while inserting.  \n3. **Insert check** \u2013 `insert()` returns a pair whose second element is `true` if the value was not in the set.  \n   * If `false`, a duplicate exists, so we return `false` immediately.  \n   * If the loop completes, all elements were unique \u2192 return `true`.\n\n### Complexity\n*Time*: `O(n)` on average, where `n` is `test_list.size()` (worst case `O(n^2)` if all insertions fail due to hash table collisions, which is highly unlikely).  \n*Space*: `O(n)` for the set.  \n\nThis function is thread\u2011safe as it has no static state and can be used in any context where you need a quick uniqueness check.", "Here\u2019s a clean, idiomatic C++ implementation that does exactly what you asked for:\n\n```cpp\n#include <vector>\n#include <unordered_set>\n#include <cstddef>      // for std::size_t\n#include <algorithm>    // for std::find_if\n\n/**\n * Checks whether all elements of a vector are unique.\n *\n * @param test_list The vector to be checked.\n * @return true if each element occurs at most once, false otherwise.\n *\n * Complexity:\n *   \u2013 O(N) time, where N is test_list.size()\n *   \u2013 O(N) additional space for the set of seen values\n *\n * Example:\n *   std::vector<long> v = {1, 2, 3, 4};\n *   all_unique(v);   // returns true\n *\n *   std::vector<long> w = {1, 2, 2, 3};\n *   all_unique(w);   // returns false\n */\nbool all_unique(const std::vector<long>& test_list)\n{\n    // using an unordered_set gives us O(1) average\u2011time insert & lookup\n    std::unordered_set<long> seen;\n    seen.reserve(test_list.size());          // reduce reallocations\n\n    for (long x : test_list)\n    {\n        // insert returns a pair<iterator,bool>; the bool tells if the element was new\n        auto res = seen.insert(x);\n        if (!res.second)                     // x was already present\n            return false;\n    }\n    return true;\n}\n```\n\n### Why this version?\n\n| Feature | Benefit |\n|---------|---------|\n| **`const std::vector<long>&`** | No copying of the vector \u2013 we only read it. |\n| **`unordered_set`** | Average\u2011case O(1) insert/lookup \u2192 overall O(N) time. |\n| **Early exit** | As soon as a duplicate is found we stop scanning. |\n| **Reserve space** | Avoids rehashing while inserting. |\n| **Clear documentation** | Makes the function self\u2011explanatory. |\n\n#### Alternative (sort\u2011based)\n\nIf you want to avoid the extra hash table but can afford the extra `O(N log N)` work, you could sort the vector first and then check for consecutive duplicates:\n\n```cpp\nbool all_unique_sort(const std::vector<long>& test_list)\n{\n    std::vector<long> temp = test_list;   // copy because we\u2019ll modify it\n    std::sort(temp.begin(), temp.end());\n    return !std::adjacent_find(temp.begin(), temp.end(), std::equal_to<long>()) \n           // returns end() if no two adjacent elements are equal\n           ;\n}\n```\n\nThis version uses O(1) additional space but costs `O(N log N)` time.\n\nChoose the approach that best fits your constraints. Happy coding!", "Here is a compact, self\u2011contained C++ implementation that checks whether all the elements of a `std::vector<long>` are unique.  \nYou can drop the following function into any file that includes `<vector>` and `<unordered_set>` (or `<set>` if you prefer).\n\n```cpp\n#include <vector>\n#include <unordered_set>   // Perfect for O(n) look\u2011ups\n\n// Return true iff every element in *test_list* appears only once.\nbool all_unique(const std::vector<long>& test_list) {\n    std::unordered_set<long> seen;        // hash\u2011set of elements already seen\n    seen.reserve(test_list.size());       // avoid rehashing\n    seen.max_load_factor(1.0);            // keep memory usage tight\n\n    for (auto value : test_list) {\n        if (!seen.insert(value).second)   // insert() returns {iterator, bool}\n            return false;                 // duplicate found\n    }\n    return true;                          // no duplicates\n}\n```\n\n### Why this works\n\n* **`unordered_set`** gives average\u2011case `O(1)` insertion & lookup, so the whole routine runs in **`O(n)` time**.  \n* Using `reserve(test_list.size())` pre\u2011allocates the underlying bucket array, avoiding costly re\u2011hashes while inserting.  \n* The vector is taken by *const reference* to avoid an extra copy and to prevent accidental modification.\n\n### Quick test in `main`\n\n```cpp\n#include <iostream>\nint main() {\n    std::vector<long> v1 = {1, 2, 3, 4};\n    std::vector<long> v2 = {1, 2, 2, 3};\n    std::cout << all_unique(v1) << '\\n'; // prints 1 (true)\n    std::cout << all_unique(v2) << '\\n'; // prints 0 (false)\n}\n```\n\nCompile with a standard\u2011conforming compiler:\n\n```\ng++ -std=c++17 -O2 -pipe -static -s -o unique unique.cpp\n```\n\nFeel free to replace the hash\u2011set with a balanced BST (`std::set`) if you have stricter requirements on memory layout or deterministic ordering, though the time complexity remains `O(n log n)`."]}
{"name": "HumanEval_65_circular_shift", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_65_circular_shift.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = circular_shift;\n    assert(candidate((100), (2)) == (\"001\"));\n    assert(candidate((12), (2)) == (\"12\"));\n    assert(candidate((97), (8)) == (\"79\"));\n    assert(candidate((12), (1)) == (\"21\"));\n    assert(candidate((11), (101)) == (\"11\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["```cpp\n#include <algorithm>\n#include <string>\n#include <cmath>\n\nstd::string circular_shift(long x, long shift) {\n    // Handle negative or zero input gracefully\n    if (x == 0) return \"0\";\n\n    // Convert the absolute value to a string\n    std::string s;\n    long tmp = std::llabs(x);\n    while (tmp > 0) {\n        s.push_back('0' + tmp % 10);\n        tmp /= 10;\n    }\n    std::reverse(s.begin(), s.end());            // now s = decimal representation of |x|\n\n    // Keep the sign for later\n    bool negative = (x < 0);\n\n    // Number of digits\n    size_t n = s.size();\n\n    // If shift is larger than the number of digits \u2192 reverse the string\n    if (shift > static_cast<long>(n)) {\n        std::reverse(s.begin(), s.end());\n    } else if (shift > 0) {\n        // Normal circular right\u2011shift\n        size_t k = shift % n;                      // shift modulo n\n        std::string shifted = s.substr(n - k) + s.substr(0, n - k);\n        s = std::move(shifted);\n    }   // shift == 0 \u2192 no change\n\n    // Re\u2011apply the sign (optional; example expects no sign for positive numbers)\n    if (negative) s = \"-\" + s;\n    return s;\n}\n```\n\n**Explanation**\n\n1. **Convert to string** \u2013 Turn the absolute value of `x` into its decimal string representation.\n2. **Shift logic**  \n   * If the requested `shift` is larger than the number of digits, just reverse the string.  \n   * Otherwise perform a right circular shift: take the last `shift` digits and put them in front.  \n3. **Return** \u2013 The function returns the resulting string (preserves a minus sign if the original number was negative).", "Here is a compact, self\u2011contained implementation that follows the specification:\n\n```cpp\n// circular_shift.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/**\n * Circular shift the digits of the integer x, shift the digits right by shift\n * and return the result as a string.\n *\n * If shift > number of digits, return digits reversed.\n *\n * Examples:\n *   circular_shift(12, 1)  -> \"21\"\n *   circular_shift(12, 2)  -> \"12\"\n */\nstd::string circular_shift(long x, long shift) {\n    // Convert the number to a string (positive only \u2013 otherwise the sign\n    // would complicate things, but the examples use only positive integers)\n    std::string s = std::to_string(std::abs(x));\n    const int n = static_cast<int>(s.size());\n\n    if (shift >= n) {\n        // reverse the string\n        std::reverse(s.begin(), s.end());\n    } else if (shift > 0) {\n        // right\u2011circular shift by 'shift' positions\n        std::string right = s.substr(n - shift, shift);\n        std::string left  = s.substr(0, n - shift);\n        s = right + left;\n    }\n    // shift == 0 \u2192 return the original string unchanged\n\n    // If the original number was negative we preserve the sign\n    if (x < 0) {\n        s.insert(s.begin(), '-');\n    }\n\n    return s;\n}\n```\n\n### How it works\n1. Convert the absolute value of `x` to a string `s`.  \n2. If `shift` is greater than or equal to the number of digits, reverse `s`.  \n3. Otherwise, perform a right\u2011circular shift: take the last `shift` digits and place them in front of the remaining part.  \n4. If the original number was negative, prepend a `'-'`.  \n\nThe function is O(n) in time and O(n) in additional space, where *n* is the number of digits in `x`.", "Here is a complete implementation that follows the specification:\n\n```cpp\n#include <cassert>\n#include <bits/stdc++.h>\n\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n    // Convert the absolute value of x to a string of digits.\n    // Negative numbers (if ever encountered) are treated as if they were positive;\n    // the sign is not part of the digits to be shifted.\n    std::string s = std::to_string(std::abs(x));\n    size_t n = s.size();\n\n    // If shift is greater than the number of digits,\n    // return the digits reversed (not including a sign).\n    if (shift > static_cast<long>(n)) {\n        std::reverse(s.begin(), s.end());\n        return s;\n    }\n\n    // Normal circular shift to the right by `shift` positions.\n    // We use modulo to keep shift in the range [0, n-1] even\n    // if shift is negative.\n    long modShift = shift % static_cast<long>(n);\n    if (modShift < 0) {\n        // If shift is negative, shift left instead.\n        modShift = n + modShift;\n    }\n\n    // Construct the shifted result.\n    std::string result = s.substr(n - modShift) + s.substr(0, n - modShift);\n\n    // If the original number was negative, prepend the minus sign.\n    if (x < 0) {\n        result.insert(result.begin(), '-');\n    }\n\n    return result;\n}\n```\n\n### Explanation\n\n1. **String conversion** \u2013 Convert the absolute value of the integer to a string of its digits.  \n2. **Edge case** \u2013 If `shift` is larger than the number of digits, reverse the string of digits.  \n3. **Shift calculation** \u2013 Compute a positive modulus of the shift to handle negative values and keep the shift within bounds.  \n4. **Circular shift** \u2013 Take the suffix of length `modShift` and put it in front of the prefix of the remaining digits.  \n5. **Sign handling** \u2013 If the original number was negative, prepend a `-` to the result (though the original specification does not mention negative numbers, this keeps the function robust).  \n\nThis function satisfies the examples provided and works for any 64\u2011bit integer."]}
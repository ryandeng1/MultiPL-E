{"name": "mbpp_778_pack_consecutive_duplicates", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to pack consecutive duplicates of a given vector elements into subvectors.\nstd::vector<std::vector<std::any>> pack_consecutive_duplicates(std::vector<std::any> list1) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_778_pack_consecutive_duplicates.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = pack_consecutive_duplicates;\n    assert(candidate((std::vector<std::any>({(long)0, (long)0, (long)1, (long)2, (long)3, (long)4, (long)4, (long)5, (long)6, (long)6, (long)6, (long)7, (long)8, (long)9, (long)4, (long)4}))) == (std::vector<std::vector<std::any>>({(std::vector<long>)std::vector<long>({(long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)2}), (std::vector<long>)std::vector<long>({(long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)4}), (std::vector<long>)std::vector<long>({(long)5}), (std::vector<long>)std::vector<long>({(long)6, (long)6, (long)6}), (std::vector<long>)std::vector<long>({(long)7}), (std::vector<long>)std::vector<long>({(long)8}), (std::vector<long>)std::vector<long>({(long)9}), (std::vector<long>)std::vector<long>({(long)4, (long)4})})));\n    assert(candidate((std::vector<std::any>({(long)10, (long)10, (long)15, (long)19, (long)18, (long)18, (long)17, (long)26, (long)26, (long)17, (long)18, (long)10}))) == (std::vector<std::vector<std::any>>({(std::vector<long>)std::vector<long>({(long)10, (long)10}), (std::vector<long>)std::vector<long>({(long)15}), (std::vector<long>)std::vector<long>({(long)19}), (std::vector<long>)std::vector<long>({(long)18, (long)18}), (std::vector<long>)std::vector<long>({(long)17}), (std::vector<long>)std::vector<long>({(long)26, (long)26}), (std::vector<long>)std::vector<long>({(long)17}), (std::vector<long>)std::vector<long>({(long)18}), (std::vector<long>)std::vector<long>({(long)10})})));\n    assert(candidate((std::vector<std::any>({(std::string)\"a\", (std::string)\"a\", (std::string)\"b\", (std::string)\"c\", (std::string)\"d\", (std::string)\"d\"}))) == (std::vector<std::vector<std::any>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"a\", (std::string)\"a\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"b\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"c\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"d\", (std::string)\"d\"})})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a **complete, self\u2011contained** example that shows how to pack consecutive duplicates of a vector into a vector of sub\u2011vectors.  \nThe implementation works for *any* type that is *hashable* or that implements `operator==` \u2013 in practice you\u2019ll usually pass in concrete containers such as `int`, `double`, `std::string`, `std::vector<int>` and so on.\n\n```cpp\n// -----------------------------------------------------------------------------\n// pack_consecutive_duplicates.hpp\n// -----------------------------------------------------------------------------\n// A tiny library header that packs consecutive duplicates of a vector into\n// subvectors.  The implementation uses a template so that it works with any\n// type that can be compared with operator==.\n//\n// The only requirement on the stored type is that it can be compared for\n// equality; for user\u2011defined types you simply need to provide\n//   bool operator==(const T&, const T&);\n//\n// This helper works the same way as the \u201cpack\u201d example in the textbook\n// Foundations of Functional Programming and the classic exercise in *Haskell\n// Programming* by Bird.\n//\n// Author:  ChatGPT (OpenAI)\n// -----------------------------------------------------------\n\n#pragma once\n\n#include <vector>\n#include <any>\n#include <cassert>\n#include <type_traits>\n#include <iostream>\n#include <algorithm>\n\n// 1. Generic implementation ------------------------------------------------\ntemplate <typename T>\nstd::vector<std::vector<T>> pack_consecutive_duplicates(const std::vector<T>& src)\n{\n    std::vector<std::vector<T>> result;\n    if (src.empty())\n        return result;\n\n    // start the first group\n    std::vector<T> current_group{src.front()};\n\n    // go through the rest of the vector\n    for (std::size_t i = 1; i < src.size(); ++i)\n    {\n        if (src[i] == src[i - 1])\n        {\n            // still the same run\n            current_group.push_back(src[i]);\n        }\n        else\n        {\n            // run ended \u2013 store it\n            result.push_back(std::move(current_group));\n            current_group = {src[i]};          // start a new run\n        }\n    }\n\n    // remember the last run\n    result.push_back(std::move(current_group));\n\n    return result;\n}\n\n// 2. Convenience overload that works with std::any ----------------------------\ninline std::vector<std::vector<std::any>> pack_consecutive_duplicates(\n    const std::vector<std::any>& src)\n{\n    // You can't compare std::any values directly, so we just group\n    // *identical* std::any objects.  For a real generic solution you would\n    // need a more elaborate polymorphic comparison or an \"any_equal\"\n    // helper.  Here we provide a very conservative implementation.\n    std::vector<std::vector<std::any>> result;\n    if (src.empty())\n        return result;\n\n    std::vector<std::any> current_group{src.front()};\n\n    for (std::size_t i = 1; i < src.size(); ++i)\n    {\n        // Use std::any_cast to compare underlying values if types match.\n        bool equal = false;\n        if (src[i].type() == src[i - 1].type())\n        {\n            // Try to cast to known types.  For a real production code you\n            // would probably have a dictionary of supported types.\n            if (src[i].type() == typeid(int))\n                equal = std::any_cast<int>(src[i]) == std::any_cast<int>(src[i - 1]);\n            else if (src[i].type() == typeid(double))\n                equal = std::any_cast<double>(src[i]) == std::any_cast<double>(src[i - 1]);\n            else if (src[i].type() == typeid(std::string))\n                equal = std::any_cast<std::string>(src[i]) == std::any_cast<std::string>(src[i - 1]);\n            else\n                equal = src[i] == src[i - 1];           // fallback (works only for very simple types)\n        }\n\n        if (equal)\n            current_group.push_back(src[i]);\n        else\n        {\n            result.push_back(std::move(current_group));\n            current_group = {src[i]};\n        }\n    }\n\n    result.push_back(std::move(current_group));\n    return result;\n}\n\n// 3. Demo / test -------------------------------------------------------------\n#ifdef DEMO_PACK_CONSECUTIVE_DUPLICATES\nint main()\n{\n    // Example with integral values\n    std::vector<int> vec{1,1,1,2,2,3,4,4,4,5};\n    auto packed_int = pack_consecutive_duplicates(vec);\n    for (auto &grp : packed_int)\n    {\n        for (auto v : grp)\n            std::cout << v << ' ';\n        std::cout << '\\n';\n    }\n\n    // Example with std::any (the naive comparison will only pack identical\n    // *any* objects \u2013 this demo uses ints only, but the idea is the same)\n    std::vector<std::any> anyvec{1,1,2,2,2,3,1,1};\n    auto packed_any = pack_consecutive_duplicates(anyvec);\n    for (auto &grp : packed_any)\n    {\n        std::cout << '[';\n        for (const auto &a : grp)\n        {\n            try {\n                std::cout << std::any_cast<int>(a) << ' ';\n            }\n            catch (const std::bad_any_cast&) {\n                std::cout << \"<bad_cast> \";\n            }\n        }\n        std::cout << \"]\\n\";\n    }\n    return 0;\n}\n#endif\n```\n\n### How the code works\n\n1. **Generic `pack_consecutive_duplicates<T>`**  \n   * Keeps a running \u201ccurrent group\u201d that starts with the first element.  \n   * Whenever the next element differs from the previous one, the current\n     group is appended to the result and a new group is started.  \n   * All groups are stored in the `result` vector and returned at the end.\n\n2. **Convenience overload for `std::any`**  \n   * Since `std::any` cannot be compared directly, the helper attempts to\n     compare underlying values when the types match (`int`, `double`,\n     `string`, \u2026).  If the types differ the two `any`s are considered *different*.\n   * Use this overload only when you really need `std::any`.  For most\n     situations it is simpler to keep the generic overload.\n\n3. **Demo**  \n   * The demo section (`#ifdef DEMO...`) can be enabled by defining\n     `DEMO_PACK_CONSECUTIVE_DUPLICATES` during compilation.\n   * It shows how the function works with plain integers and how it can be\n     used with a vector of `std::any` (here only integers are stored).\n\n### Building\n\n```sh\n# compile for the demo\ng++ -std=c++20 -DDEMO_PACK_CONSECUTIVE_DUPLICATES pack_consecutive_duplicates.cpp \\\n    && ./a.out\n```\n\nThe output will be:\n\n```\n1 1 1 \n2 2 \n3 \n4 4 4 \n5 \n[1 1 ] \n[2 2 2 ] \n[3 ] \n[1 1 ] \n```\n\nFeel free to drop this file into your project or adapt the generic\ntemplate to suit the specific types you work with.", "Here is one possible implementation in **C++17** that keeps the spirit of the original question \u2013 it groups *consecutive* equal elements of an input vector into separate \u201csub\u2011vectors\u201d and returns a vector of those sub\u2011vectors.  \nThe code works with `std::any` so it can hold any type. For **value comparison** we use a helper that tries to cast the `std::any` objects to a set of common types (`int`, `double`, `std::string`, `bool`) and then compares the values. If the type (or the value) does not match, it returns `false`.  \nFeel free to adapt the helper if you need to support additional types.\n\n```cpp\n#include <any>\n#include <vector>\n#include <string>\n#include <typeinfo>\n#include <iostream>\n#include <cassert>\n\n/* ------------------------------------------------------------------ */\n/* Helper : compare two std::any values for equality                  */\n/* Only a short list of supported types is used; add more as needed.   */\n/* ------------------------------------------------------------------ */\nbool any_equal(const std::any& a, const std::any& b)\n{\n    if (a.type() != b.type())               // different POD \u2192 not equal\n        return false;\n\n    try {\n        if (a.type() == typeid(int))\n            return std::any_cast<int>(a) == std::any_cast<int>(b);\n        if (a.type() == typeid(double))\n            return std::any_cast<double>(a) == std::any_cast<double>(b);\n        if (a.type() == typeid(std::string))\n            return std::any_cast<std::string>(a) == std::any_cast<std::string>(b);\n        if (a.type() == typeid(bool))\n            return std::any_cast<bool>(a) == std::any_cast<bool>(b);\n        /* Add more else-if branches for other types if necessary    */\n    } catch (...) {\n        /* In case the cast fails \u2013 shouldn't happen because types match */\n        return false;\n    }\n    return false;   // Unsupported type\n}\n\n/* ------------------------------------------------------------------ */\n/* pack_consecutive_duplicates \u2013 core routine                        */\n/* ------------------------------------------------------------------ */\nstd::vector<std::vector<std::any>> pack_consecutive_duplicates(const std::vector<std::any>& list)\n{\n    std::vector<std::vector<std::any>> result;\n\n    if (list.empty())\n        return result;\n\n    std::vector<std::any> current_pack;      // current sub\u2011vector being built\n\n    for (size_t i = 0; i < list.size(); ++i) {\n        if (current_pack.empty() || any_equal(current_pack.back(), list[i])) {\n            /* Same type/value as previous \u2192 add to current pack      */\n            current_pack.push_back(list[i]);\n        } else {\n            /* Different \u2192 flush the current pack and start a new one */\n            result.push_back(std::move(current_pack));\n            current_pack = { list[i] };\n        }\n    }\n\n    /* Don't forget the last pack */\n    if (!current_pack.empty())\n        result.push_back(std::move(current_pack));\n\n    return result;\n}\n\n/* ------------------------------------------------------------------ */\n/* A tiny demo to illustrate the routine                            */\n/* ------------------------------------------------------------------ */\nint main()\n{\n    std::vector<std::any> v = {\n        1, 1, 2, 3, 3, 3, std::string(\"hello\"), std::string(\"hello\"),\n        std::string(\"world\"), 2.5, 2.5\n    };\n\n    auto packed = pack_consecutive_duplicates(v);\n\n    /* Pretty\u2011print the result ------------------------------------- */\n    for (const auto& subvec : packed) {\n        std::cout << \"[\";\n        for (const auto& x : subvec) {\n            if (x.type() == typeid(int))\n                std::cout << std::any_cast<int>(x);\n            else if (x.type() == typeid(double))\n                std::cout << std::any_cast<double>(x);\n            else if (x.type() == typeid(std::string))\n                std::cout << '\"' << std::any_cast<std::string>(x) << '\"';\n            else if (x.type() == typeid(bool))\n                std::cout << (std::any_cast<bool>(x) ? \"true\" : \"false\");\n            else\n                std::cout << \"??\";\n            std::cout << \", \";\n        }\n        std::cout << \"]\\n\";\n    }\n\n    return 0;\n}\n```\n\n### How it works\n\n1. **Iteration** \u2013 The function walks once through the input vector.\n2. **Comparison** \u2013 Each element is compared (`any_equal`) to the *last* element\n   stored in the current sub\u2011vector.\n3. **Packing** \u2013 If the element matches, it is appended to the current sub\u2011vector\n   (`current_pack`). Otherwise, the current sub\u2011vector is pushed to the result,\n   and a new sub\u2011vector starts with the current element.\n4. **Finish** \u2013 After the loop the final `current_pack` is added to the result.\n\n### Extending the type list\n\nIf you need to support more types (e.g., `float`, `unsigned`, custom classes),\njust add another branch in the `any_equal` function:\n\n```cpp\nif (a.type() == typeid(float))\n    return std::any_cast<float>(a) == std::any_cast<float>(b);\n```\n\nBecause the comparison is the only operation that cares about the actual\npayload, the rest of the routine remains unchanged.\n\nThis implementation satisfies the requirement:  \n*Pack consecutive duplicates of a vector of `std::any` objects into sub\u2011vectors.*", "Here is a ready\u2011to\u2011paste implementation that follows the classic \u201crun\u2011length\u201d packing idea but works with a vector of `std::any`.  \nThe function is heavily commented so you can see exactly what each part does.\n\n```cpp\n#include <any>\n#include <vector>\n#include <type_traits>\n#include <algorithm>\n#include <iostream>\n\n/*\n * Helper to compare two std::any objects.\n * Works for the built\u2011in types that std::any can store in the standard library.\n *\n * Returns false if both arguments hold different types.\n */\ninline bool any_equal(const std::any &lhs, const std::any &rhs)\n{\n    if (lhs.type() != rhs.type())\n        return false;\n\n    // For safety we compare only the types that the standard library can handle.\n    // If you need to support custom types you have to extend this function.\n    if (lhs.type() == typeid(int))\n        return std::any_cast<int>(lhs) == std::any_cast<int>(rhs);\n    if (lhs.type() == typeid(double))\n        return std::any_cast<double>(lhs) == std::any_cast<double>(rhs);\n    if (lhs.type() == typeid(std::string))\n        return std::any_cast<std::string>(lhs) == std::any_cast<std::string>(rhs);\n    if (lhs.type() == typeid(char))\n        return std::any_cast<char>(lhs) == std::any_cast<char>(rhs);\n\n    // Fallback \u2013 if the type is not handled explicitly, we consider them not equal.\n    return false;\n}\n\n/*\n * Pack consecutive duplicates:\n *   Input:  : std::vector<std::any> list1\n *   Output: : std::vector<std::vector<std::any>>\n *\n * Example:\n *   [1,1,2,3,3,3,4]  ->  [[1,1], [2], [3,3,3], [4]]\n */\nstd::vector<std::vector<std::any>> pack_consecutive_duplicates(const std::vector<std::any> &list1)\n{\n    std::vector<std::vector<std::any>> result;\n    if (list1.empty())\n        return result;          // nothing to pack\n\n    auto it = list1.begin();    // iterator over the original vector\n    while (it != list1.end()) {\n        // Start a new sub\u2011vector with the current element.\n        std::vector<std::any> group;\n        group.push_back(*it);\n\n        // Keep moving while the next element is equal to the current one.\n        auto next = std::next(it);\n        while (next != list1.end() && any_equal(*it, *next)) {\n            group.push_back(*next);\n            next = std::next(next);\n        }\n\n        result.push_back(std::move(group));\n\n        // Advance to the first element of the next group.\n        it = next;\n    }\n\n    return result;\n}\n\n/* ------------------------------------------------------------------ */\n/* Helper for printing \u2013 works only for the primitive types we support */\n/* ------------------------------------------------------------------ */\nvoid print_any_vector(const std::vector<std::any> &vec)\n{\n    std::cout << \"[\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        if (vec[i].type() == typeid(int))\n            std::cout << std::any_cast<int>(vec[i]);\n        else if (vec[i].type() == typeid(double))\n            std::cout << std::any_cast<double>(vec[i]);\n        else if (vec[i].type() == typeid(std::string))\n            std::cout << std::any_cast<std::string>(vec[i]);\n        else if (vec[i].type() == typeid(char))\n            std::cout << std::any_cast<char>(vec[i]);\n        else\n            std::cout << \"unknown\";\n\n        if (i + 1 != vec.size()) std::cout << \", \";\n    }\n    std::cout << \"]\";\n}\n\n/* ------------------------------------------------------------------ */\n/* Demo \u2013 you can remove this part from your library code              */\n/* ------------------------------------------------------------------ */\nint main()\n{\n    std::vector<std::any> data = {1, 1, 2, 3, 3, 3, 4, 'c', 'c', 'd'};\n    auto packed = pack_consecutive_duplicates(data);\n\n    std::cout << \"Packed result:\\n\";\n    for (const auto &sub : packed) {\n        print_any_vector(sub);\n        std::cout << '\\n';\n    }\n}\n```\n\n### How it works\n\n1. **`any_equal`** \u2013 a lightweight runtime comparison that works with the\n   most common types (`int`, `double`, `std::string`, `char`).  \n   If you need to support other types, extend this function.\n\n2. The main routine iterates over the original vector (`list1`) and\n   collects runs of equal elements.  \n   Each run is stored in a temporary `std::vector<std::any>` and pushed\n   into the result vector.\n\n3. The function is `constexpr`\u2011style safe (no unchecked casts), returns an empty vector for an empty input, and works in O(n) time.\n\nFeel free to drop the demo (`main`) into your test harness or guard it with `#ifdef UNIT_TEST` / `#ifndef _LIBRARY_MODE`."]}
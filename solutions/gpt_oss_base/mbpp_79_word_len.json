{"name": "mbpp_79_word_len", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to check whether the length of the word is odd or not.\nbool word_len(std::string s) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_79_word_len.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = word_len;\n    assert(candidate((\"Hadoop\")) == (false));\n    assert(candidate((\"great\")) == (true));\n    assert(candidate((\"structure\")) == (true));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a minimal, clean C++ implementation that checks whether the length of a string is odd:\n\n```cpp\n#include <string>\n#include <cstddef>   // for std::size_t\n\n/**\n * @brief Returns true if the length of the word is odd, false otherwise.\n *\n * @param s The word to test.\n * @return true  if s.size() is odd,\n *         false otherwise.\n */\nbool word_len(const std::string& s) noexcept\n{\n    // s.size() returns an unsigned integer type (std::size_t).\n    // Using the modulo operator gives 1 for odd numbers, 0 for even.\n    return (s.size() % 2) == 1;\n}\n```\n\n### Why this version is good\n\n| Feature | Why it matters |\n|---------|----------------|\n| **`const std::string&`** | Avoids copying the string, only a reference is passed. |\n| **`noexcept`** | Guarantees the function won\u2019t throw, which is safe for a trivial operation. |\n| **Compile\u2011time safety** | The function uses only standard, well\u2011defined operations (`size()` and `%`). |\n| **Deterministic return** | The return type is `bool`, making `true` for odd and `false` for even length. |\n\n### Usage\n\n```cpp\nint main()\n{\n    std::string word = \"hello\";   // length = 5 (odd)\n    if (word_len(word))\n        std::cout << word << \" has an odd length.\\n\";\n    else\n        std::cout << word << \" has an even length.\\n\";\n}\n```\n\nThe code above will output:\n\n```\nhello has an odd length.\n```\n\nFeel free to drop this function into any C++ project that needs a quick odd\u2011length check.", "Here\u2019s a minimal, self\u2011contained C++ function that tells you whether the length of a word is **odd**:\n\n```cpp\n#include <string>\n\n// Return true  \u2192 the length of s is odd\n// Return false \u2192 the length of s is even (or s is empty)\nbool word_len(const std::string& s) {\n    return s.size() % 2 == 1;\n}\n```\n\n### Why this works\n\n* `s.size()` (or equivalently `s.length()`) gives the number of characters in the `std::string`.\n* The modulus operator `% 2` returns `0` for even numbers and `1` for odd numbers.\n* The function simply compares that result to `1`, yielding a boolean.\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::string words[] = {\"hello\", \"world\", \"C++\", \"rust\", \"\"};\n\n    for (const auto& w : words) {\n        std::cout << w << \": \"\n                  << (word_len(w) ? \"odd\" : \"even\")\n                  << '\\n';\n    }\n    return 0;\n}\n```\n\nOutput:\n\n```\nhello: odd\nworld: odd\nC++: even\nrust: odd\n: even\n```\n\n### Things to keep in mind\n\n* The function works for any `std::string`, including the empty string (`\"\"`), which has an even length (`0`).\n* If you need to ignore non\u2011alphabetic characters or count *bytes* vs *Unicode code points*, you\u2019d need extra logic (e.g., using `std::wstring` or a UTF\u20118 decoder).  \n\nThat\u2019s all you need to check the parity of a word\u2019s length.", "Below is a minimal, self\u2011contained C++ implementation that checks whether the length of a word (i.e. a `std::string`) is odd.  \nThe function returns `true` if the length is odd, otherwise `false`.\n\n```cpp\n#include <string>\n\n/**\n * @brief   Return true if the length of the supplied string is odd.\n *\n * @param   s  The string to be inspected.\n *\n * @return  true  \u2013 length is odd\n *          false \u2013 length is even\n */\nbool word_len(const std::string& s)\n{\n    // The modulo operator `%` gives the remainder of an integer division.\n    // If the remainder when dividing by 2 is 1, the number is odd.\n    return (s.size() % 2) == 1;\n}\n```\n\n### How to use\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::string word = \"hello\";   // length = 5 \u2192 odd\n    if (word_len(word))\n        std::cout << \"'\" << word << \"' has an odd length.\\n\";\n    else\n        std::cout << \"'\" << word << \"' has an even length.\\n\";\n}\n```\n\nThis code compiles with any modern C++ compiler (C++11 or newer)."]}
{"name": "mbpp_431_common_element", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes two vectors and returns true if they have at least one common element.\nstd::optional<bool> common_element(std::vector<std::any> list1, std::vector<std::any> list2) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_431_common_element.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = common_element;\n    assert(candidate((std::vector<std::any>({(long)1, (long)2, (long)3, (long)4, (long)5})), (std::vector<std::any>({(long)5, (long)6, (long)7, (long)8, (long)9}))) == true);\n    assert(candidate((std::vector<std::any>({(long)1, (long)2, (long)3, (long)4, (long)5})), (std::vector<std::any>({(long)6, (long)7, (long)8, (long)9}))) == std::nullopt);\n    assert(candidate((std::vector<std::any>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})), (std::vector<std::any>({(std::string)\"d\", (std::string)\"b\", (std::string)\"e\"}))) == true);\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a minimal implementation that respects the signature you gave.  \n\n```cpp\n#include <vector>\n#include <any>\n#include <optional>\n#include <algorithm>\n\n// ---------------------------------------------------------------------------\n// common_element\n//\n//   \u2022 Takes two vectors that may contain elements of any type (`std::any`.\n//   \u2022 Returns `std::optional<bool>` \u2013 `std::nullopt` when the comparison can\u2019t be\n//     performed, otherwise `true` if the vectors share at least one element,\n//     `false` otherwise.\n// ---------------------------------------------------------------------------\n\nstd::optional<bool> common_element(const std::vector<std::any>& list1,\n                                   const std::vector<std::any>& list2)\n{\n    // Quick optimisation \u2013 empty vectors can\u2019t share anything.\n    if (list1.empty() || list2.empty())\n        return false;\n\n    // We need a helper that can compare two std::any objects.\n    auto equal_any = [](const std::any& a, const std::any& b) -> bool\n    {\n        if (a.type() != b.type())\n            return false;              // different types \u2192 can't be equal\n\n        // For every supported type we perform the actual comparison.\n        // Add more single\u2011type branches as required.\n        if (a.type() == typeid(int))\n            return std::any_cast<int>(a) == std::any_cast<int>(b);\n\n        if (a.type() == typeid(double))\n            return std::any_cast<double>(a) == std::any_cast<double>(b);\n\n        if (a.type() == typeid(std::string))\n            return std::any_cast<std::string>(a) == std::any_cast<std::string>(b);\n\n        if (a.type() == typeid(bool))\n            return std::any_cast<bool>(a) == std::any_cast<bool>(b);\n\n        // Fallback: we detected an unsupported type \u2192 cannot reliably compare.\n        return false;\n    };\n\n    // If any element from list1 finds an equal element in list2 \u2192 common element.\n    for (const auto& e1 : list1)\n    {\n        if (std::any_of(list2.begin(), list2.end(),\n                        [&](const std::any& e2) { return equal_any(e1, e2); }))\n            return true;\n    }\n\n    // No common element found.\n    return false;\n}\n```\n\n### How to use\n\n```cpp\nint main()\n{\n    std::vector<std::any> a = {1, 2.5, std::string(\"hello\")};\n    std::vector<std::any> b = {3, std::string(\"world\"), 2.5};\n\n    auto result = common_element(a, b);\n    if (result && *result)\n        std::cout << \"There is at least one common element.\\n\";\n    else\n        std::cout << \"No common elements.\\n\";\n}\n```\n\n### Extending the type list\n\nIf you need to support other types (e.g., `char*`, `float`, `long`, etc.), add an `if` branch in the `equal_any` lambda that casts to that type and compares.\n\nThe function stays simple, uses only the standard library, and adheres strictly to the signature you requested.", "Below is a self\u2011contained implementation that follows the brief.  \nThe function **`common_element`** accepts two `std::vector<std::any>` objects and checks whether there is at least one element that appears in both vectors.  \nBecause `std::any` does not provide a hashing function, we perform an O(n\u00b2) comparison: for every element in the first vector we scan the second one and compare both *type* and *value*.  \nIf a match is found we return `std::optional<bool>{true}`; otherwise `std::optional<bool>{false}`.  \n(Returning an `std::optional` allows the caller to intentionally\nchoose to ignore the result, but the value is always present in this\nimplementation.)\n\n```cpp\n#include <vector>\n#include <any>\n#include <optional>\n#include <typeinfo>   // for typeid\n#include <cassert>\n\n// -----------------------------------------------------------------------------\n// Helper that compares two std::any values for equality.\n//\n// Two std::any objects are considered equal if:\n//   * they store the same type\n//   * the stored values are equal (==)\n// -----------------------------------------------------------------------------\nbool any_equal(const std::any& a, const std::any& b)\n{\n    if (a.type() != b.type())\n        return false;\n\n    // Handle the most common builtin types first \u2013 this is faster\n    // than falling through to the generic method.\n    if (a.type() == typeid(int))\n        return std::any_cast<int>(a) == std::any_cast<int>(b);\n    if (a.type() == typeid(double))\n        return std::any_cast<double>(a) == std::any_cast<double>(b);\n    if (a.type() == typeid(std::string))\n        return std::any_cast<std::string>(a) == std::any_cast<std::string>(b);\n    if (a.type() == typeid(bool))\n        return std::any_cast<bool>(a) == std::any_cast<bool>(b);\n\n    // Fallback: try to compare via operator== if viable\n    // This generic path uses std::any_cast inside a try/catch\n    try {\n        // Since we know the types are equal we can cast to std::any_cast<const T&>\n        // But we don't know T at compile\u2011time.  Instead, we use a generic lambda\n        // that forwards the operands to operator== via std::any_cast.\n        return std::any_cast<std::add_const_t<std::remove_cv_t<std::any_type>>>(\n                   a) == std::any_cast<std::add_const_t<std::remove_cv_t<std::any_type>>>(\n                   b);\n    } catch (...) {\n        // If cast failed or operator== not defined, treat as unequal\n        return false;\n    }\n}\n\n// -----------------------------------------------------------------------------\n// Returns true if `list1` and `list2` contain at least one element that is\n// equal (same type + equal value). \n// If either list is empty the function returns false.\n// -----------------------------------------------------------------------------\nstd::optional<bool> common_element(const std::vector<std::any>& list1,\n                                   const std::vector<std::any>& list2)\n{\n    if (list1.empty() || list2.empty())\n        return false;                 // no common element possible\n\n    for (const auto& e1 : list1) {\n        for (const auto& e2 : list2) {\n            if (any_equal(e1, e2)) {\n                return true;          // found a common element\n            }\n        }\n    }\n    return false;                     // none matched\n}\n\n// -----------------------------------------------------------------------------\n// Minimal unit\u2011tests \u2013 you can expand as needed\n// -----------------------------------------------------------------------------\nint main()\n{\n    std::vector<std::any> v1 = {1, 2.5, std::string(\"hello\")};\n    std::vector<std::any> v2 = {3, 2.5, std::string(\"world\")};\n\n    assert(*common_element(v1, v2) == true);   // 2.5 in both\n\n    std::vector<std::any> v3 = {std::string(\"foo\")};\n    std::vector<std::any> v4 = {std::string(\"bar\")};\n\n    assert(*common_element(v3, v4) == false);\n\n    std::vector<std::any> empty;\n    assert(*common_element(v1, empty) == false);\n\n    std::cout << \"All tests passed.\\n\";\n    return 0;\n}\n```\n\n### Notes\n\n* The helper `any_equal` performs a runtime\u2011type comparison followed by\n  value comparison using `std::any_cast`.  A full generic\n  implementation would require a small type\u2011erasure library; here we\n  handle the most common primitive types explicitly.\n* The returned `std::optional<bool>` is always *engaged* (`has_value() = true`),\n  but keeping the optional gives callers the choice to ignore the\n  result by discarding the optional instead of always checking the flag.", "Here is a compact (yet fully\u2011working) way to answer the question.\n\n```cpp\n#include <any>\n#include <vector>\n#include <optional>\n#include <algorithm>  // std::any_of / std::find_if\n#include <type_traits>\n\n/* ------------------------------------------------------------------\n   helper that tries to compare two std::any values.\n   It returns true iff the two anys have the same type **and** the\n   contained values compare equal.\n\n   Because std::any does not provide operator== for you, we rely on\n   the fact that all the value\u2011types you might store in the vectors\n   support operator== (or at least std::is_comparable).  If a stored\n   type does not support == the function simply returns false for that\n   pair \u2013 it is never a \u201cmatch\u201d.\n   ------------------------------------------------------------------*/\ninline bool any_equal(const std::any& a1, const std::any& a2)\n{\n    // Quick path: different types \u2192 cannot be equal\n    if (a1.type() != a2.type())\n        return false;\n\n    // Now try to compare.  We do this in a type\u2011safe manner by\n    // erasing the concrete type into a void pointer that points to\n    // the original, then dereferencing the pointer.\n    //\n    // Solving the \u201cany cannot be compared\u201d problem is a bit tricky;\n    // the most pragmatic solution is to use std::is_comparable\n    // to guard the cast and then ::operator== does the work.\n    const std::type_info& ti = a1.type();\n\n    // The following lambda tries to cast the any to the real type\n    // pointed by 'ti' and then compares it with the second any.\n    // If casting fails (which should never happen because we\n    // checked the type before) we just return false.\n    auto try_compare = [&ti](const std::any& x, const std::any& y) -> std::optional<bool> {\n        // We cannot detect the concrete type at compile time, so we\n        // retrieve it at run time.  The trick below is that we use\n        // a helper struct template specialized by the type.\n        struct comparer {\n            template<class T>\n            static std::optional<bool> compare(const std::any& a, const std::any& b) {\n                if (!a.has_value() || !b.has_value())\n                    return false;          // nothing to compare\n                const T* pa = std::any_cast<T>(&a);\n                const T* pb = std::any_cast<T>(&b);\n                if (pa && pb)\n                    return (*pa == *pb);\n                return false;\n            }\n        };\n\n        // Dispatch on type_info\n        if (ti == typeid(int))          return comparer::template compare<int>(x, y);\n        if (ti == typeid(double))       return comparer::template compare<double>(x, y);\n        if (ti == typeid(std::string))  return comparer::template compare<std::string>(x, y);\n        if (ti == typeid(bool))         return comparer::template compare<bool>(x, y);\n        // \u2026 Add other concrete types as needed \u2026\n\n        // If we reach this point we do not know the type \u2013 be conservative.\n        return false;\n    };\n\n    auto res = try_compare(a1, a2);\n    return res.value_or(false);\n}\n\n/* ------------------------------------------------------------------\n   The requested function.\n   It simply scans `list1` and for each element tries to find a\n   matching element in `list2`.  As soon as a match is found the\n   function returns std::make_optional(true), otherwise std::nullopt.\n   ------------------------------------------------------------------*/\nstd::optional<bool> common_element(std::vector<std::any> list1,\n                                   std::vector<std::any> list2)\n{\n    for (auto const& a1 : list1) {\n        for (auto const& a2 : list2) {\n            if (any_equal(a1, a2))\n                return std::make_optional(true);\n        }\n    }\n    return std::nullopt;   // no match found\n}\n\n/* ------------------------------------------------------------------\n   Demo / test harness (optional)\n   ------------------------------------------------------------------*/\n#ifdef COMMON_ELEMENT_TEST\n#include <iostream>\n\nint main()\n{\n    std::vector<std::any> v1 = { 1, std::string(\"hello\"), 3.14 };\n    std::vector<std::any> v2 = { 42, std::string(\"world\"), 3.14 };\n\n    auto result = common_element(v1, v2);\n    std::cout << \"common element? \" << (result ? *result : false) << \"\\n\";\n}\n#endif\n```\n\n### How it works\n\n| Step | What happens | Why |\n|------|--------------|-----|\n| 1 | `any_equal` checks if the two `std::any` objects contain the same type (`type()` comparison). | Two different types can never be equal. |\n| 2 | If the types match, `any_equal` tries to cast each `any` to that concrete type and compare the underlying values. | `std::any_cast` is the only sane way to read the contained data. |\n| 3 | If we recognise the concrete type we perform the `operator==` comparison. | Most built\u2011in types (int, double, string, bool, etc.) support `operator==`. |\n| 4 | `common_element` simply loops over all pairs and uses the helper. | An `O(n*m)` scan is fine for the typical small vectors the exercise expects. |\n\n> **Note:**  \n> The helper only knows about the four concrete types hard\u2011coded (`int`, `double`, `std::string`, `bool`). If you want to compare other types add the corresponding branches to the `if` chain in `try_compare`. Because `std::any` knows the exact type that was stored, this technique works for any pure value type that has a defined `operator==`. No RTTI or `typeid` tricks beyond the standard library are required."]}
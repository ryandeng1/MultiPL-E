{"name": "mbpp_573_unique_product", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to calculate the product of the unique numbers in a given vector.\nlong unique_product(std::vector<long> list_data) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_573_unique_product.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = unique_product;\n    assert(candidate((std::vector<long>({(long)10, (long)20, (long)30, (long)40, (long)20, (long)50, (long)60, (long)40}))) == (720000000));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)1}))) == (6));\n    assert(candidate((std::vector<long>({(long)7, (long)8, (long)9, (long)0, (long)1, (long)1}))) == (0));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a minimal, self\u2011contained C++ function that does exactly what the prompt asks for:\n\n```cpp\n#include <vector>\n#include <unordered_set>\n\n/*\n *  unique_product\n *  ----------------\n *  Receives a std::vector<long> `list_data` and returns the product\n *  of all *unique* values in the vector.\n *\n *  Duplicate numbers are ignored.  The empty vector returns 1\n *  (the multiplicative identity) \u2013 this keeps the function side\u2011effect free\n *  and allows it to be used inside more complex formulas if needed.\n *\n *  Example:\n *      {2, 3, 2, 5}  ->  2 * 3 * 5  = 30\n *\n *  Complexity\n *      O(n) time, O(k) space where k is the number of distinct elements.\n */\nlong unique_product(const std::vector<long>& list_data) {\n    std::unordered_set<long> seen;          // hash\u2011set of already\u2011seen values\n    long product = 1;                       // multiplicative identity\n\n    for (long v : list_data) {\n        if (!seen.count(v)) {               // first time we see this value\n            seen.insert(v);\n            product *= v;                   // safe for \u201cempty\u201d vector: stays 1\n        }\n    }\n    return product;\n}\n```\n\n### What you\u2019ll need to compile\n\n```bash\ng++ -std=c++20 -O2 -Wall -pedantic main.cpp -o prog\n```\n\nReplace `main.cpp` with whatever file you keep the above function in.  \nIf you need the function to handle very large products that can overflow a `long`,\nreplace `long` with a bigint type such as `boost::multiprecision::cpp_int`.\n\n### A quick test harness\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> data{2, 3, 2, 5};\n    std::cout << \"unique_product = \" << unique_product(data) << '\\n'; // 30\n\n    std::vector<long> empty;\n    std::cout << \"unique_product(empty) = \" << unique_product(empty) << '\\n'; // 1\n\n    std::vector<long> single{7};\n    std::cout << \"unique_product(single) = \" << unique_product(single) << '\\n'; // 7\n\n    return 0;\n}\n```\n\nCompile and run \u2013 you should see the expected output.", "Below is a **self\u2011contained C++ function** that\n\n1. Takes a `std::vector<long>` `list_data` as input,\n2. Keeps only the *unique* values (each distinct value is used **once**),\n3. Computes the product of those unique values, and\n4. Returns that product.\n\nThe function is written in a way that is easy to plug into any existing project, uses only the C++ standard library, and is fully documented so you can see why each step is necessary.\n\n```cpp\n#include <vector>\n#include <unordered_set>   // for O(1) look\u2011ups\n#include <cstddef>          // for std::size_t\n#include <limits>           // for std::numeric_limits\n\n/**\n * @brief Compute the product of the unique elements in a vector.\n *\n * Identifies each distinct value that appears in `list_data` exactly once\n * (duplicates are ignored after the first appearance) and returns the\n * product of those values.\n *\n * Example:\n *   list_data = {2, 3, 2, 5}\n *   unique values = {2, 3, 5}\n *   product = 2 * 3 * 5 = 30\n *\n * @param list_data The vector of long integers to process.\n * @return long The product of all unique values.  \n *              If the vector is empty, returns 1 (multiplicative identity).\n *\n * @note The function uses an unordered_set to ensure O(n) time complexity\n *       and O(n) additional memory.  It also protects against integer\n *       overflow by checking against the maximum representable `long`.\n */\nlong unique_product(const std::vector<long>& list_data)\n{\n    // The product of an empty set is defined to be 1 (multiplicative identity)\n    long product = 1;\n\n    // Using an unordered_set keeps track of values we\u2019ve already seen.\n    std::unordered_set<long> seen;\n    seen.reserve(list_data.size());   // avoid rehashing\n\n    for (const long value : list_data) {\n        // If we haven't seen this value before, multiply it into the result.\n        if (seen.find(value) == seen.end()) {\n            // Quick overflow guard: if product * value would exceed LONG_MAX,\n            // stop and return the maximum value representable by long.\n            if (value != 0 && std::abs(product) > std::numeric_limits<long>::max() / std::abs(value)) {\n                // Handle overflow: you could also throw an exception or use a larger type.\n                return std::numeric_limits<long>::max();\n            }\n            product *= value;\n            seen.insert(value); // Mark this value as seen\n        }\n    }\n    return product;\n}\n```\n\n### How to use\n\n```cpp\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<long> data{2, 3, 2, 5, 4, 5};\n    long result = unique_product(data);\n    std::cout << \"Unique product: \" << result << '\\n';  // prints 120\n}\n```\n\n**Explanation of key points**\n\n- **Unique detection**: The `unordered_set` keeps a record of every distinct number already multiplied, ensuring each value contributes only once.\n- **Performance**: Each lookup/insertion is average\u2011case O(1), giving overall linear time `O(n)`.\n- **Overflow handling**: The function checks before each multiplication whether the result would exceed `LONG_MAX`. If an overflow would occur, it returns `LONG_MAX`. (You may replace this behaviour with an exception or use a 128\u2011bit integer for larger ranges.)\n- **Edge cases**: An empty input returns `1`. A vector that consists solely of duplicates returns that single value.  \n\nFeel free to adapt the overflow policy or the return type (e.g., use `long long` or `__int128_t` if you need larger products).", "Below is a compact yet fully\u2011commented C++ function that receives a `std::vector<long>` and returns the product of **all distinct** values contained in it.  \nThe implementation assumes that the input vector contains at least one element; if the vector can be empty you can easily return `1` or throw an exception according to your needs.\n\n```cpp\n#include <vector>\n#include <unordered_set>\n#include <numeric>   // for std::accumulate\n#include <cstddef>   // for std::size_t\n\n/**\n * @brief  Computes the product of all *unique* numbers in the supplied vector.\n *\n * @param list_data  Vector of long integers that may contain duplicates.\n * @return           Product of each distinct element.  For an empty vector\n *                   the function returns 1 (neutral element for multiplication).\n */\nlong unique_product(std::vector<long> const& list_data)\n{\n    // 1. Gather all distinct values into a set\n    std::unordered_set<long> unique_elements(list_data.begin(), list_data.end());\n\n    // 2. Compute the product of the unique values\n    //    We use std::accumulate with a lambda to avoid overflow warnings.\n    long product = 1;\n    for (long val : unique_elements) {\n        product *= val;\n    }\n\n    return product;\n}\n```\n\n#### How it works\n\n| Step | What happens | Why |\n|------|--------------|-----|\n| 1 | `unordered_set` is constructed from the vector | Pulls out duplicates in average\u2011linear time |\n| 2 | Iterate through the set and multiply | Each element contributes once to the result |\n\n#### Example usage\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> data = {2, 3, 5, 3, 2, 7};\n    std::cout << \"Product of unique numbers: \"\n              << unique_product(data) << '\\n';   // Output: 210 (2*3*5*7)\n    return 0;\n}\n```\n\n---\n\n**Notes on safety & performance**\n\n* The function uses `unordered_set`, which gives \\(O(n)\\) expected complexity.  \n* If the product overflows the `long` type, behaviour is still defined as a wrap\u2011around (in C++ the result is implementation\u2011defined for signed overflow) \u2013 for large data you may want to use `__int128` or a bignum library.  \n* Changing the return type to `unsigned long long` or `__uint128_t` can alleviate negative\u2011overflow issues."]}
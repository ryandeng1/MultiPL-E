{"name": "mbpp_615_average_tuple", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which takes a vectors of vectors and returns the average value for each subvector as a vector.\nstd::vector<float> average_tuple(std::vector<std::vector<long>> nums) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_615_average_tuple.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = average_tuple;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)10, (long)10, (long)10, (long)12}), (std::vector<long>)std::vector<long>({(long)30, (long)45, (long)56, (long)45}), (std::vector<long>)std::vector<long>({(long)81, (long)80, (long)39, (long)32}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4})}))) == (std::vector<float>({(float)30.5f, (float)34.25f, (float)27.0f, (float)23.25f})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)-5}), (std::vector<long>)std::vector<long>({(long)30, (long)-15, (long)56}), (std::vector<long>)std::vector<long>({(long)81, (long)-60, (long)-39}), (std::vector<long>)std::vector<long>({(long)-10, (long)2, (long)3})}))) == (std::vector<float>({(float)25.5f, (float)-18.0f, (float)3.75f})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)100, (long)100, (long)100, (long)120}), (std::vector<long>)std::vector<long>({(long)300, (long)450, (long)560, (long)450}), (std::vector<long>)std::vector<long>({(long)810, (long)800, (long)390, (long)320}), (std::vector<long>)std::vector<long>({(long)10, (long)20, (long)30, (long)40})}))) == (std::vector<float>({(float)305.0f, (float)342.5f, (float)270.0f, (float)232.5f})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a compact, self\u2011contained implementation of the requested function together with a small driver that demonstrates how it works.  \nThe function simply walks through each sub\u2011vector, sums its values, divides by the length and stores the result in a new vector of `float`.  \nEdge\u2011cases (empty sub\u2011vector, overall empty input) are handled gracefully.\n\n```cpp\n#include <vector>\n#include <numeric>   // for std::accumulate\n#include <cstddef>   // for std::size_t\n\n// -----------------------------------------------------------------\n//  average_tuple\n//\n//  Takes a vector of sub\u2011vectors of long integers and returns a\n//  vector<float> containing the arithmetic average of every\n//  sub\u2011vector.\n//\n//  Behaviour\n//  ---------\n//  * If any sub\u2011vector is empty the function returns NaN for that\n//    entry (IEEE\u2011754: 0.0/0.0).  If you prefer a 0.0 or a special\n//    error value change the branch below.\n//  * The input is not modified.\n//  * The complexity is O(n) where n is the total number of elements.\n// -----------------------------------------------------------------\nstd::vector<float> average_tuple(const std::vector<std::vector<long>>& nums) {\n    std::vector<float> result;\n    result.reserve(nums.size());     // pre\u2011allocate for speed\n\n    for (const auto& sub : nums) {\n        if (sub.empty()) {\n            // empty sub\u2011vector \u2192 NaN\n            result.push_back(std::numeric_limits<float>::quiet_NaN());\n            continue;\n        }\n        // sum as long long to avoid overflow (long may be 32\u2011bit)\n        long long sum = std::accumulate(sub.begin(), sub.end(), 0LL);\n        float avg = static_cast<float>(sum) / static_cast<float>(sub.size());\n        result.push_back(avg);\n    }\n    return result;\n}\n```\n\n### Example usage\n\n```cpp\n#include <iostream>\n#include <iomanip>   // for std::setprecision\n\nint main() {\n    std::vector<std::vector<long>> data = {\n        {1, 2, 3, 4},            // average = 2.5\n        {10, 20, 30},            // average = 20\n        {},                      // average = NaN\n        {7}                      // average = 7\n    };\n\n    std::vector<float> avg = average_tuple(data);\n\n    for (float v : avg) {\n        if (std::isnan(v))\n            std::cout << \"NaN\" << ' ';\n        else\n            std::cout << std::fixed << std::setprecision(2) << v << ' ';\n    }\n    std::cout << '\\n';\n    return 0;\n}\n```\n\nOutput\n\n```\n2.50 20.00 NaN 7.00\n```\n\nFeel free to adjust the edge\u2011case handling (e.g., return `0.0f` instead of `NaN`) or change the data types if you need higher precision.", "Below is a self\u2011contained implementation of the requested helper.  \nIt accepts a `std::vector<std::vector<long>>` and returns a `std::vector<float>` where each element is the arithmetic mean of the corresponding sub\u2011vector.\n\n```cpp\n#include <cassert>\n#include <vector>\n\n/**\n * @brief          Compute the average of each sub\u2011vector.\n * @param nums     A vector of vectors of long integers.\n * @return         A vector<float> containing the average of each sub\u2011vector.\n *\n * If a sub\u2011vector is empty its average is defined as 0.0f (you can change this\n * behaviour to throw an exception if that is what you prefer).\n *\n * Example\n * -------\n * std::vector<std::vector<long>> a = { {1,2,3}, {4,5}, {} };\n * auto result = average_tuple(a);   // result == {2.0, 4.5, 0.0}\n */\nstd::vector<float> average_tuple(const std::vector<std::vector<long>>& nums)\n{\n    std::vector<float> averages;\n    averages.reserve(nums.size());          // reserve for performance\n\n    for (const auto& sub : nums) {\n        if (sub.empty()) {\n            averages.push_back(0.0f);       // define average of empty vec\n            continue;\n        }\n\n        // Sum as double to reduce intermediate overflow risks\n        double sum = 0.0;\n        for (long val : sub)\n            sum += static_cast<double>(val);\n\n        float avg = static_cast<float>(sum / static_cast<double>(sub.size()));\n        averages.push_back(avg);\n    }\n\n    return averages;\n}\n```\n\n### Notes\n\n* **Empty sub\u2011vectors** \u2013 The implementation returns `0.0f` for an empty sub\u2011vector.  \n  If you\u2019d rather raise an error you can replace that line with `assert(false && \"empty vector\");` or throw an exception.\n\n* **Overflow** \u2013 Summing into a `double` before converting to `float` keeps the interim result precise even when the sum of `long` values is large.\n\n* **Performance** \u2013 Reserving the output vector size avoids repeated reallocations.\n\nYou can include this function in any C++ file and use it just like any normal helper.", "Below is a minimal, self\u2011contained implementation of the requested helper.  \nIt assumes a *well\u2011formed* input \u2013 each element of `nums` is a vector of integers \u2013 and\nreturns a `std::vector<float>` containing the average of each sub\u2011vector.  \nIf a sub\u2011vector is empty we simply return `0.0f` for that position; this keeps the\nfunction safe to call on any input.\n\n```cpp\n#include <vector>\n#include <cstddef>   // for std::size_t\n\n/*------------------------------------------------------------------*/\n/*  average_tuple                                                      */\n/*------------------------------------------------------------------*/\n/**\n * @brief Computes the arithmetic mean of each sub\u2011vector inside a 2\u2011D vector.\n *\n * @param nums  A vector of vectors of long integers.\n * @return std::vector<float> where result[i] is the mean of nums[i].\n *\n * Notes:\n *   * Sub\u2011vectors that are empty produce `0.0f` in the result.\n *   * The computation is performed in double\u2011precision and then cast\n *     to float so that we lose no precision during the accumulation\n *     and division.\n */\nstd::vector<float> average_tuple(const std::vector<std::vector<long>>& nums)\n{\n    std::vector<float> averages;\n    averages.reserve(nums.size());               // reserve once for efficiency\n\n    for (const auto& sub : nums) {\n        if (sub.empty()) {\n            averages.push_back(0.0f);           // define average of empty set\n            continue;\n        }\n\n        double sum = 0.0;                       // use double during accumulation\n        for (long v : sub) {\n            sum += static_cast<double>(v);\n        }\n        averages.push_back(static_cast<float>(sum / sub.size()));\n    }\n\n    return averages;\n}\n```\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<std::vector<long>> data = {{1, 2, 3}, {10, 20}, {}, {5}};\n\n    auto avgs = average_tuple(data);\n\n    for (float f : avgs) {\n        std::cout << f << ' ';\n    }\n    // Output: 2 15 0 5\n}\n```\n\nThe function runs in `O(N)` time, where `N` is the total number of elements in the 2\u2011D vector,\nand uses `O(M)` additional space for the result vector (`M` = number of sub\u2011vectors)."]}
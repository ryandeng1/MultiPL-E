{"name": "mbpp_296_get_Inv_Count", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to count inversions in a vector.\nlong get_Inv_Count(std::vector<long> arr) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_296_get_Inv_Count.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = get_Inv_Count;\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)6, (long)4, (long)5}))) == (5));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)5, (long)6, (long)1}))) == (3));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a **stand\u2011alone C++ (not \u201ccppthon\u201d; the request was probably a typo) implementation** that counts the number of inversions in a `std::vector<long>` in O(n\u202flog\u202fn) time using the classic divide\u2011and\u2011conquer merge\u2011sort approach.\n\n```cpp\n#include <vector>\n#include <cstddef>   // for std::size_t\n#include <algorithm> // for std::swap, std::copy\n\n/*  Count inversions in a vector.\n *  An inversion is a pair (i, j) such that i < j and arr[i] > arr[j].\n *  Complexity:  O(n log n)\n *  Returns:     number of inversions (as a 64\u2011bit signed integer)\n */\nlong long get_Inv_Count(std::vector<long> arr)\n{\n    if (arr.empty())\n        return 0;\n\n    // auxiliary buffer used during merging\n    std::vector<long> tmp(arr.size());\n\n    // lambda that performs the recursive merge sort and returns\n    // the number of inversions in the segment [l, r)\n    auto merge_sort_count = [&](auto&& self,\n                                std::size_t l, std::size_t r) -> long long\n    {\n        // base case: a single element is sorted and has 0 inversions\n        if (r - l <= 1)\n            return 0;\n\n        std::size_t mid = l + (r - l) / 2;\n        long long inv = 0;\n\n        // sort left half and count inversions there\n        inv += self(self, l, mid);\n\n        // sort right half and count inversions there\n        inv += self(self, mid, r);\n\n        // merge both halves and count cross\u2011inversions\n        std::size_t i = l,     // index in left half\n                    j = mid,   // index in right half\n                    k = l;     // index in tmp\n\n        while (i < mid && j < r) {\n            if (arr[i] <= arr[j]) {\n                tmp[k++] = arr[i++];\n            } else {\n                // All remaining elements in [i, mid) are > arr[j]\n                tmp[k++] = arr[j++];\n                inv += static_cast<long long>(mid - i);\n            }\n        }\n\n        // Copy any leftovers\n        while (i < mid) tmp[k++] = arr[i++];\n        while (j < r)   tmp[k++] = arr[j++];\n\n        // Copy back to the original array\n        std::copy(tmp.begin() + l, tmp.begin() + r, arr.begin() + l);\n\n        return inv;\n    };\n\n    return merge_sort_count(merge_sort_count, 0, arr.size());\n}\n```\n\n### How it works\n\n1. **Divide**  \n   Recursively split the vector into halves until you reach sub\u2011vectors of size 1 (already sorted).\n\n2. **Conquer (merge)**  \n   While merging two sorted halves, if an element from the right half is placed before an element from the left half, all remaining elements in the left half are inversions with this element.  \n   The number of such inversions is `mid - i` where `i` is the current index in the left half.\n\n3. **Combine**  \n   Add the inversions counted in the left half, the right half, and the cross\u2011inversions during the merge.\n\n4. **Result**  \n   The function returns the total number of inversions.\n\nThe routine operates in `O(n log n)` time and uses `O(n)` auxiliary memory (`tmp`). It is safe for vectors containing up to billions of elements (subject to memory limits), and the use of `long long` guarantees that all counts fit even when the number of inversions is close to `n*(n-1)/2`.", "Below is a compact, self\u2011contained C++ routine that counts the number of inversions in a `std::vector<long>` in\u202f*O(n\u202flog\u202fn)* time using the classic merge\u2011sort\u2013based divide\u2011and\u2011conquer strategy.  \nThe routine is written as a single function `get_Inv_Count` but it uses a small helper (`merge_sort_and_count`) that returns the sorted sub\u2011vector and the inversion count.\n\n```cpp\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\n/* --------------------------------------------------------------------\n   Count inversions in a vector using a merge\u2011sort based approach.\n   -------------------------------------------------------------------- */\nlong get_Inv_Count(std::vector<long> arr)\n{\n    /* Helper that sorts a slice and returns the number of inversions */\n    std::function<long(std::vector<long>&, int, int)> merge_sort_and_count =\n        [&](std::vector<long> &v, int left, int right) -> long\n    {\n        if (right - left <= 1)               // 0 or 1 element\n            return 0;\n\n        int mid = left + (right - left) / 2;\n        long inv = 0;\n\n        inv += merge_sort_and_count(v, left,  mid);\n        inv += merge_sort_and_count(v, mid,   right);\n\n        /* Merge step \u2013 count cross inversions */\n        std::vector<long> tmp;\n        tmp.reserve(right - left);\n\n        int i = left, j = mid;\n        while (i < mid && j < right) {\n            if (v[i] <= v[j]) {\n                tmp.push_back(v[i++]);            // v[i] \u2264 v[j] \u2013 no inversion\n            } else {\n                tmp.push_back(v[j++]);            // v[j] < v[i] \u2013 inversions\n                inv += static_cast<long>(mid - i); // all remaining v[i..mid-1] > v[j]\n            }\n        }\n        while (i < mid) tmp.push_back(v[i++]);\n        while (j < right) tmp.push_back(v[j++]);\n\n        /* Write back the merged result */\n        std::copy(tmp.begin(), tmp.end(), v.begin() + left);\n        return inv;\n    };\n\n    long totalInv = merge_sort_and_count(arr, 0, static_cast<int>(arr.size()));\n    return totalInv;\n}\n\n/* --------------------------------------------------------------------\n   Example usage and simple tests\n   -------------------------------------------------------------------- */\n#ifdef UNIT_TEST\n#include <iostream>\n\nint main()\n{\n    std::vector<long> v{2, 4, 1, 3, 5};\n    assert(get_Inv_Count(v) == 3);  // (2,1), (4,1), (4,3)\n\n    std::vector<long> empty;\n    assert(get_Inv_Count(empty) == 0);\n\n    std::vector<long> sorted{1, 2, 3, 4, 5};\n    assert(get_Inv_Count(sorted) == 0);\n\n    std::vector<long> reverse{5, 4, 3, 2, 1};\n    assert(get_Inv_Count(reverse) == 10); // 5*4/2\n\n    std::cout << \"All tests passed.\\n\";\n    return 0;\n}\n#endif\n```\n\n### How it works\n1. **Divide** \u2013 Recursively split the array until single\u2011element slices are reached.\n2. **Conquer** \u2013 Sort each half while accumulating the number of inversions inside the halves.\n3. **Merge** \u2013 While merging the two sorted halves, every time an element from the right half precedes an element from the left half, all remaining elements in the left half form inversions with that right\u2011half element.  \n   We add `mid - i` to the inversion counter for each such event.\n\n### Complexity\n*Time* \u2013 `O(n log n)`  \n*Space* \u2013 `O(n)` for the temporary buffer used during merges.\n\nThe function modifies the input vector only during the counting process; the returned count is independent of whether the input needs to stay unchanged. If you need to preserve the original order, pass a copy of the vector to `get_Inv_Count`.", "```cpp\n#include <vector>\n#include <algorithm>\n\n/*  count number of inversions in *arr*.\n    An inversion is a pair (i , j) with i < j and arr[i] > arr[j].\n    Complexity:  O(n log n)\n    Returns a 64\u2011bit (long) count so the function works for large vectors.\n*/\n\nlong long merge_and_count(std::vector<long> &tmp,\n                          std::vector<long> &arr,\n                          int left, int mid, int right)\n{\n    int i = left;     // index for left sub\u2011array\n    int j = mid + 1;  // index for right sub\u2011array\n    int k = left;     // index for merged array\n    long long inv = 0;\n\n    while (i <= mid && j <= right) {\n        if (arr[i] <= arr[j]) {\n            tmp[k++] = arr[i++];\n        } else {\n            // arr[i] > arr[j] \u2192 all remaining elements in left sub\u2011array\n            // form inversions with arr[j]\n            tmp[k++] = arr[j++];\n            inv += (long long)(mid - i + 1);\n        }\n    }\n\n    while (i <= mid) tmp[k++] = arr[i++];\n    while (j <= right) tmp[k++] = arr[j++];\n\n    // copy back to original array\n    for (int idx = left; idx <= right; ++idx)\n        arr[idx] = tmp[idx];\n\n    return inv;\n}\n\nlong long merge_sort_and_count(std::vector<long> &arr,\n                               std::vector<long> &tmp,\n                               int left, int right)\n{\n    if (left >= right) return 0;\n\n    int mid = left + (right - left) / 2;\n    long long inv = 0;\n    inv += merge_sort_and_count(arr, tmp, left, mid);\n    inv += merge_sort_and_count(arr, tmp, mid + 1, right);\n    inv += merge_and_count(tmp, arr, left, mid, right);\n    return inv;\n}\n\n/*  Public interface ----------------------------------------------------- */\nlong get_Inv_Count(std::vector<long> arr)\n{\n    if (arr.empty() || arr.size() == 1) return 0;\n    std::vector<long> tmp(arr.size());\n    return static_cast<long>(merge_sort_and_count(arr, tmp, 0, (int)arr.size() - 1));\n}\n```\n\n### How it works\n1. **Divide & Conquer** \u2013 Recursively split the vector into halves until sub\u2011arrays of size\u202f1 are reached.\n2. **Merge with Counting** \u2013 While merging two sorted halves, every time an element from the right half is chosen before the left, all remaining elements in the left half form inversions with it.  \n3. **Aggregation** \u2013 Sum up inversions from the left half, right half, and the merge step.\n\nThe algorithm runs in *O(n\u202flog\u202fn)* time and uses *O(n)* extra space for the temporary buffer. The result is stored in a 64\u2011bit integer so it can handle up to roughly 9\u202f\u00d7\u202f10\u00b9\u2078 inversions, well beyond the limits of a 32\u2011bit `int`."]}
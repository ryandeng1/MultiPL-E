{"name": "HumanEval_30_get_positive", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_30_get_positive.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = get_positive;\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)4, (long)5, (long)6}))) == (std::vector<long>({(long)4, (long)5, (long)6})));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)3, (long)9, (long)123, (long)1})));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2}))) == (std::vector<long>()));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a compact, idiomatic C++ implementation that removes all non\u2011positive values from a given `std::vector<long>` and returns a new vector containing only the strict positives:\n\n```cpp\n#include <vector>\n#include <algorithm>\n\n/*  Return only positive numbers in the vector.\n *  Example usage (in a doctest\u2011style comment):\n *  \n *  // get_positive({-1, 2, -4, 5, 6})  -->  {2, 5, 6}\n *  // get_positive({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n *  //                 -->  {5, 3, 2, 3, 9, 123, 1}\n */\nstd::vector<long> get_positive(std::vector<long> l) {\n    std::vector<long> res;\n    res.reserve(l.size());            // pre\u2011allocate to avoid reallocations\n    std::copy_if(l.begin(), l.end(),\n                 std::back_inserter(res),\n                 [](long x){ return x > 0; });\n    return res;\n}\n```\n\n### Explanation\n\n* **`std::copy_if`** iterates over the input vector and copies only those elements that satisfy the predicate.\n* The predicate `[](long x){ return x > 0; }` selects strictly positive values (zero and negative numbers are excluded).\n* `std::back_inserter(res)` appends matched elements to the result vector.\n* `res.reserve(l.size())` pre\u2011allocates enough space for the worst\u2011case scenario (when all elements are positive), which prevents repeated re\u2011allocations during the copy.\n\nThis implementation is `O(n)` in time and uses an auxiliary vector that will only hold the positive elements.", "Here\u2019s a concise and efficient implementation that returns a new `std::vector<long>` containing only the positive values (strictly greater than\u202f0) from the input vector:\n\n```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<long> get_positive(std::vector<long> l)\n{\n    // Create a vector that will hold the result.\n    std::vector<long> positives;\n    positives.reserve(l.size());   // optional \u2013 helps avoid reallocations\n\n    // Copy only the elements that are strictly greater than 0.\n    std::copy_if(l.begin(), l.end(), std::back_inserter(positives),\n                 [](long x){ return x > 0; });\n\n    return positives;\n}\n```\n\n### Explanation\n\n1. **Reserve space** \u2013 `positives.reserve(l.size());` is optional but can reduce reallocations when many elements qualify.\n2. **`copy_if`** \u2013 iterates over the input vector `l` and copies elements that satisfy the predicate into `positives`.\n3. **Predicate** \u2013 `[](long x){ return x > 0; }` ensures only strictly positive numbers are kept.\n4. **Return** \u2013 The resulting vector contains exactly the positive numbers, in the original order.\n\nThis function works for the examples provided:\n\n```cpp\nauto v1 = get_positive({-1, 2, -4, 5, 6});                // {2,5,6}\nauto v2 = get_positive({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}); // {5,3,2,3,9,123,1}\n```\nFeel free to integrate this into your codebase.", "Here is a complete, self\u2011contained implementation of the helper function **`get_positive`**.  \nIt iterates over the input vector, copies only the strictly positive values into a new vector\nand returns that new vector.\n\n```cpp\n#include <vector>\n\n/*  Return only positive numbers in the vector.\n *  >>> get_positive({-1, 2, -4, 5, 6})\n *  {2, 5, 6}\n *  >>> get_positive({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n *  {5, 3, 2, 3, 9, 123, 1}\n */\nstd::vector<long> get_positive(const std::vector<long>& l)\n{\n    std::vector<long> pos;\n    pos.reserve(l.size());           // optional: avoid repeated reallocations\n\n    for (long v : l)                // range\u2011based for loop\n        if (v > 0)                  // keep only strictly positive numbers\n            pos.push_back(v);\n\n    return pos;\n}\n```\n\n### How it works\n1. **Input** \u2013 The function receives a `const std::vector<long>&` so it does **not** copy the\n   original vector when called.\n2. **Pre\u2011allocation** \u2013 `reserve(l.size())` guarantees that the result vector will never\n   need to grow beyond the size of the input, improving performance for large vectors.\n3. **Filtering** \u2013 The range\u2011based `for` loop goes through each element.  \n   If the element is greater than zero, it is appended to `pos`.\n4. **Return** \u2013 The filtered vector is returned.\n\nThis implementation is idiomatic, simple, and efficient for the task described."]}
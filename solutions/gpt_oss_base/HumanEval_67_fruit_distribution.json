{"name": "HumanEval_67_fruit_distribution", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_67_fruit_distribution.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = fruit_distribution;\n    assert(candidate((\"5 apples and 6 oranges\"), (19)) == (8));\n    assert(candidate((\"5 apples and 6 oranges\"), (21)) == (10));\n    assert(candidate((\"0 apples and 1 oranges\"), (3)) == (2));\n    assert(candidate((\"1 apples and 0 oranges\"), (3)) == (2));\n    assert(candidate((\"2 apples and 3 oranges\"), (100)) == (95));\n    assert(candidate((\"2 apples and 3 oranges\"), (5)) == (0));\n    assert(candidate((\"1 apples and 100 oranges\"), (120)) == (19));\n}\n", "stop_tokens": ["\n}"], "completions": ["**Solution Explanation**\n\nThe task is simple:\n\n* From the string `s` we have to read the number of apples and the number of oranges.  \n  The string always has the format\n\n  ```\n  \"<apples> apples and <oranges> oranges\"\n  ```\n\n  where `<apples>` and `<oranges>` are decimal integers.  \n* With `n` (the total amount of fruits in the basket) we can compute the number of\n  mangoes as\n\n  ```\n  mangoes = n \u2013 (apples + oranges)\n  ```\n\nThe only subtle part is reliably extracting the two integers from the string.\nThe easiest and most robust way is to use a `std::istringstream` that reads\nwhitespace\u2011separated tokens.  \nWhen the stream reads an integer it will skip any intervening non\u2011digit text,\nso after reading the first integer the next integer found in the stream is the\nsecond one.\n\n---\n\n#### Algorithm\n```\n1. Create a string stream from 's'.\n2. Read the first integer \u2192 apples.\n3. Read the second integer \u2192 oranges.\n4. Return n \u2013 (apples + oranges).\n```\nThe function returns a `long`, which is exactly what the problem statement\nrequires.\n\n---\n\n#### Correctness Proof  \n\nWe prove that the algorithm returns the correct number of mango fruits.\n\n*Let*  \n\n- `A` be the integer number of apples in the basket.  \n- `O` be the integer number of oranges in the basket.  \n- `T` be the total number of fruits in the basket (`n`).  \n\nBy the problem statement the input string `s` encodes exactly the two numbers\n`A` and `O`.  \nStep&nbsp;1 creates a stream over `s`.  \nWhen the stream reads an `int`, it consumes the next run of characters\nrepresenting an integer, regardless of any surrounding words.  \nTherefore:\n- Step&nbsp;2 reads `A` from the stream.  \n- Step&nbsp;3 reads `O` from the stream.  \n\nThus after steps 2\u20133 the variables `apples` and `oranges` equal `A` and `O`.\n\nBy the definition of the problem the number of mangoes `M` is\n\n```\nM = T \u2013 (A + O)\n```\n\nStep&nbsp;4 computes exactly `n \u2013 (apples + oranges)` which, by the equalities\nabove, equals `T \u2013 (A + O) = M`.  \nConsequently the function returns the exact number of mango fruits.\n\n\u220e\n\n---\n\n#### Complexity Analysis\n\nLet `L` be the length of the input string `s`.  \nThe stream scans the string once, O(L) time, and uses O(1) additional space.\n\n---\n\n#### Reference Implementation (C++17)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// ---------------------------------------------------------------\n// Returns the number of mangoes in the basket.\n//\n// Parameters:\n//   s : string of the form \"<apples> apples and <oranges> oranges\"\n//   n : total number of fruits in the basket\n// ---------------------------------------------------------------\nlong fruit_distribution(std::string s, long n) {\n    std::istringstream iss(s);\n    long apples = 0, oranges = 0;\n\n    // The stream will skip the words and read the first two integers.\n    iss >> apples >> oranges;      // apples = first int, oranges = second int\n\n    return n - (apples + oranges);\n}\n```\n\nThis implementation follows exactly the algorithm proven correct above\nand complies with the GNU++17 compiler.", "```cpp\n#include <string>\n#include <cctype>\n#include <stdexcept>\n#include <sstream>\n\n/**\n * Parse an integer that immediately precedes a keyword in a string.\n * The function looks for the pattern \"<number> <keyword>\" and returns the number.\n * Throws std::invalid_argument if the keyword cannot be found or the number is missing.\n */\nstatic long parseNumberBeforeKeyword(const std::string& text, const std::string& keyword)\n{\n    // Find the keyword in the string\n    auto pos = text.find(keyword);\n    if (pos == std::string::npos)\n        throw std::invalid_argument(\"Keyword not found: \" + keyword);\n\n    // Back\u2011track from the position of the keyword to find the preceding number\n    std::size_t i = pos;\n    // Skip any leading whitespace before the keyword\n    while (i > 0 && std::isspace(static_cast<unsigned char>(text[i-1])))\n        --i;\n\n    // Move backward until we hit the beginning of the number\n    std::size_t end = i;\n    while (i > 0 && std::isdigit(static_cast<unsigned char>(text[i-1])))\n        --i;\n\n    // Now i..end-1 contains the digits of the number\n    if (i == end)\n        throw std::invalid_argument(\"No number before keyword: \" + keyword);\n\n    std::string numberStr = text.substr(i, end - i);\n    long value = std::stol(numberStr);\n    return value;\n}\n\n/**\n * Compute the number of mangoes in a basket.\n *\n * @param s   A string containing \"<apples> apples and <oranges> oranges\".\n * @param n   Total number of fruits in the basket.\n * @return    Number of mangoes.\n *\n * If the computed number of mangoes would be negative the function returns 0.\n */\nlong fruit_distribution(std::string s, long n)\n{\n    try {\n        long apples  = parseNumberBeforeKeyword(s, \"apples\");\n        long oranges = parseNumberBeforeKeyword(s, \"oranges\");\n\n        long mangoes = n - (apples + oranges);\n        if (mangoes < 0) mangoes = 0;\n        return mangoes;\n    } catch (const std::invalid_argument&) {\n        // In case the string is malformed, return 0\n        return 0;\n    }\n}\n```\n\n### How it works\n\n1. **`parseNumberBeforeKeyword`**  \n   \u2022 Looks for the keyword (`\"apples\"` or `\"oranges\"`).  \n   \u2022 Walks backward to find the preceding digits.  \n   \u2022 Converts the digit substring to `long`.\n\n2. **`fruit_distribution`**  \n   \u2022 Calls the parser for apples and oranges.  \n   \u2022 Subtracts their sum from the total `n` to get mangoes.  \n   \u2022 Handles negative results by returning zero.\n\nThis implementation is straightforward, uses only the C++ standard library, and conforms to the examples given.", "**Solution Explanation**\n\nThe function `fruit_distribution` must extract the number of apples and oranges from a string that looks like\n\n```\n\"<a> apples and <b> oranges\"\n```\n\n(and may contain spaces or other characters).  \nAfter reading the two integers `a` and `b`, the number of mangoes is\n\n```\nmangoes = n - (a + b)\n```\n\nwhere `n` is the total number of fruits in the basket.  \nThe result can never be negative \u2013 if the given `n` does not allow for all\napples and oranges, we simply return `0`.\n\n---\n\n#### Algorithm\n```\n1. Set apple = orange = 0\n2. Scan the string looking for the first integer \u2192 apple\n3. Scan again for the second integer \u2192 orange\n4. total_known = apple + orange\n5. if n < total_known \u2192 return 0\n   else return n - total_known\n```\n\nThe scanning can be done with a simple `std::istringstream`: extract integers\nin order until we have two of them.\n\n---\n\n#### Correctness Proof  \n\nWe prove that the algorithm returns the correct number of mangoes.\n\n*Lemma 1*: After step\u202f2 the variable `apple` equals the integer that precedes\nthe word \u201capples\u201d in the input string.  \n*Proof*: The stream extraction `>>` reads consecutive digits as an integer and\nstops at the first non\u2011digit. Because the input string always contains\n`\"<a> apples\"` with `a` being a non\u2011negative integer written in decimal\nrepresentation, the first integer extracted is exactly `a`. \u220e\n\n*Lemma 2*: After step\u202f3 the variable `orange` equals the integer that precedes\nthe word \u201coranges\u201d in the input string.  \n*Proof*: After the first extraction we continue parsing the stream from the\npoint after reading the apple integer. The next integer encountered in the\nstream is the one before \u201coranges\u201d. Therefore `orange` is that integer. \u220e\n\n*Lemma 3*: `total_known = apple + orange` equals the total number of apples\nplus oranges in the basket.  \n*Proof*: By Lemma\u202f1 and Lemma\u202f2 the variables `apple` and `orange` contain\nexactly those numbers, hence their sum is the desired total. \u220e\n\n*Theorem*: The function returns the exact number of mangoes.  \n*Proof*:  \n- If `n < total_known`, the given total number of fruits cannot contain all\n  apples and oranges; the only possible non\u2011negative count of mangoes is\n  0, which the algorithm returns.\n- If `n \u2265 total_known`, the number of mangoes is `n \u2013 total_known`.  \n  By Lemma\u202f3 this is precisely the number of fruits left after allocating\n  apples and oranges, i.e. the number of mangoes. The algorithm returns this\n  value. \u220e\n\n---\n\n#### Complexity Analysis  \n\nLet `L` be the length of the input string `s`.\n\n- Parsing the string scans each character at most twice: **O(L)** time.\n- Only a few integers are stored: **O(1)** additional space.\n\n---\n\n#### Reference Implementation (C++17)\n\n```cpp\n#include <string>\n#include <sstream>\n#include <cctype>\n\n// Return number of mangos in the basket.\nlong fruit_distribution(const std::string& s, long n) {\n    long apple = 0, orange = 0;\n    std::istringstream iss(s);\n    std::string token;\n\n    // Extract first integer \u2192 apples\n    while (iss >> token) {\n        if (std::isdigit(token[0])) {\n            apple = std::stoll(token);\n            break;\n        }\n    }\n\n    // Extract second integer \u2192 oranges\n    while (iss >> token) {\n        if (std::isdigit(token[0])) {\n            orange = std::stoll(token);\n            break;\n        }\n    }\n\n    long total_known = apple + orange;\n    if (n < total_known) return 0;\n    return n - total_known;\n}\n```\n\nThe function follows exactly the algorithm proven correct above and\nconforms to the C++11/17 standard."]}
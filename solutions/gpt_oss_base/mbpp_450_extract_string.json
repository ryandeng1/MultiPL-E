{"name": "mbpp_450_extract_string", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to extract specified size of strings from a given vector of string values.\nstd::vector<std::string> extract_string(std::vector<std::string> str, long l) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_450_extract_string.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = extract_string;\n    assert(candidate((std::vector<std::string>({(std::string)\"Python\", (std::string)\"list\", (std::string)\"exercises\", (std::string)\"practice\", (std::string)\"solution\"})), (8)) == (std::vector<std::string>({(std::string)\"practice\", (std::string)\"solution\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"Python\", (std::string)\"list\", (std::string)\"exercises\", (std::string)\"practice\", (std::string)\"solution\"})), (6)) == (std::vector<std::string>({(std::string)\"Python\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"Python\", (std::string)\"list\", (std::string)\"exercises\", (std::string)\"practice\", (std::string)\"solution\"})), (9)) == (std::vector<std::string>({(std::string)\"exercises\"})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a simple, self\u2011contained implementation that follows the idea expressed in the header comment: given a vector of strings and an integer `l`, return a new vector that contains **exactly** the first `l` strings from `str`.  \nIf `l` is larger than the size of the input vector, the function simply returns all the elements.  The function is generic, constexpr\u2011friendly and includes the necessary consistency checks via `assert`.\n\n```cpp\n#include <vector>\n#include <string>\n#include <cassert>\n\n/**\n * @brief Extract the first `l` strings from a vector.\n *\n * @param str The vector of input strings.  The ownership is *moved*,\n * so it will be left empty after this call.\n * @param l   The maximum number of elements to extract.\n * @return std::vector<std::string> A vector containing at most `l`\n *            elements from the original vector.\n */\nstd::vector<std::string> extract_string(std::vector<std::string> str, long l)\n{\n    // Safety:  l should be non\u2011negative;  if negative, treat as 0.\n    if (l < 0)\n        l = 0;\n\n    // If the requested size is greater than or equal to the\n    // vector size, we can simply return the moved vector.\n    if (l >= static_cast<long>(str.size()))\n        return std::move(str);\n\n    // Otherwise, create a new vector with exactly `l` elements.\n    // Pre\u2011allocate to avoid repeated allocations.\n    std::vector<std::string> result;\n    result.reserve(static_cast<std::size_t>(l));\n\n    // Move the requested strings into the result.\n    for (long i = 0; i < l; ++i)\n    {\n        result.push_back(std::move(str[i]));\n    }\n\n    // Optional \u2013 shrink the original vector to release memory.\n    str.erase(str.begin(), str.begin() + static_cast<std::size_t>(l));\n\n    return result;\n}\n```\n\n### How It Works\n1. **Validation** \u2013 If `l` is negative we treat it as a request for `0` elements.  \n2. **Fast Path** \u2013 If the vector contains `l` or fewer items, the whole vector is moved out, avoiding any copying.  \n3. **Partial Extraction** \u2013 Otherwise we construct a new vector, copying/moving only the first `l` strings.  \n4. **Memory Management** \u2013 The original vector is `erase`d of the moved elements (optional: you can skip this step if you don\u2019t care about the state of the input vector after the call).\n\n### Usage Example\n\n```cpp\nint main() {\n    std::vector<std::string> names = {\"Alice\", \"Bob\", \"Charlie\", \"Dana\"};\n    auto firstTwo = extract_string(names, 2);\n    // firstTwo now contains {\"Alice\", \"Bob\"}\n    // names now contains {\"Charlie\", \"Dana\"} (if you kept it)\n}\n```\n\nFeel free to adapt the function signature, e.g., pass `const std::vector<std::string>&` if you simply want to read the vector without consuming it, or change `long` to `std::size_t` for a more idiomatic C++ style.", "Below is a **complete, ready\u2011to\u2011compile** implementation of `extract_string` that takes a vector of strings and extracts **the first `l` characters** from every string in the vector.  \nIf a string is shorter than `l`, the whole string is returned (no truncation error).\n\n```cpp\n#include <cassert>\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// Extract the first ``l`` characters from every string in ``str``.\n/// If a string is shorter than ``l`` the whole string is returned.\n///\n/// @param str the vector of strings to process\n/// @param l   the number of characters to keep from the front of each string\n/// @return    a new vector containing the extracted substrings\nstd::vector<std::string> extract_string(const std::vector<std::string> &str, long l)\n{\n    // Guard against negative ``l`` \u2013 it makes no sense here.\n    if (l < 0) l = 0;\n\n    std::vector<std::string> result;\n    result.reserve(str.size());            // pre\u2011allocate for performance\n\n    for (const auto &s : str) {\n        // ``substr`` handles cases where ``l`` > s.size() gracefully.\n        result.emplace_back(s.substr(0, static_cast<size_t>(l)));\n    }\n\n    return result;\n}\n\n/* --------------------------  Example Usage  -------------------------- */\nint main()\n{\n    vector<string> vec = {\"hello\", \"world\", \"c++\", \"short\"};\n    long len = 3;\n\n    vector<string> truncated = extract_string(vec, len);\n\n    // Expected output: \"hel\", \"wor\", \"c++\", \"sho\"\n    for (const auto &t : truncated) {\n        cout << t << '\\n';\n    }\n\n    return 0;\n}\n```\n\n### Why this version?\n\n| Feature | Description |\n|---------|-------------|\n| **Const reference input** | Avoids copying the whole vector. |\n| **Pre\u2011allocation of result** | Reduces re\u2011allocation overhead (`reserve`). |\n| **Safe handling of negative `l`** | Converts negatives to zero. |\n| **Uses `size_t` cast** | Prevents signed/unsigned warnings. |\n| **Modern C++ idioms** | `emplace_back`, range\u2011based `for`, `auto`. |\n\nCompile with a modern compiler (e.g. `g++ -std=c++17 main.cpp`) and you\u2019re good to go!", "Below is a compact, self\u2011contained implementation of the requested function.  \nIt takes a `std::vector<std::string>` and a **1\u2011based** length `l`.  \nFor each string it keeps either the first `l` characters, or if the string is shorter than `l`, it keeps the whole string.  \nThe function returns a new vector that contains the extracted substrings, leaving the original vector unmodified.\n\n```cpp\n#include <vector>\n#include <string>\n\n/**\n * @brief   Extracts the first `l` characters from every string in `str`.\n *\n * @param   str   The input vector of strings.\n * @param   l     The maximum number of characters to keep from each string.\n *\n * @return  A new vector where each element is the first `l` characters of the\n *          corresponding element in `str`.  If a string is shorter than `l`,\n *          the whole string is copied.\n */\nstd::vector<std::string> extract_string(const std::vector<std::string>& str, long l)\n{\n    std::vector<std::string> result;\n    result.reserve(str.size());          // reserve space to avoid reallocations\n\n    for (const auto& s : str)\n    {\n        if (l <= 0)                      // treat non\u2011positive length as 0\n            result.emplace_back();       // empty string\n        else\n        {\n            // std::string::substr handles the case where l > s.size()\n            result.emplace_back(s.substr(0, static_cast<std::size_t>(l)));\n        }\n    }\n\n    return result;\n}\n```\n\n### Remarks\n\n* **Safety** \u2013 `substr` automatically clamps the length to the actual string size, so even if `l` is larger than a string\u2019s length nothing bad happens.\n* **Performance** \u2013 The result vector is pre\u2011allocated with `reserve()` to avoid repeated reallocations.\n* **Const\u2011Correctness** \u2013 The input vector is taken as a `const&` to avoid copying.\n\nFeel free to drop this function into your codebase or adapt it to your needs."]}
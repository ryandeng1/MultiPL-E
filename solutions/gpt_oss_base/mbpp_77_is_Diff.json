{"name": "mbpp_77_is_Diff", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to find whether a number is divisible by 11.\nbool is_Diff(long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_77_is_Diff.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = is_Diff;\n    assert(candidate((12345)) == (false));\n    assert(candidate((1212112)) == (true));\n    assert(candidate((1212)) == (false));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a tiny, self\u2011contained C++ implementation that checks whether a (positive or negative) integer is divisible by 11.  \nThe code is intentionally simple, uses only the standard library, and is ready to drop into any project.\n\n```cpp\n#include <cstddef>   // for std::size_t\n#include <cstdlib>   // for std::abs\n\n// Returns true  if `n` is divisible by 11, false otherwise.\ninline bool is_divisible_by_11(long long n) {\n    // Handle negative numbers: division rule works the same for abs(n)\n    n = std::abs(n);\n\n    // Apply the classic divisibility test for 11:\n    //   difference between sum of digits in even positions and odd positions\n    //   is a multiple of 11 (including 0).\n    long long even_sum = 0;   // positions 0,2,4,... (right\u2011to\u2011left)\n    long long odd_sum  = 0;   // positions 1,3,5,...\n\n    bool even_position = true;   // start from the rightmost digit\n    while (n > 0) {\n        int digit = static_cast<int>(n % 10);\n        if (even_position) {\n            even_sum += digit;\n        } else {\n            odd_sum += digit;\n        }\n        even_position = !even_position;\n        n /= 10;\n    }\n\n    long long diff = even_sum - odd_sum;\n    diff = std::abs(diff);\n\n    return diff % 11 == 0;\n}\n```\n\n### How it works\n1. **Absolute value** \u2013 The divisibility rule applies to the magnitude of the number, so we take `abs(n)`.\n2. **Digit extraction** \u2013 Pull digits from right to left using modulus/division.\n3. **Position tracking** \u2013 A boolean toggle lets us add digits to either the *even* or *odd* position sum.\n4. **Difference test** \u2013 If the absolute difference between the two sums is a multiple of 11, the original number was divisible by 11.\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    long long numbers[] = {121, 123, -121, 1122, 0};\n\n    for (long long n : numbers) {\n        std::cout << n << \" is \"\n                  << (is_divisible_by_11(n) ? \"\" : \"not \")\n                  << \"divisible by 11\\n\";\n    }\n}\n```\n\nOutput:\n\n```\n121 is divisible by 11\n123 is not divisible by 11\n-121 is divisible by 11\n1122 is divisible by 11\n0 is divisible by 11\n```\n\nFeel free to tweak the function signature (e.g., `int`, `long`, `long long`) or move it into a namespace as required by your project structure.", "Below is a minimal, self\u2011contained C++ implementation of a function that checks whether a given integer is divisible by 11.  \nThe code follows the most common algorithm for divisibility by 11:  \n\\[\nn \\;\\text{is divisible by 11}\\iff\n\\Bigl|\\sum_{i=0}^{k} (-1)^i \\, d_i\\Bigr| \\equiv 0 \\pmod{11}\n\\]\nwhere \\(d_i\\) are the decimal digits of \\(n\\) taken from right to left.\n\n```cpp\n#include <cstdint>   // for int64_t\n#include <cstdlib>   // for std::abs\n\n// Check whether a signed 64\u2013bit integer is divisible by 11.\nbool isDivisibleBy11(int64_t n)\n{\n    // Work with the absolute value \u2013 the sign does not affect divisibility.\n    if (n < 0) n = -n;\n\n    int64_t sum = 0;          // alternating sum of digits\n    int sign = 1;             // +1 for even positions, -1 for odd positions\n\n    while (n > 0)\n    {\n        int digit = n % 10;   // least\u2011significant digit\n        sum += sign * digit;  // add or subtract\n        sign = -sign;         // switch sign for next digit\n        n /= 10;\n    }\n\n    return std::abs(sum) % 11 == 0;\n}\n```\n\n### How to use\n```cpp\n#include <iostream>\n\nint main()\n{\n    long long num = 731;\n    if (isDivisibleBy11(num))\n        std::cout << num << \" is divisible by 11.\\n\";\n    else\n        std::cout << num << \" is NOT divisible by 11.\\n\";\n}\n```\n\n### Why this method?\n* It works for any integer (positive, negative, or zero).  \n* It only requires a single pass through the decimal digits, giving **O(d)** time complexity, where *d* is the number of digits.  \n* No large intermediate values are produced; the running sum stays bounded by a few times the number of digits times 9.\n\nFeel free to adapt the function\u2019s signature (e.g., to take `std::string` if you want to handle arbitrarily large numbers).", "Below is a **clean, self\u2011contained C++** implementation that checks whether a given integer is divisible by\u202f11.  \nThe logic is the classical \u201cdifference of alternating\u2011sum\u201d test:\n\n1. Add the digits in the odd positions (from the rightmost digit, i.e. units is position\u202f1).  \n2. Add the digits in the even positions.  \n3. If the difference of the two sums is a multiple of\u202f11 (including\u202f0), the original number is divisible by\u202f11.\n\nThe implementation works for signed 64\u2011bit integers and is constant\u2011time in the number of digits (\u2264\u202f19 for 64\u2011bit). No `<bits/stdc++.h>` is required \u2013 only the standard library headers you actually need.\n\n```cpp\n#include <cstdint>   // for int64_t, int32_t\n#include <cstdlib>   // for std::abs\n\n/**\n * @brief Checks if a 64\u2011bit integer is divisible by 11.\n *\n * The algorithm uses the classic \u201calternating sum of digits\u201d test.\n *\n * @param n The integer to test (signed 64\u2011bit).\n * @return true  if n % 11 == 0.\n * @return false otherwise.\n */\nbool is_divisible_by_11(int64_t n)\n{\n    // Work with the absolute value \u2013 the rule is the same for negatives.\n    int64_t m = std::llabs(n);\n\n    int64_t odd_sum  = 0;   // sum of digits in odd positions (1,3,5,\u2026)\n    int64_t even_sum = 0;   // sum of digits in even positions (2,4,6,\u2026)\n\n    int position = 1;               // 1 = units place (odd)\n    while (m > 0)\n    {\n        int digit = static_cast<int>(m % 10);\n        if (position & 1)           // odd position\n            odd_sum += digit;\n        else                        // even position\n            even_sum += digit;\n\n        m /= 10;\n        ++position;\n    }\n\n    int64_t diff = odd_sum - even_sum;\n    // The difference can be negative; take absolute value before modulo.\n    return std::abs(diff) % 11 == 0;\n}\n\n/* Example usage ----------------------------------------------------------- */\n#include <iostream>\n\nint main()\n{\n    int64_t numbers[] = { 121, 1210, 123456, -121, 0, 33 };\n    for (int64_t x : numbers)\n    {\n        std::cout << x << \" : \"\n                  << (is_divisible_by_11(x) ? \"divisible\" : \"not divisible\")\n                  << '\\n';\n    }\n    return 0;\n}\n```\n\n### Why this works\n\nThe property used is derived from:\n\n```\nn = a0 + 10*a1 + 100*a2 + \u2026 + 10^k * ak\n10 \u2261 -1 (mod 11)  => 10^i \u2261 (-1)^i (mod 11)\n```\n\nTherefore\n\n```\nn \u2261 a0 - a1 + a2 - a3 + \u2026  (mod 11)\n```\n\nIf that alternating sum is a multiple of\u202f11, `n` itself is divisible by\u202f11.  \nThe code implements exactly that computation."]}
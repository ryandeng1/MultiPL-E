{"name": "mbpp_69_is_sublist", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to check whether a vector contains the given subvector or not.\nbool is_sublist(std::vector<long> l, std::vector<long> s) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_69_is_sublist.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = is_sublist;\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)5, (long)7})), (std::vector<long>({(long)3, (long)7}))) == (false));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)5, (long)7})), (std::vector<long>({(long)4, (long)3}))) == (true));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)5, (long)7})), (std::vector<long>({(long)1, (long)6}))) == (false));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a complete, self\u2011contained implementation of `is_sublist`.  \nI\u2019ll walk through the logic, show a couple of test cases, and explain why this\nsolution is fast enough for typical sizes of `std::vector<long>`.\n\n```cpp\n#include <cassert>\n#include <vector>\n#include <iostream>\n\n/*\n * Return true iff vector 'l' contains vector 's' as a contiguous sub\u2011sequence.\n *\n * Complexity:  O(|l| + |s|)\n *    We use the classic KMP (Knuth\u2011Morris\u2011Pratt) pattern\u2011matching algorithm\n *    on integer vectors.  That guarantees linear time regardless of the\n *    number of repeated elements in the pattern.\n *\n * Parameters\n *  ----------\n *   l : const reference to the \"longer\" vector we search in\n *   s : const reference to the pattern (subvector) we want to find\n *\n * Returns\n * -------\n *  bool : true if s appears as a contiguous block inside l\n */\nbool is_sublist(const std::vector<long>& l, const std::vector<long>& s) {\n    if (s.empty()) return true;          // empty pattern is always present\n    if (l.size() < s.size()) return false;\n\n    /* ---------- Build the longest\u2011prefix\u2011suffix (lps) array ---------- */\n    std::vector<size_t> lps(s.size(), 0);\n    for (size_t i = 1, len = 0; i < s.size(); ) {\n        if (s[i] == s[len]) {\n            lps[i++] = ++len;\n        } else if (len != 0) {\n            len = lps[len - 1];\n        } else {\n            lps[i++] = 0;\n        }\n    }\n\n    /* ---------- Run the KMP search --------------------------------- */\n    for (size_t i = 0, j = 0; i < l.size(); /* i advanced inside loop */) {\n        if (l[i] == s[j]) {\n            ++i; ++j;\n            if (j == s.size()) return true;   // match found\n        } else if (j != 0) {\n            j = lps[j - 1];                   // fall back in pattern\n        } else {\n            ++i;                               // move on in the text\n        }\n    }\n    return false;  // no match\n}\n\n/* --------------------------------------------------------------------- */\n/*                          OPTIONAL: simple test driver                 */\n/* --------------------------------------------------------------------- */\nint main() {\n    std::vector<long> A{1,2,3,4,5,6,7,8,9};\n    std::vector<long> sub1{3,4,5};\n    std::vector<long> sub2{6,7,10};\n    std::vector<long> sub3{};                 // empty\n    std::vector<long> sub4{1,2,3,4,5,6,7,8,9,10};\n\n    assert(is_sublist(A, sub1) == true);\n    assert(is_sublist(A, sub2) == false);\n    assert(is_sublist(A, sub3) == true);\n    assert(is_sublist(A, sub4) == false);\n\n    std::cout << \"All tests passed.\\n\";\n    return 0;\n}\n```\n\n### How it works\n\n1. **Edge cases**  \n   * An empty subvector is considered to be present (the empty sequence is a\n     subsequence of any vector).  \n   * If the full vector is shorter than the subvector, no match is possible.\n\n2. **Building the LPS array**  \n   The LPS (Longest Proper Prefix which is also a Suffix) array is built in\n   `O(|s|)` time.  It tells us how far we can shift the pattern when a mismatch\n   occurs.\n\n3. **KMP search**  \n   We walk through the longer vector once (`O(|l|)`), comparing elements and\n   using the LPS array to skip unnecessary comparisons.  As soon as we reach\n   the end of the subvector (`j == s.size()`), we have found a match and return\n   `true`.\n\n### Why KMP?\n\n- **Deterministic linear time** \u2013 even for pathological inputs such as\n  `s = [1,1,1,1,1,1]` and `l = [1,1,1,1,1,1,1]`, KMP does not degrade to\n  quadratic behaviour.\n- **Simplicity** \u2013 the algorithm can be implemented with only a few lines of\n  additional code (as shown above) and does not rely on any non\u2011standard\n  library functions.\n\nFeel free to replace the test harness (`main`) with whatever unit\u2011testing\nframework you prefer.", "Here is a complete, self\u2011contained implementation of `is_sublist`.  \nThe function scans the larger vector `l` and checks, for every possible starting index, whether the slice of length `s.size()` is identical to `s`.  \nIf a match is found, it immediately returns `true`; otherwise the search continues until all possible starts have been examined.\n\n```cpp\n#include <vector>\n#include <cassert>\n\n/*  Return true iff  `s` occurs as a contiguous sub\u2011vector of `l`.\n *  The function runs in O(|l| \u00b7 |s|) time (worst\u2011case) and\n *  uses only O(1) extra space.\n */\nbool is_sublist(const std::vector<long>& l, const std::vector<long>& s)\n{\n    // An empty sublist is always found.\n    if (s.empty())\n        return true;\n\n    // Quick early exit if the whole list is shorter than the sublist.\n    if (l.size() < s.size())\n        return false;\n\n    // For each possible starting index, compare the slice to `s`.\n    for (size_t i = 0; i + s.size() <= l.size(); ++i) {\n        bool all_equal = true;\n        for (size_t j = 0; j < s.size(); ++j) {\n            if (l[i + j] != s[j]) {\n                all_equal = false;\n                break;\n            }\n        }\n        if (all_equal)\n            return true;\n    }\n    return false;\n}\n\n/*  ---- Example usage & simple tests ----\n *  These tests can be compiled together with the above function:\n *\n *  int main() {\n *      std::vector<long> big = {1, 2, 3, 4, 5, 6};\n *      std::vector<long> sub = {3, 4};\n *      assert(is_sublist(big, sub) == true);\n *\n *      std::vector<long> not_present = {7, 8};\n *      assert(is_sublist(big, not_present) == false);\n *\n *      std::vector<long> empty;\n *      assert(is_sublist(big, empty) == true);\n *\n *      std::vector<long> tail = {5, 6, 7};\n *      assert(is_sublist(big, tail) == false);\n *\n *      return 0;\n *  }\n *\n *  Enjoy! */\n```\n\n### How it works\n\n1. **Edge\u2011case handling**  \n   * An empty search vector `s` is considered to be present in any vector `l`.  \n   * If `l` is shorter than `s`, it is impossible for `s` to be a sublist.\n\n2. **Sliding\u2011window comparison**  \n   * Iterate over every index `i` in `l` where a sub\u2011sequence of length `s.size()` could start (`i + s.size() <= l.size()`).  \n   * For that start, compare each element in the potential slice to the corresponding element in `s`.  \n   * Break out of the inner loop when a mismatch is found, and move to the next start.  \n\n3. **Return value**  \n   * The function returns `true` as soon as a complete match is found; otherwise, after exhausting all starts, it returns `false`.\n\nThis implementation focuses on clarity and correctness while keeping the code short and easy to understand.", "Here is a quick and compact way to implement `is_sublist`.  \nWe treat both `l` (the \u201cbig\u201d vector) and `s` (the possible sub\u2011vector) as normal containers and use the standard algorithm `std::search` to look for the first occurence of `s` inside `l`.  \n\n```cpp\n#include <vector>\n#include <algorithm>   // std::search\n#include <cassert>\n\n/// Return true iff the vector `s` appears as a *contiguous* sub\u2011vector of `l`.\n/// The order of elements in `s` must be preserved, but no restriction is\n/// imposed on elements in `l` that are outside the sub\u2011vector.\n///\n/// Example:\n///     l = {1,2,3,4,5,6}\n///     s = {3,4,5}   \u2192 true\n///     s = {4,3,5}   \u2192 false  (order matters)\n///     s = {7,8}     \u2192 false\nbool is_sublist(const std::vector<long>& l,\n                const std::vector<long>& s)\n{\n    // An empty sublist is always found (by definition).\n    if (s.empty())\n        return true;\n\n    // Normal bounds check \u2013 if s is longer than l we cannot have a match.\n    if (s.size() > l.size())\n        return false;\n\n    // std::search returns an iterator to the beginning of the first match,\n    // or l.end() when none is found.\n    return std::search(l.begin(), l.end(), s.begin(), s.end()) != l.end();\n}\n```\n\n### Why this works\n\n* `std::search` iterates through `l` and for each position it checks whether the subsequent elements match the entire sequence `s`.  \n* The algorithm is linear on the size of `l` in the worst case (O(`l.size()` \u00d7 `s.size()`)), exactly what we need for a simple sub\u2011vector lookup.  \n* The function is constant\u2011time for trivial corner cases (empty `s`, `s` longer than `l`).\n\nYou can test it with the following snippet:\n\n```cpp\nint main() {\n    std::vector<long> main = {1, 2, 3, 4, 5, 6};\n    std::vector<long> sub1 = {3, 4, 5};\n    std::vector<long> sub2 = {4, 5, 7};\n    std::vector<long> sub3 = {};         // empty\n\n    assert(is_sublist(main, sub1));      // true\n    assert(!is_sublist(main, sub2));     // false\n    assert(is_sublist(main, sub3));      // true\n\n    std::cout << \"All tests passed!\\n\";\n}\n```\n\nFeel free to adapt the function (e.g., changing the return type, passing by reference, or handling non\u2011contiguous sub\u2011lists) as needed for your project."]}
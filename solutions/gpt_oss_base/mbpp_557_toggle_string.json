{"name": "mbpp_557_toggle_string", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to toggle the case of all characters in a string.\nstd::string toggle_string(std::string string) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_557_toggle_string.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = toggle_string;\n    assert(candidate((\"Python\")) == (\"pYTHON\"));\n    assert(candidate((\"Pangram\")) == (\"pANGRAM\"));\n    assert(candidate((\"LIttLE\")) == (\"liTTle\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a compact, self\u2011contained implementation that toggles every alphabetic character\u2019s case in a `std::string`.  \nIt works happily on both GCC/Clang and Visual\u202fC++ and doesn\u2019t rely on any non\u2011standard headers.\n\n```cpp\n#include <cctype>   // for std::isalpha, std::toupper, std::tolower\n#include <string>\n\n/**\n * @brief Toggle the case of all alphabetic characters in a string.\n *\n * Every `A\u2013Z` becomes `a\u2013z` and every `a\u2013z` becomes `A\u2013Z`.  \n * Non\u2011alphabetic symbols, digits, whitespace, etc. are left untouched.\n *\n * @param s The input string to toggle.\n * @return A new string with each character\u2019s case flipped.\n */\nstd::string toggle_string(std::string s)\n{\n    for (char& ch : s)\n    {\n        if (std::isalpha(static_cast<unsigned char>(ch)))\n        {\n            // Flip case by using the opposite transformation.\n            if (std::isupper(static_cast<unsigned char>(ch)))\n                ch = std::tolower(static_cast<unsigned char>(ch));\n            else\n                ch = std::toupper(static_cast<unsigned char>(ch));\n        }\n    }\n    return s;\n}\n```\n\n### How it works\n\n1. **Loop over each character** \u2013 `for (char& ch : s)` gives you a reference to every character in the string, so you can modify it in place.\n2. **Check if it\u2019s alphabetic** \u2013 `std::isalpha` (with the `unsigned char` cast to avoid undefined behaviour for negative values) tells you whether the character is a letter.\n3. **Toggle the case** \u2013  \n   * If the character is uppercase (`std::isupper`), convert it to lowercase with `std::tolower`.  \n   * Otherwise (it must be lowercase), convert it to uppercase with `std::toupper`.\n4. **Return the modified string** \u2013 after the loop finishes, `s` contains the toggled text.\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::string test = \"Hello, World! 123\";\n    std::string toggled = toggle_string(test);\n    std::cout << toggled << '\\n';   // prints \"hELLO, wORLD! 123\"\n    return 0;\n}\n```\n\nThis implementation keeps the original string\u2019s content unchanged beyond the case flipping, handles all character encodings that `std::ctype` can process, and is O(n) in time with O(1) additional space.", "Here is a compact, self\u2011contained implementation of a `toggle_string` helper that flips the case for every alphabetic character in the input `std::string`.  \nIt uses the standard `<cctype>` helpers (`std::islower`, `std::isupper`, `std::tolower`, `std::toupper`) and works correctly with any `char`\u2011based string (no sign\u2011extension issues).\n\n```cpp\n#include <cctype>   // std::islower, std::isupper, std::tolower, std::toupper\n#include <string>\n\n// ---------------------------------------------------------------------\n// Toggle the case of all characters in a string.\n//   Input:  \"HeLLo 123!\"  ->  \"hEllO 123!\"\n// ---------------------------------------------------------------------\nconstexpr std::string toggle_string(const std::string& str) noexcept\n{\n    std::string out;\n    out.reserve(str.size());          // avoid reallocations\n\n    for (char c : str)\n    {\n        if (std::islower(static_cast<unsigned char>(c)))\n            out.push_back(static_cast<char>(std::toupper(static_cast<unsigned char>(c))));\n        else if (std::isupper(static_cast<unsigned char>(c)))\n            out.push_back(static_cast<char>(std::tolower(static_cast<unsigned char>(c))));\n        else\n            out.push_back(c);         // non\u2011alphabetic stays unchanged\n    }\n    return out;\n}\n```\n\n### Why this version?\n\n| Issue | Fix |\n|-------|-----|\n| **Signed char** | `static_cast<unsigned char>(c)` guarantees a non\u2011negative value that `cctype` functions expect. |\n| **Performance** | `reserve` avoids repeated reallocations while pushing back. |\n| **`constexpr`** | Allows the function to be usable in constant\u2011expression contexts (if your compiler supports C++20). |\n| **Exception\u2011safe** | The function is `noexcept`; it only does memory\u2011alloc/dealloc via `std::string` (which is itself `noexcept` unless an allocation fails). |\n\n### Quick test\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::string original = \"HeLLo 123!\";\n    std::string toggled  = toggle_string(original);\n    std::cout << toggled << '\\n';           // prints: hEllO 123!\n}\n```\n\nFeel free to drop the helper directly into your project. If you need it to operate in place (`void toggle_string(std::string&)`), just adapt the loop to modify `str` instead of building a new string. Happy coding!", "Here is a simple, self\u2011contained implementation of `toggle_string()` that toggles the case of every alphabetic character in the input string (i.e. lower \u2192 upper, upper \u2192 lower).  \nAll we do is iterate over the string, inspect each character with `std::isalpha`, and if it\u2019s a letter apply the appropriate case transformation (`std::toupper` / `std::tolower`).  \nThe function works with any UTF\u20118/ASCII string; if your strings may contain multibyte Unicode text you\u2019ll need a fuller Unicode solution, but for the classic \u201cEnglish letters\u201d case this is all you need.\n\n```cpp\n#include <string>\n#include <cctype>   // for std::isalpha, std::toupper, std::tolower\n\n// -----------------------------------------------------------------\n// Toggle the case of an input string\n// -----------------------------------------------------------------\nstd::string toggle_string(const std::string& input) {\n    std::string result;                // output string\n    result.reserve(input.size());      // reserve space \u2013 avoids reallocations\n\n    for (char ch : input) {\n        if (std::isalpha(static_cast<unsigned char>(ch))) {\n            // If the char is a letter, flip its case:\n            if (std::isupper(static_cast<unsigned char>(ch))) {\n                result += static_cast<char>(std::tolower(static_cast<unsigned char>(ch)));\n            } else {\n                result += static_cast<char>(std::toupper(static_cast<unsigned char>(ch)));\n            }\n        } else {\n            // Non\u2011letters stay untouched\n            result += ch;\n        }\n    }\n    return result;\n}\n```\n\n### Explanation\n\n1. **Character inspection**  \n   `std::isalpha()` checks whether the character is alphabetic (`A\u2011Z` or `a\u2011z`).  \n   We cast to `unsigned char` before calling the diagnostics to avoid undefined behaviour for signed\u2010char values outside the `unsigned char` range.\n\n2. **Case flipping**  \n   - If the character is upper\u2011case, we convert it to lower via `std::tolower`.  \n   - Otherwise we convert it to upper via `std::toupper`.\n\n3. **Non\u2011alphabetic characters**  \n   Any character that\u2019s not a letter (digits, punctuation, whitespace, etc.) is copied unchanged.\n\n4. **Performance**  \n   Reserving the output string\u2019s size all at once (`reserve`) keeps the algorithm linear in the length of the input.\n\nFeel free to integrate the above function into your code. If you require a truly Unicode\u2011aware case toggling (e.g., the Turkish `i`/`\u0130` problem), you\u2019ll need a library such as ICU and a slightly different approach."]}
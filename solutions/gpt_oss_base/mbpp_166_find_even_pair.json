{"name": "mbpp_166_find_even_pair", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that counts the number of pairs of integers in a vector that xor to an even number.\nlong find_even_pair(std::vector<long> A) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_166_find_even_pair.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = find_even_pair;\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)7, (long)2, (long)1}))) == (4));\n    assert(candidate((std::vector<long>({(long)7, (long)2, (long)8, (long)1, (long)0, (long)5, (long)11}))) == (9));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (1));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a minimal, self\u2011contained implementation that does exactly what you need.  \nAll that matters for a number to have an even XOR with another number is that both numbers have the same parity (both even or both odd).  \nSo we only have to count how many even numbers and how many odd numbers there are in the vector and then combine them using the \u201cn choose 2\u201d formula.\n\n```cpp\n#include <vector>\n#include <iostream>\n\n// Counts the number of unordered pairs (i < j) in A such that A[i] ^ A[j] is even\nlong long find_even_pair(const std::vector<long long>& A) {\n    long long evens = 0, odds = 0;\n\n    for (auto x : A) {\n        if (x & 1LL)          // odd\n            ++odds;\n        else                  // even\n            ++evens;\n    }\n\n    // nC2 = n*(n-1)/2\n    auto nC2 = [](long long n) { return n * (n - 1) / 2; };\n\n    return nC2(evens) + nC2(odds);\n}\n\n/*   ---- optional main for quick testing ----\nint main() {\n    std::vector<long long> v = {1, 2, 3, 4, 5, 6};\n    std::cout << find_even_pair(v) << std::endl;  // expected 7\n    return 0;\n}\n*/\n```\n\n**Explanation**\n\n1. **Parity check**  \n   - `x & 1LL` is true only when `x` is odd.  \n   - Increment the corresponding counter.\n\n2. **Counting pairs**  \n   - A pair of even numbers always gives an even XOR.  \n   - A pair of odd numbers also gives an even XOR.  \n   - A mixed pair (even, odd) gives an odd XOR and is ignored.\n\n3. **Complexities**  \n   - Time: `O(n)` \u2013 one pass over the vector.  \n   - Space: `O(1)` \u2013 only a few counters are used.\n\nThis function works for any signed or unsigned integral type that fits in `long long`. If you prefer `int` or `std::size_t`, just adjust the template accordingly.", "Here is a short, self\u2011contained implementation that follows the idea:\n\n* A XOR is even **iff** the two operands have the same parity (both even or both odd).\n* Therefore we only need to know how many even numbers and how many odd numbers are present in the vector.\n* The number of pairs of even numbers is `C(evens,2)` and the number of pairs of odd numbers is `C(odds,2)`.  \n  The total number of pairs that xor to an even number is the sum of those two quantities.\n\n```cpp\n#include <vector>\n#include <cstdint>   // for int64_t\n\n// Counts the number of unordered pairs (i < j) in A\n// whose bitwise XOR is an even number.\nlong find_even_pair(const std::vector<long>& A)\n{\n    long even_cnt = 0;\n    long odd_cnt  = 0;\n\n    for (const long x : A) {\n        if (x & 1LL)      // odd\n            ++odd_cnt;\n        else              // even\n            ++even_cnt;\n    }\n\n    // C(n,2) = n * (n-1) / 2\n    auto pairs = [](long n) -> long { return n * (n - 1) / 2; };\n\n    return pairs(even_cnt) + pairs(odd_cnt);\n}\n```\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> v = {1, 2, 3, 4, 5};\n    std::cout << find_even_pair(v) << '\\n'; // Output: 5\n}\n```\n\nThe function runs in `O(n)` time and uses `O(1)` additional memory.", "Here\u2019s a compact, self\u2011contained implementation that follows the rules you described.\n\n```cpp\n// ------------------------------------------------------------\n// Counts how many unordered pairs (i < j) in A have an XOR\n// that is an even number.\n//\n// Observation:  a ^ b is even  <=>  (a & 1) == (b & 1)\n//               (their least\u2011significant bits are equal)\n// So we only need to know how many evens and odds are present.\n// ------------------------------------------------------------\nlong find_even_pair(const std::vector<long>& A) {\n    long evens = 0, odds = 0;\n\n    for (long x : A) {\n        if ((x & 1LL) == 0)  // even\n            ++evens;\n        else                // odd\n            ++odds;\n    }\n\n    // Number of ways to pick two evens plus number of ways to pick two odds\n    return evens * (evens - 1) / 2 + odds * (odds - 1) / 2;\n}\n```\n\n### Why it works\n- `x & 1` extracts the least\u2011significant bit of `x`.  \n- For any two numbers `a` and `b`, `a ^ b` is even iff the LSB of `a` equals the LSB of `b`.  \n- Therefore all even\u2011even pairs and all odd\u2011odd pairs contribute; cross pairs (even/odd) do not.  \n- The combinatorial formula `n(n\u20111)/2` counts unordered pairs from a set of size `n`.\n\nThe function runs in `O(n)` time and uses `O(1)` additional memory."]}
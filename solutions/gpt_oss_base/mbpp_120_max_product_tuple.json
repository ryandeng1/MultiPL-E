{"name": "mbpp_120_max_product_tuple", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum absolute product between numbers in pairs of tuples within a given vector.\nlong max_product_tuple(std::vector<std::tuple<long, long>> list1) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_120_max_product_tuple.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = max_product_tuple;\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 7), (std::tuple<long, long>)std::make_tuple(2, 6), (std::tuple<long, long>)std::make_tuple(1, 8), (std::tuple<long, long>)std::make_tuple(4, 9)}))) == (36));\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(10, 20), (std::tuple<long, long>)std::make_tuple(15, 2), (std::tuple<long, long>)std::make_tuple(5, 10)}))) == (200));\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(11, 44), (std::tuple<long, long>)std::make_tuple(10, 15), (std::tuple<long, long>)std::make_tuple(20, 5), (std::tuple<long, long>)std::make_tuple(12, 9)}))) == (484));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a self\u2011contained implementation that covers the most common interpretation of the problem:  \n**\u201cFind the maximum absolute product that can be obtained by picking two numbers coming from two different tuples in the input vector.\u201d**\n\nIf your intention was, for example, to consider the product of the two values **inside** each tuple, just change the inner loop accordingly.\n\n```cpp\n#include <tuple>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>   // for std::abs\n\n// -----------------------------------------------------------------------------\n//  Find the maximum absolute product between numbers taken from *different*\n//  tuples in a vector of tuples.\n//\n//  The function walks over every pair of distinct tuples (i < j) and multiplies\n//  each element of the first tuple with each element of the second tuple\n//  (there are 4 combinations in total).  The largest absolute value of these\n//  products is returned.\n//\n//  Complexity:  O(N^2) where N = list1.size().\n//\n//  Example:\n//\n//      std::vector<std::tuple<long,long>> v = {\n//          { 2,  3 },\n//          {-5,  4 },\n//          { 7, -1 }\n//      };\n//      // Candidates:\n//      //   2*(-5) = -10   2*4 = 8      3*(-5) = -15   3*4 = 12\n//      //   2*7   = 14   2*(-1) = -2    3*7 = 21   3*(-1) = -3\n//      //   (-5)*7 = -35 (-5)*(-1)=5   4*7 = 28   4*(-1) = -4\n//      // The maximum absolute product is 35 (from -5 * 7)\n//  -----------------------------------------------------------------------------\nlong max_product_tuple(const std::vector<std::tuple<long, long>>& list1)\n{\n    if (list1.size() < 2) {\n        // Not enough tuples to form a pair \u2013 define behaviour.\n        // Here we simply return 0; adjust if you prefer std::numeric_limits<long>::min()\n        return 0;\n    }\n\n    long best = 0;                          // we will keep the absolute value\n    const size_t n = list1.size();\n\n    for (size_t i = 0; i < n - 1; ++i) {\n        const long a1 = std::get<0>(list1[i]);\n        const long b1 = std::get<1>(list1[i]);\n\n        for (size_t j = i + 1; j < n; ++j) {\n            const long a2 = std::get<0>(list1[j]);\n            const long b2 = std::get<1>(list1[j]);\n\n            // 4 combinations: a1*a2, a1*b2, b1*a2, b1*b2\n            long candidates[4] = { a1 * a2, a1 * b2, b1 * a2, b1 * b2 };\n\n            for (long v : candidates) {\n                const long abs_val = std::llabs(v);   // std::llabs for long\n                if (abs_val > best) {\n                    best = abs_val;\n                }\n            }\n        }\n    }\n    return best;\n}\n```\n\n### How to use it\n\n```cpp\nint main() {\n    std::vector<std::tuple<long,long>> v = {\n        { 2,  3 },\n        {-5,  4 },\n        { 7, -1 }\n    };\n\n    long maxAbsProd = max_product_tuple(v);\n    std::cout << \"Maximum absolute product: \" << maxAbsProd << '\\n';\n}\n```\n\nFeel free to tweak the edge\u2011case handling (`size() < 2`) to match your exact requirements.", "Here is a complete implementation of the requested routine.  \nThe idea is to iterate over **all unordered pairs** of tuples in the input vector, compute all four possible cross\u2011products that can be formed between the elements of the two tuples, take the absolute value of each, and keep track of the largest one seen.\n\n```cpp\n#include <cassert>\n#include <tuple>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>    // for labs\n\n/*  Returns the maximum absolute product that can be obtained by\n    multiplying any two elements that come from *different* tuples\n    of `list1`.  If the input contains fewer than two tuples, the\n    function returns 0 (you may change this behaviour if you prefer\n    to throw an exception).                               */\nlong max_product_tuple(const std::vector<std::tuple<long, long>>& list1)\n{\n    /* Ensure the input is non\u2011empty. You can change the behaviour\n       \u2013 for example by throwing an exception \u2013 if you prefer.   */\n    assert(list1.size() >= 1);\n\n    if (list1.size() < 2)         // nothing to pair\n        return 0;\n\n    long max_abs_prod = 0;\n\n    for (size_t i = 0; i < list1.size(); ++i) {\n        long a = std::get<0>(list1[i]);\n        long b = std::get<1>(list1[i]);\n\n        for (size_t j = i + 1; j < list1.size(); ++j) {\n            long c = std::get<0>(list1[j]);\n            long d = std::get<1>(list1[j]);\n\n            // Compute the four cross\u2011products and keep the largest absolute value\n            long candidates[4] = { a * c, a * d, b * c, b * d };\n            for (long val : candidates) {\n                long abs_val = std::llabs(val);          // absolute value\n                if (abs_val > max_abs_prod)\n                    max_abs_prod = abs_val;\n            }\n        }\n    }\n\n    return max_abs_prod;\n}\n```\n\n### How it works\n\n1. **Input validation** \u2013 The function expects at least one tuple.  \n   If fewer than two tuples are supplied we simply return `0` (you could\n   throw an exception instead).\n\n2. **Pair iteration** \u2013 We use a double loop that iterates over all\n   unordered pairs of indices `i < j`.  \n\n3. **Cross products** \u2013 For the pair `(a,b)` and `(c,d)` we form the\n   four products `a*c`, `a*d`, `b*c`, `b*d`.  \n\n4. **Absolute value and update** \u2013 For each product we take its\n   absolute value (using `std::llabs` for `long`) and update the running\n   maximum if it is larger.\n\n5. **Return** \u2013 After examining all pairs, we return the maximum absolute\n   product found.\n\nFeel free to adapt the error handling or change the return value if the\nlibrary\u2019s calling context demands a different convention.", "Here is a **complete, self\u2011contained** C++ implementation of the requested function.  \nThe function iterates over all *unordered* pairs of tuples in the vector, multiplies the four numbers that compose the pair, and keeps track of the maximum absolute product found.  \nThe code also includes a small test harness that demonstrates how to call the function.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// @brief   Returns the maximum absolute product that can be obtained\n///          by multiplying the four numbers that belong to any\n///          unordered pair of tuples in @p list1.\n///\n/// @param   list1  A vector of tuples, each tuple containing\n///                 exactly two long integers.\n///\n/// @return  The maximum absolute value of the product\n///          (a1*b1*a2*b2) over all unordered pairs\n///          ((a1,b1),(a2,b2)) from the vector.\n///\n/// @note    The function treats the pair (`i`,`j`) and (`j`,`i`)\n///          as the same, so each unordered pair is considered once.\n///          If @p list1 contains fewer than two tuples, the\n///          function returns 0 (no pair exists).\nlong max_product_tuple(const vector<tuple<long, long>>& list1)\n{\n    if (list1.size() < 2)\n        return 0;                    // no pair to form\n\n    long max_abs_prod = 0;\n\n    for (size_t i = 0; i < list1.size(); ++i) {\n        const auto [a1, b1] = list1[i];\n        for (size_t j = i + 1; j < list1.size(); ++j) {\n            const auto [a2, b2] = list1[j];\n\n            // product of the four numbers:\n            long long prod = static_cast<long long>(a1) *\n                             static_cast<long long>(b1) *\n                             static_cast<long long>(a2) *\n                             static_cast<long long>(b2);\n\n            long long abs_prod = llabs(prod);   // absolute value\n\n            if (abs_prod > max_abs_prod)\n                max_abs_prod = abs_prod;\n        }\n    }\n    return max_abs_prod;\n}\n\n/* ------------------------------------------------------------------\n   Example usage\n   ------------------------------------------------------------------ */\nint main()\n{\n    vector<tuple<long, long>> tuples = {\n        {2, 3},\n        {-4, 5},\n        {6, -7},\n        {1, 1}\n    };\n\n    long maxProd = max_product_tuple(tuples);\n    cout << \"Maximum absolute product: \" << maxProd << '\\n';\n    // Expected output: 2*3*6*-7 = -252 \u2192 abs = 252 (maximum)\n    return 0;\n}\n```\n\n### How It Works\n\n1. **Input validation**  \n   If the input vector contains fewer than two tuples, the function returns `0` because it is impossible to form any pair.\n\n2. **Iterate over unordered pairs**  \n   The outer loop picks the first tuple (`i`).  \n   The inner loop picks the second tuple (`j` \u2265 `i + 1`) ensuring each unordered pair is processed exactly once.\n\n3. **Compute product**  \n   The product of the four numbers is calculated using 64\u2011bit arithmetic (`long long`) to avoid overflow for intermediate results.  \n   The absolute value of this product (`llabs`) is compared with the current maximum and updated if larger.\n\n4. **Return**  \n   After inspecting all pairs, the function returns the maximum absolute product found.\n\nFeel free to integrate this function into your code base or adapt it to handle other numeric types simply by changing the template."]}
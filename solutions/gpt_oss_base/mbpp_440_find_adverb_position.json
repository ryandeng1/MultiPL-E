{"name": "mbpp_440_find_adverb_position", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the first adverb and their positions in a given sentence.\nstd::tuple<long, long, std::string> find_adverb_position(std::string text) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_440_find_adverb_position.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = find_adverb_position;\n    assert(candidate((\"clearly!! we can see the sky\")) == (std::make_tuple(0, 7, \"clearly\")));\n    assert(candidate((\"seriously!! there are many roses\")) == (std::make_tuple(0, 9, \"seriously\")));\n    assert(candidate((\"unfortunately!! sita is going to home\")) == (std::make_tuple(0, 13, \"unfortunately\")));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a minimal, self\u2011contained implementation that:\n\n* Removes punctuation (so that words like \u201clate,\u201d don\u2019t end up being read as \u201clate,\u201d)\n* Splits the sentence into words\n* Looks for the **first** word which matches a very\u2011simple adverb rule (ends in **ly** or is one of a few custom adverbs)\n* Returns a tuple `(start , end , word)` where:\n  * `start` \u2013 index of the first character of the adverb in the original string  \n  * `end`   \u2013 index of the last character of the adverb in the original string  \n  * `word`  \u2013 the adverb itself\n\n> **Note** \u2013 The adverb\u2011recognition logic is intentionally simple.  If you need a full\u2011fledged natural\u2011language\u2011processing solution you will have to replace the logic with a library such\u2011as SpaCy or NLTK.\n\n```cpp\n#include <iostream>\n#include <tuple>\n#include <string>\n#include <vector>\n#include <cctype>\n#include <algorithm>\n#include <cassert>\n\nnamespace {\n\n// ---------- helpers -------------------------------------------------------\n\n// Strip punctuation from the string *while preserving indexes*.\n// Returns a vector of (original_index, character) pairs for the *clean* string.\nstd::vector<std::pair<std::size_t, char>> strip_punctuation(const std::string& text) {\n    std::vector<std::pair<std::size_t, char>> clean;\n    for (std::size_t i = 0; i < text.size(); ++i) {\n        if (!std::ispunct(static_cast<unsigned char>(text[i]))) {\n            clean.emplace_back(i, text[i]);\n        }\n    }\n    return clean;\n}\n\n// Split the cleaned string into words and remember the original start/stop indices.\nstruct WordRange {\n    std::size_t start;   // index in the original string\n    std::size_t end;     // inclusive index in the original string\n    std::string  word;\n};\n\nstd::vector<WordRange> split_words(const std::string& text) {\n    std::vector<WordRange> words;\n    std::size_t i = 0;\n    while (i < text.size()) {\n        // skip whitespace\n        while (i < text.size() && std::isspace(static_cast<unsigned char>(text[i]))) ++i;\n        if (i >= text.size())\n            break;\n        std::size_t start = i;\n        while (i < text.size() && !std::isspace(static_cast<unsigned char>(text[i]))) ++i;\n        std::size_t end = i - 1;\n        words.push_back({start, end, text.substr(start, end - start + 1)});\n    }\n    return words;\n}\n\n// Very simple adverb check \u2013 ends with \"ly\" (case\u2011insensitive) or is in a hand\u2011written list.\nbool is_adverb(const std::string& word) {\n    if (word.empty())\n        return false;\n\n    // Three special adverbs that don't end in \"ly\" but are commonly used\n    static const std::vector<std::string> irregular = {\"again\", \"later\", \"today\"};\n    for (const auto& inc : irregular) {\n        if (strcasecmp(word.c_str(), inc.c_str()) == 0)\n            return true;\n    }\n\n    // A case\u2011insensitive suffix check for \"ly\"\n    if (word.size() >= 2) {\n        std::string suffix = word.substr(word.size() - 2);\n        std::transform(suffix.begin(), suffix.end(), suffix.begin(), ::tolower);\n        return suffix == \"ly\";\n    }\n    return false;\n}\n\n} // namespace\n\n// ---------- public API -----------------------------------------------------\n\n/**\n * Finds the first adverb in *text* and returns a tuple containing:\n *  - the start index of the adverb (first character)\n *  - the end index of the adverb (last character)\n *  - the adverb string itself\n *\n * If no adverb is found the tuple will contain (-1, -1, \"\").\n */\nstd::tuple<long, long, std::string>\nfind_adverb_position(const std::string text) {\n    // 1) Split the sentence into words with their original positions.\n    auto words = split_words(text);\n\n    // 2) Find the first word that passes the adverb test.\n    for (const auto& wr : words) {\n        if (is_adverb(wr.word)) {\n            // The start index is wr.start, the end index is wr.end\n            return {static_cast<long>(wr.start),\n                    static_cast<long>(wr.end),\n                    wr.word};\n        }\n    }\n\n    // No adverb found\n    return {-1, -1, \"\"};\n}\n\n} // namespace adverb_finder\n\n// ---------- test harness --------------------------------------------------\n\nint main() {\n    using std::string;\n    using std::tuple;\n\n    std::vector<std::pair<string, tuple<long,long,string>>> tests = {\n        {\"The quick brown fox jumps over the lazy dog.\",   {-1,-1,\"\"}           },\n        {\"She sang beautifully.\",                           {4, 14, \"beautifully\"}},\n        {\"Run fast, run furiously!\",                        {4, 8,  \"fast\"}      },\n        {\"He will arrive tomorrow.\",                        {5, 11, \"tomorrow\"}  },\n        {\"Slowly and steadily, he moved.\",                  {0, 5,  \"slowly\"}    },\n        {\"Late, he arrived.\",                               {5, 8,  \"late\"}      },\n    };\n\n    for (auto& [sentence, expected] : tests) {\n        auto res = adverb_finder::find_adverb_position(sentence);\n        assert(res == expected);\n        std::cout << \"ok: \\\"\" << sentence << \"\\\" \u2192 \" << std::get<2>(res)\n                  << \" (\" << std::get<0>(res) << \",\" << std::get<1>(res) << \")\\n\";\n    }\n\n    std::cout << \"All tests passed.\\n\";\n    return 0;\n}\n```\n\n**Explanation of the core logic**\n\n1. **Tokenisation**  \n   `split_words` scans the original string and keeps track of the exact character positions (`start` & `end`) for each word. No stripping of punctuation is done here because we want the original positions.\n\n2. **Adverb detection**  \n   `is_adverb` looks for words that end in \u201cly\u201d (case\u2011insensitive) or that belong to a short list of hard\u2011coded frequent adverbs that do not follow the pattern.\n\n3. **Result**  \n   The first word that passes `is_adverb` is returned with its original indices and the word itself.  If no such word exists, `(-1,-1,\"\")` is returned.\n\nFeel free to replace `is_adverb` with a more sophisticated NLP method if you need more accurate adverb detection.", "Below is a compact and self\u2011contained implementation that\n\n* receives a sentence as a `std::string`  \n* tokenises it into individual words (splitting on spaces and punctuation)  \n* searches the token list for the first word that matches a very simple \u201cadverb\u201d rule \u2013  \n  in this example a word ending in **\u2011ly** (you can replace the test with a full\u2011blown\n  dictionary lookup if you prefer)  \n* returns a tuple with  \n  * the index of the word in the *token* array (`first_index`)  \n  * the byte offset of the same word in the original string (`char_offset`)  \n  * the word itself (`std::string`)\n\nThe function uses only the C++17 standard library \u2013 no external dependencies.\n\n```cpp\n#include <tuple>\n#include <string>\n#include <cctype>\n#include <algorithm>\n\n// Helper that removes surrounding punctuation from a word\ninline std::string trim_punct(const std::string& w)\n{\n    auto l = w.begin();\n    while (l != w.end() && std::ispunct(static_cast<unsigned char>(*l))) ++l;\n    auto r = w.end();\n    while (r != l && std::ispunct(static_cast<unsigned char>(*(r-1)))) --r;\n    return std::string(l, r);\n}\n\n// The \u201cdictionary\u201d check \u2013 simple suffix test.  The user can replace this\n// with whatever lookup they wish.\ninline bool is_adverb(const std::string& w)\n{\n    if (w.size() < 3) return false;            // very short words are unlikely\n    std::string t = w;\n    std::transform(t.begin(), t.end(), t.begin(), ::tolower);\n    return t.size() >= 3 && t.compare(t.size()-2, 2, \"ly\") == 0;\n}\n\n/**\n * @brief Find the first adverb in a sentence.\n *\n * @param text The sentence to inspect.\n * @return std::tuple<long, long, std::string>\n *          - word index (0\u2011based)        \u2192 long\n *          - character offset in text   \u2192 long\n *          - the adverb itself (trimmed)\n *          If no adverb is found, the first element is -1,\n *          the second element is -1, and the third element is empty.\n */\nstd::tuple<long, long, std::string> find_adverb_position(const std::string& text)\n{\n    long word_index  = -1;\n    long char_offset = -1;\n    std::string adverb;\n\n    size_t pos = 0;   // current character index in `text`\n    size_t token_start = std::string::npos; // start of current token\n\n    while (pos <= text.size())                         // one extra iteration for the last token\n    {\n        if (pos == text.size() || std::isspace(static_cast<unsigned char>(text[pos])))\n        {\n            if (token_start != std::string::npos)\n            {\n                std::string raw_word = text.substr(token_start, pos - token_start);\n                std::string word = trim_punct(raw_word);\n                if (!word.empty() && is_adverb(word))\n                {\n                    adverb      = word;\n                    word_index  = static_cast<long>(pos - (pos - token_start)); // token order\n                    char_offset = static_cast<long>(token_start);\n                    break;\n                }\n                ++word_index;\n                token_start = std::string::npos;\n            }\n        }\n        else if (token_start == std::string::npos)\n        {\n            token_start = pos;   // start of a new token\n        }\n        ++pos;\n    }\n\n    return std::make_tuple(word_index, char_offset, adverb);\n}\n```\n\n### How to use it\n\n```cpp\nint main()\n{\n    std::string sentence = \"She walked slowly, and the birds sang happily.\";\n    auto [idx, offset, adv] = find_adverb_position(sentence);\n\n    if (idx != -1) {\n        std::cout << \"First adverb: \" << adv << '\\n'\n                  << \"Word index: \" << idx << '\\n'\n                  << \"Character offset: \" << offset << '\\n';\n    } else {\n        std::cout << \"No adverb found.\\n\";\n    }\n}\n```\n\nThe function respects word boundaries defined by whitespace and trims punctuation from the ends of words before applying the adverb test. Feel free to replace `is_adverb()` with any more sophisticated lookup (e.g., a hash\u2011set of known adverbs) if you need more accuracy.", "Here is a minimal yet complete implementation that searches for the first word whose suffix is \u201c\u2011ly\u201d (the most common indicator of an adverb in English) and returns its starting position, its ending position, and the word itself.  \nFeel free to adjust the criteria if you need a more sophisticated adverb detection (e.g. a dictionary lookup).  \n\n```cpp\n#include <iostream>\n#include <tuple>\n#include <cctype>\n#include <string>\n#include <algorithm>\n\n/* -------------------------------------------------------------\n   Utility helpers\n   ------------------------------------------------------------- */\n// trim leading/trailing whitespace\ninline std::string trim(const std::string& s) {\n    auto start = s.begin();\n    while (start != s.end() && std::isspace(*start)) ++start;\n    auto end = s.end();\n    do { --end; } while (std::distance(start, end) > 0 && std::isspace(*end));\n    return std::string(start, end + 1);\n}\n\n// check if a word ends with \u201cly\u201d\ninline bool is_adverb(const std::string& word) {\n    if (word.size() < 3) return false;\n    const std::string suffix = \"ly\";\n    return word.compare(word.size() - suffix.size(), suffix.size(), suffix) == 0;\n}\n\n/* -------------------------------------------------------------\n   Main function\n   ------------------------------------------------------------- */\nstd::tuple<long, long, std::string> find_adverb_position(const std::string& text)\n{\n    const std::string& str = text;\n\n    long start = -1;   // will be set on first adverb\n    long end   = -1;\n    std::string adverb;\n\n    // Simple state machine to walk through the characters\n    std::size_t i = 0;\n    while (i < str.size()) {\n        // Skip white space\n        if (std::isspace(static_cast<unsigned char>(str[i]))) {\n            ++i;\n            continue;\n        }\n\n        // Identify the start of a token\n        std::size_t token_start = i;\n        while (i < str.size() && !std::isspace(static_cast<unsigned char>(str[i]))) {\n            ++i;\n        }\n        std::size_t token_end = i;          // one past the last character\n\n        std::string token = trim(str.substr(token_start, token_end - token_start));\n\n        // Remove punctuation from the ends\n        std::size_t begin = 0;\n        while (begin < token.size() && std::ispunct(static_cast<unsigned char>(token[begin]))) ++begin;\n        std::size_t endp = token.size();\n        while (endp > begin && std::ispunct(static_cast<unsigned char>(token[endp-1]))) --endp;\n        std::string clean = token.substr(begin, endp - begin);\n\n        if (is_adverb(clean)) {\n            start = static_cast<long>(token_start + begin);\n            end   = static_cast<long>(token_start + endp - 1);   // inclusive end\n            adverb = clean;\n            break;     // first adverb found\n        }\n    }\n\n    return std::make_tuple(start, end, adverb);\n}\n\n/* -------------------------------------------------------------\n   Example usage / test harness\n   ------------------------------------------------------------- */\nint main()\n{\n    std::string sentence = \"She quickly ran to the store after doing her laundry.\";\n    auto [begin, end, adv] = find_adverb_position(sentence);\n\n    if (!adv.empty()) {\n        std::cout << \"First adverb: \\\"\" << adv << \"\\\"\\n\";\n        std::cout << \"Start index:  \" << begin << \"\\n\";\n        std::cout << \"End   index:  \" << end   << \"\\n\";\n    } else {\n        std::cout << \"No adverb found.\\n\";\n    }\n    return 0;\n}\n```\n\n**Explanation of the logic**\n\n1. **Tokenization** \u2013 The string is broken into whitespace\u2011separated \u201ctokens.\u201d  \n2. **Cleaning** \u2013 Leading and trailing punctuation is removed before testing the token.  \n3. **Adverb detection** \u2013 The helper `is_adverb` simply checks if the cleaned token ends with \u201cly.\u201d  \n4. **Position calculation** \u2013 When the first adverb is found we compute:\n   - `start` \u2013 the start index of the clean token in the original string.  \n   - `end` \u2013 the end index (inclusive) in the original string.  \n5. **Return** \u2013 A `std::tuple<long, long, std::string>` containing the start index, end index, and the adverb itself.\n\nYou can replace the `is_adverb` function with any other criterion (e.g., a lookup in a word list) if you need stricter adverb recognition."]}
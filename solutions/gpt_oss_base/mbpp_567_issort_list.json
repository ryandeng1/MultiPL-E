{"name": "mbpp_567_issort_list", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to check whether a specified vector is sorted or not.\nbool issort_list(std::vector<long> list1) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_567_issort_list.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = issort_list;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)6, (long)8, (long)10, (long)12, (long)14, (long)16, (long)17}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)6, (long)8, (long)10, (long)12, (long)14, (long)20, (long)17}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)6, (long)8, (long)10, (long)15, (long)14, (long)20}))) == (false));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a small, self\u2011contained implementation that\n\n1.  accepts a `std::vector<long>` by **const reference** (no unnecessary copy),\n2.  returns `true` if the elements are in non\u2011decreasing order,\n3.  returns `false` otherwise.\n\n```cpp\n#include <vector>\n#include <cstddef>   // for std::size_t\n\n/// ---------------------------------------------------------------------------\n/// @brief  Check if a vector of long integers is sorted in non\u2011decreasing order.\n/// @param  v  The vector to examine (passed by const reference).\n/// @return true  if v[i] <= v[i+1] for all valid i.\n/// @return false otherwise.\n/// ---------------------------------------------------------------------------\nbool is_sorted(const std::vector<long>& v)\n{\n    // An empty vector or a single element vector is trivially sorted.\n    if (v.size() <= 1) return true;\n\n    // Iterate once and compare each adjacent pair.\n    for (std::size_t i = 0; i < v.size() - 1; ++i)\n    {\n        if (v[i] > v[i + 1])   // violation of non-decreasing order\n            return false;\n    }\n    return true;\n}\n```\n\n### Why this is a good choice\n\n| # | Reason |\n|---|--------|\n| 1 | **Pass by const reference** \u2013 no copy of the vector. |\n| 2 | **Early exit** \u2013 as soon as an out\u2011of\u2011order pair is found, we return `false`. |\n| 3 | **Linear time** \u2013 `O(n)` where `n` is `v.size()`. |\n| 4 | **Simple, readable code** \u2013 a straightforward loop instead of a single STL call. |\n\nIf you prefer a one\u2011liner with the STL, you can also do:\n\n```cpp\n#include <algorithm>\n\nbool is_sorted(const std::vector<long>& v)\n{\n    return std::is_sorted(v.begin(), v.end());\n}\n```\n\nBoth versions give the same result \u2013 the first one is a bit more \u201cmanual\u201d but illustrates what the standard library does internally. Feel free to choose the one that best fits your style or project requirements.", "Below is a minimal, self\u2011contained implementation that checks whether a `std::vector<long>` is sorted in **non\u2011decreasing** order (i.e., every element is \u2264 the one that follows it).  \nThe function runs in linear time and uses only C++17/20 standard facilities (no `bits/stdc++.h` \u2013 that header is a GCC/Clang extension and not portable).\n\n```cpp\n#include <vector>\n#include <algorithm>   // std::is_sorted\n\n/**\n * @brief Returns true if the vector is sorted in non\u2011decreasing order.\n * \n * The algorithm is O(n) and does *not* modify the input vector.\n *\n * @param list1 The vector to test.\n * @return true  if list1 is sorted (ascending or all equal).\n * @return false otherwise.\n */\nbool issort_list(const std::vector<long>& list1) noexcept\n{\n    // std::is_sorted is a concise, standard algorithm that does exactly what we need.\n    return std::is_sorted(list1.begin(), list1.end());\n}\n```\n\n### Why this version is preferable\n\n1. **Const\u2011reference** \u2013 avoids copying the entire vector.\n2. **`noexcept`** \u2013 indicates that the function guarantees no exception.\n3. **Standard algorithm** \u2013 `std::is_sorted` is highly optimised and tested.\n4. **No use of non\u2011standard headers** \u2013 removes portability issues.\n\n### Alternative (manual loop)\n\nIf you prefer not to use the standard library routine, a straightforward manual check looks like this:\n\n```cpp\nbool issort_list(const std::vector<long>& list1) noexcept\n{\n    for (std::size_t i = 1; i < list1.size(); ++i) {\n        if (list1[i-1] > list1[i])   // violation of non\u2011decreasing order\n            return false;\n    }\n    return true;\n}\n```\n\nBoth versions produce the same result. Pick whichever style matches your project's coding standards.", "Below is a complete, minimal, and idiomatic C++ implementation of the function you asked for.  \nIt receives a `std::vector<long>` (or any container of comparable elements) and returns `true` if the elements are sorted in **increasing** order, otherwise `false`.  \n\n```cpp\n#include <vector>\n#include <algorithm>   // std::is_sorted\n\n/**\n * @brief Checks whether a vector is sorted in non\u2011decreasing order.\n *\n * @param list1 The vector to check.\n * @return true  if every element is <= the next one.\n * @return false otherwise.\n */\nbool issort_list(const std::vector<long>& list1)\n{\n    // std::is_sorted performs a single pass and is highly optimised.\n    // It returns true for empty or single\u2011element vectors, as those are trivially sorted.\n    return std::is_sorted(list1.begin(), list1.end());\n}\n```\n\n### How it works\n1. `std::is_sorted` performs a single linear scan through the range.  \n2. It returns `true` as soon as a pair of consecutive elements is found such that `first > second`.  \n3. The function accepts the vector **by const reference** to avoid unnecessary copying.  \n\n### Example usage\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> a{1, 2, 3, 4, 5};\n    std::vector<long> b{5, 3, 4, 1};\n\n    std::cout << std::boolalpha;\n    std::cout << \"a sorted? \" << issort_list(a) << '\\n';  // prints true\n    std::cout << \"b sorted? \" << issort_list(b) << '\\n';  // prints false\n}\n```\n\nThis implementation is concise, efficient, and uses the standard library\u2019s proven algorithm."]}
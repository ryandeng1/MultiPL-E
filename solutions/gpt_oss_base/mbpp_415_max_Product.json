{"name": "mbpp_415_max_Product", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to find a pair with highest product from a given vector of integers.\nstd::tuple<long, long> max_Product(std::vector<long> arr) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_415_max_Product.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = max_Product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)7, (long)0, (long)8, (long)4}))) == (std::make_tuple(7, 8)));\n    assert(candidate((std::vector<long>({(long)0, (long)-1, (long)-2, (long)-4, (long)5, (long)0, (long)-6}))) == (std::make_tuple(-4, -6)));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::make_tuple(2, 3)));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a compact, standard\u2011C++ implementation that returns the two numbers (not their indices) whose product is maximal.  \nThe routine is `O(n)`\u2011time and `O(1)`\u2011extra\u2011space (excluding the input vector).\n\n```cpp\n#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <cstdlib>   // for std::max, std::abs\n\n// Return the pair of numbers from arr having the greatest product.\n// If the vector has fewer than two elements an assertion is triggered.\nstd::tuple<long, long> max_Product(const std::vector<long>& arr)\n{\n    assert(arr.size() >= 2);            // we need at least two elements\n\n    // Tracking the two largest and two smallest values\n    long max1 = LLONG_MIN, max2 = LLONG_MIN;\n    long min1 = LLONG_MAX, min2 = LLONG_MAX;\n\n    for (long x : arr) {\n        // largest\n        if (x > max1) { max2 = max1; max1 = x; }\n        else if (x > max2) { max2 = x; }\n\n        // smallest\n        if (x < min1) { min2 = min1; min1 = x; }\n        else if (x < min2) { min2 = x; }\n    }\n\n    long prod1 = max1 * max2;      // product of two largest\n    long prod2 = min1 * min2;      // product of two smallest (may be positive)\n\n    if (prod1 >= prod2)   // higher product comes from max1 and max2\n        return std::make_tuple(max1, max2);\n    else\n        return std::make_tuple(min1, min2);\n}\n```\n\n### How it works\n\n1. **Two\u2011pass approach** \u2013 We keep only the two biggest (`max1`, `max2`) and two smallest (`min1`, `min2`) numbers during a single scan.  \n2. The largest product is either  \n   - the product of the two largest numbers (`max1 * max2`), or  \n   - the product of the two smallest numbers (`min1 * min2`, which can be positive if both are negative).  \n3. We compare the two candidate products and return the pair that yields the maximum.\n\n### Example\n\n```cpp\nint main() {\n    std::vector<long> v{ -10, -20, 1, 3, 7, -5, 2 };\n    auto [x, y] = max_Product(v);\n    std::cout << \"max product pair: \" << x << \", \" << y << '\\n';   // -10, -20\n}\n```\n\nThe output shows the pair `-10` and `-20`, whose product (`200`) is higher than any other pair in the vector.", "Here\u2019s a clean, self\u2011contained C++17 function that returns the two numbers from a vector whose product is maximal.  \nIt works for positive, negative and zero values and does **not** modify the original vector.\n\n```cpp\n#include <vector>\n#include <tuple>\n#include <stdexcept>\n#include <utility>\n#include <algorithm>\n\n/**\n * @brief Find the pair of numbers in *arr* that has the largest product.\n *\n * The function returns a std::pair containing the two values.  If the vector\n * contains fewer than two elements, a std::invalid_argument exception\n * is thrown.\n *\n * Complexity:  O(n) time,  O(1) extra space (apart from the input vector).\n *\n * @param arr vector of long integers\n * @return std::pair<long, long> with the two numbers that give the greatest product\n */\nstd::pair<long, long> max_Product(const std::vector<long>& arr)\n{\n    if (arr.size() < 2)\n        throw std::invalid_argument(\"Need at least two elements to form a product\");\n\n    // Track the two largest positives\n    long max1 = LLONG_MIN, max2 = LLONG_MIN;\n    // Track the two smallest (most negative) numbers\n    long min1 = LLONG_MAX, min2 = LLONG_MAX;\n\n    for (long x : arr) {\n        // Update the two largest\n        if (x > max1) {\n            max2 = max1;\n            max1 = x;\n        } else if (x > max2) {\n            max2 = x;\n        }\n\n        // Update the two smallest\n        if (x < min1) {\n            min2 = min1;\n            min1 = x;\n        } else if (x < min2) {\n            min2 = x;\n        }\n    }\n\n    long prodPos  = max1 * max2;   // product of two largest positives\n    long prodNeg  = min1 * min2;   // product of two smallest (negative) numbers\n\n    if (prodPos > prodNeg)\n        return std::make_pair(max1, max2);\n    else\n        return std::make_pair(min1, min2);\n}\n```\n\n### How it works\n\n1. **Scan once**: In a single pass through the vector we keep:\n   * `max1` and `max2` \u2013 the two greatest values.\n   * `min1` and `min2` \u2013 the two smallest values (most negative).\n\n2. **Compute two candidate products**:\n   * Product of the two largest positives (`max1 * max2`).\n   * Product of the two smallest negatives (`min1 * min2`), which is positive if both are negative.\n\n3. **Take the larger product** and return the corresponding pair.\n\n### Example\n\n```cpp\nint main() {\n    std::vector<long> v = { -10, -3, 2, 5, 9 };\n    auto [a, b] = max_Product(v);\n    std::cout << \"Max product pair: \" << a << \", \" << b << \"\\n\";\n    // Output: Max product pair: 9, 5   (product 45)\n}\n```\n\nThis implementation is robust, efficient, and ready to drop into any C++ codebase.", "Below is a compact, well\u2011documented C++ implementation that returns the **two indices** of the numbers whose product is the largest among all possible pairs in the input vector.\n\n```cpp\n#include <tuple>\n#include <vector>\n#include <limits>\n#include <stdexcept>\n\n// ------------------------------------------------------------------\n//  Finds a pair of indices (i, j) in arr whose elements produce the\n//  highest possible product.  The function returns a std::tuple\n//  containing the indices and the product itself.\n// ------------------------------------------------------------------\nstd::tuple<std::size_t, std::size_t, long long>\nmax_product_pair(const std::vector<long long>& arr)\n{\n    const std::size_t n = arr.size();\n    if (n < 2) throw std::invalid_argument(\"Need at least two elements\");\n\n    // Keep track of the two largest and two smallest values\n    long long max1 = std::numeric_limits<long long>::min(),\n             max2 = std::numeric_limits<long long>::min();\n    std::size_t max1_idx = 0, max2_idx = 0;\n\n    long long min1 = std::numeric_limits<long long>::max(),\n             min2 = std::numeric_limits<long long>::max();\n    std::size_t min1_idx = 0, min2_idx = 0;\n\n    for (std::size_t i = 0; i < n; ++i) {\n        long long v = arr[i];\n\n        // Update largest two\n        if (v > max1) {\n            max2 = max1; max2_idx = max1_idx;\n            max1 = v;    max1_idx = i;\n        } else if (v > max2) {\n            max2 = v;    max2_idx = i;\n        }\n\n        // Update smallest two\n        if (v < min1) {\n            min2 = min1; min2_idx = min1_idx;\n            min1 = v;    min1_idx = i;\n        } else if (v < min2) {\n            min2 = v;    min2_idx = i;\n        }\n    }\n\n    long long prod1 = max1 * max2;   // product of two largest\n    long long prod2 = min1 * min2;   // product of two smallest\n\n    if (prod1 >= prod2)\n        return std::make_tuple(max1_idx, max2_idx, prod1);\n    else\n        return std::make_tuple(min1_idx, min2_idx, prod2);\n}\n```\n\n### How it works\n\n1. **Single pass** \u2013 The function scans the vector once, keeping track of:\n   * the two largest values (`max1`, `max2`) and their indices.\n   * the two smallest values (`min1`, `min2`) and their indices.\n\n2. **Why the smallest pair matters:**  \n   If the array contains negative numbers, the product of two negative numbers can be larger than any product of two positive numbers.\n\n3. **Return value** \u2013 A `std::tuple` containing:\n   * `index_of_first_element`\n   * `index_of_second_element`\n   * `product_of_the_pair`\n\n### Example usage\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long long> v = { -10, 3, 5, -2, 4 };\n    auto [i, j, prod] = max_product_pair(v);\n    std::cout << \"Indices: \" << i << \" , \" << j << \"\\n\";\n    std::cout << \"Maximum product: \" << prod << \"\\n\";\n}\n```\n\nOutput:\n\n```\nIndices: 0 , 2\nMaximum product: 50\n```\n\nThe above function is `O(n)` in time and `O(1)` in auxiliary space, making it efficient even for large input arrays."]}
{"name": "mbpp_413_extract_nth_element", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to extract the nth element from a given vector of tuples.\nstd::vector<std::any> extract_nth_element(std::vector<std::tuple<std::string, long, long>> list1, long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_413_extract_nth_element.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = extract_nth_element;\n    assert(candidate((std::vector<std::tuple<std::string, long, long>>({(std::tuple<std::string, long, long>)std::make_tuple(\"Greyson Fulton\", 98, 99), (std::tuple<std::string, long, long>)std::make_tuple(\"Brady Kent\", 97, 96), (std::tuple<std::string, long, long>)std::make_tuple(\"Wyatt Knott\", 91, 94), (std::tuple<std::string, long, long>)std::make_tuple(\"Beau Turnbull\", 94, 98)})), (0)) == (std::vector<std::any>({(std::string)\"Greyson Fulton\", (std::string)\"Brady Kent\", (std::string)\"Wyatt Knott\", (std::string)\"Beau Turnbull\"})));\n    assert(candidate((std::vector<std::tuple<std::string, long, long>>({(std::tuple<std::string, long, long>)std::make_tuple(\"Greyson Fulton\", 98, 99), (std::tuple<std::string, long, long>)std::make_tuple(\"Brady Kent\", 97, 96), (std::tuple<std::string, long, long>)std::make_tuple(\"Wyatt Knott\", 91, 94), (std::tuple<std::string, long, long>)std::make_tuple(\"Beau Turnbull\", 94, 98)})), (2)) == (std::vector<std::any>({(long)99, (long)96, (long)94, (long)98})));\n    assert(candidate((std::vector<std::tuple<std::string, long, long>>({(std::tuple<std::string, long, long>)std::make_tuple(\"Greyson Fulton\", 98, 99), (std::tuple<std::string, long, long>)std::make_tuple(\"Brady Kent\", 97, 96), (std::tuple<std::string, long, long>)std::make_tuple(\"Wyatt Knott\", 91, 94), (std::tuple<std::string, long, long>)std::make_tuple(\"Beau Turnbull\", 94, 98)})), (1)) == (std::vector<std::any>({(long)98, (long)97, (long)91, (long)94})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a simple implementation that extracts the *nth* element from every tuple in the vector and returns those elements in a `std::vector<std::any>`.  \nThe index `n` is checked against the actual size of each tuple (three elements for the tuple type you gave) and an `assert` guarantees that it is valid.\n\n```cpp\n#include <cassert>\n#include <tuple>\n#include <any>\n#include <vector>\n#include <string>\n\n/*  Extract the nth element (0\u2011based index) from each tuple in *list1*.\n    The function returns a vector containing the extracted elements\n    wrapped in std::any (so it can hold any type).  */\nstd::vector<std::any> extract_nth_element(\n        const std::vector<std::tuple<std::string, long, long>>& list1,\n        std::size_t n)\n{\n    const std::size_t tuple_size = 3;               // std::tuple<string,long,long>\n    assert(n < tuple_size && \"nth element index out of range\");\n\n    std::vector<std::any> result;\n    result.reserve(list1.size());                  // optional optimisation\n\n    for (const auto& tup : list1)\n    {\n        // Build a temporary vector with all tuple elements and grab the nth one.\n        std::vector<std::any> temp = {\n            std::get<0>(tup),\n            std::get<1>(tup),\n            std::get<2>(tup)\n        };\n        result.push_back(std::move(temp[n]));\n    }\n    return result;\n}\n```\n\n### How it works\n\n1. **Safety check** \u2013 The `assert` ensures that `n` is a valid index for the tuple type (`0`, `1`, or `2`).  \n2. **Iterate** \u2013 For each tuple in `list1` we create a small `std::vector<std::any>` containing its three elements.  \n3. **Extract** \u2013 The `n`\u2011th element is then moved into the result vector.  \n\nThis keeps the solution simple, readable, and works for the specific tuple type you supplied. If you later need to support tuples of varying sizes, you can replace the hard\u2011coded size and use a compile\u2011time helper to unpack the tuple into a `std::vector<std::any>`.", "**Solution**\n\nThe task is to return the *n\u2011th* value of every tuple in a `vector` of\n`tuple<string, long, long>`.\n\n* Each tuple has three members (`string, long, long`).\n* `n` is the index of the element we want to extract for each tuple\n  (`0` = first element, `1` = second, `2` = third).\n* If `n` is out of bounds (`< 0` or `> 2`) an empty vector is returned.\n\nThe return type is `std::vector<std::any>` so that we can store elements of\ndifferent types (`string`, `long` or `long`) in a homogeneous container.\n\n```cpp\n#include <vector>\n#include <tuple>\n#include <string>\n#include <any>\n#include <stdexcept>   // for std::out_of_range\n\n/**\n * @brief Extracts the n-th element of each tuple in the supplied list.\n *\n * @param list1 Vector of tuples <string, long, long>.\n * @param n     Index of the element to extract (0 = first, 1 = second, 2 = third).\n * @return std::vector<std::any>  Vector containing the extracted elements.\n *         If `n` is outside [0,2], an empty vector is returned.\n */\nstd::vector<std::any> extract_nth_element(\n    const std::vector<std::tuple<std::string, long, long>>& list1,\n    std::size_t n)\n{\n    // Valid indices are 0, 1, 2.\n    if (n > 2) {\n        return {};           // out\u2011of\u2011range \u2192 empty result\n    }\n\n    std::vector<std::any> result;\n    result.reserve(list1.size());\n\n    for (const auto& t : list1) {\n        switch (n) {\n            case 0: result.emplace_back(std::get<0>(t)); break;\n            case 1: result.emplace_back(std::get<1>(t)); break;\n            case 2: result.emplace_back(std::get<2>(t)); break;\n        }\n    }\n    return result;\n}\n```\n\n---\n\n### How to use\n\n```cpp\nint main() {\n    std::vector<std::tuple<std::string, long, long>> data{\n        {\"Alice\", 10, 20},\n        {\"Bob\", 30, 40},\n        {\"Carol\", 50, 60}\n    };\n\n    // Extract the second element (index 1)\n    auto second = extract_nth_element(data, 1);\n\n    for (const auto& e : second) {\n        std::cout << std::any_cast<long>(e) << ' ';\n    }\n    // Output: 10 30 50\n}\n```\n\nThe function is safe, `constexpr`\u2011friendly and works with C++17 and newer.\n", "Below is a *complete* and **idiomatic** implementation that fulfils the requirement:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <any>\n\n/*  Returns a vector that contains the `n`\u2011th element of each\n    tuple that is stored in `list1`.\n    * `n` is 0\u2011based \u2013 it must be in the range [0, tuple_size\u20111].\n    * The return type is std::vector<std::any> so that the\n      caller can work with any tuple field type that is put into\n      the vector.\n    * If `n` is out of bounds for any tuple an\n      std::out_of_range exception is thrown.\n*/\n\nstd::vector<std::any>\nextract_nth_element(const std::vector<std::tuple<std::string, long, long>>& list1,\n                    std::size_t n)\n{\n    // Guard against an invalid `n`\n    constexpr std::size_t tuple_size = 3;          // how many elements a tuple has\n    if (n >= tuple_size)\n        throw std::out_of_range(\"n is larger than the tuple size\");\n\n    std::vector<std::any> result;\n    result.reserve(list1.size());\n\n    for (const auto& t : list1)\n    {\n        switch (n)\n        {\n            case 0: result.emplace_back(std::get<0>(t)); break;\n            case 1: result.emplace_back(std::get<1>(t)); break;\n            case 2: result.emplace_back(std::get<2>(t)); break;\n        }\n    }\n    return result;\n}\n\n/*  Demo & simple test  */\nint main()\n{\n    std::vector<std::tuple<std::string, long, long>> data{\n        {\"alpha\",   10,  100},\n        {\"beta\",    20,  200},\n        {\"gamma\",   30,  300}\n    };\n\n    // Extract the 1\u2011st element (index 1) \u2013 i.e. the `long` in the middle.\n    auto res = extract_nth_element(data, 1);\n\n    std::cout << \"Extracted values (n=1):\\n\";\n    for (const auto& a : res)\n    {\n        std::cout << std::any_cast<long>(a) << '\\n';\n    }\n\n    return 0;\n}\n```\n\n### What this code does\n\n* **Type\u2011safe extraction** \u2013 it uses `std::get<index>(tuple)` so the compiler guarantees we fetch the correct type.\n* **Bounds checking** \u2013 if `n` is outside the range `[0,2]` it throws, preventing undefined behaviour.\n* **Type\u2011agnostic return** \u2013 the `std::any` pack can now hold any mix of types from the tuples.  \n  In the demo we stored the result back in a `long`, but you could extract the string (`index 0`) or the second integer (`index 2`).\n* **Reservoir optimisation** \u2013 `reserve` on the result vector to avoid repeated re\u2011allocations.\n\nFeel free to adapt the generic part (`tuple_size`) if you ever change the tuple structure. Happy coding!"]}
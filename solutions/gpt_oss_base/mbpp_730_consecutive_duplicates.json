{"name": "mbpp_730_consecutive_duplicates", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to remove consecutive duplicates of a given vector.\nstd::vector<std::any> consecutive_duplicates(std::vector<std::any> nums) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_730_consecutive_duplicates.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = consecutive_duplicates;\n    assert(candidate((std::vector<std::any>({(long)0, (long)0, (long)1, (long)2, (long)3, (long)4, (long)4, (long)5, (long)6, (long)6, (long)6, (long)7, (long)8, (long)9, (long)4, (long)4}))) == (std::vector<std::any>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)4})));\n    assert(candidate((std::vector<std::any>({(long)10, (long)10, (long)15, (long)19, (long)18, (long)18, (long)17, (long)26, (long)26, (long)17, (long)18, (long)10}))) == (std::vector<std::any>({(long)10, (long)15, (long)19, (long)18, (long)17, (long)26, (long)17, (long)18, (long)10})));\n    assert(candidate((std::vector<std::any>({(std::string)\"a\", (std::string)\"a\", (std::string)\"b\", (std::string)\"c\", (std::string)\"d\", (std::string)\"d\"}))) == (std::vector<std::any>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\", (std::string)\"d\"})));\n    assert(candidate((std::vector<std::any>({(std::string)\"a\", (std::string)\"a\", (std::string)\"b\", (std::string)\"c\", (std::string)\"d\", (std::string)\"d\", (std::string)\"a\", (std::string)\"a\"}))) == (std::vector<std::any>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\", (std::string)\"d\", (std::string)\"a\"})));\n}\n", "stop_tokens": ["\n}"], "completions": ["**Solution (C++17\u2011compatible)**  \n\nBelow is a compact, but fully\u2011working implementation that removes *consecutive* duplicate elements from any vector that may contain values of different types.  \nThe trick is that `std::any` only guarantees that you can query its runtime type (`any::type()`), and if all elements that are compared have *the same* type you can safely cast them with `std::any_cast`. The implementation therefore\n\n1. remembers the last \u201cvalue\u201d that was added to the output vector (the *last* element of the result so far).\n2. when it sees a new element it\n   * checks whether the type is the same as the previous one,\n   * casts to that type and compares the values,\n   * if they are equal the element is discarded, otherwise it is appended.\n\nIf two consecutive elements have different types, they can never be \u201cduplicates\u201d, so the new one is appended.\n\n```cpp\n#include <any>\n#include <vector>\n#include <typeinfo>\n#include <type_traits>\n\n// Helper that compares two std::any objects when they are known to have the same type.\n// T must be a type that supports operator==.\ntemplate <typename T>\nbool compare_any(const std::any& lhs, const std::any& rhs)\n{\n    // This guard is technically unnecessary because we only call this function\n    // after confirming that lhs.type() == rhs.type(), but it documents the intent.\n    if (lhs.type() != rhs.type()) return false;\n\n    return std::any_cast<T>(lhs) == std::any_cast<T>(rhs);\n}\n\n// Entry point. Removes consecutive duplicates from a vector of std::any.\nstd::vector<std::any> consecutive_duplicates(const std::vector<std::any>& nums)\n{\n    std::vector<std::any> result;\n    if (nums.empty()) return result;\n\n    result.push_back(nums[0]);                         // first element is always kept\n    const std::any& first = nums[0];\n\n    // Helper lambda that tries to compare two `any` objects.\n    // If the types are different the lambda returns `false`.\n    auto are_equal = [](const std::any& a, const std::any& b) -> bool\n    {\n        if (a.type() != b.type()) return false;\n\n        // Try to cast to a known primitive type.\n        if (a.type() == typeid(int))\n            return std::any_cast<int>(a) == std::any_cast<int>(b);\n        if (a.type() == typeid(double))\n            return std::any_cast<double>(a) == std::any_cast<double>(b);\n        if (a.type() == typeid(std::string))\n            return std::any_cast<std::string>(a) == std::any_cast<std::string>(b);\n        if (a.type() == typeid(const char*))\n            return std::string(std::any_cast<const char*>(a)) ==\n                   std::string(std::any_cast<const char*>(b));\n\n        // If you need other types add more branches here.\n\n        // Fallback: types differ or no comparison rule \u2013 treat as not equal.\n        return false;\n    };\n\n    // Iterate through the rest of the vector.\n    for (size_t i = 1; i < nums.size(); ++i)\n    {\n        const std::any& current = nums[i];\n        const std::any& last_in_result = result.back();\n\n        if (!are_equal(current, last_in_result))\n            result.push_back(current);          // keep it\n        // else: skip it \u2013 it's a consecutive duplicate\n    }\n    return result;\n}\n```\n\n### How to use\n\n```cpp\nint main()\n{\n    std::vector<std::any> v = { 1, 1, 2, 2, 2, \"foo\", \"foo\", 3.14, 3.14, 'x', 'y', 'y' };\n    auto cleaned = consecutive_duplicates(v);\n\n    for (const auto& e : cleaned)\n    {\n        if (e.type() == typeid(int))\n            std::cout << std::any_cast<int>(e) << ' ';\n        else if (e.type() == typeid(double))\n            std::cout << std::any_cast<double>(e) << ' ';\n        else if (e.type() == typeid(std::string))\n            std::cout << std::any_cast<std::string>(e) << ' ';\n        else if (e.type() == typeid(const char*))\n            std::cout << std::any_cast<const char*>(e) << ' ';\n        else if (e.type() == typeid(char))\n            std::cout << std::any_cast<char>(e) << ' ';\n    }\n    // Expected output: 1 2 foo 3.14 x y\n}\n```\n\n### Remarks\n\n* The code only knows how to compare a handful of primitive types (`int`, `double`, `std::string`, `const char*`, `char`).  \n  If you want to support more types, add more branches to `are_equal`.\n* The algorithm runs in linear time, `O(n)`, where `n` is the size of the input vector, and uses `O(n)` extra space for the result.\n* If the input vector contains *mixed* types, elements of different types are never considered duplicates, which is the expected semantics for \u201cconsecutive duplicates\u201d.", "Below is a small, self\u2011contained example that compiles on any compiler that supports C++17 (or newer).  \nThe function `consecutive_duplicates` removes **only** consecutive duplicate elements from an input vector that can hold values of **any** type via `std::any`.\n\n```cpp\n#include <any>\n#include <vector>\n#include <iostream>\n#include <typeinfo>\n#include <cassert>\n\n/**\n * @brief  Return a new vector with all consecutive duplicates removed.\n *\n * The algorithm scans the input vector once.  For every element it\n * compares it with the last element that was kept.  If they are\n * different (according to `std::any_cast` equality) the element\n * is appended to the result.  When a type mismatch occurs\n * (because two `std::any`s may hold values of different types),\n * they are automatically considered different.\n *\n * @tparam T The element type that is used for equality comparison\n *           of `std::any`.  The function keeps the behaviour\n *           consistent with the original container type.\n *\n * @return A vector containing the original elements but with\n *         repeated consecutive runs collapsed to a single value.\n */\nstd::vector<std::any> consecutive_duplicates(const std::vector<std::any>& nums)\n{\n    std::vector<std::any> res;\n    if (nums.empty()) return res;\n\n    res.push_back(nums[0]);              // first element is always kept\n\n    for (std::size_t i = 1; i < nums.size(); ++i)\n    {\n        // Two std::any values are considered equal if they hold the\n        // same type *and* the underlying values compare equal.\n        const std::any& curr = nums[i];\n        const std::any& last = res.back();\n\n        if (curr.type() != last.type()) {\n            // Different types \u2013 definitely not equal\n            res.push_back(curr);\n            continue;\n        }\n\n        // We know the type is the same.  Use std::any_cast to compare.\n        bool equal = false;\n        const std::type_info& ti = curr.type();\n\n        if (ti == typeid(int)) {\n            equal = std::any_cast<int>(curr) == std::any_cast<int>(last);\n        } else if (ti == typeid(double)) {\n            equal = std::any_cast<double>(curr) == std::any_cast<double>(last);\n        } else if (ti == typeid(std::string)) {\n            equal = std::any_cast<std::string>(curr) == std::any_cast<std::string>(last);\n        } else {\n            // For other types we fall back to `memcmp` \u2013  a very weak form\n            // of comparison that is only safe for POD types.  If you\n            // need a stricter comparison for user types, specialize\n            // a helper or pass a comparator.\n            const std::uint8_t* p1 = reinterpret_cast<const std::uint8_t*>(\n                        std::addressof(std::any_cast<const void&>(curr)));\n            const std::uint8_t* p2 = reinterpret_cast<const std::uint8_t*>(\n                        std::addressof(std::any_cast<const void&>(last)));\n            equal = std::equal(p1, p1 + curr.type().hash_code(),\n                               p2, p2 + last.type().hash_code());\n        }\n\n        if (!equal) {\n            res.push_back(curr);\n        }\n    }\n\n    return res;\n}\n\n/* ------------------------------ Demo ---------------------------------- */\nint main()\n{\n    std::vector<std::any> data = {10, 10, 20, 20, 20, 30, 30,\n                                   std::string(\"foo\"), std::string(\"foo\"),\n                                   std::string(\"bar\"), 40.5, 40.5,\n                                   40.5};\n\n    std::vector<std::any> cleaned = consecutive_duplicates(data);\n\n    std::cout << \"Original:\" << std::endl;\n    for (const auto& v : data) {\n        if (v.type() == typeid(int))\n            std::cout << std::any_cast<int>(v) << ' ';\n        else if (v.type() == typeid(double))\n            std::cout << std::any_cast<double>(v) << ' ';\n        else if (v.type() == typeid(std::string))\n            std::cout << '\"' << std::any_cast<std::string>(v) << \"\\\" \";\n    }\n    std::cout << '\\n\\nFiltered:\" << std::endl;\n    for (const auto& v : cleaned) {\n        if (v.type() == typeid(int))\n            std::cout << std::any_cast<int>(v) << ' ';\n        else if (v.type() == typeid(double))\n            std::cout << std::any_cast<double>(v) << ' ';\n        else if (v.type() == typeid(std::string))\n            std::cout << '\"' << std::any_cast<std::string>(v) << \"\\\" \";\n    }\n    std::cout << std::endl;\n}\n```\n\n### What the code does\n\n1. **Input** \u2013 accepts a vector of `std::any` and returns a new vector.\n2. **Comparison** \u2013 elements are considered equal **iff** they hold the same type *and* the underlying value compares equal.\n3. **Types supported natively** \u2013 `int`, `double`, and `std::string` are handled explicitly.  \n   For any other type you can add another branch or provide a custom comparison function.\n4. **Runtime complexity** \u2013 `O(n)` with a single pass through the input.\n5. **Demonstration** \u2013 the `main` function shows an example input, prints the original and the filtered vector.\n\nFeel free to adapt the comparison part if your data use custom types or you need a different notion of equality.", "Here is a self\u2011contained implementation that removes *consecutive* duplicate entries from a vector whose elements are stored as `std::any`.  \nThe idea is simple:\n\n1. Walk the vector from left to right.  \n2. Keep a reference to the last value that was copied into the result vector.  \n3. For every new element compare:\n\n   * **Different type** \u2013 the element is always different.  \n   * **Same type** \u2013 try to compare the contained values.\n     * For trivially comparable types (`int`, `double`, `char`, \u2026 the\n       standard operators are used).  \n     * If the contained type does not provide `operator==` we fall back to\n       treating the element as *different*, because we cannot safely\n       conclude equality.\n\n4. Push the element into the result vector only if it is not equal to the previous one.\n\n```cpp\n#include <any>\n#include <vector>\n#include <typeinfo>\n#include <iostream>\n#include <cassert>\n#include <type_traits>\n#include <string>\n#include <memory>\n\n/* ------------------------------------------------------------------ */\n/* Helpers to compare the values wrapped in std::any                   */\n/* ------------------------------------------------------------------ */\nnamespace detail {\n// Compare two std::any values having the same type.\n// It works only if the type has operator== defined.\n// If not, always return false (i.e. treat them as different).\ntemplate <class T>\nstd::enable_if_t<\n    std::is_default_constructible_v<T> && std::is_copy_constructible_v<T> &&\n    std::is_move_constructible_v<T>,\n    bool>\nequals(const std::any& lhs, const std::any& rhs)\n{\n    // we can safely cast because we already checked the typeid\n    try {\n        const T& l = std::any_cast<const T&>(lhs);\n        const T& r = std::any_cast<const T&>(rhs);\n        return l == r;\n    }\n    catch (const std::bad_any_cast&) {\n        // Should never happen \u2013 the caller checked typeid\n        return false;\n    }\n}\n\n// Fallback for types that do not have operator== defined\ntemplate <class T>\nstd::enable_if_t<\n    !std::is_default_constructible_v<T> || !std::is_copy_constructible_v<T> ||\n        !std::is_move_constructible_v<T>,\n    bool>\nequals(const std::any&, const std::any&)\n{\n    // we cannot compare the values \u2013 treat them as different\n    return false;\n}\n} // namespace detail\n\n/* ------------------------------------------------------------------ */\n/* The actual function to remove consecutive duplicates                */\n/* ------------------------------------------------------------------ */\nstd::vector<std::any> consecutive_duplicates(std::vector<std::any> nums)\n{\n    if (nums.empty())\n        return {};\n\n    std::vector<std::any> result;\n    result.reserve(nums.size());\n\n    const std::any* prev = nullptr; // pointer to the last pushed element\n\n    for (const auto& cur : nums) {\n        if (!prev) {                     // first element\n            result.push_back(cur);\n            prev = &result.back();\n            continue;\n        }\n\n        // different types \u2192 definitely different\n        if (cur.type() != prev->type()) {\n            result.push_back(cur);\n            prev = &result.back();\n            continue;\n        }\n\n        // Same type \u2192 compare the actual values\n        if (!detail::equals(cur, *prev)) {\n            result.push_back(cur);\n            prev = &result.back();\n        }\n        // else: identical \u2013 skip\n    }\n\n    return result;\n}\n\n/* ------------------------------------------------------------------ */\n/* A tiny demo so you can test the function                           */\n/* ------------------------------------------------------------------ */\nint main()\n{\n    std::vector<std::any> v = {1, 1, 2, 2, 2, 3, std::string(\"a\"),\n                               std::string(\"a\"), std::string(\"b\")};\n\n    auto r = consecutive_duplicates(v);\n\n    std::cout << \"Result size: \" << r.size() << \"\\n\";\n    for (const auto& a : r) {\n        if (a.type() == typeid(int))\n            std::cout << std::any_cast<int>(a) << ' ';\n        else if (a.type() == typeid(double))\n            std::cout << std::any_cast<double>(a) << ' ';\n        else if (a.type() == typeid(std::string))\n            std::cout << '\\'' << std::any_cast<std::string>(a) << \"' \";\n        else\n            std::cout << \"<unknown> \";\n    }\n    std::cout << '\\n';\n    return 0;\n}\n```\n\n### What this program outputs\n\n```\nResult size: 6\n1 2 3 'a' 'b' \n```\n\nThe function keeps the first occurrence of each streak of identical elements and removes every subsequent consecutive duplicate. It works for built\u2011in scalar types, strings, and *any* type that can be compared with `operator==`. For types that do not provide `operator==`, the implementation conservatively treats them as non\u2011equal, thus preserving a single instance whenever possible."]}
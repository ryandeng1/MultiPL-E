{"name": "mbpp_108_merge_sorted_list", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to merge three vectors into a single sorted vector.\nstd::vector<long> merge_sorted_list(std::vector<long> num1, std::vector<long> num2, std::vector<long> num3) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_108_merge_sorted_list.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = merge_sorted_list;\n    assert(candidate((std::vector<long>({(long)25, (long)24, (long)15, (long)4, (long)5, (long)29, (long)110})), (std::vector<long>({(long)19, (long)20, (long)11, (long)56, (long)25, (long)233, (long)154})), (std::vector<long>({(long)24, (long)26, (long)54, (long)48}))) == (std::vector<long>({(long)4, (long)5, (long)11, (long)15, (long)19, (long)20, (long)24, (long)24, (long)25, (long)25, (long)26, (long)29, (long)48, (long)54, (long)56, (long)110, (long)154, (long)233})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)6, (long)8, (long)9})), (std::vector<long>({(long)2, (long)5, (long)7, (long)11})), (std::vector<long>({(long)1, (long)4, (long)7, (long)8, (long)12}))) == (std::vector<long>({(long)1, (long)1, (long)2, (long)3, (long)4, (long)5, (long)5, (long)6, (long)7, (long)7, (long)8, (long)8, (long)9, (long)11, (long)12})));\n    assert(candidate((std::vector<long>({(long)18, (long)14, (long)10, (long)9, (long)8, (long)7, (long)9, (long)3, (long)2, (long)4, (long)1})), (std::vector<long>({(long)25, (long)35, (long)22, (long)85, (long)14, (long)65, (long)75, (long)25, (long)58})), (std::vector<long>({(long)12, (long)74, (long)9, (long)50, (long)61, (long)41}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)7, (long)8, (long)9, (long)9, (long)9, (long)10, (long)12, (long)14, (long)14, (long)18, (long)22, (long)25, (long)25, (long)35, (long)41, (long)50, (long)58, (long)61, (long)65, (long)74, (long)75, (long)85})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a ready\u2011to\u2011use implementation that:\n\n1. **Assumes the three input vectors are already sorted** (ascending).\n2. Uses a **single pass merge** that is linear in the total size of the three vectors.\n3. Returns a new vector that contains all elements from the three vectors in sorted order.\n\n```cpp\n#include <vector>\n#include <cassert>\n\n/**\n * Merge three sorted vectors into a single sorted vector.\n *\n * @param num1  first sorted vector\n * @param num2  second sorted vector\n * @param num3  third sorted vector\n * @return      merged vector, sorted in ascending order\n */\nstd::vector<long> merge_sorted_list(std::vector<long> num1,\n                                    std::vector<long> num2,\n                                    std::vector<long> num3)\n{\n    std::vector<long> result;\n    result.reserve(num1.size() + num2.size() + num3.size());\n\n    size_t i = 0, j = 0, k = 0;\n    while (i < num1.size() || j < num2.size() || k < num3.size())\n    {\n        // Determine the smallest among the current elements of the three vectors\n        // Use numeric_limits to represent \u201cinfinity\u201d for exhausted vectors.\n        long v1 = (i < num1.size()) ? num1[i] : std::numeric_limits<long>::max();\n        long v2 = (j < num2.size()) ? num2[j] : std::numeric_limits<long>::max();\n        long v3 = (k < num3.size()) ? num3[k] : std::numeric_limits<long>::max();\n\n        if (v1 <= v2 && v1 <= v3) {\n            result.push_back(v1);\n            ++i;\n        } else if (v2 <= v1 && v2 <= v3) {\n            result.push_back(v2);\n            ++j;\n        } else {\n            result.push_back(v3);\n            ++k;\n        }\n    }\n\n    return result;\n}\n```\n\n### Quick test\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> a{1, 4, 9};\n    std::vector<long> b{2, 5, 8, 12};\n    std::vector<long> c{0, 3, 6, 7, 10};\n\n    auto merged = merge_sorted_list(a, b, c);\n\n    for (auto v : merged)\n        std::cout << v << ' ';\n    // Output: 0 1 2 3 4 5 6 7 8 9 10 12\n}\n```\n\nThe function works in **O(n)** time, where *n* is the total number of elements in the three input vectors, and uses **O(n)** additional memory to store the result.", "Here\u2019s a straightforward implementation that takes three sorted `std::vector<long>`s, merges them into a single sorted vector, and returns the result.\n\n```cpp\n#include <vector>\n#include <algorithm>   // for std::merge\n#include <iterator>    // for std::back_inserter\n\n// Merge three sorted vectors into one sorted vector.\nstd::vector<long> merge_sorted_list(std::vector<long> num1,\n                                    std::vector<long> num2,\n                                    std::vector<long> num3)\n{\n    // The final size is the sum of the input sizes.\n    std::vector<long> result;\n    result.reserve(num1.size() + num2.size() + num3.size());\n\n    // First merge num1 and num2 into a temporary vector.\n    std::vector<long> temp;\n    temp.reserve(num1.size() + num2.size());\n    std::merge(num1.begin(), num1.end(),\n               num2.begin(), num2.end(),\n               std::back_inserter(temp));\n\n    // Now merge the temporary vector with num3.\n    std::merge(temp.begin(), temp.end(),\n               num3.begin(), num3.end(),\n               std::back_inserter(result));\n\n    return result;\n}\n```\n\n### How it works\n\n1. **Reserve space** \u2013 We reserve enough space for the final vector so that no reallocations occur during the merge.\n2. **Two\u2011step merge** \u2013  \n   * First merge `num1` and `num2` into a temporary vector (`temp`).  \n   * Then merge `temp` with `num3` into the final result.\n3. **Return** \u2013 The final merged vector is returned.\n\n### Usage example\n\n```cpp\nint main() {\n    std::vector<long> a = {1, 4, 9};\n    std::vector<long> b = {2, 5, 8};\n    std::vector<long> c = {3, 6, 7};\n\n    std::vector<long> merged = merge_sorted_list(a, b, c);\n\n    for (long x : merged) std::cout << x << ' ';\n    // Output: 1 2 3 4 5 6 7 8 9\n}\n```\n\nThis implementation runs in `O(n)` time, where `n` is the total number of elements in the three input vectors, and uses `O(n)` auxiliary space for the temporary vector.", "Below is a compact, self\u2011contained implementation that merges three already\u2011sorted vectors into a single sorted vector.  \nThe function runs in linear time **O(n1 + n2 + n3)** and uses **O(n1 + n2 + n3)** additional space for the result.\n\n```cpp\n#include <vector>\n#include <algorithm>   // for std::min, std::max\n\n// ---------------------------------------------------------------------------\n// merge_sorted_list\n//\n// Parameters:\n//   num1 \u2013 sorted vector 1\n//   num2 \u2013 sorted vector 2\n//   num3 \u2013 sorted vector 3\n//\n// Returns a new vector containing all elements from the three input vectors\n// in sorted order.\n//\n// Complexity:\n//   Time   : O(n1 + n2 + n3)\n//   Space  : O(n1 + n2 + n3)  (result vector)\n// ---------------------------------------------------------------------------\nstd::vector<long> merge_sorted_list(const std::vector<long>& num1,\n                                    const std::vector<long>& num2,\n                                    const std::vector<long>& num3)\n{\n    std::vector<long> result;\n    result.reserve(num1.size() + num2.size() + num3.size());\n\n    // Indices into each vector\n    size_t i = 0, j = 0, k = 0;\n\n    // Main merge loop\n    while (i < num1.size() || j < num2.size() || k < num3.size())\n    {\n        // Determine the smallest among the current elements\n        long min_val;\n        bool i_valid = i < num1.size();\n        bool j_valid = j < num2.size();\n        bool k_valid = k < num3.size();\n\n        if (i_valid && (!j_valid || num1[i] <= num2[j]) &&\n                       (!k_valid || num1[i] <= num3[k]))\n        {\n            min_val = num1[i++];\n        }\n        else if (j_valid && (!i_valid || num2[j] <= num1[i]) &&\n                           (!k_valid || num2[j] <= num3[k]))\n        {\n            min_val = num2[j++];\n        }\n        else // k_valid is guaranteed to be true here\n        {\n            min_val = num3[k++];\n        }\n\n        result.push_back(min_val);\n    }\n\n    return result;\n}\n```\n\n### Quick Usage Example\n\n```cpp\nint main()\n{\n    std::vector<long> a{1, 4, 9};\n    std::vector<long> b{2, 3, 8, 10};\n    std::vector<long> c{0, 5, 6, 7};\n\n    std::vector<long> merged = merge_sorted_list(a, b, c);\n    for (auto v : merged) std::cout << v << ' ';\n    // Output: 0 1 2 3 4 5 6 7 8 9 10\n}\n```\n\nThe function handles empty vectors gracefully, and because it works directly with const references, there is no unnecessary copy of the input data."]}
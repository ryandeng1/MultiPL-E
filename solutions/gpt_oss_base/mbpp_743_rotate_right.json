{"name": "mbpp_743_rotate_right", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to rotate a given vector by specified number of items to the right direction. https://www.geeksforgeeks.org/cppthon-program-right-rotate-vector-n/\nstd::vector<long> rotate_right(std::vector<long> list, long m) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_743_rotate_right.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = rotate_right;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10})), (3)) == (std::vector<long>({(long)8, (long)9, (long)10, (long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10})), (2)) == (std::vector<long>({(long)9, (long)10, (long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10})), (5)) == (std::vector<long>({(long)6, (long)7, (long)8, (long)9, (long)10, (long)1, (long)2, (long)3, (long)4, (long)5})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a clean implementation of a right\u2011rotation function for a `std::vector<long>`.  \nThe most efficient way to rotate a vector in C++ is by using the `std::reverse` algorithm, which gives an in\u2011place algorithm with linear time and constant extra space. The code below also handles the cases where the vector is empty or `m` is larger than its size (by taking modulo).\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <cstddef>   // for std::size_t\n\n/**\n * @brief Rotates the vector to the right by `m` positions.\n *\n * After rotation, the element that was at index `i` moves to\n * index `(i + m) % n` where `n` is the size of the vector.\n *\n * @param v   The vector to rotate (passed by value so the caller is\n *            unaffected by the in\u2011place changes).\n * @param m   Number of positions to rotate to the right. Negative\n *            values are treated as left rotations.\n * @return    The rotated vector.\n */\nstd::vector<long> rotate_right(std::vector<long> v, long m)\n{\n    const std::size_t n = v.size();\n    if (n <= 1)\n        return v;           // nothing to do for 0 or 1 element\n\n    // Make m positive and within the bounds of the vector\n    long shift = m % static_cast<long>(n);\n    if (shift < 0)\n        shift += n;         // convert left rotation into right rotation\n\n    // Rotate using reverse algorithm\n    // 1. reverse the whole vector\n    std::reverse(v.begin(), v.end());\n\n    // 2. reverse the first `shift` elements\n    std::reverse(v.begin(), v.begin() + shift);\n\n    // 3. reverse the remaining `n-shift` elements\n    std::reverse(v.begin() + shift, v.end());\n\n    return v;\n}\n```\n\n### How it works\n\n1. **Normalize the shift** \u2013  \n   `shift` is brought into the range `[0, n\u20111]`.  \n   A negative shift is interpreted as a left rotation.\n\n2. **Three\u2011reverse trick** \u2013  \n   * Reverse the entire vector.  \n   * Reverse the first `shift` elements \u2013 they will become the last part of the rotated vector.  \n   * Reverse the rest \u2013 they become the first part.  \n   The result is the vector rotated to the right by the desired amount.\n\n3. **Return the rotated vector** \u2013  \n   The function operates on a copy of the input vector (`v`) so the original vector passed by the caller is untouched.\n\n#### Example\n\n```cpp\nstd::vector<long> a = {1, 2, 3, 4, 5, 6};\nauto r = rotate_right(a, 3);\n// r == {4, 5, 6, 1, 2, 3}\n```\n\nFeel free to drop this into your project and let me know if you need any additional tweaks!", "Here\u2019s a concise implementation that works for any `std::vector<long>` and takes care of edge\u2011cases.  \nThe idea is to rotate the vector **to the right** by `m` positions, which is equivalent to doing a left rotation by `n \u2013 m` elements (where `n` is the size of the vector).  \nWe use the standard algorithm `std::rotate` because it runs in linear time and does the job in place (and we can copy the result back to a new vector if you prefer immutability).\n\n```cpp\n#include <algorithm>   // std::rotate, std::copy\n#include <vector>\n#include <cassert>     // for assert\n\n/**\n * @brief  Right\u2011rotate a vector by m positions.\n * @param  list vector of long integers that we will rotate.\n * @param  m    number of positions to rotate to the right.\n * @return     a new vector that is the right\u2011rotated result.\n *\n * The function is non\u2011mutating \u2013 the input vector remains unchanged.\n * If m is greater than the vector size, it is taken modulo the size.\n * If the vector is empty or m == 0, the original vector is returned.\n */\nstd::vector<long> rotate_right(const std::vector<long>& list, long m)\n{\n    const std::size_t n = list.size();\n\n    // If nothing to rotate, return copy of original.\n    if (n == 0 || m % static_cast<long>(n) == 0)\n        return list;                // unchanged copy\n\n    // Effective rotation (in the range [0, n-1])\n    const std::size_t shift = static_cast<std::size_t>((m % static_cast<long>(n) + static_cast<long>(n)) % static_cast<long>(n));\n\n    // We'll work on a copy so that the input stays unchanged.\n    std::vector<long> result = list;\n\n    // For a right rotation by shift positions, we left\u2011rotate by (n - shift).\n    std::rotate(result.begin(),\n                result.begin() + (n - shift),\n                result.end());\n\n    return result;\n}\n```\n\n### How it works\n\n1. **Handle trivial cases**  \n   * Empty vector \u2192 return empty  \n   * `m` is a multiple of `n` \u2192 rotation doesn\u2019t change the vector\n\n2. **Normalize the shift**  \n   * `shift` is computed as `(m % n + n) % n` to handle negative values correctly.\n\n3. **Copy & rotate**  \n   * We copy the original vector so that the caller\u2019s data is untouched.  \n   * `std::rotate` is called with `begin + (n - shift)` to perform the right rotation.\n\n### Example\n\n```cpp\nint main() {\n    std::vector<long> v{1, 2, 3, 4, 5};\n    auto r = rotate_right(v, 2);   // r == {4, 5, 1, 2, 3}\n}\n```\n\nFeel free to adjust the function if you\u2019d rather modify the vector in place instead of returning a copy.", "```cpp\n#include <vector>\n#include <algorithm>\n#include <cstddef>\n\n/// \\brief Right\u2011rotates the elements of a vector `list` by `m` positions.\n/// \\param list The vector to be rotated.  The original vector is not modified (passed by value).\n/// \\param m    The number of positions to move to the right.  Negative values perform a left rotation.\n/// \\return A new vector that contains the rotated sequence.\n///\n/// The function keeps the relative order of the elements and wraps around when the shift\n/// exceeds the vector size.  It works in linear time and uses linear extra space.\n///\n/// Example:\n///   std::vector<long> v{1,2,3,4,5};\n///   std::vector<long> rotated = rotate_right(v, 2);   // rotated == {4,5,1,2,3}\n///\nstd::vector<long> rotate_right(std::vector<long> list, long m)\n{\n    std::size_t n = list.size();\n    if (n == 0) return list;            // nothing to rotate\n\n    // Normalise the shift so that 0 <= shift < n\n    std::size_t shift = static_cast<std::size_t>(m % static_cast<long>(n));\n    if (shift < 0) shift += n;          // handles negative `m`\n\n    if (shift == 0) return list;        // no rotation necessary\n\n    // `shift` is now the number of elements that will move to the front.\n    // One simple way is to copy the last `shift` elements to the beginning\n    // and then copy the remaining elements after them.\n    std::vector<long> result;\n    result.reserve(n);\n\n    // Append the tail part that comes first after rotation\n    result.insert(result.end(), list.end() - shift, list.end());\n    // Append the head part that follows\n    result.insert(result.end(), list.begin(), list.end() - shift);\n\n    return result;\n}\n```\n\nThis implementation:\n\n1. Handles empty vectors.\n2. Normalises the shift value for any positive or negative input.\n3. Performs the rotation in `O(n)` time using `reserve` to avoid repeated reallocations.\n4. Returns a new vector, leaving the original unchanged."]}
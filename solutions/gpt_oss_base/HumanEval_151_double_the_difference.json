{"name": "HumanEval_151_double_the_difference", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_151_double_the_difference.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = double_the_difference;\n    assert(candidate((std::vector<float>())) == (0));\n    assert(candidate((std::vector<float>({(float)5.0f, (float)4.0f}))) == (25));\n    assert(candidate((std::vector<float>({(float)0.1f, (float)0.2f, (float)0.3f}))) == (0));\n    assert(candidate((std::vector<float>({(float)-10.0f, (float)-20.0f, (float)-30.0f}))) == (0));\n    assert(candidate((std::vector<float>({(float)-1.0f, (float)-2.0f, (float)8.0f}))) == (0));\n    assert(candidate((std::vector<float>({(float)0.2f, (float)3.0f, (float)5.0f}))) == (34));\n    assert(candidate((std::vector<float>({(float)-9.0f, (float)-7.0f, (float)-5.0f, (float)-3.0f, (float)-1.0f, (float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f, (float)9.0f}))) == (165));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a minimal but complete implementation that follows the specification:\n\n```cpp\n#include <vector>\n#include <cmath>   // for std::floor\n\n// Returns the sum of squares of odd, non\u2011negative integer values in lst.\n// Non\u2011integers and negative numbers are ignored.\nlong double_the_difference(std::vector<float> lst)\n{\n    long sum = 0;\n    for (float f : lst) {\n        // Ignore negative numbers\n        if (f < 0)\n            continue;\n\n        // Check that the value is an integer: no fractional part\n        if (std::floor(f) != f)\n            continue;\n\n        // Convert to long (safe: value is non\u2011negative by now)\n        long v = static_cast<long>(f);\n\n        // Check for oddness\n        if (v & 1) {          // v % 2 == 1 but faster\n            long sq = v * v;  // square\n            sum += sq;\n        }\n    }\n    return sum;\n}\n```\n\n### How it works\n\n1. **Negative check** \u2013 Any negative value is skipped.\n2. **Integer check** \u2013 `std::floor(f) != f` detects a fractional part; those are ignored.\n3. **Oddness** \u2013 The bitwise test `v & 1` is equivalent to `v % 2 == 1` but very fast.\n4. **Square and accumulate** \u2013 The square `v * v` is added to the running total.\n5. If the input vector is empty, the loop simply doesn't run and `sum` stays `0`.\n\nThis function satisfies all the examples you gave.", "Below is a clean and self\u2011contained implementation of the function that does exactly what you described.  \nI\u2019ve added a few comments to keep things clear and used only the facilities that are\nnecessary for portability.\n\n```cpp\n#include <vector>\n#include <cstddef>   // for std::size_t\n\n/**\n * @brief Return the sum of the squares of the numbers that are odd,\n *        positive, and integral.\n *\n * Parameters\n * ----------\n * lst : std::vector<float>\n *        A vector of floating\u2011point numbers.  Only those elements that\n *        are integral, non\u2011negative and odd contribute to the sum.\n *\n * Returns\n * -------\n * long\n *   Sum of the squares of qualifying elements.  When `lst` is empty the\n *   function returns 0.\n */\nlong double_the_difference(const std::vector<float>& lst)\n{\n    long total = 0;\n\n    for (float v : lst)\n    {\n        // Skip negative values\n        if (v < 0.0f) continue;\n\n        // Test that the value is integral\n        if (std::floor(v) != v) continue;\n\n        // Convert to integer once, then test for oddness\n        long n = static_cast<long>(v);   // safe because v is integral and non\u2011negative\n        if (n % 2 == 0) continue;        // only odd numbers\n\n        total += n * n;                  // accumulate the square\n    }\n\n    return total;\n}\n```\n\n### Why this version?\n\n* **Type safety** \u2013 The function accepts a `const std::vector<float>&` so no accidental\n  copies are made.\n* **Clarity** \u2013 The `for` loop is short and each guard (`<0`, integral check, oddness)\n  is explicit.\n* **Portability** \u2013 Only standard headers are used; no compiler\u2011specific tricks.\n* **Return type** \u2013 Because squares of `long` values can exceed the range of\n  `int`, the return type is `long` as requested.\n\nYou can drop this function into any C++ program that includes the `<cmath>` and\n`<vector>` headers, and it will behave exactly as the examples in your\ncomments show.", "Here\u2019s a ready\u2011to\u2011paste implementation for `double_the_difference`.  \nIt follows the specification:\n\n* Skips any negative values.\n* Skips any non\u2011integer values (e.g. `3.5`).\n* Only considers odd integers.\n* Sums the squares of those numbers.\n* Returns `0` for an empty input or when no qualifying numbers are found.\n\n```cpp\n#include <vector>\n#include <cmath>\n\nlong long double_the_difference(const std::vector<float>& lst)\n{\n    long long sum = 0;\n\n    for (float f : lst)\n    {\n        // ignore negative numbers\n        if (f < 0)\n            continue;\n\n        // ignore non\u2011integer values\n        if (std::floor(f) != f)\n            continue;\n\n        long long val = static_cast<long long>(f);\n\n        // only odd integers\n        if (val % 2 == 1)\n        {\n            sum += val * val;\n        }\n    }\n\n    return sum;\n}\n```\n\n### Why it works\n1. **Negative check** \u2013 `if (f < 0) continue;` stops any negative entries from contributing.\n2. **Integer check** \u2013 `std::floor(f) != f` is true when the float has a fractional part, so those are ignored.\n3. **Odd check** \u2013 `val % 2 == 1` ensures only odd integers are processed.\n4. **Accumulation** \u2013 `val * val` is added to `sum`; the result is returned as a `long long`.\n\nThe function signature uses `long long` as the return type to safely hold the sum of squares for typical inputs. Adjust the return type if your application requires a different numeric type."]}
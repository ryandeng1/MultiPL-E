{"name": "HumanEval_7_filter_by_substring", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_7_filter_by_substring.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = filter_by_substring;\n    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"xxx\", (std::string)\"asd\", (std::string)\"xxy\", (std::string)\"john doe\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})), (\"xxx\")) == (std::vector<std::string>({(std::string)\"xxx\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"xxx\", (std::string)\"asd\", (std::string)\"aaaxxy\", (std::string)\"john doe\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})), (\"xx\")) == (std::vector<std::string>({(std::string)\"xxx\", (std::string)\"aaaxxy\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"grunt\", (std::string)\"trumpet\", (std::string)\"prune\", (std::string)\"gruesome\"})), (\"run\")) == (std::vector<std::string>({(std::string)\"grunt\", (std::string)\"prune\"})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a concise, idiomatic implementation that:\n\n1. Takes ownership of the input vector (by value \u2013 you can change to reference if you don't want a copy).\n2. Uses `std::vector` and `std::string::find` to check for the substring.\n3. Returns a new vector containing only the strings that contain the given substring.\n\n```cpp\n#include <vector>\n#include <string>\n\n// Filter an input vector of strings only for ones that contain the given substring\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings,\n                                            const std::string& substring)\n{\n    // If the substring is empty, return the original vector (every string contains it)\n    if (substring.empty()) {\n        return strings;\n    }\n\n    std::vector<std::string> result;\n    result.reserve(strings.size());   // reserve to avoid repeated reallocations\n\n    for (const auto& s : strings) {\n        if (s.find(substring) != std::string::npos) {\n            result.push_back(s);\n        }\n    }\n    return result;\n}\n\n/* --------------------\n// Example usage\n#include <iostream>\n\nint main() {\n    auto v1 = filter_by_substring({\"abc\", \"bacd\", \"cde\", \"array\"}, \"a\");\n    for (auto& s : v1) std::cout << s << ' ';   // prints: abc bacd array\n    std::cout << '\\n';\n\n    auto v2 = filter_by_substring({}, \"a\");\n    std::cout << \"Size: \" << v2.size() << '\\n'; // prints: Size: 0\n}\n--------------------*/\n```\n\n### Notes\n\n- **Efficiency** \u2013 `reserve()` pre\u2011allocates enough space for the worst case, which is useful for large inputs.\n- **Empty substring** \u2013 By definition, every string contains an empty substring, so the function simply returns the original vector.\n- **Return type** \u2013 The function returns a new `std::vector<std::string>`. If you prefer to modify the original vector in place, change the signature to take a reference and use `std::remove_if` with `erase`.", "Below is a straightforward implementation that meets the documentation examples.  \nIt uses the standard library facilities (`std::string::find` and a range\u2011based loop) to build a new vector containing only the strings that contain the given substring.\n\n```cpp\n#include <vector>\n#include <string>\n\n/* Filter an input vector of strings only for ones that contain given substring\n *\n * > filter_by_substring((std::vector<std::string>()), (\"a\"))\n *  (std::vector<std::string>())\n *\n * > filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\",\n *  (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n *  (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\n */\nstd::vector<std::string> filter_by_substring(const std::vector<std::string>& strings,\n                                            const std::string& substring)\n{\n    std::vector<std::string> result;\n    // Reserve space to avoid reallocations (optional but inexpensive)\n    result.reserve(strings.size());\n\n    for (const auto& s : strings) {\n        // std::string::find returns std::string::npos if the substring is not found\n        if (s.find(substring) != std::string::npos) {\n            result.push_back(s);\n        }\n    }\n    return result;\n}\n```\n\n### How it works\n\n1. **Loop** over every string `s` in the input vector.\n2. Use `s.find(substring)` to test whether `substring` appears in `s`.  \n   If `find()` does not return `std::string::npos`, the substring is present.\n3. Push the string into the `result` vector when a match is found.\n4. Return the `result` vector, which now contains only the matching strings.\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<std::string> data({\"abc\", \"bacd\", \"cde\", \"array\"});\n    auto filtered = filter_by_substring(data, \"a\");\n\n    for (const auto& s : filtered) {\n        std::cout << s << '\\n';\n    }\n    // Output: abc\n    //         bacd\n    //         array\n}\n```\n\nThis implementation is `O(n * m)` in time, where `n` is the number of input strings and `m` is the average length of the strings, which is efficient for typical use cases.", "```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\n/*!\n *  @brief  Filters a vector of strings and keeps only those that contain the\n *          provided substring.\n *\n *  @param  strings   = the vector of strings to be inspected.\n *  @param  substring   = the substring that we are looking for.\n *\n *  @return  A vector containing all strings from `strings` that have\n *           `substring` as a consecutive sub\u2011sequence of characters\n *           (case\u2011sensitive).\n */\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings,\n                                             const std::string& substring)\n{\n    // Result vector that will hold the filtered strings\n    std::vector<std::string> filtered;\n\n    // Iterate over the input vector, keeping the ones that contain `substring`\n    for (const auto& str : strings) {\n        if (str.find(substring) != std::string::npos) {\n            filtered.push_back(str);\n        }\n    }\n    return filtered;\n}\n```\n\nThe implementation uses `std::string::find` which performs a constant\u2011time lookup for the first occurrence of `substring` within `str`.  \nIf the substring is found, the string is appended to the result vector; otherwise it is skipped. The function is `O(n\u00b7m)` where `n` is the number of input strings and `m` is the length of each string, which is the expected complexity for this operation."]}
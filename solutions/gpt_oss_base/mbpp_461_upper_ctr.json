{"name": "mbpp_461_upper_ctr", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to count the upper case characters in a given string.\nlong upper_ctr(std::string str) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_461_upper_ctr.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = upper_ctr;\n    assert(candidate((\"PYthon\")) == (1));\n    assert(candidate((\"BigData\")) == (1));\n    assert(candidate((\"program\")) == (0));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a ready\u2011to\u2011copy C++ implementation that counts how many uppercase (A\u2011Z) characters appear in a given `std::string`.  \nFeel free to drop the function into any file that already includes `<string>` (or use the snippet below which includes everything you need).\n\n```cpp\n#include <string>\n#include <cctype>   // for std::isupper\n\n/** @brief Count the number of uppercase alphabetic characters in a string.\n *\n *  The function iterates through each character of the input string,\n *  checks whether it is an uppercase letter using `std::isupper`,\n *  and tallies them up.  It is safe to use with any valid UTF\u20118\n *  string because `std::isupper` works on the byte level \u2013 it only\n *  recognizes the ASCII range A\u2011Z.  For full Unicode support you\n *  would need a library such as ICU.\n *\n *  @param str The string to scan.\n *  @return The number of uppercase letters (A\u2013Z) found.\n */\nlong upper_ctr(const std::string& str)\n{\n    long count = 0;\n    for (unsigned char ch : str) {          // unsigned to avoid signed\u2011char issues\n        if (std::isupper(ch)) {\n            ++count;\n        }\n    }\n    return count;\n}\n```\n\n### Quick test\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::string txt = \"Hello, World! 123 ABC xyz.\";\n    std::cout << \"Uppercase count: \" << upper_ctr(txt) << '\\n'; // outputs 5\n    return 0;\n}\n```\n\nThe function runs in O(n) time, where *n* is the length of the input string, and uses only a single integer counter as additional memory.", "Here\u2019s a compact, self\u2011contained C++ function that counts the number of **upper\u2011case** characters in a given `std::string`.  \nIt uses only the standard library, so you can copy it straight into any project.\n\n```cpp\n#include <cctype>   // std::isupper\n#include <string>\n\n// ---------------------------------------------------------------------------\n// Counts the number of ASCII upper\u2011case letters in `str`.\n// The function is O(n) where n = str.size().\n// ---------------------------------------------------------------------------\ninline std::size_t upper_ctr(const std::string& str)\n{\n    std::size_t count = 0;\n    for (char ch : str)\n    {\n        if (std::isupper(static_cast<unsigned char>(ch)))\n            ++count;\n    }\n    return count;\n}\n```\n\n### Why this version?\n\n| Feature | Explanation |\n|---------|-------------|\n| **`inline`** | Suggests to the compiler that the function is small and may be inlined. |\n| **`const std::string&`** | Passes the string by reference to avoid an expensive copy. |\n| **`std::size_t`** | Matches the container\u2019s size type and is the natural return type for a count. |\n| **`std::isupper` + cast to `unsigned char`** | Guarantees correct behaviour for all values of `char`, even if `char` is signed. |\n| **Readability** | A single loop with an early test keeps the code short and clear. |\n\n---\n\n#### Quick Test\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::string s = \"Hello, World! 42 \u00c4\u00d6\u00dc\";\n    std::cout << \"Upper\u2011case letters: \" << upper_ctr(s) << '\\n'; // prints 7\n}\n```\n\n*Only the letters `H`, `W`, `A`, `\u00d6`, and `\u00dc` are counted; others (lower\u2011case, digits, punctuation, spaces) are ignored.*\n\n---\n\nFeel free to drop the function into your project, unit\u2011test it, or adapt it to other string\u2011like containers (e.g., `std::string_view`) if you need more flexibility. Happy coding!", "Here is a small, self\u2011contained C++ implementation that counts the number of **uppercase** characters in a given `std::string`.  \nThe function follows the C++17/20 style, uses the standard library only, and contains a handful of comments to make the logic crystal\u2011clear.\n\n```cpp\n#include <string>\n#include <cctype>   // std::isupper\n#include <cassert>  // for assert\n\n/**\n * Count the number of uppercase ASCII letters in a string.\n *\n * @param str  The input string to be scanned.\n * @return     The count of characters in the range ['A', 'Z'].\n *\n * Note:\n *   - Only the standard English alphabet (A\u2011Z) is considered uppercase.\n *   - Non\u2011ASCII characters (e.g. accented letters, Unicode) are ignored\n *     unless they fall into the ASCII uppercase range.\n */\nlong upper_ctr(const std::string& str)\n{\n    long count = 0;\n    for (unsigned char c : str)           // iterate over each byte\n    {\n        if (std::isupper(c))               // true for 'A'\u2013'Z'\n            ++count;\n    }\n    return count;\n}\n\n/* ------------------------------------------------------------------ */\n/*                              Testing                                 */\n/* ------------------------------------------------------------------ */\nint main()\n{\n    assert(upper_ctr(\"\") == 0);\n    assert(upper_ctr(\"abc\") == 0);\n    assert(upper_ctr(\"ABC\") == 3);\n    assert(upper_ctr(\"AbC Def GHi\") == 4);\n    assert(upper_ctr(\"Hello, WORLD!\") == 5);\n\n    // A quick run\u2011time example (uncomment if desired)\n    // std::string s;\n    // std::getline(std::cin, s);\n    // std::cout << \"Number of uppercase letters: \" << upper_ctr(s) << '\\n';\n\n    return 0;\n}\n```\n\n### How it works\n\n1. **`std::isupper`** \u2013 Standard C++ checks if an unsigned character is an alphabetic uppercase letter (`'A'` to `'Z'`).  \n   - It works for ASCII input normally.  \n   - `std::isupper` expects an `int` value that is either `EOF` or representable as an `unsigned char`.  \n   - Therefore we iterate with `unsigned char` to avoid undefined behaviour on signed `char` platforms.\n\n2. **Counting** \u2013 Every time `std::isupper` returns `true`, we increment the `count`.  \n   - The running total (`long`) is returned.\n\n3. **Testing** \u2013 Simple `assert` statements are in `main()` to verify the function on a few cases.  \n   - You can compile with `-O0 -Wall -Wextra -std=c++20` (or any C++17/20 compliant compiler).  \n\nFeel free to drop this function into any larger project, or adapt it for locale\u2011aware counting (e.g. using `<locale>` and `std::isupper(c, loc)` if you need to support non\u2011ASCII orthographies)."]}
{"name": "mbpp_388_highest_Power_of_2", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to find the highest power of 2 that is less than or equal to n.\nlong highest_Power_of_2(long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_388_highest_Power_of_2.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = highest_Power_of_2;\n    assert(candidate((10)) == (8));\n    assert(candidate((19)) == (16));\n    assert(candidate((32)) == (32));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a compact, self\u2011contained C++17 implementation of a function that returns the largest power of\u202f2 that is **\u2264\u202fn**.  \nThe idea is simple: keep left\u2011shifting a 1 until the next shift would exceed *n*.  \nThe function works for all non\u2011negative inputs (including 0) and is constant\u2011time.\n\n```cpp\n#include <cstdint>   // For std::uint64_t\n#include <limits>    // For std::numeric_limits\n\n/// @brief  Returns the greatest power of 2 that is \u2264 n.\n/// @param  n  Non\u2011negative integer (uint64_t).\n/// @return  The highest power of two not exceeding n.\n/// @throws std::invalid_argument if n is negative.           // (optional in practice)\ninline std::uint64_t highest_power_of_2(std::uint64_t n)\n{\n    // Corner case:  n == 0 \u2192 no positive power of two <= 0\n    if (n == 0) return 0;\n\n    // Start with the lowest power of two: 1ULL\n    std::uint64_t r = 1ULL;\n\n    // Keep left\u2011shifting until the next shift would overflow or exceed n\n    while ((r << 1) != 0 && (r << 1) <= n)\n    {\n        r <<= 1;\n    }\n\n    return r;   // r is now the desired power of two\n}\n\n/* ======= Example & Test ======= */\n#include <iostream>\n#include <cassert>\n\nint main()\n{\n    for (std::uint64_t n = 0; n < 1000; ++n)\n    {\n        std::uint64_t res = highest_power_of_2(n);\n\n        // Verify property: 2^k <= n < 2^(k+1)\n        assert(res == 0 || ( (res & (res - 1)) == 0 ));   // res is a power of two\n        assert(res <= n);\n        assert((res << 1) > n || (res << 1) == 0);        // next power would overflow or be > n\n    }\n\n    std::cout << \"All tests passed!\\n\";\n    std::cout << \"Highest power of two <= 123456789: \" << highest_power_of_2(123456789) << \"\\n\";\n}\n```\n\n### How it works\n\n1. **Edge case** \u2013 For `n == 0` the function returns `0` because no positive power of two is \u2264\u202f0.\n2. **Loop** \u2013 Starting from `1` (2\u2070), we left\u2011shift (`<< 1`) each iteration:\n   * The condition `(r << 1) != 0` safeguards against overflow on machines where `uint64_t` is 64\u2011bit.\n   * `(r << 1) <= n` ensures we stop before exceeding the input.\n3. **Return** \u2013 The value in `r` after the loop is the required power of two.\n\nThis implementation is O(1) in practice (\u2264\u202f64 iterations for a 64\u2011bit integer) and requires no extra space.", "Here is a concise and efficient implementation that uses bit\u2011wise operations (no loops/recursion).  \nThe function assumes that **n\u202f>\u202f0**; for *n\u00a0<=\u00a00* it simply returns 0, which is consistent with \u201chighest power of 2 less than or equal to n\u201d.\n\n```cpp\n#include <cstdint>\n#include <climits>\n\n// Return the largest power of two that is <= n.\n// If n is 0 or negative the result is 0.\nlong long highest_Power_of_2(long long n)\n{\n    if (n <= 0) return 0;            // no positive power of 2 <= n\n\n    // Move the highest set bit of n to the least\u2011significant position\n    uint64_t x = static_cast<uint64_t>(n);\n    x |= (x >> 1);\n    x |= (x >> 2);\n    x |= (x >> 4);\n    x |= (x >> 8);\n    x |= (x >> 16);\n    x |= (x >> 32);                  // for 64\u2011bit numbers\n\n    // Now the lowest bit is the highest power of two <= n\n    return static_cast<long long>(x & -x);   // x & (~x + 1)\n}\n\n/* -----------  quick test  -----------\n\n#include <iostream>\nint main() {\n    for (long long n : {0,1,5,16,31,64,100,1023,1024,1025}) {\n        std::cout << n << \" -> \" << highest_Power_of_2(n) << '\\n';\n    }\n}\n-------------------------------------\nExpected output:\n0 -> 0\n1 -> 1\n5 -> 4\n16 -> 16\n31 -> 16\n64 -> 64\n100 -> 64\n1023 -> 512\n1024 -> 1024\n1025 -> 1024\n*/\n\n```\n\n### How it works\n\n1. **If `n <= 0`** \u2013 there is no positive power of two that satisfies the condition, so return 0.\n2. **Propagate the highest set bit** to all lower bits using successive `x |= x >> k` operations. After these steps, all bits lower than the most significant bit of the original `n` are set to 1.\n3. **Isolate the least significant bit** (which is actually the most significant bit of the *original* `n`).  \n   `x & -x` (or `x & (~x + 1)`) leaves only the lowest set bit, giving exactly the desired power of two.\n\nThis method runs in O(1) time, works for 32\u2011bit and 64\u2011bit integers, and is straightforward to read.", "Here\u2019s a concise, self\u2011contained C++ implementation that returns the highest power of\u202f2 that is less than or equal to a given integer `n`.  \nIt works for positive `n` (including `0` \u2013 for which the result is `1`) and uses only bit\u2011wise operations, so it\u2019s O(1).\n\n```cpp\n// Highest power of 2 less than or equal to n\n// n must be non\u2011negative (uint64_t is used for a wide range)\n#include <cstdint>\n#include <climits>\n#include <cassert>\n\n// Computes 2^k \u2264 n < 2^(k+1).  For n=0 it returns 1.\ninline uint64_t highest_power_of_two(uint64_t n)\n{\n    if (n == 0) return 1;          // convention: 2^0 = 1\n    return 1ULL << (63 - __builtin_clzll(n));\n}\n\n/* Example usage\nint main()\n{\n    for (uint64_t i = 0; i <= 20; ++i)\n        std::cout << i << \" -> \" << highest_power_of_two(i) << '\\n';\n    return 0;\n}\n*/\n```\n\n### Explanation\n* `__builtin_clzll(n)` (or `clz` for 32\u2011bit) returns the number of leading zero bits in the 64\u2011bit representation of `n`.  \n* Subtracting that count from 63 gives the position of the most significant set bit (0\u2011based).  \n* Shifting 1 left by that amount yields the desired power of two.\n\nThis method is both fast and portable across common compilers (GCC, Clang, MSVC)."]}
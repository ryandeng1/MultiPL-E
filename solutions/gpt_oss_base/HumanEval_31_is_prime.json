{"name": "HumanEval_31_is_prime", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_31_is_prime.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = is_prime;\n    assert(candidate((6)) == (false));\n    assert(candidate((101)) == (true));\n    assert(candidate((11)) == (true));\n    assert(candidate((13441)) == (true));\n    assert(candidate((61)) == (true));\n    assert(candidate((4)) == (false));\n    assert(candidate((1)) == (false));\n    assert(candidate((5)) == (true));\n    assert(candidate((11)) == (true));\n    assert(candidate((17)) == (true));\n    assert(candidate((85)) == (false));\n    assert(candidate((77)) == (false));\n    assert(candidate((255379)) == (false));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a compact yet clear implementation of `is_prime` that works for any signed 64\u2011bit integer (the usual C++ `long` type).  \nThe algorithm uses the classic *O(\u221an)* trial division but with a few small optimisations:\n\n1. **Handle small values** \u2013 0, 1, and negative numbers are not prime.  \n2. **Even numbers** \u2013 after checking 2, all other even numbers are immediately rejected.  \n3. **Only odd divisors up to sqrt(n)** \u2013 we step by 2 to avoid testing even factors.  \n4. **Early stopping** \u2013 if `d * d` overflows or exceeds `n`, we stop.\n\n```cpp\n#include <cassert>\n#include <cstdint>\n#include <cmath>\n#include <iostream>\n\nbool is_prime(long n) {\n    if (n <= 1)          return false;          // 0, 1 and negatives\n    if (n <= 3)          return true;           // 2, 3\n\n    if (n % 2 == 0)      return false;          // even numbers > 2\n\n    const long long root = static_cast<long long>(std::sqrt(static_cast<long double>(n)));\n    for (long long d = 3; d <= root; d += 2) {\n        if (n % d == 0)  return false;\n    }\n    return true;\n}\n\n/* ----------  Signed version  ----------\n   If you prefer to use a strictly signed type you can cast to int64_t\n   instead of long in the function signature.  The algorithm is the same.\n*/\n\nint main() {\n    // Test examples from the prompt\n    assert(is_prime(6)  == false);\n    assert(is_prime(101) == true);\n    assert(is_prime(11) == true);\n    assert(is_prime(13441) == true);\n    assert(is_prime(61) == true);\n    assert(is_prime(4)  == false);\n    assert(is_prime(1)  == false);\n\n    // You can also test larger numbers\n    assert(is_prime(1000000007LL) == true);     // a known large prime\n    assert(is_prime(1000000000LL) == false);    // composite\n\n    std::cout << \"All checks passed.\\n\";\n}\n```\n\n### Why this version works\n\n| Feature | Why it matters |\n|---|---|\n| `n <= 1` \u2192 false | 0 and 1 are not prime by definition. |\n| `n <= 3` \u2192 true | 2 and 3 are the only primes < 5. |\n| `n % 2 == 0` \u2192 false | Even numbers > 2 cannot be prime. |\n| Loop with `d += 2` up to `sqrt(n)` | Eliminates the majority of composite checks and runs in O(\u221an). |\n| Use `long long` for the divisor | Prevents overflow when computing `d*d`. |\n\nThis implementation is both **readable** and **efficient** for the typical ranges of integers you\u2019ll encounter.", "Here is a compact and fully\u2011worked implementation of `is_prime` for 64\u2011bit signed integers.  \nIt first handles the obvious small cases, then checks divisibility by 2 and 3, and finally uses the\n6k\u00b11 optimization to test every remaining possible divisor up to `sqrt(n)`.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Return true if a given number is prime, false otherwise.\nbool is_prime(long long n)            // use long long to safely cover the\n{                                   // typical 64\u2011bit input range\n    if (n <= 1)           return false;          // 0, 1 are not prime\n    if (n <= 3)           return true;           // 2, 3 are prime\n    if (n % 2 == 0)       return false;          // even numbers > 2 are composite\n    if (n % 3 == 0)       return false;          // multiples of 3\n\n    // All primes greater than 3 are of the form 6k \u00b1 1\n    for (long long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0)           return false;   // divisible by i\n        if (n % (i + 2) == 0)     return false;   // divisible by i+2\n    }\n    return true;\n}\n```\n\n### How it works\n\n1. **Small numbers**  \n   - If `n <= 1`, the function returns `false` (neither 0 nor 1 is prime).  \n   - If `n <= 3`, it returns `true` (2 and 3 are prime).  \n\n2. **Eliminate trivial non\u2011primes**  \n   - Any even integer greater than 2 is composite.  \n   - Any multiple of 3 greater than 3 is composite.\n\n3. **Trial division by 6k\u00b11**  \n   - After removing multiples of 2 and 3, all remaining primes are of the form \\(6k \\pm 1\\).  \n   - We test divisibility by `i` and `i+2` where `i` starts at 5 and increments by 6 each loop.  \n   - The loop stops when `i*i` exceeds `n`, because if `n` had a divisor larger than its square root, it would have a corresponding smaller one already tested.\n\n### Complexity\n\n- **Time**: \\(O(\\sqrt{n})\\) in the worst case (for large primes).  \n- **Space**: \\(O(1)\\) \u2013 only a few variables are used.\n\nThis implementation is ideal for typical use cases such as the sample tests you showed:\n\n```\nassert(is_prime(6)  == false);\nassert(is_prime(101)== true);\nassert(is_prime(11) == true);\nassert(is_prime(13441)== true);\nassert(is_prime(61) == true);\nassert(is_prime(4)  == false);\nassert(is_prime(1)  == false);\n```\n\nFeel free to drop it straight into your project!", "Here is a complete, self\u2011contained implementation of `is_prime` for 64\u2011bit integers in C++17.  \nIt uses the deterministic Miller\u2013Rabin test for numbers up to `2^64`, which is\nfast and works for all inputs in the domain of the function (`long` on a\n64\u2011bit system).\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// ------------------------------------------------------------------\n// Helper for __int128 multiplication modulo.\ninline unsigned long long mul_mod(unsigned long long a,\n                                  unsigned long long b,\n                                  unsigned long long mod) {\n    __uint128_t res = (__uint128_t)a * b % mod;\n    return (unsigned long long)res;\n}\n\n// Power modulo using binary exponentiation.\ninline unsigned long long pow_mod(unsigned long long a,\n                                  unsigned long long d,\n                                  unsigned long long mod) {\n    unsigned long long res = 1;\n    while (d) {\n        if (d & 1) res = mul_mod(res, a, mod);\n        a = mul_mod(a, a, mod);\n        d >>= 1;\n    }\n    return res;\n}\n\n// Deterministic Miller\u2013Rabin for 64\u2011bit integers.\nbool is_prime(long n) {\n    if (n < 2) return false;\n    if (n % 2 == 0) return n == 2;\n    if (n % 3 == 0) return n == 3;\n    if (n % 5 == 0) return n == 5;\n\n    // Write n-1 = d * 2^s   (d odd)\n    unsigned long long d = n - 1;\n    int s = 0;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        ++s;\n    }\n\n    // Bases that make the test deterministic for 64\u2011bit values.\n    const unsigned long long bases[] = {2ULL, 325ULL, 9375ULL,\n                                        28178ULL, 450775ULL, 9780504ULL,\n                                        1795265022ULL};\n\n    for (unsigned long long a : bases) {\n        if (a % n == 0) continue;          // skip if base is a multiple of n\n        unsigned long long x = pow_mod(a, d, n);\n        if (x == 1 || x == (unsigned long long)n - 1) continue;\n\n        bool composite = true;\n        for (int r = 1; r < s; ++r) {\n            x = mul_mod(x, x, n);\n            if (x == (unsigned long long)n - 1) {\n                composite = false;\n                break;\n            }\n        }\n        if (composite) return false;\n    }\n    return true;\n}\n\n// ------------------------------------------------------------------\n// Simple tests (optional \u2013 remove if you only want the function)\nint main() {\n    vector<long> test_cases = {6, 101, 11, 13441, 61, 4, 1};\n\n    for (auto x : test_cases) {\n        cout << \"is_prime(\" << x << \") = \" << (is_prime(x) ? \"true\" : \"false\")\n             << '\\n';\n    }\n    return 0;\n}\n```\n\n### Why this works\n\n* **Deterministic Miller\u2013Rabin** with the seven bases listed above\n  correctly distinguishes primes from composites for all 64\u2011bit integers\n  (`0\u00a0\u2264\u00a0n\u00a0<\u00a02^64`).  \n* The helper `mul_mod` uses `__uint128_t` to avoid overflow when\n  multiplying two 64\u2011bit numbers modulo `n`.  \n* The code is compliant with the C++17 standard and compiles with\n  any conforming compiler (e.g., `g++ -std=c++17`).\n\nYou can drop the `main` function in your production code and keep only\nthe `is_prime` implementation."]}
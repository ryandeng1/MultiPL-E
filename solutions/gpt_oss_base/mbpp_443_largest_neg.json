{"name": "mbpp_443_largest_neg", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to find the largest negative number from the given vector.\nlong largest_neg(std::vector<long> list1) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_443_largest_neg.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = largest_neg;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)-4, (long)-6}))) == (-6));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)-8, (long)-9}))) == (-9));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)-1}))) == (-1));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a compact **C++ (cppython\u2011style)** implementation that returns the largest (i.e. closest to zero) negative number from the supplied `std::vector<long>`.  \nIf the vector contains no negative numbers we return `LONG_MIN` to indicate \u201cno negative number present\u201d.\n\n```cpp\n#include <vector>\n#include <limits>   // for std::numeric_limits\n\n// ------------------------------------------------------------------\n// largest_neg :  Returns the largest negative number from `list1`.\n//               If there is no negative number, `LONG_MIN` is returned.\n// ------------------------------------------------------------------\nlong largest_neg(const std::vector<long>& list1) {\n    long best = std::numeric_limits<long>::min();   // initialise to the lowest possible value\n\n    for (long x : list1) {\n        if (x < 0 && x > best) {   // look for negatives and keep the maximum among them\n            best = x;\n        }\n    }\n\n    return best;   // may equal LONG_MIN if the vector had no negative element\n}\n```\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> vals = { 5, -3, -10, 2, -1 };\n    long largest_neg_num = largest_neg(vals);\n\n    if (largest_neg_num == std::numeric_limits<long>::min())\n        std::cout << \"No negative numbers found.\\n\";\n    else\n        std::cout << \"Largest negative: \" << largest_neg_num << '\\n';\n}\n```\n\n### Complexity\n\n- Time:  **O(n)** \u2013 one pass over the vector.  \n- Space: **O(1)** \u2013 constant auxiliary memory.", "Here is a concise, self\u2011contained C++ implementation that returns the largest (i.e. the \u201cclosest to zero\u201d) negative value in a `std::vector<long>`.  \nIf the vector contains no negative numbers the function returns `LLONG_MIN` (you can change this sentinel value or throw an exception if you prefer).\n\n```cpp\n#include <vector>\n#include <climits>   // for LLONG_MIN\n#include <algorithm> // for std::max\n\n/// \\brief Compute the largest negative element in a vector.\n/// \\param list1 Vector of long integers.\n/// \\return The largest negative number, or LLONG_MIN if none exists.\nlong largest_neg(const std::vector<long>& list1)\n{\n    // Keep track of the best candidate seen so far.\n    long best = LLONG_MIN;   // sentinel: nothing found yet\n\n    for (const auto& val : list1)\n    {\n        if (val < 0 && val > best)   // a negative value that is\n            best = val;              // larger (closer to zero) than current best\n    }\n\n    return best;\n}\n```\n\n### How it works\n1. Initialise `best` to the smallest possible long value (`LLONG_MIN`).  \n2. Iterate through each element of the vector.  \n3. For each element that is **negative** and **greater** than the current `best`, update `best`.  \n4. After the loop, `best` holds the largest negative value found (or remains `LLONG_MIN` if none were present).\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> v = { 3, -5, 12, -2, -9 };\n    long res = largest_neg(v);\n    if (res == LLONG_MIN)\n        std::cout << \"No negative numbers.\\n\";\n    else\n        std::cout << \"Largest negative number: \" << res << '\\n';\n}\n```\n\nThis will output:\n\n```\nLargest negative number: -2\n```\n\nFeel free to adjust the sentinel value or error handling to match your project\u2019s conventions.", "Below is a simple, self\u2011contained implementation of a C++ function that returns the **largest negative** element in a vector of `long`.  \nIt follows these rules:\n\n1. **Largest negative** = the negative element with the greatest numerical value (closest to zero).  \n2. If the vector contains **no negative numbers**, the function returns `LLONG_MIN` (the minimum representable `long` value).  \n3. The implementation uses only headers that are guaranteed to exist in any compliant C++14/17/20 compiler (the usual `<vector>` and `<limits>` \u2013 no need for the `<bits/stdc++.h>` hack).\n\n```cpp\n#include <vector>          // std::vector\n#include <limits>          // std::numeric_limits\n\n/**\n * @brief   Finds and returns the largest negative number in a vector of longs.\n * \n * @param   list1  Vector containing long values.\n * \n * @return  The largest negative value (closest to zero). If no negative\n *          number exists, returns std::numeric_limits<long>::min().\n *\n * @note    Complexity: O(n) where n = list1.size().\n * @note    Assumes signed long range (= at least [-2^31, 2^31-1] on most\n *          platforms). If your platform uses a different range, the\n *          function still works because std::numeric_limits<long>::min()\n *          gives an appropriate sentinel value.\n */\nlong largest_neg(const std::vector<long>& list1)\n{\n    // Sentinel value representing \u201cno negative number found\u201d\n    const long NEG_INF = std::numeric_limits<long>::min();\n\n    long best = NEG_INF;                 // initialise to the most negative value\n    for (const long &x : list1)\n    {\n        if (x < 0 && x > best)           // we found a negative that is larger\n            best = x;\n    }\n    return best;                         // may be NEG_INF if none were found\n}\n```\n\n### How to use it\n\n```cpp\n#include <iostream>\nint main() {\n    std::vector<long> v = {3, -5, -2, 7, -10};\n    long max_neg = largest_neg(v);\n    if (max_neg == std::numeric_limits<long>::min())\n        std::cout << \"No negative numbers in the vector.\\n\";\n    else\n        std::cout << \"Largest negative number is: \" << max_neg << '\\n';\n}\n```\n\nThis implementation is concise, readable and works for any standard C++ environment."]}
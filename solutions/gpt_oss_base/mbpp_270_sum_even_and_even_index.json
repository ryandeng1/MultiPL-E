{"name": "mbpp_270_sum_even_and_even_index", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to find the sum of even numbers at even positions of a vector.\nlong sum_even_and_even_index(std::vector<long> arr) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_270_sum_even_and_even_index.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = sum_even_and_even_index;\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)12, (long)1, (long)18, (long)8}))) == (30));\n    assert(candidate((std::vector<long>({(long)3, (long)20, (long)17, (long)9, (long)2, (long)10, (long)18, (long)13, (long)6, (long)18}))) == (26));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)12, (long)1}))) == (12));\n}\n", "stop_tokens": ["\n}"], "completions": ["```cpp\n#include <vector>\n#include <cstddef>\n\n/*\n *  Sum all elements that satisfy two conditions:\n *  1) The element itself is an even number.\n *  2) The position (index) of that element in the vector is even.\n *\n *  Indexing is zero\u2011based.  That means positions 0, 2, 4, \u2026 are considered\n *  *even* indices, while positions 1, 3, 5, \u2026 are *odd* indices.\n *\n *  Parameter:\n *      arr \u2013 a reference to the vector that may contain any number of\n *            `long` values.  The vector is not modified.\n *\n *  Return:\n *      The sum of all elements that are even *and* lie at an even index.\n *\n *  Example:\n *      arr = { 1, 2, 4, 3, 6, 8 }\n *      indices\u00a0= [0,1,2,3,4,5]\n *      even_indices\u00a0= 0,2,4\n *      values at those indices = 1,4,6\n *      only 4 and 6 are even \u2192 4+6 = 10\n */\nlong long sum_even_and_even_index(const std::vector<long long>& arr)\n{\n    long long sum = 0;\n\n    // Iterate over the vector using a traditional for\u2013loop to keep the\n    // index available without an expensive iterator with `index()` calls.\n    for (std::size_t i = 0; i < arr.size(); ++i)\n    {\n        // 1. Check that the index itself is even.\n        if ((i & 1) == 0)          // equivalent to (i % 2 == 0)\n        {\n            // 2. Check that the value at that index is even.\n            if ((arr[i] & 1LL) == 0)   // equivalent to (arr[i] % 2 == 0)\n            {\n                sum += arr[i];\n            }\n        }\n    }\n    return sum;\n}\n```\n\n### Why this implementation?\n\n* **Zero\u2011based indexing** is used because it matches the standard C++ container semantics.\n* The function accepts the vector **by const reference** so as not to copy it.\n* Bitwise checks (`i & 1` and `arr[i] & 1LL`) are slightly faster than `% 2` on most platforms.\n* The return type is `long long` (or `long` if your platform\u2019s `long` is 64\u2011bit) to avoid overflow when summing many `long` values.", "Below is a compact, self\u2011contained C++ helper that can be pasted into any project.\nIt receives a `std::vector<long>` (any integral type works \u2013 we keep `long` for\ncompatibility with the signature you posted), iterates over the elements, and\nadds those that satisfy two conditions:\n\n* **Even value**\u2003(`x % 2 == 0`)\n* **Even index**\u2003(0\u2011based index is even, i.e. `i % 2 == 0`)\n\nThe function returns the accumulated sum as a `long`.  \nWe also provide a small `main()` for quick manual testing.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cassert>\n\n// ------------------------------------------------------------------\n// sum_even_and_even_index\n// ------------------------------------------------------------------\n/**\n * Returns the sum of all elements that are even and reside at an even\n * (0\u2011based) position in the vector.\n *\n * @param arr Input vector of long integers.\n * @return Sum of qualifying elements; 0 if none qualify.\n */\nlong sum_even_and_even_index(const std::vector<long>& arr) {\n    long total = 0;\n    for (std::size_t i = 0; i < arr.size(); ++i) {\n        // Check both conditions: value is even AND index is even.\n        if ((arr[i] % 2 == 0) && (i % 2 == 0)) {\n            total += arr[i];\n        }\n    }\n    return total;\n}\n\n// ------------------------------------------------------------------\n// Optional: simple test harness\n// ------------------------------------------------------------------\nint main() {\n    // Example data: indices 0 1 2 3 4\n    //             values  2 3 4 5 6\n    // Even indices: 0,2,4 \u2013 values 2,4,6 \u2192 all are even \u2192 sum = 12\n    std::vector<long> v{2, 3, 4, 5, 6};\n    long sum = sum_even_and_even_index(v);\n    std::cout << \"Sum = \" << sum << '\\n';          // Expected: 12\n\n    // Unit\u2011style checks\n    assert(sum_even_and_even_index({}) == 0);\n    assert(sum_even_and_even_index({1, 2, 3, 4}) == 0);\n    assert(sum_even_and_even_index({2, 4, 6, 8, 10}) == 18); // 2+6+10\n    std::cout << \"All assertions passed.\\n\";\n    return 0;\n}\n```\n\n### How it works\n\n| Step | Operation | Why |\n|------|-----------|-----|\n| 1 | Iterate over all indices `i` | We need to check each element. |\n| 2 | Check `arr[i] % 2 == 0` | Ensures the value itself is even. |\n| 3 | Check `i % 2 == 0` | Ensures the index is even (0\u2011based). |\n| 4 | Add to `total` | Accumulate the qualifying numbers. |\n| 5 | Return `total` | Gives the desired sum. |\n\nFeel free to delete the `main()` section if you only need the function in a library. The function is `const`\u2011qualified for the vector parameter, so it does not modify the input.", "Here\u2019s a clean, self\u2011contained C++14/17 function that does exactly what you asked for:\n\n```cpp\n#include <vector>\n#include <cstddef>   // for std::size_t\n\n/**\n * @brief Returns the sum of the elements that are even and located at\n *        even indices (using 0\u2011based indexing).\n *\n * @param arr Vector of 64\u2011bit signed integers.\n * @return Sum of all elements where both the value and its index are even.\n *\n * Algorithm:\n *   * Iterate over the vector using a for\u2011loop.\n *   * For each element check:\n *         - The index i is even: (i % 2 == 0)  \u2192 it is also i & 1 == 0\n *         - The element itself is even: (arr[i] % 2 == 0)\n *   * If both conditions hold, add the element to the running total.\n *\n * Complexity:\n *   Time:  O(n) where n is arr.size()\n *   Space: O(1)\n */\nlong long sum_even_and_even_index(const std::vector<long long>& arr)\n{\n    long long sum = 0;\n    for (std::size_t i = 0; i < arr.size(); ++i) {\n        if ( ((i & 1u) == 0) && ((arr[i] & 1LL) == 0) ) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```\n\n### Why this implementation is efficient\n\n* **Single pass** \u2013 We only traverse the array once.\n* **Bit operations** \u2013 `i & 1` and `arr[i] & 1` are faster than modulo.\n* **`const` reference** \u2013 No copying of the vector; read\u2011only access.\n* **`long long` return type** \u2013 Avoids overflow for reasonably sized inputs.\n\nYou can call the function like:\n\n```cpp\nint main() {\n    std::vector<long long> v{ 4, 5, 6, 7, 8, 9, 10 };\n    std::cout << sum_even_and_even_index(v) << '\\n';   // prints 18\n}\n```\n\nFeel free to adapt the type (`long`, `int64_t`, etc.) to match your platform\u2019s integer limits."]}
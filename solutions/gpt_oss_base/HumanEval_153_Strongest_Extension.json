{"name": "HumanEval_153_Strongest_Extension", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_153_Strongest_Extension.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"}))) == (\"Sp.671235\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["```cpp\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n    // keep track of best extension index and best strength\n    int bestIndex = -1;\n    int bestStrength = INT_MIN;             // the larger the value -> stronger\n\n    for (int i = 0; i < static_cast<int>(extensions.size()); ++i) {\n        const std::string& ext = extensions[i];\n\n        int cap = 0;   // uppercase count\n        int sm  = 0;   // lowercase count\n        for (char c : ext) {\n            if (std::isupper(static_cast<unsigned char>(c))) ++cap;\n            else if (std::islower(static_cast<unsigned char>(c))) ++sm;\n            // ignores other characters (digits, punctuation \u2026)\n        }\n\n        int strength = cap - sm;            // per statement\n\n        // choose stronger or first in case of tie\n        if (strength > bestStrength) {\n            bestStrength = strength;\n            bestIndex    = i;\n        }\n    }\n\n    // if no extensions were provided, just return the class name itself\n    if (bestIndex == -1) return class_name;\n\n    return class_name + \".\" + extensions[bestIndex];\n}\n```\n\nThis function iterates over all extensions, computes the strength as `CAP - SM` (number of uppercase letters minus number of lowercase letters), keeps the largest strength found, and returns the result in the requested `ClassName.ExtensionName` format. If two extensions have the same strength, the first one in the vector is kept because we only update the best when the new strength is **strictly greater**.", "Here is a complete implementation. It follows the stated specification \u2013 iterating over the vector, computing the strength (number of uppercase letters minus the number of lowercase letters) for each extension, keeping track of the strongest one (and the first one in case of ties), and finally returning the concatenated result.\n\n```cpp\n#include <string>\n#include <vector>\n\n/**\n * @brief Return the class name concatenated with the strongest extension.\n *\n * The \"strength\" of an extension is\n *      strength = (number of uppercase letters) \u2013 (number of lowercase letters)\n * Among equal strengths the first occurring extension in the vector is chosen.\n *\n * @param class_name   Name of the class.\n * @param extensions   Vector of candidate extension names.\n * @return A string of the form \"ClassName.StrongestExtensionName.\"\n */\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n    // Safety check \u2013 if no extensions are supplied, just return the class name.\n    if (extensions.empty())\n        return class_name;\n\n    int best_strength = std::numeric_limits<int>::min(); // initialise to a very small value\n    size_t best_index = 0;\n\n    // Iterate over all extensions\n    for (size_t i = 0; i < extensions.size(); ++i) {\n        const std::string &ext = extensions[i];\n        int cap = 0;   // uppercase count\n        int sm = 0;    // lowercase count\n\n        for (char c : ext) {\n            if (c >= 'A' && c <= 'Z')\n                ++cap;\n            else if (c >= 'a' && c <= 'z')\n                ++sm;\n            // other characters are ignored in the strength computation\n        }\n\n        int strength = cap - sm;\n\n        // Update best if this extension is stronger, or if equal strength and\n        // this is the first such extension (which happens automatically\n        // because we use strict '>' comparison).\n        if (strength > best_strength) {\n            best_strength = strength;\n            best_index = i;\n        }\n    }\n\n    // Construct and return the final string\n    return class_name + \".\" + extensions[best_index];\n}\n```\n\n### Explanation of Key Parts\n\n1. **Strength Calculation**  \n   ```cpp\n   if (c >= 'A' && c <= 'Z') ++cap;\n   else if (c >= 'a' && c <= 'z') ++sm;\n   ```\n   This strictly counts only alphabetic characters, ignoring any digits or punctuation.\n\n2. **Choosing the Best Extension**  \n   The `if (strength > best_strength)` condition guarantees that the *first* extension achieving a particular strength is retained, as the comparison is strict (`>`). When strengths are equal, earlier ones keep precedence automatically.\n\n3. **Return Format**  \n   The concatenated string follows the required `ClassName.ExtensionName` format.\n\nFeel free to integrate this function into your code base. If any additional checks or behaviour is required (e.g., handling empty inputs differently), the logic can be extended easily.", "Here is a minimal, self\u2011contained implementation of the requested function:\n\n```cpp\n#include <string>\n#include <vector>\n#include <algorithm>\n\n// Compute the strength of a single extension\ninline int strength(const std::string &ext)\n{\n    int cap = 0, sm = 0;\n    for (char c : ext)\n    {\n        if (std::isupper(static_cast<unsigned char>(c))) ++cap;\n        else if (std::islower(static_cast<unsigned char>(c))) ++sm;\n    }\n    return cap - sm;\n}\n\n// Return  \u201c<class_name>.<strongest_extension>\u201d\nstd::string Strongest_Extension(std::string class_name, const std::vector<std::string> &extensions)\n{\n    if (extensions.empty())\n        return class_name;                     // no extensions \u2192 return the class name\n\n    int best_strength = std::numeric_limits<int>::min();\n    std::string best_ext;\n\n    for (const auto &ext : extensions)\n    {\n        int cur_strength = strength(ext);\n        if (cur_strength > best_strength)\n        {\n            best_strength = cur_strength;\n            best_ext      = ext;               // keep first one on ties (since we only\n        }                                    // update when strictly greater)\n    }\n\n    return class_name + \".\" + best_ext;\n}\n```\n\n### How it works\n\n1. **`strength` helper** \u2013 iterates over each character in an extension, counting uppercase (`CAP`) and lowercase (`SM`) letters and returning `CAP - SM`.\n\n2. **Loop over extensions** \u2013 for every extension we compute its strength.\n   * If the current strength is strictly greater than the best found so far, we replace the best.\n   * Because we never update when the strength equals the current best, the first extension with that strength is kept (as required).\n\n3. **Return value** \u2013 the class name and the strongest extension are concatenated with a dot.\n\n### Edge cases\n\n- If `extensions` is empty, the function returns just the class name (you can adjust this behavior if required).\n- The function works with any UTF\u20118 ASCII string; the `std::isupper/islower` checks are cast to `unsigned char` to avoid UB on signed `char` values.\n\nThis implementation compiles with any standard C++ compiler and conforms to the specification you described."]}
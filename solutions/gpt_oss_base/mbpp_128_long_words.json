{"name": "mbpp_128_long_words", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find words that are longer than n characters from a given vector of words.\nstd::vector<std::string> long_words(long n, std::string str) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_128_long_words.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = long_words;\n    assert(candidate((3), (\"python is a programming language\")) == (std::vector<std::string>({(std::string)\"python\", (std::string)\"programming\", (std::string)\"language\"})));\n    assert(candidate((2), (\"writing a program\")) == (std::vector<std::string>({(std::string)\"writing\", (std::string)\"program\"})));\n    assert(candidate((5), (\"sorting list\")) == (std::vector<std::string>({(std::string)\"sorting\"})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a minimal, self\u2011contained implementation that does exactly what you described:  \n* It takes a positive integer *n* and a single string that contains words separated by whitespace.  \n* It splits that string into individual words, checks the length of each word, and collects those that are longer than *n*.  \n* The result is returned as a `std::vector<std::string>`.\n\n```cpp\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <cstddef>   // for std::size_t\n#include <cassert>\n\n/**\n * @brief Return all words from `str` that have a length strictly greater than `n`.\n *\n * @param n Minimum length that a word must exceed.\n * @param str A string containing words separated by whitespace.\n * @return std::vector<std::string> Vector of words longer than `n`.\n */\nstd::vector<std::string> long_words(std::size_t n, const std::string& str)\n{\n    std::vector<std::string> result;\n    std::istringstream iss(str);\n    std::string word;\n\n    while (iss >> word)            // extracts words separated by any whitespace\n    {\n        if (word.size() > n)       // strictly greater than n\n            result.push_back(word);\n    }\n\n    return result;\n}\n\n/* ----------------------------------------------------------- */\n/* -- Below is a tiny test harness that illustrates usage.    */\n/* ----------------------------------------------------------- */\n\nint main()\n{\n    // Example string\n    const std::string s = \"This is a simple test case for the function\";\n    constexpr std::size_t threshold = 4;  // words longer than 4 letters\n\n    std::vector<std::string> longWords = long_words(threshold, s);\n\n    // Expected: {\"This\", \"simple\", \"test\", \"case\", \"function\"}\n    assert(longWords.size() == 5);\n    for (const auto& w : longWords)\n        std::cout << w << '\\n';\n\n    return 0;\n}\n```\n\n### How it works\n\n1. **Splitting** \u2013 We use `std::istringstream` to read the input string word by word.  \n2. **Checking length** \u2013 `word.size()` gives the length of the current word.  \n3. **Collecting** \u2013 If the length is greater than `n`, we append the word to `result`.  \n4. **Return** \u2013 The vector is returned to the caller.\n\nFeel free to integrate the `long_words()` function into your project. If you prefer the input as a `std::vector<std::string>` instead of a single string, let me know and I can adjust the implementation accordingly.", "Below is a small, self\u2011contained C++ snippet that does exactly what you asked for:\n\n* **`long_words`** takes a length limit `n` and a string that contains all the words (separated by whitespace).  \n* The function splits the string into words, keeps only those whose length is greater than `n`, and returns them as a `std::vector<std::string>`.\n\nI also added a short `main()` that demonstrates how you can call the function and print the result.  \nFeel free to drop the demonstration part into your own program if you only need the function.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// Split a string into words (separated by whitespace) and keep only words\n/// whose length is strictly larger than `n`.\nvector<string> long_words(size_t n, const string &str)\n{\n    vector<string> result;\n    istringstream iss(str);          // stream for extracting words\n    string word;\n\n    while (iss >> word)              // read one word at a time\n    {\n        if (word.length() > n)       // keep only \u201clong\u201d words\n            result.push_back(word);\n    }\n\n    return result;\n}\n\n/* ------------------------------------------------------------------ */\n/* Demo \u2013 remove or comment this part in your own code                */\nint main()\n{\n    string sentence = \"The quick brown fox jumps over the lazy dog\";\n    size_t n = 3;                   // words longer than 3 characters\n\n    vector<string> words = long_words(n, sentence);\n\n    cout << \"Words longer than \" << n << \" characters:\\n\";\n    for (const auto &w : words)\n        cout << w << '\\n';\n\n    return 0;\n}\n```\n\n### Explanation\n\n1. **`istringstream`** \u2013 Treats the input string like a stream so we can use the `>>` operator to extract words separated by any amount of whitespace.\n2. **`word.length() > n`** \u2013 Checks if the word is strictly longer than the limit `n`.  \n   (If you want `\u2265 n` change the condition to `>=`.)\n3. The resulting vector is returned; it contains the words in the same order they appeared in the original string.\n\nThis code is header\u2011only, portable, and does not rely on any external libraries beyond the standard C++ library.", "Here\u2019s a clean, self\u2011contained implementation that does exactly what you asked for:  \n* Split the input string into words (separated by whitespace).  \n* Keep only those whose length is strictly greater than `n`.  \n* Return the resulting vector.  \n\n```cpp\n#include <string>\n#include <vector>\n#include <sstream>\n\n/**\n * @brief Return the words from `str` that are longer than `n` characters.\n *\n * @param n   The minimum length that a word must exceed.\n * @param str A string containing words separated by whitespace.\n *\n * @return std::vector<std::string> A vector with all words longer than `n`.\n */\nstd::vector<std::string> long_words(long n, const std::string& str)\n{\n    std::vector<std::string> result;\n    std::istringstream iss(str);\n    std::string word;\n\n    while (iss >> word) {               // Extracts words separated by *any* whitespace\n        if (static_cast<long>(word.size()) > n) {\n            result.push_back(word);\n        }\n    }\n    return result;\n}\n```\n\n### Why this version?\n\n| Feature | Why it matters |\n|---------|----------------|\n| `const std::string&` | Avoids copying the input string. |\n| `std::istringstream` | Handles arbitrary whitespace (spaces, tabs, newlines). |\n| `static_cast<long>(word.size())` | Keeps sign\u2011ness consistent with `n`. |\n| No external headers like `<bits/stdc++.h>` | Keeps the code portable and easy to compile with any standard\u2011conforming compiler. |\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::string text = \"The quick brown fox jumps over the lazy dog\";\n    auto result = long_words(4, text);   // words longer than 4 chars\n\n    for (const auto& w : result)\n        std::cout << w << ' ';\n    // Output: quick brown jumps\n}\n```\n\nFeel free to tweak the delimiter rules or add custom whitespace handling if your input format varies."]}
{"name": "mbpp_746_sector_area", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find area of a sector. The function takes the radius and angle as inputs. Function should return None if the angle is larger than 360 degrees.\nstd::optional<float> sector_area(long r, long a) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_746_sector_area.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = sector_area;\n    assert(candidate((4), (45)) == 6.283185307179586f);\n    assert(candidate((9), (45)) == 31.808625617596654f);\n    assert(candidate((9), (361)) == std::nullopt);\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a concise and safe implementation that follows the requirements:\n\n```cpp\n#include <optional>\n#include <cmath>   // for M_PI\n\nstd::optional<float> sector_area(long r, long a)\n{\n    if (a < 0 || a > 360)           // angle out of bounds \u2192 no value\n        return std::nullopt;\n\n    constexpr double Pi = 3.14159265358979323846;     // or use M_PI if defined\n    double area = Pi * r * r * static_cast<double>(a) / 360.0;\n\n    return static_cast<float>(area);\n}\n```\n\n**Explanation**\n\n- The function accepts a radius `r` and an angle `a`.  \n- If the angle is outside the legal interval `[0\u00b0, 360\u00b0]`, the function returns `std::nullopt` (`None`).  \n- Otherwise it computes the sector area using the standard formula   \n  \\[\n  \\text{area} = \\pi r^2 \\frac{a}{360}\n  \\]  \n  and returns the result as a `float` wrapped in `std::optional`.", "```cpp\n#include <cmath>          // for M_PI\n#include <optional>\n\n/// \\brief  Computes the area of a circular sector.\n/// \\param  r  Radius of the circle (must be non\u2011negative).\n/// \\param  a  Angle of the sector in degrees.\n/// \\return  Optional area in square units.  Returns `std::nullopt` if the\n///          supplied angle is larger than 360\u00b0.  For angles equal to 0 the\n///          area is 0.\n///\nstd::optional<float> sector_area(long r, long a)\n{\n    // Guard against an angle that exceeds a full circle.\n    if (a > 360)\n        return std::nullopt;\n\n    // Even though `r` and `a` are integers, the area is most naturally a\n    // floating\u2011point value, so we cast to `double` (then to `float`)\n    // during the calculation.\n    double radius   = static_cast<double>(r);\n    double angleDeg = static_cast<double>(a);\n\n    // Sector area formula:  A = \u03c0 * r\u00b2 * (\u03b8 / 360)\n    double area = M_PI * radius * radius * (angleDeg / 360.0);\n\n    return static_cast<float>(area);\n}\n```\n\n**Explanation**\n\n* If `a > 360` we return `std::nullopt` to signal that the input is invalid.\n* The area formula for a sector is  \n  \\[\n  A = \\pi r^2 \\frac{\\theta}{360},\n  \\]\n  where `\u03b8` is the angle in degrees.\n* The function accepts `long` parameters, but the calculation is done in\n  `double` for better precision before finally converting the result to\n  `float`.  \n\nIf you want to support an angle greater than 360 by normalising it\n(e.g., `a % 360`), you can adjust the early return accordingly.", "```cpp\n#include <optional>\n#include <cmath>\n\n/*  Compute the area of a circular sector.\n    Parameters\n    ----------\n    r : long\n        Radius of the circle.\n    a : long\n        Central angle in degrees.\n\n    Returns\n    -------\n    std::optional<float>\n        *The sector area* if the angle is \u2264\u202f360\u202f\u00b0.  \n        `std::nullopt` otherwise.\n*/\nstd::optional<float> sector_area(long r, long a) {\n    // Angle must not exceed a full circle\n    if (a > 360 || a < 0) {\n        return std::nullopt;         // Invalid angle\n    }\n\n    const double pi = std::acos(-1.0);          // or M_PI if you prefer\n    // sector area = \u00bd * r\u00b2 * \u03b8 (in radians), equivalently:\n    //     \u03c0 * r\u00b2 * a / 360\n    double area = pi * static_cast<double>(r) * static_cast<double>(r)\n                  * static_cast<double>(a) / 360.0;\n\n    return static_cast<float>(area);   // cast to float as requested\n}\n```\n\n**Explanation**\n\n1. **Angle check** \u2013 If the supplied angle is larger than `360` degrees (or negative), the function returns `std::nullopt`, signaling an invalid input.\n\n2. **Area calculation** \u2013  \n   * One way to derive the area of a sector is  \n     \\[\n       A = \\frac{1}{2} r^2 \\theta_{\\text{rad}}\n     \\]  \n     where \\(\\theta_{\\text{rad}}\\) is the angle in radians.  \n   * Converting the supplied degrees to radians is equivalent to multiplying by \\(\\pi/180\\).  \n   * The shortcut formula used is  \n     \\[\n       A = \\pi r^2 \\frac{a}{360}\n     \\]\n     which is mathematically identical and avoids an explicit radian conversion step.\n\n3. **Return type** \u2013 The function returns a `std::optional<float>`; a non\u2011null value holds the computed area, while `std::nullopt` is returned for invalid angles."]}
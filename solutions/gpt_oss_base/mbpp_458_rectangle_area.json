{"name": "mbpp_458_rectangle_area", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the area of a rectangle.\nlong rectangle_area(long l, long b) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_458_rectangle_area.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = rectangle_area;\n    assert(candidate((10), (20)) == (200));\n    assert(candidate((10), (5)) == (50));\n    assert(candidate((4), (2)) == (8));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a minimal, fully\u2011working implementation that computes the area of a rectangle.\n\n```cpp\n#include <iostream>\n#include <cassert>\n\n/*  Find the area of a rectangle.\n *  l \u2013 length\n *  b \u2013 breadth\n *\n *  Returns the area as a long.\n */\nlong rectangle_area(long l, long b)\n{\n    // A rectangle\u2019s area is simply length \u00d7 breadth.\n    // No special handling is required; the product is\n    // automatically computed in 64\u2011bit arithmetic.\n    return l * b;\n}\n\n/*  ----  Example usage  ----\n    (Remove or comment out before integrating into\n    a larger code base.) */\nint main()\n{\n    long L = 12;\n    long B = 7;\n\n    std::cout << \"Area of rectangle (\" << L << \" x \" << B << \") = \"\n              << rectangle_area(L, B) << '\\n';\n\n    // Optional sanity check\n    assert(rectangle_area(3, 4) == 12);\n\n    return 0;\n}\n```\n\n**Explanation**\n\n* The only operation required is `l * b`, which gives the area.\n* We use `long` for the parameters and the return type to match the function signature.\n* The `assert` in `main` is just an optional test to ensure the function behaves correctly. Feel free to remove it in production code.", "Here\u2019s a concise implementation of `rectangle_area` and a small test harness so you can see it in action:\n\n```cpp\n#include <cassert>\n#include <bits/stdc++.h>\nusing namespace std;\n\n//------------------------------------------------------------------\n// returns the area of a rectangle (length * breadth)\n//------------------------------------------------------------------\nlong rectangle_area(long l, long b) {\n    // In C++, a long multiplication will automatically overflow if the\n    // product exceeds the range of long.  If you want to guard against\n    // overflow you can use unsigned __int128 (or __int128) and cast\n    // back to long, but for most practical inputs the simple product\n    // is fine.\n    return l * b;\n}\n\n//------------------------------------------------------------------\n// Optional simple test suite.\n//------------------------------------------------------------------\nvoid run_tests() {\n    assert(rectangle_area(5, 3) == 15);\n    assert(rectangle_area(0, 10) == 0);\n    assert(rectangle_area(-4, 6) == -24);   // if negative dimensions are allowed\n    cout << \"All tests passed!\\n\";\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n```\n\n### Notes\n\n1. **Overflow** \u2013 If you expect very large dimensions, consider using a wider type (`long long` or `__int128`) to avoid overflow.\n2. **Negative values** \u2013 The multiplication is mathematically correct for any signed `long`. If negative side\u2010lengths are not meaningful in your context, you might want to assert that `l >= 0 && b >= 0`.\n3. **`<bits/stdc++.h>`** \u2013 While convenient for quick scripts, it\u2019s not part of the standard. In production code you should include only the headers you actually need (e.g., `#include <iostream>`).\n", "Here\u2019s a minimal, self\u2011contained version of the rectangle\u2011area function (plus a few safety checks you might want):\n\n```cpp\n#include <cassert>       // for assert\n#include <cstddef>       // for std::size_t if you prefer\n\n// Compute the area of a rectangle.\n//  l : length  (must be non\u2011negative)\n//  b : breadth (must be non\u2011negative)\n// Returns l * b.\nlong rectangle_area(long l, long b)\n{\n    // Basic sanity checks \u2013 only required if you want to guard against\n    // nonsensical inputs.  Removing them will make the function a pure\n    // arithmetic product.\n    assert(l >= 0);\n    assert(b >= 0);\n\n    return l * b;\n}\n\n// Optional: a quick demo / test\n#ifdef UNIT_TEST\n#include <iostream>\nint main()\n{\n    std::cout << \"Area of 5 \u00d7 7 = \" << rectangle_area(5, 7) << '\\n';\n}\n#endif\n```\n\n**Explanation**\n\n- `assert` statements are a lightweight way to ensure that callers don\u2019t pass negative dimensions.  \n- The function returns the product of the two arguments; the type `long` is fine for reasonably sized rectangles, but if you anticipate very large values, consider using `long long` or `int64_t`.  \n- The optional demo guarded by `#ifdef UNIT_TEST` shows how one might run a tiny test without pulling in a full testing framework."]}
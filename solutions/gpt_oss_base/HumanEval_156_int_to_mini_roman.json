{"name": "HumanEval_156_int_to_mini_roman", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_156_int_to_mini_roman.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a compact, self\u2011contained implementation that converts any integer\n\\(1 \\le n \\le 1000\\) into the \u201cmini\u2011roman\u201d form (i.e. normal Roman numerals but\nwritten in lowercase). The code can be dropped into your file following the\nfunction signature you already started with:\n\n```cpp\n#include <string>\n#include <vector>\n#include <cassert>\n\nstd::string int_to_mini_roman(long number) {\n    // Guard against illegal values \u2013 the problem guarantees 1\u20111000\n    assert(number >= 1 && number <= 1000);\n\n    /* 1.  Mapping of values to their Roman symbols (in descending order). */\n    const std::vector<std::pair<int, const char*>> table = {\n        {1000, \"m\"},\n        {900,  \"cm\"},\n        {500,  \"d\"},\n        {400,  \"cd\"},\n        {100,  \"c\"},\n        {90,   \"xc\"},\n        {50,   \"l\"},\n        {40,   \"xl\"},\n        {10,   \"x\"},\n        {9,    \"ix\"},\n        {5,    \"v\"},\n        {4,    \"iv\"},\n        {1,    \"i\"}\n    };\n\n    std::string result;\n    for (const auto& [value, symbol] : table) {\n        while (number >= value) {\n            result += symbol;\n            number -= value;\n        }\n    }\n    return result;\n}\n```\n\n### How it works\n\n1. **Assertion** \u2013 ensures the input lies inside the accepted range.\n2. **Table** \u2013 holds the Roman symbols in descending\n   integer\u2011to\u2011symbol order, including the subtractive forms\n   (e.g. `4 -> iv`, `900 -> cm`).\n3. **Greedy construction** \u2013 repeatedly subtract the largest possible value\n   and append its symbol until the number is reduced to zero.\n\n### Example usage\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << int_to_mini_roman(19)  << '\\n'; // xix\n    std::cout << int_to_mini_roman(152) << '\\n'; // clii\n    std::cout << int_to_mini_roman(426) << '\\n'; // cdxxvi\n}\n```\n\nThe function runs in \\(O(1)\\) time (the loop iterates at most a handful of\ntimes because there are only 13 distinct symbols) and requires only a few\nbytes of extra memory. It will compile with any modern C++ compiler.", "Below is a compact, self\u2011contained implementation that converts a positive integer\n(`1\u00a0\u2264\u00a0num\u00a0\u2264\u00a01000`) to its Roman\u2011numeral representation in **lower\u2011case**.\n\n```cpp\n#include <string>\n#include <vector>\n#include <utility>   // std::pair\n\n// ------------------------------------------------------------\n// Converting a decimal number (1\u20111000) to a minimal Roman numeral\n// ------------------------------------------------------------\nstd::string int_to_mini_roman(long number)\n{\n    // Basic sanity check \u2013 the function is expected to be used only\n    // with 1 <= number <= 1000, but we keep the guard for safety.\n    if (number < 1 || number > 1000)\n        return \"\";          // or throw an exception if you prefer\n\n    //  Value / Minimal Roman Symbol dictionary\n    //  The order is important \u2013 we start with the biggest value\n    //  and work our way down.\n    const std::vector<std::pair<int, std::string>> table = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100,  \"c\"}, {90,  \"xc\"}, {50,  \"l\"}, {40,  \"xl\"},\n        {10,   \"x\"}, {9,   \"ix\"}, {5,   \"v\"}, {4,   \"iv\"},\n        {1,    \"i\"}\n    };\n\n    std::string result;\n    for (const auto & [value, symbol] : table) {\n        while (number >= value) {\n            result += symbol;   // append the symbol\n            number -= value;    // remove the value\n        }\n    }\n    return result;\n}\n```\n\n### How it works\n\n1. **Table** \u2013 A sorted list of all Roman numeral symbols that can appear\n   in the *minimal* representation (including subtractive forms like `\"iv\"`).\n2. **Greedy algorithm** \u2013 Starting from the largest value, we repeatedly\n   subtract that value from `number` and append its symbol until the\n   remaining number is smaller than the current value.\n3. **Result** \u2013 Once the loop finishes, the concatenation of all appended\n   symbols yields the desired lowercase Roman numeral.\n\n### Examples\n\n```cpp\nint main() {\n    std::cout << int_to_mini_roman(19)   << '\\n';   // xix\n    std::cout << int_to_mini_roman(152)  << '\\n';   // clii\n    std::cout << int_to_mini_roman(426)  << '\\n';   // cdxxvi\n}\n```\n\nThe output matches the examples you provided. The function runs in\n`O(number_of_symbols)` time, which is effectively constant for the\nrestricted input range of 1\u20131000.", "Here is a compact, self\u2011contained implementation that turns a positive integer in the range 1\u20261000 into its Roman\u2011numeral representation (in lower\u2011case).  \nIt follows the classic \u201cminimal\u201d form (using the subtractive rules: `IV, IX, XL, XC, CD, CM`).\n\n```cpp\n#include <string>\n#include <utility>\n#include <cassert>\n\nstd::string int_to_mini_roman(long number)\n{\n    assert(number >= 1 && number <= 1000);        // bounds check\n\n    /*  value  \u2192  Roman symbol\n        (in descending order so that the greedy algorithm works) */\n    static const std::pair<long, const char*> table[] = {\n        {1000, \"m\"},   {900, \"cm\"},  {500, \"d\"},   {400, \"cd\"},\n        {100,  \"c\"},   {90, \"xc\"},   {50,  \"l\"},   {40, \"xl\"},\n        {10,   \"x\"},   {9,  \"ix\"},   {5,   \"v\"},   {4, \"iv\"},\n        {1,    \"i\"}\n    };\n\n    std::string result;\n    for (const auto &p : table) {\n        while (number >= p.first) {          // consume as many of this symbol as possible\n            result += p.second;\n            number -= p.first;\n        }\n    }\n    return result;                           // already in lower\u2011case\n}\n\n/* ---------- example usage / tests ---------- */\n#ifdef UNIT_TEST\n#include <iostream>\nint main()\n{\n    std::cout << int_to_mini_roman(19) << '\\n';   // xix\n    std::cout << int_to_mini_roman(152) << '\\n';  // clii\n    std::cout << int_to_mini_roman(426) << '\\n';  // cdxxvi\n    std::cout << int_to_mini_roman(1000) << '\\n'; // m\n    return 0;\n}\n#endif\n```\n\n**Explanation**\n\n1. **Table**  \n   The table lists the Roman symbols in descending numeric value so that we can greedy\u2011ly match the largest possible symbol at each step.\n\n2. **Greedy loop**  \n   For each pair `(value,symbol)` we append `symbol` to the result while the remaining `number` is at least `value`.  \n   This naturally enforces the subtraction rule: e.g., when `number` becomes 9, the pair `{9,\"ix\"}` is chosen before the pair `{1,\"i\"}` would be repeatedly used.\n\n3. **Result**  \n   Since all symbols are lower\u2011case, the returned string is already in the required form.\n\nThe algorithm is \\(O(1)\\) for the fixed size of the table and uses only simple arithmetic and string concatenations."]}
{"name": "HumanEval_13_greatest_common_divisor", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_13_greatest_common_divisor.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = greatest_common_divisor;\n    assert(candidate((3), (7)) == (1));\n    assert(candidate((10), (15)) == (5));\n    assert(candidate((49), (14)) == (7));\n    assert(candidate((144), (60)) == (12));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a robust implementation of the Euclidean algorithm that works for any two signed `long` integers (including negative values and zero). It also follows your existing style and keeps the code short and clear.\n\n```cpp\n#include <cassert>\n#include <bits/stdc++.h>\n\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n    // Make the arguments non\u2011negative \u2013 the GCD is the same for negatives\n    a = std::llabs(a);\n    b = std::llabs(b);\n\n    // Handle the base case immediately \u2013 makes the loop simpler\n    if (a == 0) return b;\n    if (b == 0) return a;\n\n    // Classic Euclidean algorithm (iterative, O(log\u202fmin(a,b)))\n    while (b != 0) {\n        long r = a % b;   // remainder of a divided by b\n        a = b;\n        b = r;\n    }\n    return a;          // a is now the greatest common divisor\n}\n```\n\n### Why this implementation works\n\n| Step | Reason |\n|------|--------|\n| `std::llabs` | Converting to absolute values means we don\u2019t have to worry about negative inputs \u2013 the GCD of \\(-a\\) and \\(b\\) is the same as that of \\(a\\) and \\(b\\). |\n| Base cases (`a == 0` or `b == 0`) | These handle the degenerate cases where one number is zero. The GCD with zero is the other number. |\n| Iterative loop | The Euclidean algorithm repeatedly replaces the pair `(a, b)` by `(b, a % b)`. Each iteration strictly decreases the second argument, guaranteeing termination. The loop stops when `b` becomes zero; at that point `a` is the GCD. |\n| Return statement | When the loop finishes, the remaining non\u2011zero `a` is the greatest common divisor. |\n\n### Unit\u2011style tests\n\n```cpp\nint main() {\n    assert(greatest_common_divisor(3, 5) == 1);\n    assert(greatest_common_divisor(25, 15) == 5);\n    assert(greatest_common_divisor(0, 7) == 7);\n    assert(greatest_common_divisor(0, 0) == 0);\n    assert(greatest_common_divisor(-8, 12) == 4);\n    return 0;\n}\n```\n\nYou can compile this with:\n\n```bash\ng++ -std=c++17 -Wall -Wextra -O2 -pipe -static -s -o gcd gcd.cpp && ./gcd\n```\n\nAll assertions should pass, confirming that the function behaves correctly for the examples and edge cases.", "Below is a complete, minimal implementation of a greatest\u2011common\u2011divisor (GCD) routine in C++.  \nI kept the template you started and only added the actual algorithm.  \nFeel free to drop this into your file or use it as a reference.\n\n```cpp\n#include <assert.h>\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// 1\n// >>> greatest_common_divisor((25), (15))\n// 5\nlong greatest_common_divisor(long a, long b) {\n    // Make sure we work with non\u2011negative numbers \u2013 GCD is defined for |a|,|b|\n    a = llabs(a);\n    b = llabs(b);\n\n    // Euclid's algorithm \u2013 faster than the naive O(min(a,b)) method\n    while (b != 0) {\n        long r = a % b;   // remainder\n        a = b;\n        b = r;\n    }\n    return a;            // when b is 0, a holds the GCD\n}\n\n// Simple tests \u2013 you can run the program to verify\nint main() {\n    assert(greatest_common_divisor(3, 5) == 1);\n    assert(greatest_common_divisor(25, 15) == 5);\n    assert(greatest_common_divisor(0, 0) == 0);   // convention\n    assert(greatest_common_divisor(-12, 18) == 6); // negative inputs\n    cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\n### Explanation\n1. **Absolute values**: GCD is always non\u2011negative, so we take the absolute value of each argument.\n2. **Euclid\u2019s algorithm**: Iteratively replace `(a, b)` with `(b, a % b)`.  \n   When `b` becomes `0`, `a` is the greatest common divisor.\n3. **Special case `(0,0)`**: The algorithm returns 0; this is a common convention though mathematically undefined.\n4. **Testing**: A few simple assertions demonstrate correctness.\n\nFeel free to adapt this outline to your needs!", "Here is a clean, self\u2011contained implementation of the Euclidean algorithm that works for all\n`long` values (positive, negative, or zero).  \nWe keep the numbers non\u2011negative (the gcd is always non\u2011negative) and repeatedly replace\nthe larger number by the remainder until the remainder is zero.\n\n```cpp\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))   // 1\n// >>> greatest_common_divisor((25), (15)) // 5\nlong greatest_common_divisor(long a, long b) {\n    // Make sure both arguments are non\u2011negative\n    a = llabs(a);\n    b = llabs(b);\n\n    // Special cases: if either is zero, the gcd is the absolute value of the other\n    if (a == 0) return b;\n    if (b == 0) return a;\n\n    // Euclidean algorithm\n    while (b != 0) {\n        long tmp = b;\n        b = a % b;\n        a = tmp;\n    }\n    return a;\n}\n```\n\n**Explanation**\n\n1. **Absolute values** \u2013 `llabs` guarantees we work with positive values; the gcd\n   of two numbers is always positive.\n2. **Zero handling** \u2013 If one of the arguments is zero, the gcd is the absolute\n   value of the other (keeping in mind that `gcd(0,0)` is conventionally `0` in many\n   contexts, and this implementation returns `0` in that case).\n3. **Loop** \u2013 While the remainder is non\u2011zero, we swap `a` and `b` and update\n   `b` to `a % b`. When the loop ends, `a` holds the gcd.\n\nYou can use this function directly in your program or add it to the header file where\nthe function prototype is declared."]}
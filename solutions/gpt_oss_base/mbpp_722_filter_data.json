{"name": "mbpp_722_filter_data", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// The input is given as - a map with a student name as a key and a tuple of float (student_height, student_weight) as a value, - minimal height, - minimal weight. Write a function to filter students that have height and weight above the minimum.\nstd::map<std::string,std::tuple<float, long>> filter_data(std::map<std::string,std::tuple<float, long>> students, float h, long w) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_722_filter_data.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = filter_data;\n    assert(candidate((std::map<std::string,std::tuple<float, long>>({{\"Cierra Vega\", std::make_tuple(6.2f, 70)}, {\"Alden Cantrell\", std::make_tuple(5.9f, 65)}, {\"Kierra Gentry\", std::make_tuple(6.0f, 68)}, {\"Pierre Cox\", std::make_tuple(5.8f, 66)}})), (6.0f), (70)) == (std::map<std::string,std::tuple<float, long>>({{\"Cierra Vega\", std::make_tuple(6.2f, 70)}})));\n    assert(candidate((std::map<std::string,std::tuple<float, long>>({{\"Cierra Vega\", std::make_tuple(6.2f, 70)}, {\"Alden Cantrell\", std::make_tuple(5.9f, 65)}, {\"Kierra Gentry\", std::make_tuple(6.0f, 68)}, {\"Pierre Cox\", std::make_tuple(5.8f, 66)}})), (5.9f), (67)) == (std::map<std::string,std::tuple<float, long>>({{\"Cierra Vega\", std::make_tuple(6.2f, 70)}, {\"Kierra Gentry\", std::make_tuple(6.0f, 68)}})));\n    assert(candidate((std::map<std::string,std::tuple<float, long>>({{\"Cierra Vega\", std::make_tuple(6.2f, 70)}, {\"Alden Cantrell\", std::make_tuple(5.9f, 65)}, {\"Kierra Gentry\", std::make_tuple(6.0f, 68)}, {\"Pierre Cox\", std::make_tuple(5.8f, 66)}})), (5.7f), (64)) == (std::map<std::string,std::tuple<float, long>>({{\"Cierra Vega\", std::make_tuple(6.2f, 70)}, {\"Alden Cantrell\", std::make_tuple(5.9f, 65)}, {\"Kierra Gentry\", std::make_tuple(6.0f, 68)}, {\"Pierre Cox\", std::make_tuple(5.8f, 66)}})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a small, self\u2011contained implementation that does exactly what you described:\n\n```cpp\n#include <string>\n#include <tuple>\n#include <map>\n\n/**\n * @brief  Filters the input map and keeps only students whose height and weight\n *         are **strictly** greater than the given minimums.\n *\n * @param students   Map of <student\u2011name, <height, weight>>\n * @param h          Minimum height that a student must exceed\n * @param w          Minimum weight that a student must exceed\n *\n * @return A new map that contains only the entries that satisfy the\n *         filtering criteria.  The original map is left untouched.\n */\nstd::map<std::string, std::tuple<float, long>>\nfilter_data(const std::map<std::string, std::tuple<float, long>>& students,\n            float h, long w)\n{\n    std::map<std::string, std::tuple<float, long>> result;\n\n    for (const auto& [name, hw] : students) {\n        const float height  = std::get<0>(hw);\n        const long  weight  = std::get<1>(hw);\n\n        if (height > h && weight > w) {\n            result.emplace(name, hw);\n        }\n    }\n\n    return result;\n}\n```\n\n### Explanation\n\n* **Pass by `const&`** \u2013 The input `students` map is not modified, so it is passed as a constant reference.  \n* **Range\u2011based for loop (structured binding)** \u2013 Uses C++17 structured bindings (`[name, hw]`) to iterate over map entries cleanly.  \n* **`std::get`** \u2013 Extracts the height and weight from the tuple.  \n* **Strictly greater\u2011than comparison** \u2013 The condition `height > h && weight > w` keeps students only if both attributes exceed the minimum.  \n* **`emplace`** \u2013 Inserts the qualifying entry into the result map efficiently.\n\nFeel free to adapt the comparison (`>=` instead of `>`) or the return type if your specific requirements differ.", "Here is a complete, self\u2011contained implementation of the required function:\n\n```cpp\n#include <map>\n#include <string>\n#include <tuple>\n#include <cstddef>   // for std::size_t\n\n//---------------------------------------------------------------------\n// filter_data\n//\n// Receives:\n//   - `students` \u2013 a map whose key is the student name and whose\n//     value is a pair (height, weight).  Height is a float, weight\n//     is a long.\n//   - `h`          \u2013 minimal height threshold\n//   - `w`          \u2013 minimal weight threshold\n//\n// Returns:\n//   A new map that contains only those students whose height > h\n//   **and** whose weight > w.\n//\n//---------------------------------------------------------------------\nstd::map<std::string, std::tuple<float, long>>\nfilter_data(const std::map<std::string, std::tuple<float, long>>& students,\n            float h,\n            long  w)\n{\n    std::map<std::string, std::tuple<float, long>> result;\n\n    for (const auto& [name, stats] : students)\n    {\n        float height = std::get<0>(stats);\n        long  weight = std::get<1>(stats);\n\n        if (height > h && weight > w)\n        {\n            result.emplace(name, stats);\n        }\n    }\n\n    return result;\n}\n```\n\n### Notes\n\n* The function receives `students` **by reference** (`const &`) to avoid an unnecessary copy of the input map.\n* The pair of `(height, weight)` is stored as a `std::tuple<float, long>`, which matches the input signature.\n* The comparison uses `>` to satisfy \u201cabove the minimum\u201d; change to `>=` if you want to allow equal values.\n* After filtering, the function returns the new map. No side\u2011effects are left on the original dataset.", "Here\u2019s a minimal, self\u2011contained implementation that fulfils the requirement:\n\n```cpp\n/*  filter_data.cpp  ------------------------------------------------------\n *\n *  Filters a map of students by minimum height and weight.\n *\n *  Input:\n *      students \u2013 map where key = student name, value = {height, weight}\n *      h        \u2013 minimum height (float)\n *      w        \u2013 minimum weight (long)\n *\n *  Output:\n *      A new map containing only the students whose height and weight are\n *      both strictly greater than the supplied thresholds.\n *\n *  Author:  <your name>\n *  Date:    2026\u201101\u201127\n *--------------------------------------------------------------------------*/\n\n#include <map>\n#include <string>\n#include <tuple>\n#include <iostream>   // For demo only (remove when using in a library)\n#include <cassert>    // Only for \u201cdebug\u201d checks\n\n// -------------------------------------------------------------------------\n//  filter_data\n// -------------------------------------------------------------------------\nstd::map<std::string,std::tuple<float, long>>\nfilter_data(const std::map<std::string,std::tuple<float, long>>& students,\n            float h,\n            long w)\n{\n    std::map<std::string,std::tuple<float, long>> result;\n    for (const auto& [name, data] : students)\n    {\n        // Unpack the tuple\n        const float &height = std::get<0>(data);\n        const long  &weight = std::get<1>(data);\n\n        // Keep the student only if BOTH height AND weight exceed the limits\n        if (height > h && weight > w)\n        {\n            result.emplace(name, data);\n        }\n    }\n    return result;\n}\n\n// -------------------------------------------------------------------------\n//  Demo / test harness \u2013 remove or comment out in production code\n// -------------------------------------------------------------------------\n#ifdef DEMO_FILTER_DATA\nint main()\n{\n    std::map<std::string, std::tuple<float, long>> students = {\n        {\"Alice\",   std::make_tuple(165.2f, 50)},\n        {\"Bob\",     std::make_tuple(180.0f, 70)},\n        {\"Charlie\", std::make_tuple(150.0f, 80)},\n        {\"Diana\",   std::make_tuple(170.5f, 60)}\n    };\n\n    float minHeight = 160.0f;\n    long  minWeight = 55;\n\n    auto filtered = filter_data(students, minHeight, minWeight);\n\n    std::cout << \"Students above \" << minHeight << \" cm and \" << minWeight << \" kg:\\n\";\n    for (const auto& [name, data] : filtered)\n    {\n        std::cout << \"  \" << name\n                  << \" \u2013 Height: \" << std::get<0>(data)\n                  << \" cm, Weight: \" << std::get<1>(data)\n                  << \" kg\\n\";\n    }\n\n    // Simple sanity check\n    assert(filtered.size() == 2);   // Bob and Diana satisfy the condition\n    return 0;\n}\n#endif\n```\n\n### How to use it\n\n1. **Include the file** (or copy the function into your own code).\n2. **Call `filter_data`** with the student\u2011map, the minimum height, and the minimum weight.\n\n```cpp\nauto good_students = filter_data(all_students, 160.0f, 55);\n```\n\nThe function takes the source map by *const reference* to avoid unnecessary copies and returns a **new** map containing only the qualifying entries.  \nIf you need the function to modify the map in place instead, you could change its signature to return `void` and erase the non\u2011qualifying elements directly."]}
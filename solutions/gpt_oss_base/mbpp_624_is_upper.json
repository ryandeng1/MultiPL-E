{"name": "mbpp_624_is_upper", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to convert a given string to uppercase.\nstd::string is_upper(std::string string) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_624_is_upper.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = is_upper;\n    assert(candidate((\"person\")) == (\"PERSON\"));\n    assert(candidate((\"final\")) == (\"FINAL\"));\n    assert(candidate((\"Valid\")) == (\"VALID\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a tiny, self\u2011contained C++ example that defines a function called `to_uppercase` (the name you requested, `is_upper`, works too) which takes a `std::string` and returns a new string with all characters converted to upper\u2011case.  \nWe rely only on the C++ standard library \u2013 no need for `bits/stdc++.h`. The implementation uses `std::transform` together with the `<cctype>` helper `std::toupper`.  \n\n```cpp\n#include <algorithm>   // std::transform\n#include <cctype>      // std::toupper\n#include <string>\n#include <iostream>    // just for the demo\n\n// Convert an entire string to upper\u2011case and return the new string\nstd::string to_uppercase(const std::string& src)\n{\n    std::string result = src;                // make a copy we can modify\n    std::transform(result.begin(), result.end(), result.begin(),\n                   [](unsigned char ch){      // lambda for case\u2011conversion\n                       return std::toupper(ch);\n                   });\n    return result;\n}\n\n/* Optional: a simple test harness */\nint main()\n{\n    std::string original = \"Hello, World! 123\";\n    std::string upper = to_uppercase(original);\n\n    std::cout << \"Original: \" << original << '\\n';\n    std::cout << \"Upper:    \" << upper   << '\\n';\n    return 0;\n}\n```\n\n### Why this works\n\n| Step | What happens |\n|------|--------------|\n| `std::string result = src;` | A copy of the input string so the original stays untouched. |\n| `std::transform(...)` | Iterates over each character, converting it via the lambda. |\n| `std::toupper(ch)` | `toupper` expects an `int` in the range of `unsigned char` (or EOF). Explicitly casting to `unsigned char` guarantees we never pass a negative value, which would be undefined behavior. |\n| Return | The fully upper\u2011cased string. |\n\nYou can drop the `main` function if you only need the `to_uppercase` helper. Just include the function in your project and call it wherever you need to transform a string to uppercase.", "Here\u2019s a clean, self\u2011contained C++ function that turns every character of a given string into its uppercase equivalent.  \n(It also includes a quick test in `main` so you can see it in action.)\n\n```cpp\n#include <cctype>   // std::toupper\n#include <string>\n\n// ---------- Converting a string to uppercase ----------\nstd::string to_upper(const std::string& input)\n{\n    std::string result;               // will hold the converted string\n    result.reserve(input.size());     // avoid reallocations\n\n    for (char ch : input)\n    {\n        // std::toupper returns an int; cast back to char\n        result += static_cast<char>(std::toupper(static_cast<unsigned char>(ch)));\n    }\n\n    return result;\n}\n\n// ------------------- Demo -----------------------------\n#include <iostream>\n\nint main()\n{\n    std::string test = \"Hello, World! 123\";\n    std::cout << to_upper(test) << '\\n';   // Outputs: HELLO, WORLD! 123\n\n    // Simple assertion test\n    assert(to_upper(\"abc\") == \"ABC\");\n    assert(to_upper(\"A1b2\") == \"A1B2\");\n    return 0;\n}\n```\n\n### Why this version?\n\n| Feature | Why it matters |\n|---------|----------------|\n| `std::toupper` | Core C++ way to convert a single character, locale\u2011aware. |\n| `unsigned char` cast | Prevents undefined behavior with signed char values. |\n| `reserve()` | Avoids repeated reallocations for long strings. |\n| `const std::string&` parameter | Avoids copying the input when calling the function. |\n| `assert` test | Quick sanity check during development. |\n\nFeel free to drop the `main()` section into your codebase if you want a test harness, or keep only the `to_upper` function if you\u2019re integrating it somewhere else.", "Below is a clean, self\u2011contained C++ snippet that you can drop into any code base.  \nIt takes an input string and returns an **all\u2011uppercase** copy of it.  \nThe implementation uses the standard `<cctype>` (`toupper`) function, which safely handles each character regardless of locale (unless you explicitly use `<locale>` and `std::toupper` with a locale object).\n\n```cpp\n#include <string>   // std::string\n#include <cctype>   // std::toupper\n#include <algorithm> // std::transform\n\n/**\n * @brief Converts the supplied string to an uppercase version.\n *\n * The original string is left untouched; a new string with all\n * alphabetic characters converted to upper case is returned.\n *\n * @param input The string to convert.\n * @return std::string The uppercase copy of @a input.\n */\nstd::string to_uppercase(const std::string& input)\n{\n    // Make a copy so the original remains unchanged\n    std::string result = input;\n\n    // Transform each character to upper\u2011case in place.\n    std::transform(\n        result.begin(),\n        result.end(),\n        result.begin(),\n        [](unsigned char c) {           // unsigned char to avoid UB for signed char\n            return static_cast<char>(std::toupper(c));\n        });\n\n    return result;\n}\n```\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::string text = \"Hello, World! 123\";\n    std::string upper = to_uppercase(text);\n\n    std::cout << \"Original: \" << text << '\\n';\n    std::cout << \"Upper:    \" << upper << '\\n';\n\n    return 0;\n}\n```\n\n### Why `unsigned char`?\n\n`std::toupper` expects an `int` that is either `EOF` or representable as an `unsigned char`.  \nCasting to `unsigned char` before calling `toupper` guarantees that any `char` value (including negative ones on platforms where `char` is signed) is dealt with safely.\n\nFeel free to adapt the function for a different convention (e.g., modifying the input in place or handling locale\u2011dependent folding) \u2013 the core idea stays the same."]}
{"name": "mbpp_426_filter_oddnumbers", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to filter odd numbers.\nstd::vector<long> filter_oddnumbers(std::vector<long> nums) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_426_filter_oddnumbers.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = filter_oddnumbers;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10}))) == (std::vector<long>({(long)1, (long)3, (long)5, (long)7, (long)9})));\n    assert(candidate((std::vector<long>({(long)10, (long)20, (long)45, (long)67, (long)84, (long)93}))) == (std::vector<long>({(long)45, (long)67, (long)93})));\n    assert(candidate((std::vector<long>({(long)5, (long)7, (long)9, (long)8, (long)6, (long)4, (long)3}))) == (std::vector<long>({(long)5, (long)7, (long)9, (long)3})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a very small, self\u2011contained implementation that filters out the odd numbers from a `std::vector<long>` and returns a new vector containing only those elements.  \nThe implementation is intentionally clean and uses only the standard library \u2013 no need for anything beyond `<vector>`, `<algorithm>`, or `<cstddef>`.\n\n```cpp\n#include <vector>\n#include <algorithm>   // for std::copy_if\n\n// -----------------------------------------------------------------------------\n// filter_oddnumbers\n//\n//   Parameters:\n//     nums \u2013 a vector of long integers (input)\n//   Returns:\n//     a vector containing only the odd numbers from *nums*\n//\ninline std::vector<long> filter_oddnumbers(const std::vector<long>& nums)\n{\n    // reserve enough space to avoid repeated reallocations\n    std::vector<long> odds;\n    odds.reserve(nums.size());         // worst\u2011case size\n\n    // copy only the odd numbers\n    std::copy_if(nums.begin(), nums.end(),\n                 std::back_inserter(odds),\n                 [](long x){ return (x & 1LL) != 0; });\n\n    return odds;\n}\n```\n\n### Why this implementation?\n| Feature | Explanation |\n|---------|-------------|\n| **`inline`** | Makes the function a candidate for header\u2011only usage. |\n| **`const std::vector<long>&`** | Avoids an unnecessary copy of the input. |\n| **`reserve(nums.size())`** | In the worst case (all numbers odd) no extra memory reallocations occur. |\n| **`std::copy_if`** | Very readable, uses a lambda that checks the least\u2011significant bit (`x & 1`) \u2013 a fast test for oddness. |\n\n### Usage Example\n\n```cpp\nint main()\n{\n    std::vector<long> v{1, 2, 3, 4, 5, 6, 7};\n    std::vector<long> odds = filter_oddnumbers(v);\n\n    for (auto n : odds)\n        std::cout << n << ' ';   // prints: 1 3 5 7\n\n    return 0;\n}\n```\n\nFeel free to drop the function into your codebase or adapt it to other numeric types if needed.", "Here\u2019s a simple, self\u2011contained implementation of the `filter_oddnumbers` function that extracts all odd numbers from an input vector.  \nWe include minimal headers, keep the style minimal, and add a small demo (commented out) so you can see how it\u2019s intended to be used.\n\n```cpp\n#include <vector>\n#include <cstddef>   // for std::size_t\n\n// -----------------------------------------------------------------------------\n//  filter_oddnumbers\n// -----------------------------------------------------------------------------\n/**\n * @brief   Return a new vector containing only the odd elements of @p nums.\n *\n * @param   nums   Input vector of integers (signed or unsigned).\n *\n * @return  Vector containing the elements of @p nums that are odd.\n *\n * @note    The function preserves the original ordering of the odd elements.\n *          It does not modify the input vector.\n *\n * @example\n * std::vector<long> v{1,2,3,4,5};\n * std::vector<long> odds = filter_oddnumbers(v);   // odds == {1,3,5}\n */\nstd::vector<long> filter_oddnumbers(const std::vector<long>& nums)\n{\n    std::vector<long> odds;\n    odds.reserve(nums.size());   // worst\u2011case allocation (optional)\n\n    for (long n : nums) {\n        if (n % 2 != 0) {               // n is odd\n            odds.push_back(n);\n        }\n    }\n    return odds;\n}\n\n// -----------------------------------------------------------------------------\n//  (Optional) Demo / basic test\n// -----------------------------------------------------------------------------\n/*\nint main() {\n    std::vector<long> numbers{10, 15, 22, 33, 44, 55, 60};\n    std::vector<long> odd = filter_oddnumbers(numbers);\n\n    for (long n : odd) {\n        std::cout << n << ' ';\n    }\n    // Expected output: 15 33 55\n    return 0;\n}\n*/\n\n```\n\n### How it works\n\n1. **Input** \u2013 The function accepts a constant reference to avoid copying the input vector.  \n2. **Reserve** \u2013 We call `reserve` with the original size for an upper bound \u2013 this keeps the memory allocation cost low even if all numbers are odd.  \n3. **Loop** \u2013 Each element is tested using `n % 2 != 0`.  \n4. **Collect** \u2013 Odd numbers are appended to the result vector.  \n5. **Return** \u2013 The collected vector is returned.\n\nFeel free to adapt the type (`long`, `int`, `int64_t`, etc.) or add overloads (e.g., accepting other container types) as needed!", "Below is a minimal, self\u2011contained implementation that simply returns a new vector containing **only the odd numbers** from the input.  \nIf you prefer the opposite behaviour (i.e., *filter the odds out* and keep the even numbers), just replace the `if`\u2011condition with `if (num % 2 == 0)`.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// Return a vector that contains only the odd numbers from the\n/// original vector `nums` .\nstd::vector<long> filter_oddnumbers(const std::vector<long>& nums) {\n    std::vector<long> odds;\n    odds.reserve(nums.size());          // pre\u2011allocate to avoid many reallocations\n\n    for (const auto& num : nums) {\n        if (num % 2 != 0) {             // keep the odd numbers\n            odds.push_back(num);\n        }\n    }\n    return odds;\n}\n```\n\n### Quick sanity\u2011check\n\n```cpp\nint main() {\n    std::vector<long> v{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    auto odds = filter_oddnumbers(v);\n\n    for (long n : odds) {\n        std::cout << n << ' ';\n    }\n    // Expected output: 1 3 5 7 9\n}\n```\n\nThe function works in `O(n)` time and uses `O(k)` additional space, where `k` is the number of odd elements in the input."]}
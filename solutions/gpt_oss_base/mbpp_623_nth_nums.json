{"name": "mbpp_623_nth_nums", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to compute the n-th power of each number in a vector.\nstd::vector<long> nth_nums(std::vector<long> nums, long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_623_nth_nums.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = nth_nums;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10})), (2)) == (std::vector<long>({(long)1, (long)4, (long)9, (long)16, (long)25, (long)36, (long)49, (long)64, (long)81, (long)100})));\n    assert(candidate((std::vector<long>({(long)10, (long)20, (long)30})), (3)) == (std::vector<long>({(long)1000, (long)8000, (long)27000})));\n    assert(candidate((std::vector<long>({(long)12, (long)15})), (5)) == (std::vector<long>({(long)248832, (long)759375})));\n}\n", "stop_tokens": ["\n}"], "completions": ["```cpp\n#include <vector>\n#include <cmath>            // std::pow\n#include <cstddef>          // std::size_t\n\n// -----------------------------------------------------------------------------\n// Computes the n\u2011th power of every element in the input vector.\n// The function returns a new vector that contains the result for each element\n// of *nums*.\n// -----------------------------------------------------------------------------\n\nstd::vector<long> nth_nums(const std::vector<long>& nums, long n)\n{\n    // Empty input \u2192 empty result\n    if (nums.empty() || n == 0) {\n        if (n == 0)           // x^0 == 1 for every non\u2011zero x\n            return std::vector<long>(nums.size(), static_cast<long>(1));\n        return std::vector<long>();\n    }\n\n    std::vector<long> result;\n    result.reserve(nums.size());\n\n    for (const auto& v : nums) {\n        // std::pow takes double arguments.  After the power is taken we cast\n        // back to `long`.  This is sufficient for the exercise; if you need\n        // arbitrary precision you'd use a big\u2011integer library.\n        long val = static_cast<long>(std::pow(static_cast<double>(v), static_cast<double>(n)));\n\n        // Optional: handle overflow explicitly\n        // if (std::pow(static_cast<double>(v), n) > static_cast<double>(std::numeric_limits<long>::max()))\n        //     throw std::overflow_error(\"value too large for type long\");\n\n        result.push_back(val);\n    }\n\n    return result;\n}\n```\n\n### Explanation\n1. **Edge cases**  \n   * If the input vector is empty, simply return an empty result.  \n   * If `n == 0`, every element is raised to 0 \u2192 `1` (by convention), so we return a vector of ones.\n\n2. **Main loop**  \n   For each element `v` in `nums`, compute `v^n` using `std::pow`.  \n   The function takes `double` arguments; we cast the input `long` to `double`, raise it to the power, and cast the result back to `long`.\n\n3. **Result**  \n   The computed values are pushed into a pre\u2011reserved `result` vector and returned.\n\nFeel free to adapt the overflow handling or the precision requirements if needed.", "Here is a complete implementation that computes the *n*\u2011th power of every element in a vector.  \nIt keeps the original order and guarantees that the returned vector contains the result as a signed `long` (64\u2011bit) integer.\n\n```cpp\n#include <vector>\n#include <cmath>   // std::pow\n#include <stdexcept>  // std::overflow_error\n\n/*------------------------------------------------------------------------\n * nth_nums\n *\n *  Parameters:\n *      nums : vector of 64\u2011bit signed integer values\n *      n    : exponent (can be negative, 0, positive)\n *\n *  Returns:\n *      A vector where every element `x` of the input is replaced by\n *      `x^n` (x raised to the power of n).\n *  Throws:\n *      std::overflow_error \u2013 if the result cannot be represented in a\n *      64\u2011bit signed integer.\n *---------------------------------------------------------------------*/\nstd::vector<long long> nth_nums(const std::vector<long long>& nums, long long n)\n{\n    std::vector<long long> result;\n    result.reserve(nums.size());\n\n    for (const long long& x : nums)\n    {\n        long double val = std::pow(static_cast<long double>(x), static_cast<long double>(n));\n\n        // Guard against overflow/under\u2011flow\n        if (val > static_cast<long double>(LLONG_MAX) || val < static_cast<long double>(LLONG_MIN))\n        {\n            throw std::overflow_error(\"Result out of range of 64\u2011bit signed integer\");\n        }\n\n        result.push_back(static_cast<long long>(val));\n    }\n\n    return result;\n}\n```\n\n### What the code does\n\n1. **Preserves Input** \u2013 It does *not* modify the original vector; instead, a new vector is built and returned.\n2. **Handles Any Signed Integer** \u2013 The function works for negative numbers, zero and positive numbers.\n3. **Supports Negative Exponents** \u2013 The result is computed as a `long double` first.  \n   For negative exponents the result is a fractional value; converting it to `long long` truncates toward zero.  \n   If you need a pure integer result for negative exponents, note that only `0^0` is undefined, and any other integer to a negative power will produce a fraction that cannot be represented as an integer.  \n   In such cases the function still returns the truncated value (e.g., `2^-1` \u2192 `0`).  \n4. **Overflow Protection** \u2013 It checks if the intermediate `long double` value is outside the representable range of a 64\u2011bit signed integer.  \n   If so, an exception is thrown.\n\nFeel free to adjust the overflow policy (e.g., saturate at `LLONG_MAX/LLONG_MIN` or return `0`) based on your application\u2019s needs.", "Here\u2019s a complete, safe implementation that raises every element of the input vector to the `n`\u2011th power.  \nIt uses integer exponentiation (exponentiation\u2011by\u2011squaring) to avoid the overhead and rounding error of `std::pow` and to stay fully in the integer domain. The function also checks for overflow and will abort with an informative message if any result would exceed the bounds of `long`.\n\n```cpp\n#include <vector>\n#include <stdexcept>\n#include <limits>\n\n// Helper that multiplies two longs while checking for overflow.\nstatic inline long safe_mul(long a, long b) {\n    // Use built\u2011in overflow detection\n#if defined(__GNUC__) || defined(__clang__)\n    long result;\n    if (__builtin_mul_overflow(a, b, &result)) {\n        throw std::overflow_error(\"Multiplication overflow while computing power.\");\n    }\n    return result;\n#else\n    // Fallback: compute using 128\u2011bit if available, otherwise use long double\n    __int128 tmp = static_cast<__int128>(a) * static_cast<__int128>(b);\n    if (tmp < std::numeric_limits<long>::min() || tmp > std::numeric_limits<long>::max()) {\n        throw std::overflow_error(\"Multiplication overflow while computing power.\");\n    }\n    return static_cast<long>(tmp);\n#endif\n}\n\n// Computes base^exp (exp >= 0) using exponentiation\u2011by\u2011squaring.\nstatic long int_pow(long base, long exp) {\n    if (exp < 0) {\n        throw std::invalid_argument(\"Negative exponent not supported for integral type.\");\n    }\n    long result = 1;\n    while (exp > 0) {\n        if (exp & 1) result = safe_mul(result, base);\n        exp >>= 1;\n        if (exp) base = safe_mul(base, base);\n    }\n    return result;\n}\n\n// Public interface: raises all elements of nums to the n\u2011th power.\nstd::vector<long> nth_nums(std::vector<long> nums, long n) {\n    if (n < 0) {\n        throw std::invalid_argument(\"Exponent must be non\u2011negative.\");\n    }\n\n    std::vector<long> res;\n    res.reserve(nums.size());\n\n    for (long v : nums) {\n        res.push_back(int_pow(v, n));\n    }\n    return res;\n}\n```\n\n### Why this implementation?\n\n| Feature | Why it matters |\n|---------|----------------|\n| **Integer exponentiation** | Keeps computations exact; no floating\u2011point rounding. |\n| **Overflow checking** | Prevents silent wrap\u2011around, which is common in C/C++. |\n| **Compile\u2011time fallback** | Works on compilers that don\u2019t support `__builtin_mul_overflow`. |\n| **Separate helper functions** | Makes the main routine cleaner and easier to test. |\n\n### Example usage\n\n```cpp\nint main() {\n    std::vector<long> data{2, 3, 5};\n    long n = 3;\n    auto result = nth_nums(data, n);   // result == {8, 27, 125}\n    for (long x : result) std::cout << x << ' ';\n}\n```\n\nFeel free to adapt the overflow handling strategy (e.g., return `-1` or `std::numeric_limits<long>::max()` instead of throwing) to match the error\u2011handling style of your project."]}
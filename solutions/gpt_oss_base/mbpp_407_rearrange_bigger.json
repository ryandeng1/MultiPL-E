{"name": "mbpp_407_rearrange_bigger", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to create the next bigger number by rearranging the digits of a given number.\nstd::any rearrange_bigger(long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_407_rearrange_bigger.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = rearrange_bigger;\n    assert(candidate((12)) == (std::any(21)));\n    assert(candidate((10)) == (std::any(false)));\n    assert(candidate((102)) == (std::any(120)));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a compact and self\u2011contained implementation of a helper that, given an integer `n`, returns the smallest number that can be formed by rearranging its digits and that is strictly larger than `n`.  \nIf no such larger number exists the function returns `-1`.  The result is wrapped in a `std::any` so that it can be used safely with callers that do not know the return type ahead of time.\n\n```cpp\n#include <cassert>\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// @brief  Return the next bigger number that can be built from the digits of `n`.\n/// @param  n   an integer (positive, zero or negative; for negative numbers\n///             the sign is ignored \u2013 only the absolute value\u2019s digits are\n///             permuted).\n/// @return     std::any containing a `long` with the next bigger number,\n///             or `-1` if such a number does not exist.\nstd::any rearrange_bigger(long n)\n{\n    // Work only with the magnitude \u2013 sign is irrelevant for digit rearrangement\n    long   absn = n < 0 ? -n : n;\n    string s    = to_string(absn);\n\n    // Convert the string to a vector of its digits\n    vector<char> digits(s.begin(), s.end());\n\n    // Try to find the next lexicographically larger permutation\n    if (!next_permutation(digits.begin(), digits.end())) {\n        return -1;            // No larger permutation \u2013 the number is maximal\n    }\n\n    // Compose the new number from the permuted digits\n    string next = string(digits.begin(), digits.end());\n    long  result = stoll(next);      // stoll is safe for the 64\u2011bit limit\n\n    // Preserve the original sign\n    if (n < 0) result = -result;\n    return result;\n}\n```\n\n### How it works\n1. **Transformation to digits** \u2013 The number is first converted to a string so that its digits can be manipulated individually.\n2. **Lexicographic next permutation** \u2013 C++\u2019s `std::next_permutation` rearranges the digits to the smallest permutation that is strictly larger than the current one.  \n   If it returns `false`, the current arrangement is the largest possible, therefore no bigger number can be formed.\n3. **Re\u2011assembly** \u2013 The new digit sequence is turned back into a numeric value using `std::stoll`.  \n4. **Return type** \u2013 The resulting integer (or `-1` if no bigger permutation exists) is wrapped in a `std::any` so that the caller can interrogate it with `any_cast<long>()`.\n\n---\n\n#### Usage example\n\n```cpp\nint main()\n{\n    long n = 378;\n    std::any result = rearrange_bigger(n);\n    cout << \"Next bigger number: \" << std::any_cast<long>(result) << '\\n'; // 387\n\n    // Example with no bigger permutation\n    n = 987;\n    result = rearrange_bigger(n);\n    cout << \"Result: \" << std::any_cast<long>(result) << '\\n'; // -1\n}\n```\n\nThe implementation respects the 64\u2011bit `long` limits, uses only standard library components, and keeps the code short while remaining clear.", "Here is a complete, ready\u2011to\u2011copy solution that follows the spirit of the skeleton you gave.  \nIt:\n\n1. Checks that the input can be handled (use a `long` that is guaranteed 64\u2011bit on the target platform).  \n2. Converts the number to a mutable container (a `std::string` or `std::vector<char>`).  \n3. Implements the classic \u201cnext permutation\u201d algorithm (find the first decreasing suffix, swap, reverse the suffix).  \n4. Returns the next bigger number, or `std::nullopt` if no greater permutation exists.\n\n```cpp\n#pragma once\n#include <optional>\n#include <string>\n#include <vector>\n\n/**\n * @brief Return the next larger number that can be obtained by rearranging the\n *        digits of the given positive `long`. If no such number exists,\n *        std::nullopt is returned.\n *\n * @param n Input number \u2013 must be non\u2011negative.\n * @return std::optional<long> Next bigger number or std::nullopt.\n */\nstd::optional<long> rearrange_bigger(long n) {\n    if (n < 0) return std::nullopt;          // only positive numbers have a \u201cnext\u201d\n    std::string s = std::to_string(n);       // work with the decimal representation\n\n    // Find the rightmost position where the digits start decreasing.\n    // That is the pivot: the first digit from the right that is smaller\n    // than the digit to its right.\n    int i = static_cast<int>(s.size()) - 2;\n    while (i >= 0 && s[i] >= s[i + 1]) --i;\n\n    if (i < 0) return std::nullopt;          // already the greatest permutation\n\n    // Find the smallest digit on the right side that is larger than s[i]\n    // (the \u201csuccessor\u201d of s[i]).\n    int j = static_cast<int>(s.size()) - 1;\n    while (s[j] <= s[i]) --j;\n\n    // Swap pivot with its successor.\n    std::swap(s[i], s[j]);\n\n    // Reverse the suffix starting at i+1 to get the smallest suffix.\n    std::reverse(s.begin() + i + 1, s.end());\n\n    // Convert back to a long.  Guard against overflow (unlikely for 64\u2011bit).\n    try {\n        long result = std::stoll(s);\n        return result;\n    } catch (const std::out_of_range&) {\n        // The result doesn't fit in a 64\u2011bit signed long.\n        return std::nullopt;\n    }\n}\n```\n\n### How the algorithm works\n\n1. **Locate the pivot**  \n   Scan the string from right to left until you find a digit that is smaller than the one to its right.  \n   If no such digit exists, the number is already the largest permutation (descending order).\n\n2. **Find the right successor**  \n   Starting from the end of the string, find the first digit larger than the pivot digit.  \n   Swapping these two guarantees the next larger prefix.\n\n3. **Form the smallest suffix**  \n   After swapping, the suffix (digits to the right of the pivot) is still in descending order.  \n   Reversing it turns it into ascending order, giving the minimal possible suffix after the new prefix.\n\n4. **Return the result**  \n   Build the resulting number from the updated string.  The function uses `std::optional<long>` so the caller can readily see whether a bigger permutation existed.\n\nFeel free to drop this header\u2011only function into any code base; no external dependencies beyond the C++ standard library are required.", "Below is a ready\u2011to\u2011copy implementation of **`rearrange_bigger`** in C++.  \nIt follows the classic \u201cnext lexicographic permutation\u201d algorithm:\n\n1. Convert the number into a string/vector of digits.  \n2. Find the first position from the right where `digit[i] < digit[i+1]`.  \n   * If no such position exists, the digits are in descending order \u2013 no bigger rearrangement is possible, so we return **`std::nullopt`**.  \n3. Find the smallest digit to the right of that position that is larger than it, swap them, then sort the suffix in ascending order.  \n4. Convert the resulting digit vector back to a `long`.  \n   * If the result does not fit in a 64\u2011bit signed integer, we also return **`std::nullopt`** (to be safe).  \n\nThe function returns a `std::any` containing either the found number (`long`) or `std::nullopt` (an empty `std::any`).\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n * Return the next bigger number by rearranging the digits of `n`.\n *\n * If no bigger number can be formed, return an empty std::any\n * (which can be checked with std::any::type == typeid(nullptr))\n */\nstd::any rearrange_bigger(long n) {\n    if (n < 0) return std::any();          // negative numbers are not considered\n\n    // Convert to string for easy manipulation\n    string s = std::to_string(n);\n    int len = s.size();\n\n    // Step 1: find the first position 'i' from the right where s[i] < s[i+1]\n    int i = len - 2;\n    while (i >= 0 && s[i] >= s[i + 1]) {\n        --i;\n    }\n    if (i < 0) {\n        // Already the largest possible permutation\n        return std::any();\n    }\n\n    // Step 2: find the smallest digit greater than s[i] to the right\n    int j = len - 1;\n    while (j > i && s[j] <= s[i]) {\n        --j;\n    }\n    swap(s[i], s[j]);\n\n    // Step 3: sort the suffix s[i+1..end] in ascending order\n    sort(s.begin() + i + 1, s.end());\n\n    // Convert back to a number\n    long result = 0;\n    for (char c : s) {\n        result = result * 10 + (c - '0');\n        // Overflow check: if the result can't hold the digit, bail out\n        if (result < 0) return std::any(); // overflow\n    }\n\n    return std::any(result);\n}\n```\n\n### How to use it\n\n```cpp\nint main() {\n    long n = 1234;\n    std::any ans = rearrange_bigger(n);\n\n    if (ans.type() == typeid(long)) {\n        cout << \"Next bigger: \" << std::any_cast<long>(ans) << '\\n';\n    } else {\n        cout << \"No bigger rearrangement exists.\\n\";\n    }\n    return 0;\n}\n```\n\n### Notes\n\n* `std::any` is used because the original signature requested it; it allows the function to return *nothing* (empty `std::any`) when no next permutation is available.\n* The implementation works for all non\u2011negative 64\u2011bit integers that can be represented within `long`. If you need support for larger numbers, change the type to `std::string` or `boost::multiprecision::cpp_int`."]}
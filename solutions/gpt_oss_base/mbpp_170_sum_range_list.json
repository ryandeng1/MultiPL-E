{"name": "mbpp_170_sum_range_list", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the sum of numbers in a vector within a range specified by two indices.\nlong sum_range_list(std::vector<long> list1, long m, long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_170_sum_range_list.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = sum_range_list;\n    assert(candidate((std::vector<long>({(long)2, (long)1, (long)5, (long)6, (long)8, (long)3, (long)4, (long)9, (long)10, (long)11, (long)8, (long)12})), (8), (10)) == (29));\n    assert(candidate((std::vector<long>({(long)2, (long)1, (long)5, (long)6, (long)8, (long)3, (long)4, (long)9, (long)10, (long)11, (long)8, (long)12})), (5), (7)) == (16));\n    assert(candidate((std::vector<long>({(long)2, (long)1, (long)5, (long)6, (long)8, (long)3, (long)4, (long)9, (long)10, (long)11, (long)8, (long)12})), (7), (10)) == (38));\n}\n", "stop_tokens": ["\n}"], "completions": ["```cpp\n#include <cassert>\n#include <vector>\n\n/**\n * @brief  Returns the sum of the elements of `list1` that lie\n *         between the indices `m` and `n` (inclusive).\n *\n * @param list1 a vector of long integers.\n * @param m     the start index (0\u2011based).\n * @param n     the end index (inclusive).\n *\n * @pre 0 \u2264 m \u2264 n < list1.size()\n *\n * @return The arithmetic sum of the sub\u2011vector [m \u2026 n].\n *\n * @note  The function performs two simple bounds checks using\n *        `assert`.  When compiling in release mode (`NDEBUG`\n *        defined) these checks are removed, and the function\n *        yields undefined behaviour if the indices are out of\n *        range.  If you want run\u2011time checking in production,\n *        replace the `assert` calls with explicit error handling\n *        (e.g. throwing an exception).\n */\nlong sum_range_list(const std::vector<long>& list1, long m, long n)\n{\n    assert(m >= 0);\n    assert(n >= 0);\n    assert(static_cast<std::size_t>(m) < list1.size());\n    assert(static_cast<std::size_t>(n) < list1.size());\n    assert(m <= n);\n\n    long sum = 0;\n    for (long i = m; i <= n; ++i) {\n        sum += list1[static_cast<std::size_t>(i)];\n    }\n    return sum;\n}\n```\n\n### How to use it\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> v = {5, 7, 3, 9, 1};\n    long result = sum_range_list(v, 1, 3);   // sums 7 + 3 + 9 = 19\n    std::cout << \"Sum: \" << result << '\\n';\n}\n```\n\nThe function follows the contract:\n\n* Accepts a vector and two indices.\n* Asserts the indices are within bounds and that `m \u2264 n`.\n* Iterates over the inclusive range and accumulates the sum.", "Here is a robust, self\u2011contained implementation that follows modern C++ practices and does **not** modify the original vector.  \nThe function checks that the indices are valid, clamps the indices to the actual bounds of the vector, then accumulates the values in the inclusive range `[m, n]`.\n\n```cpp\n#include <vector>\n#include <numeric>   // for std::accumulate\n#include <algorithm> // for std::clamp\n#include <stdexcept> // for std::out_of_range\n\n/**\n * @brief Compute the sum of elements in a vector between two indices.\n *\n * The range is inclusive: both m **and** n are taken into account.\n * A std::out_of_range exception is thrown if either index lies outside\n * the bounds of the vector.\n *\n * @param list1  The input vector of long integers.\n * @param m      The starting index of the range (0\u2011based).\n * @param n      The ending index of the range (0\u2011based).\n * @return long  The sum of the elements from list1[m] to list1[n] (inclusive).\n */\nlong sum_range_list(const std::vector<long>& list1, long m, long n)\n{\n    // Basic sanity check \u2013 indices must be within [0, list1.size() - 1].\n    if (list1.empty()) throw std::out_of_range(\"vector is empty\");\n    if (m < 0 || n < 0 || static_cast<size_t>(m) >= list1.size() ||\n        static_cast<size_t>(n) >= list1.size())\n        throw std::out_of_range(\"index out of range\");\n\n    // Ensure the lower bound <= upper bound.  If caller supplies\n    // the indices in the wrong order, we swap them.\n    if (m > n) std::swap(m, n);\n\n    // Compute the sum in the inclusive range [m, n].\n    // We use std::accumulate for clarity and to avoid manual loops.\n    return std::accumulate(list1.begin() + m, list1.begin() + n + 1, 0L);\n}\n```\n\n### Why this implementation?\n\n| Feature | Reason |\n|---------|--------|\n| **`const std::vector<long>&`** | Pass the vector by const reference to avoid expensive copies. |\n| **Range checks** | Throwing `std::out_of_range` gives immediate feedback for invalid indices. |\n| **Index order handling** | The function accepts indices in any order (`m > n`) and swaps them, making it more user\u2011friendly. |\n| **`std::accumulate`** | Clean, readable, and leverages the standard library. |\n| **Inclusive range** | The problem statement explicitly asks for a sum *within a range specified by two indices*, which typically includes both endpoints. |\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<long> v = {10, 20, 30, 40, 50};\n\n    try\n    {\n        std::cout << sum_range_list(v, 1, 3) << '\\n'; // prints 90 (20+30+40)\n        std::cout << sum_range_list(v, 3, 1) << '\\n'; // also 90 because indices are swapped\n        // std::cout << sum_range_list(v, 5, 1) << '\\n'; // throws exception\n    }\n    catch (const std::out_of_range& e) {\n        std::cerr << \"Error: \" << e.what() << '\\n';\n    }\n}\n```\n\nFeel free to adapt the exception policy or add overloads (e.g., accepting iterator ranges) if your project requires it.", "Here\u2019s a compact, well\u2011documented implementation that follows the description:\n\n```cpp\n// Sum all elements of `list1` whose indices lie in the inclusive range [m , n].\n// Preconditions:\n//   * 0 <= m <= n < list1.size()\n//   * m, n are \u201clong\u201d but we treat them as indices, so we cast to size_t\n//   * The vector is passed by value (the caller owns the data)\n//   * The function returns the sum as a `long`\nlong sum_range_list(std::vector<long> list1, long m, long n)\n{\n    // Guard clauses \u2013 using assert keeps the function lightweight for production\n    // but still traps bugs during debugging.\n    assert(m >= 0 && n >= 0 && m <= n && static_cast<uint64_t>(n) < list1.size());\n\n    long sum = 0;\n    // Zip the indices into a simple loop \u2013 we could also use std::accumulate with\n    // an indexed approach but a plain for\u2011loop is the clearest here.\n    for (long i = m; i <= n; ++i) {\n        sum += list1[static_cast<size_t>(i)];\n    }\n    return sum;\n}\n```\n\n### What\u2019s going on?\n\n1. **Input validation** \u2013 The asserts guarantee that we never read out of bounds. If any of the conditions fail, the program aborts with a clear message, useful during development.\n2. **Inclusive indexing** \u2013 The loop goes from `m` to `n` inclusive, mirroring the typical \u201crange\u201d semantics in many languages.\n3. **Type safety** \u2013 We convert the `long` indices to `size_t` when indexing the vector to avoid signed/unsigned warnings.\n\nFeel free to tweak the safety policy (e.g., throw an exception instead of `assert`) if you need a more production\u2011ready API."]}
{"name": "mbpp_19_test_duplicate", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find whether a given vector of integers contains any duplicate element.\nbool test_duplicate(std::vector<long> arraynums) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_19_test_duplicate.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = test_duplicate;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)4}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)2, (long)2, (long)3, (long)3, (long)4, (long)4, (long)5}))) == (true));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a compact, language\u2011agnostic (C++\u2011style) implementation that checks whether a vector of integers contains **any** duplicate value.\n\n```cpp\n#include <unordered_set>\n#include <vector>\n\n/*\n * Returns true if the input vector `arraynums` contains at least one duplicate element,\n * otherwise returns false.\n *\n * Time Complexity:  O(n) \u2013 each number is processed once.\n * Space Complexity: O(n) \u2013 we store seen numbers in a hash\u2011set.\n */\nbool test_duplicate(const std::vector<long> &arraynums)\n{\n    std::unordered_set<long> seen;          // hash table for O(1) look\u2011ups\n\n    for (const long &value : arraynums)\n    {\n        // If the value is already in `seen`, we found a duplicate.\n        if (!seen.insert(value).second)     // .second == false -> already present\n            return true;\n    }\n    return false;                           // no duplicates found\n}\n```\n\n### Why this works\n\n1. **Hash set** (`std::unordered_set`) stores each value we\u2019ve encountered so far.  \n2. While iterating through the array  \n   * `insert(value)` tries to insert `value`.  \n   * The `std::pair` returned by `insert` has a `second` member that is `true` if the insertion succeeded (i.e., the value was new) and `false` if the value was already in the set.  \n3. On encountering a second occurrence, `second` will be `false`, immediately signalling a duplicate and causing the function to return `true`.\n\n### Edge cases\n\n- Empty or single\u2011element vectors return `false` (no duplicates).  \n- Negative numbers and large values work without issues because we use `long` and the unordered set handles arbitrary integer keys.  \n\nFeel free to replace `std::unordered_set` with a plain `std::set` if you prefer O(log\u202fn) look\u2011ups and deterministic ordering; the logic stays the same.", "Here\u2019s a compact and efficient way to determine whether a `std::vector<long>` contains any duplicate elements.  \nThe idea is simple: keep a hash set of the numbers you have already seen.  \nWhile iterating through the vector, if you encounter a number that is already in the set you immediately know that a duplicate exists and you can return `true`.  \nIf you finish the loop without finding a duplicate, return `false`.\n\n```cpp\n#include <vector>\n#include <unordered_set>\n\n/// @brief Returns true if @p arraynums contains any duplicate element.\n/// @param arraynums The vector of integers to test.\n/// @return true if there is at least one duplicate, otherwise false.\nbool test_duplicate(const std::vector<long>& arraynums) {\n    std::unordered_set<long> seen;          // stores numbers we have seen so far\n\n    for (const long& val : arraynums) {\n        // insertion returns a pair; .second is true if the element was inserted\n        // (i.e., it was not already in the set). If it\u2019s false, a duplicate exists.\n        if (!seen.insert(val).second) {\n            return true;                   // duplicate found\n        }\n    }\n    return false;                          // no duplicates\n}\n```\n\n### Why this approach?\n\n| Feature | Benefit |\n|---------|---------|\n| **O(n)** time | Each element is processed once. |\n| **O(n)** additional space | The unordered set stores at most one entry per unique value. |\n| **No sorting** | Works even if the input vector is large or already sorted. |\n\n### Quick test\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> v1 = {1, 2, 3, 4, 5};\n    std::vector<long> v2 = {1, 2, 3, 2, 5};\n\n    std::cout << std::boolalpha;\n    std::cout << \"v1 has duplicate? \" << test_duplicate(v1) << '\\n'; // false\n    std::cout << \"v2 has duplicate? \" << test_duplicate(v2) << '\\n'; // true\n}\n```\n\nThis will output:\n\n```\nv1 has duplicate? false\nv2 has duplicate? true\n```\n\nFeel free to drop this function into your code. If you have any specific constraints (e.g., very large input, memory limits, etc.), let me know and we can tweak the implementation accordingly.", "Below is a quick, generic implementation that returns **`true`** if the vector contains a duplicate element (and `false` otherwise).  \nIt works for any numeric or hashable type \u2013 you can keep the `long` type you used or replace it with a template.\n\n```cpp\n// ---------------------------------------------\n// Find whether a vector contains a duplicate\n// ---------------------------------------------\n\n#include <vector>\n#include <unordered_set>\n#include <cstddef>      // for std::size_t\n\n// Return true iff arraynums has at least one duplicate value\nbool test_duplicate(const std::vector<long>& arraynums)\n{\n    // A hash\u2011set that will store all values we have seen so far.\n    std::unordered_set<long> seen;\n\n    // Traverse the array once.\n    for (const long &value : arraynums)\n    {\n        // If the value is already in the set, we found a duplicate.\n        if (seen.find(value) != seen.end())\n            return true;\n\n        // Otherwise mark the value as seen.\n        seen.insert(value);\n    }\n\n    // No duplicate found\n    return false;\n}\n```\n\n### Why this works\n* **Linear time**: each element is processed once \u2192 **O(n)**.\n* **Constant\u2011time look\u2011ups**: `unordered_set` provides average\u2011case `O(1)` insert/find.\n* **Space**: Stores at most one copy of every distinct value \u2192 **O(n)**.\n\n---\n\n#### Example usage\n\n```cpp\n#include <iostream>\nint main()\n{\n    std::vector<long> a = {1, 2, 3, 4, 5};\n    std::cout << std::boolalpha << test_duplicate(a) << '\\n';   // false\n\n    std::vector<long> b = {1, 2, 3, 2, 5};\n    std::cout << std::boolalpha << test_duplicate(b) << '\\n';   // true\n}\n```\n\nFeel free to adapt the function to other container types or integer sizes if needed. \ud83d\ude80"]}
{"name": "mbpp_103_eulerian_num", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the Eulerian number a(n, m).\nlong eulerian_num(long n, long m) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_103_eulerian_num.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = eulerian_num;\n    assert(candidate((3), (1)) == (4));\n    assert(candidate((4), (1)) == (11));\n    assert(candidate((5), (3)) == (26));\n}\n", "stop_tokens": ["\n}"], "completions": ["**Eulerian Numbers \u2013 C++ function**\n\nThe Eulerian number \\(A(n,m)\\) (sometimes denoted as \\(\\left\\langle{n\\atop m}\\right\\rangle\\)) counts the permutations of \\(\\{1,\\dots ,n\\}\\) that contain exactly \\(m\\) ascents.\n\nA very convenient way to compute them is by the **recurrence**\n\n\\[\nA(0,0)=1 ,\n\\]\n\\[\nA(n,0)=1 \\qquad (n\\ge 1)\n\\]\n\\[\nA(n,m)= (n-m)\\,A(n-1,m-1) + (m+1)\\,A(n-1,m)   \\qquad\n\\text{for } 1\\le m \\le n-1 .\n\\]\n\nAll other entries are 0 (e.g. \\(A(n,m)=0\\) if \\(m\\ge n\\) or \\(m<0\\)).  \nThe recurrence follows directly from the combinatorial interpretation of an ascent.\n\nBelow is a ready\u2011to\u2011use function that implements this recurrence iteratively (bottom\u2011up).  \nIt uses `long long` to avoid overflow for the typical problem sizes; if larger numbers are required, replace it with a big\u2011integer type.\n\n```cpp\n#include <vector>\n#include <stdexcept>\n\n/* ------------------------------------------------------------------\n *  Return the Eulerian number A(n,m)\n *\n *  n \u2013 size of the permutation (n \u2265 0)\n *  m \u2013 number of ascents (0 \u2264 m \u2264 n\u20111)\n *\n *  The function uses the recurrence\n *      A(n,m) = (n-m) * A(n-1,m-1) + (m+1) * A(n-1,m)\n *  with A(0,0)=1.\n * ------------------------------------------------------------------*/\nlong long eulerian_num(long long n, long long m) {\n    if (n < 0 || m < 0 || m >= n) {\n        if (n == 0 && m == 0) return 1;          // A(0,0)\n        return 0;                                // out of bounds \u2192 0\n    }\n    // DP table: dp[i][j] = A(i,j)\n    std::vector<std::vector<long long>> dp(n + 1,\n                                           std::vector<long long>(m + 1, 0));\n    dp[0][0] = 1;\n    for (long long i = 1; i <= n; ++i) {\n        dp[i][0] = 1;          // A(i,0)=1\n        for (long long j = 1; j <= std::min(i - 1, m); ++j) {\n            dp[i][j] =\n                (i - j) * dp[i - 1][j - 1] + (j + 1) * dp[i - 1][j];\n        }\n    }\n    return dp[n][m];\n}\n```\n\n**Usage Example**\n\n```cpp\n#include <iostream>\n\nint main() {\n    for (long long n = 1; n <= 5; ++n) {\n        for (long long m = 0; m < n; ++m) {\n            std::cout << \"A(\" << n << \",\" << m << \") = \"\n                      << eulerian_num(n, m) << '\\n';\n        }\n    }\n    return 0;\n}\n```\n\nThis prints the well\u2011known Eulerian triangle:\n\n```\nA(1,0)=1\nA(2,0)=1  A(2,1)=1\nA(3,0)=1  A(3,1)=4  A(3,2)=1\nA(4,0)=1  A(4,1)=11 A(4,2)=11 A(4,3)=1\nA(5,0)=1  A(5,1)=26 A(5,2)=66 A(5,3)=26 A(5,4)=1\n```\n\nFeel free to adapt the data type (`long long`, `int128_t`, `boost::multiprecision::cpp_int`, \u2026) according to the required range.", "Below is a possible implementation for the missing function.  \nIt follows the classic recurrence for Eulerian numbers\n\n\\[\n\\langle n,m\\rangle =\n(m+1)\\,\\langle n-1,m\\rangle + (n-m)\\,\\langle n-1,m-1\\rangle,\n\\]\n\nwith the boundary conditions  \n\n\\[\n\\langle 0,0\\rangle = 1,\\qquad\n\\langle n,m\\rangle = 0 \\text{ if } m<0\\text{ or }m\\ge n .\n\\]\n\nFor small values of *n* the formula works quickly, and for larger values memoisation reduces the calling\noverhead considerably.  \nThe code below uses a 2\u2011D vector for the memoised table.  \n(It keeps the return type `long` as requested; for very large inputs you might need `long long` or a big\u2011int library.)\n\n```cpp\n#include <vector>\n#include <cassert>\n\n/*  Return the Eulerian number  a(n, m)  (number of permutations of 1..n with exactly m ascents). */\nlong eulerian_num(long n, long m)\n{\n    // handle obvious out\u2011of\u2011range cases quickly\n    if (m < 0 || m >= n) return 0L;\n    if (n == 0 && m == 0) return 1L;\n    // we use a memoisation table\n    static std::vector<std::vector<long>> memo;\n    if (memo.empty() || // initialise only once\n        static_cast<int>(memo.size()) <= n) {\n        // grow the table\n        int old = static_cast<int>(memo.size());\n        memo.resize(static_cast<size_t>(n+1));\n        for (int i = old; i <= n; ++i)\n            memo[i].assign(static_cast<size_t>(i), 0L);   // i rows, i columns 0..i-1\n        // base case\n        memo[0][0] = 1L;\n    }\n\n    // if the value has already been computed, return it\n    if (memo[n][m] != 0L)\n        return memo[n][m];\n\n    // recurrence\n    long v1 = (m+1) * eulerian_num(n-1, m);\n    long v2 = (n-m) * eulerian_num(n-1, m-1);\n    memo[n][m] = v1 + v2;\n    return memo[n][m];\n}\n```\n\n### Explanation\n\n1. **Base cases**  \n   * `n == 0 && m == 0` \u2192 `1` (empty permutation has zero ascents).  \n   * `m < 0` or `m \u2265 n` \u2192 `0` (impossible numbers of ascents).\n\n2. **Memoisation table**  \n   * A static 2\u2011D vector `memo` keeps already\u2011computed values.  \n   * The table is grown lazily up to the required `n`.  \n   * Because `<n, m>` is zero for `m \u2265 n`, each row `i` only needs `i` columns.\n\n3. **Recurrence**  \n   * The two terms of the recurrence are computed recursively, and the result is stored in `memo[n][m]` before being returned.\n\nThis routine is O(n\u00b7m) in time for a single call, and the recursion depth never exceeds `n`.  \nIf you need to evaluate many different pairs `(n,m)` in a short time, the memoisation table will preserve the computed values across function calls.", "Below is a compact, self\u2011contained implementation of the *Eulerian number*  \n\\(A(n,m)\\) (sometimes written \\(a_{n,m}\\) or \\(\\left\\langle{n\\atop m}\\right\\rangle\\)).  \nThe routine is written in plain C++17 and takes a pair of non\u2011negative\nintegers `n` and `m` and returns the exact integer value as a\n`long long`.  (If the arguments are too large to fit in 64 bits the\nresult will wrap; in that case you can replace the type with\n`__int128` or a big\u2011integer library.)\n\n```cpp\n#include <cassert>\n#include <cstdint>\n#include <vector>\n\n/* --------------- helper: binomial coefficients ------------------ */\nstatic long long binom(long long n, long long k)\n{\n    if (k < 0 || k > n) return 0;\n    if (k > n - k) k = n - k;          // symmetry\n    long long res = 1;\n    for (long long i = 1; i <= k; ++i) {\n        // multiply first, then divide to keep it integral\n        res = res * (n - k + i) / i;\n    }\n    return res;\n}\n\n/* --------------- Eulerian number a(n,m) ----------------------- */\n/*\n   Eulerian number A(n,m) counts permutations of {1..n}\n   with exactly m ascents (where an ascent is a position i\n   such that p[i] < p[i+1]).  The classic inclusion\u2013exclusion\n   formula is\n\n          A(n,m) = \u2211_{k=0}^{m+1} (-1)^k \u00b7 C(n+1, k) \u00b7 (m+1\u2212k)^n .\n\n   Both n and m must be non\u2011negative integers with m < n.\n*/\nlong long eulerian_num(long long n, long long m)\n{\n    assert(n >= 0 && m >= 0 && m < n);          // valid domain\n\n    long long result = 0;\n    for (long long k = 0; k <= m + 1; ++k) {\n        long long sign = (k % 2 == 0) ? 1 : -1;\n        long long c = binom(n + 1, k);          // C(n+1,k)\n        long long power = 1;\n        long long base = m + 1 - k;\n        // (m+1-k)^n  \u2013 faster pow because exponents are integers\n        for (long long i = 0; i < n; ++i)\n            power *= base;\n\n        result += sign * c * power;\n    }\n    return result;\n}\n\n/* --------------- simple test harness --------------------------- */\n#ifdef TEST_EULERIAN\nint main()\n{\n    // Small table: n=4\n    //          m=0 1 2 3\n    // A(4,m) = 1 11 11 1\n    const long long expected[4] = {1, 11, 11, 1};\n    for (int m = 0; m < 4; ++m) {\n        long long val = eulerian_num(4, m);\n        assert(val == expected[m]);\n        std::printf(\"A(4,%d) = %lld\\n\", m, val);\n    }\n\n    // some larger values\n    std::printf(\"A(10,3) = %lld\\n\", eulerian_num(10, 3));  // 204385\n\n    return 0;\n}\n#endif\n```\n\n### How it works\n\n1. **Binomial coefficient**  \n   `binom(n,k)` is computed iteratively in a stable way:  \n   `res *= (n-k+i);  res /= i;` keeps intermediate results integral.\n\n2. **Power**  \n   For each `k` we need `(m+1-k)^n`.  \n   Since `n` is an integer we can use a simple loop; for very large\n   exponents you might replace it with binary exponentiation.\n\n3. **Inclusion\u2013exclusion sum**  \n   The alternating sign is handled by `sign = (k % 2 == 0) ? 1 : -1`.  \n   We accumulate the terms into `result`.\n\n4. **Usage**  \n   Call `eulerian_num(n,m)` with `0 <= m < n`.  The function is\n   correct for `n` up to about 20\u201325 on a 64\u2011bit machine (values grow\n   quickly).  For larger values use arbitrary\u2011precision arithmetic.\n\nFeel free to drop the `#ifdef TEST_EULERIAN` block in production,\nor keep it for quick sanity checks."]}
{"name": "mbpp_452_loss_amount", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that gives loss amount on a sale if the given amount has loss else return 0.\nlong loss_amount(long actual_cost, long sale_amount) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_452_loss_amount.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = loss_amount;\n    assert(candidate((1500), (1200)) == (0));\n    assert(candidate((100), (200)) == (100));\n    assert(candidate((2000), (5000)) == (3000));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a concise implementation that does exactly that:\n\n```cpp\nlong loss_amount(long actual_cost, long sale_amount) {\n    // If the sale price is lower than the actual cost we have a loss.\n    long diff = actual_cost - sale_amount;\n\n    // Return the loss amount if > 0; otherwise return 0\n    return diff > 0 ? diff : 0;\n}\n```\n\n### What it does\n- Computes the difference between the `actual_cost` and the `sale_amount`.\n- If the sale is less than the cost (`diff > 0`), the function returns that positive loss amount.\n- Otherwise (the sale price is equal to or higher than the cost), it returns `0`, indicating no loss.\n\nFeel free to integrate it into your code or adjust it for edge cases (e.g., handling underflow/overflow) if needed.", "Here\u2019s a compact, type\u2011safe implementation that follows the requirement:\n\n```cpp\n#include <cassert>\n#include <cstdint>\n\n/**\n * @brief Returns the loss amount for a sale.\n *\n * If the sale_amount is lower than actual_cost, the difference\n * (actual_cost - sale_amount) is returned. Otherwise, 0 is returned.\n *\n * @param actual_cost The original purchase cost (in the same units as sale_amount).\n * @param sale_amount The amount received from the sale.\n * @return long The loss amount, or 0 if no loss.\n */\nlong loss_amount(long actual_cost, long sale_amount) {\n    // Guard against impossible negative costs.  Adjust if your domain allows it.\n    assert(actual_cost >= 0);\n    assert(sale_amount >= 0);\n\n    if (sale_amount < actual_cost) {\n        return actual_cost - sale_amount;\n    }\n    return 0;\n}\n```\n\n### Why this version?\n\n| Feature | Reason |\n|---------|--------|\n| **Explicit type (`long`)** | Keeps the signature you gave. |\n| **`assert`s** | Helps catch logic errors during debugging (negative costs are unexpected). |\n| **Clear `if\u2011else`** | No hidden conversions; simple arithmetic. |\n| **No special libraries** | Only standard headers, no `<bits/stdc++.h>` needed. |\n\n#### Example Usage\n\n```cpp\n#include <iostream>\n\nint main() {\n    long cost = 1000;\n    long sale = 750;\n    std::cout << \"Loss: \" << loss_amount(cost, sale) << '\\n'; // prints 250\n\n    sale = 1200;\n    std::cout << \"Loss: \" << loss_amount(cost, sale) << '\\n'; // prints 0\n}\n```\n\nFeel free to drop the `assert`s if you want a production\u2011ready version that silently clamps negative numbers or handles unsigned types appropriately.", "Here\u2019s a compact and fully\u2011documented implementation of the `loss_amount` function.  \nIt follows best practices (strict typing, early validation, and clear comments) so you can drop it straight into a modern C++ project.\n\n```cpp\n#include <cstddef>   // for std::size_t\n#include <cstdlib>   // for std::abs\n#include <stdexcept> // for std::invalid_argument\n\n/// \\brief Returns the monetary loss incurred on a sale.\n///\n/// The function receives two `long` values:\n/// - `actual_cost`: the true cost price of the item.\n/// - `sale_amount`: the amount obtained from selling the item.\n///\n/// If the sale amount is less than the actual cost the function\n/// returns the difference `(actual_cost \u2013 sale_amount)`\n/// representing a financial loss.  \n/// If the sale amount is greater than or equal to the cost,\n/// no loss occurs and the function returns `0`.\n///\n/// \\param actual_cost   The cost price of the item.\n/// \\param sale_amount   The amount received from the sale.\n/// \\return The loss amount (non\u2011negative). Returns 0 when there is no loss.\n///\n/// \\throws std::invalid_argument if either argument is negative,\n///         because monetary amounts are expected to be non\u2011negative.\nlong loss_amount(long actual_cost, long sale_amount)\n{\n    // Input validation \u2013 monetary amounts must be non\u2011negative.\n    if (actual_cost < 0 || sale_amount < 0)\n        throw std::invalid_argument(\"Monetary amounts must be non\u2011negative\");\n\n    // Loss is computed only when sale is below cost.\n    if (sale_amount < actual_cost)\n        return actual_cost - sale_amount;\n\n    // No loss: sale is equal to or greater than cost.\n    return 0L;\n}\n```\n\n### How it works\n1. **Input validation** \u2013 Any negative input throws an exception, preventing accidental misuse.\n2. **Loss calculation** \u2013 The difference is calculated only when the sale is below cost.\n3. **Return value** \u2013 The function always returns a non\u2011negative `long`. If there\u2019s no loss, it simply returns `0`.\n\n### Usage example\n```cpp\nint main()\n{\n    long cost  = 1'000'000;\n    long sale1 =   800'000; // loss\n    long sale2 = 1'200'000; // no loss\n\n    std::cout << \"Loss for sale1: \" << loss_amount(cost, sale1) << '\\n'; // 200000\n    std::cout << \"Loss for sale2: \" << loss_amount(cost, sale2) << '\\n'; // 0\n}\n```\n\nFeel free to adjust the validation logic or error handling as per your project\u2019s conventions."]}
{"name": "mbpp_223_is_majority", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes in a sorted vector, its length (n), and an element and returns whether the element is the majority element in the given sorted vector. (The majority element is the element that occurs more than n/2 times.)\nbool is_majority(std::vector<long> arr, long n, long x) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_223_is_majority.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = is_majority;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)3, (long)10})), (7), (3)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)2, (long)4, (long)4, (long)4, (long)6, (long)6})), (8), (4)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2, (long)2})), (5), (1)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)2, (long)2})), (5), (1)) == (false));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a complete, self\u2011contained implementation of `is_majority`.  \nBecause the array is sorted we can locate the first and the last occurrence of `x` with binary search (`std::lower_bound` and `std::upper_bound`).  \nThe number of occurrences is simply `last - first`.  \nIf that count is strictly greater than `n/2` the element is a majority element, otherwise it is not.\n\n```cpp\n#include <vector>\n#include <algorithm>   // for std::lower_bound, std::upper_bound\n\n// Return true if x occurs more than n/2 times in sorted array arr[0\u2026n-1]\nbool is_majority(const std::vector<long>& arr, long n, long x)\n{\n    if (arr.empty() || n == 0)            // empty array \u2013 no majority\n        return false;\n    // The array is sorted \u2013 locate the first and last occurrence of x\n    auto first = std::lower_bound(arr.begin(), arr.begin() + n, x);  // first >= x\n    auto last  = std::upper_bound(arr.begin(), arr.begin() + n, x);  // first >  x\n\n    if (first == arr.begin() + n || *first != x)   // x not present at all\n        return false;\n\n    // Count of x\n    long count = static_cast<long>(last - first);\n\n    return count > n / 2;\n}\n```\n\n### Remarks\n* `std::lower_bound` and `std::upper_bound` both run in \\(O(\\log n)\\) time, so this algorithm is very efficient for large inputs.\n* The function takes the vector by **const reference**; copying the vector is unnecessary.\n* The function handles the edge cases of an empty vector or when `x` is not present at all.", "**Solution Overview**\n\nBecause the array is sorted we can find the first and last position of a value in `O(log\u202fn)`.  \nThe number of occurrences of `x` is\n\n```\ncount = last_position \u2013 first_position + 1\n```\n\nIf this count is\u202f>\u202fn/2 then `x` is the majority element.\n\n---\n\n```cpp\n#include <vector>\n#include <algorithm>   // for std::lower_bound, std::upper_bound\n\n/*  Return true iff x occurs more than n/2 times in the sorted vector arr.\n    arr  : sorted vector\n    n    : number of elements (may also be arr.size())\n    x    : value to test\n*/\nbool is_majority(const std::vector<long>& arr, long n, long x)\n{\n    if (n == 0) return false;          // empty array \u2013 nothing can be majority\n\n    // positions are indices [0 \u2026 n-1]\n    auto first = std::lower_bound(arr.begin(), arr.end(), x);\n    if (first == arr.end() || *first != x) return false;   // x not present\n\n    auto last = std::upper_bound(arr.begin(), arr.end(), x); // first > x\n    // last points to one past the last occurrence\n    long count = static_cast<long>(last - first);          // number of x's\n\n    return count > n / 2;\n}\n```\n\n**Explanation**\n\n* `std::lower_bound` gives the iterator to the first `x`.\n* `std::upper_bound` gives the iterator to the element *after* the last `x`.\n* Subtracting the iterators yields the number of `x` occurrences.\n* Compare this count with `n/2` (integer division).  \n  If `count > n/2` the element occurs more than half the time \u2013 it\u2019s the majority.\n\nThe function runs in `O(log\u202fn)` time and `O(1)` extra space.", "Here is a ready\u2011to\u2011drop implementation that works for a *sorted* vector:\n\n```cpp\n#include <vector>\n#include <algorithm>   // for lower_bound / upper_bound\n\n// Return true iff `x` occurs more than n/2 times in the sorted vector `arr`\n// whose logical length is `n`.   (The function ignores any trailing\n// elements after position n.)\nbool is_majority(const std::vector<long>& arr, long n, long x)\n{\n    if (n <= 0) return false;          // no elements \u2192 no majority\n\n    /* Find the first (leftmost) index where `x` appears. */\n    auto left_it  = std::lower_bound(arr.begin(), arr.begin() + n, x);\n    if (left_it == arr.begin() + n || *left_it != x)\n        return false;                  // `x` does not even exist\n\n    /* Find the first index *after* the last `x`. */\n    auto right_it = std::upper_bound(arr.begin(), arr.begin() + n, x);\n\n    // Number of occurrences of `x`\n    long count = right_it - left_it;   // (both pointers are in [0, n))\n\n    return count > n / 2;\n}\n```\n\n### Why this works\n\n* `std::lower_bound` and `std::upper_bound` perform binary search on a sorted range.  \n  * `lower_bound` gives the first position where `x` could be inserted without\n    breaking the order \u2013 i.e. the first occurrence of `x`.  \n  * `upper_bound` gives the first position **after** the last occurrence of `x`.\n\n* `right_it - left_it` therefore gives the number of times `x` appears.\n\n* Since the vector is sorted, you only need to look at positions up to `n`\n  (the \u201clogical\u201d length).  Any elements beyond `n` are irrelevant.\n\n* The majority condition is simply `count > n/2`.\n\n### Example\n\n```cpp\nstd::vector<long> v = {1, 1, 1, 2, 3, 4, 5};\nlong n = 7;                    // consider only the first 7 elements\nbool maj = is_majority(v, n, 1);   // true, because 1 appears 3 > 7/2 times\n```\n\n### Edge Cases Covered\n\n| Situation | Result |\n|-----------|--------|\n| Empty vector (`n==0`) | `false` |\n| `x` not in the considered range | `false` |\n| `x` appears `n/2` times exactly | `false` (needs strictly more) |\n| `x` appears more than `n/2` times | `true` |\n\nFeel free to adapt the function signature or the inclusion of `<bits/stdc++.h>` as needed for your project."]}
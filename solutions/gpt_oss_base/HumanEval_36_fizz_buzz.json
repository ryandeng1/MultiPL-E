{"name": "HumanEval_36_fizz_buzz", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_36_fizz_buzz.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = fizz_buzz;\n    assert(candidate((50)) == (0));\n    assert(candidate((78)) == (2));\n    assert(candidate((79)) == (3));\n    assert(candidate((100)) == (3));\n    assert(candidate((200)) == (6));\n    assert(candidate((4000)) == (192));\n    assert(candidate((10000)) == (639));\n    assert(candidate((100000)) == (8026));\n}\n", "stop_tokens": ["\n}"], "completions": ["**Solution Explanation**\n\nFor every integer `i` with `1 \u2264 i < n`\n\n* check whether `i` is divisible by `11` **or** by `13`;\n* if it is, count how many decimal digits of `i` equal to `'7'`;\n* add that count to the running total.\n\nThe only non\u2011trivial part is counting the digit `7` in a given number.\nA simple loop that repeatedly takes `i % 10` works \u2013 it extracts the least\nsignificant digit, tests it, then discards it with integer division by `10`.\nWhen `i` reaches `0` all digits have been processed.\n\nBecause the input size is only up to a `long` and we only iterate up to\n`n \u2013 1`, this straightforward approach easily meets the time limits.\n\n---\n\n#### Algorithm\n```\nfizz_buzz(n):\n    total \u2190 0\n    for i from 1 to n-1:\n        if (i mod 11 == 0) or (i mod 13 == 0):\n            x \u2190 i\n            while x > 0:\n                if (x mod 10 == 7):\n                    total \u2190 total + 1\n                x \u2190 x / 10   // integer division\n    return total\n```\n\n---\n\n#### Correctness Proof  \n\nWe prove that `fizz_buzz(n)` returns the number of times the digit `7`\nappears in all integers `< n` that are divisible by `11` or `13`.\n\n*Lemma 1*  \nFor any integer `i`, the inner `while` loop counts exactly the number of\ndigits equal to `7` in the decimal representation of `i`.\n\n*Proof of Lemma 1*  \nEach iteration of the loop inspects the least significant digit of `i`\n(`i % 10`).  \nIf that digit equals `7`, the counter is incremented once, exactly once\nper occurrence of the digit `7`.  \nAfter that, `i` is replaced by `i / 10`, discarding the inspected digit.\nThus the loop visits every decimal digit of the original number once,\ncounting `7` exactly when it appears. \u220e\n\n*Lemma 2*  \nFor each integer `i` with `1 \u2264 i < n` and `(i mod 11 == 0) \u2228 (i mod 13 == 0)`,\nthe algorithm adds to `total` the exact number of `7`\u2019s that appear in `i`.\n\n*Proof of Lemma 2*  \nIf the divisibility condition is true, the outer loop executes the inner\nloop.  \nBy Lemma&nbsp;1 the inner loop returns precisely the number of `7`\u2019s in `i`;\nthis value is added to `total`. \u220e\n\n*Theorem*  \n`fizz_buzz(n)` returns the total number of occurrences of digit `7` in all\nintegers `< n` that are divisible by `11` or `13`.\n\n*Proof of Theorem*  \nThe outer loop iterates over every integer `i` with `1 \u2264 i < n`.  \nBy Lemma&nbsp;2, whenever `i` satisfies the required divisibility,\nthe contribution of `i` (the exact count of its `7` digits) is added to\n`total`.  \nIf `i` does not satisfy the divisibility test, nothing is added, so its\nco\u2011occurrence of `7` does not inflate the result.  \nConsequently, after the loop terminates, `total` equals the sum of all\noccurrences of `7` in the specified set of integers. \u220e\n\n---\n\n#### Complexity Analysis  \n\n* Outer loop: `n-1` iterations \u2192 **O(n)**  \n* Inner loop: at most `log10(i)` digit inspections per `i`; the sum of\n  `log10(i)` over all `i` is `\u0398(n log n)` in the worst case, but since\n  `n` fits in a `long`, the total cost is still **O(n)** for typical test\n  ranges.\n\nMemory usage is **O(1)**.\n\n---\n\n#### Reference Implementation (C++17)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* Return the number of times the digit 7 appears in integers less than n\n   which are divisible by 11 or 13. */\nlong fizz_buzz(long n) {\n    long long total = 0;\n    for (long long i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            long long x = i;\n            while (x > 0) {\n                if (x % 10 == 7) ++total;\n                x /= 10;\n            }\n        }\n    }\n    return total;\n}\n\n/* Optional: simple test harness */\n#ifdef LOCAL\nint main() {\n    cout << fizz_buzz(50) << endl; // 0\n    cout << fizz_buzz(78) << endl; // 2\n    cout << fizz_buzz(79) << endl; // 3\n}\n#endif\n```\n\nThe code follows exactly the algorithm proven correct above and is fully\ncompatible with the GNU++17 compiler.", "**Explanation**\n\nWe have to count how many times the digit `7` appears in the decimal representation of all numbers  \n`x` such that\n\n```\n0 \u2264 x < n  and  (x is divisible by 11 or by 13)\n```\n\nThe algorithm is straightforward:\n\n1. Iterate `x` from `0` up to `n\u20111`.\n2. If `x % 11 == 0 || x % 13 == 0` it is a candidate.\n3. Convert the candidate to its decimal digits (or use arithmetic) and count the `7`s.\n4. Sum all counts and return the total.\n\nThe complexity is `O(n log n)` because we inspect each number once and the digit extraction\nfor a number of size `m` takes `O(m)` time.  \nFor the limits in the exercise this is perfectly fine.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Count the digit 7 in all integers x such that\n// 0 <= x < n and (x divisible by 11 or 13)\nlong fizz_buzz(long n) {\n    long long total = 0;\n    for (long long x = 0; x < n; ++x) {\n        if (x % 11 == 0 || x % 13 == 0) {\n            long long t = x;\n            while (t > 0) {\n                if (t % 10 == 7) ++total;\n                t /= 10;\n            }\n        }\n    }\n    return total;\n}\n\n/* Example tests\n#include <iostream>\nint main() {\n    cout << fizz_buzz(50) << \"\\n\"; // 0\n    cout << fizz_buzz(78) << \"\\n\"; // 2\n    cout << fizz_buzz(79) << \"\\n\"; // 3\n}\n*/\n```\n\nThis implementation follows the problem description exactly and produces the expected\nresults for the given examples.", "Here is a very straightforward implementation of the specification.  \nThe function iterates over the numbers `< n`, checks if each is divisible by 11 or 13, converts the integer to a string, and counts the `7`\u2011digits that appear.\n\n```cpp\n#include <iostream>\n#include <string>\n\n// Return the number of times the digit 7 appears in integers less than n\n// which are divisible by 11 or 13.\nlong fizz_buzz(long n) {\n    if (n <= 0) return 0;          // nothing to check\n\n    long count7 = 0;\n    for (long i = 1; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            std::string s = std::to_string(i);\n            for (char c : s) {\n                if (c == '7') ++count7;\n            }\n        }\n    }\n    return count7;\n}\n\n/* Test harness \u2013 not part of the required function\nint main() {\n    std::cout << fizz_buzz(50) << std::endl;  // 0\n    std::cout << fizz_buzz(78) << std::endl;  // 2\n    std::cout << fizz_buzz(79) << std::endl;  // 3\n}\n*/\n```\n\n### Explanation\n\n1. **Boundary check** \u2013 If `n` is zero or negative, we return `0` straight away because there are no positive integers to examine.\n2. **Loop over numbers** \u2013 For every integer `i` from `1` to `n-1` (engaging only values `< n`), we test whether it is divisible by `11` or `13`.\n3. **Digit counting** \u2013 When the divisibility test passes, we convert `i` to a string and iterate over its characters, incrementing `count7` each time we encounter `'7'`.\n4. **Return** \u2013 The final tally (`count7`) is returned.\n\nThis implementation is intentionally simple and easy to understand while meeting the required functionality."]}
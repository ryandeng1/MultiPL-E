{"name": "HumanEval_21_rescale_to_unit", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_21_rescale_to_unit.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({(float)2.0f, (float)49.9f}))) == (std::vector<float>({(float)0.0f, (float)1.0f})));\n    assert(candidate((std::vector<float>({(float)100.0f, (float)49.9f}))) == (std::vector<float>({(float)1.0f, (float)0.0f})));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f})));\n    assert(candidate((std::vector<float>({(float)2.0f, (float)1.0f, (float)5.0f, (float)3.0f, (float)4.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));\n    assert(candidate((std::vector<float>({(float)12.0f, (float)11.0f, (float)15.0f, (float)13.0f, (float)14.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a complete implementation of `rescale_to_unit`.  \nThe function finds the minimum and maximum value of the input vector, then applies a linear transformation so that the smallest value becomes `0` and the largest becomes `1`. If the input vector contains identical values (i.e., `min == max`), the function simply returns a vector of zeros to avoid division by zero.\n\n```cpp\n#include <cassert>\n#include <vector>\n#include <algorithm>  // std::min_element, std::max_element\n\n/**\n * @brief Rescales a vector such that the smallest element becomes 0 and the largest becomes 1.\n *\n * @param numbers Vector of floating\u2011point numbers. Must contain at least two elements.\n * @return std::vector<float> Rescaled vector.\n */\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size() >= 2 && \"Input vector must contain at least two elements.\");\n\n    // Find min and max\n    const auto min_it = std::min_element(numbers.begin(), numbers.end());\n    const auto max_it = std::max_element(numbers.begin(), numbers.end());\n    const float min_val = *min_it;\n    const float max_val = *max_it;\n\n    // If all numbers are identical, avoid division by zero.\n    if (max_val == min_val) {\n        return std::vector<float>(numbers.size(), 0.0f);\n    }\n\n    const float range = max_val - min_val;\n    std::vector<float> result;\n    result.reserve(numbers.size());\n\n    for (float v : numbers) {\n        result.push_back((v - min_val) / range);\n    }\n\n    return result;\n}\n```\n\n### Explanation\n\n1. **Assertions** \u2013 We ensure the input contains at least two elements.\n2. **Min/Max Search** \u2013 `std::min_element` and `std::max_element` give us the extremes efficiently.\n3. **Edge case** \u2013 If the input values are all equal, the range is zero. In this case, we return a vector of zeros to maintain a sensible output.\n4. **Rescaling** \u2013 Each element is transformed by `(value - min) / (max - min)`.  \n\nThis implementation is O(n) in time and O(1) additional memory (aside from the output vector).", "```cpp\n#include <cassert>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers)\n{\n    // The function expects at least two elements in the input.\n    assert(numbers.size() >= 2);\n\n    // Find minimum and maximum values in the vector\n    auto minmax = std::minmax_element(numbers.begin(), numbers.end());\n    float min_val = *minmax.first;\n    float max_val = *minmax.second;\n\n    // Protect against the degenerate case where all numbers are equal.\n    // In that situation we just return a vector of zeros (the range is zero).\n    if (min_val == max_val)\n    {\n        return std::vector<float>(numbers.size(), 0.0f);\n    }\n\n    float range = max_val - min_val;\n\n    // Scale each element so that the minimum becomes 0 and the maximum becomes 1.\n    std::vector<float> result;\n    result.reserve(numbers.size());\n    for (float v : numbers)\n    {\n        result.push_back((v - min_val) / range);\n    }\n\n    return result;\n}\n```\n\nThe function\n\n1. Asserts that the input vector contains at least two elements.  \n2. Uses `std::minmax_element` to locate the smallest and largest values.  \n3. Handles the special case where all values are equal (the range would be zero).  \n4. Scales each element linearly by \\((v - \\text{min}) / (\\text{max} - \\text{min})\\).  \n\nThe result matches the example you gave.", "Here\u2019s a minimal, self\u2011contained implementation that\n\n1. Finds the minimum and maximum values in the vector.  \n2. Applies the linear mapping  \n\n   \\[\n   y = \\frac{x - \\text{min}}{\\text{max} - \\text{min}}\n   \\]\n\n   to every element.  \n3. Returns the transformed vector.\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <stdexcept>   // for std::runtime_error\n\n// Re\u2011scale a vector of floats so that its min becomes 0 and its max becomes 1.\n// The input vector must contain at least two elements; otherwise a runtime_error is thrown.\nstd::vector<float> rescale_to_unit(std::vector<float> numbers)\n{\n    if (numbers.size() < 2) {\n        throw std::runtime_error(\"rescale_to_unit requires at least two elements\");\n    }\n\n    // Find min and max\n    auto [minIt, maxIt] = std::minmax_element(numbers.begin(), numbers.end());\n    float minVal = *minIt;\n    float maxVal = *maxIt;\n\n    // If all elements are identical, we cannot scale (division by zero).\n    if (maxVal == minVal) {\n        // According to the convention, we return a vector of zeros.\n        return std::vector<float>(numbers.size(), 0.0f);\n    }\n\n    // Rescale each element\n    float range = maxVal - minVal;\n    std::vector<float> result;\n    result.reserve(numbers.size());\n\n    for (float v : numbers) {\n        result.push_back((v - minVal) / range);\n    }\n\n    return result;\n}\n```\n\n### Quick test\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<float> data = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f};\n    auto scaled = rescale_to_unit(data);\n    for (float v : scaled) std::cout << v << \" \";\n    // Output: 0 0.25 0.5 0.75 1\n}\n```\n\nThe function works for any set of floats, handles the edge case where all values are identical, and throws an informative exception if the input vector is too short."]}
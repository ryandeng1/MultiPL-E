{"name": "mbpp_780_find_combinations", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the combinations of sums with tuples in the given tuple vector. https://www.geeksforgeeks.org/cppthon-combinations-of-sum-with-tuples-in-tuple-vector/\nstd::vector<std::tuple<long, long>> find_combinations(std::vector<std::tuple<long, long>> test_list) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_780_find_combinations.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = find_combinations;\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 4), (std::tuple<long, long>)std::make_tuple(6, 7), (std::tuple<long, long>)std::make_tuple(5, 1), (std::tuple<long, long>)std::make_tuple(6, 10)}))) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(8, 11), (std::tuple<long, long>)std::make_tuple(7, 5), (std::tuple<long, long>)std::make_tuple(8, 14), (std::tuple<long, long>)std::make_tuple(11, 8), (std::tuple<long, long>)std::make_tuple(12, 17), (std::tuple<long, long>)std::make_tuple(11, 11)})));\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(3, 5), (std::tuple<long, long>)std::make_tuple(7, 8), (std::tuple<long, long>)std::make_tuple(6, 2), (std::tuple<long, long>)std::make_tuple(7, 11)}))) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(10, 13), (std::tuple<long, long>)std::make_tuple(9, 7), (std::tuple<long, long>)std::make_tuple(10, 16), (std::tuple<long, long>)std::make_tuple(13, 10), (std::tuple<long, long>)std::make_tuple(14, 19), (std::tuple<long, long>)std::make_tuple(13, 13)})));\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(4, 6), (std::tuple<long, long>)std::make_tuple(8, 9), (std::tuple<long, long>)std::make_tuple(7, 3), (std::tuple<long, long>)std::make_tuple(8, 12)}))) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(12, 15), (std::tuple<long, long>)std::make_tuple(11, 9), (std::tuple<long, long>)std::make_tuple(12, 18), (std::tuple<long, long>)std::make_tuple(15, 12), (std::tuple<long, long>)std::make_tuple(16, 21), (std::tuple<long, long>)std::make_tuple(15, 15)})));\n}\n", "stop_tokens": ["\n}"], "completions": ["```cpp\n#include <vector>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n\n/*\n * Function: find_combinations\n * ---------------------------\n * Given a vector of tuples (a_i , b_i) , we have to find\n * all pairs of tuples that have the *same* sum a_i + b_i.\n *\n * The routine returns a vector of tuples that represent\n * the indices (or the values) that can form those pairs.\n *\n * For example:\n *\n *     test_list = { (1, 5), (3, 3), (4, 2), (2, 4) }\n *\n *     All pairs with equal sums are:\n *\n *         (1,5)+(4,2)  -> 6 + 6\n *         (3,3)+(2,4)  -> 6 + 6\n *\n *     The function will return\n *\n *         { (0,2), (1,3) }          // if we return pairs of indices\n *\n * or alternatively some other representation.\n *\n * The algorithm keeps a hash\u2011map that maps a possible sum\n * to the indices that produced that sum.  Whenever we see\n * a new tuple, we compute its sum and then look for\n * previous indices that had the same sum.  Those pairs are\n * added to the result.\n *\n * Complexity:  O(n) expected time (hash\u2011map) and O(n) space.\n */\n\n\n// --------------------------------------------\n// Result representation ---------------------\n//   In this example we return pairs of indices\n//   in a std::tuple<long,long>.  If you prefer\n//   returning the actual tuples instead of indices,\n//   simply change the type of the return value and\n//   how it is built (see the commented out code).\n// --------------------------------------------\n\nstd::vector<std::tuple<long, long>> find_combinations(\n    const std::vector<std::tuple<long, long>>& test_list)\n{\n    std::unordered_map<long, std::vector<long>> sum_to_indices; // sum -> indices\n    std::vector<std::tuple<long, long>> result;               // pairs of indices\n\n    for (long idx = 0; idx < static_cast<long>(test_list.size()); ++idx) {\n        long a = std::get<0>(test_list[idx]);\n        long b = std::get<1>(test_list[idx]);\n\n        long sum = a + b;\n\n        auto it = sum_to_indices.find(sum);\n        if (it != sum_to_indices.end()) {\n            // All previous indices that had the same sum can pair with idx\n            for (long prev_idx : it->second) {\n                result.emplace_back(prev_idx, idx);\n            }\n            // If you wanted to return the tuples themselves:\n            // for (long prev_idx : it->second)\n            //     result.emplace_back(test_list[prev_idx], test_list[idx]);\n        }\n\n        // Add current index to the list for this sum\n        sum_to_indices[sum].push_back(idx);\n    }\n\n    return result;\n}\n```\n\n**How it works**\n\n1. For every element in `test_list` we compute the sum `a+b`.  \n2. We maintain a hash\u2011map (`sum_to_indices`) from that sum to **all indices** seen so far that produced it.  \n3. When we encounter a new tuple that matches an existing sum, all previous indices in the map are paired with the current one.  \n4. The pairs are appended to `result`.  \n5. Finally the mapping is updated to include the current index.  \n\nThe returned vector contains pairs of indices that produce equal sums. You can easily switch to returning the actual tuples if that is more convenient.", "Below is a **complete, ready\u2011to\u2011use** implementation of a helper that takes a vector of two\u2011element tuples `(x,y)` and returns a vector of tuples that contains every **unique** sum that can be obtained by adding two (not necessarily distinct) tuples from the input.\n\nThe implementation follows the idea described in the GeeksforGeeks article \u2013 iterate over all unordered pairs of indices (including pairs where the indices are the same), compute the point\u2011wise sum of the two tuples, and keep the results in a `std::set` to suppress duplicates. Finally convert the set into a `std::vector` and return it.\n\n```cpp\n#include <vector>\n#include <tuple>\n#include <set>\n#include <algorithm>\n\n/**\n * @brief Generate all unique combinations of sums from a vector of 2\u2011element tuples.\n *\n * For every unordered pair of tuples (including the case where the same tuple\n * is used twice) the function sums the first elements and the second\n * elements separately and stores the result as a tuple `<sum1, sum2>`. The\n * result contains no duplicate tuples.\n *\n * @param test_list Vector of tuples of type <long, long>.\n * @return std::vector<std::tuple<long, long>> All unique sum\u2011tuples.\n *\n * Example\n * -------\n * Input  : { (1,2), (3,4), (1,2) }\n * Pairs  :\n *   (1,2)+(1,2)  -> (2,4)\n *   (1,2)+(3,4)  -> (4,6)\n *   (3,4)+(3,4)  -> (6,8)\n *   (1,2)+(1,2)  -> (2,4)   // duplicate\n * Result : { (2,4), (4,6), (6,8) }\n */\nstd::vector<std::tuple<long, long>>\nfind_combinations(const std::vector<std::tuple<long, long>>& test_list) {\n    // Using a set guarantees uniqueness of the result tuples.\n    std::set<std::tuple<long, long>> result_set;\n\n    const std::size_t n = test_list.size();\n    for (std::size_t i = 0; i < n; ++i) {\n        for (std::size_t j = i; j < n; ++j) {     // unordered pair (i <= j)\n            long x1 = std::get<0>(test_list[i]);\n            long y1 = std::get<1>(test_list[i]);\n            long x2 = std::get<0>(test_list[j]);\n            long y2 = std::get<1>(test_list[j]);\n\n            result_set.emplace(x1 + x2, y1 + y2);\n        }\n    }\n\n    // Convert the set to a vector \u2013 preserves order (sorted by tuple).\n    std::vector<std::tuple<long, long>> result_vec(\n        result_set.begin(), result_set.end());\n\n    return result_vec;\n}\n```\n\n### How to use it\n\n```cpp\nint main() {\n    std::vector<std::tuple<long, long>> input = {\n        {1, 2}, {3, 4}, {1, 2}\n    };\n\n    auto combos = find_combinations(input);\n\n    for (auto& t : combos) {\n        std::cout << \"(\" << std::get<0>(t) << \", \" << std::get<1>(t) << \")\\n\";\n    }\n    return 0;\n}\n```\n\n**Output**\n\n```\n(2, 4)\n(4, 6)\n(6, 8)\n```\n\nFeel free to adapt the function signature or return type to match your project's conventions.", "Below is a **complete, self\u2011contained** implementation of the helper routine that finds *all* possible pair\u2011wise sums of the\ntwo\u2011element tuples that are stored in the incoming vector.  \nThe routine follows the logic described in the GFG article that you linked to:\n\n*For every unordered pair of tuples in the input, form a new tuple whose\ncomponents are the sums of the corresponding components of the pair.*  \nThe resulting vector is then returned.\n\n```cpp\n#include <vector>\n#include <tuple>\n\n/*  Returns all pair\u2011wise sums of the tuples contained in ``test_list``.\n    For each unordered pair (i,j)   (i < j)   from ``test_list``:\n         (a,b) = test_list[i]\n         (c,d) = test_list[j]\n    we push back\n         (a + c , b + d)\n*/\nstd::vector<std::tuple<long, long>>\nfind_combinations(const std::vector<std::tuple<long, long>>& test_list)\n{\n    std::vector<std::tuple<long, long>> result;\n    const std::size_t n = test_list.size();\n\n    for (std::size_t i = 0; i < n; ++i) {\n        const auto [a, b] = test_list[i];\n        for (std::size_t j = i + 1; j < n; ++j) {\n            const auto [c, d] = test_list[j];\n            result.emplace_back(a + c, b + d);\n        }\n    }\n    return result;\n}\n```\n\n### Example\n\n```cpp\nint main()\n{\n    std::vector<std::tuple<long,long>> v =\n    { {1,2}, {3,4}, {5,6} };\n\n    auto comb = find_combinations(v);\n\n    for (auto [x, y] : comb)\n        std::cout << \"(\" << x << \",\" << y << \") \";\n\n    // Output: (4,6) (6,8) (8,10)\n}\n```\n\nThe implementation works in **O(n\u00b2)** time and **O(n\u00b2)** auxiliary space (where *n* is the number of tuples), which is the natural complexity for enumerating all pairwise combinations."]}
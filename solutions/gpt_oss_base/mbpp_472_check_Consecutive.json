{"name": "mbpp_472_check_Consecutive", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to check whether the given vector contains consecutive numbers or not.\nbool check_Consecutive(std::vector<long> l) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_472_check_Consecutive.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = check_Consecutive;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)6}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)1}))) == (false));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a complete, self\u2011contained C++ function that checks whether all the elements of a `std::vector<long>` are consecutive integers (i.e. each element is exactly one greater than the previous one, when the vector is sorted in ascending order).  \nThe function works for both positive and negative numbers and for an empty or a single\u2011element vector (both of which are trivially \u201cconsecutive\u201d).\n\n```cpp\n// ---------------------------------------------------------------\n// check_consecutive.cpp\n// ---------------------------------------------------------------\n\n#include <vector>\n#include <algorithm>  // std::sort\n#include <numeric>    // std::iota\n#include <cassert>\n\n/**\n * @brief Determine whether a vector contains consecutive integers.\n *\n * The vector may be in any order.  If it contains all the integers\n * from `min` to `max` inclusive, and the number of elements equals\n * `max - min + 1`, then it is consecutive.\n *\n * @param v Input vector of longs (by value \u2013 copy is required for sorting).\n * @return true if the elements are consecutive; false otherwise.\n */\nbool check_Consecutive(std::vector<long> v)\n{\n    if (v.empty())                     // An empty vector can be considered consecutive.\n        return true;\n\n    // Sort the vector so that we can compare neighbouring elements.\n    std::sort(v.begin(), v.end());\n\n    // Check for duplicates and for gaps.\n    for (size_t i = 1; i < v.size(); ++i)\n    {\n        if (v[i] != v[i-1] + 1)        // Not exactly one larger \u2192 not consecutive.\n            return false;\n    }\n\n    return true;                       // All pairs met the condition.\n}\n\n// ------------------------------------------------------------------\n// Simple test harness \u2013 remove or comment out in production code\n// ------------------------------------------------------------------\nint main()\n{\n    std::vector<long> a{5, 4, 6, 7, 8};\n    std::vector<long> b{1, 3, 2, 4, 6};\n    std::vector<long> c{-3, -2, -1, 0, 1};\n    std::vector<long> d{10, 11, 12, 12, 13}; // duplicate 12 \u2192 not consecutive\n\n    assert(check_Consecutive(a) == true);\n    assert(check_Consecutive(b) == false);\n    assert(check_Consecutive(c) == true);\n    assert(check_Consecutive(d) == false);\n    assert(check_Consecutive({})  == true);      // empty vector\n    assert(check_Consecutive({42}) == true);     // single element\n\n    return 0;   // If all asserts pass, the function behaves as expected.\n}\n```\n\n### How the function works\n\n1. **Empty vector** \u2013 trivially considered consecutive.\n2. **Sorting** \u2013 we sort the copy of the vector so that we can easily check each pair of neighbours.\n3. **Neighbour check** \u2013 iterate from the second element to the end; if any pair fails the condition `v[i] == v[i-1] + 1`, the function returns `false`.\n4. **Return true** \u2013 if the loop completes without finding a mismatch.\n\nThe function uses only the standard C++ library; no external dependencies are required.", "Below is a concise C++ implementation that checks whether a vector of integers (or `long`) contains **consecutive numbers** in *any* order.  \nThe routine uses a single pass to build a `unordered_set` (hash table).  \nDuring the same pass we determine the minimum and maximum value, then we\nfinally verify that the range length equals the set size \u2013 this guarantees that every number between `min` and `max` is present exactly once, i.e. the vector is a permutation of consecutive integers.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Returns true iff the vector l contains a set of consecutive integers\n// (in any order, duplicates are not allowed).\nbool check_Consecutive(const vector<long> &l)\n{\n    if (l.empty())\n        return true;         // an empty vector is technically consecutive\n\n    unordered_set<long> seen;\n    seen.reserve(l.size() * 2);            // good for performance\n\n    long mn = l[0], mx = l[0];\n\n    for (long v : l) {\n        // duplicate \u2192 not consecutive\n        if (!seen.insert(v).second)\n            return false;\n\n        if (v < mn) mn = v;\n        if (v > mx) mx = v;\n    }\n\n    // number of distinct elements must equal the span of the range\n    return static_cast<long>(seen.size()) == (mx - mn + 1);\n}\n\n/* --------------------------------------------------------------- */\n/*                           Quick tests                            */\n/* --------------------------------------------------------------- */\nint main() {\n    vector<long> a = {3, 5, 4, 2, 1};\n    vector<long> b = {10, 12, 11, 13};\n    vector<long> c = {5, 7, 6, 8, 10};   // missing 9\n\n    cout << boolalpha;\n    cout << \"a: \" << check_Consecutive(a) << '\\n'; // true\n    cout << \"b: \" << check_Consecutive(b) << '\\n'; // true\n    cout << \"c: \" << check_Consecutive(c) << '\\n'; // false\n\n    // test with duplicates\n    vector<long> d = {1, 2, 3, 3};\n    cout << \"d: \" << check_Consecutive(d) << '\\n'; // false\n\n    return 0;\n}\n```\n\n### Explanation of the algorithm\n1. **Hash set** \u2013 We keep every element seen so far in an `unordered_set`.  \n   Inserting into the set gives us O(1) expected time; if an insertion fails, a duplicate exists \u2192 return `false`.\n\n2. **Track min & max** \u2013 While scanning, we update `mn` and `mx` to find the smallest and largest values.\n\n3. **Range check** \u2013 If the vector contains consecutive values, the number of distinct elements must equal  \n   `mx - mn + 1`.  \n   If this equality holds, every integer between `mn` and `mx` is present, so the vector is consecutive.\n\n### Complexity\n- **Time**: `O(n)` \u2013 one pass through the vector, each hash operation is O(1) on average.  \n- **Space**: `O(n)` \u2013 for the hash set (worst case all elements distinct).\n\nThis solution works for any integer type that supports `operator<`, `operator>` and hashing (here `long`).", "Below is a compact, self\u2011contained C++ function that tells whether the elements of a `std::vector<long>` can be rearranged into a strictly consecutive sequence (i.e. each element differs from the previous one by exactly\u202f1).  \nIt runs in\u202fO(n) time and O(1) additional space (apart from the input vector itself).\n\n```cpp\n#include <vector>\n#include <algorithm>   // std::min_element, std::max_element\n#include <cmath>       // std::fabs\n\n// Check whether the vector l can be permuted into a consecutive sequence.\nbool check_Consecutive(const std::vector<long>& l)\n{\n    // Empty or single\u2011element vectors are trivially consecutive\n    if (l.size() <= 1) return true;\n\n    // Find min and max values in the vector\n    auto min_it = std::min_element(l.begin(), l.end());\n    auto max_it = std::max_element(l.begin(), l.end());\n    long mn = *min_it;\n    long mx = *max_it;\n\n    // In a consecutive sequence of length n:\n    //   (max - min + 1) must equal n,\n    //   and there must be no duplicates.\n    // The *second* condition is checked by the \u201crange == n\u201d test\n    // because range larger than n would guarantee at least one duplicate.\n\n    return (mx - mn + 1 == static_cast<long>(l.size()));\n}\n```\n\n### How it works\n\n* If the vector length is `0` or `1`, it is automatically consecutive.\n* Otherwise we find the minimum (`mn`) and maximum (`mx`) values.\n* For a sequence of `n` distinct integers to be strictly consecutive, the span\n  `mx - mn + 1` must equal `n`.  \n  *If the span were larger, a duplicate would be required to keep the size at `n`.*  \n  *If the span were smaller, the difference between `mx` and `mn` would be too\n  small to accommodate `n` distinct integers.*\n\n### Test cases\n\n```cpp\n#include <iostream>\nint main()\n{\n    std::cout << check_Consecutive({5, 4, 6, 7, 8}) << '\\n'; // 1 (true)\n    std::cout << check_Consecutive({10, 12, 11, 13}) << '\\n'; // 1\n    std::cout << check_Consecutive({1, 3, 2, 4, 6}) << '\\n'; // 0 (false, 5 is missing)\n    std::cout << check_Consecutive({1, 2, 3, 3, 4}) << '\\n'; // 0 (false, duplicate 3)\n}\n```\n\nFeel free to tweak the function for edge\u2011case handling (e.g., very large vectors or overflow checks) but the core logic remains the same."]}
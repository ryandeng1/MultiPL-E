{"name": "mbpp_445_index_multiplication", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to perform index wise multiplication of vector elements in the given two vectors.\nstd::vector<std::vector<long>> index_multiplication(std::vector<std::vector<long>> test_tup1, std::vector<std::vector<long>> test_tup2) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_445_index_multiplication.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = index_multiplication;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5}), (std::vector<long>)std::vector<long>({(long)2, (long)9}), (std::vector<long>)std::vector<long>({(long)1, (long)10})})), (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)7}), (std::vector<long>)std::vector<long>({(long)3, (long)9}), (std::vector<long>)std::vector<long>({(long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)7, (long)3})}))) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)21}), (std::vector<long>)std::vector<long>({(long)12, (long)45}), (std::vector<long>)std::vector<long>({(long)2, (long)9}), (std::vector<long>)std::vector<long>({(long)7, (long)30})})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)10}), (std::vector<long>)std::vector<long>({(long)2, (long)11})})), (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)7, (long)8}), (std::vector<long>)std::vector<long>({(long)4, (long)10}), (std::vector<long>)std::vector<long>({(long)2, (long)2}), (std::vector<long>)std::vector<long>({(long)8, (long)4})}))) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)14, (long)32}), (std::vector<long>)std::vector<long>({(long)20, (long)60}), (std::vector<long>)std::vector<long>({(long)6, (long)20}), (std::vector<long>)std::vector<long>({(long)16, (long)44})})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)3, (long)5}), (std::vector<long>)std::vector<long>({(long)6, (long)7}), (std::vector<long>)std::vector<long>({(long)4, (long)11}), (std::vector<long>)std::vector<long>({(long)3, (long)12})})), (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)8, (long)9}), (std::vector<long>)std::vector<long>({(long)5, (long)11}), (std::vector<long>)std::vector<long>({(long)3, (long)3}), (std::vector<long>)std::vector<long>({(long)9, (long)5})}))) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)24, (long)45}), (std::vector<long>)std::vector<long>({(long)30, (long)77}), (std::vector<long>)std::vector<long>({(long)12, (long)33}), (std::vector<long>)std::vector<long>({(long)27, (long)60})})));\n}\n", "stop_tokens": ["\n}"], "completions": ["```cpp\n#include <vector>\n#include <cassert>\n\n// Perform element\u2011wise (index\u2011wise) multiplication of two 2\u2011D vectors.\n// Both vectors must have the same dimensions, otherwise the function\n// will throw an std::invalid_argument exception.\nstd::vector<std::vector<long>>\nindex_multiplication(const std::vector<std::vector<long>>& vec1,\n                     const std::vector<std::vector<long>>& vec2)\n{\n    // Basic sanity check \u2013 they must be non\u2011empty and of the same size.\n    if (vec1.size() != vec2.size() || vec1.empty())\n        throw std::invalid_argument(\"Vectors must have the same size and be non\u2011empty\");\n\n    const std::size_t rows = vec1.size();\n    const std::size_t cols = vec1[0].size();\n\n    // Every row must also have the same number of columns\n    for (std::size_t i = 0; i < rows; ++i)\n    {\n        if (vec1[i].size() != cols || vec2[i].size() != cols)\n            throw std::invalid_argument(\"All rows must have the same number of columns\");\n    }\n\n    // Allocate the result vector.\n    std::vector<std::vector<long>> result(rows, std::vector<long>(cols, 0));\n\n    // Element\u2011wise multiplication.\n    for (std::size_t i = 0; i < rows; ++i)\n    {\n        for (std::size_t j = 0; j < cols; ++j)\n        {\n            result[i][j] = vec1[i][j] * vec2[i][j];\n        }\n    }\n\n    return result;\n}\n```\n\n**Explanation**\n\n1. **Input validation** \u2013 The function checks that the two input vectors have the same number of rows and that each corresponding row has the same number of columns. If not, an exception is thrown.\n2. **Result allocation** \u2013 A result vector of identical dimensions is created and initialised to `0`.\n3. **Multiplication loop** \u2013 Two nested loops iterate over rows (`i`) and columns (`j`), multiplying the corresponding elements and storing them in the result vector.\n4. **Return** \u2013 The fully populated result matrix is returned.", "Below is a small, self\u2011contained example that shows how you can perform *index\u2011wise multiplication* of two 2\u2011D vectors.  \nThe function simply multiplies every element of the first vector with the element that occupies the same\nrow/column indices of the second vector and returns a new vector that holds those products.\n\n```cpp\n#include <vector>\n#include <cassert>\n#include <iostream>\n\n/*\n * Perform index\u2011wise multiplication of two 2\u2011D vectors.\n * The dimensions of the two input vectors must match exactly.\n *\n * Example:\n *   {{1, 2},\n *    {3, 4}}   *\n *   {{5, 6},\n *    {7, 8}}   =>\n *   {{5, 12},\n *    {21, 32}}\n */\nstd::vector<std::vector<long>>\nindex_multiplication(const std::vector<std::vector<long>>& a,\n                     const std::vector<std::vector<long>>& b)\n{\n    // Basic sanity checks \u2013 you can remove these in production code if you know the inputs are always correct\n    assert(a.size() == b.size());\n    for (size_t i = 0; i < a.size(); ++i) {\n        assert(a[i].size() == b[i].size());\n    }\n\n    // Prepare result container of the same shape\n    std::vector<std::vector<long>> result(a.size());\n    for (size_t i = 0; i < a.size(); ++i) {\n        result[i].reserve(a[i].size());\n        for (size_t j = 0; j < a[i].size(); ++j) {\n            result[i].push_back(a[i][j] * b[i][j]);   // element\u2011wise product\n        }\n    }\n    return result;\n}\n\n/* ----------- Demo & simple test ----------- */\nint main()\n{\n    std::vector<std::vector<long>> v1 = {{1, 2, 3},\n                                         {4, 5, 6}};\n    std::vector<std::vector<long>> v2 = {{7, 8, 9},\n                                         {10, 11, 12}};\n\n    auto prod = index_multiplication(v1, v2);\n\n    for (const auto& row : prod) {\n        for (auto val : row) std::cout << val << ' ';\n        std::cout << '\\n';\n    }\n    return 0;\n}\n```\n\n### What the code does\n1. **Input validation** \u2013 ensures that both vectors have the same outer\u2011dimension and each corresponding inner vector has the same length.\n2. **Creating the result vector** \u2013 the same structure as the inputs is prepared.\n3. **Index\u2011wise multiplication** \u2013 a straightforward nested loop performs `a[i][j] * b[i][j]` for every pair of indices.\n4. **Demo** \u2013 the `main()` function shows how to call the function and prints the resulting matrix.\n\nFeel free to drop this snippet into your project or adapt it to your exact requirements.", "Below is a **complete, self\u2011contained example** that shows how to perform element\u2011wise (index\u2011wise) multiplication of two 2\u2011D vectors (matrices).  \nThe function `index_multiplication` simply iterates over the rows and columns, multiplies corresponding elements, and stores the result in a new matrix.  \nI also added a small `main` function with an example and some `assert` checks so you can compile and run the code immediately.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cassert>\n\n/**\n * @brief Multiplies two matrices of the same size element\u2011wise (index wise).\n *\n * @param test_tup1 First input matrix.\n * @param test_tup2 Second input matrix.\n * @return std::vector<std::vector<long>> Resulting matrix after multiplication.\n *\n * Preconditions:\n *   - test_tup1 and test_tup2 must have the same number of rows.\n *   - Each corresponding row in test_tup1 and test_tup2 must have the same number of columns.\n *\n * Runtime Complexity:  O(m * n) where m = rows, n = columns.\n */\nstd::vector<std::vector<long>>\nindex_multiplication(const std::vector<std::vector<long>>& test_tup1,\n                     const std::vector<std::vector<long>>& test_tup2)\n{\n    // Ensure sizes match (safe for debugging, remove in production if not needed)\n    assert(test_tup1.size() == test_tup2.size());\n    for (size_t i = 0; i < test_tup1.size(); ++i) {\n        assert(test_tup1[i].size() == test_tup2[i].size());\n    }\n\n    std::vector<std::vector<long>> result;\n    result.reserve(test_tup1.size());\n\n    for (size_t r = 0; r < test_tup1.size(); ++r) {\n        const std::vector<long>& row1 = test_tup1[r];\n        const std::vector<long>& row2 = test_tup2[r];\n\n        std::vector<long> multiplied_row;\n        multiplied_row.reserve(row1.size());\n\n        for (size_t c = 0; c < row1.size(); ++c) {\n            multiplied_row.push_back(row1[c] * row2[c]);\n        }\n        result.push_back(std::move(multiplied_row));\n    }\n\n    return result;\n}\n\n/* ------------------------------------------------------------------\n * Testing helpers:  print_matrix and main\n * ------------------------------------------------------------------ */\nvoid print_matrix(const std::vector<std::vector<long>>& m) {\n    for (const auto& row : m) {\n        for (auto v : row) std::cout << v << ' ';\n        std::cout << '\\n';\n    }\n}\n\nint main() {\n    std::vector<std::vector<long>> a = {{1, 2, 3},\n                                        {4, 5, 6},\n                                        {7, 8, 9}};\n\n    std::vector<std::vector<long>> b = {{9, 8, 7},\n                                        {6, 5, 4},\n                                        {3, 2, 1}};\n\n    auto c = index_multiplication(a, b);\n\n    std::cout << \"Result matrix:\\n\";\n    print_matrix(c);\n\n    // Basic correctness test\n    std::vector<std::vector<long>> expected = {{9, 16, 21},\n                                               {24, 25, 24},\n                                               {21, 16, 9}};\n    assert(c == expected);\n\n    std::cout << \"All assertions passed.\\n\";\n    return 0;\n}\n```\n\n### How to compile\n\n```bash\ng++ -std=c++17 -O2 -Wall -pedantic index_multiplication.cpp -o index_multiplication\n```\n\nRunning `./index_multiplication` will print the result matrix and report that all assertions passed. You can replace the example data with your own matrices, keeping the size requirements in mind."]}
{"name": "HumanEval_68_pluck", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_68_pluck.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0, (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4, (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7, (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1}))) == (std::vector<long>()));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a minimal, well\u2011commented implementation that follows the specification and will compile with a standard C++17 compiler:  \n\n```cpp\n#include <vector>\n\n// -----------------------------------------------------------------------------\n// Return the smallest even node from the vector \"arr\" together with its index.\n// If there is no even node or the vector is empty, return an empty vector.\n// The returned vector contains two elements:\n//   [ smallest_even_value , index_of_that_value ].\n// In case of ties on the value, the first (smallest index) is chosen.\n//\n// Example:\n//   arr = {4, 2, 3}          ->  {2, 1}\n//   arr = {1, 2, 3}          ->  {2, 1}\n//   arr = {}                 ->  {}\n//   arr = {5, 0, 3, 0, 4, 2} ->  {0, 1}\n// -----------------------------------------------------------------------------\nstd::vector<long> pluck(const std::vector<long>& arr)\n{\n    // If the input vector is empty we can immediately return an empty vector.\n    if (arr.empty()) {\n        return {};\n    }\n\n    // Variables to keep track of the candidate.\n    long bestValue = LLONG_MAX;   // something definitely larger than any possible value.\n    std::size_t bestIndex = 0;    // index of the current candidate.\n\n    bool found = false;  // whether we have found at least one even value.\n\n    // Scan once through the vector.\n    for (std::size_t i = 0; i < arr.size(); ++i) {\n        long val = arr[i];\n\n        // Only consider even values.\n        if (val % 2 == 0) {\n            if (!found) {                       // first even seen.\n                bestValue = val;\n                bestIndex = i;\n                found = true;\n            } else {\n                // If this even value is smaller than the current best,\n                // or equal but with a smaller index (the loop guarantees the\n                // smaller index case automatically), update the candidate.\n                if (val < bestValue) {\n                    bestValue = val;\n                    bestIndex = i;\n                }\n                // No need to check equal case separately \u2013 the loop\n                // visits indices in increasing order, so the first one\n                // encountered will always have the smallest index.\n            }\n        }\n    }\n\n    if (!found) {\n        // No even number was found.\n        return {};\n    }\n\n    // Return the result as specified: {value, index}.\n    return {bestValue, static_cast<long>(bestIndex)};\n}\n```\n\n### Why this works\n\n1. **Single Pass** \u2013 We traverse the vector only once, keeping the best candidate seen so far.  \n2. **Tie\u2011breaking** \u2013 Because we scan indices in ascending order, the first occurrence of a value is automatically the smallest index; we only replace the stored index when we encounter a strictly smaller even value.  \n3. **Edge Cases** \u2013  \n   * Empty input \u2192 returns `[]`.  \n   * No even numbers \u2192 returns `[]`.  \n   * Zero values are treated normally (they are even).  \n\nFeel free to drop the helper function into your project directly.", "Below is a complete, self\u2011contained implementation of the `pluck` function that satisfies the specifications described in the prompt.  \nThe implementation is written in C++17 and makes no external dependencies except the standard library.\n\n```cpp\n#include <vector>\n#include <limits>\n\n/**\n * @brief Returns the smallest even valued node together with its index.\n *\n * @param arr Vector of non\u2011negative integers representing the nodes of a branch.\n * @return std::vector<long> containing the smallest even value and its index.\n *         If there is no suitable node (or the input vector is empty), an empty vector is returned.\n */\nstd::vector<long> pluck(std::vector<long> arr)\n{\n    // Result vector will hold [value, index].\n    std::vector<long> result;\n\n    // Guard for empty input.\n    if (arr.empty()) {\n        return result;               // Empty result.\n    }\n\n    // Initialise best candidate with the largest possible long value.\n    long best_value = std::numeric_limits<long>::max();\n    long best_index = -1;                           // Will become valid when an even number is found.\n\n    // Linear scan of the input vector.\n    for (long i = 0; i < static_cast<long>(arr.size()); ++i) {\n        long val = arr[i];\n\n        // Skip odd numbers; only consider evens.\n        if ((val & 1LL) != 0) {                 // val % 2 != 0\n            continue;\n        }\n\n        // Update best candidate if:\n        //  - this even value is strictly smaller than the current best,  or\n        //  - it equals the current best but appears earlier (smaller index).\n        if (val < best_value || (val == best_value && i < best_index)) {\n            best_value = val;\n            best_index = i;\n        }\n    }\n\n    // If no even number was found, best_index will stay -1.\n    if (best_index == -1) {\n        return result;                           // No even node found \u2192 empty vector.\n    }\n\n    // Populate the result vector with the required output format.\n    result.push_back(best_value);\n    result.push_back(best_index);\n    return result;\n}\n```\n\n### How it works\n\n1. **Edge Cases**  \n   * If the input vector is empty, return an empty vector immediately.  \n   * If no even numbers are found after the scan, return an empty vector as well.\n\n2. **Scanning**  \n   * Iterate through the input vector once (`O(n)` time).  \n   * For every even value, compare it with the current best candidate.\n\n3. **Selection Rules**  \n   * **Smaller value** \u2192 new candidate.  \n   * **Same value but smaller index** \u2192 new candidate (since we iterate from left to right, the first occurrence will naturally have the smallest index, but the check is kept for clarity).\n\n4. **Return**  \n   * If a candidate exists, push its value and index into the result vector.  \n   * The expected output format is `[smallest_evens_value, index]`.\n\n### Example Usages\n\n```cpp\nauto a = pluck(std::vector<long>({4, 2, 3}));          // {2, 1}\nauto b = pluck(std::vector<long>({1, 2, 3}));          // {2, 1}\nauto c = pluck(std::vector<long>());                   // {}\nauto d = pluck(std::vector<long>({5, 0, 3, 0, 4, 2}));// {0, 1}\n```\n\nThese match exactly the examples given in the prompt.", "Here\u2019s a concise, self\u2011contained implementation that follows the rules you described and compiles with any modern C++ compiler.\n\n```cpp\n#include <vector>\n#include <limits>\n\n/*  pluck\n *\n *  Find the smallest even value in the vector `arr` and return\n *  a vector containing that value and its index.  If the vector\n *  is empty or contains no even numbers, an empty vector is returned.\n *\n *  Parameters\n *  ----------\n *  arr : std::vector<long>\n *\n *  Returns\n *  -------\n *  std::vector<long>\n *      - []                         if no even numbers or arr is empty\n *      - [even_value, index]        otherwise (even_value, index)\n */\nstd::vector<long> pluck(std::vector<long> arr)\n{\n    if (arr.empty())\n        return {};\n\n    long best_val   = std::numeric_limits<long>::max();\n    size_t best_idx = std::size_t(-1);        // sentinel\n\n    for (size_t i = 0; i < arr.size(); ++i)\n    {\n        long v = arr[i];\n        if (v % 2 == 0)                         // even?\n        {\n            if (v < best_val ||                // smaller value\n                (v == best_val && i < best_idx)) // same value, smaller index\n            {\n                best_val = v;\n                best_idx = i;\n            }\n        }\n    }\n\n    if (best_idx == std::size_t(-1))            // no even number found\n        return {};\n\n    return {best_val, static_cast<long>(best_idx)};\n}\n```\n\n**How it works**\n\n1. We iterate once over the vector.\n2. For each even element we:\n   * keep it if it\u2019s smaller than the current best even value,\n   * or, if equal to the best value, keep it only if its index is smaller.\n3. At the end, if we never found an even value we return an empty vector;\n   otherwise we return a two\u2011element vector containing the value and the index.\n\n**Compiling**\n\n```bash\ng++ -std=c++17 -O2 -pipe -o pluck pluck.cpp\n```\n\nFeel free to integrate it into your project!"]}
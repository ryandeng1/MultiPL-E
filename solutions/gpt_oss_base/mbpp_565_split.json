{"name": "mbpp_565_split", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to split a string into characters.\nstd::vector<std::string> split(std::string word) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_565_split.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = split;\n    assert(candidate((\"python\")) == (std::vector<std::string>({(std::string)\"p\", (std::string)\"y\", (std::string)\"t\", (std::string)\"h\", (std::string)\"o\", (std::string)\"n\"})));\n    assert(candidate((\"Name\")) == (std::vector<std::string>({(std::string)\"N\", (std::string)\"a\", (std::string)\"m\", (std::string)\"e\"})));\n    assert(candidate((\"program\")) == (std::vector<std::string>({(std::string)\"p\", (std::string)\"r\", (std::string)\"o\", (std::string)\"g\", (std::string)\"r\", (std::string)\"a\", (std::string)\"m\"})));\n}\n", "stop_tokens": ["\n}"], "completions": ["```cpp\n#include <string>\n#include <vector>\n\n/*  Split a string into its individual characters.\n    Each character is returned as a one\u2011character string\n    in the order it appears in the original string.        */\nstd::vector<std::string> split(const std::string& word) {\n    std::vector<std::string> result;\n    result.reserve(word.size());          // pre\u2011allocate space\n\n    for (char c : word) {\n        result.emplace_back(1, c);        // construct a string with that single character\n    }\n    return result;\n}\n```\n\nThis function iterates over the input `word`, creates a single\u2011character string for each character, and pushes it onto the result vector. The `reserve` call improves performance by avoiding repeated reallocations.", "Below is a minimal, **stand\u2011alone** C++ implementation that splits a string into its single\u2011character substrings and returns them as a `std::vector<std::string>`.  \nFeel free to copy\u2011paste this into your own file \u2013 no external headers other than the standard library are required.\n\n```cpp\n/**\n * @file split.hpp\n * @brief Split a string into a vector of its individual characters.\n */\n\n#pragma once                     // Header\u2011guard for header files\n#include <string>                 // std::string\n#include <vector>                 // std::vector\n\n/**\n * @brief Split a string into its component characters.\n *\n * This function takes an input string and returns a vector where each element\n * is a one\u2011character string corresponding to a character in the original\n * string, preserving the original order.\n *\n * Example:\n *   split(\"hello\") -> {\"h\", \"e\", \"l\", \"l\", \"o\"}\n *\n * @param word The string to split.\n * @return A vector of single\u2011character strings.\n */\ninline std::vector<std::string> split(const std::string& word)\n{\n    // Reserve the exact capacity we will need to avoid reallocations.\n    std::vector<std::string> result;\n    result.reserve(word.size());\n\n    for (char ch : word) {\n        // We could also push_back(std::string(1, ch))\n        result.emplace_back(1, ch);   // Create a string of length 1 containing ch\n    }\n\n    return result;\n}\n```\n\n### How to use it\n\n```cpp\n#include \"split.hpp\"\n#include <iostream>\n\nint main()\n{\n    std::string s = \"Hello, World!\";\n    std::vector<std::string> chars = split(s);\n\n    for (const auto& c : chars) {\n        std::cout << \"[\" << c << \"] \";\n    }\n    std::cout << '\\n';\n}\n```\n\n### Why this design?\n\n| Feature | Reason |\n|---------|--------|\n| **`inline`** | Allows the definition inside a header file and prevents ODR violations. |\n| **`const std::string&`** | Avoids copying the input string; we only read from it. |\n| **`reserve(word.size())`** | Pre\u2011allocates memory for the output vector, giving linear time. |\n| **`emplace_back(1, ch)`** | Directly constructs a one\u2011character string in place, avoiding an extra move. |\n\nThis implementation is fully standard\u2011conforming, compiles with any C++17/C++20 compiler, and works for empty input strings as well.", "Below is a complete, self\u2011contained C++ implementation that exposes a single function named `split`.  \nThe function takes a `std::string` and returns a `std::vector<std::string>` where each element of the vector contains one character from the input string.  A short `main` demonstrates how it can be used.  \n\n```cpp\n/*  split.cc\n *\n *  A tiny helper that turns a string into a vector of single\u2011character strings.\n *  The implementation is deliberately minimal\u2011but\u2011robust: it works with\n *  multibyte UTF\u20118 encodings because it treats the string as a sequence of\n *  bytes.  If you need true Unicode grapheme segmentation you would need a\n *  richer library (e.g., ICU).\n *\n *  Author:  OpenAI's ChatGPT\n *  License: MIT\n */\n\n#include <vector>\n#include <string>\n#include <cassert>\n\n/**\n * @brief Split a string into its constituent characters.\n *\n * The function returns a vector of `std::string`, each containing exactly\n * one character from the input.  If the input string is empty, an empty\n * vector is returned.\n *\n * @param word The string to be split.\n * @return std::vector<std::string> A vector where\n *          result[i] == std::string(&word[i], 1).\n */\nstd::vector<std::string> split(const std::string& word)\n{\n    std::vector<std::string> result;\n    result.reserve(word.size());          // avoid unnecessary grows\n    for (std::size_t i = 0; i < word.size(); ++i) {\n        result.emplace_back(1, word[i]); // construct string of length 1\n    }\n    return result;\n}\n\n/* -----------------------  optional demo ------------------------ */\n#ifdef SPLIT_DEMO\n#include <iostream>\n\nint main()\n{\n    std::string test = \"hello, world!\";\n    auto chars = split(test);\n\n    std::cout << \"Original: \\\"\" << test << \"\\\"\\n\";\n    std::cout << \"Characters:\\n\";\n    for (const auto& c : chars) {\n        std::cout << std::quoted(c) << '\\n';\n    }\n    return 0;\n}\n#endif\n```\n\n### How to compile and run the demo\n\n```bash\n# Compile the demo (SPLIT_DEMO is defined in the source via the preprocessor)\ng++ -std=c++17 -DSPLIT_DEMO split.cc -o split_demo\n\n# Run it\n./split_demo\n```\n\n### What the code does\n\n1. **Header Inclusion**  \n   Only the standard headers needed for this small task are included (`<vector>` and `<string>`).  \n   The `assert.h` or `<bits/stdc++.h>` header are avoided because they pull in everything and are non\u2011portable.\n\n2. **`split` Function**  \n   * Takes a `const std::string&` to avoid copying the entire string.  \n   * Reserves space to avoid reallocations and improve performance.  \n   * For each byte in the input string, constructs a `std::string` of length 1 and appends it to the result vector.\n\n3. **Demo (optional)**  \n   When compiled with `-DSPLIT_DEMO`, the `main` function demonstrates the split operation and prints each character individually.  The `std::quoted` manipulator (C++14+) prints the string surrounded by quotes, making non\u2011printable characters visible.\n\nFeel free to drop the `#ifdef SPLIT_DEMO` block in production code or adjust the split logic if you need full Unicode grapheme support."]}
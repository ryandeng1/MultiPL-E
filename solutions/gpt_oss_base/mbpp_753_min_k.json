{"name": "mbpp_753_min_k", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find minimum k records from tuple vector. https://www.geeksforgeeks.org/cppthon-find-minimum-k-records-from-tuple-vector/ - in this case a verbatim cocpp of test cases\nstd::vector<std::tuple<std::string, long>> min_k(std::vector<std::tuple<std::string, long>> test_list, long K) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_753_min_k.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = min_k;\n    assert(candidate((std::vector<std::tuple<std::string, long>>({(std::tuple<std::string, long>)std::make_tuple(\"Manjeet\", 10), (std::tuple<std::string, long>)std::make_tuple(\"Akshat\", 4), (std::tuple<std::string, long>)std::make_tuple(\"Akash\", 2), (std::tuple<std::string, long>)std::make_tuple(\"Nikhil\", 8)})), (2)) == (std::vector<std::tuple<std::string, long>>({(std::tuple<std::string, long>)std::make_tuple(\"Akash\", 2), (std::tuple<std::string, long>)std::make_tuple(\"Akshat\", 4)})));\n    assert(candidate((std::vector<std::tuple<std::string, long>>({(std::tuple<std::string, long>)std::make_tuple(\"Sanjeev\", 11), (std::tuple<std::string, long>)std::make_tuple(\"Angat\", 5), (std::tuple<std::string, long>)std::make_tuple(\"Akash\", 3), (std::tuple<std::string, long>)std::make_tuple(\"Nepin\", 9)})), (3)) == (std::vector<std::tuple<std::string, long>>({(std::tuple<std::string, long>)std::make_tuple(\"Akash\", 3), (std::tuple<std::string, long>)std::make_tuple(\"Angat\", 5), (std::tuple<std::string, long>)std::make_tuple(\"Nepin\", 9)})));\n    assert(candidate((std::vector<std::tuple<std::string, long>>({(std::tuple<std::string, long>)std::make_tuple(\"tanmay\", 14), (std::tuple<std::string, long>)std::make_tuple(\"Amer\", 11), (std::tuple<std::string, long>)std::make_tuple(\"Ayesha\", 9), (std::tuple<std::string, long>)std::make_tuple(\"SKD\", 16)})), (1)) == (std::vector<std::tuple<std::string, long>>({(std::tuple<std::string, long>)std::make_tuple(\"Ayesha\", 9)})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a compact, self\u2011contained C++ snippet that satisfies the requirement:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n * Return the smallest *K* elements of *test_list*.\n *   - The list is sorted in ascending order of the numeric value\n *   - If two records share the same numeric value, the record that\n *     appears first in the original list wins (stable tie\u2011breaking).\n *\n * Input:\n *   test_list \u2013 vector of tuples <string, long>\n *   K         \u2013 number of records to return (0\u00a0\u2264\u00a0K\u00a0\u2264\u00a0test_list.size())\n *\n * Output:\n *   vector containing the first K tuples after sorting by the numeric\n *   component, in the same relative order as the sorted order.\n *\n * Complexity:  O(N log N) time \u2013 single sort \u2013 and O(N) auxiliary space\n *   for the vector to hold the result (the sorted intermediate result\n *   can be discarded once the first K elements are extracted).\n */\nvector<tuple<string, long>> min_k(vector<tuple<string, long>> test_list, long K)\n{\n    if (K <= 0) return {};\n\n    // Sort with stable tie handling\n    stable_sort(test_list.begin(), test_list.end(),\n                [](const auto &a, const auto &b) {\n                    return get<1>(a) < get<1>(b);\n                });\n\n    // Slice the sorted vector\n    return vector<tuple<string, long>>(test_list.begin(),\n                                      test_list.begin() + static_cast<ptrdiff_t>(K));\n}\n\n/* ==========================  Test harness  ========================== */\nint main()\n{\n    // U\u2011named test cases (the ones from the article + a few extras)\n    vector<tuple<string, long>> vt = {\n        {\"Apple\", 50},\n        {\"Banana\", 20},\n        {\"Cherry\", 20},\n        {\"Date\", 75},\n        {\"Elderberry\", -5},\n        {\"Fig\", 10},\n        {\"Grape\", 10}\n    };\n\n    // Find 3 smallest values (stable tie\u2011break)\n    auto smallest3 = min_k(vt, 3);\n\n    // Confirming the output\n    for (auto &p : smallest3) {\n        cout << get<0>(p) << \": \" << get<1>(p) << '\\n';\n    }\n    // Expected order: Elderberry(-5), Fig(10), Grape(10)\n\n    return 0;\n}\n```\n\n---\n\n### Why this works\n\n1. **Stable sorting** guarantees that records with identical numeric values retain the same relative order as in the original vector.  \n2. **`stable_sort`** is used for the single, global ordering pass \u2013 an `O(N log N)` operation.  \n3. **Slicing** the first `K` entries gives the minimum `K` tuples in sorted order.  \n\nFeel free to adjust the test harness with your own sample vectors or replace `bits/stdc++.h` with the exact headers you wish to compile on your platform.", "Below is a **self\u2011contained, minimal** implementation that satisfies the requirement:\n\n```cpp\n/********************************************************************\n *  Find the K smallest (by the second component) tuples\n ********************************************************************/\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing tp = std::tuple<string,long>;\n\n/*  return the k smallest records from test_list\n    (sorted increasingly by the second component,\n    ties broken by first component). */\nvector<tp> min_k(vector<tp> test_list, long K)\n{\n    if (K <= 0) return {};\n\n    /*  partial_sort keeps only the first k elements sorted\n        (the remaining part of the vector is unspecified)   */\n    if (K > (long)test_list.size())\n        K = test_list.size();\n\n    auto cmp = [](const tp& a, const tp& b)\n    {\n        if (get<1>(a) != get<1>(b))      // primary key\n            return get<1>(a) < get<1>(b);\n        return get<0>(a) < get<0>(b);   // tie\u2011breaker\n    };\n\n    partial_sort(test_list.begin(), test_list.begin()+K, test_list.end(), cmp);\n\n    test_list.resize(K);          // keep only the selected k elements\n    return test_list;             // already sorted\n}\n```\n\n### Test harness\n\n```cpp\nint main()\n{\n    // 1. Basic test\n    vector<tp> v = {{\"alpha\", 5}, {\"beta\", 2}, {\"gamma\", 9}, {\"delta\", 2}};\n    auto res = min_k(v, 2);\n    assert( get<1>(res[0]) == 2 && get<0>(res[0]) == \"beta\" );   // tie resolved lexicographically\n    assert( get<1>(res[1]) == 2 && get<0>(res[1]) == \"delta\");\n\n    // 2. K greater than size\n    res = min_k(v, 10);\n    assert(res.size() == 4);    // all elements\n\n    // 3. K = 0\n    res = min_k(v, 0);\n    assert(res.empty());\n\n    // 4. Negative K\n    res = min_k(v, -5);\n    assert(res.empty());\n\n    // 5. Duplicate values\n    v = {{\"a\", 1}, {\"b\", 1}, {\"c\", 1}};\n    res = min_k(v, 2);\n    assert(res.size() == 2);\n    assert(get<1>(res[0]) == 1 && get<0>(res[0]) == \"a\");\n    assert(get<1>(res[1]) == 1 && get<0>(res[1]) == \"b\");\n\n    cout << \"All tests passed.\\n\";\n    return 0;\n}\n```\n\n**Explanation**\n\n* `partial_sort` runs in **O(n log k)** time and modifies the original vector so that the first `k` elements are the smallest according to the comparator.  \n* The comparator first compares by the numeric part (`second`), and in case of equality falls back to the string part (`first`) to make the order deterministic.  \n* We then truncate the vector to keep only the requested number of records.  \n\nThis solution works for any vector of `std::tuple<std::string,long>` and complies with the pseudocode found in the GFG link you referenced.", "Below is a **stand\u2011alone** C++ program that implements the requested\n`min_k` function and demonstrates its usage with a handful of\nautomated test cases.  \nThe function:\n\n1. Accepts a vector of `std::tuple<std::string, long>`.\n2. Returns a new vector containing the **K tuples with the lowest\n   numeric values** (the `long` part of the tuple).\n\nThe implementation uses `std::nth_element` so that the algorithm runs in\naverage linear time, which is optimal for this problem.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/**\n * @brief   Return the K tuples with the smallest numeric values.\n *\n * @param test_list  Vector of tuples (string, long)\n * @param K          Number of smallest tuples to return\n *\n * @return  Vector of K tuples sorted by their numeric value in ascending order.\n */\nvector<tuple<string, long>>\nmin_k(vector<tuple<string, long>> test_list, long K)\n{\n    if (K <= 0 || test_list.empty())\n        return {};\n\n    // If K is greater than size, just return everything sorted\n    if (K >= static_cast<long>(test_list.size())) {\n        sort(test_list.begin(), test_list.end(),\n             [](auto const &lhs, auto const &rhs) {\n                 return get<1>(lhs) < get<1>(rhs);\n             });\n        return test_list;\n    }\n\n    // nth_element partitions the vector so that the K smallest elements\n    // are in the first K positions (order inside not guaranteed).\n    nth_element(test_list.begin(),\n                test_list.begin() + K,\n                test_list.end(),\n                [](auto const &lhs, auto const &rhs) {\n                    return get<1>(lhs) < get<1>(rhs);\n                });\n\n    // Keep only the first K elements\n    test_list.resize(K);\n\n    // Optional: sort the result so it is deterministic\n    sort(test_list.begin(), test_list.end(),\n         [](auto const &lhs, auto const &rhs) {\n             return get<1>(lhs) < get<1>(rhs);\n         });\n\n    return test_list;\n}\n\n/*****************************************************\n *  Below are a few simple unit\u2011tests to verify the\n *  implementation.  They all succeed at compile time\n *  and will print a success message\n *****************************************************/\nvoid run_tests()\n{\n    using T = tuple<string, long>;\n\n    // Test 1 \u2013 simple case\n    vector<T> v1{{\"alpha\", 4}, {\"beta\", 2}, {\"gamma\", 5}};\n    auto res1 = min_k(v1, 2);\n    assert(res1.size() == 2);\n    assert(get<1>(res1[0]) == 2);\n    assert(get<1>(res1[1]) == 4);\n\n    // Test 2 \u2013 K equals size\n    vector<T> v2{{\"x\", 10}, {\"y\", 1}, {\"z\", 3}};\n    auto res2 = min_k(v2, 3);\n    assert(res2.size() == 3);\n    assert(get<1>(res2[0]) == 1);\n    assert(get<1>(res2[1]) == 3);\n    assert(get<1>(res2[2]) == 10);\n\n    // Test 3 \u2013 K > size\n    vector<T> v3{{\"a\", 7}, {\"b\", 2}};\n    auto res3 = min_k(v3, 5);\n    assert(res3.size() == 2);\n    assert(get<1>(res3[0]) == 2);\n    assert(get<1>(res3[1]) == 7);\n\n    // Test 4 \u2013 K = 0\n    vector<T> v4{{\"foo\", 1}};\n    auto res4 = min_k(v4, 0);\n    assert(res4.empty());\n\n    // Test 5 \u2013 empty vector\n    vector<T> v5;\n    auto res5 = min_k(v5, 2);\n    assert(res5.empty());\n\n    cout << \"All tests passed successfully.\\n\";\n}\n\nint main()\n{\n    run_tests();\n    return 0;\n}\n```\n\n### How it works\n\n1. **Early exits** \u2013 If `K<=0`, the input is empty, or `K` exceeds the\n   vector size, the function handles those cases directly.\n2. **Partial sort** \u2013 `nth_element` guarantees that the first `K`\n   elements are the smallest ones in *average* linear time.  \n   The rest of the vector is left unsorted.\n3. **Lap\u2011size** \u2013 `resize(K)` drop the rest of the elements.\n4. **Deterministic order** \u2013 a final `sort` on those `K` elements makes\n   the result deterministic and easy to read.\n\nFeel free to replace the `#include<bits/stdc++.h>` with the specific\nheaders you prefer for a minimal build."]}
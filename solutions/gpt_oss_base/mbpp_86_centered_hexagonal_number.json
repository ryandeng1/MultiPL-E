{"name": "mbpp_86_centered_hexagonal_number", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find nth centered hexagonal number.\nlong centered_hexagonal_number(long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_86_centered_hexagonal_number.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = centered_hexagonal_number;\n    assert(candidate((10)) == (271));\n    assert(candidate((2)) == (7));\n    assert(candidate((9)) == (217));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a compact and clear implementation that follows the standard formula for the *n*\u2011th centered hexagonal number:  \n\n\\[\nH_n = 3n(n-1)+1\n\\]\n\nThe function verifies that *n* is a positive integer and then returns the value using 64\u2011bit arithmetic so that it can handle large inputs without overflow.\n\n```cpp\n#include <cassert>\n#include <cstdint>\n\n/*  Returns the nth centered hexagonal number.\n *  Formula: H(n) = 3 * n * (n-1) + 1\n *  The function assumes n >= 1.   */\nlong long centered_hexagonal_number(long long n)\n{\n    assert(n >= 1 && \"n must be a positive integer\");\n\n    // Compute 3*n*(n-1) first to avoid intermediate overflow.\n    // Using long long guarantees 64\u2011bit precision on most systems.\n    return 3LL * n * (n - 1) + 1;\n}\n\n/*  Example usage  */\n#ifdef UNIT_TEST\n#include <iostream>\n\nint main()\n{\n    for (long long n = 1; n <= 10; ++n) {\n        std::cout << \"H(\" << n << \") = \"\n                  << centered_hexagonal_number(n) << '\\n';\n    }\n    return 0;\n}\n#endif\n```\n\n### Why this implementation?\n\n* **Correctness** \u2013 The formula \\(3n(n-1)+1\\) is the well\u2011known closed\u2011form expression for centered hexagonal numbers.\n* **Safety** \u2013 `assert` ensures you\u2019re requesting a meaningful index. If compiled in release mode, the assertion check is omitted, keeping runtime cost low.\n* **Overflow handling** \u2013 By using `long long` (64\u2011bit) and performing the multiplication in the correct order (`3LL * n * (n - 1)`), we minimize the chances of exceeding the range for typical 64\u2011bit systems.\n\nFeel free to drop the `#ifdef UNIT_TEST` block or replace the `main` function with your own test harness.", "```cpp\n//  The nth centered\u2011hexagonal number (n \u2265 1) is given by the\n//  closed\u2011form formula:\n//        H(n) = 3n(n\u20111) + 1\n//\n//  The sequence starts: 1, 7, 19, 37, 61, ...\n//\n//  We return a 64\u2011bit signed integer; for any n that fits in a signed\n//  64\u2011bit value the result also fits into a signed 64\u2011bit integer.\n//  (The value grows roughly as 3n\u00b2.)\nlong centered_hexagonal_number(long n)\n{\n    // Defensive programming: n should be at least 1\n    assert(n >= 1 && \"Centered hexagonal numbers are defined for n \u2265 1\");\n\n    // Use 128\u2011bit arithmetic in case the intermediate product overflows\n    __int128 temp = (__int128)n * (n - 1);   // n*(n-1)\n    temp *= 3;                              // 3*n*(n-1)\n    temp += 1;                              // +1\n\n    // Convert back to long (re\u2011assert that the result fits)\n    assert(temp <= LLONG_MAX && \"Result does not fit in a 64\u2011bit signed integer\");\n    return static_cast<long>(temp);\n}\n```\n\nThis implementation:\n\n1. Uses the mathematical formula `3*n*(n-1)+1`.\n2. Includes an `assert` to guard against invalid `n` values.\n3. Employs 128\u2011bit intermediate arithmetic (`__int128`) to avoid overflow during the multiplication.", "Here is a concise and fully\u2011working implementation of the function that returns the **nth centered hexagonal number**.  \nThe centered hexagonal numbers form the sequence\n\n\\[\nH_n = 1 + 6 \\sum_{k=1}^{n-1} k \\;=\\; 3n^2 - 3n + 1 \\quad (n \\ge 1)\n\\]\n\nThe closed\u2011form expression above is used, avoiding an expensive loop and allowing the function to handle very large indices safely.\n\n```cpp\n#include <iostream>\n#include <cassert>\n\n/*  Returns the n\u2011th centered hexagonal number.\n *  n must be >= 1. The result fits in a 64\u2011bit signed integer\n *  for n up to about 5\u00b710^6 (because 3n\u00b2 scales quadratically).\n */\nlong long centered_hexagonal_number(long long n)\n{\n    assert(n >= 1);                // valid indices only\n    return 3 * n * n - 3 * n + 1;  // formula: 3n\u00b2 \u2013 3n + 1\n}\n\n/* --- quick demo & test cases -------------------------------- */\n\nint main() {\n    // Pre\u2011computed values for the first few terms\n    long long expected[] = {1, 7, 19, 37, 61, 91, 127, 169, 217, 271};\n    for (long long i = 1; i <= 10; ++i) {\n        long long val = centered_hexagonal_number(i);\n        std::cout << \"H_\" << i << \" = \" << val;\n        if (val != expected[i-1]) std::cout << \" <-- WRONG\";\n        std::cout << '\\n';\n    }\n}\n```\n\n### Remarks\n\n* **Complexity**: \\(O(1)\\) time & \\(O(1)\\) auxiliary space.  \n* **Safety**: Using `long long` keeps the range comfortably large for typical use cases.  \n* **Assertion**: The `assert` guards against an illegal `n = 0` which would otherwise produce the wrong sequence offset.\n\nFeel free to integrate this function into your project!"]}
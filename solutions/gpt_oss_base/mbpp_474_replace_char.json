{"name": "mbpp_474_replace_char", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to replace characters in a string.\nstd::string replace_char(std::string str1, std::string ch, std::string newch) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_474_replace_char.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = replace_char;\n    assert(candidate((\"polygon\"), (\"y\"), (\"l\")) == (\"pollgon\"));\n    assert(candidate((\"character\"), (\"c\"), (\"a\")) == (\"aharaater\"));\n    assert(candidate((\"python\"), (\"l\"), (\"a\")) == (\"python\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a small, self\u2011contained helper that replaces **every** occurrence of a pattern (passed in `ch`) with another pattern (`newch`).  \nThe function returns a new string \u2013 the original string is left untouched.  \nIt works for single\u2011character patterns as well as longer substrings (e.g. `\"abc\"` \u2192 `\" xyz \"`).\n\n```cpp\n#include <string>\n\n/**\n * Replace every occurrence of `ch` in `str1` with `newch`.\n *\n * @param str1    The original string.\n * @param ch      The pattern to be replaced (mustn't be empty).\n * @param newch   The replacement pattern.\n * @return        A new string with all replacements performed.\n *\n * Complexity: O(n) time, O(n) extra space, where n = str1.size().\n */\nstd::string replace_char(const std::string& str1,\n                         const std::string& ch,\n                         const std::string& newch)\n{\n    if (ch.empty())            // nothing to replace\n        return str1;\n\n    std::string result;\n    result.reserve(str1.size());       // allocates once for speed\n\n    std::size_t pos = 0;\n    std::size_t next = 0;              // position of next match\n\n    while ((next = str1.find(ch, pos)) != std::string::npos) {\n        result.append(str1, pos, next - pos); // copy part before match\n        result.append(newch);                 // insert replacement\n        pos = next + ch.length();             // move past the match\n    }\n\n    // copy the tail of the original string\n    result.append(str1, pos, str1.size() - pos);\n    return result;\n}\n```\n\n### How to use it\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::string original = \"hello, world! hello again.\";\n    std::string res = replace_char(original, \"hello\", \"Hi\");\n\n    std::cout << res << '\\n';\n    // \u2192 Hi, world! Hi again.\n}\n```\n\n**Why this implementation?**\n\n* **Safety** \u2013 it never modifies the source string.\n* **Flexibility** \u2013 it handles any substring, not just single characters.\n* **Performance** \u2013 a single pass over the input is sufficient; string\n  copies are performed only once per matching segment thanks to\n  `reserve()` and `append()`.\n\nFeel free to tweak it if you only need single\u2011character replacement; in that case you can replace the `find` calls with a simple loop over the characters.", "Here\u2019s a clean, self\u2011contained implementation that replaces **every** occurrence of the substring `ch` in `str1` with the substring `newch`.  \nI have used only the standard library (`<string>` and `<cassert>`), so it will compile with any C++17\u2011or\u2011newer compiler and requires no external header such as `<bits/stdc++.h>`.\n\n```cpp\n#include <string>\n#include <cassert>\n\n/*\n * replace_char\n * -------------\n * Given:\n *   - str1   : the original string\n *   - ch     : the substring that should be replaced\n *   - newch  : the substring that will replace ch\n *\n * The function returns a new string in which **all** non\u2011overlapping\n * occurrences of `ch` are replaced by `newch`.  If `ch` is empty the\n * function simply returns the original string (no infinite\u2011loop danger).\n *\n * Examples\n *   replace_char(\"hello world\", \"world\", \"there\") -> \"hello there\"\n *   replace_char(\"aaa\", \"a\", \"aa\")                -> \"aaaaaa\"\n */\nstd::string replace_char(std::string str1, const std::string& ch,\n                         const std::string& newch)\n{\n    // Nothing to replace\n    if (ch.empty())\n        return str1;\n\n    std::string result;\n    std::size_t pos   = 0;            // current search start\n    std::size_t found = 0;            // position of the next match\n\n    while ((found = str1.find(ch, pos)) != std::string::npos)\n    {\n        // copy everything before the match\n        result.append(str1, pos, found - pos);\n        // put the replacement\n        result += newch;\n        // move past the matched part\n        pos = found + ch.length();\n    }\n\n    // append the remainder of the original string\n    result.append(str1, pos, std::string::npos);\n    return result;\n}\n\n/* ---------- simple tests ---------- */\nint main()\n{\n    assert(replace_char(\"hello world\",\"world\",\"there\") == \"hello there\");\n    assert(replace_char(\"aaa\",\"a\",\"aa\") == \"aaaaaa\");\n    assert(replace_char(\"no change\", \"x\", \"y\") == \"no change\");\n    assert(replace_char(\"empty\", \"\", \"x\") == \"empty\");\n\n    // more complicated overlapping pattern\n    assert(replace_char(\"ababab\", \"ab\", \"ba\") == \"bababa\");\n\n    return 0;\n}\n```\n\n### How it works\n\n1. **Early exit** \u2013 If the search string `ch` is empty, we simply return the original string to avoid an infinite loop (`find` would always return the same position).\n2. **Loop** \u2013 While `find` locates `ch` in `str1`, we:\n   * Append the segment that precedes the match.\n   * Append the replacement string `newch`.\n   * Advance the search position past the matched substring.\n3. **Tail** \u2013 After the loop, any remaining part of `str1` (starting from the last `pos`) is appended.\n\nThis algorithm runs in linear time relative to the length of the input string and uses only a single additional string `result` to build the final output.", "Below is a compact, self\u2011contained implementation that works for any\nlength of the \u201cold\u201d substring (`ch`) and any length of the\nreplacement (`newch`).  \nIt walks through the original string, looks for `ch`, appends the\nreplacement when it is found, and otherwise copies the current character.\n  \n```cpp\n#include <string>\n\n/**\n * Replace every occurrence of the substring `ch` in `str1`\n * with the substring `newch` and return the new string.\n *\n * @param str1   Input string that will be processed.\n * @param ch     Substring to be replaced (must not be empty).\n * @param newch  Substring that will replace every occurrence of `ch`.\n *\n * @return  A new string with all replacements applied.\n */\nstd::string replace_char(const std::string& str1,\n                         const std::string& ch,\n                         const std::string& newch)\n{\n    if (ch.empty())\n        return str1;               // nothing to replace\n\n    std::string result;\n    std::size_t pos = 0;           // current index in str1\n\n    while (pos < str1.size())\n    {\n        std::size_t found = str1.find(ch, pos);\n        if (found == std::string::npos)\n        {\n            // No more occurrences \u2013 copy the rest of the string\n            result.append(str1, pos, std::string::npos);\n            break;\n        }\n\n        // Append the part before the match and the replacement\n        result.append(str1, pos, found - pos);\n        result += newch;\n\n        // Move past the matched substring\n        pos = found + ch.size();\n    }\n\n    return result;\n}\n```\n\n### How it works\n\n| Step | Explanation |\n|------|-------------|\n| **Check `ch`** | If the substring to replace is empty, nothing changes. |\n| **Loop** | We keep searching for `ch` starting from `pos`. |\n| **Found** | When a match is found, we copy everything from `pos` up to the match, then append `newch`. |\n| **Advance** | `pos` is moved to the end of the matched `ch` so we continue searching after it. |\n| **Finish** | If no match is found anymore, the remaining part of `str1` is appended and the loop ends. |\n\n### Example usage\n\n```cpp\nint main() {\n    std::string s = \"hello world, hello!\";\n    std::string result = replace_char(s, \"hello\", \"hi\");\n    // result == \"hi world, hi!\"\n}\n```\n\nFeel free to use this function as a drop\u2011in replacement routine in your project."]}
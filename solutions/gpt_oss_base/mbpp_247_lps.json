{"name": "mbpp_247_lps", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_247_lps.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a robust and efficient implementation of **`lps`** that returns the length of the longest palindromic subsequence (LPS) of a given string.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Dynamic\u2011programming solution \u2013 O(n^2) time, O(n) memory\nlong lps(const string &s) {\n    int n = (int)s.size();\n    if (n == 0) return 0;\n\n    // dp[i] will hold the LPS length for the substring\n    // s[i..j] where j is growing.  We only need one row.\n    vector<int> dp(n, 0);\n\n    // We process the string from right to left.\n    for (int i = n - 1; i >= 0; --i) {\n        dp[i] = 1;                 // single character is a palindrome\n        int prev = 0;              // value of dp[i+1][j-1] from the previous row\n        for (int j = i + 1; j < n; ++j) {\n            int temp = dp[j];      // store current dp[i][j] for the next iteration\n            if (s[i] == s[j]) {\n                dp[j] = 2 + prev;  // chars match, extend the palindrome\n            } else {\n                dp[j] = max(dp[j], dp[j - 1]); // take the best of excluding either end\n            }\n            prev = temp;           // update prev for the next j\n        }\n    }\n    return dp[n - 1];\n}\n```\n\n### Why this version?\n\n* **Time complexity** \u2013 `O(n\u00b2)`.  \n  For every pair `(i, j)` (i \u2264 j) we perform a constant amount of work.\n\n* **Space complexity** \u2013 `O(n)`.  \n  We use only a single `vector<int>` of length `n` instead of an `n \u00d7 n` matrix.\n\n### How it works\n\n1. **Base case** \u2013 a single character is a palindrome of length `1`.  \n2. **Recurrence** \u2013 for a substring `s[i..j]`:\n   * If `s[i] == s[j]`, the LPS length is `2 + LPS(s[i+1..j-1])`.\n   * Otherwise, it is `max( LPS(s[i+1..j]), LPS(s[i..j-1]) )`.\n\n3. We iterate `i` from the end of the string toward the front.  \n   For each `i`, we iterate `j` from `i+1` to `n-1`.  \n   `dp[j]` holds the LPS length for `s[i..j]` during the inner loop, while `prev`\n   stores the value of `dp[j-1]` from the previous `i` (which corresponds to\n   `LPS(s[i+1..j-1])`).\n\n### Example\n\n```cpp\nint main() {\n    string s = \"bbbab\";\n    cout << lps(s) << endl;  // prints 4 (\"bbbb\")\n}\n```\n\nThe function works for all edge cases (empty string, single character, all\nidentical characters, etc.) and is ready to be dropped into any project.", "Here is a concise, self\u2011contained implementation that returns the length of the longest palindromic subsequence (LPS) for a given string.  \nThe solution uses the classic \\(O(n^2)\\) dynamic\u2011programming approach where `dp[i][j]` stores the LPS length of the substring `str[i..j]`.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Returns length of longest palindromic subsequence in `str`\nlong lps(const string &str) {\n    const int n = static_cast<int>(str.size());\n    if (n == 0) return 0;\n\n    // dp[i][j] = LPS length in str[i..j]\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n\n    // Every single character is a palindrome of length 1\n    for (int i = 0; i < n; ++i) dp[i][i] = 1;\n\n    // Build table for substrings of increasing length\n    for (int len = 2; len <= n; ++len) {        // substring length\n        for (int i = 0; i + len - 1 < n; ++i) {\n            int j = i + len - 1;              // ending index\n            if (str[i] == str[j]) {\n                if (len == 2)                // two equal characters\n                    dp[i][j] = 2;\n                else\n                    dp[i][j] = dp[i+1][j-1] + 2;\n            } else {\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1]);\n            }\n        }\n    }\n    return dp[0][n-1];\n}\n\n/* Optional: simple test harness\nint main() {\n    string s1 = \"bbbab\";\n    cout << lps(s1) << endl; // 4\n\n    string s2 = \"agbdba\";\n    cout << lps(s2) << endl; // 5\n\n    return 0;\n}\n*/\n```\n\n### How it works\n- **Base case** \u2013 single characters (`len==1`) are palindromes of length `1`.  \n- **Matching ends** \u2013 if the characters at the two ends match, we can extend the LPS of the inner substring by `2`.  \n- **Non\u2011matching ends** \u2013 the answer is the maximum of ignoring either the left or the right character.\n- The table is filled for increasing substring lengths, guaranteeing that the needed sub\u2011problems (`dp[i+1][j-1]`, `dp[i+1][j]`, `dp[i][j-1]`) are already computed.\n\nTime complexity: \\(O(n^2)\\).  \nSpace complexity: \\(O(n^2)\\) (can be reduced to \\(O(n)\\) using a 1\u2011D DP if required).", "Here is a complete, self\u2011contained C++ implementation of the classic **Longest Palindromic Subsequence** (LPS) problem.  \nThe code uses dynamic programming with a 2\u2011D table (`dp[i][j]`) that keeps the LPS length for the substring `str[i\u2026j]`.  \nYou can compile it with any standard C++ compiler (C++11 and later).\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*  Longest Palindromic Subsequence\n *\n *  Time Complexity :  O(n^2)\n *  Space Complexity:  O(n^2)   (you can reduce it to O(n) if needed)\n *\n *  dp[i][j]  =  length of the longest palindromic subsequence in str[i\u2026j]\n *  Recurrence:\n *      if str[i]==str[j]   ->  dp[i][j] = 2 + dp[i+1][j-1]   (i < j)\n *      else                ->  dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n *  Base case:\n *      dp[i][i] = 1   (single character is a palindrome)\n *\n *  The answer is dp[0][n-1]\n */\nlong long lps(const string &str) {\n    size_t n = str.size();\n    if (n == 0) return 0;\n\n    vector<vector<long long>> dp(n, vector<long long>(n, 0));\n\n    // every single character is a palindrome of length 1\n    for (size_t i = 0; i < n; ++i) dp[i][i] = 1;\n\n    // fill the table; l = sub\u2011string length\n    for (size_t l = 2; l <= n; ++l) {\n        for (size_t i = 0; i + l <= n; ++i) {\n            size_t j = i + l - 1;\n            if (str[i] == str[j]) {\n                if (i + 1 <= j - 1)           // length > 2\n                    dp[i][j] = 2 + dp[i + 1][j - 1];\n                else                            // two equal characters\n                    dp[i][j] = 2;\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n\n    return dp[0][n - 1];\n}\n\n/* -----------------  Demo / Testing  ----------------- */\nint main() {\n    vector<string> tests = {\n        \"BBABCBCAB\",\n        \"AGGTAB\",\n        \"ABCD\",\n        \"\",\n        \"A\",\n        \"ABA\",\n        \"1112101\"\n    };\n\n    for (const auto &s : tests) {\n        cout << \"String: \\\"\" << s << \"\\\"\\n\";\n        cout << \"Longest Palindromic Subsequence Length = \"\n             << lps(s) << \"\\n\\n\";\n    }\n    return 0;\n}\n```\n\n### How it works\n1. **Initialization** \u2013 Every character alone is a palindrome, so `dp[i][i] = 1`.  \n2. **Bottom\u2011up DP** \u2013 We build up the solution for substrings of increasing length `l`.  \n   * If the ends of the substring match, they can be part of the LPS \u2192 add 2 to the inner substring answer.  \n   * Otherwise, the LPS must be contained entirely in one of the two possible smaller substrings \u2192 take the maximum.  \n3. **Result** \u2013 The entry `dp[0][n-1]` holds the LPS length for the entire string.\n\nFeel free to trim the `main()` demo or replace it with your own test cases."]}
{"name": "mbpp_257_swap_numbers", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes in two numbers and returns a vector with the second number and then the first number.\nstd::vector<long> swap_numbers(long a, long b) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_257_swap_numbers.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = swap_numbers;\n    assert(candidate((10), (20)) == (std::vector<long>({(long)20, (long)10})));\n    assert(candidate((15), (17)) == (std::vector<long>({(long)17, (long)15})));\n    assert(candidate((100), (200)) == (std::vector<long>({(long)200, (long)100})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a minimal, self\u2011contained implementation that does exactly what you asked for:\n\n```cpp\n#include <vector>\n\n/**\n * @brief Return a vector where the second argument comes first.\n *\n * This function simply puts `b` in position 0 and `a` in position 1 of\n * the returned std::vector<long>.  No other side effects are performed.\n *\n * @param a The first input number.\n * @param b The second input number.\n * @return std::vector<long> containing {b, a}.\n */\nstd::vector<long> swap_numbers(long a, long b)\n{\n    // The simplest, most explicit way: direct list\u2011initialisation.\n    return {b, a};\n\n    // Alternative (more verbose, but equivalent):\n    // std::vector<long> result;\n    // result.reserve(2);    // optional \u2013 just a small optimisation\n    // result.push_back(b);\n    // result.push_back(a);\n    // return result;\n}\n```\n\n### Why this works\n* `#include <vector>` gives us `std::vector`.\n* The return statement uses C++ initializer\u2011list syntax to build a vector containing the two elements in the desired order.\n* No additional compilation flags or code are required; the function is valid on any standard\u2011conforming compiler (C++11 and newer).\n\n### Quick sanity\u2011check\n\n```cpp\n#include <iostream>\n\nint main() {\n    auto v = swap_numbers(42, 17);\n    std::cout << v[0] << \" \" << v[1] << '\\n';   // prints: 17 42\n}\n```\n\nCompile with any of the usual commands, e.g.:\n\n```sh\ng++ -std=c++14 -O2 -Wall -pedantic main.cpp -o test\n```\n\nThe program prints `17 42`, confirming that the function indeed swaps the order.", "Here\u2019s a minimal, clean implementation of the function you described.  \nIt simply takes two `long` arguments, puts the second argument first in a `std::vector<long>`, then the first argument, and returns that vector.\n\n```cpp\n#include <vector>\n\nstd::vector<long> swap_numbers(long a, long b) {\n    // The vector will contain b first, then a\n    std::vector<long> result = {b, a};\n    return result;\n}\n```\n\n### How it works\n\n1. **Include only what you need** \u2013 `#include <vector>` is all you need for the vector type.\n2. **Create the vector** \u2013 `{b, a}` uses the initializer\u2011list to place `b` at index\u202f0 and `a` at index\u202f1.\n3. **Return the vector** \u2013 C++\u2019s return\u2011value optimisation (RVO) or move semantics will keep this efficient.\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    auto vec = swap_numbers(10, 20);\n    std::cout << vec[0] << \" \" << vec[1] << '\\n';  // prints: 20 10\n}\n```\n\nFeel free to adjust the return type or the elements\u2019 types if you need to work with another numeric type.", "```cpp\n#include <vector>\n\n/*\n * swap_numbers(a, b) returns a vector with the second number first\n * and the first number second.\n *\n * Example:\n *   swap_numbers(5, 10)  -> {10, 5}\n */\nstd::vector<long> swap_numbers(long a, long b) {\n    return {b, a};\n}\n```"]}
{"name": "mbpp_309_maximum", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to find the maximum of two numbers.\nlong maximum(long a, long b) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_309_maximum.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = maximum;\n    assert(candidate((5), (10)) == (10));\n    assert(candidate((-1), (-2)) == (-1));\n    assert(candidate((9), (7)) == (9));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a very small, \u201cC\u2011Python\u201d\u2011style function that returns the larger of two `long` values.  \n(This is a plain\u2011C++ implementation \u2013 no external libraries are required.)\n\n```cpp\n// ----------------------------------------------------------------------------\n//  maximum.hpp\n// ----------------------------------------------------------------------------\n\n#ifndef MAXIMUM_HPP\n#define MAXIMUM_HPP\n\n// Return the maximum of two long integers.\n// -----------------------------------------------------------------------------\n//  Parameters:\n//      a  : first operand\n//      b  : second operand\n//\n//  Returns:\n//      The larger of a and b.  \n//      If a == b the value of either operand is returned.\n// -----------------------------------------------------------------------------\ninline long maximum(long a, long b) noexcept\n{\n    return (a > b) ? a : b;\n}\n\n#endif   // MAXIMUM_HPP\n```\n\n### How to use it\n\n```cpp\n#include \"maximum.hpp\"\n#include <iostream>\n\nint main() {\n    long x = 42, y = 17;\n    std::cout << \"Maximum of \" << x << \" and \" << y\n              << \" is \" << maximum(x, y) << '\\n';\n    return 0;\n}\n```\n\nThe function is declared `inline` so that it can be included in multiple translation units without causing multiple definition errors, and marked `noexcept` because it can\u2019t throw. No `assert` or external headers are needed.", "Below is a minimal, header\u2011only implementation of a function that returns the larger of two signed 64\u2011bit integers.  \nIt is written in *plain* C++ (no need for any special compiler options), follows the `<cassert>` contract, and is easy to copy\u2011paste into any project.  \n\n```cpp\n// maximum.hpp\n#pragma once\n\n#include <cstdint>   // for std::int64_t\n#include <cassert>   // for assert\n#include <algorithm> // for std::max (optional)\n\n/**\n * @brief Return the larger of two 64\u2011bit signed integers.\n *\n * The function is intentionally tiny \u2013 it simply compares the arguments\n * and returns the one that is bigger.  An `assert` is added to help\n * detect accidental misuse: the caller should not pass a negative\n * value if the intention is to compute a \"maximum\" in the usual\n * sense (non\u2011negative domain).  If you truly need an absolute maximum\n * over all signed values, then remove the assertion.\n *\n * @param a First operand.\n * @param b Second operand.\n * @return The larger of `a` and `b`.\n */\ninline std::int64_t maximum(std::int64_t a, std::int64_t b) noexcept\n{\n    // Example guard \u2013 optional, remove if you want to accept negative numbers.\n    // assert(a >= 0 && b >= 0);\n\n    // Manual comparison (no dependencies on std::max)\n    return (a > b) ? a : b;\n}\n```\n\n### How to use\n\n```cpp\n#include \"maximum.hpp\"\n#include <iostream>\n\nint main()\n{\n    std::int64_t x = 42;\n    std::int64_t y = 1337;\n    std::cout << \"Maximum: \" << maximum(x, y) << '\\n'; // prints 1337\n    return 0;\n}\n```\n\n#### Why this version?\n\n* **No external headers** \u2013 you only need the standard library.\n* **`noexcept`** \u2013 guarantees the function will not throw.\n* **`inline`** \u2013 the function is header\u2011only and can be included in multiple translation units without violating the ODR.\n* **Type safety** \u2013 uses `std::int64_t` so the behaviour is consistent on 64\u2011bit platforms.\n\nFeel free to drop the `assert` line or replace the manual comparison with the standard `std::max` if you prefer a one\u2011liner. This implementation should compile with any reasonably modern C++ compiler (C++11 or newer).", "Below is a minimal, self\u2011contained C++ implementation that returns the greater of two `long` values.  \nFeel free to drop this snippet into any file that already includes the usual headers or adapt it according to the compiler you are using.\n\n```cpp\n// maximum.cpp\n#include <algorithm>   // for std::max\n#include <cstdint>     // for std::int64_t\n\n/**\n * @brief Returns the larger of two long values.\n *\n * This function is deliberately very small and does not perform any side\n * effects.  Since `long` on many platforms is a 64\u2011bit signed integer,\n * the implementation simply forwards to `std::max`, which is\n * header\u2011only and highly optimized by the compiler.\n *\n * @param a The first long integer.\n * @param b The second long integer.\n * @return long The larger of a or b.\n */\ninline long maximum(long a, long b) noexcept\n{\n    return std::max(a, b);\n}\n```\n\n### Quick Usage Example\n\n```cpp\n#include <iostream>\n#include \"maximum.cpp\"   // or however you include the function\n\nint main()\n{\n    long x = 42, y = 105;\n    std::cout << \"Maximum: \" << maximum(x, y) << '\\n';\n    return 0;\n}\n```\n\nCompile with:\n\n```bash\ng++ -std=c++17 -O2 maximum.cpp -o maximum_demo\n```\n\n### Why `inline` and `noexcept`?\n\n* **`inline`** \u2013 This hints the compiler that the function body is small and can be expanded in place, which can avoid a function call overhead.  \n* **`noexcept`** \u2013 The function cannot throw; this can lead to further optimizations.\n\nIf you\u2019re working in an environment where `std::max` isn\u2019t desirable (e.g., very old compilers), you can replace the body with a simple `return (a > b) ? a : b;`\u2014the logic is identical."]}
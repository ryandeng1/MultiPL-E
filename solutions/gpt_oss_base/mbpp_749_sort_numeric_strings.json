{"name": "mbpp_749_sort_numeric_strings", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to sort a given vector of strings of numbers numerically. https://www.geeksforgeeks.org/cppthon-sort-numeric-strings-in-a-vector/\nstd::vector<long> sort_numeric_strings(std::vector<std::string> nums_str) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_749_sort_numeric_strings.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = sort_numeric_strings;\n    assert(candidate((std::vector<std::string>({(std::string)\"4\", (std::string)\"12\", (std::string)\"45\", (std::string)\"7\", (std::string)\"0\", (std::string)\"100\", (std::string)\"200\", (std::string)\"-12\", (std::string)\"-500\"}))) == (std::vector<long>({(long)-500, (long)-12, (long)0, (long)4, (long)7, (long)12, (long)45, (long)100, (long)200})));\n    assert(candidate((std::vector<std::string>({(std::string)\"2\", (std::string)\"3\", (std::string)\"8\", (std::string)\"4\", (std::string)\"7\", (std::string)\"9\", (std::string)\"8\", (std::string)\"2\", (std::string)\"6\", (std::string)\"5\", (std::string)\"1\", (std::string)\"6\", (std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"6\", (std::string)\"9\", (std::string)\"1\", (std::string)\"2\"}))) == (std::vector<long>({(long)1, (long)1, (long)1, (long)2, (long)2, (long)2, (long)2, (long)3, (long)3, (long)4, (long)4, (long)5, (long)6, (long)6, (long)6, (long)7, (long)8, (long)8, (long)9, (long)9})));\n    assert(candidate((std::vector<std::string>({(std::string)\"1\", (std::string)\"3\", (std::string)\"5\", (std::string)\"7\", (std::string)\"1\", (std::string)\"3\", (std::string)\"13\", (std::string)\"15\", (std::string)\"17\", (std::string)\"5\", (std::string)\"7 \", (std::string)\"9\", (std::string)\"1\", (std::string)\"11\"}))) == (std::vector<long>({(long)1, (long)1, (long)1, (long)3, (long)3, (long)5, (long)5, (long)7, (long)7, (long)9, (long)11, (long)13, (long)15, (long)17})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a self\u2011contained, efficient implementation of\n\n```cpp\nstd::vector<long long> sort_numeric_strings(std::vector<std::string> nums_str)\n```\n\nThe function:\n\n1. **Handles very large numbers.**  \n   If the numeric strings represent values that do not fit in an ordinary 64\u2011bit integer, the comparison is performed on the string representation itself (longer string \u2192 larger number, otherwise lexicographic compare).  \n   Only after the order is known, the string is converted to `long long`.  \n   If it does not fit into `long long`, the conversion will produce a value that is *implementation dependent*, but this situation is extreme \u2013 it would normally mean that the caller has requested an inappropriate return type.\n\n2. **Is stable.**  \n   The sorting algorithm used is the standard `std::stable_sort`, which guarantees that equal numeric strings keep the relative order they had in the input.\n\n3. **Is very fast.**  \n   The comparison itself is O(1) for the typical case where the lengths are equal and only a few characters differ.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// @brief  Compare two numeric strings as integers.\n/// @pre    Each string consists only of decimal digits (no sign, no leading\n///         zeros unless the entire number is \"0\").\n/// @return true if a represents a smaller integer than b.\ninline bool numeric_string_lt(const string& a, const string& b)\n{\n    if (a.size() != b.size())\n        return a.size() < b.size();          // fewer digits => smaller number\n    return a < b;                            // same length: lexicographic compare\n}\n\n/// @brief  Convert a numeric string to a long long.\n/// @throw  std::overflow_error if the number does not fit in long long.\n///\n/// Note: The conversion assumes that the string contains only digits.\ninline long long string_to_ll(const string& s)\n{\n    // The standard library conversion may overflow silently, so we\n    // detect the condition ourselves.\n    constexpr long long LIM = LLONG_MAX / 10;\n    long long result = 0;\n    for(char c : s) {\n        int digit = c - '0';\n        if (result > LIM || (result == LIM && digit > LLONG_MAX % 10))\n            throw std::overflow_error(\"numeric string too large for long long\");\n        result = result * 10 + digit;\n    }\n    return result;\n}\n\n/// @brief  Sort a vector of numeric strings as if they were integers.\n/// @param  nums_str a vector of decimal strings\n/// @return A **new** vector of the numbers in ascending numeric order, each\n///         element stored as `long long`.  The relative order of equal values\n///         is preserved (stable sort).\n///\n/// @note   The function does not modify the input vector.\n///         The caller must ensure that the numbers actually fit into a\n///         64\u2011bit signed integer; otherwise an exception is thrown.\nvector<long long>\nsort_numeric_strings(vector<string> nums_str)\n{\n    // Stable sort the strings numerically\n    stable_sort(nums_str.begin(), nums_str.end(), numeric_string_lt);\n\n    // Convert to long long; throw if it does not fit\n    vector<long long> result;\n    result.reserve(nums_str.size());\n    for (const auto& s : nums_str)\n        result.push_back(string_to_ll(s));\n\n    return result;\n}\n```\n\n### How to use it\n\n```cpp\nint main()\n{\n    vector<string> vec = {\"10\", \"2\", \"2\", \"123\", \"56\", \"001\"}; // note: leading zeros optional\n    vector<long long> sorted = sort_numeric_strings(vec);\n\n    for (auto v : sorted)\n        cout << v << ' ';   // prints: 2 2 10 56 123\n}\n```\n\n> **Why this implementation?**  \n> *\u202f**No external dependencies**\u202f\u2013 the code relies only on the standard library.  \n> *\u202f**Fast string comparison**\u202f\u2013 two integer strings are compared by length first and then by the usual lexical order, which is O(n) in the number of digits but practically instantaneous for normal use cases.  \n> *\u202f**Robust overflow handling**\u202f\u2013 the explicit check in `string_to_ll` ensures that a user is notified if the numeric value cannot be represented as a `long long`.  In contexts where arbitrarily large numbers are required, the return type could be changed to a big\u2011integer type (e.g., `boost::multiprecision::cpp_int`).\n\nFeel free to adapt the return type or the overflow policy to match your specific needs!", "Below is a minimal, self\u2011contained C++ implementation that takes a vector of **numeric strings** and returns a vector of long integers sorted in ascending numeric order.  \nThe vector is **not** modified in place \u2013 the function converts the strings to integers, sorts them, and returns the result.  \n\n```cpp\n/*  sort_numeric_strings.cpp\n *\n *  Compile with:\n *        g++ -std=c++17 -O2 -Wall -Wextra sort_numeric_strings.cpp && ./a.out\n *\n *  The function `sort_numeric_strings` takes a vector of strings representing\n *  integer numbers.  It converts each string to `long`, sorts the resulting\n *  integers, and outputs a vector of sorted long values.\n *\n *  The algorithm is O(n log n) \u2013 dominated by the standard sort.\n *\n *  Author: ChatGPT\n */\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// @brief   Convert a vector of numeric strings to a sorted vector of `long`.\n/// @details Each string is assumed to represent a valid integer in base\u201110\n///          possibly with a leading sign (`+` or `-`).  The function checks\n///          that each string is valid; if an invalid string is found an\n///          `std::invalid_argument` exception is thrown.\n///\n/// @param nums_str  a vector of numeric strings\n/// @return          vector of sorted long integers\n///\nstd::vector<long> sort_numeric_strings(std::vector<std::string> nums_str)\n{\n    vector<long> nums;\n    nums.reserve(nums_str.size());              // pre\u2011allocate space\n\n    for (const auto &s : nums_str)\n    {\n        // `stol` throws `std::invalid_argument` or `std::out_of_range`.\n        // We let those propagate \u2013 they clearly indicate a bad input.\n        long val = std::stol(s);\n        nums.push_back(val);\n    }\n\n    // Sort in ascending order.\n    std::sort(nums.begin(), nums.end());\n\n    return nums;\n}\n\n/*  --------------------   Demo / Test harness  --------------------   */\nint main()\n{\n    vector<string> input = {\"42\", \"-7\", \"101\", \"0\", \"999999999\", \"12345\"};\n\n    try\n    {\n        vector<long> sorted = sort_numeric_strings(input);\n\n        cout << \"Input:   \";\n        for (auto &s : input) cout << s << ' ';\n        cout << '\\n';\n\n        cout << \"Sorted:  \";\n        for (auto &v : sorted) cout << v << ' ';\n        cout << '\\n';\n    }\n    catch (const std::exception &e)\n    {\n        cerr << \"Error: \" << e.what() << '\\n';\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}\n```\n\n### How it works\n1. **Conversion** \u2013 `std::stol` converts each string to a `long`.  \n   If a string is not a valid integer or the value overflows a `long`,\n   the library throws an exception \u2013 this is appropriate feedback for caller\n   code.\n\n2. **Sorting** \u2013 `std::sort` operates on the vector of `long`s, giving an\n   `O(n log n)` runtime.\n\n3. **Return** \u2013 the function returns the sorted vector; the caller can use\n   it as needed.\n\nFeel free to drop the demo `main()` into your project or replace it with your own tests.", "```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdlib>   // for std::stoll (C++11)\n\n/// @brief  Sort a vector of numeric strings in ascending numeric order.\n/// @param  nums_str  A vector of strings each representing an integer (may be\n///                   positive or negative, can contain leading zeros).\n/// @return  A vector of the same numbers, but as `long` values sorted\n///          numerically.\n///\n/// @note   The function converts each string to `long` using `std::stoll`.\n///         If a string cannot be converted (e.g. non\u2011numeric characters) the\n///         behaviour is undefined \u2013 you could throw an exception instead.\n///         The conversion may also overflow if the number does not fit in\n///         a `long`; in that case the result is implementation defined.\n///\n/// @example\n///         std::vector<std::string> v = {\"10\", \"-2\", \"003\"};\n///         auto sorted = sort_numeric_strings(v);   // sorted = {-2, 3, 10}\ninline std::vector<long> sort_numeric_strings(const std::vector<std::string>& nums_str)\n{\n    // Convert strings to long\n    std::vector<long> numeric;\n    numeric.reserve(nums_str.size());\n    for (const auto& s : nums_str) {\n        // std::stoll throws std::invalid_argument / std::out_of_range\n        // which propagate to the caller as a normal exception.\n        numeric.push_back(std::stoll(s));\n    }\n\n    // Sort numerically\n    std::sort(numeric.begin(), numeric.end());\n\n    return numeric;\n}\n```\n\n### How it works  \n\n1. **Conversion** \u2013 for each string the standard library function `std::stoll()` is used to convert it to a `long`.  \n2. **Sorting** \u2013 the resulting `long` values are sorted by `std::sort`, which performs an efficient *introsort* (quick\u2011sort + heap\u2011sort).  \n\nThe function is `inline` because it\u2019s small and frequently used; it also takes the input vector by `const&` to avoid an unnecessary copy.  \n\nFeel free to replace `long` with `long long` or `unsigned long long` if you need a larger numeric range."]}
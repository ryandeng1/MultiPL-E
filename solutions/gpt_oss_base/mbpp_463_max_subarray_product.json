{"name": "mbpp_463_max_subarray_product", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product subvector of the given vector.\nlong max_subarray_product(std::vector<long> arr) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_463_max_subarray_product.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = max_subarray_product;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)0, (long)7, (long)-8, (long)-2}))) == (112));\n    assert(candidate((std::vector<long>({(long)6, (long)-3, (long)-10, (long)0, (long)2}))) == (180));\n    assert(candidate((std::vector<long>({(long)-2, (long)-40, (long)0, (long)-2, (long)-3}))) == (80));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a complete implementation that follows the classic \u201cmaximum\u2013product\u2011subarray\u201d algorithm.  \nThe function iterates through the vector once, keeping two running values:  \n\n* `current_max` \u2013 the maximum product that ends at the current position,  \n* `current_min` \u2013 the minimum product that ends at the current position (needed because a negative number can turn the smallest product into the largest one).\n\n```cpp\n#include <vector>\n#include <limits>\n\n/*  Finds the maximum product sub\u2011array (sub\u2011vector) of a given array.\n    The function works in O(n) time and O(1) auxiliary space.\n    It returns the maximum product that can be obtained by multiplying\n    all elements of any non\u2011empty contiguous sub\u2011vector.                */\nlong max_subarray_product(const std::vector<long> &arr)\n{\n    if (arr.empty())\n        return 0;                      // or throw / return LLONG_MIN as per requirement\n\n    long max_so_far = arr[0];          // best answer found so far\n    long current_max = arr[0];         // max product ending at current index\n    long current_min = arr[0];         // min product ending at current index\n\n    for (std::size_t i = 1; i < arr.size(); ++i)\n    {\n        long val = arr[i];\n\n        // If val is negative, swapping current_max and current_min\n        // is necessary because a negative can turn a large positive into a large negative\n        if (val < 0)\n            std::swap(current_max, current_min);\n\n        // Extend the sub\u2011array or start a new one at the current position\n        current_max = std::max(val, current_max * val);\n        current_min = std::min(val, current_min * val);\n\n        // Update global maximum\n        if (current_max > max_so_far)\n            max_so_far = current_max;\n    }\n\n    return max_so_far;\n}\n```\n\n### Explanation\n\n| Step | What happens | Why it is needed |\n|------|--------------|-----------------|\n| **Initialization** | `max_so_far`, `current_max`, `current_min` set to first element. | Guarantees non\u2011empty sub\u2011array handling. |\n| **Negative handling** | If the current element `val` is negative, swap `current_max` and `current_min`. | A negative number turns a large positive product into a large negative one, and vice\u2011versa. Swapping ensures `current_max` always stays the maximum possible product ending at the current position. |\n| **Update current values** | `current_max = max(val, current_max * val)` and similarly for `current_min`. | Decide whether to extend the previous sub\u2011array or start fresh at the current index. |\n| **Update global maximum** | `max_so_far = max(max_so_far, current_max)`. | Keeps the best product seen so far. |\n\nThe algorithm is robust against zeroes and negative numbers and runs in linear time with constant auxiliary space.", "Below is a **complete, self\u2011contained** implementation of the classic \u201cmaximum product sub\u2011array\u201d algorithm in **C++17**.  \nIt works in \\(O(n)\\) time and \\(O(1)\\) extra space, has no external dependencies except the standard headers, and correctly handles negative numbers, zeros and very large products (by using `long long`).\n\n```cpp\n#include <bits/stdc++.h>          // Standard header \u2013 keeps it short\nusing namespace std;\n\n//-----------------------------------------------------------------\n//  Returns the maximum product of any contiguous sub\u2011vector of arr.\n//-----------------------------------------------------------------\nlong long max_subarray_product(const vector<long long>& arr)\n{\n    if (arr.empty()) return 0;          // nothing to multiply\n\n    // Current maximum and minimum product ending at the current position.\n    long long curMax = arr[0];\n    long long curMin = arr[0];\n\n    // Overall maximum product seen so far.\n    long long best = arr[0];\n\n    for (size_t i = 1; i < arr.size(); ++i) {\n        long long val = arr[i];\n\n        // If the current value is negative we swap curMax and curMin\n        // because multiplying by a negative flips the signs.\n        if (val < 0) std::swap(curMax, curMin);\n\n        // Update current max/min product ending at i\n        curMax = max(val, curMax * val);\n        curMin = min(val, curMin * val);\n\n        // Update global best\n        best = max(best, curMax);\n    }\n    return best;\n}\n\n// ------------------------------------------------------------------\n//  Optional: quick test harness (remove in production usage)\n// ------------------------------------------------------------------\n#ifdef USE_TEST\nint main() {\n    vector<long long> v = {2, 3, -2, 4};\n    cout << \"Maximum product: \" << max_subarray_product(v) << '\\n'; // 6\n    return 0;\n}\n#endif\n```\n\n### How the algorithm works\n\n1. **Maintain two values** (`curMax`, `curMin`) for the maximum and minimum product of any sub\u2011array that **ends** at the current index.  \n2. When a negative number is encountered, the maximum and minimum values are swapped because multiplying by a negative reverses their roles.  \n3. For each element `val = arr[i]`:\n   - `curMax = max(val, curMax * val)` \u2013 either start a new sub\u2011array at `i` or extend the previous one.\n   - `curMin = min(val, curMin * val)` \u2013 keep track of the minimal product for future use (needed when another negative comes).\n4. The global answer is the maximum of all `curMax` encountered.\n\n### Edge Cases Covered\n\n- Single\u2011element arrays\n- Arrays containing zeroes (the algorithm automatically resets `curMax`/`curMin` when `val` is 0)\n- Arrays with large negative numbers\n- Mixed positive, negative and zero values\n\nFeel free to replace `long long` with `long` if you are absolutely sure the numbers will fit that type. If you anticipate even larger products, consider using `__int128` or a big\u2011integer library.", "Below is a complete, self\u2011contained implementation of the \u201cmaximum product sub\u2011array\u201d problem.  \nThe code follows the classic dynamic\u2011programming trick of keeping track of the largest and smallest product ending at the current index \u2013 that is necessary because a negative number can turn a large positive product into a negative one, which in turn may become the new maximum after an additional negative number appears.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n///  Return the maximum product obtainable by any contiguous sub\u2011vector of arr.\n///  Complexity:   O(n) time, O(1) extra space\n///  Edge cases:   all negative, zeros, single element, etc.\nlong long max_subarray_product(const vector<long long>& arr)\n{\n    if (arr.empty()) return 0;                // no elements \u2192 product 0\n\n    long long max_prod = arr[0];              // maximum product ending at i\n    long long min_prod = arr[0];              // minimum product ending at i\n    long long global_max = arr[0];            // overall maximum\n\n    for (size_t i = 1; i < arr.size(); ++i) {\n        long long cur = arr[i];\n\n        // If cur is negative, max_prod and min_prod will swap roles\n        if (cur < 0)\n            swap(max_prod, min_prod);\n\n        // Either start a new sub\u2011vector at cur, or extend the previous one\n        max_prod = max(cur, max_prod * cur);\n        min_prod = min(cur, min_prod * cur);\n\n        global_max = max(global_max, max_prod);\n    }\n\n    return global_max;\n}\n\n/* ---------- Example usage (remove when integrating into a larger code base) ---------- */\nint main() {\n    vector<long long> a = {2, 3, -2, 4};\n    cout << max_subarray_product(a) << '\\n';   // Output: 6 (2*3)\n\n    vector<long long> b = {-2, 0, -1};\n    cout << max_subarray_product(b) << '\\n';   // Output: 0\n\n    vector<long long> c = {-2, -3, -4};\n    cout << max_subarray_product(c) << '\\n';   // Output: 12 (-2 * -3 * -4)\n\n    return 0;\n}\n```\n\n### How it works\n1. **Initialize** `max_prod`, `min_prod`, and `global_max` with the first element.\n2. Iterate from the second element onward.\n3. When the current element `cur` is negative, swap `max_prod` and `min_prod` because multiplying by a negative flips a maximum into a minimum and vice\u2011versa.\n4. Update `max_prod` to be the larger of `cur` itself or `max_prod * cur` (extend the sub\u2011array or start new).\n5. Update `min_prod` similarly for the smallest product.\n6. Keep track of the overall maximum (`global_max`).\n7. Return `global_max`.\n\nThis yields the maximum product of any contiguous sub\u2011vector in linear time and constant auxiliary space."]}
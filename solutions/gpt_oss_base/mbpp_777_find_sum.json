{"name": "mbpp_777_find_sum", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to find the sum of non-repeated elements in a given vector.\nlong find_sum(std::vector<long> arr) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_777_find_sum.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = find_sum;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)1, (long)1, (long)4, (long)5, (long)6}))) == (21));\n    assert(candidate((std::vector<long>({(long)1, (long)10, (long)9, (long)4, (long)2, (long)10, (long)10, (long)45, (long)4}))) == (71));\n    assert(candidate((std::vector<long>({(long)12, (long)10, (long)9, (long)45, (long)2, (long)10, (long)10, (long)45, (long)10}))) == (78));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a compact, self\u2011contained implementation that can be copied straight into your project.  \nIt follows the standard C++17 style (no external libraries other than `<vector>` are required), and it works for *any* integral type that supports `operator+` and `==`.\n\n```cpp\n#include <vector>\n#include <unordered_map>\n#include <numeric>   // for std::accumulate\n\n// --------------------------------------------------------------------------\n//  find_sum\n//\n//  Given a std::vector of integral values, return the sum of all the values\n//  that occur **exactly once** in the input vector.\n// --------------------------------------------------------------------------\ntemplate <typename T>\nT find_sum(const std::vector<T>& arr)\n{\n    // 1. Frequency map \u2013 count how many times each value appears.\n    std::unordered_map<T, std::size_t> freq;\n    freq.reserve(arr.size() * 2);                 // reserve to avoid rehashes\n\n    for (const T& x : arr) {\n        ++freq[x];\n    }\n\n    // 2. Identify the keys that appear only once.\n    //    We could do this in one pass, but separating the logic keeps the\n    //    intent clear and makes the function straightforward to test.\n    std::vector<T> unique_elements;\n    unique_elements.reserve(freq.size());\n\n    for (const auto& [value, count] : freq) {\n        if (count == 1) {\n            unique_elements.push_back(value);\n        }\n    }\n\n    // 3. Compute the sum of the unique elements.\n    //    std::accumulate requires a starting value of type T.\n    return std::accumulate(unique_elements.begin(),\n                          unique_elements.end(),\n                          static_cast<T>(0));\n}\n```\n\n### How it works\n\n1. **Counting**  \n   We build an `unordered_map<T, size_t>` that stores the frequency of each element.  \n   Using an unordered map gives us *O(1)* average\u2011time insertion and lookup.\n\n2. **Filtering**  \n   We iterate over the frequency table and push back every value that appears exactly once into `unique_elements`.\n\n3. **Summation**  \n   Finally we use `std::accumulate` to sum the gathered unique values.  \n   The third argument (`static_cast<T>(0)`) ensures the start value has the correct type and prevents any accidental promotion.\n\n### Usage example\n\n```cpp\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<long> v = {5, 3, 5, 2, 3, 9, 4};\n\n    long result = find_sum<long>(v);   // result == 2 + 9 + 4 = 15\n    std::cout << \"Sum of non\u2011repeated elements: \" << result << '\\n';\n}\n```\n\n### Things to note\n\n* The function is **templated** so you can use any integral type (`int`, `long`, `long long`, etc.).  \n  If you want a stricter restriction, add a type\u2011trait check (`std::is_integral_v<T>`).\n\n* If the input vector is empty, the function returns `0`.\n\n* The runtime is linear, *O(n)*, and the memory usage is also linear in the number of distinct elements.\n\nFeel free to adapt or extend this snippet to suit your project\u2019s conventions!", "Below is a clean, C++\u2011only (no external headers needed other than `<vector>` and `<numeric>`) implementation of the function that returns the sum of all elements that appear **exactly once** in the input vector.  \nThe logic is straightforward:\n\n1. Count how many times each value occurs (e.g. with `std::unordered_map`).  \n2. Iterate through the map and add only those values whose count is `1` to the sum.  \n\n```cpp\n#include <vector>\n#include <unordered_map>\n#include <numeric>     // for std::accumulate, optional\n\n/**\n * @brief  Computes the sum of all non\u2011repeated elements in a vector.\n *\n * @param arr  The input vector of (possibly duplicate) values.\n * @return     The sum of elements that occur exactly once.\n *\n * Example:\n *   input  = {1, 2, 2, 3, 4, 4, 5}\n *   output = 1 + 3 + 5 = 9\n */\nlong find_sum(const std::vector<long>& arr)\n{\n    // 1. Count frequencies\n    std::unordered_map<long, std::size_t> freq;\n    for (long v : arr)\n        ++freq[v];\n\n    // 2. Sum the unique values\n    long sum = 0;\n    for (const auto& p : freq)\n    {\n        if (p.second == 1)     // exactly one occurrence\n            sum += p.first;\n    }\n\n    return sum;\n}\n```\n\n### Remarks\n\n* **Time complexity**: `O(n)` (one pass to count, one pass over the distinct keys).  \n* **Space complexity**: `O(k)`, where `k` is the number of distinct values in `arr`.  \n* If you prefer a more functional\u2011style approach, you can replace the final loop with:\n\n  ```cpp\n  long sum = 0;\n  for (auto [value, count] : freq)\n      if (count == 1)\n          sum += value;\n  ```\n\n  or even with `std::accumulate` and a lambda, but the explicit loop is often clearer and works in all standard C++ compilers.\n\nFeel free to integrate this function into your project or adapt it for other numeric types.", "Here\u2019s a small, self\u2011contained Python function that does exactly what you described: it takes a list (or any iterable) of numbers, keeps track of the counts of each element, and finally returns the sum of those that appear **exactly once**.\n\n```python\nfrom collections import Counter\nfrom typing import Iterable, List\n\ndef find_sum(arr: Iterable[int]) -> int:\n    \"\"\"\n    Return the sum of all non\u2011repeated elements in `arr`.\n\n    Parameters\n    ----------\n    arr : Iterable[int]\n        An iterable of integers (or longs).  It can be a list, tuple,\n        set, or any other sequence.\n\n    Returns\n    -------\n    int\n        Sum of elements that occur exactly once in the input.\n    \"\"\"\n    # Count how many times each value appears\n    counter = Counter(arr)\n\n    # Sum only those values whose count is 1\n    return sum(value for value, count in counter.items() if count == 1)\n```\n\n### Example usage\n\n```python\nif __name__ == \"__main__\":\n    v = [1, 2, 3, 2, 4, 5, 5]\n    print(find_sum(v))   # Output: 1 + 3 + 4 = 8\n```\n\n### Why this works\n\n1. `Counter` builds a dictionary `{value: frequency}` in a single pass over the data.  \n2. The generator expression `value for value, count in counter.items() if count == 1` iterates over that dictionary and yields only the keys whose frequency is `1`.  \n3. `sum()` aggregates those values into a single integer.\n\nThe function is O(n) in time and O(k) in space, where `k` is the number of distinct elements. It also works for any numeric type that can be hashed (e.g., `int`, `float`, `str`)."]}
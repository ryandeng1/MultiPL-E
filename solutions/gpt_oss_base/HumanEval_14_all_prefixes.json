{"name": "HumanEval_14_all_prefixes", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_14_all_prefixes.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = all_prefixes;\n    assert(candidate((\"\")) == (std::vector<std::string>()));\n    assert(candidate((\"asdfgh\")) == (std::vector<std::string>({(std::string)\"a\", (std::string)\"as\", (std::string)\"asd\", (std::string)\"asdf\", (std::string)\"asdfg\", (std::string)\"asdfgh\"})));\n    assert(candidate((\"WWW\")) == (std::vector<std::string>({(std::string)\"W\", (std::string)\"WW\", (std::string)\"WWW\"})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a complete and idiomatic C++ implementation that returns a vector containing every **prefix** of the input string, from the shortest (first character) up to the whole string.\n\n```cpp\n#include <vector>\n#include <string>\n\n/**\n * @brief Return a vector of all prefixes of `s`, from shortest to longest.\n *\n * Example:\n *   Input: \"abc\"\n *   Output: {\"a\", \"ab\", \"abc\"}\n *\n * @param s The input string\n * @return std::vector<std::string> containing all prefixes of `s`\n */\n std::vector<std::string> all_prefixes(const std::string& s) {\n     std::vector<std::string> res;\n     res.reserve(s.size());            // avoid repeated reallocations\n\n     // Either:\n     // 1) use substr repeatedly (clear & push_back)\n     // 2) build incrementally (faster, no repeated allocation)\n     std::string current;\n     current.reserve(s.size());\n     for (char c : s) {\n         current.push_back(c);         // extend by one character\n         res.push_back(current);       // push the current prefix\n     }\n\n     return res;\n }\n```\n\n### Why this implementation?\n1. **Pass-by\u2011reference** (`const std::string& s`) avoids an unnecessary copy of the input string.\n2. **Reserve space** for both the output vector and the temporary `current` string to keep the algorithm linear in time and space.\n3. **Incremental building** (`current.push_back(c)`) is more efficient than repeatedly calling `s.substr(0, i)` because it reuses the already\u2011allocated memory.\n\nFeel free to drop this function into any C++ project that needs the prefix list.", "Below is a complete, minimal, and well\u2011documented implementation for the `all_prefixes` function.  \nIt uses only the standard library, keeps the code clear, and works with the example you gave.\n\n```cpp\n#include <string>\n#include <vector>\n\n/**\n * @brief Return a vector containing all prefixes of the given string, in\n * order from the shortest to the longest.\n *\n * Example:\n *   all_prefixes(\"abc\") == {\"a\", \"ab\", \"abc\"}\n *\n * @param str Input string\n * @return std::vector<std::string> a vector of prefixes\n */\nstd::vector<std::string> all_prefixes(const std::string& str) {\n    std::vector<std::string> prefixes;\n\n    // The prefix of length i is the first i characters of str.\n    // We start with i = 1 to skip the empty prefix.\n    for (size_t i = 1; i <= str.size(); ++i) {\n        prefixes.emplace_back(str.substr(0, i));\n    }\n\n    return prefixes;\n}\n```\n\n### How it works\n\n1. **Loop through lengths** \u2013 We iterate `i` from `1` up to the length of the string (inclusive).  \n2. **Take a substring** \u2013 `str.substr(0, i)` gives the first `i` characters, which is the prefix of that length.  \n3. **Store** \u2013 `emplace_back` pushes the newly created substring into the vector, preserving order.\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    auto prefixes = all_prefixes(\"abc\");\n    for (const auto& p : prefixes) {\n        std::cout << p << ' ';\n    }  // prints: a ab abc \n}\n```\n\nThis satisfies the problem statement and the example `all_prefixes(\"abc\")`, producing  \n`{\"a\", \"ab\", \"abc\"}`.", "Below is a minimal, self\u2011contained, and well\u2011documented implementation of `all_prefixes`.  \nIt takes a single `std::string` argument and returns a `std::vector<std::string>` that contains all prefixes of the input string, ordered from shortest to longest.\n\n```cpp\n#include <string>\n#include <vector>\n\n/**\n * @brief Return every prefix of the given string, from the shortest to the longest.\n *\n * @param str The input string.\n * @return std::vector<std::string>\n *         A vector containing prefixes in increasing order of length.\n *\n * Example:\n *   std::vector<std::string> v = all_prefixes(\"abc\");\n *   // v == { \"a\", \"ab\", \"abc\" }\n *\n * Complexity:\n *   O(n^2) time and O(n^2) additional space, where n is the length of `str`.\n *   (Each prefix is a new string, so copying costs O(k) for each of the n prefixes).\n */\nstd::vector<std::string> all_prefixes(const std::string& str) {\n    std::vector<std::string> res;\n    res.reserve(str.size());           // avoid reallocations\n\n    // Build prefixes incrementally\n    std::string current;\n    current.reserve(str.size());       // optional but cheap\n    for (char c : str) {\n        current.push_back(c);\n        res.push_back(current);\n    }\n    return res;\n}\n```\n\n### How it works\n1. **Reserve space** \u2013 `res.reserve(str.size())` pre\u2011allocates enough space for all prefixes, eliminating reallocations.  \n2. **Incremental construction** \u2013 We build a temporary string `current` by adding one character at a time.  \n3. **Append to result** \u2013 After each addition we push `current` into `res`.  \n4. **Return** \u2013 Finally, we return the vector containing all prefixes.\n\nThe function is `const`\u2011correct and does not modify the input string. It is also very small, making it ideal for copy\u2011pasting into other projects."]}
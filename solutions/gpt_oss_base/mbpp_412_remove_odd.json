{"name": "mbpp_412_remove_odd", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to remove odd numbers from a given vector.\nstd::vector<long> remove_odd(std::vector<long> l) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_412_remove_odd.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = remove_odd;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)6}))) == (std::vector<long>({(long)2, (long)4, (long)6})));\n    assert(candidate((std::vector<long>({(long)10, (long)20, (long)3}))) == (std::vector<long>({(long)10, (long)20})));\n}\n", "stop_tokens": ["\n}"], "completions": ["```cpp\n#include <algorithm>\n#include <vector>\n\n/* ------------------------------------------------------------------\n   Removes all odd numbers from the given vector and returns the\n   modified vector.\n\n   Parameters\n   ----------\n   l : std::vector<long>\n        The vector from which odd elements should be removed.\n\n   Returns\n   -------\n   std::vector<long>\n        A new vector that contains only the even numbers from the\n        original vector.\n   ------------------------------------------------------------------ */\nstd::vector<long> remove_odd(std::vector<long> l)\n{\n    // Move all odd numbers to the end of the vector\n    auto new_end = std::remove_if(l.begin(), l.end(),\n                                  [](long x) { return x % 2 != 0; });\n\n    // Erase the removed elements (the ones that were moved to the end)\n    l.erase(new_end, l.end());\n\n    return l;\n}\n```\n\n**Explanation**\n\n* `std::remove_if` replaces the odd elements with the elements that\n  follow them and returns an iterator to the new logical end of the\n  vector.\n* `erase` then physically removes the elements beyond that iterator,\n  giving a vector that contains only even numbers.\n\nFeel free to use this function as is or adapt it to your own code.", "Below is a **stand\u2011alone C++** implementation of a function that removes all odd numbers from a `std::vector<long>` and returns a new vector that contains only the even values.\n\n```cpp\n// remove_odd.cpp\n// Compile with:   g++ -std=c++17 -O2 remove_odd.cpp -o remove_odd\n// Usage example:  See the main() below.\n\n#include <iostream>\n#include <vector>\n#include <cassert>\n\n/**\n * @brief Remove odd numbers from the input vector.\n *\n * The function takes ownership of the input vector, iterates over the elements,\n * keeps the even ones, and returns a new vector containing only the even\n * numbers.\n *\n * @param l Input vector of long integers.\n * @return std::vector<long> a new vector (or the same vector if no odds).\n */\nstd::vector<long> remove_odd(std::vector<long> l)\n{\n    // Reserve enough space for the worst\u2011case scenario (no odds removed).\n    std::vector<long> result;\n    result.reserve(l.size());\n\n    for (const auto &v : l) {\n        if ((v & 1LL) == 0LL) {   // check evenness using bitwise AND\n            result.push_back(v);\n        }\n    }\n    return result;\n}\n\n/* ------------------- Unit tests ------------------- */\nvoid test_remove_odd()\n{\n    // 1. Empty vector\n    assert(remove_odd({}).empty());\n\n    // 2. All odds\n    std::vector<long> odds{1, 3, 5, 7};\n    assert(remove_odd(odds).empty());\n\n    // 3. Mix of odds and evens\n    std::vector<long> mix{1, 2, 3, 4, 5};\n    std::vector<long> expected{2, 4};\n    assert(remove_odd(mix) == expected);\n\n    // 4. All evens\n    std::vector<long> evens{2, 4, 6, 8};\n    assert(remove_odd(evens) == evens);\n\n    std::cout << \"All tests passed.\\n\";\n}\n\nint main()\n{\n    test_remove_odd();\n\n    // Demo\n    std::vector<long> data{10, 21, 32, 43, 54, 65};\n    auto even = remove_odd(data);\n    std::cout << \"Even numbers:\";\n    for (auto n : even) std::cout << ' ' << n;\n    std::cout << '\\n';\n    return 0;\n}\n```\n\n### Why this implementation is good\n\n| Feature | Why it matters |\n|--------|----------------|\n| **Move semantics** | The function takes the vector by value. If the caller passes an r\u2011value or moves the vector, we avoid an extra copy. |\n| **Bitwise even check** | `(v & 1LL) == 0LL` is faster than `v % 2 == 0` because it avoids a modulo operation. |\n| **Reserve capacity once** | `result.reserve(l.size())` pre\u2011allocates space, preventing multiple reallocations. |\n| **Self\u2011contained tests** | A tiny `assert`\u2011based test harness demonstrates correctness and can be run on any compiler that supports C++17. |\n| **Standard headers** | Only `<iostream>`, `<vector>`, and `<cassert>` are needed\u2014no `<bits/stdc++.h>` or non\u2011standard includes. |\n\nYou can drop the `main()` part into another translation unit or keep it for quick testing. The function itself is just the `remove_odd` declaration shown above.", "Below is a complete, self\u2011contained C++ implementation that removes every odd\nnumber from a vector of `long` integers.  \nThe function is written in idiomatic modern C++ (C++17/20) and uses only\nstandard library facilities, so it will compile with any standard\u2011conforming\ncompiler.\n\n```cpp\n// remove_odd.cpp\n#include <vector>\n#include <algorithm>\n#include <iostream>\n\n// -----------------------------------------------------------------------------\n//  Function: remove_odd\n//  ---------------------\n//  Removes all odd numbers from the supplied vector and returns the\n//  reduced vector.  The function uses std::remove_if followed by\n//  erase\u2011erase idiom to achieve O(n) time complexity and constant\n//  extra space.\n//\n//  Parameters:\n//      l : vector<long>  \u2013 The input vector.  It is passed by value,\n//                          so that the caller\u2019s vector is not modified.\n//                          (If you want to modify the caller\u2019s vector, just\n//                          pass it by reference instead.)\n//  Returns:\n//      A new vector containing only the even numbers from l.\n// -----------------------------------------------------------------------------\nstd::vector<long> remove_odd(std::vector<long> l)\n{\n    // Keep every element that is even (x % 2 == 0).\n    l.erase(\n        std::remove_if(l.begin(), l.end(),\n                       [](long v){ return v % 2 != 0; }),   // predicate\n        l.end());\n    return l;\n}\n\n// -----------------------------------------------------------------------------\n//  Example usage + simple test harness\n// -----------------------------------------------------------------------------\nint main()\n{\n    std::vector<long> data{ 5, 12, 7, 10, 3, 8, 14, 9 };\n\n    // Original vector\n    std::cout << \"Original: \";\n    for (long v : data) std::cout << v << ' ';\n    std::cout << '\\n';\n\n    std::vector<long> evens = remove_odd(data);\n\n    // Result\n    std::cout << \"Evens   : \";\n    for (long v : evens) std::cout << v << ' ';\n    std::cout << '\\n';\n\n    // Basic sanity test\n    assert((evens == std::vector<long>{12,10,8,14}));\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\n### Key points\n\n| Operation | What it does | Complexity |\n|-----------|--------------|------------|\n| `std::remove_if` | Reorders the vector so that all elements that *do not* satisfy the predicate (`v % 2 != 0`) are moved to the back; returns an iterator to the new logical end. | `O(n)` |\n| `erase(first, last)` | Erases the trailing elements that were just moved to the back. | `O(n)` |\n| Pass-by-value | Keeps the function pure: the caller\u2019s vector is unchanged. Change to `std::vector<long>& l` if you want an in\u2011place modification. |\n\nCompile with a modern compiler, for example:\n\n```\ng++ -std=c++20 -O2 -Wall -Wextra remove_odd.cpp -o remove_odd\n```\n\nThis code is fully portable, requires no external dependencies, and follows best practices for C++ code that manipulates containers."]}
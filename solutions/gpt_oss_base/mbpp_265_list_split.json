{"name": "mbpp_265_list_split", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes in a vector and an integer n and splits a vector for every nth element, returning a vector of the resulting vectors.\nstd::vector<std::vector<std::any>> list_split(std::vector<std::any> S, long step) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_265_list_split.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = list_split;\n    assert(candidate((std::vector<std::any>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\", (std::string)\"d\", (std::string)\"e\", (std::string)\"f\", (std::string)\"g\", (std::string)\"h\", (std::string)\"i\", (std::string)\"j\", (std::string)\"k\", (std::string)\"l\", (std::string)\"m\", (std::string)\"n\"})), (3)) == (std::vector<std::vector<std::any>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"a\", (std::string)\"d\", (std::string)\"g\", (std::string)\"j\", (std::string)\"m\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"b\", (std::string)\"e\", (std::string)\"h\", (std::string)\"k\", (std::string)\"n\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"c\", (std::string)\"f\", (std::string)\"i\", (std::string)\"l\"})})));\n    assert(candidate((std::vector<std::any>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10, (long)11, (long)12, (long)13, (long)14})), (3)) == (std::vector<std::vector<std::any>>({(std::vector<long>)std::vector<long>({(long)1, (long)4, (long)7, (long)10, (long)13}), (std::vector<long>)std::vector<long>({(long)2, (long)5, (long)8, (long)11, (long)14}), (std::vector<long>)std::vector<long>({(long)3, (long)6, (long)9, (long)12})})));\n    assert(candidate((std::vector<std::any>({(std::string)\"python\", (std::string)\"java\", (std::string)\"C\", (std::string)\"C++\", (std::string)\"DBMS\", (std::string)\"SQL\"})), (2)) == (std::vector<std::vector<std::any>>({(std::vector<std::string>)std::vector<std::string>({(std::string)\"python\", (std::string)\"C\", (std::string)\"DBMS\"}), (std::vector<std::string>)std::vector<std::string>({(std::string)\"java\", (std::string)\"C++\", (std::string)\"SQL\"})})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a complete, self\u2011contained implementation of `list_split`.  \nThe function simply walks through the input vector and whenever it encounters an\nindex that is a multiple of `step` it starts a new sub\u2011vector.  \nIf `step` is 0 or negative the function throws an `std::invalid_argument` so that\nthe caller can see that the input is wrong.\n\n```cpp\n#include <any>\n#include <vector>\n#include <stdexcept>\n#include <numeric>\n\n/** Split the vector `S` into slices of length `step`.\n *\n *  Example\n *  -------\n *  S = {1,2,3,4,5,6,7,8,9,10,11}\n *  step = 4\n *  result = {{1,2,3,4}, {5,6,7,8}, {9,10,11}}\n *\n *  The function is generic because it works with std::any, so you can put any\n *  type in the original vector.\n */\nstd::vector<std::vector<std::any>>\nlist_split(const std::vector<std::any>& S, long step)\n{\n    if (step <= 0)\n        throw std::invalid_argument(\"step must be positive\");\n\n    std::vector<std::vector<std::any>> result;\n    result.reserve((S.size() + step - 1) / step);   // avoid reallocations\n\n    for (std::size_t i = 0; i < S.size(); i++) {\n        if (i % step == 0)                 // start a new chunk\n            result.emplace_back();\n\n        result.back().push_back(S[i]);      // add the element to the last chunk\n    }\n\n    return result;\n}\n```\n\n### How to use it\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<std::any> v = {1, 2, 3, 4, 5, 6, 7};\n    auto chunks = list_split(v, 3);\n\n    for (const auto& chunk : chunks) {\n        for (const auto& e : chunk)\n            std::cout << std::any_cast<int>(e) << ' ';\n        std::cout << '\\n';\n    }\n    // Output:\n    // 1 2 3\n    // 4 5 6\n    // 7\n}\n```\n\nFeel free to adapt the casting and printing logic to your own data types.", "Here is a ready\u2011to\u2011compile implementation that does exactly what you described:  \n\n* It receives a `std::vector<std::any>` called `S` and a `long step` value (`n`).  \n* It splits the vector every `step` elements.  \n* Each chunk becomes an entry in the outer vector and the function returns the collection of these chunks.  \n\nThe function includes a few safety checks (e.g., non\u2011positive\u202fstep) and uses standard algorithms only, so it works in any conforming C++17/20/23 compiler.\n\n```cpp\n#include <any>\n#include <vector>\n#include <stdexcept>\n\n/**\n * @brief Splits a vector into sub\u2011vectors every `step` elements.\n *\n * Example:\n *   S = [1,2,3,4,5,6,7], step = 3\n *   Result = { [1,2,3], [4,5,6], [7] }\n *\n * @param S    The input vector of std::any elements to be split.\n * @param step The number of elements per chunk (must be > 0).\n * @return     A vector containing the split sub\u2011vectors.\n * @throws     std::invalid_argument if `step <= 0`.\n */\nstd::vector<std::vector<std::any>> list_split(\n    std::vector<std::any> const& S,\n    long step)\n{\n    if (step <= 0)\n        throw std::invalid_argument(\"step must be a positive integer\");\n\n    std::vector<std::vector<std::any>> result;\n    result.reserve((S.size() + step - 1) / step);   // optional, to avoid reallocations\n\n    for (size_t i = 0; i < S.size(); i += step) {\n        size_t end = std::min(S.size(), i + static_cast<size_t>(step));\n        result.emplace_back(S.begin() + i, S.begin() + end);\n    }\n\n    return result;\n}\n```\n\n### How to use it\n\n```cpp\n#include <iostream>\n#include <any>\n\nint main() {\n    std::vector<std::any> vec;\n    for (int i = 1; i <= 10; ++i) vec.emplace_back(i);\n\n    auto chunks = list_split(vec, 4);\n\n    for (const auto& chunk : chunks) {\n        std::cout << \"[\";\n        for (const auto& e : chunk) {\n            std::cout << std::any_cast<int>(e) << \" \";\n        }\n        std::cout << \"]\\n\";\n    }\n}\n```\n\nThis will output:\n\n```\n[1 2 3 4 ]\n[5 6 7 8 ]\n[9 10 ]\n```\n\nFeel free to adapt the `any_cast` part in your own code depending on the types you actually store in the vector.", "Here is a minimal, self\u2011contained implementation of the requested `list_split` function.  \nIt works for any type stored in the input `std::vector<std::any>` and returns a\nvector of those sub\u2011vectors. The code is fully commented and does not rely on any\nexternal libraries beyond the standard C++ library.\n\n```cpp\n#include <vector>\n#include <any>\n\n/**\n * @brief  Split a vector into chunks of size `step`.\n *\n * The function takes a copy of the input vector `S`.  \n * Every `step` elements (or the remaining elements at the end) are put\n * into a new vector which is appended to the result.\n *\n * @tparam T  (unused, but retained in the original signature)\n * @param S   Input vector of `std::any`, allowed to be empty.\n * @param step  Number of elements per chunk.  Must be > 0.\n * @return  Vector of sub\u2011vectors (each a `std::vector<std::any>`).\n */\nstd::vector<std::vector<std::any>> list_split(const std::vector<std::any>& S,\n                                              std::size_t step)\n{\n    // Defensive programming: make sure step is not zero.\n    if (step == 0)\n        throw std::invalid_argument(\"step must be > 0\");\n\n    std::vector<std::vector<std::any>> result;\n    result.reserve((S.size() + step - 1) / step);   // pre\u2011allocate\n\n    for (std::size_t i = 0; i < S.size(); i += step)\n    {\n        std::size_t end = std::min(i + step, S.size());\n        // Construct a sub\u2011vector containing the slice [i, end)\n        std::vector<std::any> chunk(S.begin() + i, S.begin() + end);\n        result.push_back(std::move(chunk));\n    }\n\n    return result;\n}\n```\n\n### How it works\n\n* We take the input vector as a **const reference** to avoid an unnecessary copy.  \n* `step` is checked for zero (to prevent division/loops that would crash).  \n* The result vector is reserved with the exact number of chunks needed:  \n  `ceil(S.size() / step)`.  \n* A simple loop iterates over the indices in increments of `step`.  \n  For each iteration we build a sub\u2011vector from the range `[i, end)` where\n  `end = min(i + step, S.size())`.  \n* `std::vector<std::any>` is cheap to copy/move, so we simply move each chunk\n  into the result.\n\n### Usage example\n\n```cpp\n#include <iostream>\n#include <any>\n\nint main()\n{\n    std::vector<std::any> v = { 1, 2.5, std::string(\"foo\"), 4 };\n    auto chunks = list_split(v, 2);\n\n    for (const auto& chunk : chunks)\n    {\n        for (const auto& elem : chunk)\n        {\n            if (elem.type() == typeid(int))\n                std::cout << std::any_cast<int>(elem) << ' ';\n            else if (elem.type() == typeid(double))\n                std::cout << std::any_cast<double>(elem) << ' ';\n            else if (elem.type() == typeid(std::string))\n                std::cout << std::any_cast<std::string>(elem) << ' ';\n        }\n        std::cout << '\\n';\n    }\n}\n```\n\nThis will output:\n\n```\n1 2.5 \nfoo 4\n```\n\nFeel free to adapt the type handling or return type to your project\u2019s specific needs."]}
{"name": "HumanEval_19_sort_numbers", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_19_sort_numbers.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = sort_numbers;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"three\")) == (\"three\"));\n    assert(candidate((\"three five nine\")) == (\"three five nine\"));\n    assert(candidate((\"five zero four seven nine eight\")) == (\"zero four five seven eight nine\"));\n    assert(candidate((\"six five four three two one zero\")) == (\"zero one two three four five six\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["**Solution Explanation**\n\nWe receive a single string that contains the English words for digits  \n(`\"zero\"` \u2026 `\"nine\"`), separated by one or more spaces.  \nThe task is to return a new string where those words are sorted in\nascending numerical order (so `\"three\"` comes before `\"five\"`).\n\nThe straightforward way is:\n\n1. **Tokenise** the input string \u2013 split it on whitespace.\n2. **Map** each word to the numeric value it represents (0 \u2026 9).  \n   We can store the mapping in an `unordered_map<string,int>`.\n3. **Sort** the list of words according to that numeric value.  \n   We use `std::sort` with a custom comparator that looks up the numeric\n   value in the mapping.\n4. **Re\u2011join** the sorted words into a single string with single spaces.\n\nThe algorithm runs in \u0398(n\u202flog\u202fn) time (because of the sort) and uses\n\u0398(n) extra memory, where *n* is the number of words in the input.\n\n\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// ------------------------------------------------------------\n// Helper: build the word -> digit mapping\nstatic const unordered_map<string, int> word_to_digit = {\n    {\"zero\",   0},\n    {\"one\",    1},\n    {\"two\",    2},\n    {\"three\",  3},\n    {\"four\",   4},\n    {\"five\",   5},\n    {\"six\",    6},\n    {\"seven\",  7},\n    {\"eight\",  8},\n    {\"nine\",   9}\n};\n// ------------------------------------------------------------\n\nstd::string sort_numbers(const std::string& numbers) {\n    // 1. split the string by whitespace\n    vector<string> tokens;\n    string token;\n    std::istringstream iss(numbers);\n    while (iss >> token) {\n        tokens.push_back(token);\n    }\n\n    // 2. sort using the numeric mapping\n    std::sort(tokens.begin(), tokens.end(),\n              [](const string& a, const string& b) {\n                  return word_to_digit.at(a) < word_to_digit.at(b);\n              });\n\n    // 3. join back into a single string\n    std::ostringstream oss;\n    for (size_t i = 0; i < tokens.size(); ++i) {\n        if (i) oss << ' ';\n        oss << tokens[i];\n    }\n    return oss.str();\n}\n```\n\n**Test**\n\n```cpp\nint main() {\n    std::cout << sort_numbers(\"three one five\") << '\\n';  // one three five\n    std::cout << sort_numbers(\"nine eight seven\") << '\\n'; // seven eight nine\n}\n```\n\nThe function correctly orders the English words from smallest to largest digit.", "Below is a self\u2011contained C++\u201117 implementation that satisfies the description\nand works with the example given.  \nThe algorithm is straightforward:\n\n1. Keep a mapping from each textual number to its integer value.  \n2. Split the input string on whitespace.  \n3. Sort the tokens by the integer value obtained from the map.  \n4. Join the sorted tokens back into a single string.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Return the string with numbers sorted from smallest to largest\nstring sort_numbers(const string &numbers) {\n    // 1. Mapping from word to numeric value\n    static const unordered_map<string,int> order{\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4},\n        {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // 2. Split the input string on whitespace\n    vector<string> tokens;\n    string token;\n    istringstream iss(numbers);\n    while (iss >> token) {\n        // Optional: Validate that the token is one of the allowed words\n        if (order.find(token) == order.end()) {\n            // If you want to be strict, you could throw an exception here.\n            // For this implementation we simply ignore invalid tokens.\n            continue;\n        }\n        tokens.push_back(token);\n    }\n\n    // 3. Sort according to the numeric value\n    sort(tokens.begin(), tokens.end(),\n         [&](const string &a, const string &b) {\n             return order.at(a) < order.at(b);\n         });\n\n    // 4. Join back into a single string\n    string result;\n    for (size_t i = 0; i < tokens.size(); ++i) {\n        if (i) result += ' ';\n        result += tokens[i];\n    }\n    return result;\n}\n\n// Example usage\nint main() {\n    string input = \"three one five\";\n    cout << '\"' << sort_numbers(input) << '\"' << endl;   // prints: \"one three five\"\n    return 0;\n}\n```\n\n### Explanation\n\n- **`unordered_map<string,int>`** provides O(1) lookup time for mapping word to value.\n- **`istringstream`** tokenises the input on whitespace.\n- The custom comparator in `sort` uses the map to compare words numerically.\n- After sorting, the words are concatenated with single spaces between them.\n\nThe program compiles with a standard C++ compiler (`g++ -std=c++17`). It will handle any whitespace\u2011separated string containing the words \u201czero\u201d to \u201cnine\u201d and produce the correctly sorted string.", "Below is a clean, self\u2011contained implementation that can be dropped straight into a C++ file.  \nThe function `sort_numbers` takes a space\u2011delimited string containing the words *zero* \u2026 *nine*, converts each word to its numeric value, sorts them, and returns the resulting string in the same format.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// Map the word representation to its numeric value.\nstatic const unordered_map<string, int> word_to_val = {\n    {\"zero\",   0},\n    {\"one\",    1},\n    {\"two\",    2},\n    {\"three\",  3},\n    {\"four\",   4},\n    {\"five\",   5},\n    {\"six\",    6},\n    {\"seven\",  7},\n    {\"eight\",  8},\n    {\"nine\",   9}\n};\n\n/// Reverse map (numeric value \u2192 word)\nstatic const vector<string> val_to_word = {\n    \"zero\", \"one\", \"two\", \"three\", \"four\",\n    \"five\", \"six\", \"seven\", \"eight\", \"nine\"\n};\n\n/// Sort a space\u2011delimited string of number words.\nstring sort_numbers(const string &numbers)\n{\n    if (numbers.empty())\n        return \"\";\n\n    // Tokenise the input\n    vector<string> tokens;\n    istringstream iss(numbers);\n    string tok;\n    while (iss >> tok) tokens.push_back(tok);\n\n    // Convert words \u2192 numbers, sort, then convert back\n    vector<int> vals;\n    vals.reserve(tokens.size());\n    for (const auto &w : tokens) {\n        auto it = word_to_val.find(w);\n        if (it == word_to_val.end())\n            throw std::invalid_argument(\"unknown word: \" + w);\n        vals.push_back(it->second);\n    }\n\n    sort(vals.begin(), vals.end());\n\n    // Re\u2011create the string\n    ostringstream oss;\n    for (size_t i = 0; i < vals.size(); ++i) {\n        if (i) oss << ' ';\n        oss << val_to_word[vals[i]];\n    }\n    return oss.str();\n}\n```\n\n### Usage example\n\n```cpp\nint main() {\n    cout << sort_numbers(\"three one five\") << endl;   // prints: one three five\n    cout << sort_numbers(\"nine two zero\") << endl;    // prints: zero two nine\n}\n```\n\nThe function has no external dependencies beyond the Standard Library, handles empty strings gracefully, and throws an exception for any token that is not one of the ten allowed words."]}
{"name": "mbpp_400_extract_freq", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to extract the number of unique tuples in the given vector.\nlong extract_freq(std::vector<std::tuple<long, long>> test_list) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_400_extract_freq.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = extract_freq;\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(3, 4), (std::tuple<long, long>)std::make_tuple(1, 2), (std::tuple<long, long>)std::make_tuple(4, 3), (std::tuple<long, long>)std::make_tuple(5, 6)}))) == (3));\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(4, 15), (std::tuple<long, long>)std::make_tuple(2, 3), (std::tuple<long, long>)std::make_tuple(5, 4), (std::tuple<long, long>)std::make_tuple(6, 7)}))) == (4));\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(5, 16), (std::tuple<long, long>)std::make_tuple(2, 3), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(6, 9)}))) == (4));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a concise implementation that counts the number of distinct tuples in the vector:\n\n```cpp\n#include <vector>\n#include <tuple>\n#include <unordered_set>\n\nlong extract_freq(std::vector<std::tuple<long, long>> test_list)\n{\n    // A custom hash function for std::tuple<long,long>\n    struct TupleHash {\n        std::size_t operator()(std::tuple<long, long> const& t) const noexcept {\n            std::size_t h1 = std::hash<long>()(std::get<0>(t));\n            std::size_t h2 = std::hash<long>()(std::get<1>(t));\n            // Combine the two hashes (boost style)\n            return h1 ^ (h2 + 0x9e3779b9 + (h1 << 6) + (h1 >> 2));\n        }\n    };\n\n    // Use unordered_set to automatically keep only unique tuples\n    std::unordered_set<std::tuple<long,long>, TupleHash> uniq;\n    uniq.reserve(test_list.size());          // optional: reduce rehashing\n    uniq.insert(test_list.begin(), test_list.end());\n\n    return static_cast<long>(uniq.size());\n}\n```\n\n### How it works\n1. **Hash Function** \u2013 Because `std::unordered_set` needs a hash, a lightweight hash for the tuple is defined.  \n2. **Insertion** \u2013 All tuples from `test_list` are inserted into the set; duplicates are ignored.  \n3. **Result** \u2013 The size of the set is the number of unique tuples.\n\n### Usage\n\n```cpp\nint main() {\n    std::vector<std::tuple<long,long>> v = {\n        {1,2}, {3,4}, {1,2}, {5,6}\n    };\n    long unique = extract_freq(v);   // unique == 3\n    std::cout << unique << std::endl;\n}\n```\n\nThe function runs in roughly `O(n)` average\u2011time complexity and uses `O(n)` additional memory, where `n` is the length of `test_list`.", "Here\u2019s a robust and compact implementation that counts how many **distinct** `(long, long)` tuples are present in the supplied vector.  \nThe code uses an `unordered_set` with a custom hash for `std::pair<long,long>` (which is what `std::tuple<long,long>` unpacks to). This gives `O(n)` average\u2011time complexity and O(n) additional space.\n\n```cpp\n#include <vector>\n#include <tuple>\n#include <unordered_set>\n\n/* ---------- Helper: hash for std::pair<long,long> ---------- */\nstruct PairHash\n{\n    std::size_t operator()( const std::pair<long,long>& p ) const noexcept\n    {\n        // Uses the well\u2011known boost\u2011style splitmix64 trick.\n        std::size_t lhs = std::hash<long>{}(p.first);\n        std::size_t rhs = std::hash<long>{}(p.second);\n        // Combine the two hashes\n        return lhs ^ ( rhs + 0x9e3779b9 + (lhs<<6) + (lhs>>2) );\n    }\n};\n\n/* ---------- Function to count unique tuples ---------- */\nlong extract_freq( const std::vector<std::tuple<long,long>>& test_list )\n{\n    std::unordered_set< std::pair<long,long>, PairHash > uniq;\n    uniq.reserve( test_list.size() );          // avoid re\u2011hashing\n    \n    for ( const auto& t : test_list )\n        uniq.emplace( std::get<0>(t), std::get<1>(t) );\n    \n    return static_cast<long>( uniq.size() );\n}\n```\n\n### What does it do?\n\n1. **Iterate** over every element of `test_list`.  \n2. Convert each `tuple<long,long>` to a `std::pair<long,long>` (the same memory layout).  \n3. Insert that pair into an `unordered_set` \u2013 duplicates are automatically discarded.  \n4. Return the size of the set, which represents the number of unique tuples.\n\nThe function works in linear time and handles any `std::vector` size, including an empty vector (returns `0`).", "Here\u2019s a minimal, self\u2011contained implementation of the `extract_freq` function that counts how many *distinct* `(long, long)` tuples are present in the input vector.  \nThe function simply inserts every tuple into an `std::unordered_set` (or `std::set`, if you prefer deterministic ordering) and then returns the size of that set.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n * Count the number of unique tuples in a vector.\n *\n * Parameters\n * ----------\n *   test_list : vector of pair-like tuples\n *        The input vector containing tuples to be examined.\n *\n * Returns\n * -------\n *   long : number of distinct tuples found in `test_list`.\n */\nlong extract_freq(const vector<tuple<long, long>>& test_list) {\n    // We use an unordered_set to keep unique tuples.\n    unordered_set<tuple<long, long>> seen;\n    for (const auto& t : test_list) {\n        seen.insert(t);\n    }\n    return static_cast<long>(seen.size());\n}\n```\n\n### Quick sanity check\n\n```cpp\nint main() {\n    vector<tuple<long,long>> data = {\n        {1,2}, {3,4}, {1,2}, {5,6}, {3,4}\n    };\n    cout << extract_freq(data) << '\\n';  // Outputs 3\n}\n```\n\nThe function works in *O(n)* time and uses *O(k)* auxiliary space, where *k* is the number of distinct tuples."]}
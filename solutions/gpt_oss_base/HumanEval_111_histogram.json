{"name": "HumanEval_111_histogram", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_111_histogram.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = histogram;\n    assert(candidate((\"a b b a\")) == (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}})));\n    assert(candidate((\"a b c a b\")) == (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}})));\n    assert(candidate((\"a b c d g\")) == (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}, {\"d\", 1}, {\"g\", 1}})));\n    assert(candidate((\"r t g\")) == (std::map<std::string,long>({{\"r\", 1}, {\"t\", 1}, {\"g\", 1}})));\n    assert(candidate((\"b b b b a\")) == (std::map<std::string,long>({{\"b\", 4}})));\n    assert(candidate((\"r t g\")) == (std::map<std::string,long>({{\"r\", 1}, {\"t\", 1}, {\"g\", 1}})));\n    assert(candidate((\"\")) == (std::map<std::string,long>()));\n    assert(candidate((\"a\")) == (std::map<std::string,long>({{\"a\", 1}})));\n}\n", "stop_tokens": ["\n}"], "completions": ["**Solution**\n\nThe function receives a string that contains lowercase letters separated by spaces.  \nGoals:\n\n1. Split the string into its individual letters.\n2. Count how many times each letter appears.\n3. Determine the maximum count.\n4. Return a `std::map<std::string, long>` that contains **only** the letters that reach the maximum count (if the string is empty, return an empty map).\n\nThe implementation below uses only standard C++ (no\n`<bits/stdc++.h>` is kept because it was in the original template).\n\n```cpp\n#include <string>\n#include <map>\n#include <sstream>\n#include <iomanip>\n#include <cctype>\n\nstd::map<std::string,long> histogram(std::string test)\n{\n    // map that will hold the final result\n    std::map<std::string,long> result;\n\n    // If the input is empty, return an empty map immediately\n    if (test.empty())\n        return result;\n\n    // 1. Split the string into words (letters)\n    std::istringstream iss(test);\n    std::string token;\n    std::map<std::string,long> counter;    // to store frequencies\n\n    while (iss >> token) {\n        // make sure the token is a single lowercase letter\n        if (token.size() == 1 && std::islower(static_cast<unsigned char>(token[0]))) {\n            counter[token]++;                 // 2. Count occurrences\n        }\n        // if the token is not a single lowercase letter we simply ignore\n        // the original problem only mentioned that input consists of those\n    }\n\n    // 3. Find the maximum count\n    long maxCount = 0;\n    for (const auto &p : counter) {\n        if (p.second > maxCount)\n            maxCount = p.second;\n    }\n\n    // 4. Return only the letters that have the maximum count\n    for (const auto &p : counter) {\n        if (p.second == maxCount)\n            result[p.first] = p.second;\n    }\n\n    return result;\n}\n```\n\n### Explanation\n\n| Step | What the code does | Why it's needed |\n|------|--------------------|-----------------|\n| **Split** | `std::istringstream iss(test);` and `while (iss >> token)` | Separates the string by spaces. |\n| **Validate token** | `if (token.size()==1 && std::islower(...))` | Ensures only single lowercase letters are counted. |\n| **Counting** | `counter[token]++;` | Builds a frequency table. |\n| **Maximum** | Scan `counter` to find `maxCount`. | Needed to know which letters are the most frequent. |\n| **Filtering** | Add to `result` only those with `counter[p.first] == maxCount`. | Matches the problem statement. |\n\n### Edge cases handled\n\n* Empty input \u2192 returns an empty map.\n* Multiple letters with the same maximum frequency \u2192 all are returned.\n* Tokens that are not single lowercase letters are silently ignored (the problem guarantees that the string consists of space\u2011separated lowercase letters, so this is only a safety measure).\n\nThe function returns a `std::map<std::string, long>` exactly as required.", "Below is a minimal, but fully\u2011functional implementation of `histogram`.  \nIt follows exactly the specification shown in the doctests:  \n\n* It parses the input string into individual **lower\u2011case letters** separated by whitespace.  \n* It counts how many times each letter appears.  \n* It then extracts the letter(s) that appear the most often and returns them in a\n  `std::map<std::string, long>` together with their frequency.  \n* If the input string is empty or contains no letters, an empty map is returned.\n\n```cpp\n#include <cassert>\n#include <bits/stdc++.h>\n\n/// Return a map of the letter(s) with the highest repetition count\n/// together with the count.  If no letters are present an empty map\n/// is returned.\n///\n/// @param test A string containing space\u2011separated lower\u2011case letters.\n/// @return A map from letter (as a string) to its count, containing only\n///         the letter(s) that occur most frequently.\nstd::map<std::string, long> histogram(std::string test)\n{\n    // 1. Count the frequency of every letter.\n    std::unordered_map<char, long> freq;\n    std::istringstream iss(test);\n    std::string token;\n\n    while (iss >> token) {          // token is a single letter\n        if (!token.empty()) {\n            char c = token[0];\n            // Only consider lower\u2013case letters; other cases are ignored.\n            if (c >= 'a' && c <= 'z')\n                ++freq[c];\n        }\n    }\n\n    // 2. Find the maximum count.\n    long maxCount = 0;\n    for (const auto &p : freq)\n        if (p.second > maxCount)\n            maxCount = p.second;\n\n    // 3. Build the result map containing only the letters with maxCount.\n    std::map<std::string, long> result;\n    if (maxCount > 0) {\n        for (const auto &p : freq) {\n            if (p.second == maxCount) {\n                std::string key(1, p.first); // convert char \u2192 string\n                result[key] = maxCount;\n            }\n        }\n    }\n\n    return result;\n}\n```\n\n### Why this implementation\n\n* **No external dependencies** \u2013 the whole routine lives in `<bits/stdc++.h>` in the main project, but it uses only the standard headers (`unordered_map`, `sstream`, `map`).  \n* **Straight\u2011forward logic** \u2013 first a frequency table, then a simple scan for the maximum count, finally building the desired result.  \n* **Robustness** \u2013 the code ignores empty tokens and ensures only lower\u2011case characters are counted.\n\nYou can copy\u2011paste this function as is into your project. Feel free to tweak the input validation or the type of the keys/values if you prefer `char` instead of `std::string`.", "Here\u2019s a complete, self\u2011contained implementation of the `histogram` function.  \nIt parses the input string, counts each letter, and then returns a map that contains only the letters that reach the maximum frequency (there can be more than one if there\u2019s a tie).\n\n```cpp\n#include <string>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n\n/*  histogram\n *\n *  Given a whitespace\u2011separated string of lowercase letters (e.g. \"a b c\"),\n *  return a `std::map<std::string,long>` that contains the letter(s) that\n *  appear most frequently together with their count.\n *\n *  If the input string is empty, the returned map will be empty.\n */\nstd::map<std::string, long> histogram(const std::string& test)\n{\n    /* ---------- 1. Tokenize the string -------------------------------- */\n    std::istringstream iss(test);\n    std::string token;\n    std::vector<std::string> words;\n\n    while (iss >> token)           // `>>` skips whitespace automatically\n        words.push_back(token);    // collect each word\n\n    if (words.empty())\n        return {};                // nothing to count\n\n    /* ---------- 2. Count occurrences ---------------------------------- */\n    std::map<std::string, long> freq;\n    for (const auto& w : words)\n        ++freq[w];\n\n    /* ---------- 3. Find the maximum frequency ------------------------ */\n    long maxCount = 0;\n    for (const auto& [letter, count] : freq)\n        if (count > maxCount)\n            maxCount = count;\n\n    /* ---------- 4. Build the result map (only winners) ---------------- */\n    std::map<std::string, long> result;\n    for (const auto& [letter, count] : freq)\n        if (count == maxCount)\n            result[letter] = count;\n\n    return result;\n}\n```\n\n### How it works\n\n1. **Tokenization** \u2013 `std::istringstream` and the extraction operator (`>>`) read each space\u2011separated word from the input string.\n2. **Counting** \u2013 A map (`freq`) stores how many times each word appears.\n3. **Maximum** \u2013 We scan the map to determine the largest count.\n4. **Result** \u2013 We construct a new map that contains only the key(s) whose count equals the maximum.\n\n### Test cases\n\n```cpp\n#include <iostream>\n\nauto printMap = [](const std::map<std::string,long>& m) {\n    std::cout << \"{ \";\n    for (auto it = m.cbegin(); it != m.cend(); ++it) {\n        std::cout << it->first << \":\" << it->second;\n        if (std::next(it) != m.cend()) std::cout << \", \";\n    }\n    std::cout << \" }\\n\";\n};\n\nint main()\n{\n    std::cout << \"histogram(\\\"a b c\\\") -> \";\n    printMap(histogram(\"a b c\"));          // { a:1, b:1, c:1 }\n\n    std::cout << \"histogram(\\\"a b b a\\\") -> \";\n    printMap(histogram(\"a b b a\"));        // { a:2, b:2 }\n\n    std::cout << \"histogram(\\\"a b c a b\\\") -> \";\n    printMap(histogram(\"a b c a b\"));      // { a:2, b:2 }\n\n    std::cout << \"histogram(\\\"b b b b a\\\") -> \";\n    printMap(histogram(\"b b b b a\"));      // { b:4 }\n\n    std::cout << \"histogram(\\\"\\\") -> \";\n    printMap(histogram(\"\"));               // { }\n}\n```\n\nThe implementation is straightforward, uses only the Standard Library, and handles ties by including all letters that reach the maximum frequency."]}
{"name": "mbpp_629_Split", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to find even numbers from a vector of numbers.\nstd::vector<long> Split(std::vector<long> list) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_629_Split.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = Split;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (std::vector<long>({(long)2, (long)4})));\n    assert(candidate((std::vector<long>({(long)4, (long)5, (long)6, (long)7, (long)8, (long)0, (long)1}))) == (std::vector<long>({(long)4, (long)6, (long)8, (long)0})));\n    assert(candidate((std::vector<long>({(long)8, (long)12, (long)15, (long)19}))) == (std::vector<long>({(long)8, (long)12})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a **minimal, self\u2011contained C++ (nome \"cppython\")** snippet that takes a `std::vector<long>` and returns a new vector that contains **only the even elements** from the original list.  \n\nI\u2019ve added a quick `main()` to show how you might call the function and verify the result with `assert`.  The code is portable, requires no external libraries beyond the standard library and will work on any compiler that supports C++11 or later.\n\n```cpp\n#include <vector>\n#include <cassert>\n#include <iostream>\n\n// ---------------------------------------------------------------------------\n//  Function: Split\n//  Purpose:  Extract even numbers from an input vector and return them\n//            in a new vector preserved in the original order.\n//  ---------------------------------------------------------------------------\nstd::vector<long> Split(const std::vector<long>& list) {\n    // Reserve a reasonable capacity \u2013 this is optional but can save reallocs.\n    std::vector<long> evens;\n    evens.reserve(list.size());\n\n    // Iterate over the input and keep only even numbers.\n    for (const auto& num : list) {\n        if (num % 2 == 0) {\n            evens.push_back(num);\n        }\n    }\n\n    return evens;          // return the newly constructed vector\n}\n\n// ---------------------------------------------------------------------------\n//  Optional test harness\n// ---------------------------------------------------------------------------\nint main() {\n    std::vector<long> original = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    std::vector<long> expected  = {2, 4, 6, 8, 10};\n\n    std::vector<long> result = Split(original);\n\n    // Simple sanity check\n    assert(result == expected);\n\n    // Print the result to the console\n    std::cout << \"Even numbers: \";\n    for (auto n : result) {\n        std::cout << n << ' ';\n    }\n    std::cout << '\\n';\n\n    return 0;\n}\n```\n\n### How it works\n\n1. **Input** \u2013 `Split` takes a `const std::vector<long>&` so no copying of the caller\u2019s vector is required.\n2. **Processing** \u2013 It iterates over each element, checks `num % 2 == 0`, and pushes the number into the `evens` vector if it is even.\n3. **Output** \u2013 The function returns a new vector containing just the even elements, preserving the original order.\n\nFeel free to replace the test harness with your own unit tests or integrate this helper into a larger project. Happy coding!", "Below is a compact, self\u2011contained C++ function that takes a `std::vector<long>` and returns a new `std::vector<long>` containing only the even numbers from the input.  \nFeel free to drop it into your code base or adjust the function signature as needed.\n\n```cpp\n#include <vector>\n\n/**\n * @brief  Extracts all even numbers from the input vector.\n * @param  list  Vector of long integers.\n * @return A new vector containing only the even elements of `list`.\n *\n * The function does **not** modify the original vector.  \n * It simply scans once (O(n) time) and pushes each even value into the result.\n */\nstd::vector<long> Split(const std::vector<long>& list)\n{\n    std::vector<long> evens;\n    evens.reserve(list.size());          // Reserve for worst\u2011case to avoid reallocations\n\n    for (const auto& num : list)\n    {\n        if (num % 2 == 0)                // Even check\n        {\n            evens.push_back(num);\n        }\n    }\n\n    return evens;                       // Return the filtered vector\n}\n```\n\n### How to use it\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<long> numbers = {1, 4, 7, 10, 13, 16};\n    std::vector<long> evens = Split(numbers);\n\n    std::cout << \"Even numbers:\";\n    for (long n : evens)\n        std::cout << ' ' << n;\n    std::cout << '\\n';\n\n    return 0;\n}\n```\n\n### Quick notes\n\n- **Time complexity:** `O(n)` \u2013 one pass over the input.  \n- **Space complexity:** `O(k)` where `k` is the number of even elements.  \n- The function uses `const reference` for the input to avoid unnecessary copying.  \n- `reserve` is optional but helps avoid repeated reallocations when most elements are even.  \n\nLet me know if you need additional variations (e.g., in\u2011place filtering, handling unsigned ints, or an overload that accepts `std::initializer_list`). Happy coding!", "Below is a **simple C++ implementation** that extracts the even elements from a `std::vector<long>` and returns a new vector containing only those even numbers.  \nThe function is generic (works for any integral type that fits into `long`) and is fully self\u2011contained \u2013 just copy\u2011paste it into your source file.\n\n```cpp\n#include <vector>\n\n//---------------------------------------------------------------------\n//  Returns a new vector that contains only the even values from `list`.\n//---------------------------------------------------------------------\nstd::vector<long> Split(const std::vector<long> &list)\n{\n    std::vector<long> evens;\n    evens.reserve(list.size());           // reserve space \u2013 avoids reallocations\n\n    for (long val : list)                 // iterate over the original vector\n    {\n        if ((val & 1LL) == 0)             // check evenness using bit test\n            evens.push_back(val);\n    }\n\n    return evens;                         // return the filtered vector\n}\n```\n\n### Why this implementation is efficient\n\n| Feature | Benefit |\n|---------|---------|\n| **`reserve`** | Pre\u2011allocates enough space, preventing multiple reallocations while we `push_back`. |\n| **Bit\u2011wise test (`val & 1LL`)** | Faster than using `% 2` on many compilers, because it\u2019s a single machine instruction for integers. |\n| **Range\u2011based `for`** | Clear and safe \u2013 no manual indexing, no risk of out\u2011of\u2011bounds. |\n| **`const` reference input** | Avoids copying the entire input vector, keeping the function O(n) in time and O(1) extra space (besides the output). |\n\n### How to use it\n\n```cpp\nint main()\n{\n    std::vector<long> data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n    std::vector<long> evens = Split(data);\n\n    for (long n : evens)\n        std::cout << n << ' ';   // prints: 2 4 6 8 10\n}\n```\n\nFeel free to adapt the function name (e.g., `FilterEven`, `extract_even`) or return type to fit the style of your codebase. The logic will stay the same. If you need the function to accept other numeric types (e.g., `int`, `long long`), you can template it:\n\n```cpp\ntemplate <typename T>\nstd::vector<T> Split(const std::vector<T> &list)\n{\n    std::vector<T> evens;\n    evens.reserve(list.size());\n\n    for (T val : list)\n        if ((val & 1) == 0)\n            evens.push_back(val);\n\n    return evens;\n}\n```\n\nThat\u2019s all you need to selectively \u201csplit\u201d a vector into its even members. Happy coding!"]}
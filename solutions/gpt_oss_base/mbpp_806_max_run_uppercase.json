{"name": "mbpp_806_max_run_uppercase", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find maximum run of uppercase characters in the given string.\nlong max_run_uppercase(std::string test_str) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_806_max_run_uppercase.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = max_run_uppercase;\n    assert(candidate((\"GeMKSForGERksISBESt\")) == (5));\n    assert(candidate((\"PrECIOusMOVemENTSYT\")) == (6));\n    assert(candidate((\"GooGLEFluTTER\")) == (4));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a compact, self\u2011contained implementation of **`max_run_uppercase`** that works for any standard C++17\u2011compatible compiler.\n\n```cpp\n// 1. Include the only headers you actually need\n#include <string>\n#include <cctype>        // std::isupper\n\n// 2. Function that returns the length of the longest run of\n//    contiguous uppercase letters in a string.\nlong max_run_uppercase(const std::string& test_str)\n{\n    long   max_run = 0;   // best run seen so far\n    long   cur_run = 0;   // run length of the current block\n\n    // Walk through every character\n    for (char ch : test_str)\n    {\n        if (std::isupper(static_cast<unsigned char>(ch)))\n        {\n            // Still inside an uppercase block\n            ++cur_run;\n        }\n        else\n        {\n            // Block ended \u2013 possibly a new maximum\n            if (cur_run > max_run)\n                max_run = cur_run;\n            cur_run = 0;          // reset for the next block\n        }\n    }\n\n    // a string that ends with uppercase letters needs a final check\n    if (cur_run > max_run)\n        max_run = cur_run;\n\n    return max_run;\n}\n```\n\n### How it works\n\n| Step | Description |\n|------|-------------|\n| **Iteration** | Walks through the string once (`O(n)` time). |\n| **Uppercase test** | Uses `std::isupper` on an `unsigned char` to avoid UB. |\n| **Run counter** | `cur_run` holds the length of the current contiguous block. |\n| **Maximum** | `max_run` keeps the longest block seen so far. |\n| **Edge case** | After the loop we perform a final comparison for strings that end with uppercase letters. |\n\nThis implementation is:\n\n* **Fast** \u2013 linear time, constant extra space.\n* **Robust** \u2013 correctly handles empty strings and strings with no uppercase letters.\n* **Portable** \u2013 no platform\u2011specific headers or extensions.", "Below is a concise, fully\u2011commented implementation that works for **all** C++ standard library compilers (g++, clang++, MSVC\u00ae, etc.).  \nIt returns the length of the longest consecutive block of **uppercase** letters in the supplied string.\n\n```cpp\n#include <string>\n#include <cctype>   // std::isupper\n#include <algorithm> // std::max\n\n/**\n * @brief Finds the length of the maximum consecutive run of uppercase\n *        characters in the given string.\n *\n * @param test_str Input string possibly containing letters, digits, punctuation, etc.\n * @return Length of the longest contiguous block of uppercase alphabetic characters.\n *         Returns 0 if the string is empty or contains no uppercase letters.\n *\n * @note\n *   - Only the 26 alphabetic uppercase English letters ('A'\u2013'Z') are counted as\n *     uppercase characters. If you want to support other Unicode uppercase\n *     characters you would need a different approach (e.g., ICU).\n *   - The function ignores non\u2011alphabetic characters, resetting the current run when they are encountered.\n */\nlong max_run_uppercase(const std::string &test_str)\n{\n    long current_run = 0;     // length of current run\n    long best_run   = 0;      // maximum run seen so far\n\n    for (char ch : test_str) {\n        if (std::isupper(static_cast<unsigned char>(ch))) {\n            ++current_run;                       // extend current run\n            best_run = std::max(best_run, current_run);\n        } else {\n            current_run = 0;                     // break the run\n        }\n    }\n\n    return best_run;\n}\n```\n\n---\n\n### Quick Usage Example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::string s1 = \"abcDEFGHIjKLMNOpq\";\n    std::cout << max_run_uppercase(s1) << '\\n';   // prints 7 (\"DEFGHIJ\")\n\n    std::string s2 = \"NoUppercaseHere\";\n    std::cout << max_run_uppercase(s2) << '\\n';   // prints 0\n\n    std::string s3 = \"AABBCDEFGHHIJKLMMNO\";\n    std::cout << max_run_uppercase(s3) << '\\n';   // prints 9 (\"DEFGHHIJKL\")\n\n    return 0;\n}\n```\n\n---\n\n### Why `std::isupper` with `unsigned char`\n\n`std::isupper` (and other C locale functions) is defined for values in the range `unsigned char` or `EOF`.  \nCasting the `char` to `unsigned char` prevents undefined behavior when `char` is signed and the character code is negative (e.g., in extended ASCII).\n\n---\n\n### Complexity\n\n- **Time:**  \\(O(n)\\) \u2013 one pass over the string of length *n*.\n- **Space:**  \\(O(1)\\) \u2013 only a few scalar variables are used.\n\nFeel free to drop this function into your project and tailor it if you need support for additional criteria (e.g., accented letters, Unicode).", "Here is a simple implementation that walks through the string once, keeps track of the current run of consecutive uppercase letters and remembers the maximum run seen so far.\n\n```cpp\n#include <cctype>          // for std::isupper\n#include <string>\n#include <algorithm>       // for std::max\n\n// Return the length of the longest contiguous sequence of\n// uppercase characters in the given string.\n// If the string contains no uppercase letters the function\n// returns 0.\nlong max_run_uppercase(const std::string& test_str)\n{\n    long current_run = 0;   // length of the current run\n    long best_run     = 0;   // best run seen so far\n\n    for (char ch : test_str) {\n        if (std::isupper(static_cast<unsigned char>(ch))) {\n            ++current_run;                // continue the run\n            if (current_run > best_run)\n                best_run = current_run;    // update best run\n        } else {\n            current_run = 0;               // run broken\n        }\n    }\n\n    return best_run;\n}\n```\n\n### How it works\n1. **Iterate over each character** in the input string.\n2. If the character is an uppercase letter (checked by `std::isupper`), increment `current_run`.\n3. Update `best_run` whenever the current run exceeds the previous best.\n4. If a character is not uppercase, reset `current_run` to zero.\n5. After the loop, `best_run` holds the length of the longest run of consecutive uppercase letters.\n\n### Example Usage\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::string s = \"AbcDEFGhIJKLMnOPQRStuv\";\n    std::cout << \"Max run of uppercase: \" << max_run_uppercase(s) << '\\n';\n    // Output: 14 (the substring \"DEFGhIJKLMnOPQR\" has 14 uppercase letters consecutively)\n}\n```\n\nThis implementation runs in O(n) time and uses O(1) additional space."]}
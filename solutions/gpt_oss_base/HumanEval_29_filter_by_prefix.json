{"name": "HumanEval_29_filter_by_prefix", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_29_filter_by_prefix.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"xxx\", (std::string)\"asd\", (std::string)\"xxy\", (std::string)\"john doe\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})), (\"xxx\")) == (std::vector<std::string>({(std::string)\"xxx\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a complete, self\u2011contained implementation that compiles with a modern C++ compiler (C++17 or newer).  \nThe function walks over the input vector, keeps the string if it begins with the given prefix, and returns a new vector containing only those matches.\n\n```cpp\n#include <string>\n#include <vector>\n\n/**\n * @brief Filters a vector of strings, keeping only those that start with the given prefix.\n *\n * @param strings Vector of strings to filter.\n * @param prefix  Prefix to look for.\n * @return std::vector<std::string> A new vector containing only the strings that begin with @p prefix.\n */\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings,\n                                          const std::string& prefix) {\n    std::vector<std::string> result;\n\n    // Fast\u2011path: if the prefix is empty, every string matches.\n    if (prefix.empty()) {\n        return strings;\n    }\n\n    for (const auto& s : strings) {\n        // If the string is shorter than the prefix, it cannot match.\n        if (s.size() < prefix.size())\n            continue;\n\n        // Compare the prefix portion only.\n        if (std::equal(prefix.begin(), prefix.end(), s.begin())) {\n            result.push_back(s);\n        }\n    }\n\n    return result;\n}\n```\n\n### Explanation\n\n| Step | What it does | Why |\n|------|--------------|-----|\n| `if (prefix.empty())` | Early return when the prefix is empty | Every string is considered a match; copying the original vector keeps complexity O(n). |\n| `for (const auto& s : strings)` | Iterate over every string in the input | Necessary to examine each candidate. |\n| `if (s.size() < prefix.size())` | Skip strings that cannot possibly match | Prevents out\u2011of\u2011range comparison. |\n| `std::equal(prefix.begin(), prefix.end(), s.begin())` | Compares the first part of `s` with `prefix` | Equivalent to `s.rfind(prefix,0) == 0` or `s.starts_with(prefix)` in C++20. |\n| `result.push_back(s)` | Store matched string | Build the filtered result vector. |\n\nThis implementation is `O(n * m)` where `n` is the number of strings and `m` is the length of the prefix (only the characters that actually need to be compared). It uses only the components available in C++17 (no `std::string::starts_with`).\n\nYou can test it with the examples from the docstring:\n\n```cpp\nint main() {\n    std::vector<std::string> v1 = filter_by_prefix({}, \"a\");\n    // v1 is empty\n\n    std::vector<std::string> v2 = filter_by_prefix(\n        {\"abc\", \"bcd\", \"cde\", \"array\"}, \"a\");\n    // v2 == {\"abc\", \"array\"}\n}\n```\n\nFeel free to integrate this function into your project as needed.", "Here is a complete, ready\u2011to\u2011compile implementation that simply uses the standard library to keep only the strings that begin with the required prefix:\n\n```cpp\n#include <algorithm>\n#include <cctype>\n#include <vector>\n#include <string>\n\n// Filter an input vector of strings only for ones that start with a given prefix.\n//   >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n//   (std::vector<std::string>())\n//   >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n//   (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\n//\nstd::vector<std::string>\nfilter_by_prefix(std::vector<std::string> strings, const std::string& prefix)\n{\n    // The prefix might be empty; in that case nothing is removed.\n    if (prefix.empty()) {\n        return strings;\n    }\n\n    // Keep only elements whose start matches the prefix.\n    // `std::remove_if` + erase idiom keeps the order intact.\n    strings.erase(\n        std::remove_if(\n            strings.begin(),\n            strings.end(),\n            [&](const std::string& s) {\n                // A string must be at least as long as the prefix\n                if (s.size() < prefix.size()) return true;   // remove it\n                return std::mismatch(prefix.begin(), prefix.end(), s.begin()).first != prefix.end();\n            }\n        ),\n        strings.end()\n    );\n\n    return strings;\n}\n```\n\n### How it works\n\n* **Early exit** \u2013 If the prefix is empty, nothing can match, so the original vector is returned unchanged.\n* **`std::remove_if` + `erase`** \u2013 This classic idiom keeps the remaining elements in their original order.\n* **Matching logic** \u2013  \n  * If the string is shorter than the prefix it cannot match \u2192 removed.  \n  * Otherwise we compare the prefix with the beginning of the string using `std::mismatch`.  \n  * If `std::mismatch` reaches the end of the prefix, the two substrings are identical \u2192 keep the string; otherwise remove it.\n\nThis function uses only standard headers and works in any modern C++ compiler.", "Here is a simple and efficient implementation of the `filter_by_prefix` function. It scans the input vector once and collects all strings that start with the supplied prefix.\n\n```cpp\n#include <vector>\n#include <string>\n\n/* Filter an input vector of strings only for ones that start with a given prefix\n *\n * Example\n * -------\n * filter_by_prefix({\"abc\", \"bcd\", \"cde\", \"array\"}, \"a\")\n *   \u2192 {\"abc\", \"array\"}\n */\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, const std::string& prefix)\n{\n    // Result container\n    std::vector<std::string> result;\n    result.reserve(strings.size());          // reserve space to avoid reallocations\n\n    // Keep only those strings whose initial segment matches the prefix\n    for (const auto &s : strings)\n    {\n        if (s.rfind(prefix, 0) == 0)   // prefix at position 0\n            result.push_back(s);\n    }\n\n    return result;   // move\u2011semantics will take care of efficient return\n}\n```\n\n### Why this implementation is good\n\n| Feature | Description |\n|---------|-------------|\n| **Single scan** | Only one pass over the input vector \u2192 *O(n)* time. |\n| **Efficient prefix check** | `std::string::rfind(prefix,0)` is a fast way to test if `prefix` is at position `0`. |\n| **Pre\u2011allocation** | `reserve(strings.size())` ensures we don't reallocate while pushing. | \n| **Pass\u2011by\u2011const reference** | The prefix is passed as `const std::string&` to avoid an unnecessary copy. |\n| **Return by value** | Modern C++ guarantees NRVO or move\u2011semantics, so returning the vector is cheap. |\n\nFeel free to adapt the code if you need further optimisations or integrations with other parts of your project."]}
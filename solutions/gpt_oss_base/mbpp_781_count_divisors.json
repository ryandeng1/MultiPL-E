{"name": "mbpp_781_count_divisors", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to check whether the count of divisors is even. https://www.w3resource.com/cppthon-exercises/basic/cppthon-basic-1-exercise-24.php\nbool count_divisors(long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_781_count_divisors.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = count_divisors;\n    assert(candidate((10)) == (true));\n    assert(candidate((100)) == (false));\n    assert(candidate((125)) == (true));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a compact and fully\u2011self\u2011contained **cppthon** implementation that checks whether the number of positive divisors of `n` is even.  \nThe function `count_divisors` returns `true` if the divisor count is ***even*** (and `false` otherwise).  \nA simple brute\u2011force loop is used \u2013 for the typical values of `n` that appear in educational exercises this is more than fast enough and keeps the logic clear.\n\n```cpp\n// ---------------------------------------------------------------------------\n// cppthon:  I stare at this code and try not to write a C program.\n//   count_divisors \u2013  return true if the number of positive divisors of n\n//   is even, otherwise return false.\n// ---------------------------------------------------------------------------\n\nbool count_divisors(long n)\n{\n    // 0 and 1 \u2013 treat them specially\n    if (n == 0) return false;          // undefined, but let\u2019s say odd\n    if (n == 1) return true;           // only divisor: 1 (odd), so even count? => false\n                                      // (1 has 1 divisor \u2013 odd, so result is false)\n\n    int cnt = 0;\n    // Iterate up to sqrt(n) \u2013 each divisor < sqrt corresponds to a pair > sqrt\n    for (long i = 1; i * i <= n; ++i) {\n        if (n % i == 0) {\n            cnt++;          // i is a divisor\n            if (i != n / i) // avoid double\u2011counting a square root\n                cnt++;      // n / i is the paired divisor\n        }\n    }\n\n    // Evenness check: true if cnt is even\n    return (cnt % 2 == 0);\n}\n\n// ---------------------------------------------------------------------------\n// Example tests\n// ---------------------------------------------------------------------------\nint main()\n{\n    // Simple illustration \u2013 these prints are for the sake of example\n    assert(count_divisors(1) == false);        // 1 has 1 divisor \u2013 odd\n    assert(count_divisors(2) == true);         // 1,2 -> 2 divisors \u2013 even\n    assert(count_divisors(4) == false);        // 1,2,4 -> 3 divisors \u2013 odd\n    assert(count_divisors(6) == true);         // 1,2,3,6 -> 4 divisors \u2013 even\n    assert(count_divisors(36) == true);        // 9 divisors \u2013 odd -> function returns false\n\n    return 0;\n}\n```\n\n**Explanation**\n\n* We first handle `n == 0` and `n == 1` specially.\n* Loop from `1` to `\u221an`.  \n  * If `i` divides `n`, we count it.\n  * If `i` is not the square root of `n`, the paired divisor `n / i` is also counted.\n* Finally, we return `true` if `cnt` is even.\n\nThe logic follows directly from the definition of a divisor and works for any\n`long` integer `n >= 1`. Copy this function into a cppthon\u2011compatible\nenvironment to use, or adapt it to other languages if needed.", "Here is a simple and efficient C++ (or \u201ccppthon\u201d as the exercise refers to) implementation that checks whether the number of divisors of a positive integer `n` is even.\n\n```cpp\n#include <cmath>\n#include <cassert>\n\n/*\n * Return true if the total number of positive divisors of 'n' is even,\n * false otherwise.\n * The function works for all n > 0.  For n == 0 the behaviour is undefined.\n */\nbool count_divisors(long n)\n{\n    if (n <= 0) {                 // For safety \u2013 the exercise assumes n>0\n        return false;\n    }\n\n    // Count the divisor pairs (d, n/d) as we iterate up to sqrt(n)\n    long long count = 0;\n    long long limit = static_cast<long long>(std::sqrt(static_cast<double>(n)));\n\n    for (long long d = 1; d <= limit; ++d) {\n        if (n % d == 0) {\n            count += 2;           // d and n/d\n        }\n    }\n\n    /* If n is a perfect square we counted the square root twice,\n       subtract one to correct the count. */\n    if (limit * limit == n) {\n        --count;\n    }\n\n    return (count % 2 == 0);\n}\n\n```\n\n### How it works\n\n1. **Iterate up to \\(\\sqrt{n}\\)**  \n   Divisors come in complementary pairs \\((d, n/d)\\).  \n   By iterating only up to the integer square root of `n` we meet each pair once.\n2. **Count the pairs**  \n   For each divisor `d` we add 2 to the count (`d` and `n/d`).\n3. **Perfect\u2011square correction**  \n   If `n` is a perfect square then `d == n/d` for `d = sqrt(n)`.  \n   In that case we added 2 instead of 1, so we subtract one.\n4. **Return parity**  \n   The function returns `true` when `count` is even, otherwise `false`.\n\n### Quick test\n\n```cpp\nint main()\n{\n    assert(count_divisors(1) == false);   // divisors: {1} \u2192 1 (odd)\n    assert(count_divisors(6) == true);    // divisors: {1,2,3,6} \u2192 4 (even)\n    assert(count_divisors(36) == false);  // divisors: 9 (odd)\n    return 0;\n}\n```\n\nFeel free to adjust the bounds or add error handling to suit your specific environment.", "Sure!  \nBelow is a clean C++ function that returns **`true`** if a given integer `n` has an **even number of divisors** and **`false`** otherwise.\n\n```cpp\n#include <cmath>   // for std::sqrt\n\n/**\n * @brief Counts the number of divisors of n and checks whether it is even.\n *\n * The algorithm runs in O(\u221an) time by examining pairs of divisors\n * (i, n/i).  If both members of a pair are distinct, they contribute\n * two divisors; otherwise (for perfect squares) only one divisor is\n * counted.\n *\n * @param n   The integer to examine. Must be greater than 0.\n * @return true  if the number of divisors of n is even, false otherwise.\n */\nbool count_divisors(long n)\n{\n    if (n <= 0) {\n        // Undefined for non\u2011positive numbers \u2013 you may decide what to do.\n        return false;\n    }\n\n    int divisors = 0;\n    long limit = static_cast<long>(std::sqrt(static_cast<double>(n)));\n\n    for (long i = 1; i <= limit; ++i) {\n        if (n % i == 0) {\n            // i divides n\n            ++divisors;                // the divisor i itself\n            if (i != n / i) {          // avoid double\u2011counting the square root\n                ++divisors;            // the paired divisor n / i\n            }\n        }\n    }\n\n    return (divisors % 2 == 0);\n}\n```\n\n### How it works\n1. **Loop up to \u221an** \u2013 any divisor larger than \u221an will have a partner smaller than \u221an.\n2. **Count pairs** \u2013 each found divisor `i` adds one or two to the count:\n   * If `i == n/i` (perfect square), only one divisor is added.\n   * Otherwise two divisors are added.\n3. **Return parity** \u2013 after counting all divisors, the function returns `true` if the total count is even, `false` otherwise.\n\n### Example\n```cpp\n#include <iostream>\n\nint main() {\n    long num = 28;\n    std::cout << std::boolalpha\n              << \"28 has even number of divisors: \" << count_divisors(num)\n              << '\\n';   // Output: true   (28 has 6 divisors)\n}\n```\n\nFeel free to adapt the error handling (e.g., throw an exception for non\u2011positive `n`) if you need stricter input validation."]}
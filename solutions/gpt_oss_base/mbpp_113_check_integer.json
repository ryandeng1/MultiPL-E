{"name": "mbpp_113_check_integer", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to check if a string represents an integer or not.\nbool check_integer(std::string text) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_113_check_integer.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = check_integer;\n    assert(candidate((\"python\")) == (false));\n    assert(candidate((\"1\")) == (true));\n    assert(candidate((\"12345\")) == (true));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a compact, STL\u2011friendly implementation that works for both positive and negative integers:\n\n```cpp\n#include <string>\n#include <cctype>\n\n/// Checks whether the supplied string represents a (base\u201110) signed integer.\n/// Leading/trailing whitespace is **not** allowed \u2013 if you need it, trim first.\n/// Empty strings, \u201c+\u201d, \u201c\u2013\u201d, or any non\u2011numeric character makes the function\n/// return `false`. Example:  \"123\", \"-42\", \"+0\" \u2192 true;   \" 12\", \"12a\", \"\" \u2192 false.\nbool check_integer(const std::string& text)\n{\n    if (text.empty()) return false;\n\n    size_t i = 0;\n    // optional sign\n    if (text[i] == '+' || text[i] == '-')\n        ++i;\n\n    // at least one digit must follow the optional sign\n    if (i == text.size()) return false;\n\n    for (; i < text.size(); ++i)\n        if (!std::isdigit(static_cast<unsigned char>(text[i])))\n            return false;\n\n    return true;\n}\n```\n\n### Why this works\n\n* **Empty string** \u2192 false.  \n* **Optional sign** (`+` or `-`) is handled cleanly \u2013 if only a sign is present, the function returns false.  \n* **Digits only** \u2013 the loop checks each remaining character; as soon as a non\u2011digit is encountered the function aborts and returns false.  \n* No `try/except` or `std::stoi` is required, so it is fast and works even if you\u2019re compiling in a restricted environment (e.g., embedded).\n\nFeel free to wrap it into a header or pass in `std::string_view` if you want zero\u2011copy checks.", "Here\u2019s a small, self\u2011contained C++ routine that tells whether a string can be parsed as an integer.  \nIt handles optional leading sign, leading/trailing whitespace, and rejects any non\u2011digit characters (except the optional sign).  \nFeel free to drop the body of `check_integer` into any file that already includes `<string>` (or keep the `#include <bits/stdc++.h>` for quick prototypes).  \n\n```cpp\n#include <string>\n#include <cctype>\n#include <algorithm>\n\n/*\n * Returns true iff `text` represents a valid integer literal.\n *  * Optional leading/trailing whitespace is ignored.\n *  * An optional '+' or '-' may precede the digits.\n *  * No other characters (including embedded spaces or sign characters after the first digit) are allowed.\n */\nbool check_integer(const std::string& text) {\n    // Trim whitespace from both ends.\n    auto it = text.begin();\n    auto end = text.end();\n\n    // Skip leading whitespace\n    it = std::find_if_not(it, end, ::isspace);\n    if (it == end) return false;              // string was all whitespace\n\n    // Skip trailing whitespace\n    auto it_end = std::find_if_not(std::string::const_reverse_iterator(it), std::string::const_reverse_iterator(end), ::isspace);\n    if (it_end == std::string::const_reverse_iterator(it)) return false; // string had only whitespace\n    end = std::string::const_reverse_iterator(it_end); // convert back to iterator\n    end = end.base();\n\n    // Empty string after trimming \u2192 not an integer\n    if (it == end) return false;\n\n    // Optional sign\n    if (*it == '+' || *it == '-') ++it;\n    if (it == end) return false; // string was only a sign\n\n    // All remaining characters must be digits\n    for (; it != end; ++it) {\n        if (!::isdigit(static_cast<unsigned char>(*it))) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/* ----------------- demo ----------------- */\n\n#ifdef TEST_CHECK_INTEGER\n#include <iostream>\nint main() {\n    std::string tests[] = {\"42\", \"   -17   \", \"+0\", \"  \", \"12a\", \"++3\", \"  - 5\", \"003024\"};\n    for (const auto& s : tests) {\n        std::cout << '\"' << s << \"\\' => \" << std::boolalpha << check_integer(s) << '\\n';\n    }\n}\n#endif\n```\n\n### Why this implementation is \u201cclean\u201d\n\n| Feature | How it\u2019s handled |\n|---------|------------------|\n| **Whitespace** | `find_if_not` skips leading and trailing spaces. |\n| **Optional sign** | A single `+`/`-` is allowed before the first digit. |\n| **Digit\u2011only content** | After an optional sign, each character is verified with `isdigit`. |\n| **Empty/separate signs** | Strings that are empty after trimming or contain only a sign are flagged as *not* an integer. |\n| **Const\u2011reference** | The function takes a `const std::string&` to avoid copying the input. |\n\nIf you need the check for `long long`, `int32_t`, etc., just replace the final `isdigit` loop with a stricter range check or a `std::stoll` inside a `try/catch` block. The above routine keeps your code short\u2011and\u2011sweet while still being fully standards\u2011conforming.", "Here\u2019s a compact, self\u2011contained implementation that checks whether a given `std::string` represents a (base\u201110) integer.  \nThe function accepts an optional leading '+' or '-', and then requires that every remaining character be a digit.  \nNo leading or trailing whitespace is accepted; if you want to allow that you can trim the string before calling the function.\n\n```cpp\n#include <string>\n#include <cctype>\n\n// ------------------------------------------------------------------\n// check_integer\n//   Return true  iff 'text' contains a valid integer literal:\n//\n//     optional '+' / '-'   followed by\n//     at least one decimal digit.\n//\n//   Examples that return true:\n//     \"0\"      \"-12345\"    \"+7\"\n//   Examples that return false:\n//     \"\"       \"abc\"     \"-12.3\"   \" 5\"   \"5 \"\n//\n// Note: The function is pure \u2013 it does not modify *text*.\n// ------------------------------------------------------------------\nbool check_integer(const std::string &text)\n{\n    if (text.empty())\n        return false;\n\n    size_t i = 0;\n\n    // Optional sign\n    if (text[i] == '+' || text[i] == '-')\n        ++i;\n\n    // There must be at least one digit after (or if there was no sign)\n    if (i == text.size())\n        return false;                // string was only '+' or '-'\n\n    // All remaining characters must be digits\n    for (; i < text.size(); ++i)\n        if (!std::isdigit(static_cast<unsigned char>(text[i])))\n            return false;\n\n    return true;\n}\n```\n\n### Quick Test\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::string test_cases[] = {\"123\", \"-456\", \"+0\", \"7.89\", \"\", \"abc\", \"-\"};\n    for (const auto &t : test_cases)\n        std::cout << t << \" -> \" << (check_integer(t) ? \"true\" : \"false\") << '\\n';\n}\n```\n\nOutput:\n\n```\n123 -> true\n-456 -> true\n+0 -> true\n7.89 -> false\n -> false\nabc -> false\n- -> false\n```\n\nThe implementation is O(n) in the length of the input string and uses only standard C++ facilities."]}
{"name": "HumanEval_80_is_happy", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_80_is_happy.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = is_happy;\n    assert(candidate((\"a\")) == (false));\n    assert(candidate((\"aa\")) == (false));\n    assert(candidate((\"abcd\")) == (true));\n    assert(candidate((\"aabb\")) == (false));\n    assert(candidate((\"adb\")) == (true));\n    assert(candidate((\"xyy\")) == (false));\n    assert(candidate((\"iopaxpoi\")) == (true));\n    assert(candidate((\"iopaxioi\")) == (false));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a clean, self\u2011contained implementation of `is_happy`.  \nIt follows the exact rules you described:\n\n* `s` must contain **at least 3 characters**;\n* every **three consecutive characters** must be pairwise distinct.\n\n```cpp\n#include <string>\n#include <cstddef>   // for std::size_t\n\n// ------------------------------------------------------------------\n//  is_happy\n// ------------------------------------------------------------------\n/// \\brief  Checks whether a string is \"hapcpp\".\n/// \\param  s  The string to test.\n/// \\return true if s is at least 3 characters long and every\n///         three consecutive characters are all different.\nbool is_happy(const std::string& s) {\n    // 1. Length must be at least 3\n    if (s.size() < 3) {\n        return false;\n    }\n\n    // 2. Check every window of size 3\n    for (std::size_t i = 0; i + 2 < s.size(); ++i) {\n        // four ways to be not distinct\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n\n    // If we reached here, the string fulfills the conditions\n    return true;\n}\n```\n\n### Usage examples\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << is_happy(\"a\") << '\\n';     // false\n    std::cout << is_happy(\"aa\") << '\\n';    // false\n    std::cout << is_happy(\"abcd\") << '\\n';  // true\n    std::cout << is_happy(\"aabb\") << '\\n';  // false\n    std::cout << is_happy(\"adb\") << '\\n';   // true\n    std::cout << is_happy(\"xyy\") << '\\n';   // false\n}\n```\n\nThe function runs in **O(n)** time where *n* is the length of the input string, and it uses **O(1)** extra space.", "Here is a straightforward implementation of the `is_happy` function that follows the rules you described:\n\n```cpp\n#include <string>\n\nbool is_happy(const std::string& s) {\n    // Rule 1: Length must be at least 3\n    if (s.length() < 3)\n        return false;\n\n    // Rule 2: Every group of 3 consecutive characters must be pair\u2011wise distinct\n    for (size_t i = 0; i + 2 < s.length(); ++i) {\n        char a = s[i];\n        char b = s[i + 1];\n        char c = s[i + 2];\n        if (a == b || a == c || b == c)\n            return false;\n    }\n\n    return true;\n}\n```\n\n### How it works\n1. **Length check** \u2013 If the string contains fewer than 3 characters, it can\u2019t satisfy the \u201cevery 3 consecutive letters are distinct\u201d rule, so the function returns `false`.\n2. **Sliding window** \u2013 The loop slides a window of size 3 across the string.  \n   - `i` is the starting index of the window.\n   - `i + 2 < s.length()` ensures we never access out of bounds.\n3. **Distinctness check** \u2013 Inside each window we compare the three characters pairwise.  \n   - If any two are equal, the string is not \u201chapcpp\u201d and we return `false`.\n4. If the loop finishes without finding a violation, the string satisfies all conditions, so we return `true`.\n\n### Example usage\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << is_happy(\"a\") << '\\n';      // false\n    std::cout << is_happy(\"aa\") << '\\n';     // false\n    std::cout << is_happy(\"abcd\") << '\\n';   // true\n    std::cout << is_happy(\"aabb\") << '\\n';   // false\n    std::cout << is_happy(\"adb\") << '\\n';    // true\n    std::cout << is_happy(\"xyy\") << '\\n';    // false\n}\n```\n\nThe function satisfies all the examples and adheres to the problem statement. Feel free to drop it into your codebase!", "Here is a simple and efficient implementation of `is_happy` that follows the given rules:\n\n```cpp\n#include <string>\n\nbool is_happy(const std::string& s)\n{\n    // A string must have at least 3 characters.\n    if (s.size() < 3) return false;\n\n    // Check every block of 3 consecutive characters.\n    for (size_t i = 0; i + 2 < s.size(); ++i) {\n        // The three characters must be pairwise distinct.\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2])\n            return false;\n    }\n    return true;\n}\n```\n\n**Explanation**\n\n1. **Length check** \u2013 If the string has fewer than three characters, it can\u2019t satisfy the rule, so we return `false` immediately.\n\n2. **Sliding window** \u2013 We iterate from the first character to the third\u2011from\u2011last one (`i + 2 < s.size()`).  \n   At each position we look at the three letters `s[i]`, `s[i+1]`, and `s[i+2]`.\n\n3. **Distinctness test** \u2013 If any pair among the three characters is equal, the string violates the rule, so we return `false`.\n\n4. If the loop completes without finding a violation, the string is happy, so we return `true`.\n\nThis implementation runs in O(n) time with O(1) additional space."]}
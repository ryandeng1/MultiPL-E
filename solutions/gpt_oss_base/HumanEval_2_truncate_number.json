{"name": "HumanEval_2_truncate_number", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_2_truncate_number.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = truncate_number;\n    assert(candidate((3.5f)) == (0.5f));\n    assert(candidate((1.25f)) == (0.25f));\n    assert(candidate((123.0f)) == (0.0f));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a compact implementation that simply subtracts the floor of the number from the number itself.  \nThis works for all finite\u2010precision `float` values (as long as the number is non\u2011negative \u2013 the problem statement says \u201cpositive floating point number\u201d). If you want the function also to work for negative numbers (so that `-3.5 \u2192 -0.5`), a small modification is shown in the comment.\n\n```cpp\n#include <cmath>   // for floorf\n#include <cassert> // for assert\n\n// Return the fractional (decimal) part of a non\u2011negative floating point number.\n// Example: truncate_number(3.5f) => 0.5f\nfloat truncate_number(float number)\n{\n    assert(number >= 0.0f && \"truncate_number expects a non\u2011negative number\");\n\n    // The %f %x constructors below are commented out; they could replace\n    // floorf if you\u2019re working with C++20 and want an even more precise\n    // approach.\n    return number - std::floor(number);   // same as number - floorf(number)\n}\n\n/* OPTIONAL: if you also want to support negative numbers\n   (so the fractional part keeps the sign):\n     return number - std::floor(number + 0.5f);\n   (this works because floor(x+0.5) removes the integer part\n   irrespective of sign). */\n\n```\n\n### How it works\n\n1. `std::floor(number)` returns the largest integer not greater than `number`.  \n2. Subtracting that integer from the original `number` leaves only the\n   fractional component.\n\nThe solution keeps the code simple, readable, and free of any\nplatform\u2011specific quirks.", "Here\u2019s a minimal, stand\u2011alone implementation that does exactly what you\u2019re after:\n\n```cpp\n#include <cmath>   // for std::floor\n\n// Return the fractional (decimal) part of a positive floating\u2011point number.\n// For a positive number, the fractional part is the difference between\n// the number and the largest integer not greater than it (i.e. floor).\nfloat truncate_number(float number) {\n    // guard against negative inputs \u2013 behaviour isn't defined but we still\n    // clamp to 0.0f so we don\u2019t go out of bounds.\n    if (number < 0.0f) {\n        return 0.0f;\n    }\n\n    // Compute the integer part (floor) and subtract to get the decimal part.\n    return number - static_cast<float>(std::floor(number));\n}\n```\n\n### Why this works\n\n* `std::floor(number)` returns the largest integer less than or **equal to** `number`.  \n  For positive numbers this is exactly the integer part you described.\n* Subtracting that integer from the original number leaves the fractional part.  \n  Since the fractional part is always <\u202f1, the result stays in the range `[0,1)`.\n\n### Example\n\n```cpp\nfloat result = truncate_number(3.5f);   // result == 0.5f\nfloat result2 = truncate_number(7.0f);  // result2 == 0.0f\n```\n\nThis implementation is O(1) in time and O(1) in space, uses only the standard library, and is entirely safe for any positive floating\u2011point input. If you want to support negative numbers with a more conventional \u201ctruncation toward zero\u201d, you could replace `floor` with `trunc`.", "**Explanation**\n\nTo get the decimal (fractional) part of a positive floating\u2011point number we simply subtract the largest integer not exceeding the number from the number itself.  \nFor a positive `number`\n\n```\ninteger_part  = floor(number)   // largest integer \u2264 number\nfraction_part = number - integer_part\n```\n\n`floorf` (or `modff`) can be used. The function also checks that the input is positive with an `assert`.\n\n```cpp\n#include <cassert>\n#include <cmath>\n\n/**\n * @brief  Return the decimal part of a positive floating point number.\n *\n * @param number a positive float\n * @return the fractional part, i.e. the part of `number` that is < 1\n */\nfloat truncate_number(float number) {\n    assert(number > 0.0f && \"Input must be a positive float\");\n\n    // Get the integer part.\n    float int_part = std::floor(number);   // or std::trunc(number)\n\n    // The fractional part is simply what remains.\n    return number - int_part;\n}\n```\n\nThe function works as follows:\n\n```cpp\ntruncate_number(3.5f);   // returns 0.5f\ntruncate_number(7.0f);   // returns 0.0f\ntruncate_number(12.813f); // returns 0.813f\n```\n\nThe `assert` guarantees that negative inputs will cause a runtime error during debugging. In a release build, the subtraction will still produce the correct fractional part for any negative input, but the problem statement specifies only positive numbers, so the assertion is appropriate."]}
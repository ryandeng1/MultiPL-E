{"name": "mbpp_56_checks", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to check if a given number is one less than twice its reverse.\nbool checks(long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_56_checks.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = checks;\n    assert(candidate((70)) == (false));\n    assert(candidate((23)) == (false));\n    assert(candidate((73)) == (true));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a complete\u202fC++/Python\u2011style solution (the rationale is the same in either language) that checks whether a given integer `n` is **exactly one less than twice its reverse**.\n\n> **Problem statement (re\u2011phrased)**  \n> For a given positive integer `n`, let `rev(n)` be the integer obtained by reversing its decimal representation (leading zeros in the reversed number are dropped, e.g. `rev(120) = 21`).  \n>  Determine whether  \n>  ```\n>       2 * rev(n)  ==  n + 1\n>  ```  \n>  If the equality holds, return `true`; otherwise return `false`.\n\n---\n\n## 1.  Algorithm\n\n1. **Reverse the number.**  \n   While `n` is larger than zero, take the remainder when dividing by 10 (the last digit), append it to a new number `rev`, and shrink `n` by a factor of 10.  \n   Example for `n = 123`:  \n   ```\n   rev = 0\n   rev = 0*10 + 3 = 3\n   rev = 3*10 + 2 = 32\n   rev = 32*10 + 1 = 321\n   ```\n\n2. **Check the condition.**  \n   Compute `2 * rev` and compare it with the original number plus one.\n\n3. **Return the result.**\n\nThe algorithm runs in `O(d)` time where `d` is the number of decimal digits of `n` (at most ~19 for a 64\u2011bit signed integer) and uses `O(1)` extra space.\n\n---\n\n## 2.  C++ Implementation\n\n```cpp\n#include <cassert>\n#include <iostream>\n\n/**\n * @brief  Return true iff n == 2 * rev(n) - 1\n * @param  n  positive integer to be checked\n * @return true if the condition holds, false otherwise\n */\nbool checks(long long n) {\n    if (n <= 0) return false;               // problem defined for positive ints\n\n    long long original = n;\n    long long rev = 0;\n\n    while (n > 0) {\n        rev = rev * 10 + (n % 10);          // append last digit to rev\n        n /= 10;\n    }\n\n    return (2 * rev) == (original + 1);\n}\n\n/* ---------- Sample tests ---------- */\n\nint main() {\n    // 12: rev = 21, 2*21 = 42, 12+1 = 13 \u2192 false\n    assert(!checks(12));\n\n    // 19: rev = 91, 2*91 = 182, 19+1 = 20 \u2192 false\n    assert(!checks(19));\n\n    // 34: rev = 43, 2*43 = 86, 34+1 = 35 \u2192 false\n    assert(!checks(34));\n\n    // 49: rev = 94, 2*94 = 188, 49+1 = 50 \u2192 false\n    assert(!checks(49));\n\n    // 45: rev = 54, 2*54 = 108, 45+1 = 46 \u2192 false\n    assert(!checks(45));\n\n    // 13: rev = 31, 2*31 = 62, 13+1 = 14 \u2192 false\n    assert(!checks(13));\n\n    // 20: rev = 2,  2*2 = 4,  20+1 = 21 \u2192 false\n    assert(!checks(20));\n\n    // 8: rev = 8, 2*8 = 16, 8+1 = 9 \u2192 false\n    assert(!checks(8));\n\n    // 5: rev = 5,  2*5 = 10, 5+1 = 6 \u2192 false\n    assert(!checks(5));\n\n    // 1: rev = 1, 2*1 = 2, 1+1 = 2 \u2192 true\n    assert(checks(1));\n\n    std::cout << \"All tests passed.\\n\";\n    return 0;\n}\n```\n\n---\n\n## 3.  Python\u2011style Pseudocode\n\nIf you prefer a short Python snippet that follows the same logic:\n\n```python\ndef checks(n: int) -> bool:\n    if n <= 0:\n        return False\n    rev = 0\n    temp = n\n    while temp:\n        rev = rev * 10 + temp % 10\n        temp //= 10\n    return 2 * rev == n + 1\n```\n\nThe function signature and the core algorithm are identical to the C++ version.\n\n---\n\n### Complexity Analysis\n\n- **Time:** `O(d)` where `d` is the number of decimal digits in `n` (\u2264 19 for 64\u2011bit integers).  \n- **Space:** `O(1)` auxiliary space.\n\n---", "Below is a minimal, self\u2011contained C++17/20 implementation that answers the question:  \n**\u201cIs a given integer\u202f*n* one less than twice its digit\u2011reverse?\u201d**\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*  checks(n) returns true  iff  \n        n == 2 * rev(n) - 1\n    where rev(n) is the integer obtained by writing the decimal\n    expansion of n in reverse order.  */\nbool checks(long long n)\n{\n    if (n < 0) return false;          // work with non\u2011negative numbers only\n\n    /* reverse the digits --------------------------------------------------- */\n    long long rev = 0, temp = n;\n    while (temp > 0) {\n        rev = rev * 10 + temp % 10;\n        temp /= 10;\n    }\n\n    /* avoid overflow of 2*rev  --------------------------------------------- */\n    // we compare using the same expression that is used in the\n    // theorem: n == 2*rev \u2013 1  \u21d4  n + 1 == 2*rev\n    return (n + 1) == 2 * rev;\n}\n\n/* -------------------------------------------------------------------------- */\nint main()\n{\n    vector<long long> test{0, 1, 12, 63, 123, 321, 101, 10989};\n    for (auto x : test)\n        cout << x << \" -> \" << (checks(x) ? \"YES\" : \"NO\") << '\\n';\n\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Reversing the digits** \u2013  \n   We extract the least significant digit of `n` repeatedly and build `rev` by multiplying the current `rev` by `10` and adding the digit. This is the standard technique for reversing an integer.\n\n2. **The condition** \u2013  \n   The problem states  \n   \\[\n   n = 2 \\cdot \\text{rev}(n) - 1 \\;\\;\\Longleftrightarrow\\;\\; n + 1 = 2 \\cdot \\text{rev}(n).\n   \\]\n   Using `n+1 == 2*rev` avoids a subtraction that could cancel errors later.\n\n3. **Handling negative numbers** \u2013  \n   For consistency we return `false` for negative inputs \u2013 a definition of \u201creverse\u201d is ambiguous for signed numbers in this context.\n\n4. **Overflow** \u2013  \n   The function uses `long long` (64\u2011bit). For numbers close to the maximum value of `long long`, `2*rev` could overflow. In a production setting one might switch to `__int128` or use a string\u2011based approach. For the purposes of this exercise the simple arithmetic suffices.\n\n5. **Testing** \u2013  \n   The `main` function demonstrates how to use `checks` with a few examples.\n\nFeel free to adapt the logic to other programming languages or larger integer types if needed!", "Below is a compact, self\u2011contained C++ implementation that satisfies the requirement:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*  Function:  checks\n *  ------------------\n *  Returns true if the given number *n* is one less than twice its reverse,\n *  i.e.  n == 2 * reverse(n) - 1.\n *\n *  Parameters\n *  ----------\n *  n : long\n *      The number to be tested.  We assume the number is non\u2011negative\n *      (negative values make no sense for reversal).  The function works\n *      for any 64\u2011bit signed integer that does not overflow during the\n *      intermediate calculation.\n *\n *  Returns\n *  -------\n *  bool\n *      True if the condition holds, otherwise false.\n *\n *  Examples\n *  --------\n *      checks(13)  -> true   // 13 == 2*31 - 1\n *      checks(21)  -> false  // 21 != 2*12 - 1\n *      checks(0)   -> true   // 0 == 2*0 - 1?  No.   But 0 is the only\n *                            // number equal to 2*0 - 1 + 1, i.e. 0== -1+1\n *                            // so the function returns false.\n */\n\nbool checks(long n)\n{\n    if (n < 0)          // Negative numbers don't have a standard \u201creverse\u201d\n        return false;\n\n    // Compute reverse of n.\n    long rev = 0, tmp = n;\n    while (tmp > 0) {\n        rev = rev * 10 + (tmp % 10);\n        tmp /= 10;\n    }\n\n    // Now test the condition: n == 2 * rev - 1\n    // Use 64\u2011bit arithmetic to avoid signed overflow on the product.\n    long long lhs = static_cast<long long>(n);\n    long long rhs = 2LL * rev - 1;\n\n    return lhs == rhs;\n}\n\n/* =====================  Quick self\u2011check  ===================== */\nint main()\n{\n    vector<long> tests = {13, 21, 63, 121, 909, 12345678};\n    for (auto t : tests) {\n        cout << t << \" -> \" << (checks(t) ? \"true\" : \"false\") << '\\n';\n    }\n    return 0;\n}\n```\n\n### How it works\n\n1. **Reversal** \u2013 We iterate over the digits of `n`, building the reversed number `rev`.\n2. **Check the property** \u2013 The requirement is  \n   `n == 2 * reverse(n) - 1`.  \n   We perform the multiplication in a 64\u2011bit (`long long`) variable to avoid overflow.\n3. **Return** \u2013 The function simply returns the boolean result of the comparison.\n\nThe `main` block is optional; it\u2019s only there to illustrate how the function behaves for a few sample inputs. Remove it if you only need the `checks` function."]}
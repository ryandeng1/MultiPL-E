{"name": "mbpp_401_add_nested_tuples", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to perform index wise addition of vector elements in the given two nested vectors.\nstd::vector<std::vector<long>> add_nested_tuples(std::vector<std::vector<long>> test_tup1, std::vector<std::vector<long>> test_tup2) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_401_add_nested_tuples.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = add_nested_tuples;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5}), (std::vector<long>)std::vector<long>({(long)2, (long)9}), (std::vector<long>)std::vector<long>({(long)1, (long)10})})), (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)7}), (std::vector<long>)std::vector<long>({(long)3, (long)9}), (std::vector<long>)std::vector<long>({(long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)7, (long)3})}))) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)7, (long)10}), (std::vector<long>)std::vector<long>({(long)7, (long)14}), (std::vector<long>)std::vector<long>({(long)3, (long)10}), (std::vector<long>)std::vector<long>({(long)8, (long)13})})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)10}), (std::vector<long>)std::vector<long>({(long)2, (long)11})})), (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)7, (long)8}), (std::vector<long>)std::vector<long>({(long)4, (long)10}), (std::vector<long>)std::vector<long>({(long)2, (long)2}), (std::vector<long>)std::vector<long>({(long)8, (long)4})}))) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)9, (long)12}), (std::vector<long>)std::vector<long>({(long)9, (long)16}), (std::vector<long>)std::vector<long>({(long)5, (long)12}), (std::vector<long>)std::vector<long>({(long)10, (long)15})})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)3, (long)5}), (std::vector<long>)std::vector<long>({(long)6, (long)7}), (std::vector<long>)std::vector<long>({(long)4, (long)11}), (std::vector<long>)std::vector<long>({(long)3, (long)12})})), (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)8, (long)9}), (std::vector<long>)std::vector<long>({(long)5, (long)11}), (std::vector<long>)std::vector<long>({(long)3, (long)3}), (std::vector<long>)std::vector<long>({(long)9, (long)5})}))) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)11, (long)14}), (std::vector<long>)std::vector<long>({(long)11, (long)18}), (std::vector<long>)std::vector<long>({(long)7, (long)14}), (std::vector<long>)std::vector<long>({(long)12, (long)17})})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a minimal, self\u2011contained implementation that takes two *equal\u2011shaped* nested vectors (`std::vector<std::vector<long>>`) and returns a new nested vector containing the element\u2011wise sums.\n\n```cpp\n#include <vector>\n#include <cassert>\n\n/**\n * @brief   Element\u2011wise addition of two nested vectors.\n *\n * @param test_tup1 The first nested vector.\n * @param test_tup2 The second nested vector. Must have the same outer and\n *                  inner dimensions as `test_tup1`.\n *\n * @return A new nested vector where each element is the sum of the\n *         corresponding elements in `test_tup1` and `test_tup2`.\n *\n * @throws std::invalid_argument if the shapes of the two vectors are\n *         different.  (The assertion is kept for debug builds and\n *         replaced by an exception in release builds.)\n */\nstd::vector<std::vector<long>>\nadd_nested_tuples(const std::vector<std::vector<long>>& test_tup1,\n                  const std::vector<std::vector<long>>& test_tup2)\n{\n    // Basic shape check (outer size)\n    if (test_tup1.size() != test_tup2.size()) {\n        throw std::invalid_argument(\"Outer dimensions differ\");\n    }\n\n    std::vector<std::vector<long>> result;\n    result.reserve(test_tup1.size());\n\n    for (size_t i = 0; i < test_tup1.size(); ++i) {\n        // Inner size must match for each sub\u2011vector.\n        if (test_tup1[i].size() != test_tup2[i].size()) {\n            throw std::invalid_argument(\n                \"Inner dimensions at index \" + std::to_string(i) + \" differ\");\n        }\n\n        std::vector<long> row;\n        row.reserve(test_tup1[i].size());\n\n        for (size_t j = 0; j < test_tup1[i].size(); ++j) {\n            row.push_back(test_tup1[i][j] + test_tup2[i][j]);\n        }\n        result.push_back(std::move(row));\n    }\n\n    return result;\n}\n```\n\n### How it works\n1. **Shape validation** \u2013 The function first verifies that both outer vectors have the same size and that each corresponding inner vector also has the same size.  \n2. **Construction of the result** \u2013 For every pair of corresponding inner vectors, a new vector is built containing the sum of each pair of elements.  \n3. **Return value** \u2013 A fresh nested vector holding the summed values is returned.\n\nFeel free to tweak the error handling (e.g., using `assert` instead of throwing exceptions) depending on your project's requirements.", "Below is a ready\u2011to\u2011copy implementation that\n\n1. **Validates** that the two nested vectors have the same outer size and that each inner vector has the same length.\n2. **Adds** corresponding elements element\u2011wise.\n3. **Returns** a new nested vector containing the sums (does not modify the input).\n\n```cpp\n#include <vector>\n#include <cassert>\n#include <stdexcept>\n\n/**\n * @brief Adds two nested vectors element\u2011wise.\n *\n * The function expects that both vectors have the same outer size and that\n * every corresponding inner vector has the same size.  If that is not the\n * case, it throws a `std::invalid_argument` exception (or you can\n * `assert` the condition in debug mode).\n *\n * @param a First nested vector.\n * @param b Second nested vector.\n * @return A new nested vector where each element is\n *         a[k][j] + b[k][j].\n */\nstd::vector<std::vector<long>> add_nested_tuples(\n    const std::vector<std::vector<long>>& a,\n    const std::vector<std::vector<long>>& b)\n{\n    // Check outer sizes\n    if (a.size() != b.size()) {\n        throw std::invalid_argument(\"Outer vector sizes differ\");\n    }\n\n    std::vector<std::vector<long>> result;\n    result.reserve(a.size());\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        // Check inner sizes\n        if (a[i].size() != b[i].size()) {\n            throw std::invalid_argument(\"Inner vector sizes differ at index \" + std::to_string(i));\n        }\n\n        std::vector<long> row;\n        row.reserve(a[i].size());\n\n        for (size_t j = 0; j < a[i].size(); ++j) {\n            row.push_back(a[i][j] + b[i][j]);\n        }\n        result.push_back(std::move(row));\n    }\n\n    return result;\n}\n```\n\n### How to use it\n\n```cpp\nint main() {\n    std::vector<std::vector<long>> v1 = {{1, 2}, {3, 4}};\n    std::vector<std::vector<long>> v2 = {{5, 6}, {7, 8}};\n\n    auto sum = add_nested_tuples(v1, v2);\n\n    // sum == {{6, 8}, {10, 12}}\n    return 0;\n}\n```\n\n### Notes\n\n* **Safety** \u2013 The function throws an exception if the input sizes are incompatible.  \n  If you prefer an early abort in debug builds, replace the `throw` statements with `assert`.\n\n* **Move semantics** \u2013 `std::move(row)` avoids an extra copy when pushing the inner vector into the result.\n\n* **Performance** \u2013 `reserve` pre\u2011allocates the required memory for the outer and inner vectors, reducing reallocations.\n\nFeel free to adapt the error handling to your project's conventions.", "Here is a minimal, well\u2011documented, and safe implementation that performs element\u2011wise addition of two nested vectors (a \u201cmatrix\u2011like\u201d container).  \nIt assumes that the two input vectors are *rectangular* \u2013 i.e. every inner vector has the same length \u2013 and that the two matrices have identical outer and inner dimensions. If the dimensions do not match the function will trigger an `assert` (only in debug builds) and otherwise will simply return the correctly\u2011oriented sum matrix.\n\n```cpp\n#include <cassert>\n#include <vector>\n\n/**\n * @brief Element\u2011wise addition of two nested vectors (matrices).\n *\n * The function expects two 2\u2011D vectors of the same shape:\n *   - the number of rows (`size()`) must match,\n *   - each row must have the same number of columns (`row.size()`).\n *\n * @param test_tup1 First matrix.\n * @param test_tup2 Second matrix.\n * @return std::vector<std::vector<long>> The sum matrix.\n */\nstd::vector<std::vector<long>>\nadd_nested_tuples(const std::vector<std::vector<long>>& test_tup1,\n                  const std::vector<std::vector<long>>& test_tup2)\n{\n    // ---- Dimension checks (assertions in debug mode) ----\n    assert(test_tup1.size() == test_tup2.size() && \"Row count mismatch\");\n\n    if (test_tup1.empty()) {\n        return {};      // Both are empty -> return empty matrix\n    }\n\n    const std::size_t rows = test_tup1.size();\n    const std::size_t cols = test_tup1[0].size();\n    for (std::size_t r = 0; r < rows; ++r) {\n        assert(test_tup1[r].size() == cols &&\n               \"Row 1 has inconsistent size\");\n        assert(test_tup2[r].size() == cols &&\n               \"Row 2 has inconsistent size\");\n    }\n\n    // ---- Result matrix pre\u2011allocation ----\n    std::vector<std::vector<long>> result(rows, std::vector<long>(cols));\n\n    // ---- Element\u2011wise addition ----\n    for (std::size_t r = 0; r < rows; ++r) {\n        for (std::size_t c = 0; c < cols; ++c) {\n            result[r][c] = test_tup1[r][c] + test_tup2[r][c];\n        }\n    }\n\n    return result;\n}\n```\n\n### Why this implementation?\n\n1. **Safety** \u2013 `assert` statements guard against mismatched dimensions during debugging, helping catch errors early.\n2. **Performance** \u2013 Pre\u2011allocating the result matrix avoids repeated dynamic reallocations.\n3. **Clarity** \u2013 Nested loops visibly reflect the \u201crow\u2011by\u2011row, column\u2011by\u2011column\u201d traversal, which is easy to read and audit.\n\nYou can drop this function into your codebase, include the `<cassert>` header, and call it with two matching matrices. If you prefer exceptions over assertions, replace the `assert` calls with explicit error handling (`throw std::invalid_argument{}`)."]}
{"name": "mbpp_618_div_list", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to divide two vectors element wise.\nstd::vector<float> div_list(std::vector<long> nums1, std::vector<long> nums2) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_618_div_list.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = div_list;\n    assert(candidate((std::vector<long>({(long)4, (long)5, (long)6})), (std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<float>({(float)4.0f, (float)2.5f, (float)2.0f})));\n    assert(candidate((std::vector<long>({(long)3, (long)2})), (std::vector<long>({(long)1, (long)4}))) == (std::vector<float>({(float)3.0f, (float)0.5f})));\n    assert(candidate((std::vector<long>({(long)90, (long)120})), (std::vector<long>({(long)50, (long)70}))) == (std::vector<float>({(float)1.8f, (float)1.7142857142857142f})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a compact, robust implementation of the **`div_list`** routine that\n\n1. **(Re\u2011)validates** the inputs \u2013 they must have the same length.\n2. **Performs element\u2011wise division** (`float` result per component).\n3. **Safeguards** against division by zero (the function will throw a `std::runtime_error` in that case\u2014 you can change the behaviour if you prefer).\n\n```cpp\n#include <vector>\n#include <stdexcept>   // for std::runtime_error\n#include <cstddef>     // for std::size_t\n\n/**\n * @brief Divide two vectors element\u2011wise.\n *\n * @param nums1  dividend vector\n * @param nums2  divisor vector\n * @return std::vector<float> result of element\u2011wise division\n *\n * @throws std::invalid_argument if the two vectors have different sizes\n * @throws std::runtime_error    if any divisor entry is zero\n */\nstd::vector<float> div_list(const std::vector<long>& nums1,\n                            const std::vector<long>& nums2)\n{\n    // Size check\n    if (nums1.size() != nums2.size())\n    {\n        throw std::invalid_argument(\n            \"div_list: input vectors must have the same length\");\n    }\n\n    std::vector<float> out;\n    out.reserve(nums1.size());          // avoid reallocations\n\n    for (std::size_t i = 0; i < nums1.size(); ++i)\n    {\n        if (nums2[i] == 0)\n        {\n            throw std::runtime_error(\n                \"div_list: division by zero at position \" + std::to_string(i));\n        }\n\n        // Cast both operands to float before dividing\n        out.push_back( static_cast<float>(nums1[i]) /\n                       static_cast<float>(nums2[i]) );\n    }\n\n    return out;\n}\n```\n\n### Why is this implementation useful?\n\n| Feature | Why it matters |\n|---------|----------------|\n| **Size validation** | Guarantees the resulting vector is exactly the same length as the inputs and prevents silent truncation/extension. |\n| **Zero\u2011division guard** | Avoids undefined behaviour (`inf`/`nan`) and gives a clear error message. |\n| **`reserve`** | Minimises reallocations for large vectors. |\n| **`const` references** | Avoids unnecessary copies of the input vectors. |\n| **Explicit casts** | Keeps the division in floating\u2011point domain and avoids integer truncation. |\n\nFeel free to tweak the exception types or the error handling logic to fit your project\u2019s conventions.", "Below is a self\u2011contained example that implements a **safe, element\u2011wise division** of two vectors of integral values.  \n- The function returns a vector of `float` so that fractional results are preserved.  \n- If the input vectors have different lengths a `std::invalid_argument` exception is thrown.  \n- Division by zero is detected and handled by returning `std::numeric_limits<float>::infinity()` (you may choose `nan()` or any other policy).  \n- An example `main` demonstrates usage and catches possible errors.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <stdexcept>\n#include <cmath>\n#include <limits>\n\n/**\n * @brief Divide two vectors element wise.\n *\n * Both input vectors must contain the same number of elements.\n * Division by zero is handled by returning IEEE infinity.\n *\n * @param nums1 Numerators.\n * @param nums2 Denominators.\n * @return std::vector<float> Result of element\u2011wise division.\n */\nstd::vector<float> div_list(const std::vector<long>& nums1,\n                            const std::vector<long>& nums2)\n{\n    if (nums1.size() != nums2.size()) {\n        throw std::invalid_argument(\"Vectors must have the same length\");\n    }\n\n    std::vector<float> result;\n    result.reserve(nums1.size());\n\n    for (size_t i = 0; i < nums1.size(); ++i) {\n        if (nums2[i] == 0) {\n            // Define behaviour for division by zero.\n            // Here we use IEEE infinity.  Replace with NaN if desired:\n            // result.push_back(std::numeric_limits<float>::quiet_NaN());\n            result.push_back(std::numeric_limits<float>::infinity());\n        } else {\n            result.push_back(static_cast<float>(nums1[i]) /\n                             static_cast<float>(nums2[i]));\n        }\n    }\n    return result;\n}\n\n/* ----------------------------------------------------------- */\n/* Example usage (optional).                                   */\n/* ----------------------------------------------------------- */\nint main()\n{\n    std::vector<long> a{10, 20, 30, 40};\n    std::vector<long> b{2, 5, 0, 4};\n\n    try {\n        std::vector<float> c = div_list(a, b);\n        std::cout << \"Result: \";\n        for (float v : c) {\n            if (std::isinf(v)) {\n                std::cout << \"inf \";\n            } else if (std::isnan(v)) {\n                std::cout << \"nan \";\n            } else {\n                std::cout << v << ' ';\n            }\n        }\n        std::cout << '\\n';\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << '\\n';\n    }\n    return 0;\n}\n```\n\n### Customisation / Extensions\n| Feature | What to change |\n|---------|----------------|\n| **Zero\u2011division policy** | Replace `infinity()` with `quiet_NaN()` or throw an exception. |\n| **Return type** | Return `std::vector<long>` or `std::vector<double>` if exact integers are required. |\n| **Parallelisation** | Use OpenMP or C++17 parallel algorithms (`std::transform(..., std::execution::par)`) for large vectors. |\n\nFeel free to copy\u2011paste this snippet into your project. Happy coding!", "Here is a complete, well\u2011commented implementation of the requested function.  \nThe function\n\n* checks that the two input vectors have the same length,\n* returns a new vector whose *i*\u2011th element is `nums1[i] / nums2[i]` (as a `float`);\n* throws a `std::invalid_argument` if the sizes differ or an element of `nums2` is `0`.\n\n```cpp\n#include <vector>\n#include <stdexcept>   // std::invalid_argument\n#include <cstdint>     // for int64_t / long\n\n/**\n * @brief Divide two vectors element\u2011wise.\n *\n * The division is performed element\u2011wise:\n *   result[i] = static_cast<float>(num1[i]) / static_cast<float>(num2[i])\n *\n * @param num1 First vector of integers (long).\n * @param num2 Second vector of integers (long). Must be the same size as num1.\n * @return std::vector<float> containing the quotients.\n *\n * @throws std::invalid_argument if:\n *   * num1 and num2 don't have the same size\n *   * an element of num2 is zero (division by zero).\n */\nstd::vector<float> div_list(const std::vector<long>& num1,\n                            const std::vector<long>& num2)\n{\n    if (num1.size() != num2.size()) {\n        throw std::invalid_argument(\"Vectors must have the same length\");\n    }\n\n    std::vector<float> result;\n    result.reserve(num1.size());             // reserve space to avoid reallocations\n\n    for (std::size_t i = 0; i < num1.size(); ++i) {\n        if (num2[i] == 0) {\n            throw std::invalid_argument(\n                \"Division by zero encountered at index \" + std::to_string(i));\n        }\n        result.push_back(static_cast<float>(num1[i]) /\n                         static_cast<float>(num2[i]));\n    }\n\n    return result;\n}\n```\n\n### How to use it\n\n```cpp\nint main() {\n    std::vector<long> a{10, 20, 30};\n    std::vector<long> b{2, 5, 3};\n\n    try {\n        std::vector<float> quotients = div_list(a, b);\n        for (float q : quotients) {\n            std::cout << q << ' ';\n        }\n        // Output: 5 4 10\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << '\\n';\n    }\n}\n```\n\nThis implementation is straightforward, efficient, and safe. Feel free to adapt the error handling (e.g., returning `std::optional<std::vector<float>>` or using `try/catch` in the caller) to fit your project's style."]}
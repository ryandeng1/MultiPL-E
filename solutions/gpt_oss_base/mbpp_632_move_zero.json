{"name": "mbpp_632_move_zero", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to move all zeroes to the end of the given vector.\nstd::vector<long> move_zero(std::vector<long> num_list) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_632_move_zero.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = move_zero;\n    assert(candidate((std::vector<long>({(long)1, (long)0, (long)2, (long)0, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)0, (long)0})));\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)2, (long)0, (long)0, (long)4, (long)0, (long)5, (long)0}))) == (std::vector<long>({(long)2, (long)3, (long)2, (long)4, (long)5, (long)0, (long)0, (long)0, (long)0})));\n    assert(candidate((std::vector<long>({(long)0, (long)1, (long)0, (long)1, (long)1}))) == (std::vector<long>({(long)1, (long)1, (long)1, (long)0, (long)0})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a clean, self\u2011contained C++11/14+/17\u2011compatible implementation that moves all `0`s in the vector to its end while preserving the order of the non\u2011zero elements.\n\n```cpp\n#include <vector>\n\n/*\n * Move every zero element in @p num_list to the end of the vector,\n * keeping the relative order of the non\u2011zero values intact.\n *\n *   Example:\n *     input  : {1, 0, 2, 0, 3}\n *     output : {1, 2, 3, 0, 0}\n *\n * Complexity:  O(n) time,  O(1) additional space\n *               (if the function returns by value the copy cost\n *               of the vector itself is unavoidable.)\n *\n * The function works for any integral type, but for clarity\n * we keep the signature with `long`.\n */\nstd::vector<long> move_zero(std::vector<long> num_list)\n{\n    // `write` points to the position where the next\n    // non\u2011zero element should be written.\n    size_t write = 0;\n\n    // First pass: copy non\u2011zeros forward.\n    for (size_t read = 0; read < num_list.size(); ++read) {\n        if (num_list[read] != 0) {\n            // Only assign when needed to avoid extra copies\n            // when read == write.\n            if (read != write) {\n                num_list[write] = num_list[read];\n            }\n            ++write;\n        }\n    }\n\n    // Second pass: fill the rest with zeros.\n    std::fill(num_list.begin() + write, num_list.end(), 0);\n\n    return num_list;\n}\n```\n\n### Why this implementation?\n\n| Requirement | How it is satisfied |\n|-------------|---------------------|\n| **Zeroes to the end** | All non\u2013zero elements are written forward, then the tail is filled with zeros. |\n| **Order preserved** | We never reorder the non\u2011zero elements; they are shifted left only when needed. |\n| **`O(n)` time** | Two linear passes. |\n| **`O(1)` extra space** | Only a few indices are used in addition to the input vector. |\n| **Works with any built\u2011in integer type** | The function accepts `long`, but could be templated easily. |\n\nFeel free to adapt it to your specific project (e.g., add templating, change the return type, or integrate into a class).", "Here\u2019s a clean, efficient C++ implementation that moves all zeroes to the end of the vector while preserving the order of the non\u2011zero elements:\n\n```cpp\n#include <vector>\n\n// Move all zeroes to the end of `num_list` in\u2011place.\n// Complexity: O(n) time, O(1) extra space.\nstd::vector<long> move_zero(std::vector<long> num_list) {\n    size_t writeIdx = 0;                     // Position to write next non\u2011zero element\n\n    // First pass: copy non\u2011zero values to the front\n    for (long val : num_list) {\n        if (val != 0) {\n            num_list[writeIdx++] = val;\n        }\n    }\n\n    // Second pass: fill the remaining positions with zeroes\n    while (writeIdx < num_list.size()) {\n        num_list[writeIdx++] = 0;\n    }\n\n    return num_list;\n}\n```\n\n### Why this works\n\n1. **Single pass over the input** to move all non\u2011zero numbers to the front.\n2. The `writeIdx` variable keeps track of where the next non\u2011zero should be placed.\n3. After all non\u2011zero numbers are moved, the rest of the array is filled with zeroes.\n4. No additional containers of size `n` are used \u2013 it\u2019s an overwriting in\u2011place operation with only a few variables.\n\nYou can test it with:\n\n```cpp\nint main() {\n    std::vector<long> v = {0,5,0,2,3,0,1};\n    auto result = move_zero(v);\n    for(long n: result) std::cout << n << ' ';\n    // Output: 5 2 3 1 0 0 0\n}\n```\n\nFeel free to adapt the implementation to your project's style or constraints!", "Here is a clean, self\u2011contained C++ implementation of a function that moves all zeros in a `std::vector<long>` to the end while keeping the relative order of the non\u2011zero elements intact.  \nThe algorithm runs in linear time (`O(n)`) and uses only constant extra space (`O(1)`).\n\n```cpp\n#include <vector>\n#include <cassert>\n\n// Move all zeroes to the end of the vector.\n// The relative ordering of all non\u2011zero elements is preserved.\n// Complexity: O(n) time, O(1) auxiliary space.\nstd::vector<long> move_zero(std::vector<long> num_list) {\n    size_t writeIdx = 0;               // Position to write the next non\u2011zero\n    for (size_t readIdx = 0; readIdx < num_list.size(); ++readIdx) {\n        if (num_list[readIdx] != 0) {\n            num_list[writeIdx++] = num_list[readIdx];\n        }\n    }\n    // The tail of the vector now contains only zeros\n    for (size_t i = writeIdx; i < num_list.size(); ++i) {\n        num_list[i] = 0;\n    }\n    return num_list;\n}\n```\n\n### How it works\n\n1. **First pass** \u2013 Scan the vector from left to right.  \n   Every time we find a non\u2011zero element, we copy it to the position indicated by `writeIdx` and then increment `writeIdx`.  \n   By the end of the pass, all non\u2011zero elements are packed at the beginning of the vector in their original order.\n\n2. **Second pass** \u2013 Starting from `writeIdx`, set all remaining positions to zero.  \n   This turns the tail of the vector into the required block of zeros.\n\n### Example\n\n```cpp\nint main() {\n    std::vector<long> v = {0, 1, 0, 3, 12};\n    auto result = move_zero(v);   // result == {1, 3, 12, 0, 0}\n}\n```\n\n> **Note**: The function returns a new vector, but you can also modify the input vector in place by passing it by reference (`std::vector<long>&`) if you prefer. The core logic remains identical."]}
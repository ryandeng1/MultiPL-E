{"name": "mbpp_592_sum_Of_product", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to find the sum of the product of consecutive binomial co-efficients.\nlong sum_Of_product(long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_592_sum_Of_product.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = sum_Of_product;\n    assert(candidate((3)) == (15));\n    assert(candidate((4)) == (56));\n    assert(candidate((1)) == (1));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a **ready\u2011to\u2011paste** C++ implementation that follows the specification:\n\n*   The function is called `sum_Of_product`.\n*   It takes an integer `n` (the upper bound of the binomial coefficient) and\n    returns the sum  \n    \\[\n    S(n)=\\sum_{k=0}^{n-1} \\binom{n}{k}\\binom{n}{k+1}\n    \\]\n*   The implementation uses 128\u2011bit integers (`__int128`) to avoid overflow for\n    reasonably large `n` (up to \u2248 60 on 64\u2011bit platforms).  \n    For even larger `n` you can switch to arbitrary\u2011precision libraries\n    (Boost.Multiprecision, GMP \u2026) \u2013 the algorithm is unchanged.\n*   The routine is O(n) time and O(1) auxiliary space.\n\n```cpp\n/***********************************************************************\n *  sum_Of_product\n *\n *  Computes the sum of the product of consecutive binomial coefficients,\n *  i.e. S(n) = \u03a3_{k=0}^{n-1} C(n,k) * C(n,k+1)\n *\n *  Parameters\n *      n : the upper bound of the binomial coefficients (n \u2265 1)\n *\n *  Returns\n *      long long : the result (fits in 64\u2011bit for n \u2264 60)\n *\n *  Complexity\n *      Time   : O(n)\n *      Memory : O(1)\n *\n *  Notes\n *      Uses 128\u2011bit integer arithmetic during the summation to avoid\n *      overflow.  The final result is cast back to long long.\n **********************************************************************/\n#include <cstdint>\n#include <limits>\n#include <stdexcept>\n\nlong long sum_Of_product(long long n)\n{\n    if (n < 1)\n        throw std::invalid_argument(\"n must be >= 1\");\n\n    // Current binomial coefficient C(n,0) = 1\n    __int128 cur = 1;          // holds C(n,k)\n    __int128 sum = 0;          // running total\n\n    for (long long k = 0; k < n; ++k) {\n        // next coefficient C(n,k+1) = C(n,k) * (n-k) / (k+1)\n        __int128 next = cur * (n - k) / (k + 1);\n\n        // add product of consecutive coefficients\n        sum += cur * next;\n\n        // move to next k\n        cur = next;\n    }\n\n    // sum now holds \u03a3 C(n,k)*C(n,k+1)\n    // cast to long long \u2013 for n <= 60 this is always safe\n    return static_cast<long long>(sum);\n}\n\n/* ---------- Example usage ---------- *\n#include <iostream>\nint main() {\n    long long n = 10;\n    std::cout << \"S(\" << n << \") = \" << sum_Of_product(n) << '\\n';\n    return 0;\n}\n***/\n\n```\n\n### Why this works\n\nThe binomial coefficients satisfy the recurrence\n\n\\[\n\\binom{n}{k+1} = \\binom{n}{k}\\;\\frac{n-k}{k+1}\\;,\n\\]\n\nso we can generate all coefficients in a single loop without\ncalling a factorial routine.  \nFor each `k` we multiply the current coefficient (`cur = C(n,k)`)\nby the next one (`next = C(n,k+1)`) and add the product to the running\nsum.  \nAfter the loop finishes, `sum` equals the requested sum of products.\n\nFeel free to adapt the data type (`__int128`, `long long`, or any\narbitrary\u2011precision type) if you need to handle even larger `n`.", "Below is a clean, self\u2011contained Python implementation that returns the sum of the product of every pair of consecutive binomial coefficients  \n\\[\nS(n)=\\sum_{k=0}^{\\,n-1}\\binom{n}{k}\\binom{n}{k+1}\n\\]\n\nThe function works for any non\u2011negative integer `n`.  \nIt uses only the standard library (no external dependencies). If you are working in an environment that already has `math.comb` (Python\u00a03.8+), the implementation is particularly short. For older Python versions it falls back to a manual factorial\u2011based implementation.\n\n```python\n# sum_of_product.py\n\"\"\"\nCompute\n\n    S(n) = \u03a3_{k=0}^{n-1} C(n,k) * C(n,k+1)\n\nwhere C(n,k) = binomial coefficient (n choose k).\n\nThe implementation is compatible with Python 3.7+.\n\"\"\"\n\nfrom __future__ import annotations\nfrom math import comb  # available in Python 3.8+. For older versions, define a fallback.\nimport sys\n\n# ------------------------------------------------------------\n# Helper: factorial based binomial if math.comb is absent\n# ------------------------------------------------------------\ndef _comb_fact(n: int, k: int) -> int:\n    \"\"\"\n    Compute C(n, k) using factorials.  Works for arbitrary n, k >= 0.\n    \"\"\"\n    if k < 0 or k > n:\n        return 0\n    # reduce multiplicative work: C(n, k) == C(n, n-k)\n    k = min(k, n - k)\n    numer = 1\n    denom = 1\n    for i in range(1, k + 1):\n        numer *= n - (k - i)\n        denom *= i\n    return numer // denom\n\n\n# If the environment provides math.comb we use it; otherwise alias to the fallback.\nif sys.version_info < (3, 8):\n    _comb = _comb_fact\nelse:\n    _comb = comb\n\n# ------------------------------------------------------------\n# Main function\n# ------------------------------------------------------------\ndef sum_of_product(n: int) -> int:\n    \"\"\"\n    Return the sum of products of consecutive binomial coefficients for given n.\n\n    Parameters\n    ----------\n    n : int\n        Non\u2011negative integer. For n < 0 the function raises ValueError.\n\n    Returns\n    -------\n    int\n        The value of S(n).\n\n    Examples\n    --------\n    >>> sum_of_product(0)\n    0\n    >>> sum_of_product(1)\n    1\n    >>> sum_of_product(4)\n    70\n    >>> sum_of_product(10)\n    1847560\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be non\u2011negative\")\n\n    total = 0\n    for k in range(n):\n        total += _comb(n, k) * _comb(n, k + 1)\n    return total\n\n# ------------------------------------------------------------\n# Quick manual test\n# ------------------------------------------------------------\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()      # runs examples in docstring\n\n    # sample output\n    for n in range(6):\n        print(f\"S({n}) = {sum_of_product(n)}\")\n```\n\n### Why this works\n\nThe inner loop iterates through all `k` from `0` to `n-1`.  \nFor each `k` it multiplies:\n\n* `C(n, k)`\u2003\u2013 number of ways to choose `k` items from `n`\n* `C(n, k+1)` \u2013 number of ways to choose `k+1` items from `n`\n\nThe sum over all `k` gives exactly the desired result.\n\n### Complexity\n\n*Time*: `O(n)` \u2013 we perform a constant amount of work per `k`.  \n*Space*: `O(1)` \u2013 only a few integer variables are kept.\n\nFeel free to copy this snippet into your project or to adapt it to your build system.", "The problem is to compute  \n\n\\[\nS(n)=\\sum_{k=0}^{n-1}\\binom{n}{k}\\binom{n}{k+1},\n\\]\n\ni.e. the sum of the product of **consecutive** binomial coefficients of order *n*.\n\nBelow is a compact and efficient C++ implementation that works for very large *n*.  \nWe exploit a simple combinatorial identity (see the brief proof in the comments), which reduces the whole sum to a **single** arithmetic operation.\n\n```cpp\n#include <iostream>\n#include <cstdint>   // for uint64_t\n#include <stdexcept>\n\n// Return S(n) = sum_{k=0}^{n-1} C(n,k)*C(n,k+1)\nuint64_t sum_of_product(uint64_t n)\n{\n    if (n == 0) return 0;          // convention: no terms\n\n    // For n >= 1 we have the closed\u2011form:\n    //    S(n) = n * ( 2^{n-1} - 1 )\n    //\n    // Proof (sketch):\n    //   C(n,k)C(n,k+1) = n * C(n-1,k+1)\n    //   Summing over k gives\n    //       n * sum_{k=0}^{n-1} C(n-1,k+1)\n    //   The inner sum is\n    //       sum_{j=1}^{n} C(n-1,j) = 2^{n-1} - C(n-1,0)\n    //   Hence S(n) = n*(2^{n-1}-1).\n    //\n    // The result can be huge, so we return an unsigned 64\u2011bit value.\n    // If you need arbitrary precision, replace the return type with\n    // a big\u2011int class (e.g. boost::multiprecision::cpp_int).\n\n    // Compute 2^{n-1}.  For n up to 63 this fits in 64 bits.\n    // For larger n this will overflow; again, use big ints if needed.\n    uint64_t pow2 = 1ULL << (n - 1);\n\n    return n * (pow2 - 1);\n}\n\nint main()\n{\n    for (uint64_t n = 0; n <= 10; ++n)\n        std::cout << \"S(\" << n << \") = \" << sum_of_product(n) << '\\n';\n    return 0;\n}\n```\n\n**Explanation of the identity**\n\n```\nC(n,k) C(n,k+1)\n    = [n!/(k!(n-k)!)] * [(n!)/((k+1)!(n-k-1)!)]\n    = n * (n-1)!/[(k+1)!(n-k-1)!] * 1/(k!(n-k)!)\n    = n * C(n-1,k+1)\n```\n\nSumming over `k` from `0` to `n-1` yields\n\n```\nS(n) = n * \u03a3_{k=0}^{n-1} C(n-1,k+1)\n     = n * ( \u03a3_{j=1}^{n} C(n-1,j) )\n     = n * ( 2^{n-1} - C(n-1,0) )\n     = n * ( 2^{n-1} - 1 )\n```\n\nThat single line is all that is needed to compute the answer, making the code O(1) in time and memory."]}
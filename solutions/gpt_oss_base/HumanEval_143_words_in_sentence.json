{"name": "HumanEval_143_words_in_sentence", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_143_words_in_sentence.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// helper: check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    return true;\n}\n\nstring words_in_sentence(string sentence) {\n    vector<string> result;\n    stringstream ss(sentence);\n    string word;\n    while (ss >> word) {                     // split by whitespace\n        if (isPrime((int)word.length())) {\n            result.push_back(word);\n        }\n    }\n    if (result.empty())\n        return \"\";\n    // join the words back together with a single space\n    string out = result[0];\n    for (size_t i = 1; i < result.size(); ++i)\n        out += ' ' + result[i];\n    return out;\n}\n```\n\n**Explanation**\n\n1. **Prime check (`isPrime`)** \u2013 fast enough for lengths up to 100.  \n2. Split the input sentence using `stringstream`, which automatically skips consecutive spaces.  \n3. Append every word whose length is prime to a `vector`.  \n4. Finally join the selected words with a single space; if no words match, return an empty string.  \n\nThis meets the constraints and preserves the original order of the qualifying words.", "Here is a compact and efficient implementation that follows the specification:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic bool isPrime(int n) {\n    if (n < 2) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i * i <= n; i += 2)\n        if (n % i == 0) return false;\n    return true;\n}\n\nstring words_in_sentence(string sentence) {\n    vector<string> result;\n    string word;\n    stringstream ss(sentence);\n\n    while (ss >> word) {                 // iterate over space\u2011separated words\n        if (isPrime((int)word.length()))\n            result.push_back(word);       // keep the word if its length is prime\n    }\n\n    // Join the selected words back into a single string\n    string res;\n    for (size_t i = 0; i < result.size(); ++i) {\n        if (i) res += ' ';\n        res += result[i];\n    }\n    return res;\n}\n```\n\n## How it works\n\n1. **Prime check (`isPrime`)**  \n   - Handles numbers `< 2` as non\u2011prime.  \n   - Uses trial division only up to \u221an, skipping even numbers after checking 2.  \n\n2. **Parsing the sentence**  \n   - `stringstream` splits the input by whitespace, giving each word in order.  \n\n3. **Filtering**  \n   - For each word, its length is checked for primality.  \n   - If prime, the word is pushed into a vector to preserve order.  \n\n4. **Re\u2011assembling**  \n   - The selected words are concatenated with single spaces between them.  \n   - If no words match, an empty string is returned.  \n\n### Example\n\n```cpp\ncout << words_in_sentence(\"This is a test\") << '\\n';   // outputs: is\ncout << words_in_sentence(\"lets go for swimming\") << '\\n'; // outputs: go for\n```\n\nThis solution runs in O(L) time (where L is the number of characters in the sentence) and uses only a few auxiliary containers.", "Here is a compact, self\u2011contained solution that follows the requirements of the problem:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// ------- helper -------------------------------------------------\ninline bool isPrime(int x)\n{\n    if (x < 2) return false;\n    for (int i = 2; i * i <= x; ++i)\n        if (x % i == 0) return false;\n    return true;\n}\n\n// ------- main ----------------------------------------------------\n/**\n * Given a sentence, returns a string that contains only those words\n * whose lengths are prime numbers.  \n * The order of the words is preserved.\n *\n * Example:\n *   \"This is a test\"      -> \"is\"\n *   \"lets go for swimming\" -> \"go for\"\n */\nstring words_in_sentence(const string& sentence)\n{\n    vector<string> result;\n    string word;\n    stringstream ss(sentence);\n\n    while (ss >> word)            // extract words separated by whitespace\n        if (isPrime(static_cast<int>(word.size())))\n            result.push_back(word);\n\n    // join all qualified words with a single space\n    string out;\n    for (size_t i = 0; i < result.size(); ++i) {\n        if (i) out += ' ';\n        out += result[i];\n    }\n    return out;\n}\n\n// ------------------------------------------------------------------\n```\n\n### Why this works\n\n1. **Splitting the sentence** \u2013 `stringstream` is used to split the input string by whitespace, giving us each word in its original order.\n2. **Prime check** \u2013 `isPrime` checks whether the length of a word is a prime number.  \n   It runs in \\(O(\\sqrt{n})\\) where `n` is the size of the word (max 100, so it\u2019s trivial).\n3. **Collect & join** \u2013 Qualified words are gathered in a `vector` and finally joined with single spaces in order, which yields the desired result.\n\nThis implementation runs in \\(O(L \\sqrt{W})\\) where \\(L\\) is the total number of characters in the sentence and \\(W\\) is the length of the longest word, both comfortably within the given constraints."]}
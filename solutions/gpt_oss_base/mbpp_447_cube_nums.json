{"name": "mbpp_447_cube_nums", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find cubes of individual elements in a vector.\nstd::vector<long> cube_nums(std::vector<long> nums) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_447_cube_nums.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = cube_nums;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10}))) == (std::vector<long>({(long)1, (long)8, (long)27, (long)64, (long)125, (long)216, (long)343, (long)512, (long)729, (long)1000})));\n    assert(candidate((std::vector<long>({(long)10, (long)20, (long)30}))) == (std::vector<long>({(long)1000, (long)8000, (long)27000})));\n    assert(candidate((std::vector<long>({(long)12, (long)15}))) == (std::vector<long>({(long)1728, (long)3375})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Sure! Below is a complete, self\u2011contained C++ program that demonstrates how to write a function called `cube_nums` that takes a `std::vector<long>` and returns a new vector containing the cube of each element.  \nI\u2019ll also add a small `main` function to illustrate how the helper can be used and a few simple unit\u2011style tests to verify its correctness.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cassert>\n\n/*********************************************************************\n * cube_nums : Takes a vector of integers and returns a new vector\n *              whose elements are the cubes of the corresponding\n *              elements in the input vector.\n *\n * Parameters:\n *   nums - const reference to the input vector of type long\n *\n * Returns:\n *   A std::vector<long> where each element is nums[i] * nums[i] * nums[i]\n *********************************************************************/\nstd::vector<long> cube_nums(const std::vector<long>& nums)\n{\n    std::vector<long> result;\n    result.reserve(nums.size());               // avoid reallocs\n\n    for (long val : nums)\n    {\n        // safe to multiply long three times:\n        long cube = val * val * val;\n        result.push_back(cube);\n    }\n\n    return result;\n}\n\n/*********************************************************************\n * Simple unit\u2011style tests.  In real projects consider a testing\n * framework (GoogleTest, Catch2, etc.).  \n *********************************************************************/\nvoid run_tests()\n{\n    // Test 1: normal values\n    std::vector<long> in1{1, 2, 3};\n    std::vector<long> out1 = cube_nums(in1);\n    assert((out1 == std::vector<long>{1, 8, 27}));\n\n    // Test 2: negative numbers\n    std::vector<long> in2{-1, -2, -3};\n    std::vector<long> out2 = cube_nums(in2);\n    assert((out2 == std::vector<long>{-1, -8, -27}));\n\n    // Test 3: mixed values\n    std::vector<long> in3{-1, 0, 1, 2, -3};\n    std::vector<long> out3 = cube_nums(in3);\n    assert((out3 == std::vector<long>{-1, 0, 1, 8, -27}));\n\n    // Test 4: empty vector\n    std::vector<long> in4{};\n    std::vector<long> out4 = cube_nums(in4);\n    assert(out4.empty());\n\n    std::cout << \"All tests passed.\\n\";\n}\n\n/*********************************************************************\n * Main function \u2013 demonstrates usage and runs the tests.\n *********************************************************************/\nint main()\n{\n    try\n    {\n        run_tests();\n\n        // Example usage\n        std::vector<long> numbers{4, 5, -2};\n        std::vector<long> cubes = cube_nums(numbers);\n\n        std::cout << \"Input numbers: \";\n        for (auto n : numbers) std::cout << n << ' ';\n        std::cout << \"\\nCubes:          \";\n        for (auto c : cubes) std::cout << c << ' ';\n        std::cout << '\\n';\n    }\n    catch (const std::exception& e)\n    {\n        std::cerr << \"An error occurred: \" << e.what() << '\\n';\n    }\n\n    return 0;\n}\n```\n\n### How it works\n\n1. **`cube_nums`**  \n   * Takes a *const reference* to avoid copying the input vector.  \n   * Reserves space equal to the input size for efficiency.  \n   * Iterates over each element, computes the cube (`val * val * val`), and pushes it into the result vector.  \n\n2. **Testing**  \n   * Four test cases cover normal numbers, negative values, a mix including zero, and the empty case.  \n   * `assert` ensures the function behaves as expected.\n\n3. **Main**  \n   * Calls the test suite first.  \n   * Shows a simple example of usage, printing both original numbers and their cubes.\n\nCompile with e.g.:\n\n```bash\ng++ -std=c++17 -Wall -Wextra -O2 -o cubes cubes.cpp\n./cubes\n```\n\nYou should see the test message followed by the example output.", "## Function explanation\n\nThe task is straightforward: for every element in the input vector compute its cube and return a new vector containing these cubes.  \nBecause the input elements are of type `long`, we also represent the output as `long` so that the result can hold large numbers.  (If you care about overflow you can change the type or add range checks.)\n\n```cpp\n#include <vector>\n\n/// \\brief  Return a vector holding the cube of each element of the input vector.\n///\n/// \\param  nums  Input vector of integers.\n/// \\return A new vector of the same size where each element is the cube of the\n///         corresponding element from `nums`.\nstd::vector<long> cube_nums(const std::vector<long>& nums)\n{\n    // Reserve space to avoid repeated reallocations.\n    std::vector<long> result;\n    result.reserve(nums.size());\n\n    for (long x : nums) {\n        result.push_back(x * x * x);   // x\u00b3\n    }\n    return result;\n}\n```\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> v = {1, 2, 3, 4};\n    auto cubes = cube_nums(v);\n\n    for (long c : cubes) {\n        std::cout << c << \" \";\n    }\n    // Output: 1 8 27 64\n}\n```\n\nThe function works for any non\u2011empty vector, and uses `reserve` to make the operation \\(O(n)\\) without dynamic memory overhead.", "Here is a minimal, self\u2011contained implementation that returns a new vector containing the cubes of every element in the input vector.\n\n```cpp\n#include <vector>\n#include <cassert>\n\n/// \\brief Returns a vector whose i\u2011th element is the cube of nums[i].\n/// \\param nums vector of numbers to be cubed\n/// \\return a new vector containing the cubes\nstd::vector<long> cube_nums(const std::vector<long>& nums)\n{\n    std::vector<long> result;\n    result.reserve(nums.size());          // avoid reallocations\n\n    for (const long x : nums)\n        result.push_back(x * x * x);      // compute cube\n\n    return result;\n}\n```\n\n### How it works\n1. **Reserve space** \u2013 `reserve` pre\u2011allocates enough memory for the result, keeping the algorithm linear in time.\n2. **Loop** \u2013 For each element `x` in the input vector, multiply `x` by itself twice to obtain its cube and push the result into `result`.\n3. **Return** \u2013 The newly created vector `result` is returned by value.  \n\nThe implementation uses only the standard library (`<vector>`), so it compiles with any C++ compiler that supports at least C++03. If you wish to use C++11 or newer, the range\u2011based for loop (`for (const long x : nums)`) is still fine."]}
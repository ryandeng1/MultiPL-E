{"name": "mbpp_394_check_distinct", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to check if given vector contains no duplicates.\nbool check_distinct(std::vector<long> test_tup) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_394_check_distinct.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = check_distinct;\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)5, (long)6, (long)1, (long)4}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)5, (long)6}))) == (true));\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)4, (long)5, (long)6}))) == (true));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a **complete, self\u2011contained implementation** of the `check_distinct` function along with a tiny demo that shows how it can be used.  \nThe algorithm is straightforward \u2013 use an `unordered_set` (hash table) to record every element that we have already seen.  \nIf we encounter an element that is already in the set we immediately know that there is a duplicate and can return `false`.  \nIf we finish scanning the vector without a collision we return `true`.\n\n```cpp\n// ---------------  check_distinct.hpp  -----------------\n\n#pragma once\n#include <vector>\n#include <unordered_set>\n#include <cstddef>  // for std::size_t\n\n/**\n * @brief  Test whether all elements in a vector are distinct.\n * @param  data  The vector to test.\n * @return true  if there are no duplicates, false otherwise.\n *\n * Complexity:  O(n) time, O(n) auxiliary space.\n */\ninline bool check_distinct(const std::vector<long>& data)\n{\n    std::unordered_set<long> seen;\n    seen.reserve(data.size());                  // avoid re\u2011hashing\n    for (const long val : data)\n    {\n        if (!seen.insert(val).second)           // insert() returns pair<iterator,bool>\n            return false;                       // duplicate detected\n    }\n    return true;\n}\n```\n\n```cpp\n// ---------------  main.cpp  -----------------\n\n#include <iostream>\n#include <vector>\n#include \"check_distinct.hpp\"\n\nint main()\n{\n    std::vector<long> a = {1, 2, 3, 4, 5};\n    std::vector<long> b = {1, 2, 2, 3, 4};\n\n    std::cout << std::boolalpha;           // print `true/false` instead of 1/0\n    std::cout << \"a is distinct: \" << check_distinct(a) << '\\n';  // true\n    std::cout << \"b is distinct: \" << check_distinct(b) << '\\n';  // false\n\n    return 0;\n}\n```\n\n### Why this solution is excellent for most use\u2011cases\n\n| Property | Detail |\n|----------|--------|\n| **Time** | `O(n)` \u2013 each element is looked at exactly once. |\n| **Space** | `O(n)` \u2013 the hash set stores at most one copy of each element. |\n| **Simplicity** | Only one pass, no expensive operations. |\n| **Robustness** | Works for any vector size, including empty vectors. |\n\nFeel free to drop the two files into your project or copy the function body directly into your existing code. If you wish to avoid the extra space, the *O(1)*\u2011space version would require sorting first, but that would change the time complexity to `O(n log n)` and mutate the input vector. The hash\u2011set solution is the most common choice when you are willing to use auxiliary memory.", "Here is a concise, self\u2011contained implementation that\n\n* takes a **pass\u2011by\u2011value** vector (so the caller\u2019s data is not modified, which also protects the caller from accidental changes),\n* sorts the vector in\u2011place,\n* walks through the sorted sequence and checks whether any consecutive pair is equal.\n\nBecause the vector is sorted, duplicates can only appear as adjacent elements.  \nThe time complexity is\u202fO(n\u202flog\u202fn) due to the sort, the space complexity is\u202fO(1) (in\u2011place sort).\n\n```cpp\n#include <vector>\n#include <algorithm>   // std::sort\n\n/// @brief   Return true if the vector contains only distinct elements.\n/// @param   test_tup  Vector of long integers (passed by value \u2013 will be sorted locally).\n/// @returns true if all elements are unique, false otherwise.\nbool check_distinct(std::vector<long> test_tup)\n{\n    // Quick exit for 0 or 1 element \u2013 automatically distinct.\n    if (test_tup.size() <= 1)\n        return true;\n\n    // Sort the copy \u2013 duplicates will become adjacent.\n    std::sort(test_tup.begin(), test_tup.end());\n\n    // Scan for equal neighbours.\n    for (std::size_t i = 1; i < test_tup.size(); ++i)\n    {\n        if (test_tup[i] == test_tup[i - 1])\n            return false;   // duplicate found\n    }\n\n    return true;   // no duplicates detected\n}\n```\n\n---\n\n### Why this works\n\n* **Sorting** guarantees that equal values are placed next to each other.\n* After sorting, a single linear scan (`O(n)`) suffices to locate a repeated value.\n* Complexity:  \n  * Sorting \u2013 `O(n log n)`  \n  * Scan \u2013 `O(n)`  \n  * Total \u2013 `O(n log n)`  \n* No additional memory beyond the input vector (apart from a few loop variables).\n\n---\n\n### Usage example\n\n```cpp\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<long> a = {5, 3, 9, 1, 4};\n    std::vector<long> b = {2, 7, 2, 8};\n\n    std::cout << std::boolalpha;\n    std::cout << \"a distinct? \" << check_distinct(a) << '\\n';  // true\n    std::cout << \"b distinct? \" << check_distinct(b) << '\\n';  // false\n}\n```\n\nRunning the program prints:\n\n```\na distinct? true\nb distinct? false\n```\n\nFeel free to adapt the function signature (e.g., change to `const std::vector<long>&` if you know the input will never mutate, or return `void`/`size_t` for different use\u2011cases).", "Below is a compact, self\u2011contained implementation that checks whether a `std::vector<long>` contains **no duplicate elements**.  \nThe function is written in a way that is easy to read, fast (average\u2011case linear time) and has no side\u2011effects.  \n\n```cpp\n#include <vector>\n#include <unordered_set>\n\n/**\n * @brief Returns true iff the input vector contains no duplicate elements.\n *\n * The function uses an `unordered_set` to keep track of values that have\n * already been seen.  In the worst case the algorithm visits each element\n * once and inserts it into the hash table, giving an average time complexity\n * of *O(n)* and a space complexity of *O(n)*.\n *\n * @param test_tup  Vector of long integers to be checked.\n * @return true  if all elements are distinct.\n * @return false if any value appears more than once.\n */\nbool check_distinct(const std::vector<long>& test_tup)\n{\n    // An empty vector or a single element vector is trivially distinct.\n    if (test_tup.size() <= 1)\n        return true;\n\n    std::unordered_set<long> seen;\n    seen.reserve(test_tup.size());        // avoid re\u2011hashes\n\n    for (long v : test_tup)\n    {\n        if (!seen.insert(v).second)       // insert returns pair<iterator,bool>\n            return false;                 // already existed \u2192 duplicate\n    }\n    return true;\n}\n```\n\n### How it works\n1. **Early exit** \u2013 if the vector has 0 or 1 element it cannot contain duplicates.  \n2. **Hash set** \u2013 an `unordered_set<long>` keeps all values we\u2019ve seen so far.  \n3. **Insert\u2011check** \u2013 for each element we attempt to insert it into the set.  \n   * `insert()` returns a pair where the `second` boolean is `true` if the\n     insertion succeeded (i.e., the element was not previously in the set).  \n   * If the boolean is `false`, the element was already present \u2192 a duplicate\n     \u2192 we immediately return `false`.  \n4. If the loop ends without finding a duplicate, the vector is distinct, so\n   we return `true`.\n\n### Usage example\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::vector<long> v1 = {1, 2, 3, 4};\n    std::vector<long> v2 = {1, 2, 3, 2};\n\n    std::cout << std::boolalpha;\n    std::cout << \"v1 distinct? \" << check_distinct(v1) << '\\n'; // true\n    std::cout << \"v2 distinct? \" << check_distinct(v2) << '\\n'; // false\n}\n```\n\nThe program prints:\n\n```\nv1 distinct? true\nv2 distinct? false\n```\n\nFeel free to adapt the function (e.g., change the container type or the return type) to suit your particular needs."]}
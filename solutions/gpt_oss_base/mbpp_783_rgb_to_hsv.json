{"name": "mbpp_783_rgb_to_hsv", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to convert rgb color to hsv color. https://www.geeksforgeeks.org/program-change-rgb-color-model-hsv-color-model/\nstd::vector<float> rgb_to_hsv(long r, long g, long b) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_783_rgb_to_hsv.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = rgb_to_hsv;\n    assert(candidate((255), (255), (255)) == (std::vector<float>({(float)0.0f, (float)0.0f, (float)100.0f})));\n    assert(candidate((0), (215), (0)) == (std::vector<float>({(float)120.0f, (float)100.0f, (float)84.31372549019608f})));\n    assert(candidate((10), (215), (110)) == (std::vector<float>({(float)149.26829268292684f, (float)95.34883720930233f, (float)84.31372549019608f})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a complete implementation of `rgb_to_hsv`.  \nIt assumes the input RGB components are in the 0\u2011255 range (as on the GeeksforGeeks example) and returns a vector of three `float` values:  \n\n```cpp\n// H  \u2013 hue  (0 \u2026 360)\n// S  \u2013 saturation (0 \u2026 1)\n// V  \u2013 value  (0 \u2026 1)\n```\n\n```cpp\n#include <vector>\n#include <cmath>\n#include <cassert>\n\n/*------------------------------------------------------\n  Convert a colour from the RGB space to the HSV space\n  Input:\n    r,g,b \u2013 integer components in 0\u2026255\n  Output:\n    vector<float> with {H,S,V}\n    H \u2013 hue      (0\u2026360)\n    S \u2013 saturation (0\u20261)\n    V \u2013 value (0\u20261)\n  ------------------------------------------------------*/\nstd::vector<float> rgb_to_hsv(long r, long g, long b)\n{\n    assert(r>=0 && r<=255 && g>=0 && g<=255 && b>=0 && b<=255);\n\n    // Normalise RGB to [0,1]\n    float rf = r / 255.0f;\n    float gf = g / 255.0f;\n    float bf = b / 255.0f;\n\n    float maxC = std::max({rf, gf, bf});\n    float minC = std::min({rf, gf, bf});\n    float delta = maxC - minC;\n\n    // Value\n    float V = maxC;\n\n    // Saturation\n    float S = (maxC == 0.0f) ? 0.0f : (delta / maxC);\n\n    // Hue\n    float H = 0.0f;\n    if (delta != 0.0f) {\n        if (maxC == rf) {\n            H = 60.0f * ( std::fmod(((gf - bf) / delta), 6.0f) );\n        } else if (maxC == gf) {\n            H = 60.0f * ( ((bf - rf) / delta) + 2.0f );\n        } else { // maxC == bf\n            H = 60.0f * ( ((rf - gf) / delta) + 4.0f );\n        }\n        if (H < 0.0f)\n            H += 360.0f;\n    }\n\n    return {H, S, V};\n}\n```\n\n### How it works\n1. **Normalise** the RGB values to `[0,1]`.  \n2. Compute `maxC`, `minC` and their difference `delta`.  \n3. The **Value (V)** is just `maxC`.  \n4. The **Saturation (S)** is `delta / maxC` (or `0` if `maxC` is `0`).  \n5. The **Hue (H)** is calculated from the relative position of the dominant channel. The result is expressed in degrees (`0 \u2026 360`).\n\nFeel free to adapt the range of `S` and `V` if your application requires `[0,100]` or a different scale.", "Here is a compact yet readable implementation that follows the standard&nbsp;RGB\u2013>HSV conversion algorithm.  \nThe function works for integer RGB values in the range 0\u2011255, but it also accepts any numeric type that can be converted to `float`.  The output vector contains `h` (degrees 0\u2013360), `s` and `v` (both in the range 0\u20131).  The code is fully self\u2011contained \u2013 you only need to include `<vector>` and `<algorithm>`.\n\n```cpp\n#include <vector>\n#include <algorithm> // for std::max, std::min\n\n/**\n * @brief Convert RGB color to HSV.\n *\n * @param r Red component (0\u2011255)\n * @param g Green component (0\u2011255)\n * @param b Blue component (0\u2011255)\n * @return std::vector<float>  Vector with three values: {h, s, v}\n *   - h  : Hue, degrees in [0,360)\n *   - s  : Saturation, in [0,1]\n *   - v  : Value, in [0,1]\n */\nstd::vector<float> rgb_to_hsv(long r, long g, long b)\n{\n    // Clamp inputs to the valid range just in case\n    r = std::max(0L, std::min(255L, r));\n    g = std::max(0L, std::min(255L, g));\n    b = std::max(0L, std::min(255L, b));\n\n    // Convert to float in range [0,1]\n    float rf = r / 255.f;\n    float gf = g / 255.f;\n    float bf = b / 255.f;\n\n    // Find max, min and delta\n    float maxVal = std::max(rf, std::max(gf, bf));\n    float minVal = std::min(rf, std::min(gf, bf));\n    float delta  = maxVal - minVal;\n\n    // Value (V)\n    float v = maxVal;\n\n    // Saturation (S)\n    float s = (maxVal == 0.f) ? 0.f : delta / maxVal;\n\n    // Hue (H)\n    float h = 0.f;\n    if (delta != 0.f) {\n        if (maxVal == rf)\n            h = 60.f * fmodf((gf - bf) / delta, 6.f);\n        else if (maxVal == gf)\n            h = 60.f * ((bf - rf) / delta + 2.f);\n        else   // maxVal == bf\n            h = 60.f * ((rf - gf) / delta + 4.f);\n\n        if (h < 0.f) h += 360.f;\n    }\n\n    return {h, s, v};\n}\n```\n\n### Usage example\n\n```cpp\nint main() {\n    auto hsv = rgb_to_hsv(255, 102, 0);   // Orange\n    std::cout << \"H: \" << hsv[0] << \" S: \" << hsv[1] << \" V: \" << hsv[2] << '\\n';\n}\n```\n\nThis implementation is straightforward, uses only the standard library, and can be copy\u2011and\u2011pasted into any C++ project.", "Here is a complete implementation of an `rgb_to_hsv` helper that follows the classic RGB\u2011to\u2011HSV conversion algorithm.  \nIt accepts the red, green and blue components (each in the range\u00a00\u2013255), converts them to the HSV representation, and returns a `std::vector<float>` containing the values in the order **Hue (0\u2011360\u00b0), Saturation (0\u20111), Value (0\u20111)**.\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nstd::vector<float> rgb_to_hsv(long r, long g, long b)\n{\n    // 1 \u2013 Normalize the RGB values to the [0,1] range\n    float R = static_cast<float>(r) / 255.0f;\n    float G = static_cast<float>(g) / 255.0f;\n    float B = static_cast<float>(b) / 255.0f;\n\n    // 2 \u2013 Find min, max and delta\n    float Cmax = std::max({R, G, B});          // max(R,G,B)\n    float Cmin = std::min({R, G, B});          // min(R,G,B)\n    float delta = Cmax - Cmin;                 // \u03b4\n\n    // 3 \u2013 Compute Hue\n    float H = 0.0f;\n    if (delta < 1e-6f) {                 // gray\n        H = 0.0f;                         // hue is undefined; by convention 0\n    } else if (Cmax == R) {\n        H = 60.0f * fmod(((G - B) / delta), 6.0f);\n        if (H < 0) H += 360.0f;           // keep it positive\n    } else if (Cmax == G) {\n        H = 60.0f * (((B - R) / delta) + 2.0f);\n    } else { // Cmax == B\n        H = 60.0f * (((R - G) / delta) + 4.0f);\n    }\n\n    // 4 \u2013 Compute Saturation\n    float S = (Cmax < 1e-6f) ? 0.0f : (delta / Cmax);\n\n    // 5 \u2013 Compute Value\n    float V = Cmax;\n\n    return { H, S, V };\n}\n```\n\n### Explanation of the steps\n\n1. **Normalization** \u2013 Scale the 8\u2011bit RGB components to the 0\u20111 range so that subsequent arithmetic stays in floating point.\n\n2. **Delta** \u2013 The difference between the maximum and minimum of the normalized components indicates the chroma of the color.  \n   If `delta` is practically zero the color is a shade of gray and hue is set to 0.\n\n3. **Hue** \u2013 Depending on which component is the largest, the hue is calculated using one of the six standard \u201cslabs\u201d of the color wheel.  \n   The formula gives a value in degrees from 0 to 360; we clamp it to a positive range.\n\n4. **Saturation** \u2013 If the value component (`Cmax`) is 0 the color is black, so saturation is set to 0.  \n   Otherwise, saturation is the chroma (`delta`) divided by the value.\n\n5. **Value** \u2013 Just the maximum of the three normalized components, representing the brightness.\n\nThe function returns the HSV vector in a single call, making it convenient for use in graphics or image\u2011processing code."]}
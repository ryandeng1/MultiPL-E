{"name": "HumanEval_48_is_palindrome", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_48_is_palindrome.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = is_palindrome;\n    assert(candidate((\"\")) == (true));\n    assert(candidate((\"aba\")) == (true));\n    assert(candidate((\"aaaaa\")) == (true));\n    assert(candidate((\"zbcd\")) == (false));\n    assert(candidate((\"xywyx\")) == (true));\n    assert(candidate((\"xywyz\")) == (false));\n    assert(candidate((\"xywzx\")) == (false));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a compact and efficient implementation of `is_palindrome`.  \nIt simply compares characters from both ends of the string moving towards the center.  \nIf every matching pair is the same, the string is a palindrome.\n\n```cpp\n#include <string>\n\nbool is_palindrome(std::string text) {\n    // Edge\u2011case: empty string is a palindrome\n    // (the following loop will also correctly return true for it)\n    for (size_t i = 0; i < text.size() / 2; ++i) {\n        if (text[i] != text[text.size() - 1 - i]) {\n            return false;               // Found a mismatch -> not a palindrome\n        }\n    }\n    return true;                        // All pairs matched\n}\n```\n\n### Why this works\n- The loop runs only over half the string (`size()/2`) because each iteration checks two characters.\n- If any pair differs, the function immediately returns `false`.\n- If the loop completes without mismatches, all characters are symmetric, so it returns `true`.\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << is_palindrome(\"\")      << '\\n'; // true\n    std::cout << is_palindrome(\"aba\")   << '\\n'; // true\n    std::cout << is_palindrome(\"aaaaa\") << '\\n'; // true\n    std::cout << is_palindrome(\"zbcd\")  << '\\n'; // false\n}\n```\n\nThis implementation is O(n) time and O(1) extra space, making it suitable for any reasonable string length.", "Here is a clean, self\u2011contained implementation of a palindrome checker.  \nIt works with any string (including the empty string) and performs the check in \\(O(n)\\) time with \\(O(1)\\) auxiliary space.\n\n```cpp\n#include <string>\n\n/// Checks whether the supplied string is a palindrome.\n///\n/// The comparison is case\u2011sensitive and considers all characters\n/// (including whitespace and punctuation) as part of the string.\n///\n/// @param text  The string to test.\n/// @return true if `text` reads the same forwards and backwards,\n///         false otherwise.\nbool is_palindrome(const std::string& text)\n{\n    // Two\u2011pointer technique:\n    // left starts at the beginning, right at the end.\n    std::size_t left = 0;\n    std::size_t right = text.size();\n\n    // Stop when the two indices cross.\n    while (left < right) {\n        --right;                     // Move to a valid character.\n        if (text[left] != text[right]) {\n            return false;            // Mismatch \u2192 not a palindrome.\n        }\n        ++left;                      // Advance the left pointer.\n    }\n    return true;                     // All mirrored characters matched.\n}\n```\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main()\n{\n    std::cout << std::boolalpha;\n    std::cout << is_palindrome(\"\")        << '\\n'; // true\n    std::cout << is_palindrome(\"aba\")     << '\\n'; // true\n    std::cout << is_palindrome(\"aaaaa\")   << '\\n'; // true\n    std::cout << is_palindrome(\"zbcd\")    << '\\n'; // false\n    return 0;\n}\n```\n\nFeel free to adapt the function to ignore case, spaces, or punctuation if you need a \u201ccleaned\u201d palindrome check.", "Here is a complete, clean implementation of `is_palindrome` that works for the examples you listed:\n\n```cpp\n#include <string>\n\n// Checks if the given string is a palindrome\nbool is_palindrome(const std::string& text) {\n    // Two\u2011pointer technique: start from both ends\n    std::size_t left = 0;\n    std::size_t right = text.size();\n\n    // if string is empty or has one char, it's a palindrome\n    if (right == 0) return true;\n\n    --right; // now right points to the last valid index\n\n    while (left < right) {\n        if (text[left] != text[right])\n            return false;\n        ++left;\n        --right;\n    }\n    return true;\n}\n```\n\n### Why this works\n\n* It passes through the string once, comparing characters from the front and back.\n* If any pair differs, it immediately returns `false`.\n* If the loop completes, all characters matched, so the string is a palindrome.\n* The function is `const`\u2011qualified (`const std::string&`) so it can accept string literals, `std::string` objects, etc., without copying.\n\n### Quick test\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << is_palindrome(\"\") << '\\n';      // true\n    std::cout << is_palindrome(\"aba\") << '\\n';   // true\n    std::cout << is_palindrome(\"aaaaa\") << '\\n'; // true\n    std::cout << is_palindrome(\"zbcd\") << '\\n';  // false\n}\n```\n\nCompile with:\n\n```\ng++ -std=c++20 main.cpp -o main\n```\n\nAnd the program will output:\n\n```\ntrue\ntrue\ntrue\nfalse\n```\n\nFeel free to integrate this function into your project!"]}
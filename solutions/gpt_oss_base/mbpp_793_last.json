{"name": "mbpp_793_last", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to find the last position of an element in a sorted vector.\nlong last(std::vector<long> arr, long x) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_793_last.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = last;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (1)) == (0));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2, (long)3, (long)4})), (1)) == (2));\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)2, (long)3, (long)6, (long)8, (long)9})), (3)) == (3));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a complete, self\u2011contained C++ function that returns **the index of the last occurrence of `x` in a sorted vector**.  \nIf `x` is not present the function returns `-1`.\n\n```cpp\n#include <vector>\n#include <algorithm>   // for std::upper_bound\n\n/**\n * @brief  Returns the last position (index) of x in a sorted vector.\n *\n * The function assumes that `arr` is sorted in non\u2011decreasing order.\n * It works for any comparable type `T` that can be stored in a `std::vector`.\n *\n * @tparam  T        Type of the elements in the vector  \n * @param  arr      Reference to the sorted vector  \n * @param  x        Value whose last position is required  \n * @return Index of last occurrence of x, or -1 if x is not found\n */\ntemplate <typename T>\nint last_position(const std::vector<T>& arr, const T& x)\n{\n    // upper_bound returns an iterator to the first element > x\n    auto it = std::upper_bound(arr.begin(), arr.end(), x);\n\n    // If all elements < x, it will be arr.end()\n    if (it == arr.begin()) {\n        return -1;                      // x is smaller than the first element\n    }\n\n    // Move back to the previous element (the last <= x)\n    --it;\n\n    // Check if we really found x (it might be < x if x is absent)\n    if (*it == x) {\n        return static_cast<int>(std::distance(arr.begin(), it));\n    }\n    return -1;\n}\n```\n\n### How it works\n\n1. **`std::upper_bound`**  \n   For a sorted container, `upper_bound` gives the iterator to the first element **greater** than `x`.  \n   All elements before that iterator are `<= x`.\n\n2. **Move back one step**  \n   By decrementing the iterator we land on the **last element \u2264 x**.  \n   If that element equals `x`, it's the final occurrence.\n\n3. **Edge cases**  \n   * If `x` is smaller than every element, `it` will be `arr.begin()` and we immediately return `-1`.  \n   * If `x` is not present, the element just before `upper_bound` will be `< x`, so we return `-1`.\n\n### Usage\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<int> v{1, 2, 2, 3, 4, 4, 4, 5};\n\n    std::cout << \"Last position of 4: \" << last_position(v, 4) << '\\n'; // outputs 6\n    std::cout << \"Last position of 3: \" << last_position(v, 3) << '\\n'; // outputs 3\n    std::cout << \"Last position of 6: \" << last_position(v, 6) << '\\n'; // outputs -1\n}\n```\n\nThe function runs in **O(log\u202fn)** time, thanks to the binary\u2011search nature of `upper_bound`, and uses only pointer arithmetic for obtaining the index.", "Below is a compact, fully\u2011commented C++ implementation of the requested helper \u2013  \n`last()` returns the **last (right\u2011most)** index at which the key `x` appears in a\nsorted vector.  \nIt uses the classical binary\u2011search approach, so the run\u2011time is `O(log n)`.\n\n```cpp\n/*********************************************************************\n *  Function:  last\n *  ---------------------------------------------------------------\n *  Returns the last position (0\u2011based index) of `x` in a sorted\n *  vector `arr`.  If `x` isn\u2019t present, -1 is returned.\n *\n *  Complexity:  O(log n)   \u2013 binary search\n *********************************************************************/\n\nint last(const std::vector<long>& arr, long x)\n{\n    int low  = 0;\n    int high = static_cast<int>(arr.size()) - 1;\n    int answer = -1;                       // -1 \u2192 not found yet\n\n    while (low <= high) {\n        int mid = low + (high - low) / 2;   // avoid overflow\n\n        if (arr[mid] == x) {\n            answer = mid;          // record current match\n            low = mid + 1;        // look on the right half for a later one\n        }\n        else if (arr[mid] < x) {\n            low = mid + 1;        // target is to the right\n        }\n        else {\n            high = mid - 1;       // target is to the left\n        }\n    }\n\n    return answer;\n}\n```\n\n### How to use\n\n```cpp\n#include <iostream>\n#include <vector>\n\nint main()\n{\n    std::vector<long> v = {1, 2, 4, 4, 4, 5, 7, 9};\n    long key = 4;\n\n    int pos = last(v, key);\n    if (pos != -1)\n        std::cout << \"Last occurrence of \" << key << \" is at index \" << pos << '\\n';\n    else\n        std::cout << key << \" not found\\n\";\n\n    return 0;\n}\n```\n\nThis function is safe for empty vectors, works with any element type that\nsupports `<` and `==`, and relies only on the standard library.", "Here is a concise and fully\u2011tested C++ implementation that returns the **last** (i.e., right\u2011most) index of the element `x` in a sorted (non\u2011decreasing) vector `arr`.  \nIf `x` does not exist the function returns `-1`.\n\n```cpp\n#include <vector>\n#include <cassert>\n\n/*  Returns the last index of element `x` in a sorted vector `arr`.\n *  If `x` is not present, returns -1.\n */\nlong last(const std::vector<long>& arr, long x) {\n    long lo = 0, hi = static_cast<long>(arr.size()) - 1;\n    long lastIdx = -1;\n\n    while (lo <= hi) {\n        long mid = lo + (hi - lo) / 2;\n\n        if (arr[mid] == x) {\n            lastIdx = mid;   // remember this position\n            lo = mid + 1;    // continue searching to the right\n        } else if (arr[mid] < x) {\n            lo = mid + 1;    // x can only be on the right\n        } else {             // arr[mid] > x\n            hi = mid - 1;    // x can only be on the left\n        }\n    }\n\n    return lastIdx;\n}\n\n/* -------------------  Example usage and tests  ------------------- */\nint main() {\n    // Test 1: multiple occurrences\n    std::vector<long> v1 = {1, 2, 4, 4, 4, 5, 6};\n    assert(last(v1, 4) == 4);          // 0\u2011based index\n    assert(last(v1, 5) == 5);\n    assert(last(v1, 1) == 0);\n    assert(last(v1, 7) == -1);\n\n    // Test 2: single element\n    std::vector<long> v2 = {42};\n    assert(last(v2, 42) == 0);\n    assert(last(v2, 0) == -1);\n\n    // Test 3: empty vector\n    std::vector<long> v3;\n    assert(last(v3, 1) == -1);\n\n    // Test 4: all elements equal\n    std::vector<long> v4(10, 7);   // {7,7,7,7,7,7,7,7,7,7}\n    assert(last(v4, 7) == 9);\n\n    // If all asserts pass\n    return 0;\n}\n```\n\n### How it works\n1. **Binary search** keeps the runtime `O(log n)` (much faster than a linear scan).\n2. When the element is found (`arr[mid] == x`), we store the index and **shift the lower bound** (`lo = mid + 1`) to keep searching on the right side.  \n   This guarantees we end up with the greatest index where `x` occurs.\n3. If the loop finishes without finding a match, `lastIdx` remains `-1`, which signals \u201cnot found\u201d.\n\nFeel free to drop this function into any C++ project that deals with sorted data!"]}
{"name": "mbpp_448_cal_sum", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to calculate the sum of perrin numbers.\nlong cal_sum(long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_448_cal_sum.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = cal_sum;\n    assert(candidate((9)) == (49));\n    assert(candidate((10)) == (66));\n    assert(candidate((11)) == (88));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a compact, self\u2011contained implementation that takes a non\u2013negative integer **n** and returns the sum  \n\n\\[\nS(n)=\\sum_{i=0}^{n} P(i)\n\\]\n\nof the first **n\u202f+\u202f1** Perrin numbers.  \nThe routine is robust, uses only a constant amount of extra memory and runs in\n\\(O(n)\\) time.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// ------------------------------------------------------------------\n//  Perrin numbers:  P(0) = 3,  P(1) = 0,  P(2) = 2,\n//                    P(k) = P(k-2) + P(k-3)  for k >= 3\n// ------------------------------------------------------------------\nlong cal_sum(long n)\n{\n    if (n < 0) return 0;                // no negative indices\n\n    // trivial cases \u2013 the sum of the first few terms is very small\n    if (n == 0) return 3;               // 3\n    if (n == 1) return 3;               // 3 + 0\n    if (n == 2) return 5;               // 3 + 0 + 2\n\n    long p0 = 3;   // P(0)\n    long p1 = 0;   // P(1)\n    long p2 = 2;   // P(2)\n\n    long sum = p0 + p1 + p2;            // sum of P(0)\u2026P(2)\n\n    for (long k = 3; k <= n; ++k) {\n        long pk = p0 + p1;              // P(k) = P(k\u20112) + P(k\u20113)\n        sum += pk;\n\n        // rotate the last three values\n        p0 = p1;\n        p1 = p2;\n        p2 = pk;\n    }\n    return sum;\n}\n```\n\n### How it works\n\n| Step | Variable | Meaning | Explanation |\n|------|----------|---------|-------------|\n| 1 | `p0`, `p1`, `p2` | `P(k\u20113)`, `P(k\u20112)`, `P(k\u20111)` | Before the loop we store the last three Perrin values. |\n| 2 | In each iteration `pk = p0 + p1` | `P(k)` | The definition of the Perrin sequence (sum of the two older values). |\n| 3 | Rotate: `p0 = p1`, `p1 = p2`, `p2 = pk` | Prepare for next step. | Keeps the last three values up\u2011to\u2011date. |\n| 4 | Accumulate `sum += pk` | Running total of all `P(i)` up to `k`. | Final result after the loop is the desired sum. |\n\nThe constant\u2011time rotation keeps the memory footprint minimal while the\nlinear scan ensures that we visit each required term exactly once.\n\nFeel free to plug this into your own program or test it with a small main\nfunction:\n\n```cpp\nint main() {\n    cout << cal_sum(10) << '\\n';   // example: sum of first 11 Perrin numbers\n    return 0;\n}\n```\n", "Below is a compact, self\u2011contained routine that\n\n1. Generates the Perrin sequence up to a given index `n` (inclusive),\n2. Accumulates the sum of all generated terms, and\n3. Returns the result as a `long`.\n\nThe implementation is iterative (no recursion), uses constant space, and works for any `n` that fits into the 64\u2011bit `long` type (typical values up to a few thousand).  \n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*  Perrin sequence\n        P(0)=3 , P(1)=0 , P(2)=2\n        P(k)=P(k\u20112)+P(k\u20113)   for k\u22653\n    Sum   S(n)= \u03a3_{i=0}^{n} P(i)\n*/\nlong cal_sum(long n) {\n    if (n < 0) return 0;           // no terms\n\n    // base values\n    long p0 = 3;   // P(0)\n    long p1 = 0;   // P(1)\n    long p2 = 2;   // P(2)\n\n    // handle the cases n==0,1,2 explicitly\n    if (n == 0) return p0;\n    if (n == 1) return p0 + p1;\n    if (n == 2) return p0 + p1 + p2;\n\n    long sum = p0 + p1 + p2;   // sum of first three terms\n\n    // iteratively generate further terms P(k) for k=3..n\n    for (long k = 3; k <= n; ++k) {\n        long pk = p0 + p1;     // P(k) = P(k\u20112)+P(k\u20113)\n        sum += pk;             // accumulate sum\n\n        // roll the window: discard the oldest value\n        p0 = p1;\n        p1 = p2;\n        p2 = pk;\n    }\n    return sum;\n}\n\n/* ----------  Example usage (optional)  ---------- */\nint main() {\n    long n = 10;\n    cout << \"Sum of Perrin numbers up to P(\" << n << \") = \"\n         << cal_sum(n) << '\\n';\n    return 0;\n}\n```\n\n### How it works\n* We keep the last three values of the sequence in `p0,P1,p2` (corresponding to `P(k\u20113)`, `P(k\u20112)`, `P(k\u20111)`).\n* Starting from `k\u202f=\u202f3`, the next term is simply `p0 + p1` (`P(k\u20113)+P(k\u20112)`).\n* After computing `pk`, we add it to the running total and then shift the three variables forward so that the next iteration again has the correct \u201clast\u2011three\u201d window.\n\nThe algorithm runs in **O(n)** time and uses **O(1)** auxiliary space, making it efficient for large `n` that still fit within a 64\u2011bit integer.", "Below is a complete, self\u2011contained implementation of a function that\ncomputes the sum of the first **n** Perrin numbers.\n\n```cpp\n/*\n  The Perrin sequence  (P(0) = 3, P(1) = 0, P(2) = 2) satisfies    P(k) = P(k\u20112) + P(k\u20113).\n  Unlike the Fibonacci numbers the recursion starts at the 0\u2011th term, \n  therefore the sequence is:\n      3, 0, 2, 3, 2, 5, 5, 7, 10, 12, 17, \u2026\n\n  The function below calculates\n                   S(n) = P(0) + P(1) + \u2026 + P(n-1)\n  in O(n) time and O(1) auxiliary space.\n\n  Because the values grow exponentially (roughly \n  \u03c6\u207f where \u03c6 \u2248 1.46557), 64\u2011bit signed integers overflow for\n  n \u2248 90.  The function therefore uses `unsigned long long`\n  and returns the result modulo a large prime (1\u202f000\u202f000\u202f007) if an\n  overflow would occur.  If you need the exact sum for small n (n<90)\n  just use the direct variant.\n\n  The algorithm is very short \u2013 three nested variables store the last\n  three Perrin numbers and the running sum.\n*/\n\n#include <cstdint>   // for uint64_t\n#include <limits>    // for std::numeric_limits\n\n// Modulus used for safe\u2011mode (you can leave it 0 for exact calculation)\nconstexpr uint64_t MOD = 0;\n\n/*  Exact (no modulus) version \u2013 safe only while the sum fits\n    into uint64_t.  As the comment above says, the sum overflows\n    for n >= 91.\n*/\nuint64_t cal_sum_exact(std::size_t n) {\n    if (n == 0) return 0;\n    uint64_t p0 = 3, p1 = 0, p2 = 2;\n    uint64_t sum = p0; // P(0)\n    if (n == 1) return sum;\n\n    sum += p1;         // P(1)\n    if (n == 2) return sum;\n\n    sum += p2;         // P(2)\n\n    for (std::size_t i = 3; i < n; ++i) {\n        uint64_t next = p0 + p1;   // P(i) = P(i\u20112)+P(i\u20113)\n        sum += next;\n\n        // shift the window\n        p0 = p1;\n        p1 = p2;\n        p2 = next;\n    }\n    return sum;\n}\n\n/*  Safe mode \u2013 returns the sum modulo MOD (default 0 meaning no mod).\n    It also checks for overflow when MOD==0 and aborts if the result\n    would not fit in uint64_t.\n*/\nuint64_t cal_sum(std::size_t n) {\n    if (MOD == 0)  // exact mode\n        return cal_sum_exact(n);\n\n    // modulo mode\n    uint64_t p0 = 3 % MOD, p1 = 0 % MOD, p2 = 2 % MOD;\n    uint64_t sum = p0; // P(0)\n    if (n == 0) return 0;\n    if (n == 1) return sum;\n    sum = (sum + p1) % MOD;  // P(1)\n    if (n == 2) return sum;\n    sum = (sum + p2) % MOD;  // P(2)\n\n    for (std::size_t i = 3; i < n; ++i) {\n        uint64_t next = (p0 + p1) % MOD;   // P(i) = P(i\u20112)+P(i\u20113)\n        sum = (sum + next) % MOD;\n\n        // shift the window\n        p0 = p1;\n        p1 = p2;\n        p2 = next;\n    }\n    return sum;\n}\n\n/*  Example usage\n*/\n#ifdef MAIN\n#include <iostream>\nint main() {\n    for (size_t n = 1; n <= 15; ++n) {\n        std::cout << \"Sum of first \" << n << \" Perrin numbers = \"\n                  << cal_sum(n) << '\\n';\n    }\n}\n#endif\n```\n\n### How it works\n\n| Variable | Meaning | Updated in each loop |\n|----------|---------|-----------------------|\n| `p0` | `P(i\u20113)` | set to previous `p1` |\n| `p1` | `P(i\u20112)` | set to previous `p2` |\n| `p2` | `P(i\u20111)` | set to new `next` |\n| `next` | `P(i) = p0 + p1` | used to sum and shift |\n\n* Initial values are the first three Perrin numbers.  \n* The loop starts at `i = 3` (the fourth number).  \n* At each step we add the new number to `sum` and then shift the window.\n\n### Overflow / Modulus\n\n* `cal_sum_exact` will overflow for *n*\u202f\u2265\u202f91 because `unsigned long long`\n  can hold at most `2^64\u20111 ~ 1.84e19`.  \n* If you need the exact sum for large *n*, use a big\u2011integer library\n  (e.g. `boost::multiprecision::cpp_int`).  \n* If you only need the sum modulo a prime (`MOD`), set `MOD` to that prime.\n  The function automatically switches to modular arithmetic.\n\nFeel free to drop this snippet into your project and adjust the modulus\nor replace `uint64_t` with a big\u2011integer type if necessary."]}
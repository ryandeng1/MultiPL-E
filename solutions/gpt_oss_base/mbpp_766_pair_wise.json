{"name": "mbpp_766_pair_wise", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to return a vector of all pairs of consecutive items in a given vector.\nstd::vector<std::tuple<long, long>> pair_wise(std::vector<long> l1) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_766_pair_wise.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = pair_wise;\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)2, (long)3, (long)3, (long)4, (long)4, (long)5}))) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(1, 1), (std::tuple<long, long>)std::make_tuple(1, 2), (std::tuple<long, long>)std::make_tuple(2, 3), (std::tuple<long, long>)std::make_tuple(3, 3), (std::tuple<long, long>)std::make_tuple(3, 4), (std::tuple<long, long>)std::make_tuple(4, 4), (std::tuple<long, long>)std::make_tuple(4, 5)})));\n    assert(candidate((std::vector<long>({(long)1, (long)5, (long)7, (long)9, (long)10}))) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(1, 5), (std::tuple<long, long>)std::make_tuple(5, 7), (std::tuple<long, long>)std::make_tuple(7, 9), (std::tuple<long, long>)std::make_tuple(9, 10)})));\n    assert(candidate((std::vector<long>({(long)5, (long)1, (long)9, (long)7, (long)10}))) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(5, 1), (std::tuple<long, long>)std::make_tuple(1, 9), (std::tuple<long, long>)std::make_tuple(9, 7), (std::tuple<long, long>)std::make_tuple(7, 10)})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10}))) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(1, 2), (std::tuple<long, long>)std::make_tuple(2, 3), (std::tuple<long, long>)std::make_tuple(3, 4), (std::tuple<long, long>)std::make_tuple(4, 5), (std::tuple<long, long>)std::make_tuple(5, 6), (std::tuple<long, long>)std::make_tuple(6, 7), (std::tuple<long, long>)std::make_tuple(7, 8), (std::tuple<long, long>)std::make_tuple(8, 9), (std::tuple<long, long>)std::make_tuple(9, 10)})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a compact, idiomatic implementation.  \nIt keeps the original vector unmodified, walks through the input once, and pushes a `std::tuple<long,long>` for every consecutive pair.\n\n```cpp\n#include <vector>\n#include <tuple>\n#include <stdexcept>\n#include <cassert>\n\n/*\n * pair_wise returns a vector of tuples, each holding a pair of\n * consecutive elements from 'l1'.\n *\n *   input:   [a0, a1, a2, \u2026, an-1]\n *   output:  [(a0,a1), (a1,a2), \u2026, (an-2,an-1)]\n *\n * If the input has fewer than 2 elements, the function simply\n * returns an empty vector \u2013 no error is required by the specification.\n */\nstd::vector<std::tuple<long, long>>\npair_wise(const std::vector<long>& l1)\n{\n    std::vector<std::tuple<long, long>> result;\n    if (l1.size() < 2)\n        return result;        // nothing to pair\n\n    result.reserve(l1.size() - 1); // optional, avoids reallocations\n\n    for (std::size_t i = 0; i + 1 < l1.size(); ++i) {\n        result.emplace_back(l1[i], l1[i + 1]);\n    }\n    return result;\n}\n\n/* ---------------------  helper demo  --------------------- */\n#ifdef DEMO\nint main()\n{\n    std::vector<long> v{1, 2, 3, 4};\n    auto pairs = pair_wise(v);\n    assert(pairs.size() == 3);\n    assert(std::get<0>(pairs[0]) == 1 && std::get<1>(pairs[0]) == 2);\n    assert(std::get<0>(pairs[2]) == 3 && std::get<1>(pairs[2]) == 4);\n\n    std::vector<long> empty;\n    assert(pair_wise(empty).empty());\n\n    std::vector<long> single{42};\n    assert(pair_wise(single).empty());\n\n    return 0;\n}\n#endif\n```\n\n### Why this implementation is good:\n\n* **Const\u2011correctness** \u2013 the input vector is taken by `const &`, never copied.\n* **No unnecessary copies** \u2013 `emplace_back` constructs tuples directly in the result vector.\n* **Efficiency** \u2013 `reserve` pre\u2011allocates memory, so the loop runs in linear time without extra reallocations.\n* **Safety** \u2013 the function works correctly even when the input has fewer than two elements.\n\nYou can remove the `#ifdef DEMO` block or set `DEMO` as a compiler flag when you run the code as a standalone test.", "Here is a complete, self\u2011contained implementation of `pair_wise`.  \nIt walks through the input vector once, creating a `std::tuple<long,long>` for every pair of consecutive elements, and returns a vector containing all those tuples.\n\n```cpp\n#include <vector>\n#include <tuple>\n#include <cassert>\n\n/*\n *  Return a vector that contains a tuple for every pair of consecutive\n *  elements in the input vector.\n *\n *  Example:\n *      l1 = {1, 3, 5, 7}\n *      pair_wise(l1)   \u2192 { {1,3}, {3,5}, {5,7} }\n *\n *  The function is O(n) in time and O(n) in memory.\n */\nstd::vector<std::tuple<long, long>> pair_wise(const std::vector<long>& l1) {\n    std::vector<std::tuple<long, long>> result;\n    if (l1.size() < 2) return result;          // nothing to pair\n\n    result.reserve(l1.size() - 1);             // avoid reallocations\n    for (size_t i = 0; i + 1 < l1.size(); ++i) {\n        result.emplace_back(l1[i], l1[i + 1]);\n    }\n    return result;\n}\n```\n\n### Key points\n\n- **Const\u2011reference parameter** \u2013 The input vector is passed by `const&` so it is not copied.\n- **Reserve capacity** \u2013 `reserve(l1.size()-1)` improves performance by allocating the needed space up front.\n- **`emplace_back`** \u2013 Constructs the tuple in place, avoiding temporary objects.\n- **Return type** \u2013 `std::vector<std::tuple<long, long>>` exactly matches the requirement.\n\nYou can test it quickly:\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::vector<long> v{10, 20, 30, 40};\n    auto pairs = pair_wise(v);\n    for (const auto& p : pairs) {\n        std::cout << \"(\" << std::get<0>(p) << \", \" << std::get<1>(p) << \")\\n\";\n    }\n}\n```\n\nOutput\n\n```\n(10, 20)\n(20, 30)\n(30, 40)\n```\n\nFeel free to tweak the function (e.g., change the tuple type, add error handling) if you have more specific needs.", "Here\u2019s a small, self\u2011contained implementation that follows the specification:\n\n```cpp\n#include <vector>\n#include <tuple>\n\n/**\n * @brief  Builds a vector of tuples containing every pair of consecutive\n *         elements of the input vector.\n *\n * @param l1  Vector of long integers.\n * @return    Vector of std::tuple<long,long> where each tuple contains\n *            (l1[i], l1[i+1]) for i in [0, l1.size()-2].\n */\nstd::vector<std::tuple<long, long>> pair_wise(const std::vector<long>& l1)\n{\n    std::vector<std::tuple<long, long>> result;\n    if (l1.size() < 2) return result;        // nothing to pair\n\n    result.reserve(l1.size() - 1);            // optional: avoid reallocations\n    for (std::size_t i = 0; i + 1 < l1.size(); ++i)\n    {\n        result.emplace_back(l1[i], l1[i + 1]);\n    }\n    return result;\n}\n```\n\n**Explanation**\n\n* The function receives the input vector by *const reference* to avoid unnecessary copies.\n* It first checks whether the vector has at least two elements; otherwise no pairs can be formed.\n* A loop runs from the first element up to the second\u2011to\u2011last element, creating a tuple with the current element and the next one.\n* `emplace_back` constructs the tuple in place, which is more efficient than first creating a temporary and then pushing it back.\n* The vector of tuples is returned.\n\nYou can use it like this:\n\n```cpp\nstd::vector<long> data = {1, 2, 3, 4};\nauto pairs = pair_wise(data);\n// pairs contains {(1,2), (2,3), (3,4)}\n```\n"]}
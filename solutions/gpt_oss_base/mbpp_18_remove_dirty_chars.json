{"name": "mbpp_18_remove_dirty_chars", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to remove characters from the first string which are present in the second string.\nstd::string remove_dirty_chars(std::string string, std::string second_string) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_18_remove_dirty_chars.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = remove_dirty_chars;\n    assert(candidate((\"probasscurve\"), (\"pros\")) == (\"bacuve\"));\n    assert(candidate((\"digitalindia\"), (\"talent\")) == (\"digiidi\"));\n    assert(candidate((\"exoticmiles\"), (\"toxic\")) == (\"emles\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a concise, self\u2011contained implementation that follows the requirement:\n\n```cpp\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\n// Remove from `first` every character that appears in `second`.\nstd::string remove_dirty_chars(const std::string& first,\n                               const std::string& second)\n{\n    // Build a hash\u2011set of characters that must be removed.\n    std::unordered_set<char> dirty(second.begin(), second.end());\n\n    // Build the result in\u2011place (works with the original string,\n    // but the caller usually passes a modifiable copy).\n    std::string result;\n    result.reserve(first.size());          // no reallocations\n\n    for (char ch : first)\n    {\n        if (dirty.find(ch) == dirty.end())  // not dirty \u2192 keep it\n            result.push_back(ch);\n    }\n    return result;\n}\n```\n\n### How it works\n1. **Hash set creation** \u2013 All characters of `second` are inserted into an `unordered_set<char>`.  \n   This gives *O(1)* average\u2011time checks for whether a character is \u201cdirty\u201d.\n\n2. **Collect result** \u2013 Iterate through each character of `first`.  \n   If it\u2019s *not* in the set, append it to `result`.\n\n3. **Return** \u2013 The new string contains only the allowed characters.\n\n### Example\n\n```cpp\nint main() {\n    std::string a = \"Hello, World!\";\n    std::string b = \"eo \";\n    std::string clean = remove_dirty_chars(a, b);\n    std::cout << clean << '\\n';   // Prints: Hll,Wrl!\n}\n```\n\nThe function is `const`\u2011correct, uses only standard library facilities, and runs in linear time with respect to the length of `first`.", "Here is a concise, efficient implementation of `remove_dirty_chars`.  \nIt builds a lookup table (`std::unordered_set`) from the second string, then iterates over the first string and copies every character that is **not** found in that set to a result string.\n\n```cpp\n#include <string>\n#include <unordered_set>\n\n/// Remove every character from `first` that appears in `second`.\n/// The relative order of the remaining characters is preserved.\n///\n/// Example:\n///     remove_dirty_chars(\"hello world\", \"aeiou\") == \"hll wrld\"\n///\nstd::string remove_dirty_chars(const std::string& first,\n                               const std::string& second) {\n    // Build a quick lookup for characters that must be removed.\n    std::unordered_set<char> forbidden(second.begin(), second.end());\n\n    std::string result;\n    result.reserve(first.size());   // avoid re\u2011allocations\n\n    for (char c : first) {\n        if (forbidden.find(c) == forbidden.end()) {\n            result.push_back(c);\n        }\n    }\n\n    return result;\n}\n```\n\n### Why this version?\n\n| Criterion | Why it\u2019s good |\n|-----------|---------------|\n| **Correctness** | Characters common to both strings are discarded, all others kept. |\n| **Order preservation** | We iterate in original order and push characters to `result`. |\n| **Time complexity** | `O(n + m)` where `n` and `m` are the lengths of `first` and `second`. |\n| **Memory usage** | Only the lookup set and the output; each of size at most `O(m)` and `O(n)` respectively. |\n| **Safety** | Takes arguments by const reference to avoid unnecessary copies. |\n\nFeel free to integrate this function into your codebase\u2014its behaviour matches the specification \u201cremove characters from the first string which are present in the second string.\u201d", "```cpp\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\n/**\n * @brief Removes every character of *first* that also appears in *second*.\n *\n * @param first  The string from which characters will be removed.\n * @param second The string whose characters must be stripped from *first*.\n *\n * @return A new string containing only the characters that were not present\n *         in *second*.\n *\n * @note The function is case\u2011sensitive \u2013 \u201ca\u201d and \u201cA\u201d are considered different\n *       characters.\n */\nstd::string remove_dirty_chars(const std::string& first, const std::string& second)\n{\n    // Build a hash set of all characters that must be removed.\n    std::unordered_set<char> remove_set;\n    for (char c : second) {\n        remove_set.insert(c);\n    }\n\n    // Build the result by keeping only characters that are NOT in remove_set.\n    std::string result;\n    result.reserve(first.size());          // avoid re\u2011allocations\n    for (char c : first) {\n        if (remove_set.find(c) == remove_set.end()) {\n            result.push_back(c);\n        }\n    }\n    return result;\n}\n```\n\n### How it works\n1. **Hash set** \u2013 All characters from `second` are inserted into an `unordered_set`.  \n   This gives O(1) average\u2011time look\u2011up for each character that needs to be removed.\n\n2. **Filtering** \u2013 Iterate over `first`.  \n   If a character is **not** found in the set, append it to the result string.\n\n3. **Return value** \u2013 The resulting string contains only those characters from\n   `first` that were not present in `second`.\n\n---\n\n#### Example\n\n```cpp\nint main()\n{\n    std::string a = \"Hello, World!\";\n    std::string b = \"lo\";\n    std::string cleaned = remove_dirty_chars(a, b);\n    // cleaned == \"He, Wrd!\"\n}\n```\n\nThis code will compile with a standard\u2011conforming compiler and does not\ndepend on any non\u2011standard headers (e.g., `<bits/stdc++.h>` was removed)."]}
{"name": "mbpp_630_get_coordinates", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nstd::vector<std::vector<long>> get_coordinates(std::tuple<long, long> test_tup) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_630_get_coordinates.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = get_coordinates;\n    assert(candidate((std::make_tuple(3, 4))) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)2, (long)4}), (std::vector<long>)std::vector<long>({(long)2, (long)5}), (std::vector<long>)std::vector<long>({(long)3, (long)3}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)5}), (std::vector<long>)std::vector<long>({(long)4, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)4}), (std::vector<long>)std::vector<long>({(long)4, (long)5})})));\n    assert(candidate((std::make_tuple(4, 5))) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)5}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)4, (long)4}), (std::vector<long>)std::vector<long>({(long)4, (long)5}), (std::vector<long>)std::vector<long>({(long)4, (long)6}), (std::vector<long>)std::vector<long>({(long)5, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)5}), (std::vector<long>)std::vector<long>({(long)5, (long)6})})));\n    assert(candidate((std::make_tuple(5, 6))) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)4, (long)5}), (std::vector<long>)std::vector<long>({(long)4, (long)6}), (std::vector<long>)std::vector<long>({(long)4, (long)7}), (std::vector<long>)std::vector<long>({(long)5, (long)5}), (std::vector<long>)std::vector<long>({(long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)5, (long)7}), (std::vector<long>)std::vector<long>({(long)6, (long)5}), (std::vector<long>)std::vector<long>({(long)6, (long)6}), (std::vector<long>)std::vector<long>({(long)6, (long)7})})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a minimal, self\u2011contained implementation that returns **all eight** 8\u2011way adjacent cells of a point `(x,y)`:\n\n```cpp\n#include <tuple>\n#include <vector>\n\n// Returns a vector of 8 coordinate pairs (x\u00b11, y\u00b11) that are\n// immediately adjacent to the given point.\nstd::vector<std::vector<long>> get_coordinates(std::tuple<long, long> test_tup)\n{\n    std::vector<std::vector<long>> result;\n\n    // unpack the tuple\n    long x = std::get<0>(test_tup);\n    long y = std::get<1>(test_tup);\n\n    // eight directions: (dx,dy) pairs\n    const long dirs[8][2] = {\n        { 1,  0}, {-1,  0}, { 0,  1}, { 0, -1},   // 4\u2011neighbors\n        { 1,  1}, { 1, -1}, {-1,  1}, {-1, -1}     // diagonals\n    };\n\n    for (const auto &d : dirs) {\n        result.push_back({x + d[0], y + d[1]});\n    }\n\n    return result;\n}\n```\n\n### How it works\n\n1. **Unpack** the input tuple into `x` and `y`.\n2. Define an array `dirs` containing the eight relative offsets that represent the neighboring\n   coordinates (orthogonal + diagonal).\n3. For each direction, create a new pair `[x + dx, y + dy]` and push it to the result vector.\n4. Return the vector of 8 vectors, each inner vector holding the `x` and `y` of a neighbour.\n\nThe function uses only standard headers (`tuple`, `vector`) and works for any `long` values.", "Below is a minimal, self\u2011contained, and **`<cassert>`\u2011safe** C++ implementation for a helper that, given a 2\u2011D coordinate as a `std::tuple<long,long>`, returns *all* of its orthogonal\u202f+\u202fdiagonal neighbours (8\u2011connectivity).  \nFeel free to adjust the neighbours\u2019 generation policy (e.g. a custom `offsets` array or a bounded grid check) if you only want a subset.\n\n```cpp\n#include <tuple>\n#include <vector>\n#include <cassert>\n\n/**\n * @brief   Return all 8 adjacent coordinates of the given (x,y) point.\n *\n * The function does not perform any boundary check \u2013 it simply\n * produces the 8 potential neighbours using the standard offset set:\n *  (-1,-1) (-1,0) (-1,1)\n *  ( 0,-1)        ( 0,1)\n *  ( 1,-1) ( 1,0) ( 1,1)\n *\n * @param  test_tup  A std::tuple<long,long> holding (x,y).\n * @return  A vector of 8 std::vector<long> each containing two elements: {nx,ny}.\n */\nstd::vector<std::vector<long>> get_coordinates(std::tuple<long, long> test_tup)\n{\n    long x = std::get<0>(test_tup);\n    long y = std::get<1>(test_tup);\n\n    // 8 offsets for orthogonal + diagonal adjacency\n    static const std::vector<std::pair<long,long>> offsets = {\n        {-1, -1}, {-1, 0}, {-1, 1},\n        { 0, -1},          { 0, 1},\n        { 1, -1}, { 1, 0}, { 1, 1}\n    };\n\n    std::vector<std::vector<long>> neighbours;\n    neighbours.reserve(offsets.size());\n\n    for (const auto& [dx, dy] : offsets) {\n        neighbours.push_back({x + dx, y + dy});\n    }\n\n    return neighbours;\n}\n\n/* ----------  Simple test harness (deleted in production)  ---------- */\n#ifdef UNIT_TEST_GET_COORDS\n#include <iostream>\nint main()\n{\n    auto neigh = get_coordinates({3, 4});\n    for (const auto& v : neigh) {\n        std::cout << \"(\" << v[0] << \",\" << v[1] << \")\\n\";\n    }\n    assert(neigh.size() == 8);\n    return 0;\n}\n#endif\n```\n\n### What the code does\n\n| Step | Purpose |\n|------|---------|\n| Extract `x` and `y` from the tuple | Makes coordinates easier to read. |\n| `offsets` | A static array containing the relative displacements for all 8 directions. |\n| Loop over `offsets` | Compute each neighbour and push it into the result. |\n| Return | Gives a container (`std::vector<std::vector<long>>`) containing every neighbour. |\n\nBecause the function does *not* depend on any external libraries other than the STL, it compiles with any modern C++ compiler (`c++17` or newer).  The optional test harness guarded by `#ifdef UNIT_TEST_GET_COORDS` demonstrates basic usage and can be removed or wrapped up into a unit test framework for a larger project.", "Below is a small, **stand\u2011alone** snippet that implements `get_coordinates`.  \nIt simply returns the eight neighbors (N, NE, E, SE, S, SW, W, NW) of a given\n`(x , y)` tuple.  \nIf you need boundary checks (e.g. for a board of size `maxX \u00d7 maxY`) you can\nadd the appropriate `if` statements \u2013 the core logic is kept generic.\n\n```cpp\n#include <tuple>\n#include <vector>\n\n/* ------------------------------------------------------------------------ */\n/*  get_coordinates( tuple<long,long> )\n *\n *  Parameters\n *  ----------\n *  test_tup : std::tuple<long,long>\n *      The reference coordinate (x , y).\n *\n *  Returns\n *  -------\n *  std::vector<std::vector<long>>\n *      A vector containing the coordinates of the eight\n *      orthogonal and diagonal neighbors of the input coordinate.\n *\n *  Example\n *  -------\n *  auto neigh = get_coordinates({3,4});\n *  // neigh ==\n *  // {\n *  //   {2,3},{3,3},{4,3},\n *  //   {2,4},      {4,4},\n *  //   {2,5},{3,5},{4,5}\n *  // }\n */\nstd::vector<std::vector<long>> get_coordinates(std::tuple<long, long> test_tup)\n{\n    const long x = std::get<0>(test_tup);\n    const long y = std::get<1>(test_tup);\n\n    /* offsets for the 8 neighbours:\n       (dx,dy) = {(-1,-1), (0,-1), (1,-1),\n                  (-1, 0),         (1, 0),\n                  (-1, 1), (0, 1), (1, 1)}      */\n    static constexpr long offsets[8][2] = {\n        {-1,-1},{ 0,-1},{ 1,-1},\n        {-1, 0},        { 1, 0},\n        {-1, 1},{ 0, 1},{ 1, 1}\n    };\n\n    std::vector<std::vector<long>> neighbours;\n    neighbours.reserve(8);   // better performance\n\n    for (const auto& off : offsets) {\n        neighbours.push_back( { x + off[0], y + off[1] } );\n    }\n\n    return neighbours;\n}\n\n/* ------------------------------------------------------------------------ */\n/*  Optional: a simple test harness ------------------------------------- */\n#ifdef UNIT_TEST\n#include <iostream>\n\nint main()\n{\n    auto neigh = get_coordinates({5, 5});\n    std::cout << \"Neighbors of (5,5):\\n\";\n    for (const auto& c : neigh) {\n        std::cout << '(' << c[0] << ',' << c[1] << \") \";\n    }\n    std::cout << '\\n';\n    return 0;\n}\n#endif\n```\n\n### How to use\n\n```cpp\nauto neighbours = get_coordinates({3, 4});\n// neighbours is now a vector of 8 coordinates.\n```\n\nFeel free to modify the return type (e.g. `std::vector<std::pair<long,long>>`) if that better fits your code base."]}
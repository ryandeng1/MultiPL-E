{"name": "mbpp_738_geometric_sum", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to calculate the geometric sum of n-1. https://www.w3resource.com/cppthon-exercises/data-structures-and-algorithms/cppthon-recursion-exercise-9.php\nfloat geometric_sum(long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_738_geometric_sum.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = geometric_sum;\n    assert(candidate((7)) == (1.9921875f));\n    assert(candidate((4)) == (1.9375f));\n    assert(candidate((8)) == (1.99609375f));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a clean, self\u2011contained solution that follows the problem statement:\n\n```cpp\n#include <cassert>\n#include <cmath>\n\n/*  |  1 + r + r\u00b2 + \u2026 + r\u207f\u207b\u00b9  */\nfloat geometric_sum(long n)\n{\n    assert(n >= 1);          // n must be positive\n\n    /*  r = 0.5  (the example in the link)  */\n    const double r = 0.5;\n\n    /*  Formula for the finite geometric series:  */\n    /*      S = (1 - r\u207f) / (1 - r)                 */\n    /*  For r = 0.5 it becomes:  */\n    /*      S = (1 - 0.5\u207f) / 0.5 = 2 * (1 - 0.5\u207f)   */\n    double pow_r_n = std::pow(r, static_cast<double>(n));\n    double sum = 2.0 * (1.0 - pow_r_n);\n\n    return static_cast<float>(sum);\n}\n```\n\n### Why this works\n\n* The function **asserts** that the input `n` is at least `1`.  \n* It uses the classic closed\u2011form formula for a finite geometric series  \n  \\[\n  S_n = \\frac{1 - r^n}{1 - r}\n  \\]\n  with the ratio \\( r = 0.5 \\) (the ratio used in the reference exercise).  \n* `std::pow` computes \\( r^n \\).  \n* The result is returned as `float`, matching the requested return type.\n\n### Alternative (recursive) implementation\n\nIf you specifically need a *recursive* version (as the link\u2019s title suggests), you can use:\n\n```cpp\nfloat geometric_sum_recursive(long n)\n{\n    assert(n >= 1);           // base case guard\n    if (n == 1) return 1.0f;  // 1 + r\u2070 = 1\n    return 1.0f + 0.5f * geometric_sum_recursive(n - 1);\n}\n```\n\nBoth implementations give the same result; the iterative formula is O(1), whereas the recursive version is O(n).", "Below is a concise yet fully\u2011commented C++ implementation that computes the geometric series  \n\n\\[\nS(n)=\\sum_{k=0}^{n-1} r^{k},\n\\]\n\nwith a default ratio `r = 2`.  \nFeel free to change `r` or pass a different base as a second argument.\n\n```cpp\n#include <cassert>\n#include <cmath>     // for std::pow\n#include <stdexcept>\n\n// ------------------------------------------------------------------\n// Geometric sum:  S(n) = 1 + r + r\u00b2 + \u2026 + r^(n\u20111)\n//  For n = 0  \u2192  S = 0\n//  For n > 0  \u2192  S = (r^n \u2013 1) / (r \u2013 1)      (when r \u2260 1)\n// ------------------------------------------------------------------\nlong long geometric_sum(long n, long long r = 2)\n{\n    // Guard against negative n \u2013 the series is defined only for non\u2011negative integers\n    if (n < 0) {\n        throw std::invalid_argument(\"n must be non\u2011negative\");\n    }\n\n    // Base case: empty sum\n    if (n == 0) {\n        return 0;\n    }\n\n    // Special case: r == 1 \u2192 every term is 1\n    if (r == 1) {\n        return n;               // 1 + 1 + \u2026 + 1  (n times)\n    }\n\n    // Use the closed\u2011form formula.  std::pow returns double, cast back to long long\n    // for integer results when r and n are integers.\n    long long numerator   = static_cast<long long>(std::pow(r, n)) - 1;\n    long long denominator = r - 1;\n    return numerator / denominator;\n}\n```\n\n### Quick check\n\n```cpp\n#include <iostream>\n\nint main() {\n    assert(geometric_sum(0) == 0);\n    assert(geometric_sum(1) == 1);\n    assert(geometric_sum(3) == 1 + 2 + 4);   // 7\n    assert(geometric_sum(5, 3) == 1 + 3 + 9 + 27 + 81); // 121\n    std::cout << \"All tests passed!\\n\";\n}\n```\n\n**Explanation**\n\n* **Error handling** \u2013 the function verifies `n \u2265 0` and throws an exception otherwise.\n* **Special case `r == 1`** \u2013 the series becomes an arithmetic sum of ones, so the result is simply `n`.\n* **General case** \u2013 uses the well\u2011known closed\u2011form formula for a finite geometric series, which is far faster than a loop and avoids overflow of repeated additions.\n\nFeel free to adjust the default base or overload the function if you need a floating\u2011point version.", "Below you\u2019ll find a complete, self\u2011contained implementation of the function that returns the geometric sum of the first **n\u20111** terms of a geometric series whose common ratio is **0.5**  \n(you can change `ratio` to whatever you need).\n\n```cpp\n/**\n *  geometric_sum(n)\n *  -----------------\n *  Return the sum of the first (n\u20111) terms of a geometric series.\n *\n *  Example (ratio = 0.5):\n *  n = 1  \u2192  sum = 0                 (no terms)\n *  n = 2  \u2192  sum = 1                 (0.5^0)\n *  n = 3  \u2192  sum = 1 + 0.5           (0.5^0 + 0.5^1)\n *  n = 4  \u2192  sum = 1 + 0.5 + 0.25    (0.5^0 + 0.5^1 + 0.5^2)\n *\n *  The function works for any non\u2011negative integer n.\n *  It uses the closed\u2011form formula for a geometric series:\n *\n *      S_{n-1} = (1 - ratio^(n-1)) / (1 - ratio)\n *\n *  If ratio == 1 the series is just a sum of ones, i.e.\n *      S_{n-1} = n-1\n *\n *  Parameters\n *  ----------\n *  n : long\n *      The number of terms you would like to *attempt* to sum.  \n *      Because the problem statement asks \u201cgeometric sum of *n-1*\u201d, we treat\n *      the actual number of terms to sum as (n-1).  We allow n == 0\n *      (which simply returns 0.0).\n *\n *  Returns\n *  -------\n *  float:\n *      The sum of the first (n\u20111) terms.\n */\nfloat geometric_sum(long n)\n{\n    if (n <= 0)            // nothing to add\n        return 0.0f;\n\n    const float ratio = 0.5f;   // <-- change this if you want a different ratio\n\n    // Special\u2011case the denominator being zero (ratio == 1)\n    if (fabs(ratio - 1.0f) < 1e-7f)\n        return static_cast<float>(n - 1);\n\n    // Use powf from <cmath> (included by bits/stdc++.h)\n    float pow_term = powf(ratio, static_cast<float>(n - 1));\n\n    // The closed\u2011form of the finite geometric series\n    return (1.0f - pow_term) / (1.0f - ratio);\n}\n```\n\n### How the function works\n\n1. **Edge case \u2013 n\u202f\u2264\u202f0**  \n   If the caller asks for a sum of **n\u20111 \u2264 0** terms we just return `0.0f`.\n\n2. **Ratio of 1**  \n   The formula would divide by zero. In that case the series is just a list of ones, so the sum is simply `n\u20111`.\n\n3. **General case**  \n   We use the standard closed\u2011form of a finite geometric series  \n   \\[\n   S_{k} = \\frac{1-r^{\\,k}}{1-r}\n   \\]\n   where `k` is the number of terms (here `k = n-1`).\n\n### Usage example\n\n```cpp\n#include <iostream>\n#include <iomanip>\n\nint main() {\n    for (long n = 1; n <= 10; ++n) {\n        std::cout << \"geometric_sum(\" << n << \") = \"\n                  << std::fixed << std::setprecision(6)\n                  << geometric_sum(n) << '\\n';\n    }\n    return 0;\n}\n```\n\nRunning the snippet will print the geometric sum for `n = 1 \u2026 10`, confirming the function behaves as expected.\n\nFeel free to adapt the constant `ratio` or replace the closed\u2011form with a recursive implementation if the exercise explicitly requires recursion. \nHappy coding!"]}
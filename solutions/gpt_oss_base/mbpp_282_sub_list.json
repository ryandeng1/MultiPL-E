{"name": "mbpp_282_sub_list", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to subtract two vectors element-wise.\nstd::vector<long> sub_list(std::vector<long> nums1, std::vector<long> nums2) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_282_sub_list.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = sub_list;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (std::vector<long>({(long)4, (long)5, (long)6}))) == (std::vector<long>({(long)-3, (long)-3, (long)-3})));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (std::vector<long>({(long)3, (long)4}))) == (std::vector<long>({(long)-2, (long)-2})));\n    assert(candidate((std::vector<long>({(long)90, (long)120})), (std::vector<long>({(long)50, (long)70}))) == (std::vector<long>({(long)40, (long)50})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a concise, self\u2011contained implementation that subtracts two vectors element\u2011wise:\n\n```cpp\n#include <vector>\n#include <cassert>\n\n/*  sub_list\n *\n *  Subtracts two vectors of the same length element\u2011by\u2011element.\n *\n *  Parameters\n *     nums1: first vector\n *     nums2: second vector (must be the same size as `nums1`)\n *\n *  Returns\n *     A new std::vector<long> where each element is\n *        result[i] = nums1[i] - nums2[i]\n *\n *  Precondition\n *     nums1.size() == nums2.size()\n *\n *  Complexity\n *     O(n) time, O(n) additional space\n */\nstd::vector<long> sub_list(const std::vector<long>& nums1,\n                           const std::vector<long>& nums2)\n{\n    // It's safer to check that the sizes agree.\n    // If they differ we trigger a program\u2011abort with a clear message.\n    assert(nums1.size() == nums2.size());\n\n    std::vector<long> result;\n    result.reserve(nums1.size());               // avoid repeated reallocations\n\n    for (std::size_t i = 0; i < nums1.size(); ++i) {\n        result.push_back(nums1[i] - nums2[i]);\n    }\n    return result;\n}\n```\n\n### Why this version?\n\n* **Const references** \u2013 The input vectors are passed as const references to avoid unnecessary copies.\n* **Assertion** \u2013 We guard against mismatched lengths; in production you might replace it with error handling or throw an exception.\n* **Reserve** \u2013 `reserve` keeps the allocation to a single pass, improving performance for large vectors.\n* **Straightforward loop** \u2013 No fancy STL tricks; the logic stays clear and easy to read.\n\nYou can drop this function into your code base wherever you need element\u2011wise subtraction.", "Here\u2019s a minimal, self\u2011contained implementation that does what you described:\n\n```cpp\n#include <cassert>\n#include <vector>\n\n/**\n * Element\u2011wise subtraction of two equal\u2011length vectors.\n *\n * @param nums1 The minuend vector.\n * @param nums2 The subtrahend vector.\n * @return  A vector containing the difference of corresponding elements.\n *\n * @throws std::invalid_argument if the two vectors are not the same length.\n */\nstd::vector<long> sub_list(std::vector<long> nums1,\n                          std::vector<long> nums2)\n{\n    // Ensure both vectors have the same length \u2013 this is the simplest safety\n    // net.  You could silently truncate/pad them instead, but a mismatch\n    // almost always indicates a logic bug.\n    if (nums1.size() != nums2.size()) {\n        throw std::invalid_argument(\"Vectors must be the same length\");\n    }\n\n    std::vector<long> result;\n    result.reserve(nums1.size());          // pre\u2011allocate for speed\n\n    for (std::size_t i = 0; i < nums1.size(); ++i) {\n        result.push_back(nums1[i] - nums2[i]);  // element\u2011wise difference\n    }\n    return result;\n}\n```\n\n### How to use it\n\n```cpp\nint main()\n{\n    std::vector<long> a{10, 20, 30};\n    std::vector<long> b{1, 5, 7};\n\n    auto diff = sub_list(a, b);\n\n    for (auto v : diff)\n        std::cout << v << ' ';   // prints: 9 15 23\n\n    return 0;\n}\n```\n\n- The function checks that the vectors have the same size and throws an exception if they don\u2019t.\n- It reserves the result vector\u2019s capacity in advance to avoid repeated reallocations.\n- The implementation is fully compliant with C++17/20/23 (no GCC/Clang\u2011specific extensions are needed).", "Below is a compact, self\u2011contained implementation that\n\n* takes the two `std::vector<long>` arguments,\n* verifies that they are of the same length (the classic way is to `assert` on that condition \u2013 in production code you might throw an exception instead),\n* subtracts element\u2011wise (first minus second),\n* returns a new vector with the results.\n\n```cpp\n#include <vector>\n#include <cassert>\n\n// Subtract two vectors element\u2011wise:  result[i] = nums1[i] - nums2[i]\nstd::vector<long> sub_list(const std::vector<long>& nums1,\n                          const std::vector<long>& nums2)\n{\n    // Sanity check: both vectors must have the same size.\n    // If you prefer runtime error handling, replace this with an\n    // explicit throw or return an empty vector.\n    assert(nums1.size() == nums2.size());\n\n    std::vector<long> result;\n    result.reserve(nums1.size());          // avoid repeated reallocations\n\n    for (size_t i = 0; i < nums1.size(); ++i)\n    {\n        result.push_back(nums1[i] - nums2[i]);\n    }\n\n    return result;\n}\n```\n\n### Quick usage example\n\n```cpp\nint main()\n{\n    std::vector<long> a = { 10, 20, 30 };\n    std::vector<long> b = { 1, 2, 3 };\n\n    std::vector<long> c = sub_list(a, b);  // c == {9, 18, 27}\n\n    for (auto v : c) std::cout << v << ' ';\n    return 0;\n}\n```\n\nThe function is `constexpr`\u2011like because it only operates on vectors; if you want to make it more generic (e.g., work with any `Iterable` of arithmetic types) you can template it further, but for the stated requirement this implementation is clear and fast."]}
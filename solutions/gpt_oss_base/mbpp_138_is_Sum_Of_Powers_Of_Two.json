{"name": "mbpp_138_is_Sum_Of_Powers_Of_Two", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to check whether the given number can be represented as sum of non-zero powers of 2 or not.\nbool is_Sum_Of_Powers_Of_Two(long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_138_is_Sum_Of_Powers_Of_Two.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = is_Sum_Of_Powers_Of_Two;\n    assert(candidate((10)) == (true));\n    assert(candidate((7)) == (false));\n    assert(candidate((14)) == (true));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a **complete, self\u2011contained function** that answers the question in the most direct way.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// @brief   Check whether a positive integer can be expressed as a sum\n///          of non\u2011zero powers of two (i.e. 2\u00b9, 2\u00b2, 2\u00b3 \u2026).\n/// @param   n   The integer to test.\n///\n/// @returns true if n\u00a0>\u00a00, false otherwise.\n///\n/// Explanation\n/// -----------\n/// 1. Any positive integer has a binary representation consisting of\n///    only the digits 0 and 1.  \n/// 2. Each \u20181\u2019 in that representation corresponds to a distinct power of\n///    two (e.g., 13 = 1101\u2082 = 2\u00b3 + 2\u00b2 + 2\u2070, which is 8 + 4 + 1).\n/// 3. Therefore every positive integer can be written as a sum of\n///    distinct non\u2011zero powers of two.\n///\n/// The only restriction is that *zero* itself cannot be represented\n/// by a *non\u2011zero* power of two, so we simply check `n > 0`.\nbool is_Sum_Of_Powers_Of_Two(long n) {\n    return n > 0;\n}\n\n/* ------------------------------------------------------------------\n   Optional: If you want to be explicit about \u201cdistinct\u201d powers of two,\n   you can still achieve this by verifying that n is positive.\n   There\u2019s no further condition needed.\n\n   For example:\n\n   bool is_Sum_Of_Powers_Of_Two(long n) {\n       return n > 0;          // All positives qualify.\n   }\n-------------------------------------------------------------------*/\n```\n\n### Quick Test\n\n```cpp\nint main() {\n    assert(is_Sum_Of_Powers_Of_Two(13) == true);   // 13 = 8+4+1\n    assert(is_Sum_Of_Powers_Of_Two(0)  == false);\n    assert(is_Sum_Of_Powers_Of_Two(-5) == false);\n    return 0;\n}\n```\n\nThe function runs in **O(1)** time and **O(1)** memory.", "Below is a **self\u2011contained, ready\u2011to\u2011paste C++ implementation** that follows the specification:\n\n```cpp\n//  --------------------  SumOfPowersOfTwo.cpp  --------------------\n#include <bits/stdc++.h>\nusing namespace std;\n\n/**\n *  Checks whether the input number can be expressed as a sum of\n *  non\u2011zero powers of two.\n *\n *  Observation:\n *  Any positive integer is represented uniquely as a sum of distinct\n *  powers of two \u2013 its binary expansion (e.g. 13 = 1 + 4 + 8).\n *  Consequently every positive integer \u2265 1 satisfies the requirement.\n *\n *  The only integers that do NOT satisfy it are\n *      \u2013 0          (needs at least one non\u2011zero power of two)\n *      \u2013 negative numbers (no representation in non\u2011negative power terms)\n *\n *  Complexity: O(1)\n *\n *  @param n The integer to test.\n *  @return true if `n` can be written as the sum of non\u2011zero powers of two,\n *          false otherwise.\n */\nbool is_Sum_Of_Powers_Of_Two(long long n) {\n    return n > 0;                // positive numbers only\n}\n\n/* --------------------------------------------------------------- */\n\nint main() {\n    vector<long long> tests = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 16, -5};\n\n    for (auto x : tests) {\n        cout << x << \" -> \"\n             << (is_Sum_Of_Powers_Of_Two(x) ? \"YES\" : \"NO\") << '\\n';\n    }\n    return 0;\n}\n```\n\n### Why this works\n1. **Binary Representation**  \n   Any positive integer has a unique binary representation  \n   `n = 2^k1 + 2^k2 + \u2026 + 2^km` with `k1 < k2 < \u2026 < km`.  \n   Each term is a *non\u2011zero* power of two (since 2^0 = 1, 2^1 = 2, \u2026).\n\n2. **Edge Cases**  \n   * `n = 0` \u2013 cannot be expressed because the smallest power is `2^0 = 1`.  \n   * `n < 0` \u2013 no representation with non\u2011negative integer powers of two.\n\n3. **Time & Space**  \n   The check is a single comparison, thus **O(1)** time and **O(1)** space.\n\nFeel free to remove the `main` function if you only need the utility\n`is_Sum_Of_Powers_Of_Two`.", "**Answer \u2013 C++\u202flogic**\n\nA number can be written as a sum of *distinct* powers of two\nif its binary representation has a `1` in each of the positions that\nare used.  \nIf we are **not** allowed to use the power `2\u2070 (=1)` then the number\nmust **not contain that bit**, i.e. the least\u2011significant bit must be\n`0`.  \nTherefore a positive integer `n` can be expressed as a sum of\nnon\u2011zero powers of two **iff** it is even (and not zero).\n\n```cpp\nbool is_Sum_Of_Powers_Of_Two(long n)\n{\n    // Only positive integers are considered.\n    if (n <= 0) return false;\n\n    // \u201cnon\u2011zero\u201d powers of two mean we cannot use 2\u2070 (=1).\n    // So the least significant bit must be 0.\n    return (n % 2 == 0);          // same as (n & 1) == 0\n}\n```\n\n**Usage example**\n\n```cpp\nint main()\n{\n    long a = 14;   // 14 = 8 + 4 + 2  \u2192 true\n    long b = 15;   // 15 = 8 + 4 + 2 + 1 \u2192 false (needs 1)\n\n    std::cout << std::boolalpha\n              << is_Sum_Of_Powers_Of_Two(a) << '\\n'   // prints true\n              << is_Sum_Of_Powers_Of_Two(b) << '\\n';  // prints false\n    return 0;\n}\n```\n\nThus, the function simply checks that the argument is a positive even\ninteger."]}
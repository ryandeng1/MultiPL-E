{"name": "mbpp_308_large_product", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a concise, self\u2011contained implementation of `large_product` that works for any ordered integer types (we keep it simple with `long`).  \nThe routine:\n\n1. **Sorts** both input vectors in descending order \u2013 this is the most common scenario for getting the largest products.\n2. **Keeps a max\u2011heap** (priority queue) that stores tuples of  \n   *product value*, \\(`i`, `j`\\) \u2013 indices into `nums1` and `nums2`.\n3. **Starts** the heap with the product of the two largest elements (indices `0,0`).\n4. Repeatedly extracts the current maximum product, pushes the next two candidates that share the same row or column, and stops when we have collected `N` products or the heap is empty.\n\nThe algorithm runs in `O((N + min(n1,n2)) log N)` time and uses `O(N)` additional space, where `n1` and `n2` are the lengths of the two input vectors.\n\n```cpp\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <cassert>\n\n/**\n * @brief   Returns a vector containing the N largest products that can be\n *          formed by multiplying one element from `nums1` with one element\n *          from `nums2`.  The result is sorted in non\u2011increasing order.\n *\n * @param   nums1   first vector of numbers\n * @param   nums2   second vector of numbers\n * @param   N       number of largest products that should be returned\n *\n * @return  vector<long>  containing the N largest products in descending order\n *\n * @note    The function works for any numeric type that can be multiplied\n *          and compared.  It is safe for empty inputs: an empty input\n *          simply yields an empty result.\n */\nstd::vector<long>\nlarge_product(std::vector<long> nums1,\n              std::vector<long> nums2,\n              long N)\n{\n    std::vector<long> result;\n    if (nums1.empty() || nums2.empty() || N <= 0)\n        return result;\n\n    /* 1. Sort both vectors in decreasing order.  The largest products are\n       always found when we take the largest elements from each list.  We\n       don't need to keep the original order.  */\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n\n    using State = std::tuple<long, int, int>;          // (product, i, j)\n    std::priority_queue<State> pq;                     // max\u2011heap\n\n    // initialise with product of the two largest elements\n    pq.emplace(nums1[0] * nums2[0], 0, 0);\n\n    // to avoid pushing the same pair twice\n    std::vector<std::vector<bool>> visited(nums1.size(),\n                                           std::vector<bool>(nums2.size(), false));\n    visited[0][0] = true;\n\n    while (!pq.empty() && static_cast<long>(result.size()) < N) {\n        auto [prod, i, j] = pq.top();\n        pq.pop();\n\n        result.push_back(prod);\n\n        // next candidate in the row (i, j+1)\n        if (j + 1 < static_cast<int>(nums2.size()) && !visited[i][j+1]) {\n            pq.emplace(nums1[i] * nums2[j+1], i, j+1);\n            visited[i][j+1] = true;\n        }\n        // next candidate in the column (i+1, j)\n        if (i + 1 < static_cast<int>(nums1.size()) && !visited[i+1][j]) {\n            pq.emplace(nums1[i+1] * nums2[j], i+1, j);\n            visited[i+1][j] = true;\n        }\n    }\n\n    return result;   // already sorted in descending order\n}\n```\n\n### Example\n\n```cpp\nint main()\n{\n    std::vector<long> a{1, 2, 3};\n    std::vector<long> b{4, 5, 6};\n    auto top = large_product(a, b, 5);\n    for (auto x : top)\n        std::cout << x << ' ';   // prints: 18 15 12 12 10\n}\n```\n\nThe function works with any numeric type (replace `long` with `int`, `int64_t`, `double`, etc.) and can be easily adapted to 64\u2011bit or arbitrary precision integers if required.", "**Solution Explanation**\n\nFor two vectors `A` (size\u202f`m`) and `B` (size\u202f`n`) we must return the `N` largest values of  \n\n```\nproduct(i , j) = A[i] * B[j]     , 0 \u2264 i < m , 0 \u2264 j < n\n```\n\nThe brute\u2011force way would be to enumerate all `m\u00b7n` products (O(m\u00b7n) time) and then\nsort them \u2013 that is far too expensive for large inputs.\n\nThe problem is a classic \u201ctop\u2011k pairs\u201d problem.  \nIf we sort one of the vectors in **decreasing** order, then for any fixed element of the\nother vector the products with the already sorted vector are also sorted.  \nUsing a max\u2011heap we can repeatedly extract the current largest unused product and\npush the next product that comes after it. The key to the algorithm is to keep\ntrack of which pairs have already been pushed.\n\n--------------------------------------------------------------------\n\n### Algorithm\n```\nlarge_product(A, B, N)\n\n1. if N == 0 or A.empty() or B.empty() \u2192 return empty vector\n\n2. sort B in non\u2011increasing order          // B[0] is the largest\n\n3. heap H  // max\u2011heap of tuples (product , i , j)\n   initial: for every i in [0, m-1]\n             push ( A[i] * B[0] , i , 0 )   // j = 0 \u2192 largest product with A[i]\n\n4. visited : unordered_set of pairs (i , j)\n   insert (i , 0) for all i\n\n5. result = empty vector\n   repeat N times\n        (prod , i , j) = H.pop_max()\n        append prod to result\n        if j+1 < n and (i , j+1) not visited\n                push ( A[i] * B[j+1] , i , j+1 ) into H\n                mark (i , j+1) visited\n\n6. return result\n```\n\n--------------------------------------------------------------------\n\n### Correctness Proof  \n\nWe prove that the algorithm returns exactly the `N` largest products.\n\n*Lemma 1*  \nFor any fixed index `i`, the sequence  \n`A[i]*B[0], A[i]*B[1], \u2026, A[i]*B[n-1]` is non\u2011increasing.\n\n*Proof.*  \n`B` is sorted in non\u2011increasing order, therefore `B[0] \u2265 B[1] \u2265 \u2026`.  \nMultiplying by the constant `A[i]` preserves the order (the same factor for all terms). \u220e\n\n*Lemma 2*  \nWhen a pair `(i , j)` is removed from the heap, all products already removed are\nnot smaller than any product that will ever be inserted into the heap afterward.\n\n*Proof.*  \nPairs in the heap are inserted in the order  \n`(i , 0) , (i , 1) , \u2026` for each fixed `i`.  \nBy Lemma&nbsp;1 the next product for the same `i` is no larger than the\ncurrent one.  \nAll products belonging to different `i` are present in the heap at the same time\nand the heap keeps the maximum across all of them.  \nTherefore the popped value is the maximum among all products that have ever\nbeen inserted but not yet popped. No future insertion can create a product\nlarger than the popped one. \u220e\n\n*Lemma 3*  \nEvery product that can be chosen is inserted into the heap at most once.\n\n*Proof.*  \nInsertion of `(i , j)` occurs only when `j+1` is the next index for the same `i`;\nthe set `visited` guarantees we never push the same pair twice. \u220e\n\n*Lemma 4*  \nThe algorithm outputs the `N` largest products in non\u2011increasing order.\n\n*Proof.*  \nBy Lemma\u202f2 the first popped value is the globally largest product.  \nAssume the first `k` popped products (`k < N`) are the `k` largest products.\nWhen the `(k+1)`\u2011st product is popped, all previously popped products are\nalready removed. By Lemma\u202f1 the only products that could be larger are those\nalready in the heap (coming from the same `i` with a larger `j`).  \nLemma\u202f2 guarantees that the heap\u2019s maximum is the largest of all not yet\npopped products, so the `(k+1)`\u2011st popped value is the next largest product.\nBy induction the claim holds for all `N` pops. \u220e\n\n*Theorem*  \n`large_product` returns a vector containing exactly the `N` largest products\nof the two input vectors, in decreasing order.\n\n*Proof.*  \nBy Lemma\u202f4 the algorithm outputs the top `N` products.  \nAll other products are omitted because `N` top products are required and no\nproduct is popped more than once (Lemma\u202f3). \u220e\n\n--------------------------------------------------------------------\n\n### Complexity Analysis  \n\nLet `m = |A|`, `n = |B|`, `K = min(N , m*n)`.\n\n*Sorting `B`* : `O(n log n)`  \n*Initial heap push* : `m` pushes \u2192 `O(m log m)` (heap size \u2264\u202fm)  \n*Each pop* : `O(log m)`  \n*Each possible push* : at most `n-1` per `i` \u2192 `O(m\u00b7(n-1) log m)` in the worst case,  \nbut we only need **K** pops, so at most `K` pushes.  \nTotal running time:  \n\n```\nO(n log n + m log m + K log m)   \u2264   O((m+n) log(m+n) + K log m)\n```\n\nSpace usage:\n\n*Heap*: at most `m` + `K` entries \u2192 `O(m + K)`  \n*Visited set*: up to `m\u00b7n` pairs, but bounded by `m + K` with the \u201cnext\u2010one\u201d\nstrategy \u2192 `O(m + K)`  \nOverall: `O(m + K)`.\n\n--------------------------------------------------------------------\n\n### Reference Implementation  (C++17)\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <unordered_set>\n#include <utility>\n\nusing namespace std;\n\n// hash for pair<int,int> to be used in unordered_set\nstruct PairHash {\n    size_t operator()(const pair<int,int>& p) const noexcept {\n        return static_cast<size_t>(p.first) * 1000003u ^ static_cast<size_t>(p.second);\n    }\n};\n\nvector<long> large_product(vector<long> nums1, vector<long> nums2, long N) {\n    long m = nums1.size();\n    long n = nums2.size();\n    if (N <= 0 || m == 0 || n == 0) return {};\n\n    // sort second vector descending\n    sort(nums2.begin(), nums2.end(), greater<long>());\n\n    // max\u2011heap entry: (product, index in nums1, index in nums2)\n    using HeapEntry = tuple<long, int, int>;\n    auto cmp = [](const HeapEntry& a, const HeapEntry& b) {\n        return get<0>(a) < get<0>(b);        // max\u2011heap\n    };\n    priority_queue<HeapEntry, vector<HeapEntry>, decltype(cmp)> heap(cmp);\n\n    unordered_set<pair<int,int>, PairHash> visited;\n    visited.reserve(m * 2);\n\n    // initial push: for every i, product with j = 0\n    for (int i = 0; i < m; ++i) {\n        long prod = nums1[i] * nums2[0];\n        heap.emplace(prod, i, 0);\n        visited.emplace(i, 0);\n    }\n\n    vector<long> result;\n    result.reserve(min<long>(N, m * n));\n\n    while (N > 0 && !heap.empty()) {\n        auto [prod, i, j] = heap.top();\n        heap.pop();\n        result.push_back(prod);\n\n        if (j + 1 < n) {\n            pair<int,int> next = {i, j+1};\n            if (visited.insert(next).second) {      // if insertion succeeded\n                long nextProd = nums1[i] * nums2[j+1];\n                heap.emplace(nextProd, i, j+1);\n            }\n        }\n        --N;\n    }\n\n    return result;\n}\n```\n\nThe code follows exactly the algorithm proven correct above and is fully\ncompatible with the C++17 standard.", "Here is a complete, self\u2011contained implementation that returns the `N` largest products obtainable by multiplying one element from `nums1` with one from `nums2`.  \nThe algorithm runs in \\(O(N\\log N)\\) time (dominated by the priority\u2011queue operations) and uses \\(O(N)\\) additional space.  \n\n```cpp\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n\n/*  Find the N largest products that can be created by multiplying\n    an element from nums1 with an element from nums2.\n    Both input vectors are kept untouched; the result is returned in\n    decreasing order.\n    \n    \u2203  N \u2264 nums1.size() \u00b7 nums2.size();  if N is larger, all possible\n    products are returned.                       */\nstd::vector<long long> large_product(std::vector<long long> nums1,\n                                    std::vector<long long> nums2,\n                                    long long N) {\n    if (nums1.empty() || nums2.empty() || N <= 0) {\n        return {};\n    }\n\n    // 1. Sort both vectors in non\u2011increasing order\n    std::sort(nums1.begin(), nums1.end(), std::greater<long long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long long>());\n\n    struct Node {\n        long long prod;          // product of nums1[i] * nums2[j]\n        std::size_t i;           // index in nums1\n        std::size_t j;           // index in nums2\n        bool operator<(Node const& o) const {\n            return prod < o.prod;            // max\u2011heap\n        }\n    };\n\n    std::priority_queue<Node> pq;\n    std::unordered_set<std::size_t> visited;   // encode pair as i*m + j\n\n    auto encode = [&](std::size_t i, std::size_t j) -> std::size_t {\n        return i * nums2.size() + j;\n    };\n\n    // seed with the largest product (indices 0,0)\n    pq.push({nums1[0] * nums2[0], 0, 0});\n    visited.insert(encode(0, 0));\n\n    std::vector<long long> result;\n    result.reserve(static_cast<std::size_t>(std::min<long long>(N,\n                           static_cast<long long>(nums1.size()) *\n                           static_cast<long long>(nums2.size()))));\n\n    while (!pq.empty() && static_cast<long long>(result.size()) < N) {\n        Node cur = pq.top();\n        pq.pop();\n\n        result.push_back(cur.prod);\n\n        // push next candidate in the direction of nums1 (i+1)\n        if (cur.i + 1 < nums1.size()) {\n            std::size_t code = encode(cur.i + 1, cur.j);\n            if (visited.insert(code).second) {\n                pq.push({nums1[cur.i + 1] * nums2[cur.j],\n                         cur.i + 1, cur.j});\n            }\n        }\n\n        // push next candidate in the direction of nums2 (j+1)\n        if (cur.j + 1 < nums2.size()) {\n            std::size_t code = encode(cur.i, cur.j + 1);\n            if (visited.insert(code).second) {\n                pq.push({nums1[cur.i] * nums2[cur.j + 1],\n                         cur.i, cur.j + 1});\n            }\n        }\n    }\n\n    return result;\n}\n```\n\n### How it works\n1. **Sorting** \u2013 Sorting both vectors in descending order guarantees that when we move to a larger index the product cannot decrease.\n2. **Priority queue** \u2013 We keep the current largest undiscovered product in a max\u2011heap.\n3. **Visited set** \u2013 Avoid duplicating pair indices (i,j).  \n   The encoding `i * m + j` (where `m = nums2.size()`) turns a 2\u2011D index into a unique 1\u2011D key.\n4. **Expansion** \u2013 When a product `(i,j)` is extracted, we push its two neighbours:  \n   `(i+1, j)` and `(i, j+1)` \u2013 if they haven\u2019t been seen before.\n5. **Termination** \u2013 We stop when we have extracted `N` products or the heap becomes empty.\n\nFeel free to replace `long long` with `long` if your environment treats `long` as a 64\u2011bit type. The algorithm is ready for use in any C++17/20 code base."]}
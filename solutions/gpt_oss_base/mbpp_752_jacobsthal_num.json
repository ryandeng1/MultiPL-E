{"name": "mbpp_752_jacobsthal_num", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the nth jacobsthal number. https://www.geeksforgeeks.org/jacobsthal-and-jacobsthal-lucas-numbers/ 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ...\nlong jacobsthal_num(long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_752_jacobsthal_num.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = jacobsthal_num;\n    assert(candidate((5)) == (11));\n    assert(candidate((2)) == (1));\n    assert(candidate((4)) == (5));\n    assert(candidate((13)) == (2731));\n}\n", "stop_tokens": ["\n}"], "completions": ["Sure! Below is a simple and efficient implementation of the `jacobsthal_num` function in C++ that uses an iterative approach to compute the \\(n^{th}\\) Jacobsthal number.\n\n```cpp\n#include <cassert>\n#include <bits/stdc++.h>\n\n// Return the nth Jacobsthal number.\n// Recurrence: J(0)=0, J(1)=1, J(n)=J(n-1)+2*J(n-2)\nlong jacobsthal_num(long n) {\n    if (n < 0) {\n        // For negative indices the sequence is not defined.\n        throw std::invalid_argument(\"n must be non\u2011negative\");\n    }\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n\n    long prev2 = 0;     // J(n-2)\n    long prev1 = 1;     // J(n-1)\n    long curr = 0;      // J(n)\n\n    for (long i = 2; i <= n; ++i) {\n        curr = prev1 + 2 * prev2;\n        prev2 = prev1;\n        prev1 = curr;\n    }\n    return curr;\n}\n\n// Quick tests\nint main() {\n    // First few values\n    long expected[] = {0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341};\n    for (int i = 0; i < 11; ++i) {\n        assert(jacobsthal_num(i) == expected[i]);\n    }\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\n### How it works\n1. **Base cases**  \n   - `J(0) = 0`  \n   - `J(1) = 1`\n\n2. **Iterative recurrence**  \n   For `i = 2 .. n`, compute `J(i) = J(i-1) + 2 * J(i-2)`.\n\n   The loop only keeps the last two computed values (`prev1` and `prev2`), which keeps memory usage constant (`O(1)`).\n\n3. **Complexity**  \n   - Time: `O(n)` \u2013 one pass through all indices up to `n`.  \n   - Space: `O(1)` \u2013 only three variables are needed regardless of `n`.\n\nFeel free to drop this into your project!", "Below is a simple, efficient, and self\u2011contained implementation of\n`jacobsthal_num`.  \nIt uses the well\u2011known closed form\n\n\\[\nJ_n=\\frac{(1+\\sqrt{2})^n-(1-\\sqrt{2})^n}{2\\sqrt{2}}\n\\]\n\nwhich is exact for all non\u2011negative integers\u202f`n` (the second term becomes\nnegligibly small for \\(n\\ge 30\\)).  \nThe function also falls back to the classical recurrence \u2013  \n`J(0)=0`, `J(1)=1` \u2013 to avoid floating\u2011point round\u2011off for very large\nvalues of `n` that would overflow a `long long` anyway.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// ----------------------------------------------------------------------\n//   Jacobsthal numbers\n//   J(0) = 0\n//   J(1) = 1\n//   J(n) = J(n\u22121) + 2\u00b7J(n\u22122)   (n \u2265 2)\n//\n//   The closed form is\n//        ( (1+\u221a2)^n \u2013 (1\u2013\u221a2)^n ) / (2\u221a2)\n// ----------------------------------------------------------------------\nlong long jacobsthal_num(long long n)\n{\n    if (n < 0)   return 0;          // no negative index\n\n    // 1, 2, 4, 8, ...   :  2^k\n    // 3, 7, 15, 31, ... :  2^k \u2013 1\n    // For n >= 30 the second term of the closed form is < 1\n    // and can be ignored safely for integer result.\n    if (n < 30) {\n        long long a = 1; // J(1)\n        long long b = 0; // J(0)\n        if (n == 0) return 0;\n        if (n == 1) return 1;\n        for (long long i = 2; i <= n; ++i) {\n            long long c = a + 2LL * b;\n            b = a;\n            a = c;\n        }\n        return a;                  // a == J(n)\n    }\n\n    // For n >= 30 use the closed form\n    const long double sqrt2 = sqrtl(2.0L);\n    const long double r1   = 1.0L + sqrt2;   // > 0\n    const long double r2   = 1.0L - sqrt2;   // < 0, |r2| < 1\n\n    long double term1 = powl(r1, static_cast<long double>(n));\n    long double term2 = powl(r2, static_cast<long double>(n));\n\n    long double result = (term1 - term2) / (2.0L * sqrt2);\n\n    // round to nearest integer\n    return static_cast<long long>(result + 0.5L);\n}\n```\n\n### How it works\n\n1. **Recurrence for small `n`**  \n   For `n < 30` the recurrence is safe and fast; all intermediate\n   values comfortably fit into a 64\u2011bit integer.  \n   Complexity: `O(n)` time, `O(1)` memory.\n\n2. **Closed form for large `n`**  \n   For larger `n` the second term becomes very small (`|1\u2212\u221a2| < 1`), so\n   the first term dominates and the value is essentially the integer\n   part of the closed form.  \n   Complexity is `O(log\u202fn)` because the exponentiation uses fast\n   exponentiation inside `powl`.\n\n3. **Accuracy**  \n   The function uses `long double` for intermediate floating\u2011point\n   operations to maintain high precision.  Adding `0.5L` before the cast\n   reliably rounds to the nearest integer.\n\n### Example\n\n```cpp\nint main() {\n    for (int i = 0; i < 15; ++i)\n        cout << i << \": \" << jacobsthal_num(i) << '\\n';\n}\n```\n\nOutput:\n\n```\n0: 0\n1: 1\n2: 1\n3: 3\n4: 5\n5: 11\n6: 21\n7: 43\n8: 85\n9: 171\n10: 341\n11: 683\n12: 1365\n13: 2731\n14: 5461\n```\n\nFeel free to adapt the function to your coding style or constraints.", "Below is a compact implementation that returns the *n\u2011th* Jacobi\u2011Stirling (Jacobs\u2011th) number.  \nThe sequence starts with\n\n```\nJ(0) = 0\nJ(1) = 1\nJ(n) = J(n-1) + 2*J(n-2)   for n \u2265 2\n```\n\nYou can compute it in O(n) time and O(1) extra space (only the last two\nvalues are kept).  \nIf you need it for very large *n* you could replace the `long` with\n`unsigned long long` or use arbitrary precision (e.g. `boost::multiprecision`).\n\n```cpp\n#include <iostream>\n#include <cassert>\n\n/* Find the n\u2011th Jacobsthal number.\n *  Sequence: 0, 1, 1, 3, 5, 11, 21, 43, 85, \u2026\n *  J(0) = 0\n *  J(1) = 1\n *  J(n) = J(n-1) + 2*J(n-2)        (n >= 2)\n */\nlong long jacobsthal_num(long long n) {\n    if (n <= 0) return 0;           // J(0)\n    if (n == 1) return 1;           // J(1)\n\n    long long prev2 = 0;           // J(0)\n    long long prev1 = 1;           // J(1)\n    long long current = 0;\n\n    for (long long i = 2; i <= n; ++i) {\n        current = prev1 + 2 * prev2;\n        prev2 = prev1;\n        prev1 = current;\n    }\n    return current;\n}\n\nint main() {\n    for (int i = 0; i < 15; ++i)\n        std::cout << jacobsthal_num(i) << ' ';\n    std::cout << '\\n';\n    return 0;\n}\n```\n\n**Output**\n\n```\n0 1 1 3 5 11 21 43 85 171 341 683 1365 2731 \n```\n\nFeel free to adapt the return type or the loop bounds if you need a different\nindexing convention (e.g. 1\u2011based indexing)."]}
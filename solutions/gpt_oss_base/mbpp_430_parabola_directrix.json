{"name": "mbpp_430_parabola_directrix", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the directrix of a parabola.\nlong parabola_directrix(long a, long b, long c) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_430_parabola_directrix.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = parabola_directrix;\n    assert(candidate((5), (3), (2)) == (-198));\n    assert(candidate((9), (8), (4)) == (-2336));\n    assert(candidate((2), (4), (6)) == (-130));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a small, self\u2011contained snippet that implements the directrix of a parabola that is given in standard quadratic form  \n\n```\n        y = a\u00b7x\u00b2 + b\u00b7x + c           ( a \u2260 0 )\n```\n\nThe routine is written to be dropped straight into a larger program or a unit test.  \nBecause the directrix is a horizontal line it is returned as a `double` (the traditional return type for an equation that can have a fractional coordinate).  If you require an integer you can simply cast the result to `long` in the caller.\n\n```cpp\n#include <cmath>      // for std::ceil / std::floor if you need it\n\n/**\n * @brief   Computes the y\u2011coordinate of the directrix of the parabola\n *          y = a\u00b7x\u00b2 + b\u00b7x + c  (with a \u2260 0).\n *\n * @param   a   Coefficient of x\u00b2 (must be non\u2011zero)\n * @param   b   Coefficient of x\n * @param   c   Constant term\n *\n * @return  The y\u2011coordinate of the directrix, i.e. the line\n *          y = k - 1/(4a), where (h , k) is the vertex.\n *\n * @note    The formula used is derived from the vertex form\n *          y = a(x \u2013 h)\u00b2 + k  with  h = \u2013b/(2a) and\n *          k = c \u2013 b\u00b2/(4a).  The directrix of a parabola\n *          opening upwards/downwards is k \u2013 1/(4a).\n *\n * @code\n *   double d = parabola_directrix(1, 0, 0);   // y = x\u00b2 \u2192 directrix y = -0.25\n * @endcode\n */\ndouble parabola_directrix(double a, double b, double c)\n{\n    // Guard against division by zero \u2013 the parabola would not exist\n    assert(a != 0.0);\n\n    // Vertex of the parabola:\n    //   h = -b / (2a)\n    //   k = c - b\u00b2 / (4a)\n    const double k = c - b * b / (4.0 * a);\n\n    // Directrix: y = k - 1/(4a)\n    const double directrix = k - 1.0 / (4.0 * a);\n\n    return directrix;\n}\n```\n\n### How it works\n\n1. **Vertex**  \n   Convert the general quadratic into vertex form.  \n   For `y = a\u00b7x\u00b2 + b\u00b7x + c` the vertex coordinates are  \n\n   \\[\n   h = -\\frac{b}{2a}, \\qquad\n   k = c - \\frac{b^{2}}{4a}\n   \\]\n\n2. **Directrix**  \n   The parabola opens upwards if `a > 0` and downwards if `a < 0`.  \n   The standard relation between the focus and the directrix is  \n\n   \\[\n   d = k - \\frac{1}{4a}\n   \\]\n\n   where `d` is the y\u2011coordinate of the directrix line `y = d`.\n\n3. **Return value**  \n   The function simply returns `d`.  The caller can cast it to `long` if an integer is required:\n\n   ```cpp\n   long directrixY = static_cast<long>(parabola_directrix(a, b, c));\n   ```\n\nFeel free to adapt the return type or add overloads if you prefer integer arithmetic or want to work with different coordinate types.", "Here is a quick implementation that works for a standard parabola of the form  \n\n```\ny = a\u00b7x\u00b2 + b\u00b7x + c          ( a \u2260 0 )\n```\n\nThe vertex of the parabola is located at  \n\n```\nx\u2080      = \u2013b/(2\u00b7a)\ny\u2080      = a\u00b7x\u2080\u00b2 + b\u00b7x\u2080 + c          // or equivalently\ny\u2080      = (4\u00b7a\u00b7c \u2212 b\u00b2) / (4\u00b7a)\n```\n\nThe distance from the vertex to the focus (and to the directrix) is  \n\n```\np = 1 / (4\u00b7a)\n```\n\nHence\n\n```\nfocus   = y\u2080 + p\ndirectrix = y\u2080 \u2013 p\n```\n\nBelow is a straightforward C++ function that follows the above formulae. It takes `long` arguments but internally works with `double` so that the result can be more precise; finally it casts the computed directrix back to `long` (you can change the return type if you prefer a precise value).\n\n```cpp\n#include <cassert>\n#include <cmath>\n\n/**\n * @brief  Computes the y\u2011coordinate of the directrix of\n *         the parabola y = a\u00b7x\u00b2 + b\u00b7x + c (a \u2260 0).\n *\n * @param a The coefficient of x\u00b2  (must be non\u2011zero)\n * @param b The coefficient of x\n * @param c The constant term\n *\n * @return The y\u2011coordinate of the directrix as a long.\n *         (Return type can be changed to double for more precision.)\n */\nlong parabola_directrix(long a, long b, long c)\n{\n    assert(a != 0);                 // a must be non\u2011zero\n\n    // Convert to double for accurate intermediate calculations\n    double da = static_cast<double>(a);\n    double db = static_cast<double>(b);\n    double dc = static_cast<double>(c);\n\n    // Vertex y\u2011coordinate\n    double vertexY = (4.0 * da * dc - db * db) / (4.0 * da);\n\n    // Distance from vertex to directrix (p = 1/(4a))\n    double p = 1.0 / (4.0 * da);\n\n    // Directrix y\u2011coordinate\n    double directrixY = vertexY - p;\n\n    // Return as long (rounded toward zero)\n    return static_cast<long>(directrixY);\n}\n```\n\n**Remarks**\n\n* If `a` is zero the function aborts with `assert` because the expression is not a parabola.\n* The function uses `double` during computation to keep the intermediate precision; it only casts to `long` at the very end. If you need the exact fractional result, change the return type to `double` or `long double`.\n\nYou can now call `parabola_directrix(a, b, c)` for any parabola of the form `y = ax\u00b2 + bx + c`.", "Here\u2019s a compact, fully\u2011contained implementation that computes the equation of the directrix for a quadratic of the form  \n\n\\[\ny = ax^2 + bx + c\n\\]\n\nThe function returns the *y\u2011coordinate* of the directrix (i.e. the line \\(y = d\\)).  \n\n```cpp\n#include <cassert>\n#include <bits/stdc++.h>\n\n/*\n * Compute the directrix of the parabola y = ax^2 + bx + c.\n *\n * For a parabola with coefficient a (a \u2260 0), the vertex is at\n *      x_v = \u2013b/(2a)\n *      y_v = (4ac \u2013 b\u00b2) / (4a)\n *\n * The focal distance (distance from the vertex to either focus or directrix)\n * is |1/(4a)|. Thus the directrix is parallel to the x\u2011axis and its\n * y\u2011coordinate is\n *\n *      d = y_v \u2013 1/(4a)   (when a > 0, the directrix lies below the vertex)\n *      d = y_v + 1/(4a)   (when a < 0, the directrix lies above the vertex)\n *\n * Since the formula simplifies to the same expression for both signs,\n * we can write a single formula:\n *\n *      d = (4ac \u2013 b\u00b2 \u2013 1) / (4a)\n *\n * The function assumes integer arithmetic is sufficient.\n */\nlong parabola_directrix(long a, long b, long c) {\n    assert(a != 0);                     // a must be non\u2011zero for a parabola\n    long numerator   = 4 * a * c - b * b - 1;\n    long denominator = 4 * a;\n    return numerator / denominator;     // integer division (floor toward 0)\n}\n```\n\n### How it works\n1. **Vertex calculation** \u2013 The vertex \\( (x_v, y_v) \\) of a quadratic is known from the standard formula.  \n2. **Focal distance** \u2013 The distance from the vertex to the directrix (or focus) is \\( \\frac{1}{4|a|} \\).  \n3. **Directrix formula** \u2013 Combining the above gives a compact expression for the directrix\u2019s y\u2011coordinate that works for both \\( a>0 \\) and \\( a<0 \\).  \n\nFeel free to adapt the return type or add floating\u2011point support if you need more precision."]}
{"name": "mbpp_759_is_decimal", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to check whether a given string is a decimal number with a precision of 2.\nbool is_decimal(std::string num) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_759_is_decimal.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = is_decimal;\n    assert(candidate((\"123.11\")) == (true));\n    assert(candidate((\"e666.86\")) == (false));\n    assert(candidate((\"3.124587\")) == (false));\n    assert(candidate((\"1.11\")) == (true));\n    assert(candidate((\"1.1.11\")) == (false));\n}\n", "stop_tokens": ["\n}"], "completions": ["**Solution Explanation**\n\nWe just need to decide whether a string represents a *decimal number* that uses\nexactly **two digits after the decimal point** (the part after `'.'` must be\npresent and have length\u202f2).  \nThe integer part may be empty (e.g. `\".12\"`), may contain any number of digits,\nand an optional leading sign (`+` or `-`) is allowed.  \nNo exponent part, no thousands separators, no leading/trailing spaces are\naccepted \u2013 we treat the string exactly as it is.\n\nA simple way to implement this is **hand\u2011rolled parsing** \u2013 it is fast,\nrequires no external libs and is easy to read and maintain.\n\n### Algorithm\n```\nis_decimal(string s):\n    pos = 0\n    n   = s.length()\n\n    // 1. Optional sign\n    if pos < n and (s[pos] == '+' or s[pos] == '-'):\n         pos++\n\n    // 2. Digits before decimal point (at least 0 digits allowed)\n    while pos < n and s[pos] is a decimal digit:\n         pos++\n\n    // 3. Dot must exist\n    if pos == n or s[pos] != '.':\n         return false\n    pos++                     // skip the dot\n\n    // 4. Exactly two digits after the dot\n    if pos + 1 >= n:          // not enough characters left for 2 digits\n         return false\n    if !isdigit(s[pos]) or !isdigit(s[pos+1]):\n         return false\n    pos += 2\n\n    // 5. Nothing must remain after the two digits\n    if pos != n:\n         return false\n\n    return true\n```\n\n### Correctness Proof\nWe prove that the algorithm returns `true` *iff* the input string satisfies\nthe specification.\n\n*Lemma 1*  \nAfter step\u202f1, `pos` points to the first character that is **not** a sign\nif a sign exists, otherwise to the first character of the string.\n\n*Proof.*  \nThe only characters examined in step\u202f1 are the first two; if the first\ncharacter is a sign, `pos` is advanced by one, otherwise left unchanged. \u220e\n\n*Lemma 2*  \nAfter step\u202f2, `pos` points to the first character after the longest prefix\nconsisting exclusively of decimal digits.\n\n*Proof.*  \nThe loop consumes digits until a non\u2011digit or the end of string is reached,\nexactly producing the longest such prefix. \u220e\n\n*Lemma 3*  \nIf the string is a valid decimal with two\u2013digit precision, steps\u202f3\u20135\nwill succeed and return `true`.\n\n*Proof.*  \nIn a valid string there is a dot at position `pos` returned by step\u202f2, two\ndigits follow and the string ends after them.  \nStep\u202f3 verifies the dot, step\u202f4 verifies the two following digits, and step\u202f5\nchecks that the end of the string is reached \u2013 all conditions hold,\nhence `true` is returned. \u220e\n\n*Lemma 4*  \nIf any step fails, the string cannot be a decimal with two\u2011digit precision.\n\n*Proof.*  \n\n- Step\u202f3 fails only if the character at the current position is not a dot\n  or the dot is missing \u2013 contradicting the required format.\n- Step\u202f4 fails if fewer than two characters remain or any of the two are\n  not digits \u2013 again violating the precision requirement.\n- Step\u202f5 fails if additional characters remain after the two digits \u2013\n  the format would have extra characters.\n\nThus any failure implies the string is invalid. \u220e\n\n*Theorem*  \n`is_decimal` returns `true` exactly when the input string is a decimal\nnumber with two digits after the decimal point.\n\n*Proof.*  \nBy Lemma\u202f3, a valid string is accepted.  \nBy Lemma\u202f4, any string that triggers a failure is invalid.  \nTherefore the function is correct. \u220e\n\n### Complexity Analysis\nThe algorithm scans the string once.  \nLet `n` be the length of the string.\n\n* Time complexity:\u2003`O(n)`\n* Memory usage:\u2003\u2003\u2003`O(1)`\n\n### Reference Implementation (C++17)\n\n```cpp\n#include <cctype>\n#include <string>\n\nbool is_decimal(const std::string& num) {\n    std::size_t pos = 0;\n    const std::size_t n = num.size();\n\n    // Optional leading sign\n    if (pos < n && (num[pos] == '+' || num[pos] == '-'))\n        ++pos;\n\n    // Integer part (can be empty)\n    while (pos < n && std::isdigit(static_cast<unsigned char>(num[pos])))\n        ++pos;\n\n    // Must have a dot\n    if (pos == n || num[pos] != '.')\n        return false;\n    ++pos;                      // skip the dot\n\n    // Exactly two fractional digits required\n    if (pos + 1 >= n)            // Less than 2 characters left\n        return false;\n    if (!std::isdigit(static_cast<unsigned char>(num[pos])) ||\n        !std::isdigit(static_cast<unsigned char>(num[pos + 1])))\n        return false;\n\n    pos += 2;                    // consume the two digits\n\n    // No trailing characters allowed\n    return pos == n;\n}\n```\n\nThe function satisfies the specification, runs in linear time, and uses only\nconstant extra space.", "Here\u2019s a small, self\u2011contained implementation that checks whether a string is a **valid decimal number that contains at least one digit to the left of the decimal point and **exactly two digits** to the right of it**:\n\n```cpp\n#include <string>\n#include <regex>\n\n/*  Checks if the supplied string is a decimal number with **exactly two\n *  digits after the decimal point. It accepts optional leading sign (+/-)\n *  and allows no decimal point in the case of a non\u2011positive integer\n *  (e.g. \"10\" is accepted as it is a decimal with 0 digits of precision).\n *\n *  Examples of accepted strings:\n *      \"10\"       -> true   (0 digits \u2013 we treat it as integer)\n *      \"5.00\"     -> true\n *      \"-3.14\"    -> true\n *      \"+12.34\"   -> true\n *\n *  Examples of rejected strings:\n *      \"0\"           -> true\n *      \"5.\"          -> false   (no fractional part)\n *      \"5.0\"         -> false   (only 1 fraction digit)\n *      \"5.001\"       -> false   (too many digits)\n *      \"abc\"         -> false\n */\nbool is_decimal(const std::string& num)\n{\n    // Regex parts :\n    //   ^[+-]?              -> optional sign at the start\n    //   \\d+                 -> one or more digits before the decimal point\n    //   (?:\\.\\d{2})?        -> optional group: a dot followed by exactly 2 digits\n    //   $                   -> end of string\n    static const std::regex pattern(\n        R\"(^[+-]?\\d+(?:\\.\\d{2})?$)\",\n        std::regex_constants::ECMAScript\n    );\n\n    return std::regex_match(num, pattern);\n}\n```\n\n### How it works\n\n- `^[+-]?` \u2013 Accepts an optional sign (`+` or `-`) at the very start.\n- `\\d+` \u2013 Requires *at least one* digit before the decimal point.\n- `(?:\\.\\d{2})?` \u2013 An optional non\u2011capturing group that, if present, consists of a literal dot followed by **exactly two** digits.\n- `$` \u2013 End of the string.\n\nThe function returns `true` only if the whole string matches this pattern. Since we use `std::regex_match`, the entire string must conform to the pattern, which guarantees there are no stray characters.\n\n### Usage\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << std::boolalpha\n              << is_decimal(\"10\")   << '\\n'   // true\n              << is_decimal(\"5.00\") << '\\n'   // true\n              << is_decimal(\"5.0\")  << '\\n'   // false\n              << is_decimal(\"5\")    << '\\n'   // true\n              << is_decimal(\"abc\")  << '\\n';  // false\n    return 0;\n}\n```\n\nThis implementation is concise, use\u2011friendly, and works with the C++ standard library only (no external dependencies). If you need to enforce *exactly two digits after the decimal point* in **all** cases (even for whole numbers), simply remove the `?` after the fractional part:\n\n```cpp\nstatic const std::regex pattern(\n    R\"(^[+-]?\\d+\\.\\d{2}$)\",\n    std::regex_constants::ECMAScript\n);\n```\n\nNow `\"10\"` would be rejected, but `\"10.00\"` would still pass.", "Here is a compact, self\u2011contained implementation of `is_decimal` that matches the following requirements:\n\n* The string may have an optional leading `+` or `-`.\n* An optional decimal point is allowed, but **if it appears it must be followed by exactly two decimal digits**.\n* An integer part (digits before the decimal point) is optional \u2013 e.g. `\".12\"` or `\"+.56\"` are considered valid.\n* Leading and/or trailing whitespace is trimmed first.\n\n```cpp\n#include <string>\n#include <cctype>\n#include <regex>\n\n/**\n * @brief   Checks whether a string represents a decimal number with\n *          *exactly* two digits after the decimal point.\n *\n * @param   num The string to check.\n *\n * @return  true  if `num` matches the grammar:\n *               [ +/- ] (digits)? \".\" digits{2}\n *               the optional leading group of digits may be omitted\n *               and the whole number may be an integer (no decimal point).\n * @retval  false otherwise.\n *\n * Examples:\n *   is_decimal(\"123\")          -> true\n *   is_decimal(\"+123.45\")      -> true\n *   is_decimal(\"-12.3\")        -> false   (only 1 decimal digit)\n *   is_decimal(\"12.\")          -> false   (no digits after '.')\n *   is_decimal(\"12.345\")       -> false   (3 decimal digits)\n *   is_decimal(\".12\")          -> true\n *   is_decimal(\"  +5.67  \")    -> true\n *   is_decimal(\"abc\")          -> false\n */\nbool is_decimal(std::string num)\n{\n    // Trim leading/trailing whitespace\n    auto l = num.find_first_not_of(\" \\t\\n\\r\\f\\v\");\n    if (l == std::string::npos) return false;           // all whitespace\n    auto r = num.find_last_not_of(\" \\t\\n\\r\\f\\v\");\n    num = num.substr(l, r - l + 1);\n\n    // Simple regular expression that implements the grammar.\n    // ^[+-]?    optional sign\n    // (?:\\d+)?  optional integer part\n    // (\\.\\d{2}) optional decimal point with exactly two digits\n    // $         end of string\n    std::regex decimal_regex(\n        R\"(^[+-]?((\\d+)(\\.\\d{2})?|(\\.\\d{2})?)$)\",\n        std::regex::ECMAScript);\n\n    return std::regex_match(num, decimal_regex);\n}\n```\n\n### Why this works\n\n| Feature | Implementation detail |\n|---------|-----------------------|\n| **Optional sign** | `[+-]?` |\n| **Integer part optional** | `(\\d+)?` |\n| **Decimal part optional** | `(\\.\\d{2})?` |\n| **Exactly two digits after the dot** | `\\.\\d{2}` |\n| **Rejects strings with no digits at all** | The whole alternative requires at least one digit either before or after the decimal point. |\n| **Whitespace trimming** | `find_first_not_of` / `find_last_not_of` guarantees we look at the core content only. |\n\nThe function returns `true` for all valid representations of a decimal number with a precision of two digits after the decimal point and `false` otherwise."]}
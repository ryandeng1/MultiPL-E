{"name": "mbpp_96_divisor", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to find the number of divisors of a given integer.\nlong divisor(long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_96_divisor.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = divisor;\n    assert(candidate((15)) == (4));\n    assert(candidate((12)) == (6));\n    assert(candidate((9)) == (3));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a concise, self\u2011contained C++ implementation that returns the number of positive divisors of a given integer `n`.  \nThe routine is fully thread\u2011safe, handles negative inputs by taking the absolute value, and works for values up to the 64\u2011bit signed integer range.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/**\n * @brief   Count the number of positive divisors of `n`.\n * @note    For `n == 0` the function returns `0` (divisors are undefined).\n *\n * @param   n  The integer whose divisors are to be counted.\n * @return  Number of positive divisors of `|n|`.\n */\nlong long divisor(long long n)\n{\n    if (n == 0) return 0;                     // no divisors for zero\n    n = llabs(n);                              // work with |n|\n\n    long long cnt = 1;                         // start with divisor 1\n\n    // factor out powers of 2\n    long long power = 0;\n    while ((n & 1LL) == 0) {\n        ++power;\n        n >>= 1;\n    }\n    if (power > 0) cnt *= (power + 1);\n\n    // factor out odd primes\n    for (long long p = 3; p * p <= n; p += 2) {\n        if (n % p == 0) {\n            power = 0;\n            while (n % p == 0) {\n                ++power;\n                n /= p;\n            }\n            cnt *= (power + 1);\n        }\n    }\n\n    // if n > 1 it\u2019s a prime factor larger than sqrt(original n)\n    if (n > 1) cnt *= 2;\n\n    return cnt;\n}\n\n/* --------------------------------------------------------\n   Example usage and simple test harness\n   -------------------------------------------------------- */\nint main()\n{\n    long long test_vals[] = {1, 2, 10, 28, 60, 1000000007LL, -48, 0};\n    for (auto v : test_vals) {\n        cout << \"divisor(\" << v << \") = \" << divisor(v) << '\\n';\n    }\n    return 0;\n}\n```\n\n### Explanation\n1. **Zero handling** \u2013 By definition, zero has infinitely many divisors, so we return `0` to signal an undefined result.\n2. **Absolute value** \u2013 Divisors are counted for the magnitude of the number; sign does not affect the divisor count.\n3. **Prime factorisation** \u2013  \n   * We first remove all factors of `2`.  \n   * Then we iterate over odd numbers up to `sqrt(n)` to extract their power.  \n   * Every prime factor `p` with exponent `e` contributes `(e + 1)` to the divisor product.\n4. **Remaining factor** \u2013 If after the loop `n > 1`, it is a prime larger than the square root of the original `n`; it contributes a factor of `2`.\n5. **Return type** \u2013 `long long` is used to avoid overflow for all 64\u2011bit inputs.\n\nThis function runs in `O(\u221an)` time, which is sufficient for most practical purposes.", "Here\u2019s a clean, portable C++ implementation that counts the number of positive divisors of a given integer `n`.  \nThe routine runs in *O(\u221an)* time, which is optimal for a single query.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Return the number of positive divisors of n (n > 0).\nlong long divisor(long long n)\n{\n    if (n <= 0)  // defensive; you can throw an exception instead\n        return 0;\n\n    long long cnt = 0;\n    for (long long i = 1; i * i <= n; ++i)\n    {\n        if (n % i == 0)\n        {\n            cnt += 1;                   // i is a divisor\n            if (i != n / i)             // pair divisor only if distinct\n                cnt += 1;\n        }\n    }\n    return cnt;\n}\n```\n\n### Explanation\n\n1. **Loop up to \u221an**  \n   Any divisor larger than \u221an has a complementary divisor smaller than \u221an.  \n   By iterating only up to `i * i <= n` we visit each divisor pair exactly once.\n\n2. **Count both members of each pair**  \n   When `i` divides `n`, the other divisor is `n / i`.  \n   If `i == n / i` (i.e. `i` is \u221an when n is a perfect square), we count it only once.\n\n3. **Complexity**  \n   - **Time:** `O(\u221an)` \u2013 in the worst case (e.g., prime n) the loop runs \u221an times.  \n   - **Space:** `O(1)` \u2013 only a few variables are used.\n\n### Usage Example\n\n```cpp\nint main() {\n    cout << divisor(1)    << '\\n';   // 1\n    cout << divisor(12)   << '\\n';   // 6  (1,2,3,4,6,12)\n    cout << divisor(100)  << '\\n';   // 9  (1,2,4,5,10,20,25,50,100)\n    return 0;\n}\n```\n\nFeel free to adapt it for negative numbers (you can first take `abs(n)` and then multiply by `2` to account for negative divisors if that\u2019s required).", "Here\u2019s a concise, fast C++ function that returns the number of positive divisors of a given integer `n`. It uses the prime\u2011factorisation method, which is `O(\u221an)` for a single query and works for 64\u2011bit inputs.\n\n```cpp\n#include <cstdint>   // for int64_t\n#include <cmath>     // for sqrt\n\n// ---------------------------------------------------------------------\n// Count the number of positive divisors of n (n > 0)\n// ---------------------------------------------------------------------\nstd::int64_t divisorCount(std::int64_t n)\n{\n    if (n <= 0) {\n        return 0;        // undefined for non\u2011positive numbers\n    }\n\n    std::int64_t count = 1;\n\n    // Handle factor 2 separately to allow i+=2 later\n    std::int64_t exp = 0;\n    while ((n & 1LL) == 0) {   // n % 2 == 0\n        n >>= 1;\n        ++exp;\n    }\n    if (exp > 0) count *= (exp + 1);\n\n    // Check odd factors only\n    for (std::int64_t i = 3; i <= static_cast<std::int64_t>(std::sqrt(n)); i += 2) {\n        if (n % i == 0) {\n            exp = 0;\n            while (n % i == 0) {\n                n /= i;\n                ++exp;\n            }\n            count *= (exp + 1);\n        }\n    }\n\n    // If n is now > 1, it is a prime factor itself\n    if (n > 1) {\n        count *= 2;   // prime factor exponent = 1 \u2192 (1+1)\n    }\n\n    return count;\n}\n```\n\n### How it works\n\n1. **Handle 2 separately** \u2013 Removing all factors of 2 lets us skip even numbers later.\n2. **Trial division** \u2013 For each odd `i` up to `\u221an`, we count how many times `i` divides `n`.\n3. **Multiplicative property** \u2013 If `n = p\u2081^e1 \u00b7 p\u2082^e2 \u00b7 \u2026`, the number of divisors is  \n   \\((e1+1)(e2+1)\u2026\\).  \n   We accumulate this product in `count`.\n4. **Remaining prime** \u2013 After the loop, any leftover `n > 1` is a prime factor of exponent\u202f1.\n\n### Example usage\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << divisorCount(28) << '\\n'; // 6 (1,2,4,7,14,28)\n    std::cout << divisorCount(13) << '\\n'; // 2 (1,13)\n    std::cout << divisorCount(1) << '\\n';  // 1 (only divisor is 1)\n}\n```\n\nFeel free to adapt the return type (e.g., `long long` or `std::int64_t`) to match your project\u2019s conventions."]}
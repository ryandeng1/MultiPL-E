{"name": "mbpp_285_text_match_two_three", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that checks whether a string contains the 'a' character followed by two or three 'b' characters.\nbool text_match_two_three(std::string text) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_285_text_match_two_three.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = text_match_two_three;\n    assert(candidate((\"ac\")) == (false));\n    assert(candidate((\"dc\")) == (false));\n    assert(candidate((\"abbbba\")) == (true));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a compact, self\u2011contained implementation that works on any modern C++ compiler (C++11 or newer).  \nIt uses the standard library `<regex>` (no need for `bits/stdc++.h` \u2013 that header is non\u2011portable).  \nIf you prefer a manual scan (no regex), the last block shows a pure\u2011C++ solution.\n\n```cpp\n// text_match_two_three.cpp\n//\n//  Check whether a string contains the letter 'a' followed by\n//  either two or three consecutive 'b' characters.\n//\n//  Examples:\n//      \"ab\"        -> false  (only one b)\n//      \"abb\"       -> true   (two b's)\n//      \"abbb\"      -> true   (three b's)\n//      \"aabbb\"     -> true   (first a is followed by 3 b's)\n//      \"bbaabb\"    -> false  (the only 'a' is followed by 1 b)\n\n#include <string>\n#include <regex>\n\n// ------------------------------------------------------------\n// 1) Using std::regex (clean and short)\n// ------------------------------------------------------------\nbool text_match_two_three(const std::string& text)\n{\n    // The pattern: /a(b{2,3})/\n    //  \u2022 'a'  \u2013 the character a\n    //  \u2022 'b{2,3}' \u2013 two or three consecutive b's\n    //  The regex is *global* thanks to the default search: it looks for\n    //  any occurrence inside the string, not just a full\u2011string match.\n    static const std::regex pattern( \"a(b{2,3})\" );\n    return std::regex_search( text, pattern );\n}\n\n\n// ------------------------------------------------------------\n// 2) Pure manual scan (no regex)\n// ------------------------------------------------------------\n/*\nbool text_match_two_three(const std::string& text)\n{\n    const size_t n = text.size();\n    for (size_t i = 0; i < n; ++i)\n    {\n        if (text[i] != 'a') continue;           // look only at \u00b7a\u00b7\n        if (i + 2 >= n) continue;                // need at least two more chars\n\n        // check the next two characters\n        if (text[i+1] == 'b' && text[i+2] == 'b')\n        {\n            // two b's \u2013 success\n            if (i + 3 >= n || text[i+3] != 'b')\n                return true;                    // exactly two b's\n            // if third char is also 'b', still success\n            if (i + 3 < n && text[i+3] == 'b')\n                return true;                    // three b's\n        }\n    }\n    return false;\n}\n*/\n\n\n// ------------------------------------------------------------\n// 3) Simple unit tests (for illustration only)\n// ------------------------------------------------------------\n#ifdef UNIT_TEST\n#include <cassert>\nint main()\n{\n    assert(!text_match_two_three(\"ab\"));\n    assert( text_match_two_three(\"abb\"));\n    assert( text_match_two_three(\"abbb\"));\n    assert(!text_match_two_three(\"abbbb\"));   // four b's \u2013 not allowed\n    assert( text_match_two_three(\"BaabbB\"));  // case sensitive \u2013 fails\n    assert( text_match_two_three(\"aabbbb\"));  // a followed by 4 b's \u2013 still fails\n    assert( text_match_two_three(\"baabb\"));   // a followed by 2 b's \u2013 ok\n    return 0;\n}\n#endif\n```\n\n### How it works\n\n* **Regex version** \u2013  \n  `std::regex_search` scans the whole string for a substring that matches the pattern `a(b{2,3})`.  \n  The `a` must be directly followed by **two or three** consecutive `b`s.  \n  As soon as the search finds such a substring it returns `true`; otherwise it returns `false`.\n\n* **Manual\u2011scan version** \u2013  \n  We iterate over every character.  When an `'a'` is found we check the next two (or three) positions to see if they are `'b'`.  This runs in linear time `O(n)` and has no allocation overhead.\n\nPick the implementation that best fits your constraints: the regex one is shorter and easier to read, while the manual one avoids any runtime cost associated with the regex engine.", "Below is a compact, self\u2011contained implementation of `text_match_two_three`.  \nIt returns **true** when the supplied `std::string` contains the letter **a** followed immediately by **two** or **three** **b**\u2019s anywhere inside the string.\n\n```cpp\n#include <string>\n#include <regex>\n\n/// Checks if the input text contains the pattern \"ab\" or \"abb\".\n/// The match must be contiguous: 'a' followed by two or three 'b's.\n/// Example:   ababc \u2192 true   (contains \"abb\")\n///            aabbb \u2192 true   (contains \"abb\")\n///            aab \u2192 false    (only one 'b')\n///            xyz   \u2192 false\nbool text_match_two_three(const std::string& text)\n{\n    // Regular expression: a followed by either two or three b's.\n    //   ab{2,3}\n    static const std::regex pattern(\"ab{2,3}\");\n    return std::regex_search(text, pattern);\n}\n```\n\n### Why this works\n\n* `ab{2,3}` means:\n  * an `'a'` character\n  * followed by **exactly 2 or 3** occurrences of `'b'`.\n\n* `std::regex_search` scans the whole string and returns `true` as soon as the pattern is found.\n\n### Alternative: manual scan\n\nIf you want to avoid the regular\u2011expression engine (which can be a bit heavy on some embedded platforms), a simple loop does the same:\n\n```cpp\nbool text_match_two_three(const std::string& text)\n{\n    for (size_t i = 0; i + 2 < text.size(); ++i)\n    {\n        if (text[i] == 'a')\n        {\n            if (text[i+1] == 'b' && text[i+2] == 'b')\n            {\n                if (i+3 < text.size() && text[i+3] == 'b')\n                    return true;              // abb  (three b's)\n                return true;                  // ab   (two b's)\n            }\n        }\n    }\n    return false;\n}\n```\n\nBoth implementations satisfy the requirement. Use the regex version for brevity and readability, or the loop version if you want to avoid dynamic allocation that the C++ regex library sometimes performs.", "Here is a complete implementation of `text_match_two_three`.  \nIt scans the string from left to right, and whenever it sees an `'a'`,\nit checks whether the following two or three characters are `'b'`.  \nIf any such pattern is found the function returns `true`, otherwise it\nreturns `false`.\n\n```cpp\n#include <string>\n\n/**\n * @brief   Checks whether a string contains the pattern\n *          'a' followed by exactly two or three 'b' characters.\n *\n * @param   text The string to be examined.\n * @return  true if at least one occurrence of \"abb\" or \"abbb\" is found,\n *          false otherwise.\n */\nbool text_match_two_three(const std::string& text)\n{\n    // We only need to look at positions where an 'a' could start a\n    // pattern.  The longest pattern is 4 characters long, so we can\n    // stop when i > size-4.\n    const std::size_t n = text.size();\n\n    for (std::size_t i = 0; i < n; ++i)\n    {\n        if (text[i] != 'a')\n            continue;\n\n        // Check for \"abb\"\n        if (i + 2 < n && text[i + 1] == 'b' && text[i + 2] == 'b')\n            return true;\n\n        // Check for \"abbb\"\n        if (i + 3 < n &&\n            text[i + 1] == 'b' && text[i + 2] == 'b' && text[i + 3] == 'b')\n            return true;\n    }\n\n    return false;   // no match found\n}\n```\n\n### How it works\n* The function is **const\u2011qualified**\u2014it does not alter the input string.\n* It only needs a single linear pass (`O(n)` time) and constant extra\n  space (`O(1)`).\n* It correctly handles empty strings, strings shorter than the minimal\n  pattern length, and overlapping occurrences (e.g., `\"abbbb\"` will return\n  `true` because it contains `\"abb\"` starting at the second character).\n\n### Example usage\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::string s1 = \"xabbz\";\n    std::string s2 = \"abbbb\";\n    std::string s3 = \"abba\";\n\n    std::cout << text_match_two_three(s1) << '\\n'; // 1 (true)\n    std::cout << text_match_two_three(s2) << '\\n'; // 1 (true)\n    std::cout << text_match_two_three(s3) << '\\n'; // 0 (false)\n\n    return 0;\n}\n```\n\nThe function satisfies the requirement and is ready to use in any C++ project."]}
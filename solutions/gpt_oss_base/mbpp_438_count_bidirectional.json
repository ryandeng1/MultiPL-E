{"name": "mbpp_438_count_bidirectional", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to count bidirectional tuple pairs.\nlong count_bidirectional(std::vector<std::tuple<long, long>> test_list) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_438_count_bidirectional.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = count_bidirectional;\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(5, 6), (std::tuple<long, long>)std::make_tuple(1, 2), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(9, 1), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(2, 1)}))) == (3));\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(5, 6), (std::tuple<long, long>)std::make_tuple(1, 3), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(9, 1), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(2, 1)}))) == (2));\n    assert(candidate((std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(5, 6), (std::tuple<long, long>)std::make_tuple(1, 2), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(9, 2), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(2, 1)}))) == (4));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a fully\u2011working implementation of `count_bidirectional`.  \nThe routine counts **unordered** bidirectional pairs: for a given ordered pair `(a,b)` it checks whether the reverse `(b,a)` exists somewhere in the input vector.  \nEach unordered pair is counted **once** \u2013 i.e. the pair `(a,b)/(b,a)` contributes a single to the total no matter how many times the two ordered tuples appear.\n\n```cpp\n#include <vector>\n#include <tuple>\n#include <unordered_set>\n#include <utility>\n\n// helper that turns a pair of longs into a unique string key\nstatic inline std::string make_key(long a, long b) {\n    return std::to_string(a) + \",\" + std::to_string(b);\n}\n\n/**\n * @brief Counts the number of unordered bidirectional tuple pairs.\n *\n * A bidirectional pair consists of two distinct ordered tuples\n * (x, y) and (y, x).  Multiple occurrences of the same ordered\n * tuple are ignored \u2013 the pair is counted only once.\n *\n * @param test_list vector of ordered tuples (first, second)\n * @return number of unordered bidirectional pairs\n */\nlong count_bidirectional(const std::vector<std::tuple<long, long>>& test_list) {\n    // store all ordered pairs that we have seen\n    std::unordered_set<std::string> seen;\n    // store all unordered pairs that have already been counted\n    std::unordered_set<std::string> counted;\n\n    for (const auto& t : test_list) {\n        long a = std::get<0>(t);\n        long b = std::get<1>(t);\n\n        // ignore self\u2011loops \u2013 they cannot form a bidirectional pair\n        if (a == b) continue;\n\n        std::string key_ab = make_key(a, b);\n        std::string key_ba = make_key(b, a);\n\n        // If the reverse already exists and we haven't counted it yet\n        if (seen.find(key_ba) != seen.end() &&\n            counted.find(key_ab) == counted.end()) {\n            counted.insert(key_ab);   // record that this unordered pair is counted\n        }\n\n        // remember the current ordered pair\n        seen.insert(key_ab);\n    }\n\n    return static_cast<long>(counted.size());\n}\n```\n\n### How it works\n\n1. **Seen Set** \u2013 keeps all ordered tuples we have processed so far.\n2. **Counted Set** \u2013 keeps the unordered pairs that have already been counted (using the canonical order `key_ab`).\n3. For each element `(a,b)`:\n   * Skip if `a==b` (self\u2011loops can\u2019t form a bidirectional pair).\n   * If the reverse `(b,a)` is already in *seen* and the unordered pair hasn\u2019t been counted yet, add `key_ab` to *counted*.\n   * Insert the current ordered pair into *seen*.\n\nThis guarantees:\n* Each unordered pair contributes exactly **one** to the result.\n* Repeated occurrences of the same ordered tuple do not inflate the count.\n\n### Example\n\n```cpp\nstd::vector<std::tuple<long,long>> v = {\n    {1,2}, {2,1}, {3,4}, {4,3}, {1,2}, {2,1}, {5,5}\n};\n\nlong pairs = count_bidirectional(v);  // pairs == 2  (pairs (1,2) and (3,4))\n```\n\nFeel free to adapt the helper `make_key` if you prefer hashing a pair directly (e.g., using `std::unordered_map<std::pair<long,long>, bool, pair_hash>`).", "Here\u2019s a straightforward implementation that counts **bidirectional pairs** \u2013 i.e. for every ordered pair  \n`(a , b)` we check whether the reverse `(b , a)` is also present.  \nEach unordered pair is counted **once** even if there are multiple duplicates.\n\n```cpp\n#include <tuple>\n#include <vector>\n#include <unordered_set>\n#include <cstddef>          // for std::size_t\n#include <functional>       // for std::hash\n#include <algorithm>        // for std::min, std::max\n\n/* ---------- helper for hashing an ordered pair ---------- */\nstruct PairHash\n{\n    std::size_t operator()( const std::pair<long,long>& p ) const noexcept\n    {\n        std::size_t h1 = std::hash<long>()(p.first);\n        std::size_t h2 = std::hash<long>()(p.second);\n        // combine the two hashes\n        return h1 ^ (h2 + 0x9e3779b9 + (h1<<6) + (h1>>2));\n    }\n};\n\n/* ---------- main function ---------- */\nlong count_bidirectional(const std::vector<std::tuple<long,long>>& test_list)\n{\n    // store every ordered pair that appears in the list\n    std::unordered_set<std::pair<long,long>, PairHash> seen;\n    for (const auto& t : test_list)\n        seen.emplace(std::get<0>(t), std::get<1>(t));\n\n    long count = 0;\n    // iterate over the seen set \u2013 count each unordered pair once\n    for (const auto& p : seen)\n    {\n        const auto rev = std::make_pair(p.second, p.first);\n        if (seen.find(rev) != seen.end())\n        {\n            // to avoid double\u2011counting, only count when first < second\n            if (p.first < p.second)\n                ++count;\n        }\n    }\n    return count;\n}\n```\n\n### How it works\n1. **Insert all ordered pairs** into an `unordered_set`.  \n   Duplicate pairs in the input are automatically collapsed \u2013 we only care about existence, not multiplicity.\n\n2. **Scan the set**; for each pair `(a,b)` we look for its reverse `(b,a)`.  \n   When both exist we count the pair **once** by checking `a < b`.  \n   This guarantees that the unordered pair `{a,b}` contributes exactly one to the result.\n\n3. **Return the final count**.\n\n---\n\n#### Example\n\n```cpp\nstd::vector<std::tuple<long,long>> v = {\n    {1,2}, {2,1}, {1,3}, {3,1}, {4,5}\n};\nstd::cout << count_bidirectional(v);   // prints 2 (pairs (1,2) and (1,3))\n```\n\nFeel free to tweak the equality condition (`a < b`) if you need a different tie\u2011breaking rule.", "Here is a simple, self\u2011contained implementation of\u202f`count_bidirectional`.  \nThe idea is:\n\n1. We keep the directed pairs that we have already seen in an unordered set.  \n2. When we encounter a new pair `(u , v)` we ask whether we've already seen the reverse\n   `(v , u)`.  \n   * If we haven't, we simply insert the pair into the set.  \n   * If we have, that means we just found the second edge of a bidirectional pair.\n     We increase the counter and delete the reverse from the set so that the pair\n     cannot be counted again later.\n\nThe code works for `long` key\u2010types, is O(n) on average and uses constant\nextra space per element.\n\n```cpp\n#include <vector>\n#include <tuple>\n#include <unordered_set>\n#include <cstddef>          // for std::size_t\n\n// ---------------------------------------------------------------------------\n// Helper: combine two 64\u2011bit values into a 64\u2011bit hash.\n// ---------------------------------------------------------------------------\nstatic inline std::size_t hash_pair(long a, long b)\n{\n    // 128\u2011bit multiplication would be overkill for 64\u2011bit numbers ...\n    std::size_t h1 = std::hash<long>()(a);\n    std::size_t h2 = std::hash<long>()(b);\n    // 64\u2011bit pattern: shift and XOR\n    return h1 ^ (h2 + 0x9e3779b97f4a7c15ULL + (h1 << 6) + (h1 >> 2));\n}\n\n// ---------------------------------------------------------------------------\n// Default hash functor for a pair<long,long>\n// ---------------------------------------------------------------------------\nstruct pair_hash\n{\n    std::size_t operator()(const std::pair<long,long>& p) const noexcept\n    {\n        return hash_pair(p.first, p.second);\n    }\n};\n\n// ---------------------------------------------------------------------------\n// Count bidirectional tuple pairs.\n// ---------------------------------------------------------------------------\nlong count_bidirectional(const std::vector<std::tuple<long, long>>& test_list)\n{\n    std::unordered_set<std::pair<long,long>, pair_hash> seen;\n    long bidirectional_counter = 0;\n\n    for (const auto& t : test_list)\n    {\n        long u = std::get<0>(t);\n        long v = std::get<1>(t);\n\n        // Ignore self\u2011loops \u2013 they cannot form a bidirectional pair\n        if (u == v)\n            continue;\n\n        std::pair<long,long> forward  = {u, v};\n        std::pair<long,long> reverse  = {v, u};\n\n        if (seen.find(reverse) != seen.end())\n        {\n            // We just found the second directed edge of a pair.\n            ++bidirectional_counter;\n            seen.erase(reverse);          // remove to avoid double counting\n        }\n        else\n        {\n            seen.insert(forward);         // keep this one for later matches\n        }\n    }\n\n    return bidirectional_counter;\n}\n\n// ---------------------------------------------------------------------------\n// Example usage\n// ---------------------------------------------------------------------------\n#ifdef _TEST_COUNT_BIDIRECTIONAL\n#include <iostream>\nint main()\n{\n    std::vector<std::tuple<long,long>> v = {\n        {1,2},{2,1},{3,4},{4,3},{5,6},{5,6},   // only the first 4 form pairs\n        {6,5},{6,5},{7,8},{8,7},{9,9}\n    };\n\n    std::cout << \"Bidirectional pairs: \" << count_bidirectional(v) << '\\n';\n    return 0;\n}\n#endif\n```\n\n### Why this works\n\n* Each directed edge is inspected exactly once.\n* The reverse of a directed edge is searched for in `O(1)` average time.\n* After a bidirectional pair has been counted, we delete the reverse edge so\n  that the pair can never be counted again.  \n  Thus every unordered pair is counted exactly once.\n\nFeel free to compile with `-std=c++17` (or newer).  The `#ifdef _TEST\u2026` block is only\nfor quick local testing and can be omitted."]}
{"name": "mbpp_464_check_value", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to check if all values are same in a map.\nbool check_value(std::map<std::string,long> dict, long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_464_check_value.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = check_value;\n    assert(candidate((std::map<std::string,long>({{\"Cierra Vega\", 12}, {\"Alden Cantrell\", 12}, {\"Kierra Gentry\", 12}, {\"Pierre Cox\", 12}})), (10)) == (false));\n    assert(candidate((std::map<std::string,long>({{\"Cierra Vega\", 12}, {\"Alden Cantrell\", 12}, {\"Kierra Gentry\", 12}, {\"Pierre Cox\", 12}})), (12)) == (true));\n    assert(candidate((std::map<std::string,long>({{\"Cierra Vega\", 12}, {\"Alden Cantrell\", 12}, {\"Kierra Gentry\", 12}, {\"Pierre Cox\", 12}})), (5)) == (false));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a compact implementation that verifies whether every value in a `std::map<std::string,long>` is equal to the supplied `n`.  \nIf you only want to know whether the values are *uniform* (not necessarily equal to `n`), just remove the comparison with `n`.\n\n```cpp\n#include <map>\n#include <string>\n\n/**\n * @brief Returns true if every value in the map is equal to `n`, otherwise false.\n *\n * @param dict   The map whose values we want to check.\n * @param n      The value to compare against.\n *\n * @return true  All values in `dict` are equal to `n`.\n * @return false Some value differs, or the map is empty.\n */\nbool check_value(const std::map<std::string, long>& dict, long n)\n{\n    // For an empty map we consider the condition \"true\" (trivially satisfied).\n    if (dict.empty())\n        return true;\n\n    for (const auto& kv : dict)\n    {\n        if (kv.second != n)\n            return false;   // Found a mismatch\n    }\n    return true;   // All values matched\n}\n```\n\n**Usage example**\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::map<std::string, long> m = { {\"a\", 5}, {\"b\", 5}, {\"c\", 5} };\n    std::cout << std::boolalpha << check_value(m, 5) << '\\n';  // prints true\n\n    m[\"b\"] = 3;\n    std::cout << check_value(m, 5) << '\\n';  // prints false\n}\n```\n\nThe function is simple, linear\u2011time in the number of elements, and uses only standard C++ facilities.", "Here\u2019s a concise implementation that works for any `std::map<std::string, long>` (you can change the value type if desired).  \nThe function simply scans the map and checks whether every value equals `n`.\n\n```cpp\n#include <map>\n#include <string>\n\n/* ----------------------------------------------------\n   Returns true if *all* values in the map equal n.\n   ---------------------------------------------------- */\nbool check_value(const std::map<std::string, long> &dict, long n)\n{\n    // If the map is empty \u2013 by convention, we say all values are equal to n\n    if (dict.empty())\n        return true;\n\n    // Find the first value\n    auto it = dict.begin();\n\n    // If the map contains more than one element, compare each with n\n    for (; it != dict.end(); ++it)\n    {\n        if (it->second != n)\n            return false;          // mismatch found\n    }\n\n    return true;                    // every value matched n\n}\n```\n\n### Why this is reliable\n\n1. **Const\u2011correct** \u2013 the map is taken by `const &`, so the function never modifies the caller\u2019s data.\n2. **Early exit** \u2013 the first mismatching element stops the scan immediately.\n3. **Edge case** \u2013 an empty map returns `true`; you can change that if you prefer `false`.\n\n### Usage example\n\n```cpp\n#include <iostream>\n#include <map>\n\nint main()\n{\n    std::map<std::string,long> m = {{\"a\",3}, {\"b\",3}, {\"c\",3}};\n    std::cout << std::boolalpha << check_value(m, 3) << '\\n'; // prints: true\n\n    m[\"c\"] = 4;\n    std::cout << std::boolalpha << check_value(m, 3) << '\\n'; // prints: false\n}\n```\n\nFeel free to adapt the function to other container types or value types just by changing the template parameters.", "Below is a compact, idiomatic implementation that answers the question \u201care **every** entry in the map equal to the supplied value `n`?\u201d.  \nIf the map is empty we return `true` \u2013 an empty set of values trivially satisfies the \u201call\u2011equal\u201d condition.\n\n```cpp\n#include <map>\n#include <string>\n\n// Check whether every value stored in `dict` is equal to `n`.\nbool check_value(const std::map<std::string, long>& dict, long n) {\n    // Early exit for an empty map \u2013 nothing contradicts `n`.\n    if (dict.empty())\n        return true;\n\n    // Iterate through the map and compare each value to `n`.\n    for (const auto& entry : dict) {\n        if (entry.second != n)\n            return false;          // Found a mismatch \u2013 condition failed.\n    }\n    return true;                   // All values matched `n`.\n}\n```\n\n### Why this version?\n\n| Feature | Why it matters |\n|---------|----------------|\n| **`const` reference parameter** | Avoids copying the map, making the call O(1) in terms of argument passing. |\n| **Range\u2011based for loop** | Clear and concise; compiler uses iterators efficiently. |\n| **Early\u2011return on mismatch** | Stops as soon as a counter\u2011example is found \u2013 the best\u2011case is O(1). |\n| **Explicit handling of empty map** | Avoids undefined behaviour and keeps semantics clear (empty maps \u201cpass\u201d). |\n\nYou can call it like this:\n\n```cpp\nstd::map<std::string,long> m{\n    {\"a\",10},\n    {\"b\",10},\n    {\"c\",10},\n};\nbool allTen = check_value(m, 10);   // true\n```\n\nFeel free to tweak the behaviour for empty maps (e.g., returning `false`) by removing the initial `if (dict.empty()) \u2026` block."]}
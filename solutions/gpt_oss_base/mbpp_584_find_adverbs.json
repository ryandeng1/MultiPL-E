{"name": "mbpp_584_find_adverbs", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the first adverb ending with ly and its positions in a given string.\nstd::string find_adverbs(std::string text) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_584_find_adverbs.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = find_adverbs;\n    assert(candidate((\"Clearly, he has no excuse for such behavior.\")) == (\"0-7: Clearly\"));\n    assert(candidate((\"Please handle the situation carefuly\")) == (\"28-36: carefuly\"));\n    assert(candidate((\"Complete the task quickly\")) == (\"18-25: quickly\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["```cpp\n#include <string>\n#include <cctype>\n#include <algorithm>\n\n/*\n * find_adverbs\n *\n * Given an English\u2011style text, locate the first adverb that ends with the suffix\n * \u201cly\u201d (case\u2011insensitive).  The function returns a string that contains:\n *\n *      <adverb>   <start_pos>   <end_pos>\n *\n *  where <start_pos> is the index of the first character of the adverb\n *  (0\u2011based) and <end_pos> is one past the last character (as returned by\n *  string::substr).  If no such adverb is found the function returns an\n *  empty string.\n *\n *  The implementation is deliberately simple: we split the string on\n *  whitespace and punctuation, then examine each token.  We treat a token\n *  as an adverb if it ends with \u201cly\u201d (case\u2011insensitive) and consists only\n *  of alphabetic characters.  The first matching token is returned.\n */\n\nstd::string find_adverbs(const std::string &text)\n{\n    // Flag to detect the first match\n    bool found = false;\n\n    // Indices that lead to the warning that the compiler might produce\n    // in strict mode.  The original index will be stored when the\n    // candidate adverb is found.\n    std::string adverb;\n    size_t startIndex = 0, endIndex = 0;\n\n    // Let's walk through the string character by character.\n    for (size_t i = 0; i < text.size(); ++i)\n    {\n        // Skip non\u2011alphabetic characters \u2013 they serve as delimiters.\n        if (!std::isalpha(static_cast<unsigned char>(text[i])))\n            continue;\n\n        // We are at the first letter of a word; locate the word's end.\n        size_t j = i;\n        while (j < text.size() && std::isalpha(static_cast<unsigned char>(text[j])))\n            ++j;\n\n        // Extract the word.\n        std::string word = text.substr(i, j - i);\n\n        // Check the suffix \u201cly\u201d (case\u2011insensitive).\n        if (word.size() >= 2)\n        {\n            std::string suffix = word.substr(word.size() - 2);\n            std::transform(suffix.begin(), suffix.end(), suffix.begin(), ::tolower);\n            if (suffix == \"ly\")\n            {\n                // We found the first adverb with the \u201cly\u201d suffix.\n                adverb = word;\n                startIndex = i;\n                endIndex   = j; // endIndex is exclusive\n                found = true;\n                break;   // stop searching\n            }\n        }\n\n        // Continue scanning from the end of this word.\n        i = j - 1; // the for\u2011loop will increment i again\n    }\n\n    if (!found)\n        return {};\n\n    // Build the result: adverb + start + end (space separated).\n    return adverb + \" \" + std::to_string(startIndex) + \" \" + std::to_string(endIndex);\n}\n```\n\n**How it works**\n\n1. The function scans the text one character at a time.  \n2. Whenever it encounters an alphabetic character, it treats it as the start of a word and consumes all consecutive alphabetic characters to find the word\u2019s end.  \n3. The word is checked for the suffix \u201cly\u201d (case\u2011insensitive).  \n4. As soon as a match is found, the word and its start/end indices are stored and the search stops.  \n5. The function returns a single string containing the adverb and its positions, separated by spaces.  \n6. If the text contains no \u201cly\u201d adverb, an empty string is returned.\n\nFeel free to adjust the return format if you prefer a different representation (e.g., a struct or a tuple).", "Below is a compact, self\u2011contained C++ implementation that walks through the given text, looks for the first word that ends in \u201cly\u201d, and returns a short report containing the word itself as well as the **start** and **end** character positions (0\u2011based indices).  \nFeel free to adjust the return format if you need a different output.\n\n```cpp\n#include <string>\n#include <cctype>\n#include <sstream>\n#include <iomanip>\n\n/**\n * @brief Finds the first adverb that ends with \u201cly\u201d and returns it together\n *        with its start and end positions inside the original string.\n *\n * @param text  The input string to search.\n * @return      A string in the form:\n *                \"adverb: <adverb>, start: <start>, end: <end>\"\n *              If no such adverb exists, returns an empty string.\n *\n *              Example:   \"apple kindly eight\"\n *              Result:    \"adverb: kindly, start: 7, end: 12\"\n */\nstd::string find_adverbs(const std::string& text)\n{\n    const std::size_t n = text.size();\n    std::string word;\n    std::size_t word_start = std::string::npos;  // index of the first char of the current word\n\n    for (std::size_t i = 0; i <= n; ++i) {\n        char c = (i < n) ? text[i] : '\\0';   // sentinel to treat end-of-string as delimiter\n\n        if (std::isalpha(static_cast<unsigned char>(c))) {\n            // Start of a new word?\n            if (word_start == std::string::npos)\n                word_start = i;\n            word.push_back(c);\n        }\n        else {\n            // We hit a delimiter (or end of string). Evaluate the word if any.\n            if (!word.empty()) {\n                // Must be at least 3 letters: 'ly' plus at least one more letter\n                if (word.size() >= 3 &&\n                    word.substr(word.size() - 2, 2) == \"ly\") {\n                    std::ostringstream oss;\n                    oss << \"adverb: \" << word\n                        << \", start: \" << word_start\n                        << \", end: \"   << (i - 1);   // i points to delimiter\n                    return oss.str();\n                }\n            }\n            // Reset for next word\n            word.clear();\n            word_start = std::string::npos;\n        }\n    }\n    return \"\";   // No adverb ending with 'ly' found\n}\n```\n\n### How it works\n1. **Word extraction** \u2013 Scan the string character by character.  \n   Accumulate alphabetic characters into `word` and remember the index where the word begins (`word_start`).  \n   Any non\u2011alphabetic character (including the sentinel `\\0` added at the end) marks the end of a word.\n\n2. **Adverb check** \u2013 When a word ends, verify that its length is at least 3 and that the last two characters are `\"ly\"`. If so, the word is an adverb of the requested form.\n\n3. **Return value** \u2013 As soon as the first matching adverb is found, build a human\u2011readable report containing the adverb, its start index, and its last index (inclusive). If the scan finishes without finding any such word, an empty string is returned.\n\nFeel free to drop this function into your project or adapt the output format to your specific needs. Happy coding!", "Below is a self\u2011contained implementation of the function.  \nIt scans the string from left to right, looks for whole\u2011word tokens that end with **\u201cly\u201d**, and returns the first such adverb together with its start and end positions (0\u2011based indices).  \nIf no adverb is found, an empty string is returned.\n\n```cpp\n#include <string>\n#include <cctype>\n#include <utility>\n\n/*--------------------------------------------------------------------\n  return the first adverb that ends with \"ly\" and its position.\n  The function returns a string of the form\n        \"adverb:start:end\"\n  e.g.  \"quickly:5:13\"\n\n  If no such adverb exists, the function returns an empty string.\n -------------------------------------------------------------------*/\nstd::string find_adverbs(const std::string& text)\n{\n    const std::string suffix = \"ly\";\n    const size_t n = text.size();\n    size_t i = 0;\n\n    while (i < n) {\n        /* skip non\u2011alphabetic characters \u2013 they are word separators */\n        while (i < n && !std::isalpha(static_cast<unsigned char>(text[i])))\n            ++i;\n        if (i >= n) break;\n\n        size_t word_start = i;\n\n        /* find the end of the word */\n        while (i < n && std::isalpha(static_cast<unsigned char>(text[i])))\n            ++i;\n        size_t word_end = i;          // first index after the word\n\n        /* check if the word ends with \u201cly\u201d */\n        if (word_end - word_start >= suffix.size() &&\n            text.compare(word_end - suffix.size(), suffix.size(), suffix) == 0) {\n            // return \"adverb:start:end\" (end is exclusive)\n            return text.substr(word_start, word_end - word_start) + \":\" +\n                   std::to_string(word_start) + \":\" +\n                   std::to_string(word_end);\n        }\n    }\n    return \"\";\n}\n```\n\n### How it works\n\n1. **Tokenisation** \u2013 The string is walked character by character.  \n   Non\u2011alphabetic characters (`space`, punctuation, digits, \u2026) are treated as word separators.  \n   The indices `word_start` and `word_end` delimit an entire word.\n\n2. **Suffix check** \u2013 For each word, we compare its last two letters with `\"ly\"`.  \n   The comparison is case\u2011sensitive; if you need a case\u2011insensitive search, convert the word to lower case before the comparison.\n\n3. **Return format** \u2013 On success, the function builds the returned string  \n   `adverb:start:end`, where `start` is the index of the First character of the adverb, and `end` is the index past the last character (exclusive).  \n   If no matching adverb exists, an empty string is returned.\n\nFeel free to adapt the return format or the case\u2011handling to fit your particular use\u2011case."]}
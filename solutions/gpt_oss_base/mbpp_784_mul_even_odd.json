{"name": "mbpp_784_mul_even_odd", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the product of first even and odd number of a given vector.\nlong mul_even_odd(std::vector<long> list1) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_784_mul_even_odd.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = mul_even_odd;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)7, (long)4, (long)1, (long)6, (long)8}))) == (4));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10}))) == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)5, (long)7, (long)9, (long)10}))) == (10));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a clean, self\u2011contained implementation that follows the standard C++ style guidelines and works for any `std::vector<long>` you feed in.\n\n```cpp\n#include <vector>\n#include <utility>\n\n/**\n * @brief Computes the product of the first even and first odd numbers\n *        found in @p nums.\n *\n * The function walks through the vector once, keeping track of the first\n * even and the first odd number that appear.  When both have been\n * found, the loop can terminate early.  If one or both of those\n * numbers do not exist the product is simply the value of the existing\n * number(s) (i.e. `0` if neither exists).\n *\n * @param nums vector of long integers to search\n * @return long product of the first even and the first odd numbers\n */\nlong mul_even_odd(const std::vector<long>& nums)\n{\n    long first_even = 0;\n    long first_odd  = 0;\n    bool even_found = false;\n    bool odd_found  = false;\n\n    for (long num : nums)\n    {\n        if (!even_found && (num % 2 == 0))\n        {\n            first_even = num;\n            even_found = true;\n        }\n        else if (!odd_found && (num % 2 != 0))\n        {\n            first_odd = num;\n            odd_found = true;\n        }\n\n        // Early exit: we found both numbers\n        if (even_found && odd_found)\n            break;\n    }\n\n    // If one of the numbers was never found we treat it as 1 (neutral\n    // element for multiplication) so that the product is simply the\n    // existing number.  If both are missing we return 0.\n    if (!even_found && !odd_found) return 0;\n    if (!even_found) return first_odd;\n    if (!odd_found ) return first_even;\n\n    return first_even * first_odd;\n}\n```\n\n### How to use it\n\n```cpp\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<long> v1{3, 7, 8, 12, 5};\n    std::cout << mul_even_odd(v1) << '\\n';  // 7*8 = 56\n\n    std::vector<long> v2{2, 4, 10};\n    std::cout << mul_even_odd(v2) << '\\n';  // only even numbers \u2192 2\n\n    std::vector<long> v3{5, 9, 13};\n    std::cout << mul_even_odd(v3) << '\\n';  // only odd numbers  \u2192 5\n\n    std::vector<long> v4{};\n    std::cout << mul_even_odd(v4) << '\\n';  // no numbers \u2192 0\n}\n```\n\n### Why this approach?\n\n| Feature | Why it matters |\n|---------|----------------|\n| **Single pass** | Linear\u2011time (`O(n)`) regardless of vector length. |\n| **Early exit** | Stops as soon as both numbers are found, saving work. |\n| **No extra memory** | Only a few primitives are used, regardless of vector size. |\n| **Robust edge handling** | Handles empty vectors, vectors with only evens / only odds, or no qualifying numbers gracefully. |\n| **Clear intent** | Variables and comments explain what is happening at each step. |\n\nFeel free to drop this function into any project that needs the product of the first even and odd numbers in a vector!", "Below is a clean, self\u2011contained implementation that follows the requirement:\n\n```cpp\n#include <vector>\n#include <stdexcept>   // for std::runtime_error\n\n/// @brief  Return the product of the first even number and the first odd number in @p v.\n/// @param  v  A vector of integers.\n/// @return product of the first even element and the first odd element.\n/// @throws std::runtime_error   if  v contains no even or no odd element.\nlong mul_even_odd(const std::vector<long>& v)\n{\n    long first_even = 0;   // will hold the first even value\n    long first_odd  = 0;   // will hold the first odd  value\n    bool got_even = false;\n    bool got_odd  = false;\n\n    for (const long x : v)\n    {\n        if (!got_even && (x % 2 == 0))\n        {\n            first_even = x;\n            got_even = true;\n        }\n        if (!got_odd && (x % 2 != 0))\n        {\n            first_odd = x;\n            got_odd = true;\n        }\n        if (got_even && got_odd) break;   // we have both numbers\n    }\n\n    if (!got_even || !got_odd)\n        throw std::runtime_error(\"Vector must contain at least one even AND one odd number\");\n\n    return first_even * first_odd;\n}\n```\n\n### How it works\n\n* The function scans the vector once, keeping track of the first even and the first odd number it encounters.\n* As soon as both have been found it stops the loop (`break`), making the algorithm **O(n)** with **O(1)** additional space.\n* If the vector does not contain both types of numbers, the function throws a run\u2011time exception so the caller knows that the input was invalid.\n\nFeel free to replace the exception with any other error\u2011handling strategy that fits your larger code base (e.g., returning a sentinel value or using `std::optional<long>` in C++17+).", "Below is a clean, self\u2011contained implementation of the requested helper:\n\n```cpp\n#include <vector>\n#include <optional>\n#include <stdexcept>\n\n/**\n * @brief  Returns the product of the first even number and the first odd number\n *         found in the input vector.\n *\n * @param  nums  A vector of long integers.\n * @return       product = first_even * first_odd\n *\n * @throws std::invalid_argument if the vector does not contain an even or an\n *                               odd number.\n *\n * Example\n * -------\n * For nums = {3, 4, 7, 8, 5}\n *     first even  = 4\n *     first odd   = 3\n *     product     = 4 * 3 = 12\n */\nlong mul_even_odd(const std::vector<long>& nums)\n{\n    std::optional<long> first_even;\n    std::optional<long> first_odd;\n\n    for (const auto& x : nums) {\n        if (x % 2 == 0 && !first_even.has_value()) {\n            first_even = x;\n        } else if (x % 2 != 0 && !first_odd.has_value()) {\n            first_odd = x;\n        }\n\n        // Short\u2011circuit once we have both\n        if (first_even.has_value() && first_odd.has_value())\n            break;\n    }\n\n    if (!first_even.has_value() || !first_odd.has_value())\n        throw std::invalid_argument(\"Vector must contain at least one even and one odd number\");\n\n    return first_even.value() * first_odd.value();\n}\n```\n\n### How it works\n\n1. **Iteration** \u2013 We scan the vector once, storing the first even and the first odd number encountered.\n2. **Early exit** \u2013 As soon as we have both numbers we break out of the loop to avoid unnecessary work.\n3. **Error handling** \u2013 If either kind of number is missing we throw an exception; this choice is preferable to silently returning `0` because the caller can then decide how to handle the error.\n4. **Return** \u2013 The product of the two numbers is returned.\n\nFeel free to adapt the error\u2011handling behaviour (e.g., return `0` or `-1`) to fit your project\u2019s conventions."]}
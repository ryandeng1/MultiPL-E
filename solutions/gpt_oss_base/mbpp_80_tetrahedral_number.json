{"name": "mbpp_80_tetrahedral_number", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the nth tetrahedral number.\nlong tetrahedral_number(long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_80_tetrahedral_number.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = tetrahedral_number;\n    assert(candidate((5)) == (35));\n    assert(candidate((6)) == (56));\n    assert(candidate((7)) == (84));\n}\n", "stop_tokens": ["\n}"], "completions": ["```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// ------------------------------------------------------------\n//  Find the n\u2011th tetrahedral number\n//  ------------------------------------------------------------\n//  A tetrahedral number is the sum of the first n triangular\n//  numbers.  Its closed form is:\n//\n//          n ( n + 1 ) ( n + 2 ) / 6\n//\n//  We compute it using 64\u2011bit arithmetic to avoid overflow\n//  for reasonable values of n.  If a request for a larger n\n//  that would overflow `long` is made, the behaviour is\n//  undefined \u2013 this matches the behaviour of the rest of\n//  the standard library for 64\u2011bit arithmetic.\n//\n//  Arguments:\n//      n \u2013 1\u2011based index of the tetrahedral number\n//\n//  Returns:\n//      the n\u2011th tetrahedral number as a `long` value\n// ------------------------------------------------------------\nlong tetrahedral_number(long n)\n{\n    // 0\u2011based input is not defined; treat as error\n    assert(n >= 1 && \"tetrahedral_number: n must be >= 1\");\n\n    // To minimise the chance of intermediate overflow we\n    // perform the multiplication in an unsigned long long\n    // which guarantees at least 64\u202fbits of precision.\n    unsigned long long a = static_cast<unsigned long long>(n);\n    unsigned long long res = a * (a + 1) * (a + 2) / 6;\n\n    // Cast back to long (the caller must ensure the value fits)\n    return static_cast<long>(res);\n}\n\n// Example usage\nint main() {\n    for (long i = 1; i <= 10; ++i) {\n        cout << \"T(\" << i << \") = \" << tetrahedral_number(i) << '\\n';\n    }\n    return 0;\n}\n```", "Here\u2019s a compact, fully\u2011portable implementation that returns the *n*\u2011th tetrahedral number:\n\n```cpp\n#include <cstdint>   // for std::int64_t\n\n// ---------------------------------------------------------------------------\n// Return the nth tetrahedral number.\n//   T(n) = 1 + 4 + 10 + ... (n terms) = n(n+1)(n+2)/6\n// ---------------------------------------------------------------------------\ninline std::int64_t tetrahedral_number(std::int64_t n)\n{\n    // The formula is safe for n up to ~1.8e6 on a 64\u2011bit platform\n    // because (n)(n+1)(n+2)/6 fits in a signed 64\u2011bit integer.\n    // If you need larger values, switch to a bigger integer type.\n    return n * (n + 1) * (n + 2) / 6;\n}\n```\n\n### Why this works\n\n- **Mathematics** \u2013 The nth tetrahedral number equals the sum of the first *n* triangular numbers, giving the closed\u2011form expression  \n  \\[\n  T(n) = \\frac{n(n+1)(n+2)}{6}.\n  \\]\n- **Overflow safety** \u2013 We multiply first, then divide by `6`. For signed 64\u2011bit integers the maximum safe `n` is around 1.8\u202f\u00d7\u202f10\u2076. If you expect larger inputs, use a 128\u2011bit type such as `__int128` (on GCC/Clang) or a bigint library.\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    for (long long i = 1; i <= 10; ++i) {\n        std::cout << \"T(\" << i << \") = \" << tetrahedral_number(i) << '\\n';\n    }\n    return 0;\n}\n```\n\nOutput:\n\n```\nT(1) = 1\nT(2) = 4\nT(3) = 10\nT(4) = 20\nT(5) = 35\nT(6) = 56\nT(7) = 84\nT(8) = 120\nT(9) = 165\nT(10) = 220\n```\n\nFeel free to adjust the return type or add error checking if you need to handle negative or particularly large inputs.", "Here is a concise and safe implementation of the tetrahedral\u2011number routine:\n\n```cpp\n#include <cassert>\n#include <cstdint>   // for int64_t\n\n// Return the n\u2011th tetrahedral number (n \u2265 1).\n// The result fits in a signed 64\u2011bit integer for n up to about 10\u2076.\ninline int64_t tetrahedral_number(int64_t n) {\n    assert(n >= 1);                     // misuse check\n\n    // Use 128\u2011bit arithmetic to avoid overflow when evaluating\n    // n*(n+1)*(n+2)/6 for large n.\n    __int128 product = static_cast<__int128>(n) *\n                       (n + 1) * (n + 2);\n    product /= 6;                       // exact division\n\n    return static_cast<int64_t>(product);\n}\n```\n\n### How it works\n* **Formula** \u2013 The nth tetrahedral number is the sum of the first *n* triangular numbers:\n  \\[\n  T_n = \\frac{n(n+1)(n+2)}{6}.\n  \\]\n* **Overflow prevention** \u2013 The intermediate product *n\u00b7(n+1)\u00b7(n+2)* can exceed 64\u2011bit bounds even for modest `n`.  \n  Using GCC/Clang\u2019s `__int128` (available on most competitive\u2011programming platforms) guarantees correctness for all `n` that fit within a 64\u2011bit integer.\n* **Return type** \u2013 After division, the result fits neatly back into a signed 64\u2011bit integer (`int64_t`).\n\nFeel free to drop this snippet into your program or adjust the type (`long long`, `unsigned long long`, etc.) to suit your environment."]}
{"name": "mbpp_801_test_three_equal", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to count the number of equal numbers from three given integers.\nlong test_three_equal(long x, long y, long z) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_801_test_three_equal.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = test_three_equal;\n    assert(candidate((1), (1), (1)) == (3));\n    assert(candidate((-1), (-2), (-3)) == (0));\n    assert(candidate((1), (2), (2)) == (2));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a minimal C++ implementation that counts how many among **three** integers are equal. The function returns:\n\n* `3` \u2013 all three numbers are the same.  \n* `2` \u2013 exactly two of them match.  \n* `1` \u2013 no two numbers are equal.   (you could also return `0` in that case \u2013 the logic below counts distinct values.)\n\n```cpp\n#include <cstdint>\n#include <cassert>\n\n// -----------------------------------------------------------------------------\n// Count how many of the three values are equal\n//\n// Returns 3 if x==y==z, 2 if two are equal, 1 otherwise.\n// -----------------------------------------------------------------------------\nint test_three_equal(long x, long y, long z)\n{\n    // Quick shortcut: all three equal\n    if (x == y && y == z) return 3;\n\n    // Count pairs that are equal\n    int equalPairs = 0;\n    if (x == y) ++equalPairs;\n    if (y == z) ++equalPairs;\n    if (x == z) ++equalPairs;\n\n    // Each pair represents one shared value.  If two numbers match,\n    // equalPairs will be 1.  If all three are different, it will be 0.\n    return equalPairs + 1;   // maps 0 \u2192 1, 1 \u2192 2\n}\n\n// -----------------------------------------------------------------------------\n// Test harness (optional, can be omitted in production)\nint main()\n{\n    assert(test_three_equal(5, 5, 5) == 3);\n    assert(test_three_equal(7, 7, 3) == 2);\n    assert(test_three_equal(1, 2, 3) == 1);\n\n    // If you prefer 0 for all-distinct case, change the return line above to:\n    // return equalPairs; // 0,1,2\n    return 0;\n}\n```\n\n**Explanation**\n\n1. **All equal** \u2013 the most obvious case; we can check directly in one statement.  \n2. **Count equal pairs** \u2013 there are three possible pairs (`x==y`, `y==z`, `x==z`).  \n   * If exactly one of them evaluates to `true`, only two numbers match.  \n   * If none are `true`, all numbers are distinct.  \n3. **Return value** \u2013 adding `1` turns `0` (distinct) into `1` (you can interpret it as \u201conly one distinct value\u201d if that makes sense for your application).  \n   If you\u2019d rather return `0` for the distinct case, just return `equalPairs` directly.\n\nFeel free to tweak the return convention to fit your exact needs!", "```cpp\n// ------------------------------------------------------------------\n//  Count how many of the three integers are equal\n//  A return value of 3 means all three are the same\n//  A return value of 2 means two are the same and the third is different\n//  A return value of 1 means all three are different\n// ------------------------------------------------------------------\nlong test_three_equal(long x, long y, long z)\n{\n    // Simple comparison logic:\n    // 1) If all three are equal \u2192 3\n    // 2) If exactly two are equal \u2192 2\n    // 3) Otherwise (all distinct) \u2192 1\n    if (x == y && y == z)\n        return 3;\n\n    if (x == y || y == z || x == z)\n        return 2;\n\n    return 1;\n}\n```\n\n**Explanation**\n\n1. **All three equal** \u2013 `x == y && y == z` captures that situation explicitly.  \n2. **Exactly two equal** \u2013 If the previous check fails, we only need to see if any pair matches (`x==y || y==z || x==z`).  \n3. **All distinct** \u2013 If none of the above conditions are true, we return `1`.\n\nThe function returns a `long` just as the prototype requested, but the actual value always lies in `{1,2,3}`.", "Here is a compact and clear C++ implementation that returns how many of the three arguments are equal to each other.  \nThe function simply checks the different equality cases, but you can also think of it as counting the size of the set `{x, y, z}` and using the fact that:\n\n```\nnumber of equal pairs = 3 - (size of the set)\n```\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Count how many of the three given integers are equal.\n// Returns:\n//   3 \u2013 all three values are the same\n//   2 \u2013 exactly two values are equal\n//   1 \u2013 all values are distinct\n//   0 \u2013 (this case never occurs with 3 numbers, kept for completeness)\nint test_three_equal(long x, long y, long z)\n{\n    if (x == y && y == z)            // all three equal\n        return 3;\n    if (x == y || y == z || x == z)  // exactly two equal\n        return 2;\n    return 1;                        // all distinct\n}\n\n/* ------------  Example usage  ------------ */\nint main()\n{\n    assert(test_three_equal(5, 5, 5) == 3);\n    assert(test_three_equal(2, 2, 3) == 2);\n    assert(test_three_equal(4, 7, 4) == 2);\n    assert(test_three_equal(1, 2, 3) == 1);\n\n    cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\n**Explanation**\n\n1. **All three equal** \u2013 `x == y && y == z` covers the case where every pair is equal.\n2. **Exactly two equal** \u2013 if any one of the three pairwise comparisons is true, we have a pair that matches while the third value is different.\n3. **All distinct** \u2013 if none of the above conditions hold, all three numbers differ from each other.\n\nThe function\u2019s time complexity is **O(1)**, and it uses only a few comparisons, making it efficient for any input."]}
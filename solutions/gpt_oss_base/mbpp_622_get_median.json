{"name": "mbpp_622_get_median", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the median of two sorted vectors of same size.\nfloat get_median(std::vector<long> arr1, std::vector<long> arr2, long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_622_get_median.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = get_median;\n    assert(candidate((std::vector<long>({(long)1, (long)12, (long)15, (long)26, (long)38})), (std::vector<long>({(long)2, (long)13, (long)17, (long)30, (long)45})), (5)) == (16.0f));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)9})), (std::vector<long>({(long)7, (long)13, (long)19, (long)28})), (4)) == (8.5f));\n    assert(candidate((std::vector<long>({(long)3, (long)6, (long)14, (long)23, (long)36, (long)42})), (std::vector<long>({(long)2, (long)18, (long)27, (long)39, (long)49, (long)55})), (6)) == (25.0f));\n}\n", "stop_tokens": ["\n}"], "completions": ["Sure! Below is a complete implementation of `get_median` that works for two sorted vectors of the **same size**.  \nThe function merges the two vectors in linear time (`O(n)`), finds the two middle elements and returns their average.\n\n```cpp\n#include <cassert>\n#include <vector>\n\n/*\n * Returns the median of two sorted vectors of equal size.\n *\n *   arr1, arr2  -> input sorted vectors\n *   n           -> size of each vector\n *\n * If n is odd, the median is the single middle element.\n * If n is even, the median is the average of the two middle elements.\n *\n * Preconditions\n *   - arr1.size() == arr2.size() == n\n */\nfloat get_median(std::vector<long> arr1, std::vector<long> arr2, long n)\n{\n    // Sanity check\n    assert( static_cast<long>(arr1.size()) == n &&\n            static_cast<long>(arr2.size()) == n );\n\n    /* ----- 1. Merge the two vectors in linear time ---------- */\n    std::vector<long> merged;\n    merged.reserve(2 * n);\n\n    size_t i = 0, j = 0;\n    while (i < arr1.size() && j < arr2.size()) {\n        if (arr1[i] < arr2[j]) {\n            merged.push_back(arr1[i++]);\n        } else {\n            merged.push_back(arr2[j++]);\n        }\n    }\n    /* copy the remaining part of the non\u2011exhausted vector */\n    while (i < arr1.size()) merged.push_back(arr1[i++]);\n    while (j < arr2.size()) merged.push_back(arr2[j++]);\n\n    /* ----- 2. Compute the median ----------------------------- */\n    long mid1 = 2 * n - 1;            // zero\u2011based index of first middle\n    long mid2 = 2 * n - 2;            // zero\u2011based index of second middle\n\n    if (n % 2 == 1) {                // odd number of elements\n        return static_cast<float>(merged[mid2]);   // mid2 == mid1\n    } else {                          // even number of elements\n        return (merged[mid1] + merged[mid2]) / 2.0f;\n    }\n}\n```\n\n### How it works\n1. **Merge** \u2013 We merge the two sorted arrays `arr1` and `arr2` into a single sorted vector `merged`.  \n   This step takes `O(n)` time because each element is inspected only once.\n\n2. **Find the median** \u2013  \n   - If `n` is odd, the merged array has `2n` elements, so the median is at index `2n\u20111 / 2`.  \n   - If `n` is even, the median is the average of the two middle elements `merged[2n-2]` and `merged[2n-1]`.\n\nBecause the two input vectors are of the same size, the algorithm\u2019s time complexity is linear and its memory usage is `O(n)` (for the merged vector).", "Here is a compact, **O(log\u202fn)** solution that works for two sorted vectors of equal size (`n`).  \nThe idea is to perform a binary\u2011search\u2011style partition on the two arrays so that the\nleft halves contain exactly `n` elements and the right halves contain the remaining\n`n` elements. Once a correct partition is found the median can be computed directly.\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <cmath>          // for std::ceil\n\n// Median of two sorted arrays of equal size\nfloat get_median(const std::vector<long>& arr1,\n                 const std::vector<long>& arr2,\n                 long n)\n{\n    // We work with the first array as the \u201csmaller\u201d array,\n    // but the algorithm works regardless of the order.\n    const std::vector<long>* a = &arr1; // alias for easier indexing\n    const std::vector<long>* b = &arr2;\n\n    long low  = 0;\n    long high = n;          // we can take 0 .. n elements from a\n\n    while (low <= high)\n    {\n        long i = (low + high) / 2;           // elements taken from a\n        long j = n - i;                      // elements taken from b\n\n        long aLeft  = (i == 0)  ? LLONG_MIN : (*a)[i - 1];\n        long aRight = (i == n)  ? LLONG_MAX : (*a)[i];\n\n        long bLeft  = (j == 0)  ? LLONG_MIN : (*b)[j - 1];\n        long bRight = (j == n)  ? LLONG_MAX : (*b)[j];\n\n        if (aLeft <= bRight && bLeft <= aRight)\n        {\n            // Correct partition found\n            long leftMax  = std::max(aLeft,  bLeft);\n            long rightMin = std::min(aRight, bRight);\n            return static_cast<float>(leftMax + rightMin) / 2.0f;\n        }\n        else if (aLeft > bRight)\n        {\n            // We have taken too many from a; shrink right side\n            high = i - 1;\n        }\n        else\n        {\n            // We have taken too few from a; expand right side\n            low = i + 1;\n        }\n    }\n\n    // The arrays are guaranteed to be sorted and of equal size,\n    // so we should never reach here.\n    assert(false);\n    return 0.0f;\n}\n```\n\n### Why it works\n\n* `i` (0\u202f\u2264\u202fi\u202f\u2264\u202fn) elements come from `arr1`.  \n  Consequently `j = n \u2013 i` elements come from `arr2`.\n\n* We keep the invariant that all elements in the left side of the partition\n  are `\u2264` all elements in the right side.\n\n* `aLeft`, `aRight`, `bLeft`, `bRight` are the boundary values around the\n  partition.  \n  By treating out\u2011of\u2011bound indices as `-\u221e` or `+\u221e` we can safely compare.\n\n* When the partition is correct, the median is simply the average of the\n  greatest element on the left side (`max(aLeft,\u202fbLeft)`) and the smallest\n  element on the right side (`min(aRight,\u202fbRight)`).\n\nThe algorithm terminates in at most `log\u2082 n` iterations because in each step\nthe search interval `[low, high]` is halved.  \nThe time complexity is **O(log\u202fn)** and the space usage is **O(1)**.", "Below is a **complete** implementation that works for two sorted `std::vector<long>` of the same length \\(n\\).\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n\n/* ------------------------------------------------------------------\n   Find the median of two sorted arrays of the same size\n   ------------------------------------------------------------------ */\nfloat get_median(const std::vector<long>& arr1,\n                 const std::vector<long>& arr2,\n                 long n) {\n\n    // ---------------------------------------------------------------\n    // 1. sanity checks\n    //---------------------------------------------------------------\n    assert(arr1.size() == n && arr2.size() == n);\n    assert(n > 0);\n\n    // ---------------------------------------------------------------\n    // 2.  We use the classic \u201cmerge\u2011and\u2011track\u20112\u2011middle\u201d method\n    //     that runs in O(n) time and O(1) extra space.\n    // ---------------------------------------------------------------\n    long i = 0, j = 0;          // indices of arr1, arr2\n    long count = 0;             // how many elements we have \u201cseen\u201d\n\n    long last  = 0;            // element at position (2n-2)/2\n    long second = 0;           // element at position (2n-1)/2\n    // We need the two middle elements of the combined 2n array\n    const long mid1 = (2 * n - 2) / 2;  // zero\u2011based indexes\n    const long mid2 = (2 * n - 1) / 2;\n\n    while (count <= mid2) {               // we stop after we have\n        long current;                     // processed element mid2\n\n        if (i < n && (j >= n || arr1[i] <= arr2[j])) {\n            current = arr1[i++];\n        } else {\n            current = arr2[j++];\n        }\n\n        if (count == mid1)  last  = current;\n        if (count == mid2)  second = current;\n\n        ++count;\n    }\n\n    // If 2n is even, the median is the average of the two middle\n    // numbers; otherwise it is just the middle number (they will be\n    // equal in that case).\n    if ((2 * n) % 2 == 0)\n        return (static_cast<float>(last) + static_cast<float>(second)) / 2.0f;\n    else\n        return static_cast<float>(second);\n}\n\n/* ------------------------------------------------------------------ */\n/*                           Demonstration                              */\n/* ------------------------------------------------------------------ */\nint main() {\n    std::vector<long> a1 = {1, 3, 5, 7};\n    std::vector<long> a2 = {2, 4, 6, 8};\n\n    std::cout << \"Median: \" << get_median(a1, a2, static_cast<long>(a1.size())) << '\\n';\n    // Output: Median: 4.5\n}\n```\n\n### How it works\n\n1. **Merging on\u2011the\u2011fly**  \n   We keep two pointers, `i` for `arr1` and `j` for `arr2`.  \n   In each step we pick the smaller of the two current elements, just like\n   the merge phase of merge\u2011sort.  \n   We only store the last two elements that we \u201csee\u201d; that\u2019s all we need.\n\n2. **Tracking middle positions**  \n   For two sorted vectors of length `n`, the combined array has length `2n`.  \n   Its middle indices are  \n   - `mid1 = (2n\u20112)/2` (the lower middle)  \n   - `mid2 = (2n\u20111)/2` (the upper middle).  \n   While merging, when `count` equals one of these indices we capture\n   that element into `last` or `second`.\n\n3. **Computing the median**  \n   * If `2n` is odd, `mid1 == mid2`, so `last` and `second` are the same\n     number \u2013 that is the median.  \n   * If `2n` is even, the median is the average of the two middle numbers.\n\nThe algorithm runs in **O(n)** time, uses **O(1)** extra space, and\nhandles large integer ranges safely because it never casts to a floating\npoint type until the final division."]}
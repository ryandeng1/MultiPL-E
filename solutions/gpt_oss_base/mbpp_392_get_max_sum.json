{"name": "mbpp_392_get_max_sum", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\nlong get_max_sum(long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_392_get_max_sum.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = get_max_sum;\n    assert(candidate((60)) == (106));\n    assert(candidate((10)) == (12));\n    assert(candidate((2)) == (2));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a concise (but complete) implementation of `get_max_sum`.  \nIt uses **recursion with memoisation** (a map) so the solution runs in *O(log n)* time.  \nThe logic follows exactly the equation you gave:\n\n```\nf(n) = max( f(n/2) + f(n/3) + f(n/4) + f(n/5),  n )\n```\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Memoisation table \u2013 store computed values for each n\nunordered_map<long long, long long> memo;\n\n/**\n * @brief Returns the maximum sum achievable according to\n *        f(n) = max( f(n/2)+f(n/3)+f(n/4)+f(n/5) , n )\n *\n * @param n the value for which to evaluate f(n)\n * @return long long the maximal sum\n */\nlong long get_max_sum(long long n)\n{\n    // Base case: 0 returns 0 (no coins)\n    if (n == 0) return 0;\n\n    // If we already computed f(n) return it\n    auto it = memo.find(n);\n    if (it != memo.end()) return it->second;\n\n    // Recursively compute the four sub\u2011values\n    long long part = get_max_sum(n/2) + get_max_sum(n/3) +\n                     get_max_sum(n/4) + get_max_sum(n/5);\n\n    // Max of exchanging vs keeping the gold\n    long long ans = max(part, n);\n\n    memo[n] = ans;          // store for future calls\n    return ans;\n}\n\n/* -----------------------------------------------------------------\n   Optional main() to illustrate usage\n\n   int main() {\n       ios::sync_with_stdio(false);\n       cin.tie(nullptr);\n       \n       long long n;\n       if (cin >> n) {\n           cout << get_max_sum(n) << '\\n';\n       }\n       return 0;\n   }\n   ----------------------------------------------------------------- */\n```\n\n### Why this works\n\n* The function splits every `n` into four smaller integers.\n* Each sub\u2011problem is solved only once because results are cached in `memo`.\n* The recursion bottoms out at `n == 0` (or any `n < 1` from integer division) \u2013 which returns `0`.\n* The result for each `n` is either the sum of its four parts or the original amount, whichever is larger.\n\nThis implementation is efficient for the constraints typical for the classic \u201cInteger Replacement\u201d task (e.g., `n \u2264 10^9`) and demonstrates the requested equation directly.", "Below is a complete, ready\u2011to\u2011compile C++ program that implements the function `get_max_sum`.  \nIt uses **recursion with memoisation** (dynamic programming in a hash\u2011table).  \nThe core idea comes from the classic \u201cegg\u2011cracking\u201d type problems: for a given `n` we can either\n\n* take the number itself (`n`) or\n* split it into the parts `n/2 + n/3 + n/4 + n/5` and take the maximum of these two options.\n\nFor very large `n` (up to `10^12` or even `10^19` depending on the judge) the recursive approach is still efficient because most sub\u2011values are cached.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// ---------------------------------------------------------------------\n// Memoised recursion\n// ---------------------------------------------------------------------\nunordered_map<long long, long long> memo;\n\n/**\n * @brief Compute the maximum sum as defined by\n *             f(n) = max( f(n/2)+f(n/3)+f(n/4)+f(n/5) , n )\n *\n * @param n The current value.\n * @return long long The maximum possible sum for this n.\n */\nlong long get_max_sum(long long n) {\n    // base case: for very small n it is never beneficial to split\n    if (n < 2) return n;               // 0 or 1\n\n    // return cached value if we already solved it\n    if (auto it = memo.find(n); it != memo.end())\n        return it->second;\n\n    // compute recursively\n    long long split = get_max_sum(n / 2) +\n                      get_max_sum(n / 3) +\n                      get_max_sum(n / 4) +\n                      get_max_sum(n / 5);\n\n    long long result = max(split, n);\n    memo[n] = result;                  // store for future calls\n\n    return result;\n}\n\n// ---------------------------------------------------------------------\n// Demo/Testing code\n// ---------------------------------------------------------------------\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    // Example usage: read numbers until EOF\n    long long n;\n    while (cin >> n) {\n        cout << get_max_sum(n) << '\\n';\n    }\n    return 0;\n}\n```\n\n### Explanation of the algorithm\n\n| Step | What happens | Why |\n|------|--------------|-----|\n| 1 | **Base case**: if `n < 2` we simply return `n`. | Splitting `0` or `1` never improves the result. |\n| 2 | Check `memo` for an already computed value. | Avoid recomputation and keep the runtime logarithmic. |\n| 3 | Recursively compute `f(n/2) , f(n/3) , f(n/4) , f(n/5)`. | Functional equation requires the four sub\u2011problems. |\n| 4 | Take the maximum of `split` and `n`. | This follows the definition of `f`. |\n| 5 | Store the result in `memo` and return it. | Caching eases future look\u2011ups. |\n\nThe recursion depth is bounded by `log\u2082(n)` because every call reduces `n` roughly by a factor of 2.  \nThe overall time complexity is `O(k)` where `k` is the number of distinct values encountered during the recursion (roughly `O(n^0.5)` for big `n`), and the memory usage is also `O(k)`.\n\nThis solution works for the typical constraints seen in problems of this type (e.g., `n \u2264 10^12` or larger) and is very concise and easy to understand.", "Below is a compact, self\u2011contained implementation of the \u201cmaximum sum\u201d problem (sometimes called the *four\u2011thirds* problem).  \nThe function `get_max_sum` uses **memoisation** to avoid recomputing values for the same `n`, which turns the exponential na\u00efve recursion into an almost linear algorithm.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// Return the maximum value obtainable from `n` using the rule:\n///   f(n) = max( n, f(n/2) + f(n/3) + f(n/4) + f(n/5) )\n/// All divisions are integer (floor) divisions.\nlong long get_max_sum(long long n) {\n    static unordered_map<long long, long long> memo;\n    if (n == 0) return 0;                // base\u2010case, but generally memo[0]=0\n\n    auto it = memo.find(n);\n    if (it != memo.end())\n        return it->second;               // value already known\n\n    // Compute the alternative sum using the recurrence.\n    long long sum = get_max_sum(n / 2) +\n                    get_max_sum(n / 3) +\n                    get_max_sum(n / 4) +\n                    get_max_sum(n / 5);\n\n    long long result = max(n, sum);\n    memo[n] = result;                    // remember for future calls\n    return result;\n}\n\nint main() {\n    cout << get_max_sum(12) << '\\n';   // 3 + 4 + 2 + 1 + 0 = 10 < 12 \u2192 12\n    cout << get_max_sum(18) << '\\n';   // 5 + 6 + 3 + 2 = 16 < 18 \u2192 18\n    cout << get_max_sum(4000000) << '\\n'; // Massive\u2011scale test\n    return 0;\n}\n```\n\n### Why it works\n\n1. **Base Case** \u2013 For `n == 0`, the return value is `0`.  \n   In every other case `n/2`, `n/3`, `n/4`, `n/5` are all smaller, so the recursion ultimately terminates.\n\n2. **Recurrence** \u2013 The memoised recursive calls compute  \n   `f(n/2) + f(n/3) + f(n/4) + f(n/5)`.  \n\n3. **Decision** \u2013 The return value is the larger of `n` itself and the sum above.  \n   This implements the definition of `f(n)`.\n\n4. **Memoisation** \u2013 `unordered_map` caches each computed `f(n)`.  \n   The map guarantees *O(1)* average lookup and insert, giving an overall time complexity of roughly *O(number of distinct values of n reached)*, which is far below the naive *O(4\u207f)*.\n\n5. **Handling Large Input** \u2013 By using `long long` (64\u2011bit) you can handle values up to `~9\u00d710\u00b9\u2078`.  \n   If your problem guarantees `n \u2264 4\u202f000\u202f000` (the classical \u201cfour\u2011thirds\u201d problem), the mapping stays comfortably small.\n\nFeel free to strip `#include <bits/stdc++.h>` out and include only the headers you actually need (`<iostream>`, `<unordered_map>`, etc.) if you prefer a more minimal build."]}
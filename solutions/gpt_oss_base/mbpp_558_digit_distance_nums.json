{"name": "mbpp_558_digit_distance_nums", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to find the sum of the per-digit difference between two integers.\nlong digit_distance_nums(long n1, long n2) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_558_digit_distance_nums.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = digit_distance_nums;\n    assert(candidate((1), (2)) == (1));\n    assert(candidate((23), (56)) == (6));\n    assert(candidate((123), (256)) == (7));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a minimal, self\u2011contained **C++** implementation that follows the specification:\n\n```cpp\n#include <cstddef>   // for std::size_t\n#include <cstdlib>   // for std::abs\n#include <cassert>   // optional, for unit\u2011tests\n\n/**\n * @brief   Computes the sum of the per\u2011digit absolute differences\n *          between two non\u2011negative integers.\n *\n * The digits are compared starting from the least significant digit.\n * If one number has fewer digits than the other, the missing digits are\n * considered to be `0`.  \n *\n * Example:  n1 = 352, n2 = 78\n *          352\n *          078\n *          differences: |3\u20110| + |5\u20117| + |2\u20118| = 3 + 2 + 6 = 11\n *\n * @param n1  First non\u2011negative integer.\n * @param n2  Second non\u2011negative integer.\n * @return    Sum of absolute differences of each digit.\n */\nlong long digit_distance_nums(long long n1, long long n2)\n{\n    long long sum = 0;\n    while (n1 > 0 || n2 > 0) {\n        int d1 = static_cast<int>(n1 % 10);\n        int d2 = static_cast<int>(n2 % 10);\n        sum += std::abs(d1 - d2);\n        n1 /= 10;\n        n2 /= 10;\n    }\n    return sum;\n}\n\n/* --------- optional simple test driver --------------------------------- */\n\nstatic void test()\n{\n    assert(digit_distance_nums(352, 78)  == 11);\n    assert(digit_distance_nums(0, 0)    == 0);\n    assert(digit_distance_nums(12345, 54321) == 30);\n    assert(digit_distance_nums(9, 999999)     == 45);\n    // you may add more tests if you wish\n}\n\n/* --------- main (for manual testing) ----------------------------------- */\n\nint main()\n{\n    test();  // will abort if any assertion fails\n\n    // Example usage\n    long long a = 987654321;\n    long long b = 123;\n    std::cout << \"digit distance between \" << a << \" and \" << b\n              << \" = \" << digit_distance_nums(a,b) << '\\n';\n    return 0;\n}\n```\n\n### How it works\n\n1. **Digit extraction** \u2013 In each loop iteration we take the **least significant digit** of both numbers (`% 10`).\n2. **Absolute difference** \u2013 Compute `|d1 - d2|` and add it to the running total.\n3. **Progress** \u2013 Drop the processed digit (`/ 10`) and repeat until both numbers are exhausted.\n4. **Handling unequal length** \u2013 If one number becomes `0`, the remainder of the other number is processed with the missing digit assumed to be `0`.\n\nThe function runs in `O(log10(max(n1,n2)))` time and uses constant additional space.", "Below is a compact, **stand\u2011alone** C++ implementation that computes the \u201cper\u2011digit\u201d difference between two (positive) integers.  \nThe algorithm works for any non\u2011negative `long` values, including `0`, and it naturally handles numbers that have different lengths by treating missing higher\u2011order digits as `0`.\n\n```cpp\n#include <iostream>\n#include <cstdlib>   // for std::abs\n#include <cassert>\n\n/*\n *  digit_distance_nums\n *\n *  Sum of the absolute difference of each digit of n1 and n2.\n *\n *  Example:\n *      n1 =  1234\n *      n2 =   56\n *\n *      digits (right\u2011to\u2011left):\n *      n1 : 4 3 2 1\n *      n2 : 6 5 0 0\n *      difference : |4-6| + |3-5| + |2-0| + |1-0| = 2 + 2 + 2 + 1 = 7\n *\n *  The function is resilient to numbers of unequal length and to zeros.\n */\nlong digit_distance_nums(long n1, long n2)\n{\n    long sum = 0;\n\n    // Work with absolute values so that the function is defined for negatives.\n    n1 = std::llabs(n1);\n    n2 = std::llabs(n2);\n\n    while (n1 > 0 || n2 > 0) {\n        int d1 = static_cast<int>(n1 % 10);  // current last digit of n1\n        int d2 = static_cast<int>(n2 % 10);  // current last digit of n2\n\n        sum += std::abs(d1 - d2);            // add per\u2011digit difference\n\n        n1 /= 10;                            // drop the processed digit\n        n2 /= 10;\n    }\n\n    return sum;\n}\n\n/* ------------------- test harness ------------------- */\nint main()\n{\n    // basic tests\n    assert(digit_distance_nums(0, 0) == 0);\n    assert(digit_distance_nums(1234, 56) == 7);\n    assert(digit_distance_nums(987, 123) == 12);\n    assert(digit_distance_nums(10, 1) == 9);\n    assert(digit_distance_nums(339, 111) == 4);\n    assert(digit_distance_nums(0, 987) == 24);\n\n    // negative numbers are treated as positives\n    assert(digit_distance_nums(-123, 123) == 0);\n    assert(digit_distance_nums(-500, 500) == 10);\n\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\n### How it works\n\n1. **Absolute values** \u2013 the function first takes the absolute value of each input, so it behaves the same for `-123` and `123`.  \n2. **Loop until both numbers vanish** \u2013 in each iteration we fetch the least\u2011significant digit (`% 10`) of both numbers, compute the absolute difference, add it to the running total, and then divide each number by `10` to discard the processed digit.  \n3. **Unequal lengths** \u2013 if one number is already `0`, the remaining digits of the other number are compared to `0`, exactly as if leading zeroes were present.  \n\nThis gives the desired \u201cper\u2011digit difference\u201d sum in linear time with respect to the number of digits.", "Here\u2019s a clean\u2011boxed implementation (C++), plus a quick explanation of how the \u201cper\u2011digit difference\u201d is computed.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n   digit_distance_nums(n1, n2)\n\n   Returns the sum of the absolute difference of each corresponding digit\n   of n1 and n2, after aligning the numbers to the same number of digits.\n\n   Example\n       n1 = 1234, n2 = 567      -> 1234 is padded to 01234, 567 is padded to 00567\n       digits differ per position: |0-0| + |1-0| + |2-5| + |3-6| + |4-7|\n                                  = 0 + 1 + 3 + 3 + 3 = 10\n*/\nlong long digit_distance_nums(long long n1, long long n2)\n{\n    // Make both numbers positive (the problem usually considers non\u2011negative ints)\n    n1 = llabs(n1);\n    n2 = llabs(n2);\n\n    // Convert to string to work with individual digits directly\n    string s1 = to_string(n1);\n    string s2 = to_string(n2);\n\n    // Pad the shorter string with leading zeros\n    if (s1.size() < s2.size())\n        s1.insert(s1.begin(), s2.size() - s1.size(), '0');\n    else if (s2.size() < s1.size())\n        s2.insert(s2.begin(), s1.size() - s2.size(), '0');\n\n    long long sum = 0;\n    for (size_t i = 0; i < s1.size(); ++i) {\n        int d1 = s1[i] - '0';\n        int d2 = s2[i] - '0';\n        sum += llabs(d1 - d2);\n    }\n    return sum;\n}\n\n/* ----------------------------------------------------\n   Quick Test harness\n   ---------------------------------------------------- */\nint main() {\n    vector<pair<long long,long long>> tests = {\n        {1234, 567},\n        {0, 0},\n        {99, 100},\n        {500, 500},\n        {123456789, 987654321},\n    };\n\n    for (auto [a,b] : tests) {\n        cout << \"digit_distance_nums(\" << a << \", \" << b\n             << \") = \" << digit_distance_nums(a,b) << '\\n';\n    }\n    return 0;\n}\n```\n\n### How it works\n\n1. **Absolute values** \u2013 the function works with positive integers; we call `llabs` to be defensive against negative inputs (the exercise normally assumes non\u2011negative ints).\n\n2. **String conversion** \u2013 converting the numbers to strings lets us index each digit directly.\n\n3. **Padding** \u2013 the shorter string is padded with leading zeros, so each position refers to the same place value in both numbers (units, tens, hundreds\u2026).\n\n4. **Per\u2011digit difference** \u2013 for each position we compute `llabs(d1 - d2)` and accumulate that into `sum`.\n\n5. **Return** \u2013 the final sum is returned as a 64\u2011bit signed integer (`long long`).\n\nFeel free to swap the string approach for a pure arithmetic one (e.g., repeatedly halving by 10), but the string method is clearer and less error\u2011prone for this problem."]}
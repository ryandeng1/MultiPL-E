{"name": "mbpp_397_median_numbers", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the median of three numbers.\nfloat median_numbers(long a, long b, long c) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_397_median_numbers.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = median_numbers;\n    assert(candidate((25), (55), (65)) == (55.0f));\n    assert(candidate((20), (10), (30)) == (20.0f));\n    assert(candidate((15), (45), (75)) == (45.0f));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a straightforward implementation that works for any ordering of the three inputs:\n\n```cpp\n#include <cmath>   // for std::abs\n#include <algorithm> // for std::max, std::min\n\n// Return the median of a, b and c\nfloat median_numbers(long a, long b, long c)\n{\n    // One\u2011liner using max/min, which is both clear and O(1)\n    return std::max(std::min(a, b), std::min(std::max(a, b), c));\n}\n```\n\n### How it works\n\n1. `std::min(a,b)` is the smallest of `a` and `b`.  \n2. `std::max(a,b)` is the largest of `a` and `b`.  \n3. `std::min(std::max(a,b), c)` gives the smaller of the bigger one (`max(a,b)`) and `c`.\n4. Taking the maximum of the two values obtained in steps\u202f1 and\u202f3 yields the middle value \u2013 the median.\n\n---\n\n#### Full example with a simple test\n\n```cpp\n#include <iostream>\n#include <cassert>\n\nfloat median_numbers(long a, long b, long c)\n{\n    return std::max(std::min(a, b), std::min(std::max(a, b), c));\n}\n\nint main()\n{\n    assert(median_numbers(3, 1, 2) == 2.0f);\n    assert(median_numbers(-5, 0, 4) == 0.0f);\n    assert(median_numbers(7, 7, 1) == 7.0f);   // two numbers equal\n    assert(median_numbers(10, 10, 10) == 10.0f);\n\n    std::cout << \"All tests passed!\\n\";\n}\n```\n\nCompile with:\n\n```\ng++ -std=c++17 -O2 -Wall median.cpp -o median\n```\n\nThe code runs in constant time and handles all edge cases, including when two or all three numbers are equal.", "Here\u2019s a compact, self\u2011contained implementation that finds the median of three `long` values and returns it as a `float`.  \nThe routine is deliberately simple, uses only a handful of comparisons (no library sorting), and is fully type\u2011consistent with the signature you already wrote.\n\n```cpp\n#include <assert.h>\n#include <bits/stdc++.h>\n\n// Return the median of three numbers (int\u2011type values, but returned as float).\nfloat median_numbers(long a, long b, long c) {\n    // The median is the value that is neither the maximum nor the minimum.\n    // One elegant way is to sum all three and subtract the max and min.\n    long max_val = std::max({a, b, c});\n    long min_val = std::min({a, b, c});\n    long sum     = a + b + c;\n\n    // Median = (sum - max - min)\n    long med_long = sum - max_val - min_val;\n    return static_cast<float>(med_long);\n}\n\n/* Quick sanity checks \u2013 these can be removed or turned into real unit\n   tests when using a testing framework. */\nint main() {\n    assert(median_numbers(10, 20, 30) == 20.0f);\n    assert(median_numbers(30, 10, 20) == 20.0f);\n    assert(median_numbers(5, 5, 10)   == 5.0f);  // handles duplicates\n    assert(median_numbers(-1, 0, 1)   == 0.0f);\n    std::cout << \"All tests passed.\\n\";\n    return 0;\n}\n```\n\n### Why this works\n* `std::max` and `std::min` with an initializer list (`{a, b, c}`) compute the maximum and minimum in a single pass.\n* Summing all three values and then subtracting the two extremes leaves exactly the middle value.\n* Casting to `float` preserves the required return type.\n\nFeel free to drop the `main` function or replace the `assert` statements with a proper test harness if you are integrating this into a larger project. Happy coding!", "Below is a minimal, self\u2011contained C++ snippet that implements a `median_numbers` function for three integers (or any arithmetic type). The function simply orders the three values (no expensive sort is needed) and returns the middle one as a `float`. I also added a tiny test harness so you can compile and run it right away.\n\n```cpp\n#include <cassert>\n#include <iostream>\n\n// Return the median of three values\n// The input parameters are of integral type \u2013 you can change them\n// to any type that supports comparison and conversion to float.\nfloat median_numbers(long a, long b, long c)\n{\n    // The simplest O(1) approach is to check pairwise\n    // which value is neither the min nor the max.\n    if ((a <= b && b <= c) || (c <= b && b <= a))\n        return static_cast<float>(b);          // b is median\n    else if ((b <= a && a <= c) || (c <= a && a <= b))\n        return static_cast<float>(a);          // a is median\n    else\n        return static_cast<float>(c);          // c is median\n}\n\n// -----------------\n// Test the routine\n// -----------------\nint main()\n{\n    // basic tests\n    assert(median_numbers(1, 2, 3) == 2.0f);\n    assert(median_numbers(3, 2, 1) == 2.0f);\n    assert(median_numbers(1, 3, 2) == 2.0f);\n    assert(median_numbers(5, 5, 5) == 5.0f);\n    assert(median_numbers(-1, 0, 1) == 0.0f);\n\n    // random extras\n    std::cout << \"Median of (10, 20, 15) = \" << median_numbers(10, 20, 15) << '\\n';\n\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n```\n\n**How it works**\n\n* We consider three \u201cif\u201d clauses that detect which of the three numbers is sandwiched between the other two.  \n* If the clause for `b` succeeds, `b` is the median; otherwise we check for `a`.  \n* If neither `a` nor `b` are medians, the remaining `c` must be the median.\n\nThis method is O(1) time and O(1) space \u2013 it uses no temporary container or sorting routine. It will also work for any integral or floating\u2011point input type, as long as you adjust the parameter types accordingly."]}
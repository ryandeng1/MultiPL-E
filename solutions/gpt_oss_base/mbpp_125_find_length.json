{"name": "mbpp_125_find_length", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.\nlong find_length(std::string string) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_125_find_length.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = find_length;\n    assert(candidate((\"11000010001\")) == (6));\n    assert(candidate((\"10111\")) == (1));\n    assert(candidate((\"11011101100101\")) == (2));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a small self\u2011contained implementation.  \nIt turns the binary string into a numeric array in which a **`0` contributes `+1`** and a **`1` contributes `\u20111`**.  \nThe maximum difference between the number of `0`s and `1`s in any contiguous part of the string is therefore the maximum sub\u2011array sum of that array \u2013 a classic application of **Kadane\u2019s algorithm**.\n\n```cpp\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <limits>\n\n/*\n    Returns the maximal possible value of\n\n            (#0s in the sub\u2011string) \u2013 (#1s in the sub\u2011string)\n\n    for every contiguous sub\u2011string of the given binary string.\n    If the string has length 0 the function returns 0.\n*/\nlong find_length(const std::string& str)\n{\n    if (str.empty())\n        return 0;\n\n    // Kadane\u2019s algorithm \u2013 O(n) time, O(1) space\n    long best   = std::numeric_limits<long>::min();   // best sum seen so far\n    long current = 0;                                // current sub\u2011array sum\n\n    for (char ch : str)\n    {\n        // encode 0 as +1, 1 as \u20131\n        long val = (ch == '0') ? 1 : -1;\n\n        current = std::max(val, current + val);\n        best    = std::max(best, current);\n    }\n\n    /* the best value is the maximum possible difference.\n       It will always be non\u2011negative because you can always\n       take a sub\u2011string consisting of a single \u20180\u2019 (difference 1).\n       Just in case the caller expects a non\u2011negative answer\n       we clamp it to 0. */\n    return std::max(0LL, best);\n}\n\n/* ----------------- simple test harness ----------------- */\n#ifdef UNIT_TESTS\n#include <iostream>\n\nint main()\n{\n    assert(find_length(\"0011001\") == 3);   // 0011 \u2192 diff 2, 00110 \u2192 diff 2, 0011001 \u2192 diff 3\n    assert(find_length(\"1111\")     == 0);   // no 0s \u2192 diff never positive\n    assert(find_length(\"000\")     == 3);\n    assert(find_length(\"\")        == 0);\n    assert(find_length(\"1\")       == 0);\n    assert(find_length(\"0\")       == 1);\n\n    std::cout << \"All tests passed.\\n\";\n    return 0;\n}\n#endif\n```\n\n### How it works\n1. **Conversion** \u2013 Each character is mapped to `+1` (for `0`) or `\u20111` (for `1`).  \n2. **Kadane** \u2013 While iterating:\n   * `current` keeps the best sum ending at the current position (it may start a new sub\u2011array at the current position if that\u2019s better).  \n   * `best` records the maximum of all `current` values seen so far, i.e. the answer.  \n3. The function returns `best` (clamped to zero just in case).  \n\nThe algorithm runs in linear time and constant extra space, and it works for strings of any length.", "Below is a self\u2011contained implementation (GNU\u2011C++17) that\n\n1.  converts a binary string into an array of `+1` (for \u20181\u2019) and `\u20111` (for \u20180\u2019),\n2.  runs **Kadane\u2019s algorithm** to obtain the maximum\u2011sum sub\u2011array \u2013 which is exactly the maximum \\((\\#1 \u2013 \\#0)\\) that can be achieved in any substring,\n3.  returns that maximum difference (it will be\u202f\u2265\u202f0 for non\u2011empty strings).\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*  Find the maximum difference between the number of 0s and 1s\n *  in any sub\u2011string of the given binary string.\n *\n *  The function returns that maximum difference.\n *  If the string is empty it returns 0.\n */\nlong find_length(const string& binary)\n{\n    if (binary.empty())\n        return 0;\n\n    long max_diff = LLONG_MIN;   // best sum found so far\n    long cur_sum   = 0;           // current prefix sum\n\n    for (char ch : binary)\n    {\n        int val = (ch == '1') ?  1  : -1;  // 1 \u2192 +1, 0 \u2192 \u20131\n        cur_sum += val;\n\n        if (cur_sum > max_diff)         // better whole\u2011subarray\n            max_diff = cur_sum;\n\n        if (cur_sum < 0)                // reset if the sum becomes negative\n            cur_sum = 0;\n    }\n\n    return max_diff;   // \u2265 0 for any non\u2011empty binary string\n}\n\n/* ---------- Example usage ---------- */\nint main()\n{\n    string s = \"1101001110\";\n    long ans = find_length(s);\n    cout << \"Maximum difference (1s \u2212 0s) = \" << ans << '\\n';\n    return 0;\n}\n```\n\n### How it works\n\n* **Mapping** \u2013 Each character of the binary string is mapped to an integer:\n  * `'1'` \u2192 `+1` (contributing one more 1 than 0)\n  * `'0'` \u2192 `-1` (subtracting one from the difference)\n\n* **Kadane\u2019s algorithm** \u2013 As we sweep through the mapped array, we keep a running sum.  \n  Whenever this running sum becomes negative, we reset it to `0`, because a negative prefix can only hurt a future sub\u2011array and it is better to start a new sub\u2011array from the next position.  \n  The maximum value ever seen by this running sum is the maximum possible difference.\n\n* **Result** \u2013 The returned value is the sought\u2011after maximum difference between the count of 1s and 0s in any substring. It is always non\u2011negative for a non\u2011empty binary string.", "Below is a clean, self\u2011contained implementation that solves the problem:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// @brief  Find the maximum difference between the number of 0s and 1s\n///         in any substring of a binary string.\n/// @param  s   : binary string consisting only of '0' and '1'.\n/// @return     : maximum value of (#0s \u2013 #1s) over all substrings.\n///               If the given string contains only '1's, the answer will be 0.\n///               (You can change this behaviour if you need the negative value.)\nlong long find_length(const string &s)\n{\n    long long maxSum = 0;   // maximum sub\u2011array sum seen so far\n    long long curSum = 0;   // current sub\u2011array sum\n\n    for (char ch : s)\n    {\n        // Treat '0' as +1, '1' as -1\n        curSum += (ch == '0') ? 1 : -1;\n\n        // If curSum becomes negative, start a new sub\u2011array from next position\n        if (curSum < 0) curSum = 0;\n\n        if (curSum > maxSum) maxSum = curSum;\n    }\n\n    return maxSum;\n}\n\n/* ----------------------------------------------------------------\n   Example usage\n   ---------------------------------------------------------------- */\n\nint main()\n{\n    string bin = \"1101001100\";\n    cout << \"Maximum difference (#0s \u2013 #1s) is: \" << find_length(bin) << '\\n';\n    return 0;\n}\n```\n\n### Why this works\n\n* Convert every character to a numeric value:\n  * `0 \u2192 +1` (because it contributes positively to the difference)\n  * `1 \u2192 -1` (because it reduces the difference)\n* The problem becomes: **find the maximum sub\u2011array sum** of this numeric array.\n* Kadane\u2019s algorithm runs in `O(n)` time with constant extra space, so the\n  solution is efficient for very long strings.\n\nFeel free to adapt the return policy (e.g., allow negative results) or\nparameter types as needed."]}
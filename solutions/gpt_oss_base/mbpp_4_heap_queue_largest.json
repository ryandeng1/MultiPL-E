{"name": "mbpp_4_heap_queue_largest", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the n largest integers from a given vector of numbers, returned in descending order.\nstd::vector<long> heap_queue_largest(std::vector<long> nums, long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_4_heap_queue_largest.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = heap_queue_largest;\n    assert(candidate((std::vector<long>({(long)25, (long)35, (long)22, (long)85, (long)14, (long)65, (long)75, (long)22, (long)58})), (3)) == (std::vector<long>({(long)85, (long)75, (long)65})));\n    assert(candidate((std::vector<long>({(long)25, (long)35, (long)22, (long)85, (long)14, (long)65, (long)75, (long)22, (long)58})), (2)) == (std::vector<long>({(long)85, (long)75})));\n    assert(candidate((std::vector<long>({(long)25, (long)35, (long)22, (long)85, (long)14, (long)65, (long)75, (long)22, (long)58})), (5)) == (std::vector<long>({(long)85, (long)75, (long)65, (long)58, (long)35})));\n}\n", "stop_tokens": ["\n}"], "completions": ["```cpp\n#include <vector>\n#include <queue>\n#include <algorithm>\n\n/*\n * Return the **n** largest numbers from the input vector `nums` in\n * **descending** order.\n *\n * Algorithm:\n *   \u2022 Keep a *min\u2011heap* (std::priority_queue with std::greater) of size at most n.\n *   \u2022 Iterate over all elements:\n *        \u2013 If the heap size is smaller than n, push the element.\n *        \u2013 Otherwise compare the current element with the smallest (top of the heap).\n *          If the current element is larger, pop the smallest and push the current one.\n *   \u2022 After the scan the heap contains the n largest elements, but in ascending\n *     order (smallest at top).  We pop them into a vector, then reverse it.\n *\n * Complexity:\n *   \u2022 Time:   O(m\u202flog\u202fn)   (m = nums.size())\n *   \u2022 Space:  O(n)\n */\nstd::vector<long> heap_queue_largest(std::vector<long> nums, long n) {\n    if (n <= 0) return {};\n\n    // min\u2011heap of at most `n` elements\n    std::priority_queue<long, std::vector<long>, std::greater<long>> min_heap;\n\n    for (const long &v : nums) {\n        if ((long)min_heap.size() < n) {\n            min_heap.push(v);\n        } else if (v > min_heap.top()) {\n            min_heap.pop();\n            min_heap.push(v);\n        }\n    }\n\n    // Extract elements from the heap \u2013 they come out in ascending order\n    std::vector<long> result;\n    result.reserve(min_heap.size());\n    while (!min_heap.empty()) {\n        result.push_back(min_heap.top());\n        min_heap.pop();\n    }\n\n    // Reverse to get descending order\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```\n\nThis function uses only the C++ standard library, works for any size of the input vector, and handles cases where `n` is larger than the number of elements or non\u2011positive by returning an empty vector.", "Here\u2019s a complete, self\u2011contained implementation of `heap_queue_largest`.  \nIt uses a min\u2011heap (priority queue with `std::greater`) to keep the **n** largest elements seen so far.  \nWhen the heap grows beyond **n**, the smallest element is removed, guaranteeing that after scanning the whole input we end up with exactly the **n** largest values.  \nFinally we pop everything out of the heap into a vector and sort it in descending order before returning it.\n\n```cpp\n#include <vector>\n#include <queue>\n#include <functional>\n#include <algorithm>\n#include <cassert>\n\n/*\n * Find the `n` largest integers from `nums` and return them\n * in descending order.\n *\n * Complexity:\n *   Time  : O(m log n)   (m = nums.size())\n *   Space : O(n)\n */\nstd::vector<long> heap_queue_largest(std::vector<long> nums, long n)\n{\n    // Guard against invalid input\n    assert(n >= 0);\n\n    // Special cases: nothing to return or more items requested\n    // than we have\n    if (n == 0 || nums.empty())\n        return {};\n\n    if (n >= static_cast<long>(nums.size())) {\n        std::sort(nums.begin(), nums.end(), std::greater<long>());\n        return nums;\n    }\n\n    // Min\u2011heap to keep the current largest `n` elements\n    std::priority_queue<\n        long,\n        std::vector<long>,\n        std::greater<long>                // smallest on top\n    > min_heap;\n\n    for (long val : nums) {\n        if (min_heap.size() < static_cast<size_t>(n)) {\n            min_heap.push(val);\n        } else if (val > min_heap.top()) {\n            min_heap.pop();           // remove the smallest\n            min_heap.push(val);       // insert the new candidate\n        }\n        // else: val is not large enough to enter the heap\n    }\n\n    // Extract the values out of the heap into a vector\n    std::vector<long> result;\n    result.reserve(min_heap.size());\n    while (!min_heap.empty()) {\n        result.push_back(min_heap.top());\n        min_heap.pop();\n    }\n\n    // Sort descending\n    std::sort(result.begin(), result.end(), std::greater<long>());\n    return result;\n}\n```\n\n### Usage example\n\n```cpp\nint main() {\n    std::vector<long> data = {5, 1, 9, 3, 7, 2, 8};\n    long k = 4;\n    std::vector<long> largest = heap_queue_largest(data, k);\n\n    // largest now contains: 9, 8, 7, 5\n    for (long v : largest) std::cout << v << ' ';\n    std::cout << '\\n';\n}\n```\n\nThis implementation works for any numeric type that supports comparison, is efficient for large input vectors, and returns the result strictly in descending order.", "Here\u2019s a clean, self\u2011contained implementation that does what you asked for:\n\n```cpp\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <stdexcept>\n\n/*  Return the n largest elements of \u201cnums\u201d in descending order.\n    If n is zero or greater than the size of the vector the function\n    behaves like std::vector::reserve / empty vector.\n    Complexity:  O(nums.size() + n log n)\n*/\nstd::vector<long> heap_queue_largest(std::vector<long> nums, long n)\n{\n    if (n <= 0 || nums.empty())\n        return {};\n\n    if (n > static_cast<long>(nums.size()))\n        n = static_cast<long>(nums.size());\n\n    /* We keep a min\u2011heap of size n.  \n       The smallest of the current top n elements is at the root.\n       If a new element is larger than the root, we pop the root and\n       push the new element.  In the end the heap contains the n largest\n       elements.                                         */\n    std::priority_queue<long, std::vector<long>, std::greater<long>> min_heap;\n\n    for (const auto& v : nums)\n    {\n        min_heap.push(v);\n        if (static_cast<long>(min_heap.size()) > n)\n            min_heap.pop();          // remove the smallest\n    }\n\n    /* The heap is a min\u2011heap, but we need the result in descending order.\n       Pull everything out into a temporary vector and then reverse it. */\n    std::vector<long> result;\n    result.reserve(n);\n    while (!min_heap.empty())\n    {\n        result.push_back(min_heap.top());\n        min_heap.pop();\n    }\n\n    std::reverse(result.begin(), result.end());    // now it is descending\n    return result;\n}\n```\n\n### How it works\n\n1. **Early return** \u2013 if `n <= 0` or the input vector is empty, we simply return an empty vector.\n2. **Clamp `n`** \u2013 if the caller requests more than the number of elements, we clamp `n` to the vector size.\n3. **Min\u2011heap** \u2013 a `std::priority_queue` with a `std::greater` comparator acts as a min\u2011heap.  \n   As we iterate over `nums`, we keep the heap size no larger than `n`.  \n   Whenever a new element is greater than the smallest of the current top\u2011`n`, it pushes in and removes the smallest.\n4. **Collecting results** \u2013 once all elements have been processed, the heap holds the `n` largest values, but in ascending order.  \n   We pop all of them into a temporary vector and then reverse it so that the final vector is sorted in descending order.\n\n### Complexity\n\n* Inserting each element into the heap costs `O(log n)`; we do this for all `k = nums.size()` elements \u2192 `O(k log n)`.  \n* Collecting the `n` elements and reversing them is `O(n)`.  \n\nSo the total complexity is `O(k log n + n)` which is efficient for large input vectors and small `n`.\n\nFeel free to integrate this into your existing code or adapt it to your own container types. Happy coding!"]}
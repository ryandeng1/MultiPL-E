{"name": "mbpp_454_text_match_wordz", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that matches a word containing 'z'.\nbool text_match_wordz(std::string text) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_454_text_match_wordz.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = text_match_wordz;\n    assert(candidate((\"pythonz.\")) == (true));\n    assert(candidate((\"xyz.\")) == (true));\n    assert(candidate((\"  lang  .\")) == (false));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a small, self\u2011contained implementation of `text_match_wordz` that simply checks whether **any** word in the input `text` contains the character `'z'` (case\u2011insensitive).  \nThe implementation is written to be easy to understand, uses only the C++ standard library, and is fully portable.\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cctype>\n\n/**\n * @brief   Checks whether any word in the given text contains the letter 'z'.\n *\n * A \u201cword\u201d is defined as a maximal consecutive sequence of alphabetic\n * characters (according to `std::isalpha`).  The search is case\u2011insensitive:\n * both 'z' and 'Z' are considered a match.\n *\n * @param text The string to examine.\n * @return true  If at least one word contains a 'z'/'Z'.\n * @return false Otherwise.\n */\nbool text_match_wordz(const std::string& text)\n{\n    bool inWord = false;\n    bool foundZ = false;\n\n    for (size_t i = 0; i < text.size(); ++i)\n    {\n        char ch = text[i];\n\n        if (std::isalpha(static_cast<unsigned char>(ch)))\n        {\n            // We're inside a word\n            if (!inWord)\n            {\n                // Word just started\n                inWord = true;\n            }\n\n            if (std::tolower(static_cast<unsigned char>(ch)) == 'z')\n            {\n                return true;          // immediate success\n            }\n        }\n        else\n        {\n            // Non\u2011alpha: word ends\n            inWord = false;\n        }\n    }\n\n    // No 'z' found in any word\n    return false;\n}\n\n/* ------------------------------------------------------------------ */\n/* Simple test harness \u2013 remove or comment out in production          */\n/* ------------------------------------------------------------------ */\nint main()\n{\n    struct TestCase\n    {\n        std::string input;\n        bool        expected;\n    };\n\n    std::vector<TestCase> tests = {\n        {\"Hello world\",                     false},\n        {\"All zis are zis\",                 true},\n        {\"No match here.\",                  false},\n        {\"mazed out\",                       true},\n        {\"ZoO sharp\",                       true},\n        {\"The quick brown fox jumps over the lazy dog.\", true},\n        {\"1234 56!$# \",                     false},\n        {\"   zzz  \",                        true}\n    };\n\n    for (auto& t : tests)\n    {\n        bool result = text_match_wordz(t.input);\n        std::cout << \"Input: \\\"\" << t.input << \"\\\" -> \"\n                  << (result ? \"true\" : \"false\")\n                  << \" (expected: \" << (t.expected ? \"true\" : \"false\") << \")\\n\";\n        assert(result == t.expected);\n    }\n\n    std::cout << \"All tests passed.\\n\";\n    return 0;\n}\n```\n\n### How it works\n\n1. **Word detection**  \n   We treat a *word* as any maximal run of alphabetic characters (`std::isalpha`).  \n   As soon as a non\u2011alphabetic character is encountered, we consider the word ended.\n\n2. **Case\u2011insensitivity**  \n   Each alphabetic character is converted to lower case (`std::tolower`) before comparison with `'z'`.  \n   This ensures that `'Z'` matches as well.\n\n3. **Early exit**  \n   As soon as a `'z'` (or `'Z'`) is found inside a word, the function returns `true`.  \n   If the loop finishes without finding any, it returns `false`.\n\n### Extending / Customising\n\n* If you want to treat hyphenated terms or apostrophes as part of a word, adjust the `isalpha` check accordingly.\n* To make the function `const`\u2011correct, you might forward the string by reference as shown (`const std::string&`).\n\nFeel free to drop the test harness or replace it with your own tests.", "Below is a small, self\u2011contained function that receives a sentence (or any arbitrary string) and returns **true** if the sentence contains *at least one whole word that contains the letter \u2018z\u2019* and **false** otherwise.  \nThe implementation uses only the C++ standard library (no external regex engines) and works with both ASCII and UTF\u20118 encoded input \u2013 you can adapt the final step if you need Unicode support.\n\n```cpp\n#include <string>\n#include <cctype>   // std::isalpha, std::isalnum\n#include <algorithm> // std::find_if\n\n/**\n * @brief   Determines if `text` contains a word that contains the letter 'z'.\n *\n * A *word* is defined as a contiguous stretch of alphanumeric characters.\n * The search is case\u2011insensitive.\n *\n * @param text The text to search.  It may be empty \u2013 in that case the\n *             function returns false.\n * @returns true  if at least one word in `text` contains 'z' (case\u2011insensitive).\n *          false otherwise.\n *\n * Example:\n * \u2500\u2500> text_match_wordz(\"The quzzzzx jumps\")  returns true  // world contains 'z'\n * \u2500\u2500> text_match_wordz(\"zzz\")                 returns true  // whole word\n * \u2500\u2500> text_match_wordz(\"examine\")             returns false // no 'z'\n */\nbool text_match_wordz(const std::string& text) {\n    if (text.empty())\n        return false;\n\n    bool inWord = false;            // are we inside a word?\n    bool hasZ   = false;            // does the current word contain 'z'?\n\n    for (char ch : text) {\n        if (std::isalnum(static_cast<unsigned char>(ch))) {\n            // We're inside a word.\n            inWord = true;\n            if (std::tolower(static_cast<unsigned char>(ch)) == 'z')\n                hasZ = true;\n        } else {\n            // We hit a delimiter: end the current word.\n            if (inWord && hasZ)\n                return true;   // we found a word with 'z'\n            inWord = false;\n            hasZ   = false;\n        }\n    }\n\n    // Handle the last word (text may end with a letter).\n    return inWord && hasZ;\n}\n```\n\n### Why this implementation?\n\n| Feature | Reason |\n|---------|--------|\n| **No regex** | Regex can be overkill for such a simple task and may hurt performance on large texts. |\n| **Single pass** | Linear time `O(n)` with constant extra memory. |\n| **Case\u2011insensitive** | The problem statement did not specify case\u2011sensitivity, but most \u201ccontains 'z'\u201d problems treat it case\u2011insensitive. |\n| **Delimiter\u2011based words** | \u201cWord\u201d is interpreted as any alphanumeric sequence, which is adequate for typical English text. |\n| **Portable** | Uses only the C++ standard library; works on any compiler that supports C++11 or later. |\n\n### Usage example\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << text_match_wordz(\"Browsing the website\") << '\\n'; // true\n    std::cout << text_match_wordz(\"Hello world\") << '\\n';          // false\n}\n```\n\nFeel free to drop the function into your own project or adapt it for Unicode by replacing the `std::isalnum`/`std::tolower` checks with a proper Unicode library.", "Below is a compact implementation that checks whether *any* word in the given `text` contains the letter **\u201cz\u201d** (`'z'` or `'Z'`).  \nThe function returns `true` as soon as it finds such a word; otherwise it returns `false`.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/// \\brief  Returns true if the input string contains at least one\n///         word that includes the character 'z' (case\u2011insensitive).\nbool text_match_wordz( const string &text )\n{\n    // Pattern:  a word (\\w+) that contains at least one 'z'.\n    //   - \\b : word boundary\n    //   - \\w* : zero or more word characters before 'z'\n    //   - z : the letter 'z'\n    //   - \\w* : zero or more word characters after 'z'\n    //   - \\b : end of the word\n    //\n    // The regex engine is case\u2011sensitive by default; we explicitly set\n    // the flag icase (i.e., case\u2011insensitive) so that 'Z' also matches.\n    static const regex pattern{ R\"(\\b\\w*z\\w*\\b)\", regex_constants::icase };\n\n    return regex_search( text, pattern );\n}\n\n/* Example usage\n\nint main() {\n    string s1 = \"The quick brown fox jumps over the lazy dog.\";\n    string s2 = \"Hello world, this is a test.\";\n    assert(text_match_wordz(s1) == true);   // \"lazy\" contains z\n    assert(text_match_wordz(s2) == false);\n    return 0;\n}\n*/\n\n```\n\n### How it works\n\n1. **Regular expression**  \n   * `\\b` \u2013 ensures we are at a word boundary.  \n   * `\\w*z\\w*` \u2013 matches any sequence of word characters that contains the letter `z`.  \n   * Another `\\b` \u2013 guarantees the match ends at the word boundary.\n\n2. **Case\u2011insensitive**  \n   `regex_constants::icase` makes the pattern match both `'z'` and `'Z'`.\n\n3. **Short\u2011circuit evaluation**  \n   `regex_search` stops as soon as the first qualifying word is found, so the function runs efficiently even on large inputs.\n\nFeel free to adapt the regex pattern if your definition of \u201cword\u201d differs (e.g., you want to exclude apostrophes or hyphens)."]}
{"name": "mbpp_608_bell_Number", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to find nth bell number.\nlong bell_Number(long n) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_608_bell_Number.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = bell_Number;\n    assert(candidate((2)) == (2));\n    assert(candidate((3)) == (5));\n    assert(candidate((4)) == (15));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a **stand\u2011alone C++ (GNU\u2011C++17) implementation** that computes the \\(n^{th}\\) **Bell number**.  \nThe code uses the *Bell triangle* (aka *Aitken\u2013Swan\u2013Storke* triangle) which gives a very simple, reliable recurrence:\n\n\\[\nB_{n+1} = \\sum_{k=0}^{n} \\binom{n}{k} \\, B_k\n\\]\n\nThe triangle form is:\n\n```\n   1\n   1   1\n   2   3   5\n   5  10  15  20\n   ...\n```\n\nWhere the first element of each row is the Bell number for that row.\n\nBecause Bell numbers grow extremely fast (for n=30 the 30th Bell number already contains 35 digits), we use\n`boost::multiprecision::cpp_int` to store arbitrary\u2011size integers.\n\n```cpp\n#include <bits/stdc++.h>\n#include <boost/multiprecision/cpp_int.hpp>\n\nusing namespace std;\nusing boost::multiprecision::cpp_int;\n\n// ---------------------------------------------------------------------------\n// Pre\u2013computed binomial coefficients up to some limit\n// ---------------------------------------------------------------------------\nstatic vector<vector<cpp_int>> binom;        // C[n][k]\nstatic int binom_limit = 0;\n\n// ---------------------------------------------------------------------------\n// Helper: populate binomial coefficients up to N\n// ---------------------------------------------------------------------------\nvoid prepare_binom(int N)\n{\n    if (N <= binom_limit) return;\n\n    // Resize the triangular vector\n    binom.resize(N + 1);\n    for (int n = 0; n <= N; ++n) {\n        binom[n].resize(n + 1);\n        binom[n][0] = binom[n][n] = 1;\n        for (int k = 1; k < n; ++k) {\n            binom[n][k] = binom[n-1][k-1] + binom[n-1][k];\n        }\n    }\n    binom_limit = N;\n}\n\n// ---------------------------------------------------------------------------\n// Main function: Bell number B(n)  (0\u2011based)\n// ---------------------------------------------------------------------------\ncpp_int bell_Number(long n)\n{\n    if (n < 0) throw std::invalid_argument(\"n must be non\u2011negative\");\n\n    // We'll store rows of the Bell triangle on the fly.\n    // row[i] holds the i\u2011th element of the current row (0\u2011based).\n    vector<cpp_int> row(1, 1);          // B_0 = 1\n\n    if (n == 0) return row[0];\n\n    // Need binomial coefficients up to n\n    prepare_binom(n);\n\n    for (long i = 1; i <= n; ++i) {\n        vector<cpp_int> next_row(i + 1);\n\n        // first element of the new row is the last element of the previous row\n        next_row[0] = row.back();\n\n        // Fill the rest using the recurrence\n        for (long j = 1; j <= i; ++j) {\n            // next_row[j] = next_row[j-1] + row[j-1]\n            next_row[j] = next_row[j-1] + row[j-1];\n        }\n\n        // row becomes next_row\n        row.swap(next_row);\n    }\n\n    // After the loop, row[0] is B_n\n    return row[0];\n}\n\n// ---------------------------------------------------------------------------\n// Simple test routine (can be removed in production)\n// ---------------------------------------------------------------------------\n#ifdef UNITTEST\nint main()\n{\n    // Known values for n = 0..10\n    const vector<cpp_int> known = {1, 1, 2, 5, 15, 52, 203, 877, 4140, 21147, 115975};\n    for (int n = 0; n <= 10; ++n) {\n        cpp_int val = bell_Number(n);\n        cerr << \"B(\" << n << \") = \" << val;\n        if (val == known[n]) cerr << \"  \u2714\\n\";\n        else cerr << \"  \u274c (expected \" << known[n] << \")\\n\";\n    }\n}\n#endif\n```\n\n### How it works\n\n1. **`prepare_binom`**  \n   Builds Pascal\u2019s triangle up to the requested `n`.  \n   The binomial coefficients are needed only for very small `n` \u2013 for large \\(n\\) the recurrence of the Bell triangle does not require them (`row[j-1] + row[j-1]`).\n\n2. **Bell triangle**  \n   * `row[0]` holds the last element of the previous row (which is the Bell number of that order).  \n   * For each subsequent element `j` in the row we add the element directly above it:  \n     `next_row[j] = next_row[j\u20111] + row[j\u20111]`.  \n   * This construction directly gives B(n) as the first element of the final row.\n\n3. **Large integers**  \n   `cpp_int` can grow arbitrarily large, so you can compute Bell numbers up to n \u2248 200 with no overflow (only limited by memory/time).\n\n### Usage\n\n```cpp\nint main() {\n    long n = 20;\n    cout << \"B(\" << n << \") = \" << bell_Number(n) << endl;\n}\n```\n\nThe program prints the 20\u2011th Bell number (which is\u00a051724158235372).  \n\nFeel free to `#undef UNITTEST` to remove the test harness when integrating into a larger project.", "Below is a compact, self\u2011contained **C++** implementation that calculates the *n\u2011th* Bell number.  \nIt uses **Bell\u2019s triangle** (sometimes called **Bell (or Brandt) triangle**) to compute the values iteratively and stores them in a `std::vector`.  \nThe routine works for any 0\u202f\u2264\u202fn\u202f\u2264\u202f200 (you can increase the limit if you need larger numbers, but the result will quickly overflow 64\u2011bit integers).  \nIf you need arbitrary precision you can simply change the type to `boost::multiprecision::cpp_int` and add the appropriate header.\n\n```cpp\n// bell_number.cpp\n// ---------------------------------------------------------------\n//  Compute the n\u2011th Bell number using Bell's triangle\n//  ---------------------------------------------------------------\n\n#include <iostream>\n#include <vector>\n#include <stdexcept>\n#include <cassert>\n\n/*\n * bell_number(n)\n *\n * Returns the n-th Bell number B_n.\n * The function uses 0\u2011based indexing:  bell_number(0) == 1,\n * bell_number(1) == 1, bell_number(2) == 2, ...\n *\n * Complexity:\n *   O(n^2) time, O(n) auxiliary space\n *   (we only keep the current row of the triangle)\n *\n * Note:\n *   For n >= 0 64\u2011bit unsigned may overflow around n\u224880.\n *   For higher n use Boost.Multiprecision or a custom big\u2011int class.\n */\nunsigned long long bell_number(long long n)\n{\n    if (n < 0) {\n        throw std::invalid_argument(\"n must be non\u2011negative\");\n    }\n\n    // Special cases\n    if (n == 0) return 1ULL;          // B_0 = 1\n    if (n == 1) return 1ULL;          // B_1 = 1\n\n    // We keep only one row of the triangle\n    std::vector<unsigned long long> row(1, 1ULL);   // first row: [1]\n\n    for (long long i = 1; i <= n; ++i) {\n        // new_row has i+1 elements\n        std::vector<unsigned long long> new_row(i + 1);\n        new_row[0] = row.back();            // first element is last of previous row\n\n        // Fill the middle elements\n        for (size_t j = 1; j < i; ++j) {\n            new_row[j] = new_row[j - 1] + row[j - 1];\n        }\n\n        // Last element equals the first of this row (i.e. new_row[0])\n        new_row[i] = new_row[i - 1] + row[i - 1];\n\n        row.swap(new_row);\n    }\n\n    // After completion, row[0] == B_n\n    return row[0];\n}\n\n/* --------------------------------------------------------------- */\n// Demo\nint main()\n{\n    for (int i = 0; i <= 10; ++i) {\n        std::cout << \"B_\" << i << \" = \" << bell_number(i) << '\\n';\n    }\n    return 0;\n}\n```\n\n### How it works \u2013 Bell\u2019s triangle\n\n```\n          1\n       1  1\n    1  2  2\n  1  3  5  5\n1  4  7 12 12\n...\n```\n\n* The first element of each row is the last element of the previous row.\n* Every subsequent element is the sum of the element to its left **and** the element above-left from the previous row.\n\nThe first element of row `n` equals the `n`\u2011th Bell number.  \nThe implementation above follows this rule iteratively, keeping only a single row in memory (so the auxiliary space is `O(n)`).\n\nFeel free to replace `unsigned long long` with a BigInt type if you need larger numbers.", "Below is a small, self\u2011contained **C++** implementation that computes the\u202f*n*\u2011th Bell number.\nThe routine uses the classic *Bell triangle* (also called the *Peirce triangle*) which only requires\nO(*n*\u00b2) time and O(*n*) additional space.  \nIt works well up to the point where a 64\u2011bit signed integer (`long long`) can hold the result; beyond that you would need a big\u2011integer library.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* ----------------------------------------------------------\n   Return the n\u2011th Bell number.\n   Bell(0) = 1, Bell(1) = 1, Bell(2) = 2, ...\n   ---------------------------------------------------------- */\nlong long bellNumber(long long n)\n{\n    if (n < 0) {                          // negative indices not defined\n        throw std::invalid_argument(\"n must be non\u2011negative\");\n    }\n\n    /* Special cases that do not need a loop */\n    if (n == 0 || n == 1) return 1LL;\n\n    /* 1\u2011D array representing the current row of the Bell triangle.\n       row[0] will always keep the current Bell number.               */\n    vector<long long> row(n + 1, 0);\n    row[0] = 1;                      // Bell(0)\n\n    for (long long i = 1; i <= n; ++i) {\n        row[1] = row[0];              // first element of the new row\n\n        for (long long j = 2; j <= i; ++j)\n            row[j] = row[j - 1] + row[j - 2];\n\n        // After finishing the row, row[0] (= row[i]) becomes Bell(i)\n        // It already is row[i] from the last assignment of the inner loop,\n        // so we just store it when needed.\n    }\n\n    return row[n];   // row[n] == Bell(n)\n}\n\n/* -------------------  Example ------------------- */\nint main() {\n    for (int i = 0; i <= 10; ++i)\n        cout << \"Bell(\" << i << \") = \" << bellNumber(i) << '\\n';\n    return 0;\n}\n```\n\n### How it works\n\n| Step | Explanation |\n|------|-------------|\n| **Bell triangle**  | Each row starts with the last element of the previous row. Subsequent elements are the sum of the element to the left and the element above-left. |\n| **Bell number extraction** | The *k*\u2011th element of row *k* equals the *k*\u2011th Bell number. In the implementation we keep the whole row in a 1\u2011D array and simply read `row[n]` at the end. |\n| **Complexity** | Time \u202fO(*n*\u00b2) \u2013 the double\u2011loop that builds the triangle.  \nSpace O(*n*) \u2013 the 1\u2011D array. |\n\nFeel free to adapt the return type (`unsigned long long`, `__int128`, or a big\u2011integer library) if you need to handle larger numbers."]}
{"name": "mbpp_411_snake_to_camel", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to convert the given snake case string to camel case string.\nstd::string snake_to_camel(std::string word) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_411_snake_to_camel.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = snake_to_camel;\n    assert(candidate((\"android_tv\")) == (\"AndroidTv\"));\n    assert(candidate((\"google_pixel\")) == (\"GooglePixel\"));\n    assert(candidate((\"apple_watch\")) == (\"AppleWatch\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a minimal yet fully\u2011functional implementation that turns a **snake_case** string into **camelCase**.  \nIt:\n\n1. Iterates through the characters,\n2. Skips underscores,\n3. Capitalises the first character of each subsequent word,\n4. Keeps the very first character lower\u2011case as per camelCase convention.\n\n```cpp\n#include <string>\n#include <cctype>   // for std::tolower, std::toupper\n\n/**\n * @brief Convert a snake_case string to camelCase.\n *\n * The function preserves the case of the original letters except\n * for the first letter of each word (except the first).  It also\n * ignores any leading or trailing underscores and consecutive\n * underscores.\n *\n * Examples:\n *   \"hello_world\" -> \"helloWorld\"\n *   \"snake_case_example\" -> \"snakeCaseExample\"\n *\n * @param word Input snake_case string.\n * @return std::string camelCase representation.\n */\nstd::string snake_to_camel(const std::string& word) {\n    std::string result;\n    bool newWord = true;                    // true when we are at the start of a word\n    for (char ch : word) {\n        if (ch == '_') {                     // skip underscores\n            newWord = true;\n            continue;\n        }\n        if (newWord) {                       // first letter of a word\n            result.push_back(static_cast<char>(std::tolower(static_cast<unsigned char>(ch))));\n            // but if it's not the first word, capitalize\n            if (!result.empty() && result.size() > 1)\n                result.back() = static_cast<char>(std::toupper(static_cast<unsigned char>(result.back())));\n            newWord = false;\n        } else {\n            result.push_back(ch);            // regular character\n        }\n    }\n    return result;\n}\n```\n\n### How it works\n\n```\nInput:   \"hello_world_example\"\n          ^  ^  ^           (underscores are delimiters)\n\nResult:  \"helloWorldExample\"\n          ^           ^          (second and third words start with a capital letter)\n```\n\nThis code handles:\n\n- Multiple consecutive underscores (they simply separate words),\n- Leading/trailing underscores,\n- Mixed case in the original string (the letter case of non\u2011first characters is preserved).\n\nYou can replace the `std::string` parameter with `std::string&` if you want to avoid copying the argument. The function is simple enough for most use\u2011cases while being easy to understand and maintain.", "Here\u2019s a compact, fully\u2011qualified implementation that turns an ASCII snake_case word into camelCase.  \nThe function:\n\n* skips leading/trailing underscores,  \n* treats consecutive underscores as word separators (empty words are ignored),  \n* keeps the first \u201cword\u201d in all lowercase,  \n* capitalises the first character of every subsequent word,  \n* preserves all other characters exactly (so numbers, punctuation, etc. are unchanged).\n\n```cpp\n#include <string>\n#include <cctype>\n#include <algorithm>\n\n// Convert a snake_case string to camelCase.\n// Example:  \"the_big_4_nick\" -> \"theBig4Nick\"\n// Also handles edge cases such as \"__foo__bar__\" \u2192 \"fooBar\".\nstd::string snake_to_camel(std::string word)\n{\n    std::string result;\n    bool new_word = true;        // true when we are at the start of a new word\n    for (size_t i = 0; i < word.size(); ++i)\n    {\n        char c = word[i];\n\n        if (c == '_')\n        {\n            // Start of a new word \u2013 set flag and skip underscore.\n            new_word = true;\n            continue;\n        }\n\n        if (new_word)\n        {\n            // First character of a word\n            if (!result.empty())\n                result.push_back(std::toupper(static_cast<unsigned char>(c))); // capitalize\n            else\n                result.push_back(std::tolower(static_cast<unsigned char>(c))); // first word lowercase\n            new_word = false;\n        }\n        else\n        {\n            // Inside a word \u2013 keep the character as\u2011is.\n            result.push_back(c);\n        }\n    }\n    return result;\n}\n```\n\n### How it works\n\n1. **Iteration** \u2013 We walk through the input string once.  \n2. **Underscore handling** \u2013 On encountering '`_`' we set `new_word` to `true` and skip it.  \n3. **Word start** \u2013 When `new_word` is `true` we know the next non\u2011underscore character starts a new word.  \n   * If the result already has characters (i.e., it\u2019s not the first word), we capitalize this character.  \n   * If the result is still empty (the very first word), we keep the character in lowercase.  \n4. **Inside a word** \u2013 If we\u2019re not at a word boundary, we simply append the character unchanged.\n\nThis implementation respects the common snake_case \u2192 camelCase convention while being robust to odd inputs (multiple underscores, leading/trailing underscores, non\u2011alphabetic characters, etc.).", "Here\u2019s a ready\u2011to\u2011paste implementation that does exactly what you asked for \u2013 converting a snake_case string to camelCase.  \nIt handles edge cases (empty string, leading/trailing underscores, multiple consecutive underscores) and guarantees the output is in camelCase (first letter lower\u2011case, subsequent \u201ccomponents\u201d capitalised).  \n\n```cpp\n#include <cassert>\n#include <string>\n#include <cctype>\n\n// Convert a snake_case string to camelCase\nstd::string snake_to_camel(const std::string& word) {\n    std::string result;\n    bool next_upper = false;      // flag to capitalize next character\n    bool first_char = true;       // handle the first letter separately\n\n    for (char ch : word) {\n        if (ch == '_') {\n            // Skip underscores but set flag to uppercase the next non\u2011underscore\n            next_upper = true;\n        } else {\n            if (first_char) {\n                // First character stays lower\u2011case as per camelCase convention\n                result += std::tolower(static_cast<unsigned char>(ch));\n                first_char = false;\n                next_upper = false;  // already handled the first letter\n            } else {\n                if (next_upper) {\n                    result += std::toupper(static_cast<unsigned char>(ch));\n                    next_upper = false;\n                } else {\n                    result += std::tolower(static_cast<unsigned char>(ch));\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\n\n// ---------- Optional: sanity checks (can be removed in production) ----------\nint main() {\n    assert(snake_to_camel(\"my_variable_name\") == \"myVariableName\");\n    assert(snake_to_camel(\"simple\") == \"simple\");\n    assert(snake_to_camel(\"\") == \"\");\n    assert(snake_to_camel(\"_leading_underscore\") == \"leadingUnderscore\");\n    assert(snake_to_camel(\"trailing_underscore_\") == \"trailingUnderscore\");\n    assert(snake_to_camel(\"multiple__underscores\") == \"multipleUnderscores\");\n    assert(snake_to_camel(\"ALL_CAPS\") == \"allCaps\");\n\n    // If all tests pass, print a success message\n    std::puts(\"All tests passed!\");\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Loop through each character** \u2013 we keep two flags:  \n   * `next_upper` \u2013 set to `true` when we encounter an underscore; instructs the next non\u2011underscore to be capitalized.  \n   * `first_char` \u2013 ensures the very first alphabetic character remains lowercase, which is the typical camelCase rule.\n\n2. **Skip underscores** \u2013 they are not added to the result, only used to set `next_upper`.\n\n3. **Capitalise/normalise** \u2013  \n   * For the first character we always write it lower\u2011case.  \n   * For subsequent characters, if `next_upper` is `true` we capitalize; otherwise we write the character in lower\u2011case.\n\n4. **Return the result** \u2013 after the loop, `result` holds the camel\u2011case conversion.\n\nFeel free to integrate this snippet into your project. Happy coding!"]}
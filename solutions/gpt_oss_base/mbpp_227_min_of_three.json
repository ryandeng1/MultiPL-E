{"name": "mbpp_227_min_of_three", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find minimum of three numbers.\nlong min_of_three(long a, long b, long c) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_227_min_of_three.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = min_of_three;\n    assert(candidate((10), (20), (0)) == (0));\n    assert(candidate((19), (15), (18)) == (15));\n    assert(candidate((-10), (-20), (-30)) == (-30));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a compact and idiomatic implementation of `min_of_three`.  \nIt uses the C++ standard library `std::min` (twice) to keep the code short, readable, and correct for all integral types.\n\n```cpp\n#include <algorithm>   // for std::min\n#include <cassert>     // for assert\n\n// Return the smallest of three long integers.\nlong min_of_three(long a, long b, long c) {\n    // std::min can pairwise reduce the arguments.\n    return std::min(a, std::min(b, c));\n}\n\n/* Optional tests */\nint main() {\n    assert(min_of_three(3, 1, 2) == 1);\n    assert(min_of_three(10, 10, 5) == 5);\n    assert(min_of_three(-5, -3, 0) == -5);\n    return 0;\n}\n```\n\n### Why this is good\n\n- **Clarity**: The intent is obvious\u2014take the pairwise minimum until the overall minimum is found.\n- **Portability**: No custom helper functions or macros; just standard library utilities.\n- **Robustness**: Works with any type that satisfies `std::min`, so it\u2019s immediately reusable for other numeric types.", "Here\u2019s a small, clean implementation that returns the smallest of the three values:\n\n```cpp\n#include <algorithm>   // std::min\n\nlong min_of_three(long a, long b, long c) {\n    // Use std::min on the first two values, then compare that result\n    // with the third. This keeps the code readable and still\n    // operates in O(1) time.\n    return std::min(a, std::min(b, c));\n}\n```\n\n## Why it works\n* `std::min` is a template that returns the smaller of its two arguments.\n* `std::min(b, c)` gives the smaller of `b` and `c`.\n* `std::min(a, that)` then gives the smallest among all three values.\n\n## Alternative (hand\u2011written)\n\nIf you prefer not to use `std::min`:\n\n```cpp\nlong min_of_three(long a, long b, long c) {\n    long min = a;\n    if (b < min) min = b;\n    if (c < min) min = c;\n    return min;\n}\n```\n\nBoth versions run in constant time and use constant extra space. Feel free to choose the one that best fits the style guidelines of your project.", "Here is a simple, self\u2011contained implementation that works for any integral type (you can also use templates to make it generic).  \nIt uses the standard `std::min` (with overload resolution) instead of writing nested `if` statements, which keeps the code short and idiomatic.\n\n```cpp\n#include <algorithm>   // std::min\n#include <limits>      // std::numeric_limits\n\n/*  Find the minimum of three values.\n *  The function works for any arithmetic type that supports\n *  the `<` operator (signed/unsigned integers, floating\u2011point, etc.).\n */\ntemplate <typename T>\nT min_of_three(const T& a, const T& b, const T& c)\n{\n    // Compare a and b, then compare the result with c\n    return std::min(a, std::min(b, c));\n}\n\n/*  If you need the non\u2011templated version for `long` specifically:\n    long min_of_three(long a, long b, long c) {\n        return std::min(a, std::min(b, c));\n    }\n*/\n\nint main()\n{\n    // Example usage\n    long x = 42, y = 7, z = 18;\n    long smallest = min_of_three(x, y, z);\n    std::cout << \"The smallest value is \" << smallest << '\\n';\n    return 0;\n}\n```\n\n### Why this version is preferable\n\n1. **Concise** \u2013 Uses the standard library\u2019s `std::min`, which is battle\u2011tested and clear.\n2. **Generic** \u2013 By templating, it works with any type that defines comparison operators, so you can reuse it for `int`, `double`, `unsigned long`, etc.\n3. **Correctness** \u2013 No risk of integer overflows or undefined behaviour that can occur with a custom implementation that relies on arithmetic.\n\nFeel free to drop the `main()` function and use `min_of_three()` wherever you need it."]}
{"name": "HumanEval_161_solve", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_161_solve.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = solve;\n    assert(candidate((\"AsDf\")) == (\"aSdF\"));\n    assert(candidate((\"1234\")) == (\"4321\"));\n    assert(candidate((\"ab\")) == (\"AB\"));\n    assert(candidate((\"#a@C\")) == (\"#A@c\"));\n    assert(candidate((\"#AsdfW^45\")) == (\"#aSDFw^45\"));\n    assert(candidate((\"#6@2\")) == (\"2@6#\"));\n    assert(candidate((\"#$a^D\")) == (\"#$A^d\"));\n    assert(candidate((\"#ccc\")) == (\"#CCC\"));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a compact implementation that follows the rules described in the prompt:\n\n```cpp\n#include <string>\n#include <cctype>   // for std::isalpha, std::islower, std::isupper, std::toupper, std::tolower\n#include <algorithm> // for std::reverse\n\nstd::string solve(std::string s)\n{\n    // Determine whether the string contains any alphabetic character\n    bool has_letter = false;\n    for (char c : s)\n    {\n        if (std::isalpha(static_cast<unsigned char>(c)))\n        {\n            has_letter = true;\n            break;\n        }\n    }\n\n    if (has_letter)\n    {\n        // Toggle case for every alphabetic character; keep all other\n        // characters unchanged.\n        for (char& c : s)      // by reference so we modify in place\n        {\n            if (std::islower(static_cast<unsigned char>(c)))\n                c = std::toupper(static_cast<unsigned char>(c));\n            else if (std::isupper(static_cast<unsigned char>(c)))\n                c = std::tolower(static_cast<unsigned char>(c));\n        }\n        return s;\n    }\n    else\n    {\n        // No letters \u2013 just reverse the entire string.\n        std::reverse(s.begin(), s.end());\n        return s;\n    }\n}\n```\n\n### Why it works\n\n| Step | What\u2019s happening | Reason |\n|------|------------------|--------|\n| `has_letter` | Scan the input for `std::isalpha` | Determines whether to apply case\u2011toggling or reversal |\n| If `has_letter` | Loop over every character; toggle case when the character is alphabetic | `islower` \u2192 `toupper`; `isupper` \u2192 `tolower`; other characters are untouched |\n| Else | Reverse the string with `std::reverse` | Meets the \u201cno letters \u2192 reverse\u201d rule |\n\nThis function has `O(n)` time complexity and uses `O(1)` additional space (in\u2011place modification except for the reverse step). It conforms to the examples given: `\"1234\"` \u2192 `\"4321\"`, `\"ab\"` \u2192 `\"AB\"`, and `\"#a@C\"` \u2192 `\"#A@c\"`.", "Here is a complete, self\u2011contained implementation of the function described in the comments.  \nIt follows the rules:\n\n1. If the string contains at least one alphabetic character, flip every letter\u2019s case.\n2. If the string contains **no** alphabetic characters, reverse the whole string.\n3. All other characters (digits, punctuation, etc.) are left unchanged.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetter = false;\n    for (char c : s) {\n        if (isalpha(static_cast<unsigned char>(c))) {\n            hasLetter = true;\n            break;\n        }\n    }\n\n    if (hasLetter) {                    // flip case of every letter\n        for (char &c : s) {\n            if (islower(static_cast<unsigned char>(c)))\n                c = toupper(static_cast<unsigned char>(c));\n            else if (isupper(static_cast<unsigned char>(c)))\n                c = tolower(static_cast<unsigned char>(c));\n        }\n        return s;\n    } else {                            // no letters \u2013 reverse string\n        reverse(s.begin(), s.end());\n        return s;\n    }\n}\n```\n\n### Explanation\n\n* **Alphabet detection** \u2013 a single pass (`isalpha`) determines if there is at least one letter.  \n* **Case flipping** \u2013 another pass makes the change; `tolower`/`toupper` are used only if the character is already a letter.  \n* **Reversing** \u2013 the standard `<algorithm>` `reverse` function is used when no letters are present.\n\nThe function runs in `O(n)` time, where `n` is the length of the input string, and uses `O(1)` extra space (apart from the returned string).", "```cpp\n#include <string>\n#include <cctype>\n\nstd::string solve(std::string s) {\n    bool hasLetter = false;\n    // Check whether the string contains any alphabetic character\n    for (char c : s) {\n        if (std::isalpha(static_cast<unsigned char>(c))) {\n            hasLetter = true;\n            break;\n        }\n    }\n\n    if (hasLetter) {\n        // If there is at least one letter \u2013 flip its case\n        for (char &c : s) {\n            if (std::islower(static_cast<unsigned char>(c))) {\n                c = std::toupper(static_cast<unsigned char>(c));\n            } else if (std::isupper(static_cast<unsigned char>(c))) {\n                c = std::tolower(static_cast<unsigned char>(c));\n            }\n        }\n    } else {\n        // Otherwise reverse the whole string\n        std::reverse(s.begin(), s.end());\n    }\n\n    return s;\n}\n```"]}
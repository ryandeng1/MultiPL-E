{"name": "HumanEval_23_strlen", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_23_strlen.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = string_length;\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"x\")) == (1));\n    assert(candidate((\"asdasnakj\")) == (9));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a minimal, self\u2011contained implementation that follows the behaviour you described:\n\n```cpp\n#include <bits/stdc++.h>      // brings in <string> and many other headers\nusing namespace std;\n\n// Return the length of a string, in the same style as the Python examples\nlong string_length(const string &s) {\n    return static_cast<long>(s.size());   // size() is unsigned \u2192 cast to long\n}\n\n// Simple test harness (optional)\nint main() {\n    assert(string_length(\"\") == 0);\n    assert(string_length(\"abc\") == 3);\n\n    cout << \"All tests passed.\\n\";\n    return 0;\n}\n```\n\n**Explanation**\n\n* `string_length` takes its argument by `const &` to avoid an unnecessary copy.  \n* `std::string::size()` returns `std::size_type` (an unsigned integer).  \n* For the return type `long` we cast explicitly, which keeps the function signature consistent with the examples you provided.  \n\nYou can drop the `main()` section if you are only interested in the function itself.", "Here is a minimal, complete implementation of a `string_length` helper that returns the length of a `std::string`.  \nI\u2019ve kept the surrounding comment because it mirrors the documentation style you already started with.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/**\n * Return length of given string\n *\n * >>> string_length(\"\")   // 0\n * >>> string_length(\"abc\") // 3\n */\nlong string_length(const string& s) {\n    return static_cast<long>(s.size());\n}\n```\n\n**Notes**\n\n* The function takes the string *by const reference* to avoid copying large strings.\n* `std::string::size()` returns a `size_t`; it\u2019s cast to `long` to match your original prototype. If you prefer 64\u2011bit safety, simply return `size_t` instead of `long`.", "Here\u2019s a minimal, clean and well\u2011documented implementation that fits the spirit of the example comments you gave:\n\n```cpp\n#include <string>\n\n/**\n * @brief Return the length of the supplied string.\n *\n * The function follows the same semantics as the excerpts in the comment block:\n *   string_length(\"\")   \u2192 0\n *   string_length(\"abc\") \u2192 3\n *\n * @param str The input string.\n * @return std::size_t The length of the string in characters.\n */\nstd::size_t string_length(const std::string& str) noexcept {\n    return str.size();\n}\n```\n\n### Why this implementation?\n\n| Requirement | Reasoning |\n|-------------|-----------|\n| Use only the standard library | `<bits/stdc++.h>` is non\u2011portable and unnecessary. |\n| Provide clear documentation | Helps future readers understand purpose and usage. |\n| Return a size that matches the comments | `std::size_t` is the natural type for string lengths. |\n| Ensure no side\u2011effects and const\u2011correct | The function accepts a `const` reference and is `noexcept`. |\n\n#### Example usage\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << \"Length of \\\"\\\" is \" << string_length(\"\") << '\\n';\n    std::cout << \"Length of \\\"abc\\\" is \" << string_length(\"abc\") << '\\n';\n}\n```\n\nOutput:\n\n```\nLength of \"\" is 0\nLength of \"abc\" is 3\n```\n\nFeel free to drop the `noexcept` qualifier if you prefer, though it accurately reflects the guarantee that `std::string::size()` cannot throw."]}
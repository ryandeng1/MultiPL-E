{"name": "mbpp_460_Extract", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to get the first element of each subvector.\nstd::vector<long> Extract(std::vector<std::vector<long>> lst) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_460_Extract.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = Extract;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)3, (long)4, (long)5}), (std::vector<long>)std::vector<long>({(long)6, (long)7, (long)8, (long)9})}))) == (std::vector<long>({(long)1, (long)3, (long)6})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5})}))) == (std::vector<long>({(long)1, (long)4})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)9, (long)8, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2})}))) == (std::vector<long>({(long)9, (long)1})));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here is a compact, self\u2011contained C++17 implementation that pulls the first element out of each inner vector:\n\n```cpp\n#include <vector>\n#include <cassert>\n\n/*  Extract\n    -----------------\n     Return a vector containing the first element of each sub\u2011vector in\n     the input list.  If an inner vector is empty the function does **not**\n     insert anything for that position (you can change the behaviour to\n     throw or insert a sentinel value if you prefer).\n\n    Parameters\n    ----------\n    lst : std::vector<std::vector<long>>\n          The list of sub\u2011vectors to process.\n\n    Returns\n    -------\n    std::vector<long>\n          A new vector that holds the first element of every non\u2011empty\n          sub\u2011vector in the order they appear.\n*/\nstd::vector<long> Extract(const std::vector<std::vector<long>>& lst)\n{\n    std::vector<long> result;\n    result.reserve(lst.size());          // avoid repeated allocations\n\n    for (const auto& sub : lst) {\n        if (!sub.empty()) {              // ignore empty sub\u2011vectors\n            result.push_back(sub.front());\n        }\n    }\n    return result;\n}\n```\n\n### How it works\n* The function takes the outer vector **by const reference** \u2013 no copy is made.\n* For each inner vector it checks whether it is non\u2011empty.  \n  * If it is, it pushes the first element (`sub.front()`) into the result.\n  * If it is empty, it simply skips that element.  \n  (You can throw an exception instead if an empty inner vector should be an error.)\n* The final vector is returned.\n\n### Usage example\n\n```cpp\nint main()\n{\n    std::vector<std::vector<long>> data =\n    {\n        {10, 20, 30},\n        {40, 50},\n        {},              // will be ignored\n        {70}\n    };\n\n    std::vector<long> firsts = Extract(data);  // {10, 40, 70}\n\n    for(long v : firsts) { std::cout << v << ' '; }   // prints: 10 40 70\n}\n```\n\nFeel free to adjust the handling of empty sub\u2011vectors or add extra error checking as your application requires.", "Below is a minimal, self\u2011contained C++ implementation that does exactly what the prompt asks for:\n\n```cpp\n#include <vector>\n#include <iterator>\n#include <stdexcept>\n\n/*\n *  Extract the first element from each sub\u2011vector.\n *\n *  Arguments:\n *      lst   \u2013 a vector whose elements are themselves vectors of long.\n *               The sub\u2011vectors are expected to be non\u2011empty; if an empty\n *               sub\u2011vector is encountered the function throws std::invalid_argument.\n *\n *  Return:\n *      A vector containing the first element of each sub\u2011vector.\n *\n *  Example:\n *      std::vector<std::vector<long>> v = {{10,20},{30},{40,50,60}};\n *      auto res = Extract(v);          // res == {10, 30, 40}\n */\nstd::vector<long> Extract(const std::vector<std::vector<long>>& lst)\n{\n    std::vector<long> result;\n    result.reserve(lst.size());          // avoid excess reallocations\n\n    for(const auto& subVec : lst)\n    {\n        if(subVec.empty())\n            throw std::invalid_argument(\"Empty sub\u2011vector encountered\");\n\n        result.push_back(subVec.front());\n    }\n\n    return result;\n}\n\n/* ---------- Purely competitive\u2011style boilerplate (optional) ----------\n   The following main() function is for quick manual testing.\n---------------------------------------------------------------*/\n#ifdef EXTRACT_TEST\n#include <iostream>\n\nint main()\n{\n    std::vector<std::vector<long>> data = {{1,2,3},{4},{5,6}};\n    auto out = Extract(data);\n\n    for(long x : out)\n        std::cout << x << ' ';\n    std::cout << '\\n';\n\n    return 0;\n}\n#endif\n```\n\n### Why this version is useful\n\n* **Safety** \u2013 An exception (`std::invalid_argument`) is thrown if any sub\u2011vector is empty, preventing silent bugs.\n* **Efficiency** \u2013 `reserve` pre\u2011allocates the result vector to `lst.size()` elements, so no needless reallocations occur.\n* **Readability** \u2013 The algorithm is a simple `for\u2011each` loop over the outer vector, with `subVec.front()` taking the first element directly.\n* **Extensibility** \u2013 Because the function accepts `const std::vector<std::vector<long>>&`, you can easily substitute any other suitable container (e.g., `std::list<std::vector<long>>`) without changing the logic.\n\nFeel free to drop the `#ifdef EXTRACT_TEST` section or replace the `main()` with your own test harness.", "Below is a compact, self\u2011contained C++ implementation that extracts the first element of every sub\u2011vector in a `std::vector<std::vector<long>>`.  \nThe function skips empty sub\u2011vectors \u2013 you can change this behavior (e.g. by inserting a sentinel value) if you prefer.\n\n```cpp\n#include <vector>\n#include <iostream>\n\n/*  Extract\n *  --------\n *  Given a vector of vectors, return a new vector that contains\n *  the first element of each inner vector.  \n *\n *  Example:\n *      { {10, 20}, {5, 6, 7}, {42} }   ->   {10, 5, 42}\n *\n *  If an inner vector is empty it is simply ignored.\n */\nstd::vector<long> Extract(const std::vector<std::vector<long>>& lst)\n{\n    std::vector<long> result;\n    result.reserve(lst.size());          // reserve space \u2013 most cases\n    for (const auto& sub : lst) {\n        if (!sub.empty()) {\n            result.push_back(sub[0]);    // first element\n        }\n    }\n    return result;\n}\n\n/*  Helper: pretty\u2011print a std::vector<long>  */\nvoid Print(const std::vector<long>& v)\n{\n    std::cout << \"{ \";\n    for (long x : v) std::cout << x << ' ';\n    std::cout << \"}\\n\";\n}\n\n/*  Demo  */\nint main()\n{\n    std::vector<std::vector<long>> data{\n        {10, 20, 30},\n        {5, 6},\n        {},                 // empty \u2013 will be skipped\n        {42}\n    };\n\n    auto firstElems = Extract(data);\n    Print(firstElems);   // \u2192 { 10 5 42 }\n}\n```\n\n### What this code does  \n1. **Iterates** over each sub\u2011vector in the input.  \n2. **Checks** that the sub\u2011vector is not empty (`!sub.empty()`).  \n3. **Pushes** the first element (`sub[0]`) into the result vector.  \n4. Returns the collected first\u2011elements vector.\n\nFeel free to adapt the error handling or the way empty sub\u2011vectors are treated according to your needs."]}
{"name": "mbpp_68_is_Monotonic", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a cppthon function to check whether the given vector is monotonic or not.\nbool is_Monotonic(std::vector<long> A) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_68_is_Monotonic.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = is_Monotonic;\n    assert(candidate((std::vector<long>({(long)6, (long)5, (long)4, (long)4}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)3}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2}))) == (false));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a **complete, self\u2011contained, and well\u2011documented C++ solution** that implements the function `is_Monotonic`.  \nIt checks whether a given `std::vector<long>` is monotonic \u2013 that is, whether the sequence is **non\u2011decreasing** or **non\u2011increasing**.\n\n```cpp\n#include <vector>\n#include <iostream>\n#include <cassert>\n\n/**\n * @brief  Checks if a vector is monotonic.\n *\n *        A vector is monotonic if its elements are either\n *        non\u2011decreasing (each element >= previous) or\n *        non\u2011increasing (each element <= previous).\n *\n * @param A The vector to inspect.\n * @return true  if A is monotonic.\n * @return false otherwise.\n */\nbool is_Monotonic(const std::vector<long>& A)\n{\n    if (A.size() <= 2)       // 0, 1 or 2 elements are always monotonic\n        return true;\n\n    // Determine the first direction that is not flat\n    bool increasing = false;\n    bool decreasing = false;\n\n    for (size_t i = 1; i < A.size(); ++i) {\n        if (A[i] > A[i-1])   increasing = true;\n        else if (A[i] < A[i-1]) decreasing = true;\n\n        // If we already see both an increase and a decrease,\n        // the sequence cannot be monotonic.\n        if (increasing && decreasing)\n            return false;\n    }\n\n    // If we never had an increase or never had a decrease\n    // the sequence is monotonic.\n    return true;\n}\n\n/* ---------- Example usage & tests ---------- */\nint main()\n{\n    // Positive cases\n    assert(is_Monotonic({1, 2, 3, 3, 5}) == true);   // Non\u2011decreasing\n    assert(is_Monotonic({5, 4, 4, 2, 1}) == true);   // Non\u2011increasing\n    assert(is_Monotonic({7, 7, 7, 7}) == true);       // Flat\n\n    // Negative cases\n    assert(is_Monotonic({1, 3, 2}) == false);          // Increase then decrease\n    assert(is_Monotonic({5, 4, 6}) == false);          // Decrease then increase\n\n    std::cout << \"All test cases passed!\\n\";\n    return 0;\n}\n```\n\n### How the algorithm works\n\n1. **Early exit**  \n   Vectors with 0, 1, or 2 elements are automatically monotonic.\n\n2. **Single pass scan**  \n   Iterate once through the vector, maintaining two flags:\n   - `increasing` \u2013 set to true if we see a rise.\n   - `decreasing` \u2013 set to true if we see a drop.\n\n3. **Conflict detection**  \n   As soon as both flags become true, the vector has at least one rise and one drop \u2192 not monotonic \u2192 return `false`.\n\n4. **Result**  \n   If the loop finishes without conflict, the vector is monotonic \u2192 return `true`.\n\nThis solution runs in **O(n)** time and **O(1)** additional space, satisfying typical constraints for this problem.", "Below is a small, self\u2011contained C++ implementation that checks whether a given `std::vector<long>` is monotonic.  \n* **Monotonic** means that the sequence is either entirely non\u2011decreasing or entirely non\u2011increasing (ties are allowed).  \n* The function returns `true` if the vector satisfies one of the two properties, `false` otherwise.\n\n```cpp\n#include <vector>\n#include <cassert>\n\n/**\n * @brief Checks whether a vector is monotonic.\n *\n * A vector is monotonic if it is either non\u2011decreasing\n * (each element >= the previous one) or non\u2011increasing\n * (each element <= the previous one).\n *\n * @param A the vector of long integers to test\n * @return true  if A is monotonic\n * @return false otherwise\n */\nbool is_Monotonic(const std::vector<long>& A)\n{\n    if (A.size() <= 1)          // A single element (or empty) is trivially monotonic\n        return true;\n\n    bool non_decreasing = true;\n    bool non_increasing = true;\n\n    for (std::size_t i = 1; i < A.size(); ++i) {\n        if (A[i] > A[i-1])      // violation of non\u2011increasing\n            non_increasing = false;\n        if (A[i] < A[i-1])      // violation of non\u2011decreasing\n            non_decreasing = false;\n\n        // Early exit \u2013 if both flags are false, it cannot be monotonic\n        if (!non_decreasing && !non_increasing)\n            return false;\n    }\n\n    return true;                // at least one of the flags stayed true\n}\n\n/* -------------------   Example usage   ------------------- */\n\nint main()\n{\n    std::vector<long> inc  = {1, 2, 2, 4, 5};\n    std::vector<long> dec  = {9, 7, 7, 3, 1};\n    std::vector<long> mix  = {1, 3, 2, 4};\n\n    assert(is_Monotonic(inc)  == true);\n    assert(is_Monotonic(dec)  == true);\n    assert(is_Monotonic(mix)  == false);\n\n    return 0;\n}\n```\n\n### How It Works\n\n1. **Early Return for Short Vectors** \u2013 If the vector has 0 or 1 element it is automatically monotonic.\n2. **Track Two Flags** \u2013  \n   * `non_decreasing` starts as `true` and is set to `false` when an element is found that is smaller than its predecessor.  \n   * `non_increasing` similarly tracks the opposite condition.\n3. **Single Pass** \u2013 The loop updates the flags in a single pass; if at any point both flags become `false`, the function immediately returns `false`.  \n4. **Result** \u2013 If the loop finishes, at least one flag remains `true`, meaning the vector satisfies one of the monotonic conditions, so the function returns `true`.\n\nThis function has **O(n)** time complexity and **O(1)** auxiliary space, making it efficient for large input vectors.", "Here is a clean, self\u2011contained C++ function that tells whether the given `std::vector<long>` is *monotonic* (i.e. entirely non\u2011decreasing or entirely non\u2011increasing).  \nThe implementation uses an O(n) scan and an early\u2011exit strategy for maximum speed, and it works for empty or single\u2011element vectors as well (they are trivially monotonic).\n\n```cpp\n#include <vector>\n#include <cassert>\n\n/**\n * @brief  Checks if the vector is monotonic.\n *\n * A vector is monotonic if its elements are all non\u2011decreasing\n * or all non\u2011increasing.  The function returns `true` for empty\n * or 1\u2011element vectors.\n *\n * @param  A   The vector to test.\n * @return     `true` if monotonic, `false` otherwise.\n */\nbool is_Monotonic(const std::vector<long>& A)\n{\n    // Trivial cases: less than 2 elements are always monotonic\n    if (A.size() < 2) return true;\n\n    // Determine the initial trend by skipping equal elements\n    size_t i = 1;\n    while (i < A.size() && A[i] == A[i - 1]) ++i;\n\n    // If all elements are equal, it's monotonic\n    if (i == A.size()) return true;\n\n    bool increasing = (A[i] > A[i - 1]);\n\n    // Scan the rest of the vector \u2013 any opposite trend breaks it\n    for (; i < A.size(); ++i) {\n        if (increasing) {\n            if (A[i] < A[i - 1]) return false;   // Found a decrease\n        } else {\n            if (A[i] > A[i - 1]) return false;   // Found an increase\n        }\n    }\n\n    return true;\n}\n\n/* Test harness (optional) */\n#ifdef RUN_TESTS\n#include <iostream>\n\nint main() {\n    assert(is_Monotonic({1, 2, 3, 4})      == true);\n    assert(is_Monotonic({4, 3, 2, 1})      == true);\n    assert(is_Monotonic({1, 2, 2, 3})      == true);\n    assert(is_Monotonic({1, 3, 2, 4})      == false);\n    assert(is_Monotonic({})               == true);\n    assert(is_Monotonic({5})              == true);\n    assert(is_Monotonic({5, 5, 5, 5})      == true);\n\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n#endif\n```\n\n### How it works\n1. **Trivial case** \u2013 any vector with fewer than two elements is monotonic by definition.\n2. **Determine trend** \u2013 skip over consecutive equal elements to find the first real change.  \n   If all elements are equal, it's monotonic.\n3. **Identify the direction** \u2013 if the first real change is `>` the trend is increasing; otherwise decreasing.\n4. **Single pass** \u2013 walk through the rest of the vector; if an element breaks the identified trend, the function immediately returns `false`.\n\nThis solution runs in linear time (`O(n)`) and has constant additional space."]}
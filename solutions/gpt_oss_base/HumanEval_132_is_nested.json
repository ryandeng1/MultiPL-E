{"name": "HumanEval_132_is_nested", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n", "doctests": "transform", "original": "/work/arjunguha-research-group/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_132_is_nested.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n", "stop_tokens": ["\n}"], "completions": ["Below is a straight\u2011forward C++ implementation that follows the specification you described.  \nThe function `is_nested` returns `true` **iff** there exists a subsequence of the input string that\n\n* consists only of the two bracket characters `[` and `]`,\n* forms a syntactically correct sequence (every `[` can be matched with a later `]`), and\n* contains at least one pair that is *nested* \u2013 i.e. there is a `[` \u2026 `]` pair that completely surrounds another complete pair.\n\nThe implementation uses a triple\u2011nested loop (brute\u2011force) which is perfectly adequate for the very short input strings that appear in the examples. If you need to handle very long strings, a more efficient \\(O(n^2)\\) or \\(O(n)\\) approach can be replaced in the same place.\n\n```cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\n\n/*\n  Checks whether the input string (consisting only of '[' and ']')\n  contains a nested subsequence of brackets.\n\n  A nested subsequence must\n  - read as a correct bracket sequence (every '[' is matched by a later ']'),\n  - contain at least one pair that is inside another pair.\n*/\nbool is_nested(const std::string& s) {\n    int n = s.size();\n    // We need at least 4 characters to have two complete pairs,\n    // one of which is nested inside the other.\n    if (n < 4) return false;\n\n    // Collect indices of all '[' and all ']'\n    std::vector<int> open, close;\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == '[') open.push_back(i);\n        else if (s[i] == ']') close.push_back(i);\n    }\n\n    // Quick prune: need at least four brackets\n    if (open.size() < 2 || close.size() < 2) return false;\n\n    // Try every possible outer pair (i, j) with i from 'open' and j from 'close'\n    for (int i : open) {\n        for (int j : close) if (j > i) {     // outer pair must be open ... close\n            // Now look for a second pair (k, l) completely inside (i, j)\n            for (int k : open) {\n                if (k <= i) continue;        // must be strictly inside\n                for (int l : close) {\n                    if (l <= k || l >= j) continue; // l must be after k and before j\n                    // We have found an outer pair (i,j) and an inner pair (k,l)\n                    // They obviously form valid subsequences: [ ... [ ... ] ... ]\n                    // The outer pair encloses the inner pair, so nesting exists.\n                    return true;\n                }\n            }\n        }\n    }\n\n    // No nested pair found\n    return false;\n}\n\n/*****   Driver / tests   *****/\nint main() {\n    // Expected outputs match the examples in the problem statement\n    assert(is_nested(\"[[]]\") == true);\n    assert(is_nested(\"[]]]]]]][[[[[]\") == false);\n    assert(is_nested(\"[][]\") == false);\n    assert(is_nested(\"[]\") == false);\n    assert(is_nested(\"[[][]]\") == true);\n    assert(is_nested(\"[[]][[\") == true);\n\n    std::cout << \"All tests passed.\\n\";\n    return 0;\n}\n```\n\n### How it works\n\n1. **Pre\u2011processing** \u2013 Store the positions of every left and right bracket.\n2. **Brute\u2011force search** \u2013  \n   * Pick an outer `[`\u2011`]` pair.  \n   * Within this interval look for at least one inner `[`\u2011`]` pair that is completely inside the outer one.  \n   If such a pair is found, the answer is `true`.\n3. If no pair satisfies the condition after exhausting all possibilities, return `false`.\n\nThis direct strategy exactly captures the requirement: a subsequence that contains a pair nested inside another pair. The algorithm is simple, readable, and works correctly for the provided examples.", "**Solution Explanation**\n\nFor a nested subsequence we need a pair of brackets that fully contains\nanother pair \u2013 e.g. `[ [ ] ]` or `[ [ ] [ ] ]`.  \nIn terms of indices of the input string `s` this means that there must be\n\n```\ni < j < k < l\ns[i] = '['\ns[j] = '['         // the inner left bracket\ns[k] = ']'         // the inner right bracket\ns[l] = ']'         // the outer most right bracket\n```\n\nIf such indices exist we can form the subsequence\n\n```\ns[i], s[j], s[k], s[l]   \u2192   [[ ]]\n```\n\nand the answer is *true*.  \nOtherwise no nested subsequence can exist, so the answer is *false*.\n\nThe problem guarantees that the input contains only square brackets, so we\ndo not need to verify any other characters.\n\n--------------------------------------------------------------------\n\n#### Algorithm\n```\nfor i = 0 .. n-1\n    if s[i] == '['\n        for j = i+1 .. n-1\n            if s[j] == '['\n                for k = j+1 .. n-1\n                    if s[k] == ']'\n                        for l = k+1 .. n-1\n                            if s[l] == ']'\n                                return true\nreturn false\n```\n\nThe nested loops check all 4\u2011tuples of indices that respect the ordering\n`i<j<k<l`.  \nAs soon as one valid quadruple is found we can immediately return `true`.\n\n--------------------------------------------------------------------\n\n#### Correctness Proof  \n\nWe prove that the algorithm returns the correct answer.\n\n---\n\n##### Lemma 1  \nIf the algorithm returns `true`, then the input string contains a valid\nnested subsequence.\n\n**Proof.**  \nThe algorithm returns `true` only after it has found indices  \n`i<j<k<l` with `s[i]='['`, `s[j]='['`,\n` s[k]=']'`, `s[l]=']'`.  \nThe subsequence formed by these four positions is `[[ ]]`,\nwhich is a balanced bracket sequence with a pair nested inside another pair.\nHence a valid nested subsequence exists. \u220e\n\n\n\n##### Lemma 2  \nIf the input string contains a valid nested subsequence,\nthe algorithm will eventually return `true`.\n\n**Proof.**  \nLet a nested subsequence exist.  \nThen there are indices `p<q<r<s` with  \n\n```\ns[p] = '['\ns[q] = '['\ns[r] = ']'\ns[s] = ']'\n```\n\nindicating the outer left bracket, inner left bracket, inner right bracket\nand outer right bracket respectively.\nDuring the execution of the algorithm the outermost loop will consider `i = p`.\nThe second loop will then consider `j = q`, the third `k = r` and the fourth\n`l = s`. All four characters match the required ones, so the algorithm\nreturns `true`. \u220e\n\n\n\n##### Theorem  \nThe algorithm returns `true` **iff** the input string contains a valid\nnested subsequence.\n\n**Proof.**  \n*If* part follows from Lemma&nbsp;1.  \n*Only if* part follows from Lemma&nbsp;2.  \nTherefore the returned value is exactly the desired result. \u220e\n\n\n\n--------------------------------------------------------------------\n\n#### Complexity Analysis  \n\nLet `n` be the length of the input string.\n\nThe algorithm uses four nested loops.\nIn the worst case all loops run up to `n` times:\n\n```\nT(n) = O(n^4)\n```\n\nSince `n` is small in typical use (a few dozen characters), this is\nperfectly acceptable.  \nMemory consumption is `O(1)`.\n\n--------------------------------------------------------------------\n\n#### Reference Implementation  (C++17)\n\n```cpp\n#include <string>\n\n/*  Returns true iff the string contains a valid nested subsequence\n *  of square brackets.\n */\nbool is_nested(std::string s) {\n    const int n = static_cast<int>(s.size());\n\n    for (int i = 0; i < n; ++i)\n        if (s[i] == '[')\n            for (int j = i + 1; j < n; ++j)\n                if (s[j] == '[')\n                    for (int k = j + 1; k < n; ++k)\n                        if (s[k] == ']')\n                            for (int l = k + 1; l < n; ++l)\n                                if (s[l] == ']')\n                                    return true;   // found a nested pair\n\n    return false;   // no such quadruple exists\n}\n\n/*  Example usage\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << is_nested(\"[[]]\") << '\\n';          // true\n    std::cout << is_nested(\"[]]]]]]][[[[[]\") << '\\n'; // false\n    std::cout << is_nested(\"[][]\") << '\\n';           // false\n    std::cout << is_nested(\"[]\") << '\\n';             // false\n    std::cout << is_nested(\"[[][]]\") << '\\n';         // true\n    std::cout << is_nested(\"[[]][[\") << '\\n';         // true\n}\n*/\n```\n\nThe code follows exactly the algorithm proven correct above and\nconforms to the C++17 standard.", "**Solution Explanation**\n\nFor every opening bracket \u2018[\u2019 we push its position on a stack.\nWhen a closing bracket \u2018]\u2019 is found we pop the most recent opening bracket.\n\n* If the popped bracket is **not the immediate previous one** in the original string  \n  (i.e. there exists another opening bracket between them), we have found a\n  nested pair.\n\n`is_nested` returns **true** as soon as such a situation occurs, otherwise **false**.\n\nThe algorithm runs in linear time `O(n)` and uses `O(n)` additional space for the stack.\n\n```cpp\n#include <iostream>\n#include <stack>\n#include <string>\n\n/*  Returns true iff there is a subsequence of brackets that is\n    properly matched and contains a nested pair.            */\nbool is_nested(const std::string& s) {\n    std::stack<int> st;          // positions of unclosed '['\n\n    for (size_t i = 0; i < s.size(); ++i) {\n        char c = s[i];\n        if (c == '[') {\n            st.push(i);\n        } else if (c == ']') {\n            if (st.empty())          // mismatched closing\n                continue;\n            int open_pos = st.top();\n            st.pop();\n\n            /* If the closing bracket is not the next character\n               after the corresponding opening bracket, then a '['\n               must be nested inside this pair. */\n            if (i > open_pos + 1) {\n                return true;        // found nested pair\n            }\n        }\n    }\n    return false;   // no nested pair found\n}\n\n/* ------------------  optional test harness  ------------------ */\n\nint main() {\n    std::string tests[] = {\n        \"[[]]\",\n        \"[]]]]]]][[[[[]\",\n        \"[][]\",\n        \"[]\",\n        \"[[][]]\",\n        \"[[]][[\"\n    };\n    bool expected[] = {true, false, false, false, true, true};\n\n    for (size_t i = 0; i < sizeof(tests)/sizeof(*tests); ++i) {\n        bool ans = is_nested(tests[i]);\n        std::cout << \"is_nested(\\\"\" << tests[i] << \"\\\") = \"\n                  << (ans ? \"true\" : \"false\")\n                  << \"  (expected: \" << (expected[i] ? \"true\" : \"false\") << \")\\n\";\n    }\n    return 0;\n}\n```\n\n**Explanation of the core part**\n\n```cpp\nint open_pos = st.top();   // index of matching '['\n...\nif (i > open_pos + 1) {\n    // there is at least one character between '[' and ']'\n    // that character must be a '[' (otherwise the string would be invalid).\n    return true;\n}\n```\n\nIf the closing bracket is immediately after its matching opening bracket (`i == open_pos + 1`), the pair is *not nested* (simple \u201c[]\u201d).  \nIf there is any character in between, the only legal character is `'['`, so the pair is nested. The function stops at the first such hit because only the existence of **any** nested subsequence is required."]}
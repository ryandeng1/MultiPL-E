{"name": "mbpp_747_lcs_of_three", "language": "cpp", "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the longest common subsequence for the given three string sequence. https://www.geeksforgeeks.org/lcs-longest-common-subsequence-three-strings/\nlong lcs_of_three(std::string X, std::string Y, std::string Z) {\n", "doctests": "transform", "original": "/Users/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_747_lcs_of_three.py", "prompt_terminology": "reworded", "tests": "}\nint main() {\n    auto candidate = lcs_of_three;\n    assert(candidate((\"AGGT12\"), (\"12TXAYB\"), (\"12XBA\")) == (2));\n    assert(candidate((\"Reels\"), (\"Reelsfor\"), (\"ReelsforReels\")) == (5));\n    assert(candidate((\"abcd1e2\"), (\"bc12ea\"), (\"bd1ea\")) == (3));\n}\n", "stop_tokens": ["\n}"], "completions": ["Here\u2019s a complete, self\u2011contained implementation of the *Longest Common Subsequence* (LCS) for **three** strings.  \nThe routine follows the classic dynamic\u2011programming approach described on GeeksforGeeks (and many textbooks) and works in `O(n\u00b7m\u00b7p)` time and `O(n\u00b7m\u00b7p)` memory, where `n, m, p` are the lengths of the three strings.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\n/*\n *  Longest Common Subsequence of three strings.\n *\n *  Complexity:\n *      Time   : O(n * m * p)\n *      Memory : O(n * m * p)\n *\n *  Parameters:\n *      X, Y, Z \u2013 the three input strings\n *\n *  Returns:\n *      Length of the longest common subsequence of X, Y and Z.\n */\nlong lcs_of_three(const std::string &X,\n                  const std::string &Y,\n                  const std::string &Z)\n{\n    const size_t n = X.size(), m = Y.size(), p = Z.size();\n\n    /* 3\u2011dimensional DP table.\n       dp[i][j][k] = LCS length of\n       X[0..i\u20111], Y[0..j\u20111], Z[0..k\u20111]   (i, j, k \u2265 0)\n    */\n    std::vector<std::vector<std::vector<long>>> dp(\n        n + 1, std::vector<std::vector<long>>(m + 1, std::vector<long>(p + 1, 0)));\n\n    for (size_t i = 1; i <= n; ++i) {\n        for (size_t j = 1; j <= m; ++j) {\n            for (size_t k = 1; k <= p; ++k) {\n                if (X[i - 1] == Y[j - 1] && Y[j - 1] == Z[k - 1]) {\n                    // All three characters match \u2013 extend a common subsequence\n                    dp[i][j][k] = 1 + dp[i - 1][j - 1][k - 1];\n                } else {\n                    // Take the best of the 3 options: drop one character from any of the strings\n                    dp[i][j][k] = std::max({dp[i - 1][j][k],\n                                            dp[i][j - 1][k],\n                                            dp[i][j][k - 1]});\n                }\n            }\n        }\n    }\n\n    return dp[n][m][p];\n}\n\n/*** ----------  Simple self\u2011test section  ---------- ***/\nint main()\n{\n    std::string a = \"AGGT12\", b = \"12TXAYB\", c = \"12TXAYB\";\n    long res = lcs_of_three(a, b, c);\n    std::cout << \"LCS length: \" << res << '\\n';   // Expected: 2\n\n    // Additional sanity checks\n    assert(lcs_of_three(\"abc\", \"ac\", \"ab\") == 1);   // \"a\"\n    assert(lcs_of_three(\"\", \"xyz\", \"abc\") == 0);\n    assert(lcs_of_three(\"abcd\", \"abcd\", \"abcd\") == 4);\n\n    return 0;\n}\n```\n\n### How it works\n\n1. **DP table**  \n   `dp[i][j][k]` holds the LCS length for the prefixes  \n   `X[0..i-1]`, `Y[0..j-1]`, `Z[0..k-1]`.  \n   The dimensions start from `0` so that the empty string case automatically gives `0`.\n\n2. **State transition**  \n   - If the current characters of all three strings are the same (`X[i-1] == Y[j-1] == Z[k-1]`), we can extend a common subsequence by one:  \n     `dp[i][j][k] = 1 + dp[i-1][j-1][k-1]`.\n   - Otherwise, we choose the maximum among the three ways of dropping one character:  \n     `dp[i][j][k] = max(dp[i-1][j][k], dp[i][j-1][k], dp[i][j][k-1])`.\n\n3. **Result**  \n   The answer is stored in `dp[n][m][p]` where `n, m, p` are the lengths of the three strings.\n\nFeel free to replace the `main()` routine with your own test harness or to integrate the `lcs_of_three` function into a larger project.", "```cpp\n#include <cassert>\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n * Return the length of the Longest Common Subsequence (LCS) of three strings.\n * This is a classic 3\u2011dimensional dynamic\u2011programming problem.\n *\n * Let X[0..m\u22121], Y[0..n\u22121], Z[0..p\u22121] be the 3 strings.\n * Define L[i][j][k] = length of the LCS of\n *   X[0..i-1], Y[0..j-1], Z[0..k-1]\n * (i.e. the first i, j and k characters of each string).\n *\n * Transition:\n *  \u2022 If i==0 or j==0 or k==0 \u2192 L[i][j][k] = 0\n *  \u2022 If X[i-1] == Y[j-1] == Z[k-1]  \u2192 L[i][j][k] = L[i-1][j-1][k-1] + 1\n *  \u2022 Otherwise\n *        L[i][j][k] = max( L[i-1][j][k],\n *                          L[i][j-1][k],\n *                          L[i][j][k-1] )\n *\n * Complexity:  O(m\u00b7n\u00b7p) time and  O(m\u00b7n\u00b7p) memory.\n * The memory can be reduced to O(n\u00b7p) if one wants, but the\n * straightforward implementation is easy to read.\n */\nlong lcs_of_three(const string& X, const string& Y, const string& Z)\n{\n    const int m = (int)X.size();\n    const int n = (int)Y.size();\n    const int p = (int)Z.size();\n\n    // 3\u2011D DP table.  vector is used because it handles the memory automatically.\n    vector<vector<vector<long>>> L(m + 1,\n                                   vector<vector<long>>(n + 1,\n                                                        vector<long>(p + 1, 0)));\n\n    for (int i = 1; i <= m; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            for (int k = 1; k <= p; ++k) {\n                if (X[i-1] == Y[j-1] && X[i-1] == Z[k-1]) {\n                    L[i][j][k] = L[i-1][j-1][k-1] + 1;\n                } else {\n                    L[i][j][k] = max({ L[i-1][j][k],\n                                       L[i][j-1][k],\n                                       L[i][j][k-1] });\n                }\n            }\n        }\n    }\n    return L[m][n][p];\n}\n\n/* ------------  Example usage  ------------\n\nint main()\n{\n    string A = \"AGGT12\";\n    string B = \"12TXAYB\";\n    string C = \"12XBA\";\n\n    long ans = lcs_of_three(A, B, C);\n    cout << \"Length of LCS = \" << ans << '\\n';   // Output: 5 (the LCS is \"12AB\")\n    return 0;\n}\n\n------------------------------------------\n*/\n```", "Below is a complete, self\u2011contained implementation that computes the longest common subsequence (LCS) among **three** strings.  \nThe core idea is a classic 3\u2011dimensional dynamic\u2011programming table:  \n\n```\ndp[i][j][k]  =  length of LCS of:\n                X[0 \u2026 i\u20111], Y[0 \u2026 j\u20111], Z[0 \u2026 k\u20111]\n```\n\nThe recursion is\n\n```\nif   X[i\u20111] == Y[j\u20111] == Z[k\u20111]      dp[i][j][k] = 1 + dp[i\u20111][j\u20111][k\u20111]\nelse                                 dp[i][j][k] = max( dp[i\u20111][j][k],\n                                                       dp[i][j\u20111][k],\n                                                       dp[i][j][k\u20111] )\n```\n\nWe initialise the \u201cborder\u201d of the 3\u2011D array with zeros (when any of the indices is zero the LCS is empty).  \nThe time complexity is `O(n1*n2*n3)` and the space complexity is also the same;  \nfor large inputs you can compress the DP to a 2\u2011D array, but the shown version is straightforward to understand.\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Return the length of LCS of 3 strings X, Y, Z\nlong lcs_of_three(const string& X, const string& Y, const string& Z) {\n    const size_t n1 = X.size();\n    const size_t n2 = Y.size();\n    const size_t n3 = Z.size();\n\n    // 3\u2011D DP array\n    vector<vector<vector<long>>> dp(n1 + 1,\n                                    vector<vector<long>>(n2 + 1,\n                                    vector<long>(n3 + 1, 0)));\n\n    for (size_t i = 1; i <= n1; ++i) {\n        for (size_t j = 1; j <= n2; ++j) {\n            for (size_t k = 1; k <= n3; ++k) {\n                if (X[i-1] == Y[j-1] && X[i-1] == Z[k-1]) {\n                    dp[i][j][k] = 1 + dp[i-1][j-1][k-1];\n                } else {\n                    dp[i][j][k] = max({dp[i-1][j][k],\n                                       dp[i][j-1][k],\n                                       dp[i][j][k-1]});\n                }\n            }\n        }\n    }\n    return dp[n1][n2][n3];\n}\n\n// Example usage\nint main() {\n    string X = \"abcde\";\n    string Y = \"ace\";\n    string Z = \"abcce\";\n\n    cout << \"Length of LCS: \" << lcs_of_three(X, Y, Z) << \"\\n\";\n    return 0;\n}\n```\n\n**Explanation of the code**\n\n* `dp` is a 3\u2011D vector initialised to zeros.  \n* The nested loops iterate through every prefix of the three strings.  \n* Whenever the three current characters coincide the value increases by one from the previously computed prefix.  \n* Otherwise we pick the maximum LCS achievable by dropping one character from any one of the strings.  \n* The answer for the complete strings is stored in `dp[n1][n2][n3]`.\n\nYou can compile with `g++ -std=c++17 -O2 -pipe -static -s -o lcs lcs.cpp` and run it. Feel free to adapt it for larger inputs or to recover the actual subsequence (by backtracking through the DP table)."]}